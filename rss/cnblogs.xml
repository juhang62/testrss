<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>免费试用谷歌的翻译接口 - 奔跑的Man</title>
<link>http://www.cnblogs.com/iforever/p/10852406.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iforever/p/10852406.html</guid>
<description>&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;最近做个东西，需将各种语言翻译成中文，看了各家的翻译效果，还是谷歌的最好。&lt;/p&gt;
&lt;p&gt;但谷歌的未提供免费接口，研究了谷歌的&lt;a href=&quot;https://translate.google.cn/&quot;&gt;翻译页面&lt;/a&gt;，输入内容后会触发ajax请求，请求参数中除了输入内容，还有个加密参数&lt;code&gt;tk&lt;/code&gt;，该加密算法在压缩的js代码中，我也在网上找到了网友摘出来的代码，js格式，一大段，压缩代码翻译起来很吃力，遂未翻译，而另辟蹊径，在生产环境的docker中打包了node环境，业务代码通过shell调用这段js，得到加密参数后再模拟请求，获得翻译结果，用着还挺好。&lt;/p&gt;
&lt;p&gt;没过多久，发现失效了，请求返回403 Forbidden，禁止访问 🚫，估计加密参数算法又升级了。&lt;/p&gt;
&lt;p&gt;接口翻译固然好用，但隔断时间就要重新搞一次加密算法，这个就有点儿难以接受了，每次都要从大量压缩js代码中找出加密算法，还不一定能完全找对。&lt;/p&gt;
&lt;p&gt;至此，我们的主角无头浏览器&lt;a href=&quot;https://github.com/GoogleChrome/puppeteer&quot;&gt;puppeteer&lt;/a&gt;就要登场了，puppeteer一个node类库，提供了简洁的API，可以让使用者操作chrome浏览器，基本可以完全模拟人的操作，比如打开页面、输入网址、等待页面指定内容加载、点击按钮、甚至滑动也可以，有了这个工具模拟用户翻译然后获取结果完全没问题。&lt;/p&gt;
&lt;h2 id=&quot;获取翻译结果&quot;&gt;获取翻译结果&lt;/h2&gt;
&lt;h3 id=&quot;通过js获取&quot;&gt;通过js获取&lt;/h3&gt;
&lt;p&gt;分析了谷歌翻译页面的元素，发现用户输入内容的时候会触发某些按钮变灰，等到翻译完成，按钮会再次变亮，这其实是通过添加去除&lt;code&gt;*-disabled&lt;/code&gt;类来实现的，所以当我们模拟输入之后等待该类消失即可&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;await page.waitForSelector('selector-ele-disabled', {hidden: true});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;待元素变亮（去除了&lt;code&gt;*-disabled&lt;/code&gt;类），就可以从结果输入框中获取到结果了。&lt;/p&gt;
&lt;p&gt;但这样实现起来比较麻烦，也不够直接，还需要puppeteer调用chrome的js执行环境去获取，获取的也不是原始的接口返回数据。因此通过查阅文档找到了下面更好的方法👇。&lt;/p&gt;
&lt;h3 id=&quot;通过拦截请求返回获取&quot;&gt;通过拦截请求返回获取&lt;/h3&gt;
&lt;p&gt;前段时间研究了如何爬取手机app中的数据，里面用到了中间人代理攻击，中间人代理转发请求、返回，转发的时候就可以对请求进行拦截处理，我就想puppeteer应该也有，果然查到了&lt;a href=&quot;https://github.com/GoogleChrome/puppeteer/blob/v1.15.0/docs/api.md#event-response&quot;&gt;event-response&lt;/a&gt;，他是&lt;a href=&quot;https://github.com/GoogleChrome/puppeteer/blob/v1.15.0/docs/api.md#class-page&quot;&gt;Page&lt;/a&gt;实例的一个钩子，如果我们设置了&lt;code&gt;&quot;response&quot;: function callback(response){}&lt;/code&gt;，当chrome发出的任何一个请求返回的时候，都会触发他，并将类&lt;a href=&quot;https://github.com/GoogleChrome/puppeteer/blob/v1.15.0/docs/api.md#class-response&quot;&gt;Response&lt;/a&gt;的一个实例传给回调函数，里面包含请求url、请求结果、请求结果状态等信息，这样我们就可以检测我们的翻译接口了&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let browser = await puppeteer.launch()

let page = await browser.newPage()
page.on('response', async response =&amp;gt; {
    const url = response.url()

    if (url.indexOf(&quot;检测的接口地址&quot;) != -1) {
        let text = await response.text()
        // text就是接口返回的结果，拿到接口原始数据，接下来就任你处理了
    }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;设计&quot;&gt;设计&lt;/h2&gt;
&lt;p&gt;大体流程如下图所示，初始化实例，等待请求，请求到达之后模拟输入，然后返回结果，再次进入等待请求状态。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/675818/201905/675818-20190512152620652-87167377.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此文的最终目的是可以为调用者提供一个简洁的接口，请求该接口返回，返回为中文的结果，接口的响应时间尽可能的短，可支持并发。&lt;/p&gt;
&lt;p&gt;响应时间没多少可以优化的地方，主要依赖网络环境，以及谷歌的接口响应时间，我们只能做到当谷歌接口返回的时候我们也第一时间返回给调用者。&lt;/p&gt;
&lt;p&gt;并发这里可以做优化，一个puppeteer同一时间只能处理一个翻译请求，如果做个实例池，维护多个puppeteer实例，这样就可以提升翻译接口的并发能力了。&lt;/p&gt;
&lt;h3 id=&quot;实例池&quot;&gt;实例池&lt;/h3&gt;
&lt;p&gt;如下图所示，虚线框内表示一个实例池，实例池中有多个puppeteer实例，他们之间互相独立，当请求来的时候，随机从池子中拿出一个实例，处理请求，等待请求处理完毕之后，再次将改实例放回池子中。&lt;/p&gt;
&lt;p&gt;为了减少意外情况，池子中的每个实例处理100个翻译之后推出，重新启动一个新的额实例补充进来，池子中的实例总量保持不变，如果需要甚至可以搞成动态的，像php-fpm一样，请求多的时候动态增加实例池中的实例，空闲的时候，清理推出一些实例。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/675818/201905/675818-20190512152646921-803141589.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;如何将请求和结果联系起来&quot;&gt;如何将请求和结果联系起来&lt;/h3&gt;
&lt;p&gt;一个请求可以分为两个流程，一个&lt;code&gt;请求流程&lt;/code&gt;，一个&lt;code&gt;ajax成功回调流程&lt;/code&gt;，请求时候输入翻译原始内容，实例内部在请求谷歌ajax接口成功的时候调用预先注册好的回调函数，这两个流程没有办法直接联系起来，但他们都会接触到同一个实例，所以用这个实例将他们俩联系起来，ajax流程成功之后写入一个变量到实例对象上，请求流程中监测该实例上的变量，有数据说明请求成功，返回数据，清空该变量，原理可以看下面的简化代码&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let obj = {}
setTimeout(() =&amp;gt; {
    obj.result = &quot;this is async result&quot;
}, 2000)

async function sleep(duration) {
    return new Promise(resolve =&amp;gt; {
        setTimeout(() =&amp;gt; {
            resolve()
        }, duration)
    })
}

async function getRet() {
    let times = 1
    while(times &amp;lt;= 100) {
        if (obj.result) {
            return Promise.resolve(obj.result)
        } else {
            await sleep(200)
        }
        times++
    }
}

(async () =&amp;gt; {
    let ret = await getRet()
    console.log(ret)
    console.log(&quot;now i can do something&quot;)
})()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实现&quot;&gt;实现&lt;/h2&gt;
&lt;p&gt;我将这个功能包装成了一个类库，上传到了npm，&lt;a href=&quot;https://www.npmjs.com/package/google-trans-api&quot;&gt;google-trans-api&lt;/a&gt;，顺便也熟悉了整个打包流程以及typescript的使用，不得不说typescript真是不错，可以防止很多误写的错误，还有自动提示的功能，用起来不要太爽。这里是源码地址&lt;a href=&quot;https://github.com/aizuyan/google-trans-api&quot;&gt;aizuyan/google-trans-api&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;使用&quot;&gt;使用&lt;/h2&gt;
&lt;h3 id=&quot;下载chromium&quot;&gt;下载Chromium&lt;/h3&gt;
&lt;p&gt;linux、mac下面的Chromium是两个不同的包，如果网络可以FQ，直接部署安装即可，否则需要手动下载，&lt;a href=&quot;https://download-chromium.appspot.com/&quot;&gt;传送门&lt;/a&gt;，我的网络就不好，因此提前将两个版本的包放在项目根目录下的&lt;code&gt;Chromium&lt;/code&gt;目录下，开发环境使用&lt;code&gt;darwin&lt;/code&gt;目录下的包，生产环境使用linux下的包&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.
├── Chromium
│   ├── darwin
│   └── linux&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配合下面的代码，可以自动根据环境选择使用的包路径，并传入实例的&lt;code&gt;executablePath&lt;/code&gt;参数中&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;&quot;use strict&quot;
const path = require(&quot;path&quot;)
const os = require(&quot;os&quot;)

const platform = os.platform()

let ret = path.join(__dirname, &quot;..&quot;, &quot;Chromium&quot;, platform)

switch (platform) {
  case &quot;linux&quot;:
    ret = path.join(ret, &quot;chrome&quot;)
    break
  case &quot;darwin&quot;:
    ret = path.join(ret, &quot;Chromium.app/Contents/MacOS/Chromium&quot;)
    break
}

module.exports = ret&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;代理&quot;&gt;代理&lt;/h3&gt;
&lt;p&gt;如果网路不好，可能需要安装代理，可以使用shadowsocks，支持所有环境，默认没有代理，如果需要，可以在初始化的时候传入&lt;code&gt;proxyServer: '--proxy-server=socks5://127.0.0.1:1080'&lt;/code&gt;参数。&lt;/p&gt;
&lt;h3 id=&quot;完整的试用版本&quot;&gt;完整的试用版本&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;const koa = require('koa')
const app = new koa()
const router = require('koa-router')();
const GoogleTrans = require('google-trans-api').default
// 调用的时候改为你自己的
const chromePath = '/path/to/puppeteer Chromium';

(async () =&amp;gt; {
  let instance = new GoogleTrans({
    handles: false,
    worker:3,
    executablePath: chromePath,
    initPageTimeout: 0,
    //proxyServer: '--proxy-server=socks5://127.0.0.1:1080',
    regExpIncludeUrl: url =&amp;gt; {
      const reg = new RegExp(&quot;translate.google.cn/translate_a/single.*?q=.*&quot;)
      return reg.test(url)
    },
    responseCb: async response =&amp;gt; {
      const url = response.url()
      console.log(url)
      try {
        const text = await response.text()
        const status = response.status()

        let ret = JSON.parse(text)
        ret = ret[0]
        let data = &quot;&quot;
        for (let i = 0; i &amp;lt; ret.length; i++) {
          if (ret[i][0]) {
            data += ret[i][0]
          }
        }
        return Promise.resolve(data)
      } catch (err) {
        console.error(`Failed getting data from: ${url}`)
        console.error(err);
      }
    }
  })

  let flag = await instance.init()

  router.get('/trans-auto', async ctx =&amp;gt; {
    try {
      let msg = decodeURIComponent(ctx.query.msg)
      let ret = await instance.trans(msg)
      ctx.response.body = ret
    } catch (e) {
      console.log(`[error] when trans ${e.message}`)
      ctx.response.body = &quot;&quot;
    }
  })

  app
    .use(router.routes())
    .use(router.allowedMethods())

  app.listen(3000, () =&amp;gt; {
    console.log('server is running at http://localhost:3000')
  })
})()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是我打开GUI模式，看效果的图片&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/675818/201905/675818-20190512152702153-1619123688.gif&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 12 May 2019 07:28:00 +0000</pubDate>
<dc:creator>奔跑的Man</dc:creator>
<og:description>引言 最近做个东西，需将各种语言翻译成中文，看了各家的翻译效果，还是谷歌的最好。 但谷歌的未提供免费接口，研究了谷歌的 '翻译页面' ，输入内容后会触发ajax请求，请求参数中除了输入内容，还有个加密</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iforever/p/10852406.html</dc:identifier>
</item>
<item>
<title>Scrapy爬取新浪微博移动版用户首页第一条微博 - Berryguo</title>
<link>http://www.cnblogs.com/berryguotoshare/p/10852404.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/berryguotoshare/p/10852404.html</guid>
<description>&lt;p&gt;大家好，本月第一次更新。&lt;/p&gt;
&lt;p&gt;最近找了一份关于爬虫的实习工作，需要爬取较大量的数据，这时就发现通过自己编写函数来实现爬虫效率太慢了；于是又转回来用scrapy，以前稍微学习了一下，这次刚好爬爬微博练练手，而后再使用部分数据生成词云。&lt;/p&gt;
&lt;p&gt;本次爬取的是新浪微博移动端（&lt;a href=&quot;https://m.weibo.cn/&quot;&gt;https://m.weibo.cn/&lt;/a&gt;），爬取的数据是用户微博首页的第一条微博（如下图），包括文字内容、转发量、评论数、点赞数和发布时间，还有用户名和其所在地区（后面可以分析不同地区微博用户的关心的热点话题）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1526536/201905/1526536-20190512134841207-1931734979.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;一、分析网页&lt;/p&gt;
&lt;hr/&gt;
&lt;ul&gt;&lt;li&gt;获取用户微博入口url&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;浏览发现使用的是使用Ajax渲染的网页，微博数据（&lt;a href=&quot;https://m.weibo.cn/api/container/getIndex?containerid=102803_ctg1_5088_-_ctg1_5088&amp;amp;openApp=0&amp;amp;since_id=1&quot; target=&quot;_blank&quot;&gt;https://m.weibo.cn/api/container/getIndex?containerid=102803_ctg1_5088_-_ctg1_5088&amp;amp;openApp=0&amp;amp;since_id=1&lt;/a&gt;）存储在json格式网页中，所以思路是先通过微博数据得到用户url（如下图），再来爬取后续内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1526536/201905/1526536-20190512135235837-960830631.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; 获取第一条微博数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;也是使用了Ajax渲染的网页，跟上面一样找到网页入口就行了。请求网址如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1526536/201905/1526536-20190512140421870-821814354.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样看网址的话毫无规律可言，简化后发现 &lt;a href=&quot;https://m.weibo.cn/api/container/getIndex?containerid=1076032554757470&quot; target=&quot;_blank&quot;&gt;https://m.weibo.cn/api/container/getIndex?containerid=1076032554757470&lt;/a&gt;就可以进入。而且containerid=107603（***）这里，括号里的数字刚好是用户的id号，因此我们可以通过这个来构造网页。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;获取用户所在地区&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;用户所在地在其基本资料中，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1526536/201905/1526536-20190512141024483-1786729670.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;地址为：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1526536/201905/1526536-20190512141148302-149693704.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同样进行简化得到：&lt;span&gt;https://m.weibo.cn/api/container/getIndex?containerid=230283（***）_-_INFO&lt;/span&gt;&lt;span&gt;&lt;span&gt;其中括号里面是用户id号。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;通过以上分析可知，获取用户的 &lt;strong&gt;id&lt;/strong&gt; 号是本次爬取数据的关键，只需要用 &lt;strong&gt;id &lt;/strong&gt;构成网址，后面的爬取就相对简单了。下面是编程部分。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;二、编程爬取&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;注：转载代码请标明出处&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;ul&gt;&lt;li&gt;首先通过命令行创建 scrapy 爬虫。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;scrapy startproject sinaweibo

scrapy genspider xxx(爬虫名) xxx(所在域名)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;items.py定义爬虫字段&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; scrapy


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; SinaweiboItem(scrapy.Item):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; define the fields for your item here like:&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; name = scrapy.Field()&lt;/span&gt;
    name = scrapy.Field()       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;用户名&lt;/span&gt;
    first_news = scrapy.Field()     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;首条微博&lt;/span&gt;
    dates = scrapy.Field()     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;发布时间 &lt;/span&gt;
    zhuanzai = scrapy.Field()       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;转载数&lt;/span&gt;
    comment = scrapy.Field()        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;评论数&lt;/span&gt;
    agree = scrapy.Field()      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;点赞数&lt;/span&gt;
    city = scrapy.Field()       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;所在地区&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;编写爬取代码&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; scrapy
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sinaweibo.items &lt;span&gt;import&lt;/span&gt;&lt;span&gt; SinaweiboItem
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; copy
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WeibodiyuSpider(scrapy.Spider):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;weibodiyu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;爬虫名&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     allowed_domains = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;m.weibo.cn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;只在该域名内爬取&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     start_urls = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://m.weibo.cn/api/container/getIndex?containerid=102803_ctg1_4188_-_ctg1_4188&amp;amp;openApp=0&amp;amp;since_id=1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                  ]
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; parse1(self, response):
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         infos = json.loads(response.body)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;将内容转为json对象&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         item = response.meta[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;利用meta方法传入item&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         city = response.meta[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;传入城市&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             name = infos[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cards&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][0][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mblog&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;screen_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;爬取名字&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             first_news = re.findall(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;([\u4e00-\u9fa5]+)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, str(infos[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cards&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][0][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mblog&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]), re.S)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;爬取微博内容，使用正则去除一些杂项如网页代码&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;             dates = infos[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cards&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][0][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mblog&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;created_at&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;发布时间&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             zhuanzai = infos[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cards&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][0][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mblog&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;reposts_count&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;转载数&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             comment = infos[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cards&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][0][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mblog&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;comments_count&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;评论数&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;             agree = infos[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cards&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][0][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mblog&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;attitudes_count&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;点赞数&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;将数据赋给item&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;             item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; name
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;first_news&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; first_news
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dates&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; dates
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhuanzai&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; zhuanzai
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;comment&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; comment
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;agree&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; agree
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; city
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; item    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt; IndexError &lt;span&gt;or&lt;/span&gt;&lt;span&gt; KeyError:
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; parse2(self, response):    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取所在地区函数&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;         infos =&lt;span&gt; json.loads(response.body)
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             item = response.meta[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;传入item&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;             city_cont = str(infos[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cards&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][1][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;card_group&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             city = re.findall(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;card_type.*?所在地.*?item.*?:(.*?)}]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, city_cont, re.S)[0].replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\'&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;&lt;span&gt;).replace(
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                 &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;城市&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;             item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; city
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             ids = response.meta[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ids&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;传入id并赋给ids变量&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;             n_url1 = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://m.weibo.cn/api/container/getIndex?&amp;amp;containerid=107603&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; ids
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;yield&lt;/span&gt; scrapy.Request(n_url1, meta={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: item, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: copy.deepcopy(city)}, callback=self.parse1)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;执行完上述命令后的步骤&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt; IndexError &lt;span&gt;or&lt;/span&gt;&lt;span&gt; KeyError:
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; parse(self, response):
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         datas =&lt;span&gt; json.loads(response.body)
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         item =&lt;span&gt; SinaweiboItem()
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(0, 20&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                 ids = str(datas[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cards&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][i][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mblog&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;])    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取用户id&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt;                 n_url2 = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://m.weibo.cn/api/container/getIndex?containerid=230283{}_-_INFO&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(ids)
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;                 &lt;span&gt;yield&lt;/span&gt; scrapy.Request(n_url2, meta={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: item, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ids&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: copy.deepcopy(ids)}, callback=self.parse2)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;进入parse2函数执行命令&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt;             &lt;span&gt;except&lt;/span&gt; IndexError &lt;span&gt;or&lt;/span&gt;&lt;span&gt; KeyError:
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;                 &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt;         social_urls =&lt;span&gt; [
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://m.weibo.cn/api/container/getIndex?containerid=102803_ctg1_4188_-_ctg1_4188&amp;amp;openApp=0&amp;amp;since_id={}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;                 str(i)) &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(2, 100&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;         celebritys_urls =&lt;span&gt; [
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://m.weibo.cn/api/container/getIndex?containerid=102803_ctg1_4288_-_ctg1_4288&amp;amp;openApp=0&amp;amp;since_id={}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;                 str(j)) &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(1, 100&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;         hots_urls = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://m.weibo.cn/api/container/getIndex?containerid=102803&amp;amp;openApp=0&amp;amp;since_id={}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(str(t))
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;                      &lt;span&gt;for&lt;/span&gt;
&lt;span&gt;70&lt;/span&gt;                      t &lt;span&gt;in&lt;/span&gt; range(1, 100&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;         urls = celebritys_urls + social_urls + hots_urls    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;入口网址&lt;/span&gt;
&lt;span&gt;72&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; url &lt;span&gt;in&lt;/span&gt;&lt;span&gt; urls:
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;             &lt;span&gt;yield&lt;/span&gt; scrapy.Request(url, callback=self.parse)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里要注意 &lt;strong&gt;scrpay.Request&lt;/strong&gt; 函数的meta参数，它是一个字典，用来进行参数传递，如上面代码所示，我想在parse2()函数中用到parse()函数中爬取的用户id，就需要进行设置，这里就不过多解释了，其实我也是处于摸着石头过河的理解程度，想深入了解的朋友可自行百度。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在setting.py配置爬虫&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这次我只将内容导出到了csv文件中，方便后续筛选制作词云，如果爬取的数据较多的话，可以存储到数据库中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; BOT_NAME = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sinaweibo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; SPIDER_MODULES = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sinaweibo.spiders&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; NEWSPIDER_MODULE = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sinaweibo.spiders&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; USER_AGENT: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;消息头&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; DOWNLOAD_DELAY = 0.5    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;延时0.5s&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Crawl responsibly by identifying yourself (and your website) on the user-agent&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;USER_AGENT = 'sinaweibo (+http://www.yourdomain.com)'&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; FEED_URI = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;file:C:/Users/lenovo/Desktop/weibo.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;存入文件位置&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; FEED_FORMAT = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;保存格式&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; ITEM_PIPELINES= {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sinaweibo.pipelines.SinaweiboPipeline&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 300}     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;管道设置&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Obey robots.txt rules&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; ROBOTSTXT_OBEY =&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; FEED_EXPORT_ENCODING = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;UTF8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;编码格式&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;本次没有下载图片及其他内容了，因此pipelines.py文件就没有编写内容了。爬取的部分数据如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1526536/201905/1526536-20190512150233630-1290617618.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;到这里爬虫部分就结束了，本次爬取的内容也较为简单，下面的话就是使用其中的部分数据来生成词云。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;词云制作&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在文件中新建了一个 weibo_analysis.py 的文件，使用jieba库来进行分词，在此之前，需要先将所需数据提取出来，这里使用pandas就可以。&lt;/p&gt;
&lt;p&gt; 这部分程序很简单，就不废话了，直接上代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; csv
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; jieba.analyse
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; get_ciyun(city):    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;进行分词&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     tags=jieba.analyse.extract_tags(str(city),topK=100,withWeight=&lt;span&gt;True)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; tags:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(item[0]+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+str(int(item[1]*1000&lt;span&gt;)))
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; need_citys = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;北京&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;上海&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;湖南&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;四川&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;广东&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; beijing =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; shanghai =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; hunan =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; sichuan =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; gd =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; pd.set_option(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;expand_frame_repr&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, True)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;可换行显示&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; pd.set_option(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;display.max_rows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, None)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;显示所有行&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; pd.set_option(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;display.max_columns&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, None)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;显示所有列&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; df = pd.read_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\\Users\lenovo\Desktop\weibo.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;读取文件内容并转化为dataframes对象&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; contents = df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;first_news&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;取微博内容&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; city = df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;取城市&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(city)):
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; need_citys[0] &lt;span&gt;in&lt;/span&gt; city[i]:    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;判断并存入&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        beijing.append(contents[i])
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;elif&lt;/span&gt; need_citys[1] &lt;span&gt;in&lt;/span&gt;&lt;span&gt; city[i]:
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        shanghai.append(contents[i])
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;elif&lt;/span&gt; need_citys[2] &lt;span&gt;in&lt;/span&gt;&lt;span&gt; city[i]:
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        hunan.append(contents[i])
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;elif&lt;/span&gt; need_citys[3] &lt;span&gt;in&lt;/span&gt;&lt;span&gt; city[i]:
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        sichuan.append(contents[i])
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;elif&lt;/span&gt; need_citys[4] &lt;span&gt;in&lt;/span&gt;&lt;span&gt; city[i]:
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        gd.append(contents[i])
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;get_ciyun(beijing)
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;*20&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;get_ciyun(shanghai)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;*20&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;get_ciyun(hunan)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;*20&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;get_ciyun(sichuan)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;*20&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; get_ciyun(gd)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;本次是通过Tagul网站在制作词云，将上方输出的词频导入，选择好词云形状、字体（不支持中文可自行导入中文字体包）、颜色等点击可视化就能生成了，非常方便。&lt;/p&gt;
&lt;p&gt;下面是我本次生成的词云图片：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;北京&quot; src=&quot;https://img2018.cnblogs.com/blog/1526536/201905/1526536-20190512151224437-324731520.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img title=&quot;上海&quot; src=&quot;https://img2018.cnblogs.com/blog/1526536/201905/1526536-20190512151339234-107146284.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;广东&quot; src=&quot;https://img2018.cnblogs.com/blog/1526536/201905/1526536-20190512151440863-1652676264.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;四川&quot; src=&quot;https://img2018.cnblogs.com/blog/1526536/201905/1526536-20190512151501557-425296484.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img title=&quot;湖南&quot; src=&quot;https://img2018.cnblogs.com/blog/1526536/201905/1526536-20190512151530135-290460950.png&quot; alt=&quot;&quot; width=&quot;650&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;使用scrapy进行爬虫确实能大大提高爬取效率，同时本次使用过程中也发现了许多的问题，如对这个框架不够深入，还有很多方法不会用、不知道，还有就是Python本身的面向对象的知识理解的也不够，需要继续学习。这也说明了自己还只是一枚菜鸟。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;若有疑问或建议，欢迎提出指正。&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 12 May 2019 07:27:00 +0000</pubDate>
<dc:creator>Berryguo</dc:creator>
<og:description>大家好，本月第一次更新。 最近找了一份关于爬虫的实习工作，需要爬取较大量的数据，这时就发现通过自己编写函数来实现爬虫效率太慢了；于是又转回来用scrapy，以前稍微学习了一下，这次刚好爬爬微博练练手，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/berryguotoshare/p/10852404.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 通过 Microsoft.DotNet.Watcher.Tools 实现热部署 - 季小鱼</title>
<link>http://www.cnblogs.com/efanfan/p/10852123.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/efanfan/p/10852123.html</guid>
<description>&lt;p&gt;之前开发前端的时候，webpack 会有热更新工具，在修改了代码之后，自动将代码编译，实时展现到页面上，给开发带来了极大的方便。&lt;/p&gt;
&lt;p&gt;Java也可以通过第三方插件JRebel实现热部署，不用频繁的重启Tomcat。&lt;/p&gt;
&lt;p&gt;微软官方也为.NET Core 开发了热部署工具，就是Microsoft.DotNet.Watcher.Tools 。最新的版本可以通过nuget查询到，目前最新的版本是2.0.2。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/454014/201905/454014-20190512104734840-369399267.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体使用：&lt;/p&gt;
&lt;p&gt;可以参照nuget上面的方法，将工具添加到项目，参照教程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/454014/201905/454014-20190512105008533-1521385122.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我这边用的是.NET Core CLI，，运行 dotnet add package Microsoft.DotNet.Watcher.Tools --version 2.0.2 命令就可以了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/454014/201905/454014-20190512110047553-389048132.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行完毕之后就可以使用了。&lt;/p&gt;
&lt;p&gt;运行dotnet watch run --verbose 就可以启动项目，并实现热部署了。--verbose 可以看到详细输出的消息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/454014/201905/454014-20190512110513959-2035685438.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;测试代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
public&lt;span&gt; IActionResult test()
{
    return Content(&quot;123&quot;&lt;span&gt;);
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/454014/201905/454014-20190512110749213-507624256.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改代码并保存，控制台检测到更新：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/454014/201905/454014-20190512110919920-1714228250.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看浏览器结果，可以看到已经更新了，中途并未重启服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/454014/201905/454014-20190512111020385-1466109698.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 12 May 2019 06:14:00 +0000</pubDate>
<dc:creator>季小鱼</dc:creator>
<og:description>之前开发前端的时候，webpack 会有热更新工具，在修改了代码之后，自动将代码编译，实时展现到页面上，给开发带来了极大的方便。 Java也可以通过第三方插件JRebel实现热部署，不用频繁的重启To</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/efanfan/p/10852123.html</dc:identifier>
</item>
<item>
<title>提前体验让人&quot;回归Windows怀抱&quot;的Windows Terminal - 三升水</title>
<link>http://www.cnblogs.com/sanshengshui/p/10852099.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sanshengshui/p/10852099.html</guid>
<description>&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;在一年一度的微软开发者大会&lt;span&gt;&lt;strong&gt;Build 2019&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;登场的&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://github.com/microsoft/Terminal&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;Windows Terminal&lt;/span&gt;&lt;/a&gt;&lt;span class=&quot;md-plain&quot;&gt;饱受好评，大家对其也是充满了兴趣和热情，程序员的朋友圈都被微软发布的最新终端 &lt;span&gt;&lt;strong&gt;windows Terminal&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;短短几天时间内就已登顶Github。当然与此同时，微软还新出一款萌萌的等宽字体 &lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://github.com/tonsky/FiraCode&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;Fira Code&lt;/span&gt;&lt;/a&gt;&lt;span class=&quot;md-plain&quot;&gt;，它有自己的库，也是开源的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;Windows Terminal是一个面向命令行用户的全新，现代，功能丰富，高效的终端应用程序。 它包括Windows命令行社区最常请求的许多功能，包括对选项卡，富文本，全球化，可配置性，主题和样式等的支持。终端还需要满足我们的目标和措施，以确保它保持快速，高效，并且不会消耗大量的内存或电量。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/windows-terminal/github-Trending.png&quot;&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/windows-terminal/github-Trending.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;

&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;多标签&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;程序员如果在Terminal打开很多个Tab，切换起来很麻烦，而这次你想开几个就几个！&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;并一键连接到你选择的命令或应用程序，例如想切换到Cmd、PowerShell、 Ubuntu等等，一键直达！&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/windows-terminal/window-terminal.png&quot;&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/windows-terminal/window-terminal.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;告别死板的界面，表情用起来&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;以前的Terminal在界面上……程序员们已无力吐槽了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;Windows Terminal是基于DirectWrite/DirectX的&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;http://www.elecfans.com/tags/gpu/&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;gpu&lt;/span&gt;&lt;/a&gt; &lt;span class=&quot;md-plain&quot;&gt;渲染加速的文本呈现。同时微软也卖起萌来，支持Emoji 表情符号、日韩CJK 表意文字、电力线符号、图标、编程连字。当然还有上面那个开源的等宽字体Fira Code。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/windows-terminal/%E5%8D%9A%E5%AE%A2%E5%9B%AD.png&quot;&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/windows-terminal/%E5%8D%9A%E5%AE%A2%E5%9B%AD.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/windows-terminal/Fira%20Code.png&quot;&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/windows-terminal/Fira%20Code.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;支持自定义设置&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;Windows Terminal提供了许多设置和配置选项，可以对Terminal的外观自定义设置。Set&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;http://www.elecfans.com/tags/%E5%BE%B7%E5%B7%9E%E4%BB%AA%E5%99%A8/&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;ti&lt;/span&gt;&lt;/a&gt;&lt;span class=&quot;md-plain&quot;&gt;ngs文件存储在结构化文本中，便于用户配置。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;还可以为每个shell、应用和工具创建对应的配置文件，例如可以给PowerShell、 Cmd、Ubuntu、甚至是Azure 或 &lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;http://www.elecfans.com/tags/iot/&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;IoT&lt;/span&gt;&lt;/a&gt; &lt;span class=&quot;md-plain&quot;&gt;设备配置。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;这些配置文件可以自定义字体样式、大小、颜色主题、背景等。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;这么个性，走起来！&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;如何设置&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;单击菜单时，请查看“设置”，这将在JSON编辑器中打开您的profile.json。我使用VS Code进行编辑。您需要运行Format Document以使JSON看起来很好，因为它可能会出现在一行上。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;您可以在“方案”节点中创建颜色配置文件。例如，这里是我的“UbuntuLegit”颜色主题我profiles.json。&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block ty-contain-cm modeLoaded&quot;&gt;
&lt;span&gt;{&lt;br/&gt;&lt;span&gt;    &quot;name&quot;: &quot;UbuntuLegit&quot;,&lt;br/&gt;&lt;span&gt;    &quot;foreground&quot;: &quot;#EEEEEE&quot;,&lt;br/&gt;&lt;span&gt;    &quot;background&quot;: &quot;#2C001E&quot;,&lt;br/&gt;&lt;span&gt;    &quot;colors&quot;: [&lt;br/&gt;&lt;span&gt;        &quot;#4E9A06&quot;, &quot;#CC0000&quot;, &quot;#300A24&quot;, &quot;#C4A000&quot;,&lt;br/&gt;&lt;span&gt;        &quot;#3465A4&quot;, &quot;#75507B&quot;, &quot;#06989A&quot;, &quot;#D3D7CF&quot;,&lt;br/&gt;&lt;span&gt;        &quot;#555753&quot;, &quot;#EF2929&quot;, &quot;#8AE234&quot;, &quot;#FCE94F&quot;,&lt;br/&gt;&lt;span&gt;        &quot;#729FCF&quot;, &quot;#AD7FA8&quot;, &quot;#34E2E2&quot;, &quot;#EEEEEE&quot;&lt;br/&gt;&lt;span&gt;    ]&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;这是一个示例配置文件，其中包含我所知道的有关set的所有设置。这是为“CMD.exe”&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block ty-contain-cm modeLoaded&quot;&gt;
&lt;span&gt;&quot;profiles&quot;: [&lt;br/&gt;&lt;span&gt;{&lt;br/&gt;&lt;span&gt;    &quot;startingDirectory&quot;: &quot;C:/Users/Scott/Desktop&quot;,&lt;br/&gt;&lt;span&gt;    &quot;guid&quot;: &quot;{7d04ce37-c00f-43ac-ba47-992cb1393215}&quot;,&lt;br/&gt;&lt;span&gt;    &quot;name&quot;: &quot;DOS but not DOS&quot;,&lt;br/&gt;&lt;span&gt;    &quot;colorscheme&quot;: &quot;Solarized Dark&quot;,&lt;br/&gt;&lt;span&gt;    &quot;historySize&quot;: 9001,&lt;br/&gt;&lt;span&gt;    &quot;snapOnInput&quot;: true,&lt;br/&gt;&lt;span&gt;    &quot;cursorColor&quot;: &quot;#00FF00&quot;,&lt;br/&gt;&lt;span&gt;    &quot;cursorHeight&quot;: 25,&lt;br/&gt;&lt;span&gt;    &quot;cursorShape&quot;: &quot;vintage&quot;,&lt;br/&gt;&lt;span&gt;    &quot;commandline&quot;: &quot;cmd.exe&quot;,&lt;br/&gt;&lt;span&gt;    &quot;fontFace&quot;: &quot;Cascadia Code&quot;,&lt;br/&gt;&lt;span&gt;    &quot;fontSize&quot;: 20,&lt;br/&gt;&lt;span&gt;    &quot;acrylicOpacity&quot;: 0.85,&lt;br/&gt;&lt;span&gt;    &quot;useAcrylic&quot;: true,&lt;br/&gt;&lt;span&gt;    &quot;closeOnExit&quot;: false,&lt;br/&gt;&lt;span&gt;    &quot;padding&quot;: &quot;0, 0, 0, 0&quot;,&lt;br/&gt;&lt;span&gt;    &quot;icon&quot;: &quot;ms-appdata:///roaming/cmd-32.png&quot;&lt;br/&gt;&lt;span&gt;},&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;我喜欢光标，我把它变成了亮绿色。我也可以在这个位置添加图标：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;%LOCALAPPDATA%\packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\RoamingState&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;所以我在该文件夹中放入了一些32x32 PNG，然后我可以使用ms-appdata://&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/windows-terminal/tu.png&quot;&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/windows-terminal/tu.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;官方还没有发布正式版,要编译安装该工具,并没有想象的那样简单.甚至可以说,坑非常多。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;如果对于想自己编译这个Terminal的程序员的话，这里有一个&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://github.com/microsoft/Terminal/issues/489&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;Issue&lt;/span&gt;&lt;/a&gt;&lt;span class=&quot;md-plain&quot;&gt;可以供大家参考，虽然一直使用Ubuntu,用的顺风顺水,但看到号称能让程序员”回归到Windows怀抱”的工具,还是想上手亲测验证一波. 经过一番探索&amp;amp;折腾,在此给出最简便体验该工具的方案.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;  (提前预警,Windows10版本号需要是更新至最新的1903)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;下面正式开始:&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;-0.87931034482759&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://pan.baidu.com/s/1N-_UA8P46i081Y-sUSfzIQ&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;下载编译好的文件&lt;/span&gt;&lt;/a&gt;&lt;span class=&quot;md-plain&quot;&gt;,提取码:7mux&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;运行如图文件&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/windows-terminal/run.png&quot;&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/windows-terminal/run.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;过程中可能会报错&lt;span&gt;&lt;strong&gt;你需要为此应用包安装新证书，或者使用带受信任证书的新应用包。系统管理员或应用开发人员可以提供帮助。已处理证书链，但处理过程因根证书不受信任而终止 (0x800B0109)&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://blog.csdn.net/egostudio/article/details/77408126&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;可参考此文步骤轻松解决&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/windows-terminal/6.png&quot;&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/windows-terminal/6.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;3&quot; readability=&quot;1.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;3&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;过了这个坎是新的沟,&lt;span&gt;&lt;strong&gt;应用安装失败，错误消息: 由于程序包 Microsoft.WindowsTerminal_2019.5.6.0_x64__8wekyb3d8bbwe 与设备不兼容，Windows 无法安装该程序包。该程序包要求 Windows.Universal 设备系列运行操作系统版本 10、0、18362、0 或更高版本。该设备当前运行的操作系统版本为 10、0、17763、316。 (0x80073cfd)&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/windows-terminal/7.png&quot;&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/windows-terminal/7.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;这个报错是说需将windows版本从17763升级至18362,查看当前版本信息&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/windows-terminal/version.png&quot;&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/windows-terminal/version.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;可通过该网站下载对应操作系统最新的版本,&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;http://news.mydrivers.com/1/440/440540.htm&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;点此&lt;/span&gt;&lt;/a&gt;&lt;span class=&quot;md-plain&quot;&gt;, &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;对64位系统,可直接复制&lt;span&gt;&lt;strong&gt;ed2k://|file|cn_windows_10_consumer_editions_version_1903_x64_dvd_8f05241d.iso|4905476096|F28FDC23DA34D55BA466BFD6E91DD311|/&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;至迅雷或电骡下载。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;5&quot; readability=&quot;-1.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;经过漫长的下载,点击iso安装最新版本，然后便可一马平川安装体验~&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/windows-terminal/install.png&quot;&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/windows-terminal/install.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;微软官方原话是这样的:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;截至今天，Windows 终端和 Windows 控制台已经成为开源的，您可以从 GitHub 上的存储库克隆，构建，运行和测试代码。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;今年夏天 2019 年，Windows 终端预览将发布到 Microsoft Store，供早期采用者使用并提供反馈。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;在 2019 年的这个冬天，我们的目标是推出 Windows 终端 1.0，我们将与社区合作，确保在我们发布之前就已经准备就绪！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 12 May 2019 06:09:00 +0000</pubDate>
<dc:creator>三升水</dc:creator>
<og:description>前言 在一年一度的微软开发者大会Build 2019登场的Windows Terminal饱受好评，大家对其也是充满了兴趣和热情，程序员的朋友圈都被微软发布的最新终端 windows Terminal</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sanshengshui/p/10852099.html</dc:identifier>
</item>
<item>
<title>黑科技抢先尝 - Windows全新终端初体验(附代码Build全过程) - dotNET匠人</title>
<link>http://www.cnblogs.com/enjoy233/p/awesome_windows_terminal_build_and_trial.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/enjoy233/p/awesome_windows_terminal_build_and_trial.html</guid>
<description>&lt;p&gt;微软在几天前的build大会上展示了 &lt;code&gt;Windows Terminal&lt;/code&gt;的威力，由于官宣要在6月中旬才上&lt;code&gt;Microsoft store&lt;/code&gt;，还有一个多月要等呢。好在代码已公布在 github, 于是决定自己 build 后体验一番。遇到不少坑，大概整理一下流程，分享给大家。如果大家如果发现问题，欢迎指正。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;官方视频如下：&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://v.qq.com/x/page/p0869ovd7aw.html&quot; class=&quot;uri&quot;&gt;https://v.qq.com/x/page/p0869ovd7aw.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;将window-10-升级到1903版本&quot;&gt;将Window 10 升级到1903版本&lt;/h2&gt;
&lt;p&gt;试过用Windows 10 更新助手(Windows 10 update assistant)来升级Windows 10, 发现只能升级到1809版本。而编译 github 上的 Microsoft terminal 代码必须使用&lt;code&gt;Window 10&lt;/code&gt;的1903版本.&lt;/p&gt;
&lt;p&gt;好在前不久听说了工具网站 &lt;a href=&quot;http://msdn.itellyou.cn/&quot;&gt;MSDN, 我告诉你&lt;/a&gt;上可以下载到该版本的镜像。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201905/436938-20190512132024347-1419949998.png&quot; alt=&quot;1557627006164&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于版本选择，到底选Consumer版还是Business版呢？经大佬Edi Wang指点，得悉如下信息：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果你的 Windows 是 家庭版，请选择 &lt;code&gt;Consumer&lt;/code&gt; 版&lt;/li&gt;
&lt;li&gt;如果你的 Windows 是 专业版或企业版，请选择 &lt;code&gt;Business&lt;/code&gt;版&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;至于&lt;code&gt;ed2k://&lt;/code&gt;资源的下载，你使用百度云盘的离线下载也好，使用迅雷也行。&lt;/p&gt;

&lt;h2 id=&quot;安装好git-从github上clone代码&quot;&gt;安装好git, 从github上clone代码&lt;/h2&gt;
&lt;p&gt;首先需要安装好 &lt;code&gt;git for Windows&lt;/code&gt;（&lt;a href=&quot;https://gitforwindows.org/&quot; class=&quot;uri&quot;&gt;https://gitforwindows.org/&lt;/a&gt;），然后使用 git 去 clone 一份代码。&lt;/p&gt;
&lt;p&gt;Microsoft Terminal 的 github仓库是:&lt;br/&gt;&lt;a href=&quot;https://github.com/microsoft/Terminal&quot; class=&quot;uri&quot;&gt;https://github.com/microsoft/Terminal&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对应的 clone地址是:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/microsoft/Terminal.git&quot; class=&quot;uri&quot;&gt;https://github.com/microsoft/Terminal.git&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;打开命令行，使用cd命令，切换到自己平时存vs项目的路径(比如我切换到&lt;code&gt;D:\Coding&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;接着只需要在&lt;code&gt;Git Bash&lt;/code&gt;中输入如下命令即可：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;git clone https://github.com/microsoft/Terminal.git&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201905/436938-20190512133007537-2097577478.png&quot; alt=&quot;1557625927965&quot;/&gt;&lt;/p&gt;
&lt;p&gt;等 clone 完成，就可以进行下一步了。&lt;/p&gt;
&lt;p&gt;确保克隆存储库后，还可以使用以下命令克隆子模块：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;git submodule update --init --recursive&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;安装-vs-2019-和-.net-core-3.0-sdk&quot;&gt;安装 VS 2019 和 .NET core 3.0 SDK&lt;/h2&gt;
&lt;p&gt;先安装 vs 2019 professional 或 enterprise版本，github上的文档提到了要编译 window terminal 必须勾选上：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Desktop Development with C++&lt;/li&gt;
&lt;li&gt;Universal Windows Platform Development&lt;/li&gt;
&lt;li&gt;Windows SDK version 10.0.18362.0&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;再安装好.net core 3.0 SDK，比较简单，就不再详述。&lt;/p&gt;
&lt;p&gt;在vs的设置里，勾选.NET core下的&quot;Use preview SDK&quot;(使用.NET Core SDK预览版)，重启 VS。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190420171558821-101048975.jpg&quot; alt=&quot;img3&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 vs 2019 中打开Windows terminal项目(对应文件夹&lt;code&gt;Terminal&lt;/code&gt;)下的&lt;code&gt;OpenConsole.sln&lt;/code&gt;, 如果不勾选&quot;使用.NET Core SDK预览版&quot;直接编译，很可能会报下面的 Error:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201905/436938-20190512133102223-830064832.png&quot; alt=&quot;1557627653748&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;重定解决方案目标&quot;&gt;重定解决方案目标&lt;/h2&gt;
&lt;p&gt;在上一步中，用vs2019打开&lt;code&gt;OpenConsole.sln&lt;/code&gt;时，系统会提示你将项目重新定位到 v142。 对于“Windows SDK版本”，请选择“10.0.18362.0”。 将“Platform Toolset”设置为“Upgrade to v142”。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201905/436938-20190512133125424-111563664.png&quot; alt=&quot;1557632133871&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后往下拖，按下图设置:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201905/436938-20190512133523116-894929558.png&quot; alt=&quot;1557632360926&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置完后，单击最下面的OK。&lt;/p&gt;
&lt;p&gt;当然，如果误点了&quot;取消&quot;，也能通过右键单击整个Solution -&amp;gt; Retarget solution来设置:&lt;/p&gt;

&lt;h2 id=&quot;设置好编译平台和启动的项目&quot;&gt;设置好编译平台和启动的项目&lt;/h2&gt;
&lt;p&gt;在你尝试再次build之前，请确保你已经选择好与你的计算机匹配的编译平台(Solution Platform)。&lt;/p&gt;
&lt;p&gt;不知道你一开始打开Solution &lt;code&gt;OpenConsole.sln&lt;/code&gt;时编译平台和启动项目是什么样的，我的是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201905/436938-20190512133551160-1995999451.png&quot; alt=&quot;1557631342884&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要正确地 build，这里需要设置如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201905/436938-20190512133617953-1566553716.png&quot; alt=&quot;1557629911752&quot;/&gt;&lt;/p&gt;
&lt;p&gt;否则会出现很多错误。&lt;/p&gt;

&lt;h2 id=&quot;编译成功后出现一个新的powershell&quot;&gt;编译成功后出现一个新的Powershell&lt;/h2&gt;
&lt;p&gt;解决完编译时的各种状况之后，&lt;code&gt;Ctrl + F5&lt;/code&gt; 运行项目。&lt;/p&gt;
&lt;p&gt;唉，和之前的Powershell有何不一样呢？按&lt;code&gt;Ctrl + T&lt;/code&gt;之后会多了个菜单，同一个窗口中可以有多个Tab，而其他功能暂时没进来，等正式版。此外，还多了句话(见高亮部分)~&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;尝试新的跨平台 PowerShell https://aka.ms/pscore6 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201905/436938-20190512133646344-49777678.png&quot; alt=&quot;1557632560061&quot;/&gt;&lt;/p&gt;
&lt;p&gt;任务栏中相应的图标为:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201905/436938-20190512133718728-1930643979.png&quot; alt=&quot;1557634914551&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按&lt;code&gt;Ctrl + T&lt;/code&gt;之后, 右上角会出现一个以&lt;code&gt;+&lt;/code&gt;开头的菜单&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201905/436938-20190512133813146-1849414524.png&quot; alt=&quot;1557632764029&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但你在菜单中切换到&lt;code&gt;cmd&lt;/code&gt;的时候，视频中的酷炫效果就有一点出来的迹象了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201905/436938-20190512133839605-987225297.png&quot; alt=&quot;1557632951609&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，介绍一下如何在上面这个新的&lt;code&gt;cmd&lt;/code&gt;中使用&lt;code&gt;Linux&lt;/code&gt;命令，以我最熟悉的Ubuntu为例来介绍吧。&lt;/p&gt;

&lt;h2 id=&quot;安装ubuntu&quot;&gt;安装Ubuntu&lt;/h2&gt;
&lt;p&gt;在Microsoft store里搜索到&lt;code&gt;Ubuntu&lt;/code&gt;，然后购买，安装。这实际上就是WSL (Windows Subsystem for Linux)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201905/436938-20190512133900947-483996122.png&quot; alt=&quot;1557633269919&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，你想体验其他版本的 &lt;code&gt;Linux&lt;/code&gt;，也是可以的，比如&lt;code&gt;Arch Linux&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201905/436938-20190512133919678-2096288566.png&quot; alt=&quot;1557633347262&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;在编译出来的命令行中使用linux命令&quot;&gt;在编译出来的命令行中使用Linux命令&lt;/h2&gt;
&lt;p&gt;安装完WSL版的 Linux 后，还需要开启&lt;code&gt;WSL&lt;/code&gt;的权限:&lt;/p&gt;
&lt;p&gt;以&quot;管理员权限&quot;另开一个&lt;code&gt;PowerShell&lt;/code&gt;窗口,&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201905/436938-20190512133939101-904947600.png&quot; alt=&quot;1557633727047&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后输入如下命令:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201905/436938-20190512134023006-835289777.png&quot; alt=&quot;1557633836814&quot;/&gt;&lt;/p&gt;
&lt;p&gt;等这里的命令完成，就可以在build出来的 Terminal 中执行 Linux 命令了。&lt;/p&gt;
&lt;p&gt;先在&lt;code&gt;cmd&lt;/code&gt;中输入 &lt;code&gt;ubuntu&lt;/code&gt;, 需要花一点点时间启动 &lt;code&gt;Ubuntu&lt;/code&gt;, 设置好用户名和密码。&lt;/p&gt;
&lt;p&gt;然后就可以愉快地玩Ubuntu了，下面我随便输入了几个命令 ps, touch, ls等，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201905/436938-20190512131703021-681615350.png&quot; alt=&quot;1557633540178&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如有什么疑问或建议，欢迎及时留言交流。&lt;/p&gt;
&lt;p&gt;如果自己不想配置和build，可以下载build好的体验一把:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pan.baidu.com/s/1Xrh-0KbsBmh-zJYsdtYqnA&quot; class=&quot;uri&quot;&gt;https://pan.baidu.com/s/1Xrh-0KbsBmh-zJYsdtYqnA&lt;/a&gt; 口令: y233&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备份地址:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/yanglr/WindowsDevTools/tree/master/awosomeTerminal&quot; class=&quot;uri&quot;&gt;https://github.com/yanglr/WindowsDevTools/tree/master/awosomeTerminal&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其他玩法:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Build and install Windows Terminal from Azure DevOps ? Keep IT tidy&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.stomsvik.com/posts/2019/terminal-azure-devops/&quot; class=&quot;uri&quot;&gt;https://blog.stomsvik.com/posts/2019/terminal-azure-devops/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Terminal/README.md at master · microsoft/Terminal&lt;br/&gt;&lt;a href=&quot;https://github.com/microsoft/Terminal/blob/master/README.md&quot; class=&quot;uri&quot;&gt;https://github.com/microsoft/Terminal/blob/master/README.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Windows 子系统适用于 Linux (WSL) 上 Windows 10 上安装 | Microsoft Docs&lt;br/&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/windows/wsl/install-win10&quot; class=&quot;uri&quot;&gt;https://docs.microsoft.com/zh-cn/windows/wsl/install-win10&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Donovan Brown | Building the new Windows Terminal with Visual Studio 2019&lt;br/&gt;&lt;a href=&quot;http://www.donovanbrown.com/post/Building-the-new-Windows-Terminal-with-Visual-Studio-2019&quot; class=&quot;uri&quot;&gt;http://www.donovanbrown.com/post/Building-the-new-Windows-Terminal-with-Visual-Studio-2019&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 12 May 2019 05:49:00 +0000</pubDate>
<dc:creator>dotNET匠人</dc:creator>
<og:description>[TOC] 微软在几天前的build大会上展示了 的威力，由于官宣要在6月中旬才上 ，还有一个多月要等呢。好在代码已公布在 github, 于是决定自己 build 后体验一番。遇到不少坑，大概整理一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/enjoy233/p/awesome_windows_terminal_build_and_trial.html</dc:identifier>
</item>
<item>
<title>React Hooks 深入系列 - 牧云云</title>
<link>http://www.cnblogs.com/MuYunyun/p/10852005.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MuYunyun/p/10852005.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/12/16aaa87f5913e2e8?w=640&amp;amp;h=280&amp;amp;f=jpeg&amp;amp;s=14917&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文基于近段时间对 hooks 碎片化的理解作一次简单梳理, &lt;a href=&quot;https://github.com/MuYunyun/blog&quot;&gt;个人博客&lt;/a&gt;。同时欢迎关注基于 hooks 构建的 UI 组件库 —— &lt;a href=&quot;https://github.com/ming-cult/snake-design&quot;&gt;snake-design&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在 class 已经融入 React 生态的节点下, React 推出的 Hooks 具有如下优势:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;更简洁的书写;&lt;/li&gt;
&lt;li&gt;相对类中的 &lt;code&gt;HOC&lt;/code&gt; 与 &lt;code&gt;render Props&lt;/code&gt;, Hooks 拥有更加自由地组合抽象的能力;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;使用-hooks-的注意项&quot;&gt;使用 Hooks 的注意项&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在 &lt;code&gt;hooks&lt;/code&gt; 中每一次 &lt;code&gt;render&lt;/code&gt; 都有自己的 &lt;code&gt;state&lt;/code&gt; 和 &lt;code&gt;props&lt;/code&gt;, 这与 &lt;code&gt;class&lt;/code&gt; 中存在差异, 见 &lt;a href=&quot;https://overreacted.io/a-complete-guide-to-useeffect/#each-render-has-its-own-everything&quot;&gt;Hooks 每次渲染都是闭包&lt;/a&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;class&lt;/code&gt; 中可以用闭包模拟 &lt;code&gt;hooks&lt;/code&gt; 的表现, &lt;a href=&quot;https://codesandbox.io/s/w7vjo07055&quot;&gt;链接&lt;/a&gt;, &lt;code&gt;hooks&lt;/code&gt; 中可以使用 &lt;code&gt;ref&lt;/code&gt; 模拟 &lt;code&gt;class&lt;/code&gt; 的表现, &lt;a href=&quot;https://codesandbox.io/s/rm7z22qnlp&quot;&gt;链接&lt;/a&gt;;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;写出 useEffect 的所用到的依赖&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在以下 demo 中, &lt;code&gt;useEffect&lt;/code&gt; 的第二个参数传入 &lt;code&gt;[]&lt;/code&gt;, 希望的是 &lt;code&gt;useEffect&lt;/code&gt; 里的函数只执行一次(类似在 &lt;code&gt;componentDidMount&lt;/code&gt; 中执行一次, 但是注意这里仅仅是&lt;code&gt;类似&lt;/code&gt;, 详细原因见上一条注意项), 页面上每隔 1s 递增 1。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function Demo() {
  const [count, setCount] = useState(0);

  useEffect(() =&amp;gt; {
    const id = setInterval(() =&amp;gt; {
      setCount(count + 1);
    }, 1000);
    return () =&amp;gt; {
      clearInterval(id);
    };
  }, []);

  return count;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但这样达到我们预期的效果了么? &lt;a href=&quot;https://codesandbox.io/s/n3o2m1wpj4&quot;&gt;demo&lt;/a&gt;, 可以看到界面上只增加到 1 就停止了。原因就是传入的第二个参数 &lt;code&gt;[]&lt;/code&gt; 搞的鬼, &lt;code&gt;[]&lt;/code&gt; 表示没有外界状态对 &lt;code&gt;effect&lt;/code&gt; 产生干扰。流程大致如下:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第一次调用 &lt;code&gt;useEffect&lt;/code&gt; 传入的 &lt;code&gt;count&lt;/code&gt; 为 0, 于是 &lt;code&gt;setCount(0 + 1)&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;受 &lt;code&gt;useEffect&lt;/code&gt; 第二个参数 &lt;code&gt;[]&lt;/code&gt; 的影响，&lt;code&gt;count&lt;/code&gt; 仍然为 0, 所以相当于还是 &lt;code&gt;setCount(0 + 1)&lt;/code&gt;;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;那如何修正上述问题呢? 方法有两个(方法一为主, 方法二为辅):&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;方法一: 将 &lt;code&gt;[]&lt;/code&gt; 改为 &lt;code&gt;[count]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;方法二: 将 &lt;code&gt;setCount(count + 1)&lt;/code&gt; 改为 &lt;code&gt;setCount(count =&amp;gt; count + 1)&lt;/code&gt;。这种方法的思想是修正状态的值而不依赖外面传进的状态。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不过遇到 &lt;code&gt;setCount(count =&amp;gt; count + 1)&lt;/code&gt; 的情况就可以考虑使用 &lt;code&gt;useReducer&lt;/code&gt; 了。&lt;/p&gt;
&lt;h4 id=&quot;何时使用-usereducer&quot;&gt;何时使用 useReducer&lt;/h4&gt;
&lt;p&gt;使用 &lt;code&gt;useState&lt;/code&gt; 的地方都能用 &lt;code&gt;useReducer&lt;/code&gt; 进行替代。相较 &lt;code&gt;useState&lt;/code&gt;, &lt;code&gt;useReducer&lt;/code&gt; 有如下优势:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;useReducer&lt;/code&gt; 将 &lt;code&gt;how&lt;/code&gt;(reducer) 和 &lt;code&gt;what&lt;/code&gt;(dispatch(action)) 进行抽离; 使用 &lt;code&gt;reducer&lt;/code&gt; 逻辑状态进行集中化维护;&lt;/li&gt;
&lt;li&gt;相比 useState, useReducer 没有&lt;a href=&quot;https://overreacted.io/a-complete-guide-to-useeffect/#each-render-has-its-own-everything&quot;&gt;闭包问题&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;当状态的一个 state 依赖状态中的另一个 state 时, 这种情况最好使用 useReducer; 可以参考 &lt;a href=&quot;https://overreacted.io/a-complete-guide-to-useeffect/#decoupling-updates-from-actions&quot;&gt;decoupling-updates-from-actions&lt;/a&gt; 中 Dan 列举的 demo。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;处理-useeffect-中的公用函数&quot;&gt;处理 useEffect 中的公用函数&lt;/h4&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function Demo() {
  const [count, setCount] = useState(0);

  function getFetchUrl(query) {
    return `http://demo${query}`
  }

  useEffect(() =&amp;gt; {
    const url = getFetchUrl('react')
  }, [getFetchUrl]);

  useEffect(() =&amp;gt; {
    const url = getFetchUrl('redux')
  }, [getFetchUrl]);

  return count;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时 &lt;code&gt;useEffect&lt;/code&gt; 中传入的第二个参数 &lt;code&gt;getFetchUrl&lt;/code&gt; 相当于每次都是新的, 所以每次都会请求数据, 那除了 &lt;code&gt;[getFetchUrl]&lt;/code&gt; 将改为 &lt;code&gt;[]&lt;/code&gt; 这种不推荐的写法外，有两种解决方法:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;. 方法一: 提升 &lt;code&gt;getFetchUrl&lt;/code&gt; 的作用域;&lt;br/&gt;&lt;/em&gt;. 方法二: 使用 &lt;code&gt;useCallback&lt;/code&gt; 或者 &lt;code&gt;useMemo&lt;/code&gt; 来包裹 getFetchUrl;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;React.memo&lt;/code&gt; 修饰一个函数组件, &lt;code&gt;useMemo&lt;/code&gt; 修饰一个函数。它们本质都是运用缓存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;react-hooks-内部是怎么工作的&quot;&gt;React Hooks 内部是怎么工作的&lt;/h3&gt;
&lt;p&gt;为了理解 React Hooks 内部实现原理, 对 &lt;code&gt;useState&lt;/code&gt;、&lt;code&gt;useEffect&lt;/code&gt; 进行了简单的实现。&lt;/p&gt;
&lt;h4 id=&quot;usestate-的简单实现&quot;&gt;useState 的简单实现&lt;/h4&gt;
&lt;p&gt;使用闭包来实现 &lt;code&gt;useState&lt;/code&gt; 的简单逻辑:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 这里使用闭包
const React = (function() {
  let _val

  return {
    useState(initialValue) {
      _val = _val || initialValue

      function setVal(value) {
        _val = value
      }

      return [_val, setVal]
    }
  }
})()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试如下:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function Counter() {
  const [count, setCount] = React.useState(0)

  return {
    render: () =&amp;gt; console.log(count),
    click: () =&amp;gt; setCount(count + 1)
  }
}

Counter().render() // 0
Counter().click()  // 模拟点击
Counter().render() // 1&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;useeffect-的简单实现&quot;&gt;useEffect 的简单实现&lt;/h4&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var React = (function() {
  let _val, _deps

  return {
    useState(initialValue) {
      _val = _val || initialValue

      function setVal(value) {
        _val = value
      }

      return [_val, setVal]
    },
    useEffect(callback, deps) {
      const ifUpdate = !deps

      // 判断 Deps 中的依赖是否改变
      const ifDepsChange = _deps ? !_deps.every((r, index) =&amp;gt; r === deps[index]) : true

      if (ifUpdate || ifDepsChange) {
        callback()

        _deps = deps || []
      }
    }
  }
})()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码如下:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var {useState, useEffect} = React

function Counter() {
  const [count, setCount] = useState(0)

  useEffect(() =&amp;gt; {
    console.log('useEffect', count)
  }, [count])

  return {
    render: () =&amp;gt; console.log('render', count),
    click: () =&amp;gt; setCount(count + 1),
    noop: () =&amp;gt; setCount(count), // 保持不变, 观察 useEffect 是否被调用
  }
}

Counter().render() // 'useEffect' 0, 'render', 0
Counter().noop()
Counter().render() // 'render', 0
Counter().click()
Counter().render() // 'useEffect' 1, 'render', 1&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;处理多次调用的情形&quot;&gt;处理多次调用的情形&lt;/h4&gt;
&lt;p&gt;为了在 &lt;code&gt;hooks&lt;/code&gt; 中能使用多次 &lt;code&gt;useState&lt;/code&gt;, &lt;code&gt;useEffect&lt;/code&gt;, 将各个 &lt;code&gt;useState&lt;/code&gt;, &lt;code&gt;useEffect&lt;/code&gt; 的调用存进一个数组中, 在上面基础上进行如下改造:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const React = (function() {
  const hooks = []
  let currentHook = 0

  return {
    render(Component) {
      const component = Component()
      component.render()
      currentHook = 0 // 重置, 这里很关键, 将 hooks 的执行放到 hooks 队列中, 确保每次执行的顺序保持一致。
      return component
    },
    useState(initialValue) {
      hooks[currentHook] = hooks[currentHook] || initialValue

      function setVal(value) {
        hooks[currentHook] = value
      }

      return [hooks[currentHook++], setVal]
    },
    useEffect(callback, deps) {
      const ifUpdate = !deps

      // 判断 Deps 中的依赖是否改变
      const ifDepsChange = hooks[currentHook] ? !hooks[currentHook].every((r, index) =&amp;gt; r === deps[index]) : true

      if (ifUpdate || ifDepsChange) {
        callback()

        hooks[currentHook++] = deps || []
      }
    }
  }
})()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码如下:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var {useState, useEffect} = React

function Counter() {
  const [count, setCount] = useState(0)
  const [type, setType] = useState('hi')

  useEffect(() =&amp;gt; {
    console.log('useEffect', count)
    console.log('type', type)
  }, [count, type])

  return {
    render: () =&amp;gt; console.log('render', count),
    click: () =&amp;gt; setCount(count + 1),
    noop: () =&amp;gt; setCount(count), // 保持不变, 观察 useEffect 是否被调用
  }
}

/* 如下 mock 执行了 useEffect、render; 这里使用 React.render 的原因是为了重置 currentHook 的值 */
let comp = React.render(Counter) // useEffect 0 type hi render 0

/* 如下 mock 只执行了 render */
comp.noop()
comp = React.render(Counter) // render 0

/* 如下 mock 重新执行了 useEffect、render */
comp.click()
React.render(Counter) // useEffect 1, render 1&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;相关资源&quot;&gt;相关资源&lt;/h3&gt;
</description>
<pubDate>Sun, 12 May 2019 05:38:00 +0000</pubDate>
<dc:creator>牧云云</dc:creator>
<og:description>本文基于近段时间对 hooks 碎片化的理解作一次简单梳理, '个人博客' 。同时欢迎关注基于 hooks 构建的 UI 组件库 —— 'snake design' 。 在 class 已经融入 Re</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MuYunyun/p/10852005.html</dc:identifier>
</item>
<item>
<title>性能对比：aelf智能合约运行环境性能是evm的1000倍 - Loning</title>
<link>http://www.cnblogs.com/loning/p/10851968.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/loning/p/10851968.html</guid>
<description>&lt;ol&gt;&lt;li&gt;测试用例及代码库&lt;/li&gt;
&lt;li&gt;机器配置&lt;/li&gt;
&lt;li&gt;测试结果&lt;br/&gt;3.1 EVM&lt;br/&gt;3.2 AElf&lt;br/&gt;3.2.1 LoopDivAdd10M&lt;br/&gt;3.2.2 LoopExpNop1M&lt;/li&gt;
&lt;li&gt;测试结论&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;近期对标以太坊做了一系列针对测试，在此次测试过程中，我们发现在同一机型上，运行同样的测试用例，aelf的合约执行效率远高于以太坊EVM的合约执行效率。&lt;/p&gt;
&lt;p&gt;以太坊的合约执行效率低，一方面因为虚拟机机制和gas费规则带来的一定开销导致效率降低，另一方面因为EVM的256位设计导致合约执行效率更低。&lt;/p&gt;
&lt;p&gt;而aelf使用C#的发射机制来调用合约，并且没有多余设计，合约执行效率自然远高于以太坊的合约执行效率&lt;/p&gt;
&lt;h2 id=&quot;测试用例及代码库&quot;&gt;1.测试用例及代码库&lt;/h2&gt;
&lt;p&gt;以下是对标以太坊 loop-DivAdd-10M.json 和 loop-exp-nop-1M.json的测试情况&lt;/p&gt;
&lt;p&gt;ETH: 基于官网go实现版本&lt;br/&gt;&lt;a href=&quot;https://github.com/ethereum/go-ethereum&quot; class=&quot;uri&quot;&gt;https://github.com/ethereum/go-ethereum&lt;/a&gt; &lt;br/&gt;AELF: 基于官方C#实现版本&lt;br/&gt;&lt;a href=&quot;https://github.com/AElfProject/AElf&quot; class=&quot;uri&quot;&gt;https://github.com/AElfProject/AElf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;测试用例，对标ETH的标准测试：&lt;br/&gt;&lt;a href=&quot;https://github.com/ethereum/tests/tree/develop/src/VMTestsFiller&quot; class=&quot;uri&quot;&gt;https://github.com/ethereum/tests/tree/develop/src/VMTestsFiller&lt;/a&gt;&lt;br/&gt;对应aelf测试用例：&lt;br/&gt;&lt;a href=&quot;https://github.com/AElfProject/AElf/blob/dev/bench/AElf.Benchmark&quot; class=&quot;uri&quot;&gt;https://github.com/AElfProject/AElf/blob/dev/bench/AElf.Benchmark&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;机器配置&quot;&gt;2.机器配置&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;Test Enviornment:
OS=ubuntu 16.04
QEMU Virtual CPU, 2 CPU, 2 logical and 2 physical cores
CPU MHz: 2194.916; cache size : 16384 KB

AElf Test Environment:

BenchmarkDotNet=v0.11.5
.NET Core SDK=2.2.203
[Host] : .NET Core 2.2.4 (CoreCLR 4.6.27521.02, CoreFX 4.6.27521.01), 64bit RyuJIT DEBUG&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;测试结果&quot;&gt;3.测试结果&lt;/h2&gt;
&lt;p&gt;LoopDivAdd10M：EVM耗时为aelf的169倍，差两个数量级&lt;br/&gt;LoopExpNop1M：EVM耗时为aelf的1223倍，差三个数量级&lt;/p&gt;
&lt;h3 id=&quot;evm&quot;&gt;3.1 EVM&lt;/h3&gt;
&lt;p&gt;官方go实现版本的自带测试程序执行结果&lt;/p&gt;
&lt;p&gt;LoopDivAdd10M：14.236813572s&lt;br/&gt;LoopExpNop1M: 639.16568ms&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190426194013416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ejc4MA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;aelf&quot;&gt;3.2 AElf&lt;/h3&gt;
&lt;p&gt;LoopDivAdd10M：84.01ms&lt;br/&gt;LoopExpNop1M: 522.5us&lt;/p&gt;
&lt;h4 id=&quot;loopdivadd10m&quot;&gt;3.2.1 LoopDivAdd10M&lt;/h4&gt;
&lt;p&gt;除法加法循环一千万次&lt;/p&gt;
&lt;p&gt;方法&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public override DoubleValue LoopDivAdd(DivAddTestInput input)
{
    var r = input.X;
    for (uint i = 0; i &amp;lt; input.N; i++) 
    {
        r /= input.Y;
        r += input.K;
    }
    return new DoubleValue {Value = r};
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;new DivAddTestInput()
{
    X = 100,
    Y = 300,
    K = 500,
    N = 10000000
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果:&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190426193222110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ejc4MA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;执行结果&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;loopexpnop1m&quot;&gt;3.2.2 LoopExpNop1M&lt;/h4&gt;
&lt;p&gt;方法&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public override Int32Value LoopExpNop(PerformanceTesteInput input)
{
    for (uint i = 0; i &amp;lt; input.N; i++)
    {
    }
    return new Int32Value {Value = input.Seed};
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;new PerformanceTesteInput()
{
    Exponent = 0,
    Seed = _executeResult,
    N = 1000000
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果:&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190426193648981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ejc4MA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;执行结果&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;测试结论&quot;&gt;4.测试结论&lt;/h2&gt;
&lt;p&gt;在试验机配置相同的情况下：&lt;/p&gt;
&lt;p&gt;循环运行1000万次加法、除法测试后：&lt;/p&gt;
&lt;p&gt;以太坊EVM约需要14236.81毫秒&lt;/p&gt;
&lt;p&gt;而在aelf的节点测试中仅需84.01毫秒，高于EVM 169倍。&lt;/p&gt;
&lt;p&gt;空循环运行100万次后：&lt;/p&gt;
&lt;p&gt;以太坊EVM需要639.16毫秒&lt;/p&gt;
&lt;p&gt;而在aelf的节点测试中仅需0.5225毫秒，高于EVM 1223倍。&lt;/p&gt;
</description>
<pubDate>Sun, 12 May 2019 05:20:00 +0000</pubDate>
<dc:creator>Loning</dc:creator>
<og:description>1. 测试用例及代码库 2. 机器配置 3. 测试结果 3.1 EVM 3.2 AElf 3.2.1 LoopDivAdd10M 3.2.2 LoopExpNop1M 4. 测试结论 近期对标以太坊做</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/loning/p/10851968.html</dc:identifier>
</item>
<item>
<title>设计模式----备忘录模式 - 守望阳光01</title>
<link>http://www.cnblogs.com/liuhuimh/p/10851719.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuhuimh/p/10851719.html</guid>
<description>&lt;p&gt;&lt;span&gt;       前面说的设计模式几乎都有用到继承、接口，今天，我要说的这个设计模式，它就没有用到任何接口，也不需要抽象类，更没有复杂的继承关系，它就是备忘录模式，何为备忘录，按照现实世界的理解，备忘录就是人们在此刻记录一些东西用作未来供我们回忆想起此刻所记录的信息，大白话就是记录作用，我们今天的备忘录也是一样的道理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 备忘录，首先当然是备忘录类了，请看代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Memento
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; state;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Memento(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; state)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state =&lt;span&gt; state;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; State
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; state; }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;       这里就是一个构造函数注入和一个属性，因为我们是简化版，所以只用一个属性来替代，所谓备忘录类，就是用来保存，这里的state字段就是我们要保存的值，所以为什么State这个属性才只有get方法而没有set方法了。备忘录有了，肯定要有管理备忘录的对象啊。请看下面的代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Originator
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; state;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; State
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; state; }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; { state =&lt;span&gt; value; }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Memento CreateMemento()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Memento(state));
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SetMemento(Memento memento)
        {
            state &lt;/span&gt;=&lt;span&gt; memento.State;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Show()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;State=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; state);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;        这个对象最重要的方法就是CreateMemento方法和SetMemento方法，他们分别是创建备忘录对象保存当前状态和根据备忘录状态来恢复当前状态，看代码已经是很明显了。。。，看到这里你是否觉得哪里还少点东西呢？？备忘录对象如何保存呢？？没有备忘录对象又怎么恢复呢。。所以，接下来，我们就要创建一个保存备忘录的对象，请看代码。。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Caretaker
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Memento memento;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Memento Memento
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; memento; }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; { memento =&lt;span&gt; value; }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;        这个对象很简单，就是一个属性，这个就是用来保存备忘录对象的对象，是不是很简单，这就是所有的备忘录模式。好了，照老规矩，我们还是跑一遍演示一下是如何保存恢复备忘录模式的&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Originator o &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Originator();
            o.State &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ON&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            o.Show();

            Caretaker c &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Caretaker();
            c.Memento &lt;/span&gt;=&lt;span&gt; o.CreateMemento();
            o.State &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Off&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            o.Show();

            o.SetMemento(c.Memento);
            o.Show();

            Console.ReadLine();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;       首先我们创建了一个&lt;span&gt;Originator&lt;/span&gt;对象，我们设置它的初始状态是ON，然后显示，接下来我们创建Caretaker对象来保存初始状态为ON的&lt;span&gt;Memento&lt;/span&gt;对象，然后我们改变初始状态为Off，显示现在改变的状态，最后我们通过我们保存的备忘录对象来恢复到之前的状态然后显示出来。这就是完整的备忘录模式，我们可以看看运行结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1184927/201905/1184927-20190512114105195-2041687167.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        第一次显示状态是On，接下来是Off，最后还原成On。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       上面的那些是设计模式的框架，下面，让我们用这个框架来实现我们今天的场景：游戏存档。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        首先，我们根据上面的框架来设计我们的类型，首先是存档类（备忘录类），游戏存档，当然是存游戏角色的状态，请看代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 角色状态存储箱
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RoleStateMemento
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; vit;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; atk;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; def;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RoleStateMemento(&lt;span&gt;int&lt;/span&gt; vit, &lt;span&gt;int&lt;/span&gt; atk, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; def)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.vit =&lt;span&gt; vit;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.atk =&lt;span&gt; atk;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.def =&lt;span&gt; def;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 生命力
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Vitality
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; vit; }
            
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 攻击力
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Atthack
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; atk; }
            
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 防御力
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Defense
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; def; }
           
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;       是不是有种似曾相识的感觉呢，如果没有的话请看上面的&lt;span&gt;Memento&lt;/span&gt;类，这里我们的存档类（备忘录）有三个字段，分别是生命力、攻击力和防御力，好了，下一步就是人物类（&lt;span&gt;Originator&lt;/span&gt;）了&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; GameRole
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; vit;
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 生命力
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Vit
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; vit; }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; { vit =&lt;span&gt; value; }

        }
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; atk;
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 攻击力
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Attack
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; atk; }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; { atk =&lt;span&gt; value; }
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; def;
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 防御力
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Defense
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; def; }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; { def =&lt;span&gt; value; }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 状态显示
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; StateDisplay()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;角色当前状态：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;体力：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, vit);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;攻击力：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, atk);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;防御力：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, def);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);

        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获得初始状态
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; GetInitState()
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.vit = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.atk = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.def = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 战斗
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Fight()
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.vit = &lt;span&gt;50&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.def = &lt;span&gt;50&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.atk = &lt;span&gt;50&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 保存角色状态
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RoleStateMemento SaveState()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RoleStateMemento(vit, atk, def));
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;恢复角色状态&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RecoveryState(RoleStateMemento memento)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.vit =&lt;span&gt; memento.Vitality;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.atk =&lt;span&gt; memento.Atthack;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.def =&lt;span&gt; memento.Defense;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;       同样的道理，它我们之前也认识过了，只是多了一点东西而已，但是这些并不会影响整个备忘录的框架，所以，我们从这里由此可以得出&lt;span&gt;Originator&lt;/span&gt;类就是我们的实际业务类型，当然，我们大多数项目中一个对象（Model）几乎都是用来充当一个传值对象，不会像这样有业务逻辑在里面，在软件中这种现象它们都有专业的名词解释，我们称之为贫血模式（无业务逻辑）和充血模式（有业务逻辑），定义我最后再来说，我们先把备忘录模式，不，是游戏存档说完哈，好了备忘录的其中两个对象已经出来了，接下来第三位对象也要出来亮个相了，相信我们已经都猜到它了，没错，它就是用来保存游戏对象（备忘录对象）的对象&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 角色状态管理者
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RoleStateCaretaker
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RoleStateMemento memento;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RoleStateMemento Memento
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; memento; }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; { memento =&lt;span&gt; value; }
        }

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;       所以，上面这个对象就是个类型为&lt;span&gt;RoleStateMemento&lt;/span&gt;对象的类型。到这里，我们的游戏存档就完成了，虽然不是真实的业务场景，但是已经比备忘录模式的框架要好理解的多了，接下来我们就来实现我们的游戏存档了&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {         

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;大战Boss前&lt;/span&gt;
            GameRole lixiaoyao = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GameRole();
            lixiaoyao.GetInitState();
            lixiaoyao.StateDisplay();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存进度&lt;/span&gt;
            RoleStateCaretaker stateAdmin = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RoleStateCaretaker();
            stateAdmin.Memento &lt;/span&gt;=&lt;span&gt; lixiaoyao.SaveState();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;大战Boss时，损耗严重&lt;/span&gt;
&lt;span&gt;            lixiaoyao.Fight();
            lixiaoyao.StateDisplay();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;恢复之前状态&lt;/span&gt;
&lt;span&gt;            lixiaoyao.RecoveryState(stateAdmin.Memento);
            lixiaoyao.StateDisplay();

            Console.Read();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;        首先我们创建了一个李逍遥的角色（咳咳），这个名字随意，然后显示角色初始值，然后我们先保存我们创建的这个李逍遥对象，这样我们就可以义无反顾的去杀Boss了，由于Boss过于强大，我们损伤一半血，不行了，要撤了，不然要死了（哈哈，这里都是YY），然后我们就把我们之前的存档用来恢复，最后再显示人物血条，我们看运行结果吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1184927/201905/1184927-20190512121106883-1225170683.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         好吧，这个也是似曾相识对吧，只是内容多了点而已，好了，我们的游戏存档也完成了，两种实现备忘录的方式完全都没有用到什么继承和接口。。。，下面，我们来说说官方名词。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        备忘录模式：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态，它是一种对象行为模式，其别名为Token。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        充血模式：领域对象中包含属性和业务逻辑的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        贫血模式：领域对象中只包含属性，不包含业务逻辑的&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 12 May 2019 04:30:00 +0000</pubDate>
<dc:creator>守望阳光01</dc:creator>
<og:description>前面说的设计模式几乎都有用到继承、接口，今天，我要说的这个设计模式，它就没有用到任何接口，也不需要抽象类，更没有复杂的继承关系，它就是备忘录模式，何为备忘录，按照现实世界的理解，备忘录就是人们在此刻记</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuhuimh/p/10851719.html</dc:identifier>
</item>
<item>
<title>基于NFS的PV动态供给(StorageClass) - 渣渣辉</title>
<link>http://www.cnblogs.com/Dev0ps/p/10851802.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dev0ps/p/10851802.html</guid>
<description>&lt;h3&gt;一、简介&lt;/h3&gt;
&lt;p&gt;PersistentVolume（PV）是指由集群管理员配置提供的某存储系统上的段存储空间，它是对底层共享存储的抽象，将共享存储作为种可由用户申请使的资源，实现了“存储消费”机制。通过存储插件机制，PV支持使用多种网络存储系统或云端存储等多种后端存储系统，例如，NFS、RBD和Cinder等。PV是集群级别的资源，不属于任何名称空间，用户对PV资源的使需要通过PersistentVolumeClaim（PVC）提出的使申请（或称为声明）来完成绑定，是PV资源的消费者，它向PV申请特定大小的空间及访问模式（如rw或ro），从创建出PVC存储卷，后再由Pod资源通过PersistentVolumeClaim存储卷关联使，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201905/1271786-20190512114036149-827413477.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;尽管PVC使得用户可以以抽象的方式访问存储资源，但很多时候还是会涉及PV的不少属性，例如，由于不同场景时设置的性能参数等。为此，集群管理员不得不通过多种方式提供多种不同的PV以满不同用户不同的使用需求，两者衔接上的偏差必然会导致用户的需求无法全部及时有效地得到满足。Kubernetes从1.4版起引入了一个新的资源对象StorageClass，可用于将存储资源定义为具有显著特性的类（Class）而不是具体的PV，例如“fast”“slow”或“glod”“silver”“bronze”等。用户通过PVC直接向意向的类别发出申请，匹配由管理员事先创建的PV，或者由其按需为用户动态创建PV，这样做甚至免去了需要先创建PV的过程。&lt;br/&gt;PV对存储系统的支持可通过其插件来实现，目前，Kubernetes支持如下类型的插件。&lt;br/&gt;官方地址：&lt;a href=&quot;https://kubernetes.io/docs/concepts/storage/storage-classes/&quot; target=&quot;_blank&quot;&gt;https://kubernetes.io/docs/concepts/storage/storage-classes/&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201905/1271786-20190512114211613-2095641402.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由上图我们可以看到官方插件是不支持NFS动态供给的，但是我们可以用第三方的插件来实现，下面就是本文要讲的。&lt;/p&gt;
&lt;h3&gt;二、安装NFS插件&lt;/h3&gt;
&lt;p&gt;GitHub地址：&lt;a href=&quot;https://github.com/kubernetes-incubator/external-storage/tree/master/nfs/deploy/kubernetes&quot; target=&quot;_blank&quot;&gt;https://github.com/kubernetes-incubator/external-storage/tree/master/nfs/deploy/kubernetes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201905/1271786-20190512114858098-567984359.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.1创建RBAC授权&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@master storage-class]# cat rbac.yaml 
apiVersion: v1
kind: ServiceAccount
metadata:
  name: nfs-client-provisioner

---

kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: nfs-client-provisioner-runner
rules:
  - apiGroups: [&quot;&quot;]
    resources: [&quot;persistentvolumes&quot;]
    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;delete&quot;]
  - apiGroups: [&quot;&quot;]
    resources: [&quot;persistentvolumeclaims&quot;]
    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;update&quot;]
  - apiGroups: [&quot;storage.k8s.io&quot;]
    resources: [&quot;storageclasses&quot;]
    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]
  - apiGroups: [&quot;&quot;]
    resources: [&quot;events&quot;]
    verbs: [&quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;update&quot;, &quot;patch&quot;]

---

kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: run-nfs-client-provisioner
subjects:
  - kind: ServiceAccount
    name: nfs-client-provisioner
    namespace: default
roleRef:
  kind: ClusterRole
  name: nfs-client-provisioner-runner
  apiGroup: rbac.authorization.k8s.io
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 2.2 创建Storageclass类&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@master storage-class]# cat storageclass-nfs.yaml 
apiVersion: storage.k8s.io/v1beta1
kind: StorageClass
metadata:
  name: managed-nfs-storage
provisioner: fuseim.pri/ifs
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 2.3 创建nfs的deployment，修改相应的nfs服务器ip及挂载路径即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@master storage-class]# cat deployment-nfs.yaml 
apiVersion: apps/v1beta1 
kind: Deployment
metadata:
  name: nfs-client-provisioner
spec:
  replicas: 1
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: nfs-client-provisioner
    spec:
      imagePullSecrets:
        - name: registry-pull-secret
      serviceAccount: nfs-client-provisioner
      containers:
        - name: nfs-client-provisioner
          image: lizhenliang/nfs-client-provisioner:v2.0.0
          volumeMounts:
            - name: nfs-client-root
              mountPath: /persistentvolumes
          env:
            - name: PROVISIONER_NAME
              value: fuseim.pri/ifs
            - name: NFS_SERVER
              value: 172.31.182.145
            - name: NFS_PATH
              value: /u01/nps/volumes
      volumes:
        - name: nfs-client-root
          nfs:
            server: 172.31.182.145 
            path: /u01/nps/volumes
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201905/1271786-20190512115527318-1313143017.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;三、创建一个PV动态供给应用实例&lt;/h3&gt;
&lt;p&gt;下面是一个StatefulSet应用动态申请PV的示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201905/1271786-20190512115738467-54578202.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 例如：创建一个nginx动态获取PV&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@master storage-class]# cat nginx-demo.yaml 
apiVersion: v1
kind: Service
metadata:
  name: nginx
  labels:
    app: nginx
spec:
  ports:
  - port: 80
    name: web
  clusterIP: None
  selector:
    app: nginx
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: web
spec:
  selector:
    matchLabels:
      app: nginx
  serviceName: &quot;nginx&quot;
  replicas: 3
  template:
    metadata:
      labels:
        app: nginx
    spec:
      terminationGracePeriodSeconds: 10
      containers:
      - name: nginx
        image: nginx 
        ports:
        - containerPort: 80
          name: web
        volumeMounts:
        - name: www
          mountPath: /usr/share/nginx/html
  volumeClaimTemplates:
  - metadata:
      name: www
    spec:
      accessModes: [ &quot;ReadWriteOnce&quot; ]
      storageClassName: &quot;managed-nfs-storage&quot;
      resources:
        requests:
          storage: 1Gi
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 启动后我们可以看到以下信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201905/1271786-20190512120545936-809434261.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时我们在nfs服务器上也会看到自动生成3个挂载目录，当pod删除了数据还会存在。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201905/1271786-20190512121154239-2055837626.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;StatefulSet应用有以下特点：&lt;/p&gt;
&lt;p&gt;1.唯一的网络标识&lt;/p&gt;
&lt;p&gt;2.域名访问(&amp;lt;statefulsetName-index&amp;gt;.&amp;lt;service-name&amp;gt;.svc.cluster.local) 如：web-0.nginx.default.svc.cluster.local&lt;/p&gt;
&lt;p&gt;3.独立的持久存储&lt;/p&gt;
&lt;p&gt;4.有序的部署和删除&lt;/p&gt;

</description>
<pubDate>Sun, 12 May 2019 04:13:00 +0000</pubDate>
<dc:creator>渣渣辉</dc:creator>
<og:description>一、简介 PersistentVolume（PV）是指由集群管理员配置提供的某存储系统上的段存储空间，它是对底层共享存储的抽象，将共享存储作为种可由用户申请使的资源，实现了“存储消费”机制。通过存储插</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Dev0ps/p/10851802.html</dc:identifier>
</item>
<item>
<title>广度优先搜索（BFS）思路及算法分析 - 脑热</title>
<link>http://www.cnblogs.com/Unicron/p/10850236.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Unicron/p/10850236.html</guid>
<description>&lt;p&gt;&lt;span&gt;是一种图像搜索演算法。用于遍历图中的节点，有些类似于&lt;span&gt;树的深度优先遍历。这里唯一的问题是，与树不同，图形可能包含循环，因此我们可能会再次来到同一节点。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;主要借助一个队列、一个布尔类型数组、邻接矩阵完成（判断一个点是否查看过，用于避免重复到达同一个点，造成死循环等），先将各点以及各点的关系存入邻接矩阵。&lt;/p&gt;
&lt;p&gt;再从第一个点开始，将一个点存入队列，然后在邻接表中找到他的相邻点，存入队列，每次pop出队列头部并将其打印出来（文字有些抽象，实际过程很简单），整个过程有点像往水中投入石子水花散开。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1462891/201905/1462891-20190511214855686-311058182.gif&quot; alt=&quot;&quot; width=&quot;664&quot; height=&quot;449&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1462891/201905/1462891-20190511202525712-1667763124.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（邻接表是表示了图中与每一个顶点相邻的边集的集合，这里的集合指的是无序集）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1462891/201905/1462891-20190511203901267-154596554.png&quot; alt=&quot;&quot; width=&quot;430&quot; height=&quot;267&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(以上图为例的代码）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; java.util.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;This class represents a directed graph using adjacency list 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;representation &lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Graph1 {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; V; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; No. of vertices&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; LinkedList&amp;lt;Integer&amp;gt; adj[]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Adjacency Lists
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Constructor&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     Graph1(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; v) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         V =&lt;span&gt; v;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         adj = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LinkedList[v];
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; v; ++&lt;span&gt;i)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             adj[i] = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LinkedList();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Function to add an edge into the graph&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; addEdge(&lt;span&gt;int&lt;/span&gt; v, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; w) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        adj[v].add(w);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; prints BFS traversal from a given source s&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; BFS() {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Mark all the vertices as not visited(By default
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; set as false)&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; visited[] = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt;[V];
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Create a queue for BFS&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         LinkedList&amp;lt;Integer&amp;gt; queue = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;Integer&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; V; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;visited[i]) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                BFSUtil(i, visited, queue);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BFSUtil(&lt;span&gt;int&lt;/span&gt; s, &lt;span&gt;boolean&lt;/span&gt; visited[], LinkedList&amp;lt;Integer&amp;gt;&lt;span&gt; queue) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Mark the current node as visited and enqueue it&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;         visited[s] = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        queue.add(s);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (queue.size() != 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Dequeue a vertex from queue and print it&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;             s =&lt;span&gt; queue.poll();
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             System.out.print(s + &quot; &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Get all adjacent vertices of the dequeued vertex s
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; If a adjacent has not been visited, then mark it
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; visited and enqueue it&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;             Iterator&amp;lt;Integer&amp;gt; i =&lt;span&gt; adj[s].listIterator();
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (i.hasNext()) {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; n =&lt;span&gt; i.next();
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;visited[n]) {
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                     visited[n] = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;                    queue.add(n);
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Driver method to&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args[]) {
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;         Graph1 g = &lt;span&gt;new&lt;/span&gt; Graph1(4&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; 
&lt;span&gt;65&lt;/span&gt;         g.addEdge(0, 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;         g.addEdge(0, 2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;         g.addEdge(1, 2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;         g.addEdge(2, 0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;         g.addEdge(2, 3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;         g.addEdge(3, 3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; 
&lt;span&gt;72&lt;/span&gt;         System.out.println(&quot;Following is Breadth First Traversal &quot; + &quot;(starting from vertex 2)&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; &lt;span&gt;        g.BFS();
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;算法借助了一个邻接表和队列，故它的空问复杂度为O(V）。 遍历图的过程实质上是对每个顶点查找其邻接点的过程，其耗费的时间取决于所采用结构。 邻接表表示时，查找所有顶点的邻接点所需时间为O(E)，访问顶点的邻接点所花时间为O（V）,此时，总的时间复杂度为O(V+E)。&lt;/p&gt;
</description>
<pubDate>Sun, 12 May 2019 04:12:00 +0000</pubDate>
<dc:creator>脑热</dc:creator>
<og:description>1、算法用途： 是一种图像搜索演算法。用于遍历图中的节点，有些类似于树的深度优先遍历。这里唯一的问题是，与树不同，图形可能包含循环，因此我们可能会再次来到同一节点。 2、主要思想： 主要借助一个队列、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Unicron/p/10850236.html</dc:identifier>
</item>
</channel>
</rss>