<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>软件设计的哲学：第十七章 一致性 - peida</title>
<link>http://www.cnblogs.com/peida/p/12110689.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/peida/p/12110689.html</guid>
<description>&lt;p&gt;一致性是降低系统复杂性和使其行为更加明显的强大工具。如果&lt;strong&gt;一个系统是一致的，这意味着相似的事情以相似的方式完成，而不同的事情以不同的方式完成。&lt;/strong&gt; 一致性创造了认知杠杆：一旦你学会了在一个地方如何做某件事，你就可以利用这些知识立即理解其他使用相同方法的地方。如果系统没有以一致的方式实现，开发人员必须分别了解每种情况。这需要更多的时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一致性可以减少错误。&lt;/strong&gt; 如果一个系统是不一致的，两种情况可能看起来是相同的，但实际上它们是不同的。开发人员可能会看到一个看起来很熟悉的模式，并根据之前遇到的模式做出错误的假设。另一方面，如果系统是一致的，基于熟悉的情况做出的假设将是安全的。一致性使开发人员工作更快，错误更少。&lt;/p&gt;
&lt;h2 id=&quot;一致性的例子&quot;&gt;17.1一致性的例子&lt;/h2&gt;
&lt;p&gt;一致性可以应用于系统的多个级别。这里有几个例子：&lt;br/&gt;&lt;strong&gt;命名：&lt;/strong&gt; 第14章已经讨论了以一致的方式使用名称的好处。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编码风格：&lt;/strong&gt; 现在开发组织通常有样式指南，它将程序结构限制在编译器强制执行的规则之外。现代风格指南解决了一系列问题，比如缩进、大括号放置、声明顺序、命名、注释和对被认为是危险的语言特性的限制。样式指南使代码更容易阅读，并可以减少某些类型的错误。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接口：&lt;/strong&gt; 具有多个实现的接口是一致性的另一个例子。一旦您理解了接口的一个实现，任何其他实现都会变得更容易理解，因为您已经知道它必须提供的特性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设计模式：&lt;/strong&gt; 设计模式是某些常见问题的普遍接受的解决方案，例如用户界面设计的模型-视图-控制器方法。如果您可以使用现有的设计模式来解决这个问题，那么实现将会进行得更快，更有可能工作，而且您的代码对读者来说也更容易理解。设计模式将在第19.5节中详细讨论。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不变量：&lt;/strong&gt; 不变量是变量或结构的一个总是为真的属性。例如，存储文本行的数据结构可能强制一个不变式，即每行以换行字符结束。不变量减少了必须在代码中考虑的特殊情况的数量，使对代码的行为进行推理变得更容易。&lt;/p&gt;
&lt;h2 id=&quot;确保一致性&quot;&gt;17.2 确保一致性&lt;/h2&gt;
&lt;p&gt;一致性很难保持，特别是当许多人长时间从事一个项目时。一组人可能不知道另一组人建立的惯例。新来者不知道这些规则，所以他们无意中违反了这些约定，并创建了与现有约定冲突的新约定。以下是一些建立和保持一致性的建议:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文档：&lt;/strong&gt; 创建一个文档，列出最重要的总体约定，比如编码风格指南。将文档放置在开发人员可能看到的位置，例如项目Wiki上的显眼位置。鼓励新加入团队的人阅读文档，并鼓励现有的人每隔一段时间就阅读一次。各种组织的一些风格指南已经在网上发布;考虑从其中之一开始。&lt;/p&gt;
&lt;p&gt;对于更本地化的约定(如不变量)，请在代码中找到适当的位置来记录它们。如果你不把这些惯例写下来，其他人就不太可能遵循它们。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;强制规约：&lt;/strong&gt; 即使有很好的文档，开发人员也很难记住所有的约定。执行约定的最佳方法是编写一个检查违规的工具，并确保代码不能提交到存储库，除非它通过了检查器。自动检查器对于低级语法约定特别有效。&lt;/p&gt;
&lt;p&gt;我最近的一个项目有行终止字符的问题。一些开发人员在Unix上工作，行被换行终止;其他的工作在Windows上，行通常由一个carriage-return后跟一个换行来结束。如果一个系统上的开发人员对先前在另一个系统上编辑过的文件进行了小的编辑，那么编辑器有时会将所有行终止符替换为适合该系统的行终止符。这给人的感觉是文件的每一行都被修改了，这使得跟踪有意义的更改变得很困难。我们建立了一个约定，即文件应该只包含换行，但是很难确保每个开发人员使用的每个工具都遵循这个约定。每当一个新的开发人员加入这个项目，我们就会经历一连串的线路终止问题，而那个开发人员就会适应这个约定。&lt;/p&gt;
&lt;p&gt;我们最终通过编写一个简短的脚本解决了这个问题，这个脚本在将更改提交到源代码存储库之前自动执行。该脚本检查所有已修改的文件，如果其中任何一个包含回车，则将中止提交。该脚本还可以手动运行，以修复损坏的文件，方法是用换行替换载波返回/换行序列。&lt;/p&gt;
&lt;p&gt;这立即消除了问题，并帮助培训了新的开发人员。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码审查为执行约定和对新开发人员进行约定教育提供了另一个机会。&lt;/strong&gt; 代码评审人员越是吹毛求疵，团队中的每个人就会越快地了解约定，代码就会越干净。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;入乡随俗：&lt;/strong&gt; 最重要的惯例是，每个开发人员都应该遵循这句古老的格言“入乡随俗”。在处理新文件时，请查看现有代码的结构。是否所有的公共变量和方法都在私有变量和方法之前声明?这些方法是按字母顺序排列的吗?变量在firstServerName中使用“camel case”还是在first_server_name中使用“snake case”?当你看到任何看起来可能是约定的东西时，跟着它走。在做设计决策时，问问自己是否在项目的其他地方也做了类似的决策;如果是，找到一个现有的示例，并在新代码中使用相同的方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不要改变现有的惯例&lt;/strong&gt; 抵制“改进”现有公约的冲动。有一个“更好的主意”并不足以成为产生矛盾的借口。你的新想法可能确实更好，但是一致性对不一致性的价值几乎总是大于一种方法对另一种方法的价值。在引入不一致的行为之前，问自己两个问题。首先，您是否有重要的新信息来证明您的方法是正确的，而这在旧的约定建立时是没有的?第二，新方法是否更好，值得花时间更新所有旧的用法?如果您的组织认为这两个问题的答案都是“是”，那么就继续进行升级;当你完成的时候，应该没有任何旧的惯例的迹象。但是，您仍然面临其他开发人员不知道新约定的风险，因此他们可能在将来重新引入旧的方法。总的来说，重新考虑已建立的约定很少能很好地利用开发人员的时间。&lt;/p&gt;
&lt;h2 id=&quot;别做过了头&quot;&gt;17.3 别做过了头&lt;/h2&gt;
&lt;p&gt;一致性不仅意味着相似的事情应该以相似的方式去做，还意味着不同的事情应该以不同的方式去做。如果您过于热衷于一致性，并试图强制将不同的东西放在相同的方法中，例如对真正不同的东西使用相同的变量名，或者对不适合该模式的任务使用现有的设计模式，那么您将创建复杂性和混乱。只有当开发人员确信“如果它看起来像x，那么它实际上就是x”时，一致性才会带来好处。&lt;/p&gt;
&lt;h2 id=&quot;结论&quot;&gt;17.4 结论&lt;/h2&gt;
&lt;p&gt;一致性是投资心态的另一个例子。&lt;strong&gt;确保一致性需要一些额外的工作：决定约定的工作、创建自动检查器的工作、寻找类似的情况以在新代码中模拟的工作，以及在代码评审中培训团队的工作。&lt;/strong&gt; 这种投资的回报是您的代码将更加明显。开发人员将能够更快、更准确地理解代码的行为，这将使他们工作得更快，bug更少。&lt;/p&gt;
</description>
<pubDate>Fri, 27 Dec 2019 23:17:00 +0000</pubDate>
<dc:creator>peida</dc:creator>
<og:description>确保一致性需要一些工作：决定约定的工作、创建自动检查器的工作、寻找类似的情况以在新代码中模拟的工作，以及在代码评审中培训团队的工作。 这种投资的回报是您的代码将更加明显。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/peida/p/12110689.html</dc:identifier>
</item>
<item>
<title>Kafka Eagle安装详情及问题解答 - 哥不是小萝莉</title>
<link>http://www.cnblogs.com/smartloli/p/12110570.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smartloli/p/12110570.html</guid>
<description>&lt;p&gt;最近有很多同学给笔者留言，说在安装&lt;a href=&quot;http://www.kafka-eagle.org/&quot; target=&quot;_blank&quot;&gt;Kafka Eagle&lt;/a&gt;的时候，会遇到一些问题，请教如何解决？今天笔者就在这里总结一下安装步骤，和一些安装的注意事项，以及解决方式。&lt;/p&gt;

&lt;p&gt;在安装Kafka Eagle之前，可能新接触的同学对Kafka Eagle不太了解，那我们现在简要介绍一下Kafka Eagle。&lt;/p&gt;
&lt;p&gt;源代码地址：&lt;a href=&quot;https://github.com/smartloli/kafka-eagle&quot; target=&quot;_blank&quot;&gt;https://github.com/smartloli/kafka-eagle&lt;/a&gt; （感兴趣的同学可以关注一波）&lt;/p&gt;
&lt;h2&gt;2.1 Kafka Eagle是什么？&lt;/h2&gt;
&lt;p&gt;Kafka Eagle是一款用于监控和管理Apache Kafka的完全开源系统，目前托管在&lt;a href=&quot;https://github.com/smartloli/kafka-eagle&quot; target=&quot;_blank&quot;&gt;Github&lt;/a&gt;，由笔者和一些开源爱好者共同维护。它提供了完善的管理页面，很方面的去管理和可视化Kafka集群的一些信息，例如Broker详情、性能指标趋势、Topic集合、消费者信息等。&lt;/p&gt;
&lt;p&gt;同时，兼容若干Kafka版本，例如0.8，0.9，...，以及截止到2019-12-16最新发布的2.4.0版本。&lt;/p&gt;
&lt;h2&gt;2.2 Kafka Eagle包含哪些功能？&lt;/h2&gt;
&lt;p&gt;Kafka Eagle监控管理系统，提供了一个可视化页面，使用者可以拥有不同的角色，例如管理员、开发者、游客等。不同的角色对应不同的使用权限。在知道了Kafka Eagle的作用之后，那么它包含哪些功能呢？核心功能如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201912/666745-20191228023437457-685783590.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 2.2.1 数据面板&lt;/h3&gt;

&lt;p&gt; 负责展示Kafka集群的Broker数、Topic数、Consumer数、以及Topic LogSize Top10和Topic Capacity Top10数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201912/666745-20191228023803063-1380926828.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 2.2.2 主题&lt;/h3&gt;
&lt;p&gt;该模块包含主题创建、主题管理、主题预览、KSQL查询主题、主题数据写入、主题属性配置等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201912/666745-20191228024145608-1790749208.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 2.2.3 消费者组&lt;/h3&gt;
&lt;p&gt;该模块包含监控不同消费者组中的Topic被消费的详情，例如LogSize、Offsets、以及Lag等。同时，支持查看Lag的历史趋势图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201912/666745-20191228024319107-645294098.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 2.2.4 集群管理&lt;/h3&gt;
&lt;p&gt;该模块包含Kafka集群和Zookeeper集群的详情展示，例如Kafka的IP和端口、版本号、启动时间、Zookeeper的Leader和Follower。同时，还支持多Kafka集群切换，以及Zookeeper Client数据查看等功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201912/666745-20191228024554167-400318464.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2.2.5 指标监控&lt;/h3&gt;
&lt;p&gt;该模块包含监控Kafka集群和Zookeeper集群的核心指标，包含Kafka的消息发送趋势、消息大小接收与发送趋势、Zookeeper的连接数趋势等。同时，还支持查看Broker的瞬时指标数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201912/666745-20191228024716582-1435215404.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2.2.6 告警&lt;/h3&gt;
&lt;p&gt;该模块包含告警集群异常和消费者应用Lag异常。同时，支持多种IM告警方式，例如邮件、钉钉、微信、Webhook等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201912/666745-20191228024946764-814360185.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2.2.7 系统管理&lt;/h3&gt;
&lt;p&gt;该模块包含用户管理，例如创建用户、用户授权、资源管理等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201912/666745-20191228025105101-982142100.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2.2.8 数据大屏&lt;/h3&gt;
&lt;p&gt;该模块包含展示消费者和生产者当日及最近7天趋势、Kafka集群读写速度、Kafka集群历史总记录等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201912/666745-20191228025148431-2021316669.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;Kafka Eagle安装部署非常方便，可以从&lt;a href=&quot;http://www.kafka-eagle.org/&quot; target=&quot;_blank&quot;&gt;官网&lt;/a&gt;下载最新版本进行安装，或者从Github下载最新的Release源代码进行编译安装。&lt;/p&gt;
&lt;p&gt;例如，从官网下载Kafka Eagle安装包，按如下命令操作即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 解压安装包&lt;br/&gt;tar&lt;/span&gt; -zxvf kafka-eagle-v1.&lt;span&gt;4.2&lt;/span&gt;-bin.&lt;span&gt;tar&lt;/span&gt;.gz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，是配置环境变量，这里需要注意的是，KE_HOME和JAVA_HOME均需在环境变量文件中进行配置（建议在~/.bash_profile文件中进行设置好，否则，可能在启动的时候抛出环境变量找不到的错误），配置内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 配置JAVA_HOME和KE_HOME：
&lt;/span&gt;&lt;span&gt;vi&lt;/span&gt; ~/&lt;span&gt;.bash_profile
export JAVA_HOME&lt;/span&gt;=/hadoop/&lt;span&gt;jdk8
export KE_HOME&lt;/span&gt;=/hadoop/kafka-&lt;span&gt;eagle
export PATH&lt;/span&gt;=$PATH:$JAVA_HOME/bin:$KE_HOME/bin
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来是配置Kafka Eagle的系统文件，这里需要注意一些事项，配置内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;######################################
# 设置Kafka多集群，这里只需要设置Zookeeper,
# 系统会自动识别Kafka Broker
######################################
kafka.eagle.zk.cluster.alias&lt;/span&gt;=&lt;span&gt;cluster1
cluster1.zk.list&lt;/span&gt;=&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;2181&lt;/span&gt;&lt;span&gt;
cluster2.zk.list&lt;/span&gt;=&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;2181&lt;/span&gt;/&lt;span&gt;plain
cluster3.zk.list&lt;/span&gt;=&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;2181&lt;/span&gt;/&lt;span&gt;scram
cluster4.zk.list&lt;/span&gt;=vmn4:&lt;span&gt;2181&lt;/span&gt;&lt;span&gt;

######################################
# Zookeeper线程池最大连接数
######################################
kafka.zk.limit.size&lt;/span&gt;=&lt;span&gt;25&lt;/span&gt;&lt;span&gt;

######################################
# Kafka Eagle的页面访问端口
######################################
kafka.eagle.webui.port&lt;/span&gt;=&lt;span&gt;8048&lt;/span&gt;&lt;span&gt;

######################################
# 存储消费信息的类型，一般在0.9版本之前，消费
# 信息会默认存储在Zookeeper中，所以存储类型
# 设置zookeeper即可，如果是在0.10版本之后，
# 消费者信息默认存储在Kafka中，所以存储类型
# 设置为kafka。而且，在使用消费者API时，尽量
# 客户端Kafka API版本和Kafka服务端的版本保持
# 一致性。
######################################
cluster1.kafka.eagle.offset.storage&lt;/span&gt;=&lt;span&gt;kafka
cluster2.kafka.eagle.offset.storage&lt;/span&gt;=&lt;span&gt;kafka
#cluster3.kafka.eagle.offset.storage&lt;/span&gt;=&lt;span&gt;kafka
cluster4.kafka.eagle.offset.storage&lt;/span&gt;=&lt;span&gt;kafka

######################################
# 开启性能监控，数据默认保留30天
######################################
kafka.eagle.metrics.charts&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
kafka.eagle.metrics.retain&lt;/span&gt;=&lt;span&gt;30&lt;/span&gt;&lt;span&gt;


######################################
# KSQL查询Topic数据默认是最新的5000条，如果
# 在使用KSQL查询的过程中出现异常，可以将下面
# 的false属性修改为true，Kafka Eagle会在
# 系统中自动修复错误。
######################################
kafka.eagle.sql.topic.records.max&lt;/span&gt;=&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;
kafka.eagle.sql.fix.error&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;

######################################
# 删除Kafka Topic时需要输入删除密钥，由
# 管理员执行
######################################
kafka.eagle.topic.token&lt;/span&gt;=&lt;span&gt;keadmin

######################################
# 开启Kafka ACL特性，例如SCRAM或者PLAIN，
# 一般生产环境会使用SCRAM来做ACL，应为SCRAM
# 可以动态创建和管理用户。
######################################
cluster1.kafka.eagle.sasl.enable&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
cluster1.kafka.eagle.sasl.protocol&lt;/span&gt;=&lt;span&gt;SASL_PLAINTEXT
cluster1.kafka.eagle.sasl.mechanism&lt;/span&gt;=SCRAM-SHA-&lt;span&gt;256&lt;/span&gt;&lt;span&gt;
cluster1.kafka.eagle.sasl.jaas.config&lt;/span&gt;=org.apache.kafka.common.security.scram.ScramLoginModule required username=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; password=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin-secret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
cluster1.kafka.eagle.sasl.client.&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;=&lt;span&gt;

cluster2.kafka.eagle.sasl.enable&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
cluster2.kafka.eagle.sasl.protocol&lt;/span&gt;=&lt;span&gt;SASL_PLAINTEXT
cluster2.kafka.eagle.sasl.mechanism&lt;/span&gt;=&lt;span&gt;PLAIN
cluster2.kafka.eagle.sasl.jaas.config&lt;/span&gt;=org.apache.kafka.common.security.plain.PlainLoginModule required username=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; password=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin-secret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
cluster2.kafka.eagle.sasl.client.&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;=&lt;span&gt;

######################################
# 存储Kafka Eagle元数据信息的数据库，目前支持
# MySQL和Sqlite，默认使用Sqlite进行存储
######################################
kafka.eagle.driver&lt;/span&gt;=&lt;span&gt;com.mysql.jdbc.Driver
kafka.eagle.url&lt;/span&gt;=jdbc:mysql:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1:3306/ke?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;zeroDateTimeBehavior=convertToNull&lt;/span&gt;
kafka.eagle.username=&lt;span&gt;root
kafka.eagle.password&lt;/span&gt;=&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;

#kafka.eagle.driver&lt;/span&gt;=&lt;span&gt;org.sqlite.JDBC
#kafka.eagle.url&lt;/span&gt;=jdbc:sqlite:/Users/dengjie/webserver/hadoop/sqlite/&lt;span&gt;ke.db
#kafka.eagle.username&lt;/span&gt;=&lt;span&gt;root
#kafka.eagle.password&lt;/span&gt;=root
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后是启动，执行命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 启动Kafka Eagle系统，执行如下命令：
ke.&lt;/span&gt;&lt;span&gt;sh&lt;/span&gt; start
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同时，我们还可以执行其他的命令，参数如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 查看Kafka Eagle运行状态
ke.&lt;/span&gt;&lt;span&gt;sh&lt;/span&gt;&lt;span&gt; status

# 停止Kafka Eagle
ke.&lt;/span&gt;&lt;span&gt;sh&lt;/span&gt;&lt;span&gt; stop

# 查看Kafka Eagle GC情况
ke.&lt;/span&gt;&lt;span&gt;sh&lt;/span&gt;&lt;span&gt; gc

# 查看Kafka Eagle服务器资源占用情况，例如TCP、句柄等
ke.&lt;/span&gt;&lt;span&gt;sh&lt;/span&gt;&lt;span&gt; stats

# 查看Kafka Eagle版本号
ke.&lt;/span&gt;&lt;span&gt;sh&lt;/span&gt;&lt;span&gt; version

# 查看Kafka Eagle服务器上JDK的编码情况（如果JDK编码不是UTF&lt;/span&gt;-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;，可能会有异常出现，执行如下命令，根据提示来修复JDK编码问题）
ke.&lt;/span&gt;&lt;span&gt;sh&lt;/span&gt;&lt;span&gt; jdk

# 查看Kafka Eagle中是否存在某个类（如果需要精确，类名前面可以加上包名）
ke.&lt;/span&gt;&lt;span&gt;sh&lt;/span&gt; &lt;span&gt;find&lt;/span&gt; [ClassName]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;总的来说，Kafka Eagle提供了简单、易用的页面，部署方便。同时，提供非常详细的&lt;a href=&quot;https://docs.kafka-eagle.org/&quot; target=&quot;_blank&quot;&gt;操作手册&lt;/a&gt;，根据官网提供的操作手册来安装Kafka Eagle，一般都可以正常使用。另外，有时候可能会在日志中发现一些连接超时或是空指针异常，对于这类问题，首先需要检测Kafka集群的各个Broker节点JMX_PORT是否开启（这个Kafka默认是不开启），然后就是空指针异常问题，这类问题通常发生在Kafka集群配置了ACL，这就需要认真检测Kafka Eagle配置文件中ACL信息是否正确（比如设置的用户名和密码是否正确，以及用户是否拥有访问Topic的权限等）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;vi&lt;/span&gt; kafka-server-start.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt;
...
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x$KAFKA_HEAP_OPTS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt;&lt;span&gt;
    export KAFKA_HEAP_OPTS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-server -Xms8G -Xmx8G -XX:PermSize=128m -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -XX:ParallelGCThreads=8 -XX:ConcGCThreads=5 -XX:InitiatingHeapOccupancyPercent=70&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    # 开启JMX_PORT端口，端口开启后，Kafka Eagle系统会自动感知获取
    export JMX_PORT&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;9999&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    # 注释脚本中默认的信息
    # export KAFKA_HEAP_OPTS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-Xmx1G -Xms1G&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果大家对Kafka Eagle感兴趣，可以关注一波。后续，在Github上笔者也会公布每个版本的开发计划，修复大家在issues上面提的需求和问题，将Kafka Eagle建设的更加完善、易用。&lt;/p&gt;
&lt;p&gt;Kafka Eagle源代码地址：&lt;a href=&quot;https://github.com/smartloli/kafka-eagle&quot;&gt;https://github.com/smartloli/kafka-eagle&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这篇博客就和大家分享到这里，如果大家在研究学习的过程当中有什么问题，可以加群进行讨论或发送邮件给我，我会尽我所能为您解答，与君共勉！&lt;/p&gt;
&lt;p&gt;另外，博主出书了《&lt;a href=&quot;https://item.jd.com/12455361.html&quot; target=&quot;_blank&quot;&gt;Kafka并不难学&lt;/a&gt;》和《&lt;a href=&quot;https://item.jd.com/12371763.html&quot; target=&quot;_blank&quot;&gt;Hadoop大数据挖掘从入门到进阶实战&lt;/a&gt;》，喜欢的朋友或同学， 可以在公告栏那里点击购买链接购买博主的书进行学习，在此感谢大家的支持。关注下面公众号，根据提示，可免费获取书籍的教学视频。 &lt;/p&gt;
</description>
<pubDate>Fri, 27 Dec 2019 19:22:00 +0000</pubDate>
<dc:creator>哥不是小萝莉</dc:creator>
<og:description>1.概述 最近有很多同学给笔者留言，说在安装Kafka Eagle的时候，会遇到一些问题，请教如何解决？今天笔者就在这里总结一下安装步骤，和一些安装的注意事项，以及解决方式。 2.内容 在安装Kafk</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/smartloli/p/12110570.html</dc:identifier>
</item>
<item>
<title>Linux网络文件共享服务之FTP - qiuhom</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/12106900.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/12106900.html</guid>
<description>&lt;p&gt;　　一、FTP介绍&lt;/p&gt;
&lt;p&gt;　　ftp（File Transfer Protocol）是早期的三个应用级协议之一，基于C/S结构，双通道协议，数据和命令连接，数据传输格式默认是二进制，当然也支持文件方式传输。默认情况下FTP协议使用TCP端口中的21和20这两个端口，其中20用于数据传输，21用作命令传输，但是20号端口是否作为数据传输的端口，这与FTP使用的传输模式有关，从FTP服务器的角度讲，FTP传输数据的模式分为主动模式和被动模式。主动模式就是服务器主动去连接客户端，被动模式就是客户端去连接服务器。不管FTP服务器工作在那个模式下，它的命令控制端口都监听在ftp服务器的tcp21端口，而主动模式（PORT）中数据传输端口是ftp服务器的20号端口去连接客户端的一个随机端口来传输数据，在被动模式（PASV）是客户端的一个随机端口去连接FTP服务端的一个随机端口，这样一来各位可能会有一个疑问就是在被动模式中，客户端怎么知道去连接那个端口和服务器连接传输数据呢？双方的随机端口怎么确认呢？它的工作流程是这样的，在被动模式中我们知道命令控制端口是连接FTP服务器的21号端口（这是默认情况，不更改其监听的端口），客户端连接服务端的时候就会和服务端协商，到底哪个端口来当做数据传输的端口啊，事实上被动模式或主动模式中数据传输端口是通过命令链路双方协商好的，主动模式的数据传输端口是通过命令连接告诉给服务端的，这样一来当我们需要下载数据时，服务端会以20端口去连接客户端的一个协商好的端口，同理被动模式中，数据端口也是双方协商好了 的，在我们下载数据时，客户端会以一个随机端口去连接协商好的那个服务端的端口。&lt;/p&gt;
&lt;p&gt;　　服务器被动模式数据端口示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#ftp 192.168.0.99
Connected to 192.168.0.99 (192.168.0.99).
220 (vsFTPd 3.0.2)
Name (192.168.0.99:root): ftp
331 Please specify the password.
Password:
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp&amp;gt; ls
227 Entering Passive Mode (192,168,0,99,43,241).
150 Here comes the directory listing.
drwxr-xr-x    2 0        0               6 Oct 30  2018 pub
226 Directory send OK.
ftp&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明:我们可以看到消息状态为227的告诉我们被动模式（192.168.0.99，43，241）这是什么意思呢，其实它这就是告诉客户端我们连接服务端的那个端口，它的计算方式是这样的，以上为例它会去连接服务端的11249，这个端口就是通过43*256+241得来的，每传输一次数据都会写上好一个数据端口，这就是ftp工作在被动模式的端口确定方式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
227 Entering Passive Mode (192,168,0,99,201,83).
150 Here comes the directory listing.
-rw-r--r--    1 0        0        1073741824 Dec 27 04:25 bigfile
226 Directory send OK.
ftp&amp;gt; ! ss -nt
State      Recv-Q Send-Q              Local Address:Port                             Peer Address:Port              
ESTAB      0      0                    192.168.0.99:51838                            192.168.0.99:21                 
ESTAB      0      0                    192.168.0.99:59860                            192.168.0.99:3306               
ESTAB      0      0                    192.168.0.99:3306                             192.168.0.99:59860              
ESTAB      0      0                    192.168.0.99:41319                           192.168.0.232:1678               
ESTAB      0      216                  192.168.0.99:41319                           192.168.0.232:1616               
ESTAB      0      0             ::ffff:192.168.0.99:21                        ::ffff:192.168.0.99:51838              
ftp&amp;gt; get bigfile
local: bigfile remote: bigfile
227 Entering Passive Mode (192,168,0,99,247,183).
150 Opening BINARY mode data connection for bigfile (1073741824 bytes).
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：可看到数据链路上是客户端的一个随机端口连接服务端的21 端口 ，在下载数据时双方协定的端口是256×247+183，接下来我们在来看看服务端上的端口连接情况&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[qiuhom@test ~]$ss -nt
State      Recv-Q Send-Q              Local Address:Port                             Peer Address:Port              
ESTAB      0      0                    192.168.0.99:51838                            192.168.0.99:21                 
ESTAB      0      0                    192.168.0.99:59860                            192.168.0.99:3306               
ESTAB      0      0                    192.168.0.99:3306                             192.168.0.99:59860              
ESTAB      204800 0                    192.168.0.99:35409                            192.168.0.99:63415              
ESTAB      0      216                  192.168.0.99:41319                           192.168.0.232:1678               
ESTAB      0      0                    192.168.0.99:41319                           192.168.0.232:1616               
ESTAB      0      0             ::ffff:192.168.0.99:21                        ::ffff:192.168.0.99:51838              
ESTAB      0      0             ::ffff:192.168.0.99:63415                     ::ffff:192.168.0.99:35409              
[qiuhom@test ~]$bc
bc 1.06.95
Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.
This is free software with ABSOLUTELY NO WARRANTY.
For details type `warranty'. 
256*247+183
63415
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：可以看到客户端的35409这个端口与服务端的63415连接着。63415就是在下载数据的时候双方协商好的数据传输端口&lt;/p&gt;
&lt;p&gt;　　二、FTP软件介绍&lt;/p&gt;
&lt;p&gt;　　FTP服务器软件有Wu-ftpd,Proftpd,Pureftpd,servU,IIS,vsftpd,在centos上默认的FTP服务器软件就是vsftpd，它号称是非常安全的FTPDaemon ，高速，稳定，下载速度是WU-FTP的两倍，官方数据告诉我们说单击最多可支持15000个并发。听上去很牛逼的样子，接下来我们来看看它&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#yum info vsftpd
已加载插件：fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * extras: mirrors.aliyun.com
 * updates: mirrors.aliyun.com
已安装的软件包
名称    ：vsftpd
架构    ：x86_64
版本    ：3.0.2
发布    ：25.el7
大小    ：353 k
源    ：installed
来自源：base
简介    ： Very Secure Ftp Daemon
网址    ：https://security.appspot.com/vsftpd.html
协议    ： GPLv2 with exceptions
描述    ： vsftpd is a Very Secure FTP daemon. It was written completely from
         : scratch.

[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：你看看它的简介就是说非常安全的FTPDaemon。具体它的并发能够达到多少，有待测试&lt;/p&gt;
&lt;p&gt;　　在Linux系统上FTP客户端软件有，ftp,lftp,lftpget ,wget curl，其中ftp和lftp最为常用，ftp这个客户端工具一边用于测试，因为它不具备补全的功能，在生产环境中用起来不是很方便，还有就是它列出来的文件、目录，只能看文件属性信息里的‘-’，‘d’来区分，所以在字符界面一般我们都很少用ftp这个客户端，相反lftp就弥补了ftp的确定，受到大众的喜爱，它支持补全，我们用它就感觉是操作Linux文件系统一样。&lt;/p&gt;
&lt;p&gt;　　ftp连接FTP服务器的使用方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#ftp -A 192.168.0.99 2121
Connected to 192.168.0.99 (192.168.0.99).
220 (vsFTPd 3.0.2)
Name (192.168.0.99:root): ftp
331 Please specify the password.
Password:
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp&amp;gt; ls
200 PORT command successful. Consider using PASV.
150 Here comes the directory listing.
drwxr-xr-x    2 0        0              21 Dec 27 04:25 pub
226 Directory send OK.
ftp&amp;gt; cd pub
250 Directory successfully changed.
ftp&amp;gt; ls
200 PORT command successful. Consider using PASV.
150 Here comes the directory listing.
-rw-r--r--    1 0        0        1073741824 Dec 27 04:25 bigfile
226 Directory send OK.
ftp&amp;gt; bye
221 Goodbye.
[root@test ~]#ftp -p 192.168.0.99 2121 
Connected to 192.168.0.99 (192.168.0.99).
220 (vsFTPd 3.0.2)
Name (192.168.0.99:root): ftp
331 Please specify the password.
Password:
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp&amp;gt; ls
227 Entering Passive Mode (192,168,0,99,20,204).
150 Here comes the directory listing.
drwxr-xr-x    2 0        0              21 Dec 27 04:25 pub
226 Directory send OK.
ftp&amp;gt; cd pub
250 Directory successfully changed.
ftp&amp;gt; ls
227 Entering Passive Mode (192,168,0,99,205,210).
150 Here comes the directory listing.
-rw-r--r--    1 0        0        1073741824 Dec 27 04:25 bigfile
226 Directory send OK.
ftp&amp;gt; bye
221 Goodbye.
[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：-A表示主动模式，-p(小写) 表示被动模式，centos系统上默认是被动模式，这也说明了一点就是不同的客户端，其连接服务器的模式不一样。&lt;/p&gt;
&lt;p&gt;　　lftp连接ftp服务器的使用方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#lftp -u ftp 192.168.0.99 -p 2121
口令: 
lftp ftp@192.168.0.99:~&amp;gt; ls            
drwxr-xr-x    2 0        0              21 Dec 27 04:25 pub
lftp ftp@192.168.0.99:/&amp;gt; cd pub/
lftp ftp@192.168.0.99:/pub&amp;gt; ls
-rw-r--r--    1 0        0        1073741824 Dec 27 04:25 bigfile
lftp ftp@192.168.0.99:/pub&amp;gt; bye
[root@test ~]#lftp ftp@192.168.0.99 -p 2121    
口令: 
lftp ftp@192.168.0.99:~&amp;gt; ls            
drwxr-xr-x    2 0        0              21 Dec 27 04:25 pub
lftp ftp@192.168.0.99:/&amp;gt; cd pub/
lftp ftp@192.168.0.99:/pub&amp;gt; ls
-rw-r--r--    1 0        0        1073741824 Dec 27 04:25 bigfile
lftp ftp@192.168.0.99:/pub&amp;gt; bye
[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：-p是指定端口 -u 指定用户名，如果不用-u指定，可把用户名写在@前&lt;/p&gt;
&lt;p&gt;　　还有一些别的客户端工具如浏览器，Windows是对资源管理器，filezilla等等，这些都不在这里过多演示&lt;/p&gt;
&lt;p&gt;　　三、FTP服务&lt;/p&gt;
&lt;p&gt;　　1）状态码说明&lt;/p&gt;
&lt;p&gt;　　　　1xx:表示信息类，比如125：表示数据连接打开&lt;/p&gt;
&lt;p&gt;　　　　2xx:表示成功类状态，比如200：命令ok 230表示登录成功&lt;/p&gt;
&lt;p&gt;　　　　3xx:表示补充类，比如331表示用户名OK&lt;/p&gt;
&lt;p&gt;　　　　4xx:表示客户端错误，比如425表示不能打开数据链接&lt;/p&gt;
&lt;p&gt;　　　　5xx:表示服务器错误，比如530表示不能登录&lt;/p&gt;
&lt;p&gt;　　2）用户认证&lt;/p&gt;
&lt;p&gt;　　　　支持匿名用户：ftp,anonymous，对应Linux用户ftp&lt;/p&gt;
&lt;p&gt;　　　    系统用户：Linux用户，用户/etc/passwd，密码/etc/shadow&lt;/p&gt;
&lt;p&gt;　　　　虚拟用户：特定服务端装用用户，独立的用户/密码文件&lt;/p&gt;
&lt;p&gt;　　四、vsftpd服务介绍&lt;/p&gt;
&lt;p&gt;　　vsftpd由vsftpd包提供，默认不再由xinetd管理，当然我们是可以配置成非独立服务的，让它由xinetd服务带管。用户认证配置文件：/etc/pam.d/vsftpd，服务脚本：centos7上是/usr/lib/systemd/system/vsftpd.service,centos6上是/etc/rc.d/init.d/vsftpd；服务主配置文件是：/etc/vsftpd/vsftpd.conf&lt;/p&gt;
&lt;p&gt;　　其中/etc/vsftpd/vsftpd.conf 可以通过man 5 vsftpd.conf 来查看配置文件帮助，它里面的格式是选项=value的格式，等号前后不能有多余的空格，否则服务将无法正常启动。匿名用户（映射为系统用户ftp）共享文件位置上：/var/ftp，这个目录就是默认ftp的共享目录；系统用户共享文件位置就是用户的家目录；虚拟用户共享文件位置：为其映射到系统用户家目录&lt;/p&gt;
&lt;p&gt;　　五、vsftpd服务配置&lt;/p&gt;
&lt;p&gt;　　命令端口的配置：命令端口的指定有listen_port=xx来指定，不写在配置文件中表示使用默认的命令端口21&lt;/p&gt;
&lt;p&gt;　　主动模式端口：connet_from_port_20=YES 表示主动模式端口为20；ftp_data_port=xx表示指定主动模式的端口，默认是20&lt;/p&gt;
&lt;p&gt;　　被动端口范围：Linux客户端默认使用被动模式，Windows客户端默认使用主动模式；pasv_min_port=xxx;pasv_max_port=xxx通过这两条选项来指定ftp最小连接端口和最大的连接端口，这样配置后，数据端口就只能使用在指定这个范围内的端口。其中0表示随机分配端口&lt;/p&gt;
&lt;p&gt;　　使用当地时间：use_localtime=YES默认的配置上NO，使用GMT&lt;/p&gt;
&lt;p&gt;　　关于匿名用户的配置:&lt;/p&gt;
&lt;p&gt;　　　　anonymous_enable=YES 支持匿名用户&lt;br/&gt;　　　　no_anon_password=YES(默认NO) 匿名用户略过口令检查&lt;br/&gt;　　　　anon_world_readable_only (默认YES)只能下载全部读的文件&lt;br/&gt;　　　　anon_upload_enable=YES 匿名上传，注意:文件系统权限&lt;br/&gt;　　　　anon_mkdir_write_enable=YES 匿名建目录&lt;br/&gt;　　　　anon_umask=0333 指定匿名上传文件的umask，默认077&lt;br/&gt;　　　　anon_other_write_enable=YES 可删除和修改上传的文件&lt;br/&gt;　　　　指定上传文件的默认的所有者和权限&lt;br/&gt;　　　　chown_uploads=YES(默认NO)&lt;br/&gt;　　　　chown_username=wang&lt;br/&gt;　　　　chown_upload_mode=0644&lt;/p&gt;
&lt;p&gt;　　关于Linux系统用户的配置&lt;/p&gt;
&lt;p&gt;　　　　local_enable=YES 是否允许linux用户登录&lt;br/&gt;　　　　write_enable=YES 允许linux用户上传文件&lt;br/&gt;　　　　local_umask=022 指定系统用户上传文件的默认权限&lt;br/&gt;　　　　guest_enable=YES 所有系统用户都映射成guest用户&lt;br/&gt;　　　　guest_username=ftp 配合上面选项才生效，指定guest用户&lt;br/&gt;　　　　local_root=/ftproot guest用户登录所在目录&lt;/p&gt;
&lt;p&gt;　　这里需要说一下，映射成guest用户后，用户登录所指定的目录，不能有guest所指定的用户有可写的权限，否则用户无法登陆。也就是说ftp的根目录是不能有当前用户的写权限的。&lt;/p&gt;
&lt;p&gt;　　禁锢所有系统用户在家目录中&lt;/p&gt;
&lt;p&gt;　　　　chroot_local_user=YES（默认NO，不禁锢）禁锢系统用户&lt;/p&gt;
&lt;p&gt;　　　　chroot_list_enable=YES开启禁锢列表　　　&lt;/p&gt;
&lt;p&gt;　　　　chroot_list_file=/etc/vsftpd/chroot_list禁锢或不禁锢用户的名单文件，当chroot_local_user=YES时，则chroot_list中的用户不禁锢（白名单），当chroot_local_user=NO时，chroot_list中的用户禁锢（黑名单）　&lt;/p&gt;
&lt;p&gt;　　wu-ftp日志：默认启用&lt;br/&gt;　　　　xferlog_enable=YES （默认） 启用记录上传下载日志&lt;br/&gt;　　　　xferlog_std_format=YES （默认） 使用wu-ftp日志格式&lt;br/&gt;　　　　xferlog_file=/var/log/xferlog （默认）可自动生成　&lt;/p&gt;
&lt;p&gt;　　vsftpd日志：默认不启用&lt;br/&gt;　　　　dual_log_enable=YES 使用vsftpd日志格式，默认不启用&lt;br/&gt;　　　　vsftpd_log_file=/var/log/vsftpd.log（默认）可自动生成&lt;/p&gt;
&lt;p&gt;　　登录提示信息&lt;/p&gt;
&lt;p&gt;　　　　ftpd_banner=“welcome to mage ftp server&quot;&lt;br/&gt;　　　　banner_file=/etc/vsftpd/ftpbanner.txt 优先上面项生效&lt;/p&gt;
&lt;p&gt;　　目录访问提示信息&lt;/p&gt;
&lt;p&gt;　　　　dirmessage_enable=YES (默认)&lt;br/&gt;　　　　message_file=.message(默认) 信息存放在指定目录下.message&lt;/p&gt;
&lt;p&gt; 　　使用pam(Pluggable Authentication Modules)完成用户认证&lt;/p&gt;
&lt;p&gt;　　　　pam_service_name=vsftpd&lt;/p&gt;
&lt;p&gt;　　　　　　pam配置文件:/etc/pam.d/vsftpd&lt;br/&gt;　　　　　　/etc/vsftpd/ftpusers 默认文件中用户拒绝登录，当然具体这里面的用户数拒绝还是允许需要看/etc/pam.d/vsftpd 是怎么定义的了&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#cat /etc/pam.d/vsftpd 
#%PAM-1.0
session    optional     pam_keyinit.so    force revoke
auth       required     pam_listfile.so item=user sense=deny file=/etc/vsftpd/ftpusers onerr=succeed
auth       required     pam_shells.so
auth       include      password-auth
account    include      password-auth
session    required     pam_loginuid.so
session    include      password-auth
[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：此文件默认是定义的是/etc/vsftpd/ftpusers这个文件中的用户是拒绝登录ftp系统的，若我们需要/etc/vsftpd/ftpuser里的用户允许登录ftp系统，我们只需要改动/etc/pam.d/vsftpd即可，把sense=deny改成sense=allow即可。&lt;/p&gt;
&lt;p&gt;　　是否启用控制用户登录的列表文件&lt;/p&gt;
&lt;p&gt;　　　　userlist_enable=YES 默认有此设置&lt;/p&gt;
&lt;p&gt;　　　　userlist_deny=YES(默认值) 黑名单,不提示口令，NO为白名单&lt;/p&gt;
&lt;p&gt;　　　　userlist_file=/etc/vsftpd/users_list 此为默认值&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#cat /etc/vsftpd/user_list 
# vsftpd userlist
# If userlist_deny=NO, only allow users in this file
# If userlist_deny=YES (default), never allow users in this file, and
# do not even prompt for a password.
# Note that the default vsftpd pam config also checks /etc/vsftpd/ftpusers
# for users that are denied.
root
bin
daemon
adm
lp
sync
shutdown
halt
mail
news
uucp
operator
games
nobody
[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：此文件注释告诉我们如果userlist_deny=NO 那么ftp系统只允许此文件中的用户登录系统；如果userlist_deny=YES 且此选项默认是yes选项，那么此文件中的用户是不允许登录到ftp系统的，况且不会给输入密码的机会。这也就是为什么root用户登录系统，没有输入密码的机会就提示权限决绝，不光是root，像bin,daemon这些用户也是一样的，总之在这个文件中的用户都不会提示输入口令。假如我们想要让root用户登录到ftp系统里，怎么配置呢？首先我们要把此文件的root用户删除。删除了此文件中的root用户，我们用root登录就会有输入密码的提示&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#cat /etc/vsftpd/user_list
# vsftpd userlist
# If userlist_deny=NO, only allow users in this file
# If userlist_deny=YES (default), never allow users in this file, and
# do not even prompt for a password.
# Note that the default vsftpd pam config also checks /etc/vsftpd/ftpusers
# for users that are denied.
root
bin
daemon
adm
lp
sync
shutdown
halt
mail
news
uucp
operator
games
nobody
[root@test ~]#ftp 192.168.0.99
Connected to 192.168.0.99 (192.168.0.99).
220 (vsFTPd 3.0.2)
Name (192.168.0.99:root): root
530 Permission denied.
Login failed.
ftp&amp;gt; bye
221 Goodbye.
[root@test ~]#sed -i 's@root@#root@' /etc/vsftpd/user_list 
[root@test ~]#cat /etc/vsftpd/user_list
# vsftpd userlist
# If userlist_deny=NO, only allow users in this file
# If userlist_deny=YES (default), never allow users in this file, and
# do not even prompt for a password.
# Note that the default vsftpd pam config also checks /etc/vsftpd/ftpusers
# for users that are denied.
#root
bin
daemon
adm
lp
sync
shutdown
halt
mail
news
uucp
operator
games
nobody
[root@test ~]#ftp 192.168.0.99
Connected to 192.168.0.99 (192.168.0.99).
220 (vsFTPd 3.0.2)
Name (192.168.0.99:root): root
331 Please specify the password.
Password:
530 Login incorrect.
Login failed.
ftp&amp;gt; bye
221 Goodbye.
[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：我们可以看到我们把root从/etc/vsftpd/user_list文件中注释掉，root用户登录FTP系统就可以输入密码了，但是我们输入正确的口令为什么还是不能登录呢？其实/etc/vsftpd/user_list文件中告诉我们了，说默认vsftpd pam会检查配置文件/etc/vsftpd/ftpusers中的用户，也就说系统用户要想登录FTP系统，必须满足/etc/vsftpd/user_list中没有此用户的同时，pam检查/etc/vsftpd/ftpusers文件此用户通过，如果/etc/pam.d/vsftpd配置文件中指定/etc/vsftpd/ftpusers中的用户拒绝登录到ftp系统，那么此用户也必须满足ftpusers中没有此用户。如果/etc/pam.d/vsftpd配置文件中指定/etc/vsftpd/ftpusers中的用户允许登录到ftp系统，则此用户只需要满足不存在/etc/vsftpd/user_list即可，当然默认情况两个配置文件中都没有的用户是可以登录系统的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#cat /etc/vsftpd/ftpusers 
# Users that are not allowed to login via ftp
root
bin
daemon
adm
lp
sync
shutdown
halt
mail
news
uucp
operator
games
nobody
[root@test ~]#sed -i 's@root@#root@' /etc/vsftpd/ftpusers
[root@test ~]#cat /etc/vsftpd/ftpusers
# Users that are not allowed to login via ftp
#root
bin
daemon
adm
lp
sync
shutdown
halt
mail
news
uucp
operator
games
nobody
[root@test ~]#ftp 192.168.0.99
Connected to 192.168.0.99 (192.168.0.99).
220 (vsFTPd 3.0.2)
Name (192.168.0.99:root): root
331 Please specify the password.
Password:
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp&amp;gt; ls
227 Entering Passive Mode (192,168,0,99,66,75).
150 Here comes the directory listing.
drwxr-xr-x    5 0        0             190 Dec 27 04:26 bak
226 Directory send OK.
ftp&amp;gt; bye
221 Goodbye.
[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：更改了ftpusers文件，root就可以正常登录系统里，这里需要说一下，在生产环境中我们是不推荐这样做的，因为ftp默认情况是不加密的，都是明文传输，如果用root登录，很有可能泄露root密码，从而威胁到linux系统。这也告诉我们，我们如果用系统帐号作为ftp的登录帐号，必须限制其登录shell类型，否则会有ftp用户登录到Linux系统的危险。/etc/vsftpd/ftpusers和/etc/vsftpd/user_list这两个文件中的用户具体是拒绝还是允许，都取决于两个参数的配置，ftpusers 取决于pam.d/vsftpd中的配置是否允许，user_list中的用户取决于userlist_deny=yes or no，一般我们都取默认值即可。&lt;/p&gt;
&lt;p&gt;　　vsftpd服务指定用户身份运行&lt;/p&gt;
&lt;p&gt;　　　　nopriv_user=nobody (默认值)&lt;/p&gt;
&lt;p&gt;　　连接数限制&lt;/p&gt;
&lt;p&gt;　　　　max_clients=0 最大并发连接数&lt;/p&gt;
&lt;p&gt;　　　　max_per_ip=0 每个IP同时发起的最大连接数&lt;/p&gt;
&lt;p&gt;　　传输速率：字节/秒&lt;/p&gt;
&lt;p&gt;　　　　anon_max_rate=0 匿名用户的最大传输速率&lt;/p&gt;
&lt;p&gt;　　　　local_max_rate=0 本地用户的最大传输速率&lt;/p&gt;
&lt;p&gt;　　连接时间：秒为单位&lt;/p&gt;
&lt;p&gt;　　　　connect_timeout=60 主动模式数据连接超时时长&lt;/p&gt;
&lt;p&gt;　　　　accept_timeout=60 被动模式数据连接超时时长&lt;/p&gt;
&lt;p&gt;　　　　data_connection_timeout=300 数据连接无数据输超时时长&lt;/p&gt;
&lt;p&gt;　　　　idle_session_timeout=60 无命令操作超时时长&lt;/p&gt;
&lt;p&gt;　　优先以文本方式传输&lt;/p&gt;
&lt;p&gt;　　　　ascii_upload_enable=YES&lt;/p&gt;
&lt;p&gt;　　　　ascii_download_enable=YES&lt;/p&gt;
&lt;p&gt;　　这两个选项不建议大家配置，因为默认的是binary模式传输数据，如果配置了这两条后，进行传输二进制的文件会有问题，我们知道Windows和Linux的ascii文件格式是不一样的，windows上ascii的文件格式回车加换行表示Linux里的一个换行，这样一来，假如用户下载一个二进制程序，用windows客户端来下载，有可能存在破坏原来二进制文件的内容，导致下载下来的二进制程序不可用。虽然ftp客户端是可以切换传输模式，但还是不建议大家更改默认优先使用binary传输数据。因为我们用binary模式传输数据，没有破坏文件的风险，顶多下载一个文本文件它的格式不一样，但是我们可以用工具去转换呀，如果是二进制文件被破环了，相对文本文件去转换要难得多，所以还是推荐大家使用binary模式去传输数据。&lt;/p&gt;
&lt;p&gt;　　配置FTP服务以非独立服务方运行&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;50&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-node1 ~]#yum install vsftpd xinetd -y
Loaded plugins: fastestmirror, security
Setting up Install Process
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * extras: mirrors.aliyun.com
 * updates: mirrors.aliyun.com
Package vsftpd-2.2.2-24.el6.x86_64 already installed and latest version
Package 2:xinetd-2.3.14-40.el6.x86_64 already installed and latest version
Nothing to do
[root@test-node1 ~]#grep &quot;listen&quot; /etc/vsftpd/vsftpd.conf 
# When &quot;listen&quot; directive is enabled, vsftpd runs in standalone mode and
# listens on IPv4 sockets. This directive cannot be used in conjunction
# with the listen_ipv6 directive.
listen=YES
# This directive enables listening on IPv6 sockets. To listen on IPv4 and IPv6
# Make sure, that one of the listen options is commented !!
#listen_ipv6=YES
[root@test-node1 ~]#sed -i 's@listen=YES@listen=NO@' /etc/vsftpd/vsftpd.conf 
[root@test-node1 ~]#grep &quot;listen=&quot; /etc/vsftpd/vsftpd.conf
listen=NO
[root@test-node1 ~]#cat &amp;gt;&amp;gt; /etc/xinetd.d/vsftpd &amp;lt;&amp;lt; EOF
&amp;gt; service ftp
&amp;gt; {
&amp;gt; flags = REUSE
&amp;gt; socket_type = stream
&amp;gt; wait = no
&amp;gt; user = root
&amp;gt; server = /usr/sbin/vsftpd
&amp;gt; log_on_failure += USERID
&amp;gt; disable = no
&amp;gt; }
&amp;gt; EOF
[root@test-node1 ~]#cat /etc/xinetd.d/vsftpd 
service ftp
{
flags = REUSE
socket_type = stream
wait = no
user = root
server = /usr/sbin/vsftpd
log_on_failure += USERID
disable = no
}
[root@test-node1 ~]#/etc/init.d/xinetd start
Starting xinetd:                                           [  OK  ]
[root@test-node1 ~]#ss -ntlp |grep 21
LISTEN     0      64                       :::21                      :::*      users:((&quot;xinetd&quot;,3966,5))
[root@test-node1 ~]#ftp 192.168.0.151
Connected to 192.168.0.151 (192.168.0.151).
220 (vsFTPd 2.2.2)
Name (192.168.0.151:root): ftp
331 Please specify the password.
Password:
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp&amp;gt; ls
227 Entering Passive Mode (192,168,0,151,252,106).
150 Here comes the directory listing.
drwxr-xr-x    2 0        0            4096 Mar 22  2017 pub
226 Directory send OK.
ftp&amp;gt; cd pub
250 Directory successfully changed.
ftp&amp;gt; ls
227 Entering Passive Mode (192,168,0,151,230,82).
150 Here comes the directory listing.
226 Directory send OK.
ftp&amp;gt; bye
221 Goodbye.
[root@test-node1 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：centos7上用以上方式是可以开启以xinetd来代管vsftpd，但是没法连接去使用，不知道为什么。centos6上用以上方式是可以的。&lt;/p&gt;
&lt;p&gt;　　六、基于ssl的ftps实现&lt;/p&gt;
&lt;p&gt;　　　　1）查看是否支持SSL&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#ldd `which vsftpd`
        linux-vdso.so.1 =&amp;gt;  (0x00007ffe512c9000)
        libssl.so.10 =&amp;gt; /lib64/libssl.so.10 (0x00007f3e65c8a000)
        libwrap.so.0 =&amp;gt; /lib64/libwrap.so.0 (0x00007f3e65a7f000)
        libnsl.so.1 =&amp;gt; /lib64/libnsl.so.1 (0x00007f3e65865000)
        libpam.so.0 =&amp;gt; /lib64/libpam.so.0 (0x00007f3e65656000)
        libcap.so.2 =&amp;gt; /lib64/libcap.so.2 (0x00007f3e65451000)
        libdl.so.2 =&amp;gt; /lib64/libdl.so.2 (0x00007f3e6524d000)
        libcrypto.so.10 =&amp;gt; /lib64/libcrypto.so.10 (0x00007f3e64deb000)
        libc.so.6 =&amp;gt; /lib64/libc.so.6 (0x00007f3e64a1e000)
        libgssapi_krb5.so.2 =&amp;gt; /lib64/libgssapi_krb5.so.2 (0x00007f3e647d1000)
        libkrb5.so.3 =&amp;gt; /lib64/libkrb5.so.3 (0x00007f3e644e8000)
        libcom_err.so.2 =&amp;gt; /lib64/libcom_err.so.2 (0x00007f3e642e4000)
        libk5crypto.so.3 =&amp;gt; /lib64/libk5crypto.so.3 (0x00007f3e640b1000)
        libz.so.1 =&amp;gt; /lib64/libz.so.1 (0x00007f3e63e9b000)
        libaudit.so.1 =&amp;gt; /lib64/libaudit.so.1 (0x00007f3e63c72000)
        libattr.so.1 =&amp;gt; /lib64/libattr.so.1 (0x00007f3e63a6d000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f3e66127000)
        libkrb5support.so.0 =&amp;gt; /lib64/libkrb5support.so.0 (0x00007f3e6385d000)
        libkeyutils.so.1 =&amp;gt; /lib64/libkeyutils.so.1 (0x00007f3e63659000)
        libresolv.so.2 =&amp;gt; /lib64/libresolv.so.2 (0x00007f3e63440000)
        libpthread.so.0 =&amp;gt; /lib64/libpthread.so.0 (0x00007f3e63224000)
        libcap-ng.so.0 =&amp;gt; /lib64/libcap-ng.so.0 (0x00007f3e6301e000)
        libselinux.so.1 =&amp;gt; /lib64/libselinux.so.1 (0x00007f3e62df7000)
        libpcre.so.1 =&amp;gt; /lib64/libpcre.so.1 (0x00007f3e62b95000)
[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：我们都知道要想某个软件支持ssl，那么它必须调用ssl的库文件，ssl库文件就是libssl.so,用ldd命令可以查看某个应用调用的库文件有哪些&lt;/p&gt;
&lt;p&gt;　　2）创建自签名证书&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#cd /etc/pki/tls/certs/
[root@test certs]#ls
ca-bundle.crt  ca-bundle.trust.crt  make-dummy-cert  Makefile  renew-dummy-cert
[root@test certs]#make vsftpd.pem
umask 77 ; \
PEM1=`/bin/mktemp /tmp/openssl.XXXXXX` ; \
PEM2=`/bin/mktemp /tmp/openssl.XXXXXX` ; \
/usr/bin/openssl req -utf8 -newkey rsa:2048 -keyout $PEM1 -nodes -x509 -days 365 -out $PEM2  ; \
cat $PEM1 &amp;gt;  vsftpd.pem ; \
echo &quot;&quot;    &amp;gt;&amp;gt; vsftpd.pem ; \
cat $PEM2 &amp;gt;&amp;gt; vsftpd.pem ; \
rm -f $PEM1 $PEM2
Generating a 2048 bit RSA private key
...........................+++
...+++
writing new private key to '/tmp/openssl.uUotmW'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [XX]:CN
State or Province Name (full name) []:sichuan
Locality Name (eg, city) [Default City]:guangyuan
Organization Name (eg, company) [Default Company Ltd]:test
Organizational Unit Name (eg, section) []:test
Common Name (eg, your name or your server's hostname) []:ftp.test.com  
Email Address []:
[root@test certs]#ll
总用量 16
lrwxrwxrwx. 1 root root   49 6月  22 2019 ca-bundle.crt -&amp;gt; /etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem
lrwxrwxrwx. 1 root root   55 6月  22 2019 ca-bundle.trust.crt -&amp;gt; /etc/pki/ca-trust/extracted/openssl/ca-bundle.trust.crt
-rwxr-xr-x. 1 root root  610 3月  12 2019 make-dummy-cert
-rw-r--r--. 1 root root 2516 3月  12 2019 Makefile
-rwxr-xr-x. 1 root root  829 3月  12 2019 renew-dummy-cert
-rw-------  1 root root 3027 12月 27 22:54 vsftpd.pem
[root@test certs]#cat vsftpd.pem 
-----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDWYYttWUinc+z9
uzcaEJ38qC3WEp/SNgijGj1Kn8dovJSvxgUHYuZlzgnBe3UfTrkHsQTj/f1y8OUd
4/8UCw1YRjPdZJAhZ4cnCwj6mgSxXM/ru0k232m7IeSZ5RcV/LlEZ+6wxmsv+Vow
2iaGDLlxaXczSgpHb4n0zigswCVzegmXQpQxBZvAuEEzyg204+Qf7J0qJPfc8j0H
F4Gx806C+FAlMxD79pAGxzlyb8w3gosG1H4eIlHJKtXUsZIo5cvPZxlVVqrg6SD4
o1U6FfIVGtOA0Ud4DtQnasrfQOWUOTuQrfJiykShVM8iCp5xGdZMWwD6cP0DbDdB
OUa4hB8PAgMBAAECggEAfckMGuPZKk9tjU6svQFlAVrYUhPpbFjB5pk9vyxSv1Ru
1VeVmcjgsHkc5kZ+6Riynh2yZeegLzHC7S/aebMmaFYAlnUr0D3DYhgqc4etGzf+
0yy3f5fEnMT9MYLmccMwHT/yIAy71ZEz5xgIpHyQzkd4ZkKaF2INivLvRZqUHtU4
IrzkGyF26DJNgw8+s5C+VtpF9Ii8oLQfvBvIkud4tw47rHpU5jp3Osply//s2Q8C
fHWcjqzHPWH6qSW9xppatXkJJmTiqYt9kiFJyEd5gf4ELkSEmv02Q9OHnCt6W4wo
/4EtlsfLcCPvkVjgI66PNCxObCkh13WoBOe/MJNuyQKBgQDrp3ZFPeWGMqCUTYHf
mHLlJcTtgCsqu3fxRYvG/gc5cy2Th8ECXJE4X08X6stCqBrlaLqnc2YgXjl0fNGL
YqjlXX/KymsmRWIUfBCLux6JqTfU9klQyzbZgbSIfZE0ATplT6J8MdpmzhnQJX2O
xm80KI9Vv4GmqtctjGiw4h0XcwKBgQDo4+Ty4h//VatA7sxpnDjY88y58cPyp/J1
4g0DUx2R4RVbCBkp+XgX7VXXT0TghuQSUwzvrVse9JrRxh7JegdkVshdiE2pg4NT
k+OJRi7fbWoX5cfPRCSJ1FXsNY2kz8gMhXuDWLualcQg83sHjdyUGdpCEn5i8dc1
xmsw98ka9QKBgHFNROopxm9tbBOh6G2vCJ7wN+zREPAszpBslbYJcUPIAwPJ45zV
EOV/vbGMLEpSNQxT/FqCe3nYk9tUIBPaTcZp3AWOqVHvTib3N6VXRGl/uN5lw/5a
lnahjEGLzgKpDICld0QrXAzNz09qlyHMeq8jSTc7KoUN4wN9XOCe9snNAoGBAIzv
POHvDcYLJfPJj1JqA8zm3QG52QbDs+q6vX1Bkydwuue34uKP4ak5KzV89wWZG/Qq
5i01D2uQQxCngIIUotyJ1/8iOT1YJOUzHgM4wazcHdQQbfZ0Glh+cvDbB7ixNTK+
pJw72mwWLfZy4gUUSGQnsPlDD9D44W/df4jGqqDxAoGAM107eZVXENYYbVNae0M3
K1o/kg+hVgkTtKJj1t3eMTZSOEIOlwHH48KkIdF5T37t5BQ2cmLaoBqAY2rJMP8U
YhQ65LrpC/m9IyewjE5lD5Zkz51WToMHSA9K+++1VY7+x5aJk4KJobBGl5BHMPDU
hxdjIeQujOoWlRLLWMCn/CE=
-----END PRIVATE KEY-----

-----BEGIN CERTIFICATE-----
MIIDozCCAougAwIBAgIJAIBmy3n1yB5dMA0GCSqGSIb3DQEBCwUAMGgxCzAJBgNV
BAYTAkNOMRAwDgYDVQQIDAdzaWNodWFuMRIwEAYDVQQHDAlndWFuZ3l1YW4xDTAL
BgNVBAoMBHRlc3QxDTALBgNVBAsMBHRlc3QxFTATBgNVBAMMDGZ0cC50ZXN0LmNv
bTAeFw0xOTEyMjcxNDU0MDFaFw0yMDEyMjYxNDU0MDFaMGgxCzAJBgNVBAYTAkNO
MRAwDgYDVQQIDAdzaWNodWFuMRIwEAYDVQQHDAlndWFuZ3l1YW4xDTALBgNVBAoM
BHRlc3QxDTALBgNVBAsMBHRlc3QxFTATBgNVBAMMDGZ0cC50ZXN0LmNvbTCCASIw
DQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBANZhi21ZSKdz7P27NxoQnfyoLdYS
n9I2CKMaPUqfx2i8lK/GBQdi5mXOCcF7dR9OuQexBOP9/XLw5R3j/xQLDVhGM91k
kCFnhycLCPqaBLFcz+u7STbfabsh5JnlFxX8uURn7rDGay/5WjDaJoYMuXFpdzNK
CkdvifTOKCzAJXN6CZdClDEFm8C4QTPKDbTj5B/snSok99zyPQcXgbHzToL4UCUz
EPv2kAbHOXJvzDeCiwbUfh4iUckq1dSxkijly89nGVVWquDpIPijVToV8hUa04DR
R3gO1Cdqyt9A5ZQ5O5Ct8mLKRKFUzyIKnnEZ1kxbAPpw/QNsN0E5RriEHw8CAwEA
AaNQME4wHQYDVR0OBBYEFBIAwA/ZbgW55Ljm/5Q/55wuGDd+MB8GA1UdIwQYMBaA
FBIAwA/ZbgW55Ljm/5Q/55wuGDd+MAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcNAQEL
BQADggEBAIXXG0y8PiEkBFCbnusCOK7llJkzMhmogJjWFcLn9UfKzHvgpC1bhCRw
P8TKbviL616grY40NKHvGfy1kpO6vxykSnUnjATloTGyySnVQpmGOwVVT29t3Gtp
Opay0nrhKoyIZIMV44pHhPIbRAkofex3lNOXaL2lWCV8Es/1IXniyuq8XML3JSMZ
d+Lbu0P+e8sUQNQc1NCnbAUN6qFmG+LSjr+hRS25IlKQTATjMPNLcucGsF+2jwIQ
ScsSr4vVvYAj3JeW/2gV71hr4rZI8wLCZLszKKuhyyCGL2cpkS5Hwa3dahprEVkm
RB9ehsAnYgfTOMVPnzS1pgEem8cqDLg=
-----END CERTIFICATE-----
[root@test certs]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：ftp的证书有一个要求，它需要把私钥信息和证书信息放在同一个文件中。我们也可以先各自创建私钥文件和证书文件，最后把它们合并在一起也行；以上方式就一条命令将私钥文件和证书文件一并放入一个文件中&lt;/p&gt;
&lt;p&gt;　　3) 配置vsftpd服务支持SSL：/etc/vsftpd/vsftpd.conf&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test certs]#grep &quot;ssl&quot; /etc/vsftpd/vsftpd.conf
[root@test certs]#cat &amp;gt;&amp;gt; /etc/vsftpd/vsftpd.conf &amp;lt;&amp;lt; EOF
&amp;gt; 
&amp;gt; ssl_enable=YES
&amp;gt; allow_anon_ssl=NO
&amp;gt; force_local_logins_ssl=YES
&amp;gt; force_local_data_ssl=YES
&amp;gt; rsa_cert_file=/etc/pki/tls/certs/vsftpd.pem
&amp;gt; EOF
[root@test certs]#grep &quot;ssl&quot; /etc/vsftpd/vsftpd.conf    
ssl_enable=YES
allow_anon_ssl=NO
force_local_logins_ssl=YES
force_local_data_ssl=YES
[root@test certs]#tail -6 /etc/vsftpd/vsftpd.conf

ssl_enable=YES
allow_anon_ssl=NO
force_local_logins_ssl=YES
force_local_data_ssl=YES
rsa_cert_file=/etc/pki/tls/certs/vsftpd.pem
[root@test certs]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：ssl_enable=YES表示启用ssl,allow_anon_ssl=NO表示匿名用户不支持ssl,force_local_logins_ssl=YES表示本地用户登录加密，force_local_data_ssl=YES表示本地用户数据传输加密，rsa_cert_file=/etc/pki/tls/certs/vsftpd.pem表示指定自签名证书的位置，这个位置可以任意选择，不一定是在这个目录，也可以将证书放入/etc/vsftpd/ssl中也可以，看自己的习惯怎么放就可以。&lt;/p&gt;
&lt;p&gt;　　4)重启vsftpd服务，测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test certs]#systemctl restart vsftpd
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：之前加大选项和对应的值前后都不能有空格，否则重启服务会起不来的，且日志也不会记录。&lt;/p&gt;
&lt;p&gt;测试1，用tcpdump抓包，把vsftpd配置成不启用ssl来抓21端口的报文，然后记录到一个文件中&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;56&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test certs]#tcpdump -i enp2s0 -nn -x port 21 &amp;amp;&amp;gt; xx.txt
[root@test certs]#cat xx.txt |grep -i user
23:29:44.168817 IP 192.168.0.151.42304 &amp;gt; 192.168.0.99.21: Flags [P.], seq 1:14, ack 21, win 115, options [nop,nop,TS val 5044219 ecr 185815506], length 13: FTP: USER qiuhom
[root@test certs]#cat xx.txt |grep -i pass
23:29:44.169050 IP 192.168.0.99.21 &amp;gt; 192.168.0.151.42304: Flags [P.], seq 21:55, ack 14, win 227, options [nop,nop,TS val 185819003 ecr 5044219], length 34: FTP: 331 Please specify the password.
23:29:45.560826 IP 192.168.0.151.42304 &amp;gt; 192.168.0.99.21: Flags [P.], seq 14:26, ack 55, win 115, options [nop,nop,TS val 5045611 ecr 185819003], length 12: FTP: PASS admin
[root@test certs]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：可以看到在不启用加密，用户名和密码就很容易的被别人抓包获取&lt;/p&gt;
&lt;p&gt;测试2,把vsftpd配置成启用ssl，然后再来抓21端口的报文，然后记录到一个文件中&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test certs]#tcpdump -i enp2s0 -nn -x port 21 &amp;amp;&amp;gt; yy.txt
^C[root@test certs]#grep -i &quot;user&quot; yy.txt 
[root@test certs]#grep -i &quot;pass&quot; yy.txt     
[root@test certs]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：可以看到加密后的报文我们是抓不到user和pass的字样&lt;/p&gt;
&lt;p&gt;用filezilla等工具测试&lt;/p&gt;
&lt;p&gt;　　配置好加密重启vsftpd后用filezilla工具连接它就会弹出一个整数信息，让你确认&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/201912/1503305-20191227234035887-1687103025.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 说明：从证书上看，可看到我们刚才在证书上填写的内容，我们必须要信任了证书才可登录到服务器，也可以选择以后始终信任，这样以后再连接服务器就不会提示这个证书了&lt;/p&gt;
&lt;p&gt;　　七、vsftpd虚拟用户&lt;/p&gt;
&lt;p&gt;　　虚拟用户：&lt;/p&gt;
&lt;p&gt;　　　　所有的虚拟用户会统一映射为一个指定的系统帐号：访问共享位置，即为此系统帐号的家目录，各个虚拟账号可以被赋予不同的访问权限，通过匿名用户的权限控制参数进行指定&lt;/p&gt;
&lt;p&gt;　　实现虚拟用户帐号的储存方式：文件&lt;/p&gt;
&lt;p&gt;　　1）编辑文本文件，此文件需要被编码为hash格式，并且奇数行为用户名，偶数行为密码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test vsftpd]#getent passwd tom
[root@test vsftpd]#getent passwd jerry
[root@test vsftpd]#cat &amp;gt;&amp;gt; vuser.txt &amp;lt;&amp;lt; EOF
&amp;gt; tom
&amp;gt; admin
&amp;gt; jerry
&amp;gt; admin123
&amp;gt; EOF
[root@test vsftpd]#cat vuser.txt
tom
admin
jerry
admin123
[root@test vsftpd]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2）准备用户数据库文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test vsftpd]#db_load -T -t hash -f vuser.txt vuser.db
[root@test vsftpd]#ll vuser*
-rw-r--r-- 1 root root    25 12月 27 23:51 vuser.txt
-rw-r--r-- 1 root root 12288 12月 27 23:52 vuser.db
[root@test vsftpd]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：为了安全，建议将存放用户用户名和密码的数据库文件权限修改成600&lt;/p&gt;
&lt;p&gt;　　3）创建被映射到用户和访问FTP目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
root@test vsftpd]#useradd -d /var/ftpboot/ -s /sbin/nologin vuser
[root@test vsftpd]#getent passwd vuser
vuser:x:1005:1005::/var/ftpboot/:/sbin/nologin
[root@test vsftpd]#chmod +rx /var/ftpboot/
[root@test vsftpd]#ll /var/ftpboot/ -d
dr-xr-xr-x 4 vuser vuser 127 12月 28 00:40 /var/ftpboot/
[root@test vsftpd]#chmod -w /var/ftpboot/
[root@test vsftpd]#mkdir /var/ftpboot/upload
[root@test vsftpd]#setfacl -m u:vuser:rwx /var/ftpboot/upload
[root@test vsftpd]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：此帐号只用作虚拟账户映射成登录ftp系统的本地账号，所以应该把shell类型给设置成/sbin/nologin类型，况且贾母要把写的权限给去掉，因为ftp服务器不允许在根目录下对用户有写的权限。在其用户的家目录建立一个可读写的目录是方便用户上传数据&lt;/p&gt;
&lt;p&gt;　　4）创建pam配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test vsftpd]#cat &amp;gt;&amp;gt; /etc/pam.d/vsftpd.db &amp;lt;&amp;lt; EOF
&amp;gt; auth required pam_userdb.so db=/etc/vsftpd/vuser
&amp;gt; account required pam_userdb.so db=/etc/vsftpd/vuser
&amp;gt; EOF
[root@test vsftpd]#cat /etc/pam.d/vsftpd.db 
auth required pam_userdb.so db=/etc/vsftpd/vuser
account required pam_userdb.so db=/etc/vsftpd/vuser
[root@test vsftpd]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：配置文件的说明可以通过man pam_userdb 来查看pam_userdb这个模块的用法&lt;/p&gt;
&lt;p&gt;　　5）在/etc/vsftpd/vsftpd.conf中指定pam的配置文件，以及开启guest用户，并制定其映射成vuser&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test vsftpd]#grep &quot;guest&quot; /etc/vsftpd/vsftpd.conf
[root@test vsftpd]#grep &quot;pam&quot; /etc/vsftpd/vsftpd.conf
pam_service_name=vsftpd
[root@test vsftpd]#sed -i 's@pam_service_name=vsftpd@pam_service_name=vsftpd.db@' /etc/vsftpd/vsftpd.conf
[root@test vsftpd]#sed ^C
[root@test vsftpd]#grep &quot;pam&quot; /etc/vsftpd/vsftpd.conf
pam_service_name=vsftpd.db
[root@test vsftpd]#cat &amp;gt;&amp;gt; /etc/vsftpd/vsftpd.conf &amp;lt;&amp;lt; EOF
&amp;gt; guest_enable=YES
&amp;gt; guest_username=vuser
&amp;gt; EOF
[root@test vsftpd]#grep &quot;guest&quot; /etc/vsftpd/vsftpd.conf
guest_enable=YES
guest_username=vuser
[root@test vsftpd]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：在做以上实验先进用selinux，若没有禁用selinux ,还需要执行setsebool -P ftpd_full_access 1 &lt;/p&gt;
&lt;p&gt;　　6）创建虚拟用户独立的配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test vsftpd]#mkdir /etc/vsftpd/vusers.d/
[root@test vsftpd]#grep &quot;user_config_dir&quot; /etc/vsftpd/vsftpd.conf
[root@test vsftpd]#cat &amp;gt;&amp;gt; /etc/vsftpd/vsftpd.conf &amp;lt;&amp;lt; EOF
&amp;gt; user_config_dir=/etc/vsftpd/vusers.d/
&amp;gt; EOF
[root@test vsftpd]#grep &quot;user_config_dir&quot; /etc/vsftpd/vsftpd.conf
user_config_dir=/etc/vsftpd/vusers.d/
[root@test vsftpd]#cat &amp;gt;&amp;gt; /etc/vsftpd/vusers.d/tom &amp;lt;&amp;lt; EOF
&amp;gt; anon_upload_enable=YES
&amp;gt; anon_mkdir_write_enable=YES
&amp;gt; anon_other_write_enable=YES
&amp;gt; EOF
[root@test vsftpd]#cat &amp;gt;&amp;gt; /etc/vsftpd/vusers.d/jerry &amp;lt;&amp;lt; EOF
&amp;gt; local_root=/var/ftp
&amp;gt; EOF
[root@test vsftpd]#cat /etc/vsftpd/vusers.d/tom 
anon_upload_enable=YES
anon_mkdir_write_enable=YES
anon_other_write_enable=YES
[root@test vsftpd]#cat /etc/vsftpd/vusers.d/jerry 
local_root=/var/ftp
[root@test vsftpd]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：以上分别给tom可以自由下载上传，以及修改上传的文件，给jerry赋予登录ftp改变其指定的目录的权限。这里需要注意一点就是用户的授权文件必须同虚拟用户的名称相同。至此基于文件存放验证vsftpd的虚拟用户的实现就到此结束了，接下来就是测试我们新建的两个虚拟用户是否可登录系统，以及登录系统后的权限&lt;/p&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;p&gt;　　重启服务，并在/var/ftp/目录下建立一个varftp_dir文件，在/var/ftpboot/下创建一个名为vuser_home，以示区分连个不同的目录，并在var/ftpboot目录下存放一个测试的下载文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test vsftpd]#systemctl restart vsftpd
[root@test vsftpd]#touch /var/ftp/varftp_dir 
[root@test vsftpd]#touch /var/ftpboot/vuser_home 
[root@test vsftpd]#cp /etc/fstab /var/ftpboot/test_file
[root@test vsftpd]#ll /var/ftp/
总用量 0
drwxr-xr-x 2 root root 21 10月 31 2018 pub
-rw-r--r-- 1 root root  0 12月 28 00:39 varftp_dir
[root@test vsftpd]#ll /var/ftpboot/
总用量 4
-rw-r--r--  1 root root 552 12月 28 00:40 test_file
drwxrwxr-x+ 2 root root   6 12月 28 00:04 upload
-rw-r--r--  1 root root   0 12月 28 00:39 vuser_home
[root@test vsftpd]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试tom用户是否可以正常登录，登录后是否可以正常上传和下载文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;50&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test vsftpd]#ftp 192.168.0.99
Connected to 192.168.0.99 (192.168.0.99).
220 (vsFTPd 3.0.2)
Name (192.168.0.99:root): tom
331 Please specify the password.
Password:
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp&amp;gt; ls
227 Entering Passive Mode (192,168,0,99,220,156).
150 Here comes the directory listing.
-rw-r--r--    1 0        0             552 Dec 27 16:40 test_file
drwxrwxr-x    2 0        0               6 Dec 27 16:04 upload
-rw-r--r--    1 0        0               0 Dec 27 16:39 vuser_home
226 Directory send OK.
ftp&amp;gt; pwd
257 &quot;/&quot;
ftp&amp;gt; !ls
ftpusers  user_list  vsftpd.conf  vsftpd.conf.bak  vsftpd_conf_migrate.sh  vuser.db  vusers.d  vuser.txt
ftp&amp;gt; lcd /root
Local directory now /root
ftp&amp;gt; !ls
bak  fstab
ftp&amp;gt; get test_file
local: test_file remote: test_file
227 Entering Passive Mode (192,168,0,99,99,53).
150 Opening BINARY mode data connection for test_file (552 bytes).
226 Transfer complete.
552 bytes received in 9.6e-05 secs (5750.00 Kbytes/sec)
ftp&amp;gt; cd upload
250 Directory successfully changed.
ftp&amp;gt; put fstab 
local: fstab remote: fstab
227 Entering Passive Mode (192,168,0,99,254,231).
150 Ok to send data.
226 Transfer complete.
552 bytes sent in 0.000136 secs (4058.82 Kbytes/sec)
ftp&amp;gt; bye
221 Goodbye.
[root@test vsftpd]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：用tom用户登录ftp系统可正常的上传下载文件&lt;/p&gt;
&lt;p&gt;　　测试jerry登录是否在/var/ftp目录下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test vsftpd]#ftp 192.168.0.99
Connected to 192.168.0.99 (192.168.0.99).
220 (vsFTPd 3.0.2)
Name (192.168.0.99:root): jerry
331 Please specify the password.
Password:
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp&amp;gt; ls
227 Entering Passive Mode (192,168,0,99,100,79).
150 Here comes the directory listing.
drwxr-xr-x    2 0        0              21 Oct 30  2018 pub
-rw-r--r--    1 0        0               0 Dec 27 16:39 varftp_dir
226 Directory send OK.
ftp&amp;gt; bye
221 Goodbye.
[root@test vsftpd]#ll /var/ftp
总用量 0
drwxr-xr-x 2 root root 21 10月 31 2018 pub
-rw-r--r-- 1 root root  0 12月 28 00:39 varftp_dir
[root@test vsftpd]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：可看到jerry和tom登录到系统不是同一个目录。&lt;/p&gt;
&lt;p&gt;　　实现虚拟用户帐号的储存方式：mysql&lt;/p&gt;
&lt;p&gt;　　1）实验环境&lt;/p&gt;
&lt;p&gt;　　centos6：ip 192.168.0.151 mysql数据库服务器&lt;/p&gt;
&lt;p&gt;　　centos7：ip 192.168.0.99 vsftpd服务器&lt;/p&gt;
&lt;p&gt;　　2）安装所需要的包和包组&lt;/p&gt;
&lt;p&gt;　　centos6上安装mysql-server 并启动mysql数据库&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@ansible_centos6 ~]# yum install -y mysql-server
Loaded plugins: fastestmirror, refresh-packagekit, security
Setting up Install Process
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * extras: mirrors.163.com
 * updates: mirrors.cn99.com
base                                                                       | 3.7 kB     00:00     
epel                                                                       | 5.3 kB     00:00     
epel/primary_db                                                            | 6.1 MB     00:01     
extras                                                                     | 3.4 kB     00:00     
updates                                                                    | 3.4 kB     00:00     
updates/primary_db                                                         | 8.0 MB     00:02     
Resolving Dependencies
--&amp;gt; Running transaction check
---&amp;gt; Package mysql-server.x86_64 0:5.1.73-8.el6_8 will be installed
--&amp;gt; Processing Dependency: mysql = 5.1.73-8.el6_8 for package: mysql-server-5.1.73-8.el6_8.x86_64
--&amp;gt; Processing Dependency: perl-DBI for package: mysql-server-5.1.73-8.el6_8.x86_64
--&amp;gt; Processing Dependency: perl-DBD-MySQL for package: mysql-server-5.1.73-8.el6_8.x86_64
--&amp;gt; Processing Dependency: perl(DBI) for package: mysql-server-5.1.73-8.el6_8.x86_64
--&amp;gt; Running transaction check
---&amp;gt; Package mysql.x86_64 0:5.1.73-8.el6_8 will be installed
---&amp;gt; Package perl-DBD-MySQL.x86_64 0:4.013-3.el6 will be installed
---&amp;gt; Package perl-DBI.x86_64 0:1.609-4.el6 will be installed
--&amp;gt; Finished Dependency Resolution

Dependencies Resolved

==================================================================================================
 Package                    Arch               Version                     Repository        Size
==================================================================================================
Installing:
 mysql-server               x86_64             5.1.73-8.el6_8              base             8.6 M
Installing for dependencies:
 mysql                      x86_64             5.1.73-8.el6_8              base             895 k
 perl-DBD-MySQL             x86_64             4.013-3.el6                 base             134 k
 perl-DBI                   x86_64             1.609-4.el6                 base             705 k

Transaction Summary
==================================================================================================
Install       4 Package(s)

Total download size: 10 M
Installed size: 29 M
Downloading Packages:
(1/4): mysql-5.1.73-8.el6_8.x86_64.rpm                                     | 895 kB     00:00     
(2/4): mysql-server-5.1.73-8.el6_8.x86_64.rpm                              | 8.6 MB     00:01     
(3/4): perl-DBD-MySQL-4.013-3.el6.x86_64.rpm                               | 134 kB     00:00     
(4/4): perl-DBI-1.609-4.el6.x86_64.rpm                                     | 705 kB     00:00     
--------------------------------------------------------------------------------------------------
Total                                                             5.5 MB/s |  10 MB     00:01     
Running rpm_check_debug
Running Transaction Test
Transaction Test Succeeded
Running Transaction
  Installing : perl-DBI-1.609-4.el6.x86_64                                                    1/4 
  Installing : perl-DBD-MySQL-4.013-3.el6.x86_64                                              2/4 
  Installing : mysql-5.1.73-8.el6_8.x86_64                                                    3/4 
  Installing : mysql-server-5.1.73-8.el6_8.x86_64                                             4/4 
  Verifying  : perl-DBD-MySQL-4.013-3.el6.x86_64                                              1/4 
  Verifying  : mysql-server-5.1.73-8.el6_8.x86_64                                             2/4 
  Verifying  : mysql-5.1.73-8.el6_8.x86_64                                                    3/4 
  Verifying  : perl-DBI-1.609-4.el6.x86_64                                                    4/4 

Installed:
  mysql-server.x86_64 0:5.1.73-8.el6_8                                                            

Dependency Installed:
  mysql.x86_64 0:5.1.73-8.el6_8 perl-DBD-MySQL.x86_64 0:4.013-3.el6 perl-DBI.x86_64 0:1.609-4.el6

Complete!
[root@ansible_centos6 ~]# /etc/init.d/mysqld start
Initializing MySQL database:  WARNING: The host 'ansible_centos6' could not be looked up with resolveip.
This probably means that your libc libraries are not 100 % compatible
with this binary MySQL version. The MySQL daemon, mysqld, should work
normally with the exception that host name resolving will not work.
This means that you should use IP addresses instead of hostnames
when specifying MySQL privileges !
Installing MySQL system tables...
OK
Filling help tables...
OK

To start mysqld at boot time you have to copy
support-files/mysql.server to the right place for your system

PLEASE REMEMBER TO SET A PASSWORD FOR THE MySQL root USER !
To do so, start the server, then issue the following commands:

/usr/bin/mysqladmin -u root password 'new-password'
/usr/bin/mysqladmin -u root -h ansible_centos6 password 'new-password'

Alternatively you can run:
/usr/bin/mysql_secure_installation

which will also give you the option of removing the test
databases and anonymous user created by default.  This is
strongly recommended for production servers.

See the manual for more instructions.

You can start the MySQL daemon with:
cd /usr ; /usr/bin/mysqld_safe &amp;amp;

You can test the MySQL daemon with mysql-test-run.pl
cd /usr/mysql-test ; perl mysql-test-run.pl

Please report any problems with the /usr/bin/mysqlbug script!

                                                           [  OK  ]
Starting mysqld:                                           [  OK  ]
[root@ansible_centos6 ~]# ss -ntl |grep 3306
LISTEN     0      50                        *:3306                     *:*     
[root@ansible_centos6 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在数据库里建立存储虚拟用户数据库和连接的数据库用户&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@ansible_centos6 ~]# mysql
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 3
Server version: 5.1.73 Source distribution

Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql&amp;gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| test               |
+--------------------+
3 rows in set (0.00 sec)

mysql&amp;gt; create database vsftpd;
Query OK, 1 row affected (0.00 sec)

mysql&amp;gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| test               |
| vsftpd             |
+--------------------+
4 rows in set (0.01 sec)

mysql&amp;gt; grant select on vsftpd.* to vsftpd@'%' identified by 'admin123.com';
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在vsftpd库里创建存储虚拟用户用户名和密码的表&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
mysql&amp;gt; use vsftpd                                 
Database changed
mysql&amp;gt; show tables;                               
Empty set (0.00 sec)

mysql&amp;gt; create table users(
    -&amp;gt; id int auto_increment not null primary key,
    -&amp;gt; name char(50) binary not null,
    -&amp;gt; password char(48) binary not null);
Query OK, 0 rows affected (0.02 sec)

mysql&amp;gt; desc users;
+----------+----------+------+-----+---------+----------------+
| Field    | Type     | Null | Key | Default | Extra          |
+----------+----------+------+-----+---------+----------------+
| id       | int(11)  | NO   | PRI | NULL    | auto_increment |
| name     | char(50) | NO   |     | NULL    |                |
| password | char(48) | NO   |     | NULL    |                |
+----------+----------+------+-----+---------+----------------+
3 rows in set (0.01 sec)

mysql&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：name和password两个字段分别用binary修饰，表示此字段区存储的内容分大小写，若不用binary 则不区分大小写&lt;/p&gt;
&lt;p&gt;　　在vsftpd服务器上测试创建的用户是否可以正常连接&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test vsftpd]#mysql -uvsftpd -h192.168.0.218 -p
Enter password: 
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MySQL connection id is 5
Server version: 5.1.73 Source distribution

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MySQL [(none)]&amp;gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| test               |
| vsftpd             |
+--------------------+
3 rows in set (0.00 sec)

MySQL [(none)]&amp;gt; use vsftpd
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
MySQL [vsftpd]&amp;gt; show tables;
+------------------+
| Tables_in_vsftpd |
+------------------+
| users            |
+------------------+
1 row in set (0.00 sec)

MySQL [vsftpd]&amp;gt; desc users;
+----------+----------+------+-----+---------+----------------+
| Field    | Type     | Null | Key | Default | Extra          |
+----------+----------+------+-----+---------+----------------+
| id       | int(11)  | NO   | PRI | NULL    | auto_increment |
| name     | char(50) | NO   |     | NULL    |                |
| password | char(48) | NO   |     | NULL    |                |
+----------+----------+------+-----+---------+----------------+
3 rows in set (0.00 sec)

MySQL [vsftpd]&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：到此数据库服务器上的配置就基本完成&lt;/p&gt;
&lt;p&gt;　　centos7 vsftpd服务器上安装pam_mysql&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#yum info pam_mysql
已加载插件：fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * extras: mirrors.aliyun.com
 * updates: mirrors.aliyun.com
错误：没有匹配的软件包可以列出
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：centos7上没有找到pam_mysql，这个就需要我们去网上找源码包编译安装了&lt;/p&gt;
&lt;p&gt;　　编译pam_mysql-0.7RC1.tar.gz,说到Linux里的编译安装我们不难就想起来三大步骤，configure，make,make install，在编译前我们还需要注意我们的编译环境是否准备好了，基础的编译开发包是否都安装了&lt;/p&gt;
&lt;p&gt;　　安装编译环境说依赖的包组和包&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
yum -y groupinstall &quot;Development Tools&quot;
yum -y install mariadb-devel pam-devel
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上传源码包，解压，进行编译&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#rz
rz waiting to receive.
 zmodem trl+C ȡ

  100%     327 KB  327 KB/s 00:00:01       0 Errorsz...

[root@test ~]#ls
bak  fstab  pam_mysql-0.7RC1.tar.gz  test_file
[root@test ~]#tar xf pam_mysql-0.7RC1.tar.gz 
[root@test ~]#cd pam_mysql-0.7RC1/
[root@test pam_mysql-0.7RC1]#./configure --with-pam-mods-dir=/lib64/security 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：编译选项 就只需要指定模块的存放位置即可，pam相关的模块存放路径都是lib64/security目录下&lt;/p&gt;
&lt;p&gt;　　./configure 没有任何错误提示后，就可以make &amp;amp;&amp;amp; make install &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test pam_mysql-0.7RC1]#make &amp;amp;&amp;amp; make install
/bin/sh ./libtool --mode=compile gcc -DHAVE_CONFIG_H -I. -I. -I. -I/usr/include/security -I/usr/include  -g -O2  -g -O2 -I/usr/include/mysql    -c pam_mysql.c
mkdir .libs
 gcc -DHAVE_CONFIG_H -I. -I. -I. -I/usr/include/security -I/usr/include -g -O2 -g -O2 -I/usr/include/mysql -c pam_mysql.c  -fPIC -DPIC -o .libs/pam_mysql.o
pam_mysql.c: In function 'pam_mysql_converse':
pam_mysql.c:3192:4: warning: passing argument 2 of 'conv-&amp;gt;conv' from incompatible pointer type [enabled by default]
    conv-&amp;gt;appdata_ptr))) {
    ^
pam_mysql.c:3192:4: note: expected 'const struct pam_message **' but argument is of type 'struct pam_message **'
/bin/sh ./libtool --mode=link gcc  -g -O2 -I/usr/include/mysql     -o pam_mysql.la -rpath /lib64/security -module -avoid-version pam_mysql.lo  -L/usr/lib64/mysql -lmysqlclient -lpthread -lz -lm -ldl -lssl -lcrypto    -lcrypt
gcc -shared  .libs/pam_mysql.o  -L/usr/lib64/mysql -lmysqlclient -lpthread -lz -lm -ldl -lssl -lcrypto -lcrypt  -Wl,-soname -Wl,pam_mysql.so -o .libs/pam_mysql.so
creating pam_mysql.la
(cd .libs &amp;amp;&amp;amp; rm -f pam_mysql.la &amp;amp;&amp;amp; ln -s ../pam_mysql.la pam_mysql.la)
make[1]: 进入目录“/root/pam_mysql-0.7RC1”
/bin/sh ./mkinstalldirs /lib64/security
/bin/sh ./libtool  --mode=install /bin/install -c pam_mysql.la /lib64/security/pam_mysql.la
/bin/install -c .libs/pam_mysql.so /lib64/security/pam_mysql.so
/bin/install -c .libs/pam_mysql.lai /lib64/security/pam_mysql.la
PATH=&quot;$PATH:/sbin&quot; ldconfig -n /lib64/security
----------------------------------------------------------------------
Libraries have been installed in:
   /lib64/security

If you ever happen to want to link against installed libraries
in a given directory, LIBDIR, you must either use libtool, and
specify the full pathname of the library, or use the `-LLIBDIR'
flag during linking and do at least one of the following:
   - add LIBDIR to the `LD_LIBRARY_PATH' environment variable
     during execution
   - add LIBDIR to the `LD_RUN_PATH' environment variable
     during linking
   - use the `-Wl,--rpath -Wl,LIBDIR' linker flag
   - have your system administrator add LIBDIR to `/etc/ld.so.conf'

See any operating system documentation about shared libraries for
more information, such as the ld(1) and ld.so(8) manual pages.
----------------------------------------------------------------------
make[1]: 对“install-data-am”无需做任何事。
make[1]: 离开目录“/root/pam_mysql-0.7RC1”
[root@test pam_mysql-0.7RC1]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：到此pam_mysql就编译安装好了，接下来就需要看，源码包里的README文件，看看模块的用法&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test pam_mysql-0.7RC1]#less README 
pam_mysql - A PAM authentication module against MySQL database.
$Id: README,v 1.8.2.9 2006/01/09 10:35:59 moriyoshi Exp $

Introduction
------------
This is a successor of the &quot;old&quot; pam_mysql module, which comes with
a more stable, secure and robust implementation.

Prerequisites
-------------
To try this module, you need the following stuff:
 - A *NIX (or similar) system, in which PAM facility is set up and working
   either system-wide or in a chroot jail.
 - A MySQL server, up and running.

Installation instruction
------------------------
See INSTALL file for detail.

An example of the configuration file:
---------------------------------------------------------------
auth       optional     pam_mysql.so user=root passwd=password
account    required     pam_mysql.so user=root passwd=password
---------------------------------------------------------------

Available options
-----------------
The module options are listed below with default in ()s:

verbose (0)

    If set to 1, produces logs with detailed messages that describes what
    PAM-MySQL is doing. May be useful for debugging.

debug

    An alias for the verbose option. This is added in 0.7pre2.

user

    The user name used to open the specified MySQL database.

passwd

    The password used to open the specified MySQL database.

host

    The host name or the absolute path to the unix socket where the
        MySQL server is listening.  The following formats are accepted:

    1. absolute path to the unix socket (e.g. &quot;/tmp/mysql.sock&quot;)
        2. host name (e.g. &quot;somewhere.example.com&quot;)
        3. host name + port number (e.g. &quot;somewhere.example.com:3306&quot;)

db

    The name of the database that contains a user-password table.

table

    The name of table that maps unique login names to the passwords.
    This can be a combination of tables with full JOIN syntax if you
    need more control.  For example:

        [table=Host LEFT JOIN HostUser ON HostUser.host_id=Host.id \
                    LEFT JOIN User ON HostUser.user_id=User.id]

update_table

    The name of the table used for password alteration.
    If not defined, the value of the &quot;table&quot; option will be used instead.
    This is handy if you have a complex JOIN instead of a simple table in
    the &quot;table&quot; option above.

usercolumn

    The name of the column that contains a unix login name.
    Should be in a fully qualified form.

passwdcolumn

    The name of the column that contains a (encrypted) password string.
    Should be in a fully qualified form.

statcolumn

    The name of the column or an SQL expression that indicates the status of
    the user. The status is expressed by the combination of two bitfields
    shown below:

    bit 0 (0x01): if flagged, pam_mysql deems the account to be expired and
                  returns PAM_ACCT_EXPIRED. That is, the account is supposed
                  to no longer be available. Note this doesn't mean that
                  pam_mysql rejects further authentication operations.

    bit 1 (0x02): if flagged, pam_mysql deems the authentication token
                  (password) to be expired and returns PAM_NEW_AUTHTOK_REQD.
                  This ends up requiring that the user enter a new password.

    This option is available since 0.6.

crypt (plain)

    The method to encrypt the user's password:

       0 (or &quot;plain&quot;) = No encryption.  Passwords stored in plaintext.
                        HIGHLY DISCOURAGED.

       1 (or &quot;Y&quot;)     = Use crypt(3) function.

       2 (or &quot;mysql&quot;) = Use MySQL PASSWORD() function. It is possible
                        that the encryption function used by PAM-MySQL
                        is different from that of the MySQL server, as
                        PAM-MySQL uses the function defined in MySQL's
                        C-client API instead of using PASSWORD() SQL function
                        in the query.
                        
       3 (or &quot;md5&quot;)   = Use plain hex MD5.

       4 (or &quot;sha1&quot;)  = Use plain hex SHA1.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：从上面的信息我们可以了解到pam_mysql.so的用法就是传给模块几个参数，其中user指定其连接数据库服务器的用户名，passwd指定连接数据库用户名的密码，host是指定mysql服务器地址，db指定数据库名，table指定存放虚拟用户的表名，usercolumn指定存放虚拟用户名单字段名称，passwdcolumn指定存放虚拟用户密码字段名称 ，crypt指定加密类型，其中crypt=2表示存放使用mysql password()函数加密后的密码。接下来编写vsftpd基于mysql验证的配置文件&lt;/p&gt;
&lt;p&gt;　　创建vsftpd调用pam_mysql的配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test pam_mysql-0.7RC1]#cat /etc/pam.d/vsftpd.mysql
auth required pam_mysql.so user=vsftpd passwd=admin123.com host=192.168.0.218 db=vsftpd table=users usercolumn=name passwdcolumn=password crypt=2
account required pam_mysql.so user=vsftpd passwd=admin123.com host=192.168.0.218 db=vsftpd table=users usercolumn=name passwdcolumn=password crypt=2
[root@test pam_mysql-0.7RC1]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：pam的配置文件格式大致有4个部分，第一部分是工作类别，比如auth表示认证，account表示验证账号密码正常使用；第二部分是控制模式，用于模块在给出各种结果时pam的行为，required表示认证通过；第三部分是模块名称或路径 ；第四部分是模块的参数；综合这四部分它表达的综合意思是，如果本条目验证通过则验证下面的条目，若不通过则验证最终失败，但是它还会验证下面的条目，这就是刚才说的第二部分控制模式required，也就说要想验证通过，必须满足此条目。&lt;/p&gt;
&lt;p&gt;　　修改vsftpd配置文件，指定pam的配置文件为vsftpd.mysql&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test pam_mysql-0.7RC1]#grep &quot;pam&quot; /etc/vsftpd/vsftpd.conf
pam_service_name=vsftpd.db
[root@test pam_mysql-0.7RC1]#sed -i 's@pam_service_name=vsftpd.db@pam_service_name=vsftpd.mysql@' /etc/vsftpd/vsftpd.conf
[root@test pam_mysql-0.7RC1]#grep &quot;pam&quot; /etc/vsftpd/vsftpd.conf
pam_service_name=vsftpd.mysql
[root@test pam_mysql-0.7RC1]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：此实验是接着上面的基于文件存放虚拟用户的基础上修改配置来完成对，若不是，还需要创建一个映射到系统用户账号，还要在配置文件中配置启动guest ，guest账号映射成创建的那个账号， 还要更改创建用户的家目录不能有写的权限，在其目录下创建一个目录，让其映射到系统用户有写权限。这些步骤都需要去做。&lt;/p&gt;
&lt;p&gt;　　重启vsftpd服务，查看服务是否启动起来&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test pam_mysql-0.7RC1]#systemctl restart vsftpd
[root@test pam_mysql-0.7RC1]#ss -ntl
State      Recv-Q Send-Q                         Local Address:Port                                        Peer Address:Port              
LISTEN     0      100                                127.0.0.1:25                                                     *:*                  
LISTEN     0      25                                         *:514                                                    *:*                  
LISTEN     0      128                                        *:41319                                                  *:*                  
LISTEN     0      50                                         *:3306                                                   *:*                  
LISTEN     0      100                                      ::1:25                                                    :::*                  
LISTEN     0      25                                        :::514                                                   :::*                  
LISTEN     0      128                                       :::41319                                                 :::*                  
LISTEN     0      128                                       :::80                                                    :::*                  
LISTEN     0      32                                        :::21                                                    :::*                  
[root@test pam_mysql-0.7RC1]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：可以看到21好端口已经起来了&lt;/p&gt;
&lt;p&gt;　　在数据库服务器上添加虚拟账号&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
mysql&amp;gt; desc users;
+----------+----------+------+-----+---------+----------------+
| Field    | Type     | Null | Key | Default | Extra          |
+----------+----------+------+-----+---------+----------------+
| id       | int(11)  | NO   | PRI | NULL    | auto_increment |
| name     | char(50) | NO   |     | NULL    |                |
| password | char(48) | NO   |     | NULL    |                |
+----------+----------+------+-----+---------+----------------+
3 rows in set (0.00 sec)

mysql&amp;gt; insert users(name,password) values('user1',password('admin1')),('user2',password('admin2'));
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql&amp;gt; select * from users;
+----+-------+-------------------------------------------+
| id | name  | password                                  |
+----+-------+-------------------------------------------+
|  1 | user1 | *6D45FD76D5E9C6A404E39C25106A7F032659ACB8 |
|  2 | user2 | *0E6FD44C7B722784DAE6E67EF8C06FB1ACB3E0A6 |
+----+-------+-------------------------------------------+
2 rows in set (0.00 sec)

mysql&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：因为我们配置文件中写的加密方式是用mysql password（）函数加密密码，所以我们在插入密码口令是一定要调用password()函数来加密我们的口令&lt;/p&gt;
&lt;p&gt;　　到此vsftpd的虚拟用户已经实现存放到mysql里，接下来我们就可以用我们创建的user1和user2用户登录ftp服务器&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#ftp 192.168.0.99
Connected to 192.168.0.99 (192.168.0.99).
220 (vsFTPd 3.0.2)
Name (192.168.0.99:root): user1
331 Please specify the password.
Password:
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp&amp;gt; ls
227 Entering Passive Mode (192,168,0,99,251,38).
150 Here comes the directory listing.
-rw-r--r--    1 0        0             552 Dec 27 16:40 test_file
drwxrwxr-x    2 0        0              19 Dec 27 16:58 upload
-rw-r--r--    1 0        0               0 Dec 27 16:39 vuser_home
226 Directory send OK.
ftp&amp;gt; bye
221 Goodbye.
[root@test ~]#ftp 192.168.0.99
Connected to 192.168.0.99 (192.168.0.99).
220 (vsFTPd 3.0.2)
Name (192.168.0.99:root): user2
331 Please specify the password.
Password:
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp&amp;gt; ls
227 Entering Passive Mode (192,168,0,99,163,148).
150 Here comes the directory listing.
-rw-r--r--    1 0        0             552 Dec 27 16:40 test_file
drwxrwxr-x    2 0        0              19 Dec 27 16:58 upload
-rw-r--r--    1 0        0               0 Dec 27 16:39 vuser_home
226 Directory send OK.
ftp&amp;gt; bye
221 Goodbye.
[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：可看到我们新建两个虚拟账号是可以正常登录到ftp系统，但是他俩的权限似乎都是一致的，登录都是同一目录下。&lt;/p&gt;
&lt;p&gt;　　修改user1 user2的权限&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#ll /etc/vsftpd/vusers.d/
总用量 8
-rw-r--r-- 1 root root 20 12月 28 00:27 jerry
-rw-r--r-- 1 root root 79 12月 28 00:26 tom
[root@test ~]#cat &amp;gt;&amp;gt; /etc/vsftpd/vusers.d/user1 &amp;lt;&amp;lt; EOF
&amp;gt; anon_upload_enable=YES
&amp;gt; anon_mkdir_write_enable=YES
&amp;gt; anon_other_write_enable=YES
&amp;gt; EOF
[root@test ~]#cat /etc/vsftpd/vusers.d/user1 
anon_upload_enable=YES
anon_mkdir_write_enable=YES
anon_other_write_enable=YES
[root@test ~]#cat &amp;gt;&amp;gt; /etc/vsftpd/vusers.d/user2 &amp;lt;&amp;lt; EOF
&amp;gt; local_root=/var/ftp
&amp;gt; EOF
[root@test ~]#cat /etc/vsftpd/vusers.d/user2 
local_root=/var/ftp
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试：&lt;/p&gt;
&lt;p&gt;　　用user1登录ftp服务器，上传和下载文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;60&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#ftp 192.168.0.99
Connected to 192.168.0.99 (192.168.0.99).
220 (vsFTPd 3.0.2)
Name (192.168.0.99:root): user1
331 Please specify the password.
Password:
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp&amp;gt; ls
227 Entering Passive Mode (192,168,0,99,209,0).
150 Here comes the directory listing.
-rw-r--r--    1 0        0             552 Dec 27 16:40 test_file
drwxrwxr-x    2 0        0              29 Dec 27 19:06 upload
-rw-r--r--    1 0        0               0 Dec 27 16:39 vuser_home
226 Directory send OK.
ftp&amp;gt; get test_file
local: test_file remote: test_file
227 Entering Passive Mode (192,168,0,99,33,135).
150 Opening BINARY mode data connection for test_file (552 bytes).
226 Transfer complete.
552 bytes received in 0.000111 secs (4972.97 Kbytes/sec)
ftp&amp;gt; !ls
bak  pam_mysql-0.7RC1  pam_mysql-0.7RC1.tar.gz  test_file
ftp&amp;gt; cd upload
250 Directory successfully changed.
ftp&amp;gt; ls
227 Entering Passive Mode (192,168,0,99,33,221).
150 Here comes the directory listing.
-rw-------    1 1005     1005          552 Dec 27 16:58 fstab
-rw-------    1 1005     1005       117680 Dec 27 19:06 ls
226 Directory send OK.
ftp&amp;gt; put pam_mysql-0.7RC1.tar.gz 
local: pam_mysql-0.7RC1.tar.gz remote: pam_mysql-0.7RC1.tar.gz
227 Entering Passive Mode (192,168,0,99,189,142).
150 Ok to send data.
226 Transfer complete.
335240 bytes sent in 0.00172 secs (194342.03 Kbytes/sec)
ftp&amp;gt; ls
227 Entering Passive Mode (192,168,0,99,196,23).
150 Here comes the directory listing.
-rw-------    1 1005     1005          552 Dec 27 16:58 fstab
-rw-------    1 1005     1005       117680 Dec 27 19:06 ls
-rw-------    1 1005     1005       335240 Dec 27 19:12 pam_mysql-0.7RC1.tar.gz
226 Directory send OK.
ftp&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：可看到user1可以正常的上传和下载，当然上传下载还关系到对应的文件系统是否有读写权限，这个还要结合到其他选项的配置。&lt;/p&gt;
&lt;p&gt;　　用user2登录ftp服务器，查看所在的目录和user1是否相同&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#ftp 192.168.0.99
Connected to 192.168.0.99 (192.168.0.99).
220 (vsFTPd 3.0.2)
Name (192.168.0.99:root): user2
331 Please specify the password.
Password:
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp&amp;gt; ls
227 Entering Passive Mode (192,168,0,99,214,69).
150 Here comes the directory listing.
drwxr-xr-x    2 0        0              21 Oct 30  2018 pub
-rw-r--r--    1 0        0               0 Dec 27 16:39 varftp_dir
226 Directory send OK.
ftp&amp;gt; bye
221 Goodbye.
[root@test ~]#ll /var/ftp/
总用量 0
drwxr-xr-x 2 root root 21 10月 31 2018 pub
-rw-r--r-- 1 root root  0 12月 28 00:39 varftp_dir
[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：和上面user1登录的目录里的文件可以判断user1和user2登录到ftp服务器后，不是在同一个目录里，user1登录的是vuser的家目录/var/ftpboot/，而user2登录到ftp系统的目录是/var/ftp&lt;/p&gt;
</description>
<pubDate>Fri, 27 Dec 2019 19:20:00 +0000</pubDate>
<dc:creator>qiuhom</dc:creator>
<og:description>一、FTP介绍 ftp（File Transfer Protocol）是早期的三个应用级协议之一，基于C/S结构，双通道协议，数据和命令连接，数据传输格式默认是二进制，当然也支持文件方式传输。默认情况</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/12106900.html</dc:identifier>
</item>
<item>
<title>如何更优雅地对接第三方API - OKevin</title>
<link>http://www.cnblogs.com/yulinfeng/p/12110213.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yulinfeng/p/12110213.html</guid>
<description>&lt;p&gt;&lt;strong&gt;本文所有示例完整代码地址：https://github.com/yu-linfeng/BlogRepositories/tree/master/repositories/third&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们在日常开发过程中，有不少场景会对接第三方的API，例如第三方账号登录，第三方服务等等。第三方服务会提供API或者SDK，我依稀记得早些年Maven还没那么广泛使用，通常要对接第三方服务的时候会去下载第三方服务的SDK开发包，也就是jar包，拷贝到自己的工程中进行开发。但现如今，几乎所有的大中小企业都使用Maven进行依赖管理，第三方服务通过提供SDK包的情况越来越少，有的SDK也早已处于不再更新的状态。并且现在流行的微服务以及轻量级的RESTful通信方式，使得第三方服务主要提供API接口。&lt;/p&gt;
&lt;p&gt;API接口，指的是通过HTTP的方式提供服务对接，也就需要对接方发起HTTP请求，解析第三方服务返回的数据；而SDK开发包，指的是对接方直接调用第三方服务提供的Java方法进行调用，不再对第三方服务发起HTTP请求。从便利性上讲，以SDK的方式对接第三方服务，的确能更加方便地进行开发对接工作。而从目前的趋势看，以RESTful通信的微服务正逐渐成为主流，服务的提供方也不再对外提供SDK开发包，因为这涉及开发量以及包的依赖问题。&lt;/p&gt;
&lt;p&gt;我仍记得在第一家公司对接第三方API时的场景，业务要求能通过&lt;strong&gt;微信发起WiFi连接&lt;/strong&gt;，这自然需要对接微信提供的API接口。那时我用了“最低级”的对接方式，也就是使用原生JDK发起HTTP请求，以及对HTTP响应的JSON数据进行解析获取我想要的数据。这其中的坑不胜其数，手写的HTTP请求客户端本身的不健壮，解析响应数据时经常抛出空指针，其中的苦恼不尽其数。&lt;/p&gt;
&lt;p&gt;直到现在，SpringBoot为我们封装了&lt;code&gt;RestTemplate&lt;/code&gt;，再到SpringCloud可以通过&lt;code&gt;Feign&lt;/code&gt;让我们调用API就好像在调用接口一般顺滑。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Feign&lt;/code&gt;诠释了什么是面向对象，什么是一切皆为对象，我甚至认为，它可以作为面向对象编程实践的典型。&lt;/p&gt;
&lt;p&gt;所以本文将以下4个示例讲述如何优雅地对接第三方API。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原生JDK构造HTTP请求客户端，调用API&lt;/li&gt;
&lt;li&gt;在SpringBoot下使用&lt;code&gt;RestTemplate&lt;/code&gt;，以及抽取配置的方式调用API&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;OpenFeign&lt;/code&gt;以及抽取配置的方式调用API&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;9.0120481927711&quot;&gt;
&lt;p&gt;&lt;strong&gt;准备工作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第三方API提供方，聚合数据：&lt;a href=&quot;https://www.cnblogs.com/yulinfeng/p/www.juhe.cn&quot; class=&quot;uri&quot;&gt;www.juhe.cn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;API接口详情：&lt;a href=&quot;https://www.juhe.cn/docs/api/id/21&quot; class=&quot;uri&quot;&gt;https://www.juhe.cn/docs/api/id/21&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;appKey（建议注册账号免费申请）：71e065a2cdf2753a5d6261b5002498b7&lt;/p&gt;
&lt;p&gt;实现的功能：根据股票代码获取股票名称&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;原生jdk构造http请求客户端调用api&quot;&gt;原生JDK构造HTTP请求客户端，调用API&lt;/h3&gt;
&lt;p&gt;这种方式需要手动去创建HTTP连接，并将数据写入流中，再将数据转换为JSON对象进行解析。&lt;/p&gt;
&lt;p&gt;存在以下几个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;配置未抽取，以硬编码方式注入不利于维护&lt;/li&gt;
&lt;li&gt;返回的数据是字符串，将它转换为JSON对象极其不直观&lt;/li&gt;
&lt;li&gt;原生JDK构造HTTP客户端不能保证健壮性&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;第一个问题&lt;/strong&gt;，首先是不可取的，必须将它抽取为&lt;code&gt;properties&lt;/code&gt;或者&lt;code&gt;yml&lt;/code&gt;配置。将appId或者appKey以硬编码的方式注入，不是一个合格的工程师。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二个问题&lt;/strong&gt;，转换为JSON对象获取数据：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//本文所有示例完整代码地址：https://github.com/yu-linfeng/BlogRepositories/tree/master/repositories/third
String data = getResponse(code);        //获取API返回数据
JSONObject jsonObject = JSONObject.parseObject(data);       //将数据转换为JSON对象
if (jsonObject.getInteger(&quot;error_code&quot;) != 0) {     //判断API接口是否调用成功
  return ;
}
//解析数据，获取股票名称
JSONArray resultArray = JSONArray.parseArray(jsonObject.getString(&quot;result&quot;));
JSONObject result = JSONObject.parseObject(resultArray.getString(0));
JSONObject stockObject = JSONObject.parseObject(result.getString(&quot;data&quot;));
String stockName = stockObject.getString(&quot;name&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你写完后，还能回忆起这个API接口所返回的数据格式吗？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三个问题&lt;/strong&gt;，也就是上面代码片段中的&lt;code&gt;getResponse&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//本文所有示例完整代码地址：https://github.com/yu-linfeng/BlogRepositories/tree/master/repositories/third
String strUrl = String.format(URL, code, APPKEY);
StringBuffer sb = new StringBuffer();
URL url = new URL(strUrl);
HttpURLConnection conn = (HttpURLConnection) url.openConnection();      //创建一个HTTP连接
//构造HTTP请求数据
conn.setRequestMethod(&quot;GET&quot;);
conn.setRequestProperty(&quot;User-agent&quot;, USER_AGENT);
conn.connect();     //打开连接
InputStream is = conn.getInputStream();
BufferedReader reader = new BufferedReader(new InputStreamReader(is, &quot;UTF-8&quot;));
//将API接口的返回数据写入
String strRead = null;
while ((strRead = reader.readLine()) != null) {
  sb.append(strRead);
}
return sb.toString();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种“教科书”式的实现方式，其代码的复杂度，健壮性都值得商榷，有的工程中将HTTP请求客户端封装成一个公共类，有的使用现有的一些HTTP请求客户端。但我认为这都不是好的方式。就算例如Okhttp有很好的稳定性，但也解决不了第二个接口返回数据解析的问题，&lt;/p&gt;
&lt;h3 id=&quot;在springboot下使用resttemplate以及抽取配置的方式调用api&quot;&gt;在SpringBoot下使用&lt;code&gt;RestTemplate&lt;/code&gt;，以及抽取配置的方式调用API&lt;/h3&gt;
&lt;p&gt;前面我们使用最“古老”的方式发现了3个问题，在SpringBoot大行其道的今天，将一些配置抽取出来，不同的环境运行不同的配置文件是常见的做法。例如我们可以将上面的appKey放到&lt;code&gt;application.yml&lt;/code&gt;配置文件中。&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;juhe-stock:
  appKey: 71e065a2cdf2753a5d6261b5002498b7&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时定义第三方服务的配置类。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.coderbuff.third2resttemplateprop;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

/**
 * 配置
 * @author yulinfeng
 * @date 2019/12/26
 */
@Data
@Component
@ConfigurationProperties(&quot;juhe-stock&quot;)
public class JuheConfig {
  
    /**
     * appkey
     */
    private String appKey;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样当Spring容器启动时，appKey就被注入到了&lt;code&gt;JuheConfig&lt;/code&gt;类的&lt;code&gt;appKey&lt;/code&gt;字段中。&lt;/p&gt;
&lt;p&gt;第一个问题被完美解决了，接下来我们来看如何通过&lt;code&gt;RestTemplate&lt;/code&gt;解决第二、第三个问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RestTemplate&lt;/code&gt;简化了我们发起HTTP请求，它内部默认使用JDK构造HTTP客户端，它发起HTTP请求获取响应数据通过&lt;code&gt;getForObject&lt;/code&gt;和&lt;code&gt;getForEntity&lt;/code&gt;，前者能直接将响应数据封装成一个对象，后者则将封装HTTP调用的一些响应状态，在我们使用&lt;code&gt;getForObject&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getForObject&lt;/code&gt;能将响应数据直接转换为一个对象供我们使用，这意味着我们不再依靠繁琐的JSON格式转换获取我们想要的数据，但同时也意味着我们需要定义返回对象。我们先看示例中，返回的JSON是怎么的格式。&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;resultcode&quot;:&quot;200&quot;,
    &quot;reason&quot;:&quot;SUCCESSED!&quot;,
    &quot;result&quot;:[
        {
            //省略
            &quot;dapandata&quot;:{
                &quot;name&quot;:&quot;贵州茅台&quot;
                //省略
            }
        }
    ],
    &quot;error_code&quot;:0
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为篇幅原因，我省略了一些字段信息。观察JSON数据格式，我们只需要拿到股票名称，股票名称处于比较底层的位置，我们定义一个叫做&lt;code&gt;JuheStockResultDapanData&lt;/code&gt;的类，字段和JSON中的key相同。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.coderbuff.third2resttemplateprop.entity;

import lombok.Data;

/**
 * @author yulinfeng
 * @date 2019/12/26
 */
@Data
public class JuheStockResultDapanData {
    private String name;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它的外层key是一个数组，对应的也就是&lt;code&gt;List&lt;/code&gt;，其中的一个对象就是我们定义的&lt;code&gt;JuheStockResultDapanData&lt;/code&gt;，所以我们定义一个&lt;code&gt;JuheStockResult&lt;/code&gt;类，对应JSON中key=result的数据。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.coderbuff.third2resttemplateprop.entity;

import lombok.Data;

/**
 * @author yulinfeng
 * @date 2019/12/26
 */
@Data
public class JuheStockResult {
    private JuheStockResultDapanData dapandata;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在最外层是一些调用信息和错误码，所以我们继续定义一个响应类&lt;code&gt;JuheStockResponse&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.coderbuff.third2resttemplateprop.entity;

import lombok.Data;

import java.util.List;
import java.util.Map;

/**
 * @author yulinfeng
 * @date 2019/12/26
 */
@Data
public class JuheStockResponse {

    /**
     * 响应码
     */
    private String resultcode;

    /**
     * 错误信息
     */
    private String reason;

    /**
     * 错误码
     */
    private String error_code;

    /**
     * 数据
     */
    private List&amp;lt;JuheStockResult&amp;gt; result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意字段名要和API接口返回的JSON数据key值保持一致。这样我们就定义好了整个JSON对象所对应的Java对象，其中我省略了很多字段，Java对象中没有JSON中对应的字段，数据自然也不会映射到Java对象中。接下来就是使用&lt;code&gt;RestTemplate#getForObject&lt;/code&gt;方法调用API接口。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//本文所有示例完整代码地址：https://github.com/yu-linfeng/BlogRepositories/tree/master/repositories/third
String url = String.format(URL, code, juheConfig.getAppKey());  //拼接URL
RestTemplate restTemplate = new RestTemplate();
restTemplate.setMessageConverters(parseContentType());  //设置ContentType支持的类型
JuheStockResponse response = restTemplate.getForObject(url, JuheStockResponse.class);
JuheStockResultDapanData juheStockResultDapanData = 
  response.getResult().get(0).getDapandata();
String name = juheStockResultDapanData.getName();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到这种方式相比较于第一种“教科书”式调用HTTP接口，无论从易用性和健壮性都要略胜一筹，特别是不再去解析JSON对象，&lt;code&gt;RestTemplate&lt;/code&gt;已经为我们做好了转换，这样的代码，即使换了一个人维护，也同样能明白是什么含义。&lt;/p&gt;
&lt;p&gt;这种对接第三方API的方式，我想也是常年使用SpringBoot所采用的方式，因为它都解决了我们在开头提到几个问题，似乎想不到还能有什么更优雅地方式，直到遇到了下面的方式。&lt;/p&gt;
&lt;h3 id=&quot;使用openfeign以及抽取配置的方式调用api&quot;&gt;使用&lt;code&gt;OpenFeign&lt;/code&gt;以及抽取配置的方式调用API&lt;/h3&gt;
&lt;p&gt;在使用这种方式调用第三方API时，我简直想要大呼一声&lt;strong&gt;Amazing！&lt;/strong&gt;，简直太完美太优雅了。它不但解决了上面的3个问题，它同时把&lt;strong&gt;面向对象&lt;/strong&gt;的思想发挥到了极致。&lt;/p&gt;
&lt;p&gt;上面的思路不过是封装再封装，封装完HTTP客户端后又封装了JSON数据转换，实际上的思路仍然是传递一个URL-&amp;gt;请求-&amp;gt;响应的思路，但接下来的这种方式，真真正正地诠释了什么是&lt;strong&gt;面向对象&lt;/strong&gt;，什么是&lt;strong&gt;一切皆为对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;它将API调用变得更加像调用普通接口一样方便。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用过SpringCloud的同学对&lt;code&gt;Feign&lt;/code&gt;并不陌生，甚至觉得我孤陋寡闻。原版的&lt;code&gt;OpenFeign&lt;/code&gt;可不依赖Spring独立使用（&lt;a href=&quot;https://github.com/OpenFeign/feign&quot; class=&quot;uri&quot;&gt;https://github.com/OpenFeign/feign&lt;/a&gt;），SpringCloud整合了&lt;code&gt;OpenFeign&lt;/code&gt;，在SpringCloud2.x，Feign甚至成为了SpringCloud的一级项目（&lt;a href=&quot;https://cloud.spring.io/spring-cloud-openfeign/&quot; class=&quot;uri&quot;&gt;https://cloud.spring.io/spring-cloud-openfeign/&lt;/a&gt;）这足以体现它的地位。&lt;/p&gt;
&lt;p&gt;在SpringCloud中，&lt;code&gt;OpenFeign&lt;/code&gt;的功能很强大，它为微服务架构下服务之间的调用提供了解决方案，同时它可以结合其它组件可以实现负载均衡的HTTP客户端。&lt;/p&gt;
&lt;p&gt;接下来我们将展示使用原版的&lt;code&gt;OpenFeign&lt;/code&gt;优雅地调用第三方API服务。&lt;/p&gt;
&lt;p&gt;我们同样需要定义&lt;code&gt;JuheStockResponse&lt;/code&gt;、&lt;code&gt;JuheStockResult&lt;/code&gt;、&lt;code&gt;JuheStockResultDapanData&lt;/code&gt;类，因为在&lt;code&gt;OpenFeign&lt;/code&gt;中，也自动的将JSON数据转换为了Java对象。但我们需要定义一个&lt;strong&gt;接口&lt;/strong&gt;——&lt;code&gt;JuheClient&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.coderbuff.third3feignprop;

import com.coderbuff.third3feignprop.entity.JuheStockResponse;
import feign.Param;
import feign.RequestLine;

/**
 * @author yulinfeng
 * @date 2019/12/26
 */
public interface JuheClient {

    /**
     * 根据股票代码查询股票信息
     * @param code 股票代码
     * @return 接口返回
     */
    @RequestLine(&quot;GET /finance/stock/hs?gid={gid}&amp;amp;key={key}&quot;)
    JuheStockResponse queryStock(@Param(&quot;gid&quot;) String code, @Param(&quot;key&quot;) String appKey);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这简直就是&lt;strong&gt;面向对象&lt;/strong&gt;思想的最佳实践，接下来的工作基本上就是直接调用这个方法，就能调用我们想要调用的API。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//本文所有示例完整代码地址：https://github.com/yu-linfeng/BlogRepositories/tree/master/repositories/third
JuheClient client = Feign.builder().encoder(new JacksonEncoder()).decoder(new JacksonDecoder()).target(JuheClient.class, juheConfig.getUrl());
JuheStockResponse response = client.queryStock(code, juheConfig.getAppKey());
JuheStockResultDapanData juheStockResultDapanData = 
  response.getResult().get(0).getDapandata();
String name = juheStockResultDapanData.getName();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这看起来似乎和直接使用&lt;code&gt;RestTemplate&lt;/code&gt;并无大异，但我仍然想表达我的激动，我仍然认为这其中的奥秘不在于编码的具体实现，而在于将API接口调用上升到了&lt;strong&gt;面向对象&lt;/strong&gt;的最佳实践。没有了URL的拼接，像调用普通接口一样方便地调用第三方API。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文所有示例完整代码地址：https://github.com/yu-linfeng/BlogRepositories/tree/master/repositories/third&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注公众号：CoderBuff，回复“es”获取《ElasticSearch6.x实战教程》完整版PDF。&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;这是一个能给程序员加buff的公众号 （CoderBuff）&lt;/p&gt;
&lt;br/&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/630246/201907/630246-20190717223740465-1981496921.png&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Fri, 27 Dec 2019 16:50:00 +0000</pubDate>
<dc:creator>OKevin</dc:creator>
<og:description>本文所有示例完整代码地址：https://github.com/yu linfeng/BlogRepositories/tree/master/repositories/third 我们在日常开发过程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yulinfeng/p/12110213.html</dc:identifier>
</item>
<item>
<title>大数据（4）---HDFS工作机制简述 - 白露非霜</title>
<link>http://www.cnblogs.com/nijunyang/p/12110102.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nijunyang/p/12110102.html</guid>
<description>[unable to retrieve full-text content]一、name node管理元数据 元数据：hdfs的目录结构以及文件文件的块信息（块副本数量，存放位置等）。 Namenode把元数据存在内存中，以方便改动，同时也会在某个时间点上面将其写到磁盘上（fsimage镜像文件）。同时还会把引起元数据变化的操作记录在edits日志文件中。重新启动或者是服务</description>
<pubDate>Fri, 27 Dec 2019 15:45:00 +0000</pubDate>
<dc:creator>白露非霜</dc:creator>
<dc:identifier>https://www.cnblogs.com/nijunyang/p/12110102.html</dc:identifier>
</item>
<item>
<title>爬虫工程师的unidbg入门教程 - 成小新</title>
<link>http://www.cnblogs.com/xbjss/p/12110083.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xbjss/p/12110083.html</guid>
<description>&lt;ul&gt;&lt;li&gt;现在很多的app使用了so加密，以后会越来越多。爬虫工程师可能会直接逆向app，看java代码，完成java层的算法破解，但是如果遇到so该怎么办呢？可能你会直接破解so，但是真的会有很多爬虫工程师会去并且会破解so吗？有时候我们可以不用破解so，利用很多大佬写好的轮子即可完成so的调用。&lt;/li&gt;
&lt;li&gt;说到调用，就有很多方法了，比如用frida的rpc、xposed+andserver、再者就是unicorn+web框架等等，今天要说的并不是这些，而是unidbg，这框架有什么好的地方呢？看看介绍。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;介绍来自逸飞&quot;&gt;介绍（来自逸飞）&lt;/h2&gt;
&lt;p&gt;unidbg 是一个基于 unicorn 的逆向工具，可以黑盒调用安卓和 iOS 中的 so 文件。unidbg 是一个标准的 java 项目。&lt;/p&gt;
&lt;p&gt;由于现在的大多数 app 把签名算法已经放到了 so 文件中，所以要想破解签名算法，必须能够破解 so 文件。但是我们知道，C++ 的逆向远比 Java 的逆向要难得多了，所以好多时候是没法破解的，那么这个时候还可以采用 hook 的方法，直接读取程序中算出来的签名，但是这样的话，需要实际运行这个应用，需要模拟器或者真机，效率又不是很高。&lt;/p&gt;
&lt;p&gt;unidbg 就是一个很巧妙地解决方案，他不需要直接运行 app，也无需逆向 so 文件，而是通过在 app 中找到对应的 JNI 接口，然后用 unicorn 引擎直接执行这个 so 文件，所以效率也比较高。&lt;/p&gt;
&lt;ul readability=&quot;0.45584415584416&quot;&gt;&lt;li readability=&quot;3.6467532467532&quot;&gt;
&lt;p&gt;这里重要的是目前利用unidbg+springboot做成了web服务。&lt;/p&gt;
&lt;h2 id=&quot;食用&quot;&gt;食用&lt;/h2&gt;
&lt;p&gt;案例来自JXU2QkQyYXBwJTIwdjQuMTYuMA==&lt;br/&gt;对于该app而言，是非常适合入门的一个app，未加固、算法简单、很容易找到so的jni。&lt;br/&gt;先去凯神的github上下载&lt;a href=&quot;https://github.com/zhkl0228/unidbg&quot; class=&quot;uri&quot;&gt;https://github.com/zhkl0228/unidbg&lt;/a&gt;&lt;br/&gt;下载完毕用idea打开，等待maven下载完毕。我这里已经创建好du的文件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/12/27/16f47d3080de78a1?w=896&amp;amp;h=256&amp;amp;f=png&amp;amp;s=55937&quot;/&gt;&lt;br/&gt;上个代码看着比较方便,代码中有很多注释&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class du extends AbstractJni {

    //ARM模拟器
    private final ARMEmulator emulator;
    //vm
    private final VM vm;
    //载入的模块
    private final Module module;

    private final DvmClass TTEncryptUtils;

    //初始化
    public du() throws IOException {
        //创建app进程，这里其实可以不用写的，我这里是随便写的，使用app本身的进程就可以绕过进程检测
        emulator = new AndroidARMEmulator(&quot;com.du.du&quot;);
        Memory memory = emulator.getMemory();
        //作者支持19和23两个sdk
        memory.setLibraryResolver(new AndroidResolver(23));
        memory.setCallInitFunction();
        //创建DalvikVM，利用apk本身，可以为null
        //如果用apk文件加载so的话，会自动处理签名方面的jni，具体可看AbstractJni,利用apk加载的好处，
//        vm = emulator.createDalvikVM(new File(&quot;src/test/resources/du/du4160.apk&quot;));
我这里没有用到apk，主要是没有检测其他因素。
        vm = emulator.createDalvikVM(null);
        //加载so，使用armv8-64速度会快很多，这里是so的文件路径，其实也可以利用apk自身的。
        DalvikModule dm = vm.loadLibrary(new File(&quot;src/test/resources/du/libJNIEncrypt.so&quot;), false);
        //调用jni
        dm.callJNI_OnLoad(emulator);
        module = dm.getModule();
        //加载so的那个类
        TTEncryptUtils = vm.resolveClass(&quot;com/duapp/aesjni/AESEncrypt&quot;);
    }


    //关闭模拟器
    private void destroy() throws IOException {
        emulator.close();
        System.out.println(&quot;destroy&quot;);
    }

    public static void main(String[] args) throws IOException {
        du t = new du();
        t.encodeByte();
        t.destroy();
    }

    private String encodeByte() {
        //调试
        // 这里还支持gdb调试，
        //emulator.attach(DebuggerType.GDB_SERVER);
        //附加调试器
//        emulator.attach(DebuggerType.SIMPLE);
//        emulator.traceCode();
        //这里是打断点，原地址0x00005028-&amp;gt;新地址0x40005028 新地址需要改成0x4 
//        emulator.attach().addBreakPoint(null, 0x40001188);//encode地址
//        emulator.attach().addBreakPoint(null, 0x40000D10);
        Number ret = TTEncryptUtils.callStaticJniMethod(emulator, &quot;getByteValues()Ljava/lang/String;&quot;);
        long hash = ret.intValue() &amp;amp; 0xffffffffL;
        StringObject st1 = vm.getObject(hash);
        //*这里要处理下字符串
        String byteString = st1.getValue();
        StringBuilder builder = new StringBuilder(byteString.length());
        for (int i = 0; i &amp;lt; byteString.length(); i++) {
            if (byteString.charAt(i) == '0') {
                builder.append('1');
            } else {
                builder.append('0');
            }
        }
        //获取encodeByte地址
        ret = TTEncryptUtils.callStaticJniMethod(emulator, &quot;encodeByte(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;&quot;,
                //传参，这里需要两个字符串，所以就传入两个参数
                vm.addLocalObject(new StringObject(vm, &quot;要加密的值&quot;)),
                vm.addLocalObject(new StringObject(vm, builder.toString())));
        //ret 返回的是地址，
        hash = ret.intValue() &amp;amp; 0xffffffffL;
        //获得其值
        StringObject str = vm.getObject(hash);
        System.out.println(str.getValue());
        return str.getValue();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上边代码有jni的类是哪一个需要知道，就是下面这个类，这个其实是和加载so有关系的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TTEncryptUtils = vm.resolveClass(&quot;com/*/aesjni/AESEncrypt&quot;);&lt;/code&gt;&lt;br/&gt;我们需要逆向app，这里不细说如何在app中寻找加载so的类。如下图，encodeByte是该app调用native层加密的入口，loadLibrary是java加载so的方法，这个类就是上述代码中填写的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/12/27/16f47dad71761786?w=1040&amp;amp;h=627&amp;amp;f=png&amp;amp;s=90723&quot;/&gt;&lt;br/&gt;然后再看&lt;code&gt;&quot;encodeByte(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;&quot;&lt;/code&gt;这里，这是smali写法，不补基础，后面跟上需要传的参数，&lt;br/&gt;&lt;code&gt;getByteValues&lt;/code&gt; 这个方法是毒获取的一个01字符串，并且在java层进行了处理,然后再传进&lt;code&gt;encodeByte&lt;/code&gt;里面，&lt;code&gt;encodeByte&lt;/code&gt;这个方法最后获取的其实并不是最终需要的，需要md5才是最后的newSign。可以验证一下下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/12/27/16f47ee56a30abb4?w=1381&amp;amp;h=669&amp;amp;f=png&amp;amp;s=320545&quot;/&gt;&lt;br/&gt;测试结果通过。&lt;/p&gt;
&lt;h3 id=&quot;最后&quot;&gt;最后&lt;/h3&gt;
&lt;p&gt;启动java文件时候注意这个改成自己的平台！！！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;VM options: -Djava.library.path=prebuilt/os -Djna.library.path=prebuilt/os
Where os may: linux64, win32, win64, osx64&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/12/27/16f47f8291d2ad56?w=740&amp;amp;h=275&amp;amp;f=png&amp;amp;s=26594&quot;/&gt;&lt;br/&gt;最后这个文件放在&lt;a href=&quot;https://github.com/zhaoboy9692/dailyanalysis&quot; class=&quot;uri&quot;&gt;https://github.com/zhaoboy9692/dailyanalysis&lt;/a&gt;喜欢的可以star，谢谢。&lt;/p&gt;
</description>
<pubDate>Fri, 27 Dec 2019 15:40:00 +0000</pubDate>
<dc:creator>成小新</dc:creator>
<og:description>爬虫工程师的unidbg入门教程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xbjss/p/12110083.html</dc:identifier>
</item>
<item>
<title>Hbase概念原理扫盲 - bainianminguo</title>
<link>http://www.cnblogs.com/bainianminguo/p/12110077.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bainianminguo/p/12110077.html</guid>
<description>&lt;h3&gt;一、Hbase简介&lt;/h3&gt;
&lt;h4&gt;1、什么是Hbase&lt;/h4&gt;
&lt;p&gt;Hbase的原型是google的BigTable论文，收到了该论文思想的启发，目前作为hadoop的子项目来开发维护，用于支持结构化的数据存储。&lt;/p&gt;
&lt;p&gt;Hbase是一个高可靠性（存储在hdfs上，有副本机制），高性能，面向列，非关系型的数据库（类似redis），可伸缩的分布式存储系统（因为是存储在hdfs上），利用hbase技术可在廉价PC server上搭建大规模结构化的数据库存储集群。&lt;/p&gt;
&lt;p&gt;Hbase的目标是存储并处理大型的数据，更具体来说仅需使用普通的硬件，就能够处理由成千上万行和列所组成的大型数据。&lt;/p&gt;
&lt;p&gt;Hbase是基于hdfs构建的分布式存储框架，但是Hbase在hdfs上实现随机的读写改，解决了hdfs不支持的东西&lt;/p&gt;

&lt;h4&gt;2、Hbase的特点&lt;/h4&gt;
&lt;p&gt;A、海量存储&lt;/p&gt;
&lt;p&gt;B、列式存储&lt;/p&gt;
&lt;p&gt;这里的列式存储其实说的是列族存储，Hbase是根据列族来存储数据的，列族下面可以有非常多的列，列族在创建表的时候必须指定&lt;/p&gt;
&lt;p&gt;Hbase中的列和mysql的列不是一个东西，Hbase的列就是他的数据&lt;/p&gt;
&lt;p&gt;C、极易扩展&lt;/p&gt;
&lt;p&gt;Hbase的扩展性主要体现在两个方面，一个是基于上层的梳理能力的扩展（RegionServer，相当于datanode，处理读写请求），一个是基于存储的扩展（hdfs）&lt;/p&gt;
&lt;p&gt;通过横向添加RegionServer的机器，进行水平扩展，提升Hbase上层的处理能力，提升Hbase服务更多的Region的能力。&lt;/p&gt;
&lt;p&gt;备注：RegionServer的作用是管理Region）（类似mysql中的表的概念），承接客户端的读写请求的访问，这个后面会详细的介绍通过横向添加datanode的机器，进行存储层的扩容，提升Bhbase的存储能力和提升后端存储的读写能力&lt;/p&gt;
&lt;p&gt;D、稀疏&lt;/p&gt;
&lt;p&gt;稀疏主要是针对于hbase列的灵活性，在列族中，你可以指定任意多的列，在列数据为空的情况下，是不会占用存储空间的，这里和mysql等数据库不一样，mysql如果每个字段没有值，那这个字段的值为null，不为空，且会占用存储空间&lt;/p&gt;

&lt;h4&gt;3、Hbase的架构&lt;/h4&gt;
&lt;p&gt;Hbase的架构示意图如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227225055308-1352876735.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;Hbase由HMaster和HRegionServer组成，HMaster的高可用也依赖于zk，类似于hdfs中的Namenode;&lt;/p&gt;
&lt;p&gt;HRegionServer相当于hdfs中的datanode，实际处理读写请求的节点;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;a、Zookeeper&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HBase通过zk来做Hmaster的高可用，RegionServer的监控，元数据的入口以及集群配置的维护等工作，具体工作入下&lt;/p&gt;
&lt;p&gt;通过zk来保证集群中只有一个master在运行，如果master异常，会通过竞争机制产生新的master提供服务&lt;/p&gt;
&lt;p&gt;通过zk来监控RegionServer的状态，当RegionServer有异常的时候，通过回调的形式通知master,RegionServer上下线的信息&lt;/p&gt;
&lt;p&gt;通过zk存储元数据的统一入口地址；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;b、HMaster&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为RegionServer分配Region&lt;/p&gt;
&lt;p&gt;维护集群的负载均衡，就是分配Region&lt;/p&gt;
&lt;p&gt;维护集群的元数据信息&lt;/p&gt;
&lt;p&gt;发现失效的Region，并将失效的Region分配到正常的RegionServer上&lt;/p&gt;
&lt;p&gt;当RegionServer失效的时候，协调对应的Hlog和hdfs的block进行数据恢复&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C、HRegionServer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HRegionServer直接对接用户的读写请求，是真正的干活的节点，他的功能概括如下&lt;/p&gt;
&lt;p&gt;管理master为其分配的Region&lt;/p&gt;
&lt;p&gt;处理来自客户端的读写请求&lt;/p&gt;
&lt;p&gt;负责和底层hdfs的交互，存储数据到hdfs中&lt;/p&gt;
&lt;p&gt;负责Region变大后的拆分&lt;/p&gt;
&lt;p&gt;负责Storefile的合并工作&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;D、HDFS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Hdfs为hbase提供最终的底层数据存储服务&lt;/p&gt;
&lt;p&gt;提供元数据和表数据的底层分布式存储服务&lt;/p&gt;
&lt;p&gt;数据的多副本，保证高可靠和高可用&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;E、Hlog&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个HRegionServer中只有一个Hlog，Hlog相当于hdfs中的edits文件，保存Hbase的修改记录，当对Hbase写数据的时候，数据不是直接写进磁盘，他会在内存中保留一段时间（时间i将数据量的阈值可以设定）。但把数据保存在内存中可能有更高的概率引起数据丢失，为了解决这个问题，数据会先写在一个叫做Hlog的文件中，Hlog存储在磁盘上，也位于hdfs上，然后在写入内存，所以在系统出现故障或者内存丢失的时候，数据可以通过这个日志文件进行重建&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;F、Region&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Region相当于mysql中的表，一个HRegionServer可以有多个Region，一个HRegionServer会有多个Region；如果表的数据太大，会进行拆分，按照数据量平均切分，所有HBase中的一张表会对应一个或者多个Region，当表的内容很小，一张表就对应一个Region，如果表很大的话，则这个Region会切分，切分Region会同时拆分这个Region的所有Store。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;G、Store&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Store相当于列族，通俗的讲就是列的家族，在hbase中，想创建一个列，必须要指定列族，也就是一个列必须属于某个列族。一个表中可以有多个列族，一个store对应一个列族，hbase官方不建议多个列族，一个列族就可以搞上百个列，足够用了。但是如果一个HRegion被切分的话，是切分列族，所以就算一个HRegion只有一个列表，切分后一个Region也会对应多个Store，多个strore会被分配到其他的HRegionServer节点进行存储&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;H、MemStore&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MemStore就是列族中的数据放在内存中，写数据来了，会写到内存中，只要内存写入成功，则就返回。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;I、StoreFile&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;StoreFile，数据放在内存不安全，而且有大小限制，所以需要把内存中的数据写到磁盘中，以Hfile的格式存储在hdfs上。每次memstore刷一次，形成一个storefile，所以storefile会很多，但是很小，因为内存本身就不大，后面storeFile也会合并，但是这个合并也仅仅是一个列族内部的StoreFile进行合并，不会跨列族合并的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;J、HFile&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是磁盘上保存的原始数据的实际的物理文件，是实际的存储文件，storefile是以Hfile的形式存储在hdfs中&lt;/p&gt;

&lt;h3&gt;二、Hbase安装&lt;/h3&gt;
&lt;h4&gt;1、首先要安装zk&lt;/h4&gt;
&lt;h4&gt;2、 然后要安装hdfs&lt;/h4&gt;
&lt;h4&gt;3、 最后在安装hbase&lt;/h4&gt;
&lt;h4&gt;4、 解压，修改配置文件&lt;/h4&gt;
&lt;p&gt;这里重点说下修改配置文件，前面的就不说了，因为我在实际使用过程中使用ambari工具来进行安装&lt;/p&gt;
&lt;p&gt;首先修改hbase-env.sh &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置java的环境变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227230301954-725707928.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
export JAVA_HOME=/usr/lib/jvm/java
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;配置zk，Hbase也是强依赖于zookeeper的，是否要启用自己的zookeeper。如果用则为true，如果用外部的zookeeper，则为false&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227230413267-1897157454.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
export HBASE_MANAGES_ZK=false
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;配置hbase-site.xml &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227230436632-1004663796.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&amp;lt;property&amp;gt;
      &amp;lt;name&amp;gt;hbase.rootdir&amp;lt;/name&amp;gt;
      &amp;lt;value&amp;gt;/apps/hbase/data&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;配置hbase是否启用集群&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227230503117-917200797.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
    &amp;lt;property&amp;gt;
      &amp;lt;name&amp;gt;hbase.cluster.distributed&amp;lt;/name&amp;gt;
      &amp;lt;value&amp;gt;true&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;设置Hbase的服务的端口号，不是 web的端口号，web的端口号是16010&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227230530323-1692564679.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
  &amp;lt;property&amp;gt;
      &amp;lt;name&amp;gt;hbase.master.info.port&amp;lt;/name&amp;gt;
      &amp;lt;value&amp;gt;16010&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227230545944-1822453775.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
    &amp;lt;property&amp;gt;
      &amp;lt;name&amp;gt;hbase.master.port&amp;lt;/name&amp;gt;
      &amp;lt;value&amp;gt;16000&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;配置要连接的zk&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227230612146-316652912.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
   &amp;lt;property&amp;gt;
      &amp;lt;name&amp;gt;hbase.zookeeper.quorum&amp;lt;/name&amp;gt;
      &amp;lt;value&amp;gt;abdi1,abdi2,abdi3&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Zk存储数据的父目录，主要是为了区分多个hbase集群&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227230637671-1014917190.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
    &amp;lt;property&amp;gt;
      &amp;lt;name&amp;gt;zookeeper.znode.parent&amp;lt;/name&amp;gt;
      &amp;lt;value&amp;gt;/hbase-unsecure&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;配置regionservers文件&lt;/p&gt;
&lt;p&gt;指定RegionServer的节点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227230714626-2016199948.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;由于hbase是强依赖于hdfs的，需要拷贝hdfs的配置文件到hbase的conf目录&lt;/p&gt;
&lt;p&gt;我们一般情况会这样操作，创建一个软链接，链接到hdfs的core-site.xml和hdfs-site.xml中，就是让hbase知道我要连接哪个hadoop集群&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227230858050-2000059931.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;但是在ambari安装的hbase的配置文件中没有找到相应的配置，但是在hbase启动的时候有加载hdfs的环境变量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227230807071-531435053.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;启动hbase，可以看到有Hmaster和HRegionServer的java进程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227230934952-824649691.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;ambari的web页面显示效果如下&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227230941811-1918272140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;p&gt;注意：Hbase的Master和RegionServer安装是一样的，只是看我们是否要启动master&lt;/p&gt;
&lt;p&gt;Hbase的web页面，采用16010端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227231057294-1681314100.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h3&gt;三、Hbase的简单shell操作&lt;/h3&gt;
&lt;h4&gt;1、进入hbase shell&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
[root@abdi2 bin]# /usr/hdp/current/hbase-client/bin/hbase shell
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2、查看当前有哪些表：list&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
hbase(main):003:0&amp;gt; list
TABLE                                                                                                                                                                                                                                                                         
0 row(s)
Took 0.2713 seconds                                                                                                                                                                                                                                                           
=&amp;gt; []
hbase(main):004:0&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;3、创建表操作。这里的列族是必须要指定的，就是和mysql的列一样:create &quot;student&quot;,&quot;info&quot;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
hbase(main):004:0&amp;gt; create &quot;student&quot;,&quot;info&quot;
Created table student
Took 1.3445 seconds                                                                                                                                                                                                                                                           
=&amp;gt; Hbase::Table - student
hbase(main):005:0&amp;gt; 
hbase(main):006:0&amp;gt; list
TABLE                                                                                                                                                                                                                                                                         
student                                                                                                                                                                                                                                                                       
1 row(s)
Took 0.0055 seconds                                                                                                                                                                                                                                                           
=&amp;gt; [&quot;student&quot;]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227231517021-1982423995.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227231533459-546509634.png&quot; alt=&quot;&quot; width=&quot;799&quot; height=&quot;109&quot;/&gt;&lt;/p&gt;



&lt;h4&gt;4、插入数据。Hbase中的数据没有什么类型，比如字符串，hash等，全部是字节:put &quot;student&quot;,&quot;1001&quot;,&quot;info:name&quot;,&quot;laowang&quot;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;50&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
hbase(main):007:0&amp;gt; put &quot;student&quot;,&quot;1001&quot;,&quot;info:name&quot;,&quot;laowang&quot;
Took 0.1217 seconds                                                                                                                                                                                                                                                           
hbase(main):008:0&amp;gt; put &quot;student&quot;,&quot;1001&quot;,&quot;info:age&quot;,&quot;18&quot;
Took 0.0038 seconds                                                                                                                                                                                                                                                           
hbase(main):009:0&amp;gt; put &quot;student&quot;,&quot;1001&quot;,&quot;info:sex&quot;,&quot;male&quot;
Took 0.0049 seconds                                                                                                                                                                                                                                                           
hbase(main):010:0&amp;gt; put &quot;student&quot;,&quot;1002&quot;,&quot;info:name&quot;,&quot;laoluo&quot;
Took 0.0036 seconds                                                                                                                                                                                                                                                           
hbase(main):011:0&amp;gt; put &quot;student&quot;,&quot;1002&quot;,&quot;info:age&quot;,&quot;20&quot;
Took 0.0035 seconds  
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227231645988-1837962927.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h4&gt;5、扫描查看数据：scan “student”&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227231722769-77232807.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h4&gt;6、扫描查看数据，指定起始和截止Rowkey，&lt;span&gt;前闭后开&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227231818742-1271958872.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt; &lt;/p&gt;
&lt;h4 class=&quot;MsoListParagraph&quot;&gt;7、&lt;span&gt;查看指定Rowkey&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227231845666-377970534.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;



&lt;h4&gt;8、&lt;span&gt;查看指定行的指定列&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227231904610-1459662173.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;



&lt;h4&gt;9、&lt;span&gt;更新数据&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227231921038-1429069600.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h4&gt;10、&lt;span&gt;查看表结构&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;重点关注列族和版本即可，这里的版本是个数的意思，就一条数据存储几个版本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227231939654-34875843.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;



&lt;h4&gt;11、&lt;span&gt;修改列族的版本信息&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227232014023-1625770462.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;多更新几次数据&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227232047440-141299649.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;可以查看到有多个版本，这里的意思查看&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;3&lt;/span&gt;&lt;span&gt;个版本的数据，所以有三条，下面的命令是查看&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;&lt;span&gt;个版本的数据，所以有两条&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227232054957-339799188.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h4&gt;12、&lt;span&gt;删除操作&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;删除某个&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Rowkey&lt;/span&gt;&lt;span&gt;的指定列，可以看到其他列的数据还在，删除还可以指定时间戳，该时间戳之前的数据都会被删除&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227232121344-1139566539.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;MsoListParagraph&quot;&gt; &lt;/p&gt;

&lt;p class=&quot;MsoListParagraph&quot;&gt; &lt;/p&gt;

&lt;p class=&quot;MsoListParagraph&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;删除&lt;span lang=&quot;EN-US&quot;&gt;Rowkey&lt;/span&gt;对应的所有数据&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227232132411-1372630042.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;




&lt;h4&gt;13、统计条数&lt;/h4&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;统计条数，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Rowkey&lt;/span&gt;&lt;span&gt;有几个，条数就有几条&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227232153571-1601441316.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;



&lt;h4&gt;14、清空表&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227232205154-1800764667.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h4&gt;15、删除表&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227232218749-39104414.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;h4&gt;16、命名空间（namespace）操作&lt;/h4&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;命令空间，相当于数据库中的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;database&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;所有的表都是命名空间的成员，如果不指定，则默认在&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;default&lt;/span&gt;&lt;span&gt;的命名空间中&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;命名空间可以设置权限，比如定义访问控制列表，例如创建表，读取表，删除，更新操作，权限用的很少&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Shell&lt;/span&gt;&lt;span&gt;命令查看&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;namespace&lt;/span&gt;&lt;span&gt;、创建&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;namespace&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227232719149-1792304592.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Hbase&lt;/span&gt;&lt;span&gt;就是存储元数据的命名空间，是系统自己用的，不能给用户使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在指定命名空间下建表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227232732666-757961441.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227232739375-465595200.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;







&lt;h3&gt;四、Hbase的数据结构&lt;/h3&gt;
&lt;h4 class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;1、Rowkey&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Rowkey&lt;/span&gt;&lt;span&gt;是用来检索记录的主键，访问&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Hbase table&lt;/span&gt;&lt;span&gt;中的行，只有三种方式&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;A、&lt;/span&gt;&lt;span&gt;通过单个&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Rowkey&lt;/span&gt;&lt;span&gt;访问&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;B、&lt;/span&gt;&lt;span&gt;通过&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Rowkey&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;range&lt;/span&gt;&lt;span&gt;访问&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;C、&lt;/span&gt;&lt;span&gt;全表扫描&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;设计&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Rowkey&lt;/span&gt;&lt;span&gt;非常重要也是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Hbase&lt;/span&gt;&lt;span&gt;里最重要的一门学问，数据会按照&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Rowkey&lt;/span&gt;&lt;span&gt;的字典序排序进行存储，所以设计&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Rowkey&lt;/span&gt;&lt;span&gt;要利用这个特性，把经常一起读取的行存储在一起，学习Hbase，Rowkey设计是学习的重点&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
&lt;h4 class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;2、Column Family&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;列族，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Hbase&lt;/span&gt;&lt;span&gt;表中的每个列，都会属于某个列族，列族是表的结构的一部分，列族在建表的时候必须要指定。列名都是以列族做为前缀。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;在创建表的时候需要指定列族，列族可以指定多个&lt;/span&gt;&lt;/p&gt;

&lt;h4 class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;3、Cell&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;由&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Rowkey&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;column Family&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;column&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;version&lt;/span&gt;&lt;span&gt;唯一确定的单元，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;cell&lt;/span&gt;&lt;span&gt;中的数据是没有类型的，全部都是字节的形式存储&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227232447163-1382779147.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;



&lt;h4 class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;4、Time Stamp&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;时间戳，每个&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;cell&lt;/span&gt;&lt;span&gt;都保存着同一份数据的多个版本，版本通过时间戳来索引。时间戳可以由系统生成，也可以自己指定。每个&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;cell&lt;/span&gt;&lt;span&gt;中，不同版本的数据按照时间倒序排列，即最新的数据在最前面&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;通过时间戳不同来确定版本的&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;五、Hbase的原理&lt;/h3&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Hbase&lt;/span&gt;&lt;span&gt;的写比读还快&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
&lt;h4 class=&quot;MsoNormal&quot;&gt;&lt;span&gt;1、读流程，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;hmaster&lt;/span&gt;&lt;span&gt;没有关系，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;hmaster&lt;/span&gt;&lt;span&gt;挂掉后，不影响读流程&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227232840697-2115195999.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;a、先获取&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;meta&lt;/span&gt;&lt;span&gt;表的位置，也就元数据这张表存储的位置&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;b、&lt;span&gt;去&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;meta&lt;/span&gt;&lt;span&gt;表所在位置获取&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;meta&lt;/span&gt;&lt;span&gt;表的信息，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;meta&lt;/span&gt;&lt;span&gt;表存储的内容大致入下&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Student 0 ----10000 rs1&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Student 100001---20000 rs2&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Stff        0---10000  rs3&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Stff       10000—200000 rs4&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;c、&lt;span&gt;然后在去对应的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;regionserver&lt;/span&gt;&lt;span&gt;获取对应的数据&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;d、&lt;span&gt;获取数据，先去内存中获取，如果内存中没有，到&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;blockcache&lt;/span&gt;&lt;span&gt;中获取，如果&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;blockcash&lt;/span&gt;&lt;span&gt;没有，则去磁盘获取，这里为什么先去内存获取数据？&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;MsoListParagraph&quot;&gt;e、&lt;span&gt;返回数据的时候，先把数据写到&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;blockcache&lt;/span&gt;&lt;span&gt;中，然后在返回给&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;client&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Meta&lt;/span&gt;&lt;span&gt;表的位置&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227232943044-1236651175.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Zk&lt;/span&gt;&lt;span&gt;上查看&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;meta&lt;/span&gt;&lt;span&gt;表的存储位置&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227232955069-1294017989.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;查看meta表的内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227233003864-1408452932.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h4&gt;2、&lt;span&gt;写流程，和Hmaster没有关系&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227233042271-925721105.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;a、client&lt;/span&gt;&lt;span&gt;到&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;zk&lt;/span&gt;&lt;span&gt;获取&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;meta&lt;/span&gt;&lt;span&gt;表的位置&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;b、Zk&lt;/span&gt;&lt;span&gt;返回&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;meta&lt;/span&gt;&lt;span&gt;表的位置&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;c、Zk&lt;/span&gt;&lt;span&gt;去&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;regionserver&lt;/span&gt;&lt;span&gt;读取&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;meta&lt;/span&gt;&lt;span&gt;表的内容&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;d、Regionserver&lt;/span&gt;&lt;span&gt;将&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;meta&lt;/span&gt;&lt;span&gt;表的内容返回&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;e、去对应的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;regionserver&lt;/span&gt;&lt;span&gt;开始执行写操作，先写&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Hlog&lt;/span&gt;&lt;span&gt;文件，然后写到&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;memstore&lt;/span&gt;&lt;span&gt;，成功后，立刻返回，写入流程完成&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;因为先写到内存中，那么什么时候会刷到硬盘中呢&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;a、Regionserver&lt;/span&gt;&lt;span&gt;的使用的总内存达到堆内存的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;40%&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227233135708-128576574.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;b、&lt;span&gt;满足一个小时的条件，会刷&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;memstore&lt;/span&gt;&lt;span&gt;到硬盘中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227233147578-1776412116.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;c、单个&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;region&lt;/span&gt;&lt;span&gt;里的所有的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Memstore&lt;/span&gt;&lt;span&gt;加起来达到&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;128MB&lt;/span&gt;&lt;span&gt;，则会刷&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;memstore&lt;/span&gt;&lt;span&gt;到硬盘中&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227233205264-831560862.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;




&lt;p class=&quot;MsoNormal&quot;&gt;这样就会有很多小文件刷到&lt;span lang=&quot;EN-US&quot;&gt;hdfs&lt;/span&gt;中，但是&lt;span lang=&quot;EN-US&quot;&gt;hdfs&lt;/span&gt;不适合存储很多的小文件&lt;/p&gt;


&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;默认是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;7&lt;/span&gt;&lt;span&gt;天做一次合并&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227233222955-1911787862.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227233237912-391561205.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;超过&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;7&lt;/span&gt;&lt;span&gt;天合并&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;storefile&lt;/span&gt;&lt;span&gt;文件&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;超过&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;3&lt;/span&gt;&lt;span&gt;个&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;storefile&lt;/span&gt;&lt;span&gt;文件，会进行合并&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;这个是合并一个列族的的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;storefile&lt;/span&gt;&lt;span&gt;，不同列族的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;storefile&lt;/span&gt;&lt;span&gt;文件不会进行合并的&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt; 3、高可用&lt;/h4&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Hmaster是Active&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;standby&lt;/span&gt;&lt;span&gt;模式&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227233327406-176332706.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227233333437-980782593.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;高可用配置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201912/1101486-20191227233343789-1962914145.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;扫描查看数据&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 27 Dec 2019 15:39:00 +0000</pubDate>
<dc:creator>bainianminguo</dc:creator>
<og:description>一、Hbase简介 1、什么是Hbase Hbase的原型是google的BigTable论文，收到了该论文思想的启发，目前作为hadoop的子项目来开发维护，用于支持结构化的数据存储。 Hbase是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bainianminguo/p/12110077.html</dc:identifier>
</item>
<item>
<title>Jmeter配置元件——CSV DataSet Config参数化 - 温一壶清酒</title>
<link>http://www.cnblogs.com/hong-fithing/p/12109888.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hong-fithing/p/12109888.html</guid>
<description>&lt;p&gt;在聊CSV DataSet Config配置元件前，先来讨论下为何要参数化？&lt;/p&gt;
&lt;p&gt;比如在做性能测试过程中， 一般我们需要模拟多个用户进行操作， 为了满足实际场景， 模拟真实的用户行为， 我们需要做到模拟的用户帐号或其它信息都是不同的， 这时我们就需要用到参数化。 Jmeter中， 配置元件可以解决此问题。&lt;/p&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;Jmeter配置元件可以用来进行参数化、 初始化默认值和变量、 存储服务器的响应信息以及配置链接数据库等。 JMeter参数化一般使用配置元件中的CSV DataSet Config或者JDBC ConnectionConfiguration来进行参数化。今天，先来使用CSV DataSet Config进行参数化。&lt;/p&gt;
&lt;p&gt;CSV Data Set Config元件：&lt;/p&gt;
&lt;p&gt;该元件可以用来读取csv或dat文件的数据，然后通过设置把读取到的数据关联到Jmeter中的变量保存，csv文件可以使用execl表格工具去进行编辑。分两种文件来讲解：txt文件和csv文件。&lt;/p&gt;
&lt;h2&gt;基础配置&lt;/h2&gt;
&lt;div readability=&quot;41&quot;&gt;
&lt;p&gt;界面字段说明：&lt;/p&gt;
&lt;p&gt;名称、注释与之前元件一样可以随意设置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Filename&lt;/span&gt;&lt;/strong&gt;：指保存信息的文件目录，可以相对或者绝对路径，相对路径从Jmeter的启动目录(***/bin)路径。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;File Encoding&lt;/span&gt;&lt;/strong&gt;：文件编码，默认为ANSI，建议设置为utf-8，防止遇见乱码情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Variable Names&lt;/span&gt;&lt;/strong&gt;：参数名称，每个名称中间用分隔符分割，分隔符使用下面的“Delimitet”中定义的，默认用逗号隔开，与参数文件的参数对应。如果设置的参数名称多于参数文件中的参数，多余的参数取不到值；反之参数文件中的参数将没有参数对应。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Delimitet&lt;/span&gt;&lt;/strong&gt;：定义分隔符，用于分隔文件中的参数，及上述Variable Names中定义的参数名称。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Allow Quoated data?&lt;/span&gt;&lt;/strong&gt;：是否允许引用数据，设置为True ，设置文件中的参数值都必须用引号引起来,False则不需要&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Recycle on EOF ?&lt;/span&gt;&lt;/strong&gt;：遇到文件结束符时，是否从头开始循环读入，设置为True,则从头开始继续循环&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Stop Thread on EOF ?&lt;/span&gt;&lt;/strong&gt;：当Recycle on EOF 设置为False并且Stop Thread on EOF为True,则读完csv文件中的记录后, 停止运行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Sharing Mode&lt;/span&gt;&lt;/strong&gt;：参数文件共享模式，有三个设置，说明如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;All threads&lt;/span&gt;&lt;/strong&gt;：参数文件对所有线程共享，包含同一测试计划中的不同线程组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Current thread group&lt;/span&gt;&lt;/strong&gt;：只对当前线程组中的线程共享。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Current thread&lt;/span&gt;&lt;/strong&gt;：仅当前线程获取。&lt;/p&gt;
&lt;p&gt;界面如下图所示：&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;27&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1242227/201912/1242227-20191227220738603-1289935883.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;配置元件添加路径如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1242227/201912/1242227-20191227221316679-850673529.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;参数化&lt;/h2&gt;
&lt;p&gt;我们已经基本了解了该配置元件，那就来实践一番。&lt;/p&gt;
&lt;h3&gt;参数化一：csv文件&lt;/h3&gt;
&lt;p&gt;如何配置csv文件？&lt;/p&gt;
&lt;p&gt;新建一个xls文件，再另存为csv文件即可。&lt;/p&gt;
&lt;p&gt;这个很简单，我们主要是来看如何引用csv文件，而达到参数化的效果。&lt;/p&gt;
&lt;h4&gt;①配置界面&lt;/h4&gt;
&lt;p&gt;我们先来看配置界面，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1242227/201912/1242227-20191227230623524-1709354166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是，file encoding文件编码填写的是GB2312，不是utf-8，需要格外注意，不然就会出现乱码的现象，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1242227/201912/1242227-20191227230838049-932336991.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;②准备csv文件&lt;/h4&gt;
&lt;p&gt;文件内容填写如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1242227/201912/1242227-20191227231005754-1215503974.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;③引入参数化&lt;/h4&gt;
&lt;p&gt;我们在配置界面填写的变量名为keyword，所以引入到接口中，也用该变量名，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1242227/201912/1242227-20191227231229429-1707346208.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;④查看参数化结果&lt;/h4&gt;
&lt;p&gt;运行脚本，查看结果，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1242227/201912/1242227-20191227231342330-2042121352.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接口每次请求，关键字都是不同的，就达到了参数化的效果。&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;参数化二：txt文件&lt;/h3&gt;
&lt;p&gt;我们了解csv参数化之后，对于txt文件参数化，都是类似配置。我们新建一个txt文本文件，输入内容并保存即可。&lt;/p&gt;
&lt;h4&gt;①配置界面&lt;/h4&gt;
&lt;p&gt;配置界面如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1242227/201912/1242227-20191227231849433-664995033.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;②注意点&lt;/h4&gt;
&lt;p&gt;file encoding文件编码填写的是utf-8，不是GB2312。需要格外注意的是，文本文件保存时，默认为ANSI格式文件，即可界面配置为utf-8，但还是会出现乱码的现象，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1242227/201912/1242227-20191227230838049-932336991.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置为utf-8，还是会乱码，解决办法为：将txt文件另存为重新保存，选择文件格式为utf-8保存即可。&lt;/p&gt;
&lt;h4&gt;③准备txt文件&lt;/h4&gt;
&lt;p&gt;内容输入如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1242227/201912/1242227-20191227232258245-1136025693.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;④引入参数化&lt;/h4&gt;
&lt;p&gt;我们在配置界面填写的变量名为keyword，所以引入到接口中，也用该变量名，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1242227/201912/1242227-20191227232352521-1178673264.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;⑤查看参数化结果&lt;/h4&gt;
&lt;p&gt;运行脚本，查看结果，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1242227/201912/1242227-20191227232448260-1447881047.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;无论是用csv文件还是txt文件进行参数化，配置方式都类似。需要注意的就是，文件编码的格式问题，配置错了，就会导致乱码的情况。配置项中，如果参数化文件第一行填写了参数名称，配置的时候，则需要忽略第一行。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;29.483394833948&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;本文仅代表作者观点，系作者@温一壶清酒发表。&lt;br/&gt;欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。&lt;br/&gt;文章出处：&lt;a href=&quot;http://www.cnblogs.com/hong-fithing/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/hong-fithing/&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Fri, 27 Dec 2019 15:30:00 +0000</pubDate>
<dc:creator>温一壶清酒</dc:creator>
<og:description>在聊CSV DataSet Config配置元件前，先来讨论下为何要参数化？ 比如在做性能测试过程中， 一般我们需要模拟多个用户进行操作， 为了满足实际场景， 模拟真实的用户行为， 我们需要做到模拟的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hong-fithing/p/12109888.html</dc:identifier>
</item>
<item>
<title>SPA+.NET Core3.1 GitHub第三方授权登录 使用AspNet.Security.OAuth.GitHub - 、天上有木月</title>
<link>http://www.cnblogs.com/igeekfan/p/12110012.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/igeekfan/p/12110012.html</guid>
<description>&lt;h2 id=&quot;github第三方授权登录&quot;&gt;GitHub第三方授权登录&lt;/h2&gt;
&lt;p&gt;使用SPA+.NET Core3.1实现 GitHub第三方授权登录 类似使用AspNet.Security.OAuth.GitHub，前端使用如下：VUE+Vue-Router+axios&lt;/p&gt;
&lt;h2 id=&quot;aspnet.security.oauth.github&quot;&gt;AspNet.Security.OAuth.GitHub&lt;/h2&gt;
&lt;h2 id=&quot;github授权登录&quot;&gt;GitHub授权登录&lt;/h2&gt;
&lt;p&gt;什么配置的过程不说了。。有一推。&lt;/p&gt;
&lt;p&gt;下面为示例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;client_id:0be6b05fc717bfc4fb67
client_secret:dcaced9f176afba64e89d88b9b06ffc4a887a609&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Get&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://github.com/login/oauth/authorize?client_id=0be6b05fc717bfc4fb67&amp;amp;redirect_uri=https://localhost:5001/signin-github&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会重定向到&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://localhost:5001/signin-github?code=07537a84d12bbae08361&quot; class=&quot;uri&quot;&gt;https://localhost:5001/signin-github?code=07537a84d12bbae08361&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个code放到下面的请求中，获取access_token&lt;br/&gt;POST方式（PostMan去请求）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://github.com/login/oauth/access_token?client_id=0be6b05fc717bfc4fb67&amp;amp;client_secret=dcaced9f176afba64e89d88b9b06ffc4a887a609&amp;amp;code=07537a84d12bbae08361&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Get方式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://api.github.com/user?access_token=787506afa3271d077b98f18af56d7cfdc8db43b4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后就能获取用户信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
   &quot;login&quot;: &quot;luoyunchong&quot;,
   &quot;id&quot;: 18613266,
   &quot;node_id&quot;: &quot;MDQ6VXNlcjE4NjEzMjY2&quot;,
   &quot;avatar_url&quot;: &quot;https://avatars1.githubusercontent.com/u/18613266?v=4&quot;,
   &quot;gravatar_id&quot;: &quot;&quot;,
   &quot;url&quot;: &quot;https://api.github.com/users/luoyunchong&quot;,
   &quot;html_url&quot;: &quot;https://github.com/luoyunchong&quot;,
   &quot;followers_url&quot;: &quot;https://api.github.com/users/luoyunchong/followers&quot;,
   &quot;following_url&quot;: &quot;https://api.github.com/users/luoyunchong/following{/other_user}&quot;,
   &quot;gists_url&quot;: &quot;https://api.github.com/users/luoyunchong/gists{/gist_id}&quot;,
   &quot;starred_url&quot;: &quot;https://api.github.com/users/luoyunchong/starred{/owner}{/repo}&quot;,
   &quot;subscriptions_url&quot;: &quot;https://api.github.com/users/luoyunchong/subscriptions&quot;,
   &quot;organizations_url&quot;: &quot;https://api.github.com/users/luoyunchong/orgs&quot;,
   &quot;repos_url&quot;: &quot;https://api.github.com/users/luoyunchong/repos&quot;,
   &quot;events_url&quot;: &quot;https://api.github.com/users/luoyunchong/events{/privacy}&quot;,
   &quot;received_events_url&quot;: &quot;https://api.github.com/users/luoyunchong/received_events&quot;,
   &quot;type&quot;: &quot;User&quot;,
   &quot;site_admin&quot;: false,
   &quot;name&quot;: &quot;IGeekFan&quot;,
   &quot;company&quot;: null,
   &quot;blog&quot;: &quot;https://blog.igeekfan.cn&quot;,
   &quot;location&quot;: null,
   &quot;email&quot;: &quot;luoyunchong@foxmail.com&quot;,
   &quot;hireable&quot;: null,
   &quot;bio&quot;: &quot;学习之路漫漫无期。&quot;,
   &quot;public_repos&quot;: 14,
   &quot;public_gists&quot;: 0,
   &quot;followers&quot;: 16,
   &quot;following&quot;: 11,
   &quot;created_at&quot;: &quot;2016-04-22T10:33:44Z&quot;,
   &quot;updated_at&quot;: &quot;2019-12-21T14:49:33Z&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;net-core3.1&quot;&gt;.NET Core3.1&lt;/h2&gt;
&lt;p&gt;以下代码为主要代码，完整代码看下面的DEMO链接。&lt;/p&gt;
&lt;p&gt;使用WebApi时，看了一些项目，全是基于MVC结构的，都不是我想要的。看了一些博客上面介绍 ,步骤都是千篇一律，都是配合前后端分离的。&lt;/p&gt;
&lt;p&gt;本地测试时，gitHub回调地址设置 http(s)://ip:端口/signin-github&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如: https://localhost:5001/signin-github。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;上面这个明明填写的后端的地址那后端怎么把结果通知前端呢&quot;&gt;1. 上面这个明明填写的后端的地址，那后端怎么把结果通知前端呢？&lt;/h4&gt;
&lt;p&gt;前端请求&lt;strong&gt;https://localhost:5001/signin?provider=GitHub&amp;amp;redirectUrl=http://localhost:8080/login-result&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;提供参数provider为GitHub，&lt;/li&gt;
&lt;li&gt;redirectUrl为GitHub授权登录后，回调signin-github后，后端再去重定向的地址，这里填前端的一个路由。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;后端只提供了signinsignin-callback路由没有signin-github那github上配置的路由是怎么回调回来呢&quot;&gt;2. 后端只提供了signin，signin-callback路由，没有signin-github，那github上配置的路由是怎么回调回来呢？&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/security/authentication/social/google-logins?view=aspnetcore-3.1&quot;&gt;google-登录，微软文档&lt;/a&gt;，其中有一个&lt;strong&gt;更改默认回调 URI&lt;/strong&gt;,通过 AddGitHub中的CallbackPath属性配置。&lt;/p&gt;
&lt;p&gt;介绍了回调地址应配置signin-google,所以这里应该是signin-github，他是可以配置的，不需要自己写程序处理signin-google这个路由，内部有中间件已经处理了。&lt;/p&gt;
&lt;h4 id=&quot;回调到signin-github后后端怎么处理才能让前端刷新获取登录后的信息呢&quot;&gt;3. 回调到signin-github后，后端怎么处理，才能让前端刷新。获取登录后的信息呢。&lt;/h4&gt;
&lt;p&gt;具体上面的根据code获取access_token，根据access_token获取用户的信息的过程，这些处理的过程，都不需要我们自己处理。我们可以用直接获取用户信息。&lt;/p&gt;
&lt;p&gt;一个方法SignIn,只要&lt;strong&gt;return Challenge(properties, provider);&lt;/strong&gt;，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;provider 为 GitHub，&lt;/li&gt;
&lt;li&gt;properties var properties = new AuthenticationProperties { RedirectUri = url };&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个url为另一个获取用户信息的路由，只要拼接好地址即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var authenticateResult = await _contextAccessor.HttpContext.AuthenticateAsync(provider);
string email = authenticateResult.Principal.FindFirst(ClaimTypes.Email)?.Value;
string name = authenticateResult.Principal.FindFirst(ClaimTypes.Name)?.Value;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private readonly IHttpContextAccessor _contextAccessor;
public AuthenticationController( IHttpContextAccessor contextAccessor)
{
    _contextAccessor = contextAccessor;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;代码部署简化&quot;&gt;代码部署（简化）&lt;/h3&gt;
&lt;p&gt;打开NuGet包管理,安装包&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Install-Package AspNet.Security.OAuth.GitHub&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;appSettings.json&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;Authentication&quot;: {
    &quot;GitHub&quot;: {
      &quot;ClientId&quot;: &quot;0be6b05fc717bfc4fb67&quot;,
      &quot;ClientSecret&quot;: &quot;dcaced9f176afba64e89d88b9b06ffc4a887a609&quot;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;add扩展方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static class JwtConfiguration
{
    public static void AddJwtConfiguration(this IServiceCollection services, IConfiguration configuration)
    {

        services.AddAuthentication(opts =&amp;gt;
            {
                opts.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;
                opts.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
            }).AddCookie(options =&amp;gt;
        {
            options.LoginPath = &quot;/signin&quot;;
            options.LogoutPath = &quot;/signout&quot;;
        }).AddGitHub(options =&amp;gt;
        {
            options.ClientId = configuration[&quot;Authentication:GitHub:ClientId&quot;];
            options.ClientSecret = configuration[&quot;Authentication:GitHub:ClientSecret&quot;];
        });
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认情况下，如头像，email，是没有获取的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.AddGitHub(options =&amp;gt;
{
    options.ClientId = configuration[&quot;Authentication:GitHub:ClientId&quot;];
    options.ClientSecret = configuration[&quot;Authentication:GitHub:ClientSecret&quot;];
    //options.CallbackPath = new PathString(&quot;~/signin-github&quot;);//与GitHub上的回调地址相同，默认即是/signin-github
    options.Scope.Add(&quot;user:email&quot;);
    //authenticateResult.Principal.FindFirst(LinConsts.Claims.AvatarUrl)?.Value;  得到GitHub头像
    options.ClaimActions.MapJsonKey(LinConsts.Claims.AvatarUrl, &quot;avatar_url&quot;);
    options.ClaimActions.MapJsonKey(LinConsts.Claims.BIO, &quot;bio&quot;);
    options.ClaimActions.MapJsonKey(LinConsts.Claims.BlogAddress, &quot;blog&quot;);
});

#其中LinConsts类为静态常量
public static class LinConsts
{
    public static class Claims
    {
        public const string BIO = &quot;urn:github:bio&quot;;
        public const string AvatarUrl = &quot;urn:github:avatar_url&quot;;
        public const string BlogAddress = &quot;urn:github:blog&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;startup.cs&lt;/p&gt;
&lt;p&gt;ConfigureServices中配置此服务&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    services.AddSingleton&amp;lt;IHttpContextAccessor, HttpContextAccessor&amp;gt;();
    services.AddJwtConfiguration(Configuration);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建AuthenticationController.cs&lt;br/&gt;增加SignIn，用于处理用户授权成功后，重定回signin-callback,并将参数带回。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        private readonly IHttpContextAccessor _contextAccessor;
        private readonly IConfiguration _configuration;

        public AuthenticationController(IHttpContextAccessor contextAccessor, IConfiguration configuration)
        {
            _contextAccessor = contextAccessor;
            _configuration = configuration;
        }
        
        [HttpGet(&quot;~/signin&quot;)]
        public async Task&amp;lt;IActionResult&amp;gt; SignIn(string provider, string redirectUrl)
        {
            var request = _contextAccessor.HttpContext.Request;
            var url =
                $&quot;{request.Scheme}://{request.Host}{request.PathBase}{request.Path}-callback?provider={provider}&amp;amp;redirectUrl={redirectUrl}&quot;;
            var properties = new AuthenticationProperties { RedirectUri = url };
            properties.Items[&quot;LoginProviderKey&quot;] = provider;
            return Challenge(properties, provider);

        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在signin方法中，用户点击授权后（第一次），会根据其传递的URL，重定向到这个地址，signin-callback,参数也会一同携带。provider为GitHub,redirectUrl为：http://localhost:8081/login-result.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[HttpGet(&quot;~/signin-callback&quot;)]
public async Task&amp;lt;IActionResult&amp;gt; Home(string provider = null, string redirectUrl = &quot;&quot;)
{
    var authenticateResult = await _contextAccessor.HttpContext.AuthenticateAsync(provider);
    if (!authenticateResult.Succeeded) return Redirect(redirectUrl);
    var openIdClaim = authenticateResult.Principal.FindFirst(ClaimTypes.NameIdentifier);
    if (openIdClaim == null || string.IsNullOrWhiteSpace(openIdClaim.Value))
        return Redirect(redirectUrl);

    //TODO 记录授权成功后的信息 

    string email = authenticateResult.Principal.FindFirst(ClaimTypes.Email)?.Value;
    string name = authenticateResult.Principal.FindFirst(ClaimTypes.Name)?.Value;
    string gitHubName = authenticateResult.Principal.FindFirst(GitHubAuthenticationConstants.Claims.Name)?.Value;
    string gitHubUrl = authenticateResult.Principal.FindFirst(GitHubAuthenticationConstants.Claims.Url)?.Value;
    //startup 中 AddGitHub配置项  options.ClaimActions.MapJsonKey(LinConsts.Claims.AvatarUrl, &quot;avatar_url&quot;);
    string avatarUrl = authenticateResult.Principal.FindFirst(LinConsts.Claims.AvatarUrl)?.Value;

    return Redirect($&quot;{redirectUrl}?openId={openIdClaim.Value}&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候我们能获取用户信息了。那么前端怎么办呢。我们写个方法，获取用户信息，看看效果。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;浏览器直接打开能得到github的id。&lt;/li&gt;
&lt;li&gt;axios GET请求 https://localhost:5001/OpenId 得到null&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[HttpGet(&quot;~/OpenId&quot;)]
public async Task&amp;lt;string&amp;gt; OpenId(string provider = null)
{
   var authenticateResult = await _contextAccessor.HttpContext.AuthenticateAsync(provider);
   if (!authenticateResult.Succeeded) return null;
   var openIdClaim = authenticateResult.Principal.FindFirst(ClaimTypes.NameIdentifier);
   return openIdClaim?.Value;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我记得之前传Token时，后台是可以这样获取的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[HttpGet(&quot;~/GetOpenIdByToken&quot;)]
public string GetOpenIdByToken()
{
    return User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;LoginResult.vue在created生命周期中。都是得到null&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;axios({
  methods: &quot;get&quot;,
  url: &quot;https://localhost:5001/OpenId?provider=GitHub&quot;
})
  .then(function(response) {
    // handle success
    console.log(response);
  })

axios({
  methods: &quot;get&quot;,
  url: &quot;https://localhost:5001/GetOpenIdByToken&quot;
})
  .then(function(response) {
    // handle success
    console.log(response);
  })&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;为什么呢&quot;&gt;为什么呢？？？&lt;/h3&gt;
&lt;p&gt;因为前后端分离，不是基于Cookies的。http是无状态的。每次请求无法区分用户的。我们可以根据当前的ClaimsPrincipal，根据JWT生成相应的Token，axios请求时，放到headers中。&lt;/p&gt;
&lt;p&gt;安装包&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Install-Package Microsoft.AspNetCore.Authentication.JwtBearer&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AppSettings.json配置改成&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;Authentication&quot;: {
&quot;JwtBearer&quot;: {
  &quot;SecurityKey&quot;: &quot;JWTStudyWebsite_DI20DXU3&quot;,
  &quot;Issuer&quot;: &quot;JWTStudy&quot;,
  &quot;Audience&quot;: &quot;JWTStudyWebsite&quot;
},
&quot;GitHub&quot;: {
  &quot;ClientId&quot;: &quot;0be6b05fc717bfc4fb67&quot;,
  &quot;ClientSecret&quot;: &quot;dcaced9f176afba64e89d88b9b06ffc4a887a609&quot;
}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AddJwtConfiguration改成如下内容&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void AddJwtConfiguration(this IServiceCollection services, IConfiguration configuration)
{

    services.AddAuthentication(opts =&amp;gt;
        {
            opts.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;
            opts.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
        }).AddCookie(options =&amp;gt;
    {
        options.LoginPath = &quot;/signin&quot;;
        options.LogoutPath = &quot;/signout&quot;;
    }).AddJwtBearer(JwtBearerDefaults.AuthenticationScheme, options =&amp;gt;
    {
        options.Audience = configuration[&quot;Authentication:JwtBearer:Audience&quot;];

        options.TokenValidationParameters = new TokenValidationParameters
        {
            // The signing key must match!
            ValidateIssuerSigningKey = true,
            IssuerSigningKey = new SymmetricSecurityKey(
                Encoding.ASCII.GetBytes(configuration[&quot;Authentication:JwtBearer:SecurityKey&quot;])),

            // Validate the JWT Issuer (iss) claim
            ValidateIssuer = true,
            ValidIssuer = configuration[&quot;Authentication:JwtBearer:Issuer&quot;],

            // Validate the JWT Audience (aud) claim
            ValidateAudience = true,
            ValidAudience = configuration[&quot;Authentication:JwtBearer:Audience&quot;],

            // Validate the token expiry
            ValidateLifetime = true,

            // If you want to allow a certain amount of clock drift, set that here
            //ClockSkew = TimeSpan.Zero
        };
    }).AddGitHub(options =&amp;gt;
    {
        options.ClientId = configuration[&quot;Authentication:GitHub:ClientId&quot;];
        options.ClientSecret = configuration[&quot;Authentication:GitHub:ClientSecret&quot;];
        //options.CallbackPath = new PathString(&quot;~/signin-github&quot;);//与GitHub上的回调地址相同，默认即是/signin-github
        options.Scope.Add(&quot;user:email&quot;);
        //authenticateResult.Principal.FindFirst(LinConsts.Claims.AvatarUrl)?.Value;  得到GitHub头像
        options.ClaimActions.MapJsonKey(LinConsts.Claims.AvatarUrl, &quot;avatar_url&quot;);
        options.ClaimActions.MapJsonKey(LinConsts.Claims.BIO, &quot;bio&quot;);
        options.ClaimActions.MapJsonKey(LinConsts.Claims.BlogAddress, &quot;blog&quot;);
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/luoyunchong/dotnetcore-examples/blob/master/dotnetcore3.1/VoVo.AspNetCore.OAuth2/spa-vue-oauth2/src/components/LoginResult.vue&quot;&gt;前端LoginResult.vue代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前端运行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yarn install
yarn serve&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;点击GitHub登录&lt;/p&gt;
&lt;p&gt;GetOpenIdByToken根据生成的token值，解析出了用户id,这样前端在login-result这个组件中，把token保存好，并重定向自己的主页，获取用户所有信息即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;data: 18613266
status: 200
config: {url: &quot;https://localhost:5001/GetOpenIdByToken&quot;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;OpenId?provider=GitHub则得不到数据，只能浏览器直接请求https://localhost:5001/OpenId?provider=GitHub，才能到github 的id。这个适应于前后端不分离，或者属于之前我们经常使用MVC结构，同一域名下，同一端口，基于Cookies登录的判断。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;h2 id=&quot;demo-示例&quot;&gt;Demo 示例&lt;/h2&gt;
</description>
<pubDate>Fri, 27 Dec 2019 15:12:00 +0000</pubDate>
<dc:creator>、天上有木月</dc:creator>
<og:description>GitHub第三方授权登录 使用SPA+.NET Core3.1实现 GitHub第三方授权登录 类似使用AspNet.Security.OAuth.GitHub，前端使用如下：VUE+Vue Rou</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/igeekfan/p/12110012.html</dc:identifier>
</item>
<item>
<title>谈谈模型融合之一 —— 集成学习与 AdaBoost - ITryagain</title>
<link>http://www.cnblogs.com/csu-lmw/p/12110009.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/csu-lmw/p/12110009.html</guid>
<description>&lt;p&gt;前面的文章中介绍了决策树以及其它一些算法，但是，会发现，有时候使用使用这些算法并不能达到特别好的效果。于是乎就有了&lt;code&gt;集成学习&lt;/code&gt;（Ensemble Learning），通过构建多个学习器一起结合来完成具体的学习任务。这篇文章将介绍集成学习，以及其中的一种算法 AdaBoost。&lt;/p&gt;

&lt;p&gt;首先先来介绍下什么是集成学习：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;构建多个学习器一起结合来完成具体的学习任务，常可获得比单一学习器显著优越的泛化性能，对“弱学习器” 尤为明显（三个臭皮匠，顶个诸葛亮）&lt;/li&gt;
&lt;li&gt;也称为&lt;code&gt;Multi-Classifier System&lt;/code&gt;, &lt;code&gt;Committee-Based Learning&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;学习器可以是同类型的，也可以是不同类型&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这么一看，就感觉集成学习与常说的模型融合很像，甚至可以理解为就是模型融合。&lt;/p&gt;
&lt;p&gt;那么，常用的集成学习方法有哪些呢？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;Boosting&lt;/strong&gt;，将各种弱分类器串联起来的集成学习方式，每一个分类器的训练都依赖于前一个分类器的结果，代表：AdaBoost，Gradient Boosting Machine&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bagging&lt;/strong&gt;，Bootstrap Aggregating 的缩写。这种方法采用的是随机有放回的选择训练数据然后构造分类器，最后进行组合，代表：Random Forest&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Voting/Averaging&lt;/strong&gt;，在不改变模型的情况下，直接对各个不同的模型预测的结果进行投票或者平均&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Binning&lt;/strong&gt;，最近看到的一种方法，还没细看，参考&lt;a href=&quot;http://cseweb.ucsd.edu/~elkan/254spring01/jdrishrep.pdf&quot;&gt;论文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Stacking&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Blending&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;em&gt;后面几种方法这里暂时不做介绍，后面会单独写博客来介绍这些方法&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;算法思想&quot;&gt;算法思想&lt;/h2&gt;
&lt;p&gt;这里将介绍一个基于 Boosting 方法的一个学习算法 AdaBoost，于1995年由 Freund 和 Schapire 提出。其主要思想为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先训练出一个基学习器&lt;/li&gt;
&lt;li&gt;根据该学习器的表现对训练样本权重进行调整，使得现有基学习器做错的样本在后续学习器的训练中受到更多的关注&lt;/li&gt;
&lt;li&gt;基于调整后的权重来训练下一个基学习器&lt;/li&gt;
&lt;li&gt;重复 2、3 直至学习器数目达到事先指定的值 T&lt;/li&gt;
&lt;li&gt;最终将这 T 个学习器进行加权结合&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ H(x)=\operatorname{sign}\left(\sum_{t=1}^{T} \alpha_{t} h_{t}(x)\right) \]&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;具体算法&quot;&gt;具体算法&lt;/h2&gt;
&lt;p&gt;设训练数据集&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \{x^{(i)}, y^{(i)}\}_{i=1}^{m},x^{(i)} \in \mathbb{R}^n, y \in \{-1, +1\} \]&lt;/span&gt;&lt;br/&gt;初始化训练数据的权值分布&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \mathcal{D}_{1}\left(x^{(i)}\right)=\frac{1}{m} \]&lt;/span&gt;&lt;br/&gt;for t in range(T):&lt;/p&gt;
&lt;p&gt;​ 假设训练得到分类器 &lt;span class=&quot;math inline&quot;&gt;\(h_t(x)\)&lt;/span&gt; ，则可计算 &lt;span class=&quot;math inline&quot;&gt;\(h_t(x)\)&lt;/span&gt; 在当前训练集上的分类误差：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \epsilon_{t}=P_{x \sim \mathcal{D}_{t}}\left[h_{t}(x) \neq y\right]=\sum_{y^{(i)} \neq h_{t}\left(x^{(i)}\right)} \mathcal{D}_{t}\left(x^{(i)}\right) \]&lt;/span&gt;&lt;br/&gt;​ 若 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon_{t} &amp;gt; 0.5\)&lt;/span&gt;, break; 否则计算&lt;strong&gt;分类器&lt;/strong&gt;权重&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \alpha_{t}=\frac{1}{2} \log \frac{1-\epsilon_{t}}{\epsilon_{t}} \]&lt;/span&gt;&lt;br/&gt;​ 然后更新样本权重&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \mathcal{D}_{t+1}\left(x^{(i)}\right)=\frac{1}{Z_{t}} \mathcal{D}_{t}\left(x^{(i)}\right) \exp \left[-\alpha_{t} y^{(i)} h_{t}\left(x^{(i)}\right)\right] \]&lt;/span&gt;&lt;br/&gt;​ 其中 &lt;span class=&quot;math inline&quot;&gt;\(Z_t\)&lt;/span&gt; 为归一化因子&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ Z_{t}=\sum_{i} \mathcal{D}_{t}\left(x^{(i)}\right) \exp \left[-\alpha_{t} y^{(i)} h_{t}\left(x^{(i)}\right)\right] \]&lt;/span&gt;&lt;br/&gt;构建基本分类器的线性组合&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ f(x)=\sum_{t=1}^{T} \alpha_{t} h_{t}(x) \]&lt;/span&gt;&lt;br/&gt;得到最终分类器&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ H(x)=\operatorname{sign}\left(\sum_{t=1}^{T} \alpha_{t} h_{t}(x)\right) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里我们可以看到 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_t\)&lt;/span&gt; 是大于 $\frac{1}{2} $ 的，如果误分类了，那么 &lt;span class=&quot;math inline&quot;&gt;\(-\alpha_{t} y^{(i)} h_{t}\left(x^{(i)}\right)\)&lt;/span&gt; 为大于 0 的数，那么样本的权重就会被放大，反之，则会被缩小。并且， &lt;span class=&quot;math inline&quot;&gt;\(\epsilon_t\)&lt;/span&gt; 越大，&lt;span class=&quot;math inline&quot;&gt;\(\alpha_t\)&lt;/span&gt; 就越小，即在最终构建强分类器的时候，误差率越小的弱分类器预测结果所占比重越高。&lt;/p&gt;
&lt;h2 id=&quot;算法推导&quot;&gt;算法推导&lt;/h2&gt;
&lt;p&gt;思考两个个问题， &lt;span class=&quot;math inline&quot;&gt;\(\alpha_t\)&lt;/span&gt; 的公式是怎么来的？以及权重更新公式是怎么来的？下面通过公式推导来讲解&lt;/p&gt;
&lt;p&gt;假设已经经过 &lt;span class=&quot;math inline&quot;&gt;\(t-1\)&lt;/span&gt; 轮迭代，得到&lt;span class=&quot;math inline&quot;&gt;\(f_{t-1}(x)\)&lt;/span&gt;，根据前向分布加法算法&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ f_t(x) = f_{t-1}(x) + \alpha_{t}h_t(x) \]&lt;/span&gt;&lt;br/&gt;目标是损失函数最小，即&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \min{Loss} = \min\sum_{i=1}^{N}exp[-y_i(f_{t-1}(x_i)+\alpha_th_t)] \]&lt;/span&gt;&lt;br/&gt;所以，有&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{eqnarray}(\alpha_t,h_t(x)) &amp;amp; = &amp;amp; \arg {\min_{\alpha,h}\sum_{i=1}^{N}exp[-y_i(f_{t-1}(x_i)+\alpha_th_t()x_i)]} \\ &amp;amp; = &amp;amp; \arg {\min_{\alpha,h}\sum_{i=1}^{N}w_{t,i}exp[-y_i(\alpha_th_t(x_i))]} \end{eqnarray} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ w_{t,i} = \exp[-y_if_{t-1}(x_i)] \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们先来化简损失函数&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{eqnarray}Loss &amp;amp; = &amp;amp;\sum_{y_i=h_t(x_i)}w_{t,i}exp(-\alpha_t)+\sum_{y_i \ne h_t(x_i)}w_{t,i}exp(\alpha_t) \\ &amp;amp; = &amp;amp; \sum_{i=1}^{N}w_{t,i}(\frac{\sum_{y_i=h_t(x_i)}w_{t,i}}{\sum_{i=1}^{N}w_{t,i}}exp(-\alpha_t)+\frac{\sum_{y_i \ne h_t(x_i)}w_{t,i}}{\sum_{i=1}^{N}w_{t,i}}exp(-\alpha_t)) \end{eqnarray} \]&lt;/span&gt;&lt;br/&gt;仔细以看，后面那项 &lt;span class=&quot;math inline&quot;&gt;\(\frac{\sum_{y_i \ne h_t(x_i)}w_{t,i}}{\sum_{i=1}^{N}w_{t,i}}\)&lt;/span&gt; 就是分类误差率 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon_{t}\)&lt;/span&gt;，所以&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ Loss = \sum_{i=1}^{N}w_{t,i}[(1-\epsilon_t)exp(-\alpha_t)+\epsilon_texp(\alpha_t)] \]&lt;/span&gt;&lt;br/&gt;对 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_t\)&lt;/span&gt; 求偏导&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{eqnarray} \frac{\partial Loss}{\partial \alpha_t} &amp;amp; = &amp;amp; \sum_{i=1}^{N}w_{t,i}[-(1-\epsilon_t)exp(-\alpha_t)+\epsilon_texp(\alpha_t)] \end{eqnarray} \]&lt;/span&gt;&lt;br/&gt;令 &lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial Loss}{\partial \alpha_t} = 0\)&lt;/span&gt; ，则&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ -(1-\epsilon_t)exp(-\alpha_t)+\epsilon_texp(\alpha_t) = 0 \]&lt;/span&gt;&lt;br/&gt;推得&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \alpha_{t}=\frac{1}{2} \log \frac{1-\epsilon_{t}}{\epsilon_{t}} \]&lt;/span&gt;&lt;br/&gt;另，由前向分布加法算法&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{eqnarray} w_{t,i} &amp;amp; = &amp;amp; \exp[-y_if_{t-1}(x_i)] \\ &amp;amp; = &amp;amp; \exp[-y_i(f_{t-2}(x_i)+\alpha_{t-1}h_{t-1}(x_i))] \\ &amp;amp; = &amp;amp; w_{t-1,i}\exp[\alpha_{t-1}h_{t-1}(x_i)] \end{eqnarray} \]&lt;/span&gt;&lt;br/&gt;再加上规范化因子即为算法中的更新公式。（公式敲的要累死了~~~）&lt;/p&gt;
&lt;h2 id=&quot;代码实现&quot;&gt;代码实现&lt;/h2&gt;
&lt;p&gt;这里为了方便起见，我使用了 sklearn 里面的决策树，之前使用的时候一直没发现 sklearn 里的决策树可以带权重训练 orz。。。决策树带权训练的代码我后面再研究研究&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.tree import DecisionTreeClassifier
def adaboost(X, y, M, max_depth=None):
    &quot;&quot;&quot;
    adaboost函数，使用Decision Tree作为弱分类器
    参数:
        X: 训练样本
        y: 样本标签, y = {-1, +1}
        M: 使用 M 个弱分类器
        max_depth: 基学习器决策树的最大深度
    返回:
        F: 生成的模型
    &quot;&quot;&quot;
    num_X, num_feature = X.shape
    
    # 初始化训练数据的权值分布
    D = np.ones(num_X) / num_X
    
    G = []
    alpha = []
    
    for m in range(M):
        # 使用具有权值分布 D 的训练数据集学习，得到基本分类器
        # 使用 DecisionTreeClassifier，设置树深度为 max_depth
        G_m = DecisionTreeClassifier(max_depth=max_depth)
        # 开始训练
        G_m.fit(X, y, D)
        # 计算G_m在训练数据集上的分类误差率
        y_pred = G_m.predict(X)
        e_m = np.sum(D[y != y_pred])
        
        if e_m == 0:
            break
        
        if e_m == 1:
            raise ValueError(&quot;e_m = {}&quot;.format(e_m))
            
        # 计算 G_m 的系数
        alpha_m = np.log((1 - e_m) / e_m) / 2
#         print(alpha_m)
        # 更新训练数据集的权值分布
        D = D * np.exp(-alpha_m * y * y_pred)
        D = D / np.sum(D)
        # 保存 G_m 和其系数
        G.append(G_m)
        alpha.append(alpha_m)
    
    # 构建基本分类器的线性组合
    def F(X):
        num_G = len(G)
        score = 0
        for i in range(num_G):
            score += alpha[i] * G[i].predict(X)
        return np.sign(score)
        
    return F&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;上面介绍了集成学习的一些知识点以及 AdaBoost 的基本原理及实现，下一篇将介绍集成学习中基于 Bagging 的随机森林(Random Forest)。&lt;/p&gt;
</description>
<pubDate>Fri, 27 Dec 2019 15:11:00 +0000</pubDate>
<dc:creator>ITryagain</dc:creator>
<og:description>前言 前面的文章中介绍了决策树以及其它一些算法，但是，会发现，有时候使用使用这些算法并不能达到特别好的效果。于是乎就有了 （Ensemble Learning），通过构建多个学习器一起结合来完成具体的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/csu-lmw/p/12110009.html</dc:identifier>
</item>
</channel>
</rss>