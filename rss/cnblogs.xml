<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>从零开始开发IM（即时通讯）服务端（二） - yuanrw</title>
<link>http://www.cnblogs.com/yuanrw/p/11518268.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanrw/p/11518268.html</guid>
<description>&lt;p&gt;&lt;strong&gt;好消息：IM1.0.0版本已经上线啦，支持特性&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;私聊发送文本/文件&lt;/li&gt;
&lt;li&gt;已发送/已送达/已读回执&lt;/li&gt;
&lt;li&gt;支持使用ldap登录&lt;/li&gt;
&lt;li&gt;支持接入外部的登录认证系统&lt;/li&gt;
&lt;li&gt;提供客户端jar包，方便客户端开发&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;github链接： &lt;a href=&quot;https://github.com/yuanrw/IM&quot; class=&quot;uri&quot;&gt;https://github.com/yuanrw/IM&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本篇将带大家从零开始搭建一个轻量级的IM服务端，IM的&lt;strong&gt;整体设计思路和架构&lt;/strong&gt;在我的上篇博客中已经讲过了，没看过的同学请点击&lt;a href=&quot;https://www.cnblogs.com/yuanrw/p/11460743.html&quot;&gt;从零开始开发IM（即时通讯）服务端&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;这篇将给大家带来更多的细节实现。我将从三个方面来阐述如何构建一个完整可靠的IM系统。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;可靠性&lt;/li&gt;
&lt;li&gt;安全性&lt;/li&gt;
&lt;li&gt;存储设计&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;可靠性&quot;&gt;可靠性&lt;/h2&gt;
&lt;p&gt;什么是可靠性？对于一个IM系统来说，可靠的定义至少是&lt;strong&gt;不丢消息&lt;/strong&gt;、&lt;strong&gt;消息不重复&lt;/strong&gt;、&lt;strong&gt;不乱序&lt;/strong&gt;，满足这三点，才能说有一个好的聊天体验。&lt;/p&gt;
&lt;h3 id=&quot;不丢消息&quot;&gt;不丢消息&lt;/h3&gt;
&lt;p&gt;我们先从不丢消息开始讲起。&lt;/p&gt;
&lt;p&gt;首先复习一下上一篇设计的&lt;strong&gt;服务端架构&lt;/strong&gt;：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/4/16cfb31f8b4a256d?w=708&amp;amp;h=817&amp;amp;f=png&amp;amp;s=66544&quot; alt=&quot;im-structure.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们先从一个简单例子开始思考：当Alice给Bob发送一条消息时，可能要经过这样一条链路：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/13/16d290625b2b18fa?w=310&amp;amp;h=358&amp;amp;f=png&amp;amp;s=25230&quot; alt=&quot;route&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;client--&amp;gt;connecter&lt;/li&gt;
&lt;li&gt;connector--&amp;gt;transfer&lt;/li&gt;
&lt;li&gt;transfer--&amp;gt;connector&lt;/li&gt;
&lt;li&gt;connector--&amp;gt;client&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在这整个链路中的每个环节都有可能出问题，虽然tcp协议是可靠的，但是它只能保证链路层的可靠，无法保证应用层的可靠。&lt;/p&gt;
&lt;p&gt;例如在第一步中，&lt;code&gt;connector&lt;/code&gt;收到了从&lt;code&gt;client&lt;/code&gt;发出的消息，但是转发给&lt;code&gt;transfer&lt;/code&gt;失败，那么这条消息Bob就无法收到，而Alice也不会意识到消息发送失败了。&lt;/p&gt;
&lt;p&gt;如果Bob状态是离线，那么消息链路就是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;client--&amp;gt;connector&lt;/li&gt;
&lt;li&gt;connector--&amp;gt;transfer&lt;/li&gt;
&lt;li&gt;transfer--&amp;gt;mq&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果在第三步中，&lt;code&gt;transfer&lt;/code&gt;收到了来自&lt;code&gt;connector&lt;/code&gt;的消息，但是离线消息入库失败，&lt;br/&gt;那么这个消息也是传递失败了。&lt;br/&gt;为了保证应用层的可靠，我们必须要有一个ack机制，使发送方能够确认对方收到了这条消息。&lt;/p&gt;
&lt;p&gt;具体的实现，我们模仿tcp协议做一个应用层的ack机制。&lt;/p&gt;
&lt;p&gt;tcp的报文是以&lt;code&gt;字节（byte）&lt;/code&gt;为单位的，而我们以&lt;code&gt;message&lt;/code&gt;单位。&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/13/16d286c7b504ed26?w=482&amp;amp;h=256&amp;amp;f=png&amp;amp;s=12006&quot; alt=&quot;ack&quot;/&gt;&lt;br/&gt;发送方每次发送一个消息，就要等待对方的ack回应，在ack确认消息中应该带有收到的id以便发送方识别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其次，发送方需要维护一个等待ack的队列。&lt;/strong&gt; 每次发送一个消息之后，就将消息和一个计时器入队。&lt;/p&gt;
&lt;p&gt;另外存在一个线程一直轮询队列，如果有超时未收到ack的，就取出消息重发。&lt;/p&gt;
&lt;p&gt;超时未收到ack的消息有两种处理方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;和tcp一样不断发送直到收到ack为止。&lt;/li&gt;
&lt;li&gt;设定一个最大重试次数，超过这个次数还没收到ack，就使用&lt;strong&gt;失败机制&lt;/strong&gt;处理，节约资源。例如如果是&lt;code&gt;connector&lt;/code&gt;长时间未收到&lt;code&gt;client&lt;/code&gt;的ack，那么可以主动断开和客户端的连接，剩下未发送的消息就作为离线消息入库，客户端断连后尝试重连服务器即可。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;不重复不乱序&quot;&gt;不重复、不乱序&lt;/h2&gt;
&lt;p&gt;有的时候因为网络原因可能导致ack收到较慢，发送方就会重复发送，那么接收方必须有一个去重机制。&lt;br/&gt;去重的方式是给每个消息增加一个&lt;strong&gt;唯一id&lt;/strong&gt;。这个唯一id并不一定是全局的，只需要&lt;strong&gt;在一个会话中唯一&lt;/strong&gt;即可。例如某两个人的会话，或者某一个群。如果网络断连了，重新连接后，就是新的会话了，id会重新从0开始。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接收方需要在当前会话中维护收到的最后一个消息的id，叫做&lt;code&gt;lastId&lt;/code&gt;。&lt;/strong&gt;&lt;br/&gt;每次收到一个新消息， 就将id与&lt;code&gt;lastId&lt;/code&gt;作比较看是否连续，如果不连续，就放入一个&lt;strong&gt;暂存队列 queue&lt;/strong&gt;中稍后处理。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当前会话的&lt;code&gt;lastId&lt;/code&gt;=1，接着服务器收到了消息&lt;code&gt;msg(id=2)&lt;/code&gt;，可以判断收到的消息是连续的，就处理消息，将&lt;code&gt;lastId&lt;/code&gt;修改为2。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;但是如果服务器收到消息&lt;code&gt;msg(id=3)&lt;/code&gt;，就说明消息乱序到达了，那么就将这个消息入队，等待&lt;code&gt;lastId&lt;/code&gt;变为2后，（即服务器收到消息&lt;code&gt;msg(id=2)&lt;/code&gt;并处理完了），再取出这个消息处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此，判断消息是否重复只需要判断&lt;code&gt;msgId&amp;gt;lastId &amp;amp;&amp;amp; !queue.contains(msgId)&lt;/code&gt;即可。如果收到重复的消息，可以判断是ack未送达，就再发送一次ack。&lt;/p&gt;
&lt;p&gt;接收方收到消息后完整的处理流程如下：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/13/16d28f84ca16622a?w=624&amp;amp;h=790&amp;amp;f=png&amp;amp;s=46797&quot; alt=&quot;offer.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;伪代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class ProcessMsgNode{
    /**
     * 接收到的消息
     */
    private Message message;
    /**
     * 处理消息的方法
     */
    private Consumer&amp;lt;Message&amp;gt; consumer;
}

public CompletableFuture&amp;lt;Void&amp;gt; offer(Long id,Message     message,Consumer&amp;lt;Message&amp;gt; consumer) {
    if (isRepeat(id)) {
    //消息重复
        sendAck(id);
        return null;
    }
    if (!isConsist(id)) {
    //消息不连续
        notConsistMsgMap.put(id, new ProcessMsgNode(message, consumer));
        return null;
    }
    //处理消息
    return process(id, message, consumer);
}

private CompletableFuture&amp;lt;Void&amp;gt; process(Long id, Message message, Consumer&amp;lt;Message&amp;gt; consumer) {
    return CompletableFuture
        .runAsync(() -&amp;gt; consumer.accept(message))
        .thenAccept(v -&amp;gt; sendAck(id))
        .thenAccept(v -&amp;gt; lastId.set(id))
        .thenComposeAsync(v -&amp;gt; {
            Long nextId = nextId(id);
            if (notConsistMsgMap.containsKey(nextId)) {
                //队列中有下个消息
                ProcessMsgNode node = notConsistMsgMap.get(nextId);
                return process(nextId, node.getMessage(), consumer);
            } else {
                //队列中没有下个消息
                CompletableFuture&amp;lt;Void&amp;gt; future = new CompletableFuture&amp;lt;&amp;gt;();
                future.complete(null);
                return future;
            }
        })
        .exceptionally(e -&amp;gt; {
            logger.error(&quot;[process received msg] has error&quot;, e);
            return null;
        });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;安全性&quot;&gt;安全性&lt;/h2&gt;
&lt;p&gt;无论是聊天记录还是离线消息，肯定都会在服务端存储备份，那么消息的安全性，保护客户的隐私也至关重要。&lt;br/&gt;&lt;strong&gt;因此所有的消息都必须要加密处理。&lt;/strong&gt;&lt;br/&gt;在存储模块里，维护用户信息和关系链有两张基础表，分别是&lt;code&gt;im_user&lt;/code&gt;用户表和&lt;code&gt;im_relation&lt;/code&gt;关系链表。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;im_user&lt;/code&gt;表用于存放用户常规信息，例如用户名密码等，结构比较简单。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;im_relation&lt;/code&gt;表用于记录好友关系，结构如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;CREATE TABLE `im_relation` (
  `id` bigint(20) COMMENT '关系id',
  `user_id1` varchar(100) COMMENT '用户1id',
  `user_id2` varchar(100) COMMENT '用户2id',
  `encrypt_key` char(33) COMMENT 'aes密钥',
  `gmt_create` timestamp DEFAULT CURRENT_TIMESTAMP,
  `gmt_update` timestamp DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, 
  PRIMARY KEY (`id`),
  UNIQUE KEY `USERID1_USERID2` (`user_id1`,`user_id2`)
);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;user_id1&lt;/code&gt;和&lt;code&gt;user_id2&lt;/code&gt;是互为好友的用户id，为了避免重复，存储时按照&lt;code&gt;user_id1&lt;/code&gt;&amp;lt;&lt;code&gt;user_id2&lt;/code&gt;的顺序存，并且加上联合索引。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;encrypt_key&lt;/code&gt;是随机生成的密钥。当客户端登录时，就会从数据库中获取该用户的所有的&lt;code&gt;relation&lt;/code&gt;，存在内存中，以便后续加密解密。&lt;/li&gt;
&lt;li&gt;当客户端给某个好友发送消息时，取出内存中该关系的密钥，加密后发送。同样，当收到一条消息时，取出相应的密钥解密。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;客户端完整登录流程如下：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/13/16d29dec095c5ec9?w=466&amp;amp;h=586&amp;amp;f=png&amp;amp;s=45928&quot; alt=&quot;login process&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;client调用rest接口登录。&lt;/li&gt;
&lt;li&gt;client调用rest接口获取该用户所有&lt;code&gt;relation&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;client向connector发送greet消息，通知上线。&lt;/li&gt;
&lt;li&gt;connector拉取离线消息推送给client。&lt;/li&gt;
&lt;li&gt;connector更新用户session。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;那为什么connector要先推送离线消息再更新session呢？我们思考一下如果顺序倒过来会发生什么：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;用户&lt;code&gt;Alice&lt;/code&gt;登录服务器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;connector&lt;/code&gt;更新session&lt;/li&gt;
&lt;li&gt;推送离线消息&lt;/li&gt;
&lt;li&gt;此时Bob发送了一条消息给Alice&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果离线消息还在推送的过程中，Bob发送了新消息给Alice，服务器获取到Alice的session，就会立刻推送。这时新消息就有可能夹在一堆离线消息当中推过去了，那这时，Alice收到的消息就乱序了。&lt;/p&gt;
&lt;p&gt;而我们&lt;strong&gt;必须保证离线消息的顺序在新消息之前。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么如果先推送离线消息，之后才更新session。在离线消息推送的过程中，Alice的状态就是“未上线”，这时Bob新发送的消息只会入库&lt;code&gt;im_offline&lt;/code&gt;，&lt;code&gt;im_offline&lt;/code&gt;表中的数据被读完之后才会“上线”开始接受新消息。这也就避免了乱序。&lt;/p&gt;
&lt;h2 id=&quot;存储设计&quot;&gt;存储设计&lt;/h2&gt;
&lt;h3 id=&quot;存储离线消息&quot;&gt;存储离线消息&lt;/h3&gt;
&lt;p&gt;当用户不在线时，离线消息必然要存储在服务端，等待用户上线再推送。理解了上一个小节后，离线消息的存储就非常容易了。增加一张离线消息表&lt;code&gt;im_offline&lt;/code&gt;，表结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CREATE TABLE `im_offline` (
  `id` int(11) COMMENT '主键',
  `msg_id` bigint(20) COMMENT '消息id',
  `msg_type` int(2) COMMENT '消息类型',
  `content` varbinary(5000) COMMENT '消息内容',
  `to_user_id` varchar(100) COMMENT '收件人id',
  `has_read` tinyint(1) COMMENT '是否阅读',
  `gmt_create` timestamp COMMENT '创建时间',
  PRIMARY KEY (`id`)
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;msg_type&lt;/code&gt;用于区分消息类型（&lt;code&gt;chat&lt;/code&gt;,&lt;code&gt;ack&lt;/code&gt;），&lt;code&gt;content&lt;/code&gt;加密后的消息内容以byte数组的形式存储。&lt;br/&gt;用户上线时按照条件&lt;code&gt;to_user_id=用户id&lt;/code&gt;拉取记录即可。&lt;/p&gt;
&lt;h3 id=&quot;防止离线消息重复推送&quot;&gt;防止离线消息重复推送&lt;/h3&gt;
&lt;p&gt;我们思考一下多端登录的情况，Alice有两台设备同时登陆，在这种并发的情况下，我们就需要某种机制来保证离线消息只被读取一次。&lt;/p&gt;
&lt;p&gt;这里利用&lt;strong&gt;CAS机制&lt;/strong&gt;来实现：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先取出所有&lt;code&gt;has_read=false&lt;/code&gt;的字段。&lt;/li&gt;
&lt;li&gt;检查每条消息的&lt;code&gt;has_read&lt;/code&gt;值是否为false，如果是，则改为true。这是原子操作。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;update im_offline set has_read = true where id = ${msg_id} and has_read = false&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;修改成功则推送，失败则不推送。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;相信到这里，同学们已经可以自己动手搭建一个完整可用的IM服务端了。更多问题欢迎评论区留言~~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IM1.0.0版本已上线，github链接：&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/yuanrw/IM&quot; class=&quot;uri&quot;&gt;https://github.com/yuanrw/IM&lt;/a&gt;&lt;br/&gt;觉得对你有帮助请点个star吧～！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/4/16cfae4c411b2a23?w=225&amp;amp;h=225&amp;amp;f=png&amp;amp;s=93913&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 14 Sep 2019 00:40:00 +0000</pubDate>
<dc:creator>yuanrw</dc:creator>
<og:description>好消息：IM1.0.0版本已经上线啦，支持特性 ： 私聊发送文本/文件 已发送/已送达/已读回执 支持使用ldap登录 支持接入外部的登录认证系统 提供客户端jar包，方便客户端开发 github链接</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yuanrw/p/11518268.html</dc:identifier>
</item>
<item>
<title>Linux下PHP+Nginx环境搭建 - 王宇阳</title>
<link>http://www.cnblogs.com/wangyuyang1016/p/11518203.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangyuyang1016/p/11518203.html</guid>
<description>&lt;blockquote readability=&quot;4.6538461538462&quot;&gt;
&lt;p&gt;作者：王宇阳（ Mirror ）^_^&lt;/p&gt;
&lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;​ &lt;a href=&quot;https://www.cnblogs.com/yanqingxu/p/7927830.html&quot;&gt;Nginx+PHP+MySQL安装参考&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​ &lt;a href=&quot;https://www.cnblogs.com/hometown/p/8974624.html&quot;&gt;PHP源码安装经验&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​ &lt;a href=&quot;https://blog.csdn.net/qq_24334941/article/details/79808823&quot;&gt;PHP源码环境搭建过程中常见问题&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;centos环境&quot;&gt;CentOS环境&lt;/h3&gt;
&lt;h4 id=&quot;配置centos-7网络&quot;&gt;配置CentOS-7网络：&lt;/h4&gt;
&lt;p&gt;CentOS(最小安装)默认是不打开网络的&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;启动网络&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;vi打开：/etc/sysconfig/network-scripts/ifcfg-ens33 文件&lt;/p&gt;
&lt;p&gt;将 “ONBOOT:no”属性修改为：“ONBOOT:yes”&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;重启网络服务&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# sudo service network restart &lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# ip addr&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;nginx服务&quot;&gt;Nginx服务：&lt;/h2&gt;
&lt;h3 id=&quot;安装依赖包&quot;&gt;安装依赖包&lt;/h3&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# yum -y install build-essential&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;安装：更多依赖包&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# yum -y install gcc automake autoconf libtool make&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;安装：g++&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# yum -y install gcc gcc-c++&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;安装pcre库&quot;&gt;安装PCRE库&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;选定源码目录&lt;/strong&gt; ==&amp;gt; ftp下载PCRE库 ==&amp;gt; 安装PCRE库&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# cd /usr/local/src

# wget ftp://ftp.pcre.org/pub/pcre/pcre-8.42.tar.gz

# tar -zxvf pcre-8.42.tar.gz

# cd /pcre-8.42

# ./configure

# make &amp;amp;&amp;amp; make install&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;安装zlib源码包&quot;&gt;安装zlib源码包&lt;/h3&gt;
&lt;p&gt;下载zlib源码包 ==&amp;gt; 安装zlib包&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# cd /usr/local/src

# wget http://zlib.net/zlib-1.2.11.tar.gz

# tar -zxvf zlib-1.2.11.tar.gz

# cd zlib-1.2.11

# ./configure

# make &amp;amp;&amp;amp; make install&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;安装openssl源码包&quot;&gt;安装openssl源码包&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# cd /usr/local/src

# wget https://www.openssl.org/source/openssl-1.1.0k.tar.gz

# tar -zxvf openssl-1.1.0k.tar.gz

# cd ./openssl-1.1.0k

# ./configure

# make &amp;amp;&amp;amp; make install&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;安装nginx&quot;&gt;安装Nginx&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# cd /usr/local/src

# wget http://nginx.org/download/nginx-1.16.1.tar.gz

# tar -zxvf nginx-1.16.1.tar.gz

# cd nginx-1.16.1

# groupadd -r nginx
# useradd -r -g nginx nginx

# ./configure \
--prefix=/usr/local/nginx \
--sbin-path=/usr/local/nginx/sbin/nginx \
--conf-path=/usr/local/nginx/nginx.conf \
--pid-path=/usr/local/nginx/nginx.pid \
--user=nginx \
--group=nginx \
--with-http_ssl_module \
--with-http_flv_module \
--with-http_mp4_module  \
--with-http_stub_status_module \
--with-http_gzip_static_module \
--http-client-body-temp-path=/var/tmp/nginx/client/ \
--http-proxy-temp-path=/var/tmp/nginx/proxy/ \
--http-fastcgi-temp-path=/var/tmp/nginx/fcgi/ \
--http-uwsgi-temp-path=/var/tmp/nginx/uwsgi \
--http-scgi-temp-path=/var/tmp/nginx/scgi \
--with-pcre=/usr/local/src/pcre-8.42 \
--with-zlib=/usr/local/src/zlib-1.2.11 \
--with-openssl=/usr/local/src/openssl-1.1.0k \

[注：当前所在目录一定要是/usr/local/src/nginx-1.16.1

--with-pcre=/usr/local/src/pcre-8.41 指的是pcre-8.42 的源码路径。

--with-zlib=/usr/local/src/zlib-1.2.11 指的是zlib-1.2.11 的源码路径。

--with-openssl=/usr/local/src/openssl-1.1.0g 指的是openssl-1.1.0k 的源码路径。]

# make &amp;amp;&amp;amp; make install&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;nginx编译选项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;make是用来编译的，它从Makefile中读取指令，然后编译。&lt;/p&gt;
&lt;p&gt;make install是用来安装的，它也从Makefile中读取指令，安装到指定的位置。&lt;/p&gt;
&lt;p&gt;configure命令是用来检测你的安装平台的目标特征的。它定义了系统的各个方面，包括nginx的被允许使用的连接处理的方法，比如它会检测你是不是有CC或GCC，并不是需要CC或GCC，它是个shell脚本，执行结束时，它会创建一个Makefile文件。nginx的configure命令支持以下参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;--prefix=*path*&lt;/code&gt; 定义一个目录，存放服务器上的文件 ，也就是nginx的安装目录。默认使用 &lt;code&gt;/usr/local/nginx。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--sbin-path=*path*&lt;/code&gt; 设置nginx的可执行文件的路径，默认为 &lt;code&gt;*prefix*/sbin/nginx&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--conf-path=*path*&lt;/code&gt; 设置在nginx.conf配置文件的路径。nginx允许使用不同的配置文件启动，通过命令行中的-c选项。默认为&lt;code&gt;*prefix*/conf/nginx.conf&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--pid-path=*path* 设置nginx.pid文件，将存储的主进程的进程号。安装完成后，可以随时改变的文件名 ， 在nginx.conf配置文件中使用 PID指令。默认情况下，文件名 为``*prefix*/logs/nginx.pid&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--error-log-path=*path*&lt;/code&gt; 设置主错误，警告，和诊断文件的名称。安装完成后，可以随时改变的文件名 ，在nginx.conf配置文件中 使用 的error_log指令。默认情况下，文件名 为&lt;code&gt;*prefix*/logs/error.log&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--http-log-path=*path*&lt;/code&gt; 设置主请求的HTTP服务器的日志文件的名称。安装完成后，可以随时改变的文件名 ，在nginx.conf配置文件中 使用 的access_log指令。默认情况下，文件名 为&lt;code&gt;*prefix*/logs/access.log&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--user=*name*&lt;/code&gt; 设置nginx工作进程的用户。安装完成后，可以随时更改的名称在nginx.conf配置文件中 使用的 user指令。默认的用户名是nobody。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--group=*name*&lt;/code&gt; 设置nginx工作进程的用户组。安装完成后，可以随时更改的名称在nginx.conf配置文件中 使用的 user指令。默认的为非特权用户。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--with-select_module&lt;/code&gt; &lt;code&gt;--without-select_module 启用或禁用构建一个模块来允许服务器使用select()方法。该模块将自动建立，如果平台不支持的kqueue，epoll，rtsig或/dev/poll。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--with-poll_module&lt;/code&gt; &lt;code&gt;--without-poll_module&lt;/code&gt; 启用或禁用构建一个模块来允许服务器使用poll()方法。该模块将自动建立，如果平台不支持的kqueue，epoll，rtsig或/dev/poll。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--without-http_gzip_module&lt;/code&gt; — 不编译压缩的HTTP服务器的响应模块。编译并运行此模块需要zlib库。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--without-http_rewrite_module&lt;/code&gt; 不编译重写模块。编译并运行此模块需要PCRE库支持。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--without-http_proxy_module&lt;/code&gt; — 不编译http_proxy模块。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--with-http_ssl_module&lt;/code&gt; — 使用https协议模块。默认情况下，该模块没有被构建。建立并运行此模块的OpenSSL库是必需的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--with-pcre=*path*&lt;/code&gt; — 设置PCRE库的源码路径。PCRE库的源码（版本4.4 - 8.30）需要从PCRE网站下载并解压。其余的工作是Nginx的./ configure和make来完成。正则表达式使用在location指令和 ngx_http_rewrite_module 模块中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--with-pcre-jit&lt;/code&gt; —编译PCRE包含“just-in-time compilation”（1.1.12中， pcre_jit指令）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--with-zlib=*path*&lt;/code&gt; —设置的zlib库的源码路径。要下载从 zlib（版本1.1.3 - 1.2.5）的并解压。其余的工作是Nginx的./ configure和make完成。ngx_http_gzip_module模块需要使用zlib 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--with-cc-opt=*parameters*&lt;/code&gt; — 设置额外的参数将被添加到CFLAGS变量。例如,当你在FreeBSD上使用PCRE库时需要使用:&lt;code&gt;--with-cc-opt=&quot;-I /usr/local/include。&lt;/code&gt;.如需要需要增加 &lt;code&gt;select()支持的文件数量&lt;/code&gt;:&lt;code&gt;--with-cc-opt=&quot;-D FD_SETSIZE=2048&quot;.&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--with-ld-opt=*parameters*&lt;/code&gt; —设置附加的参数，将用于在链接期间。例如，当在FreeBSD下使用该系统的PCRE库,应指定:&lt;code&gt;--with-ld-opt=&quot;-L /usr/local/lib&quot;.&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;安装完成后，按照安装的参数，安装的启动目录在/usr/local/nginx&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@localhost nginx]# ls -l
总用量 76
drwxr-xr-x. 2 root root 4096 9月   8 09:46 conf
-rw-r--r--. 1 root root 1077 9月   8 10:34 fastcgi.conf
-rw-r--r--. 1 root root 1077 9月   8 10:34 fastcgi.conf.default
-rw-r--r--. 1 root root 1007 9月   8 10:34 fastcgi_params
-rw-r--r--. 1 root root 1007 9月   8 10:34 fastcgi_params.default
drwxr-xr-x. 2 root root   40 9月   8 09:46 html
-rw-r--r--. 1 root root 2837 9月   8 10:34 koi-utf
-rw-r--r--. 1 root root 2223 9月   8 10:34 koi-win
drwxr-xr-x. 2 root root   41 9月   8 10:37 logs
-rw-r--r--. 1 root root 5231 9月   8 10:34 mime.types
-rw-r--r--. 1 root root 5231 9月   8 10:34 mime.types.default
-rw-r--r--. 1 root root 2656 9月   8 10:34 nginx.conf
-rw-r--r--. 1 root root 2656 9月   8 10:34 nginx.conf.default
-rw-r--r--. 1 root root    6 9月   8 10:37 nginx.pid
drwxr-xr-x. 2 root root   36 9月   8 10:34 sbin
-rw-r--r--. 1 root root  636 9月   8 10:34 scgi_params
-rw-r--r--. 1 root root  636 9月   8 10:34 scgi_params.default
-rw-r--r--. 1 root root  664 9月   8 10:34 uwsgi_params
-rw-r--r--. 1 root root  664 9月   8 10:34 uwsgi_params.default
-rw-r--r--. 1 root root 3610 9月   8 10:34 win-utf
[root@localhost nginx]# pwd
/usr/local/nginx
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;启动nginx服务&quot;&gt;启动Nginx服务:&lt;/h3&gt;
&lt;p&gt;由于CentOS-7防火墙不开发端口，所以在本地测试中，可以选择关闭防火墙或者允许开发80端口&lt;/p&gt;
&lt;h4 id=&quot;centos防火墙&quot;&gt;CentOS防火墙&lt;/h4&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# systemctl status firewalld     ==&amp;gt; 防火墙状态
# systemctl start firewalld      ==&amp;gt; 开启防火墙
# systemctl stop firewalld       ==&amp;gt; 关闭防火墙
# systemctl restart firewalld    ==&amp;gt; 重启防火墙
# firewall-cmd --reload          ==&amp;gt; 防火墙重载
# firewall-cmd --permanent --zone=public --add-port=80/tcp
    permanent: 永久有效
    zone：作用域
    --add-port=80/tcp：添加-端口=端口/通信协议&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;开放端口或关闭防火墙后就可以启动nginx服务&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&quot;服务启动&quot;&gt;服务启动&lt;/h4&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@localhost nginx]# netstat -ano | grep 80
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      off (0.00/0/0)
unix  3      [ ]         STREAM     CONNECTED     80900    
unix  3      [ ]         STREAM     CONNECTED     80899    
[root@localhost nginx]# /usr/local/nginx/sbin/nginx
nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)
nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)
nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)
nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)
nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)
nginx: [emerg] still could not bind()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;通过netstat查看端口网络状态，是否有服务占用80端口；通过调用nginx的启动目录实现nginx服务启动&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1512305/201909/1512305-20190914022130071-1497216669.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;如图：启动成功&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&quot;nginx服务维护&quot;&gt;Nginx服务维护&lt;/h4&gt;
&lt;p&gt;为了避免每次开机手动启动，可以使用命令脚本，注册服务，开机自启动等&lt;/p&gt;
&lt;p&gt;创建nginx启动命令脚本&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;`vi /etc/init.d/nginx`&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;插入以下内容, 注意修改PATH和NAME字段, 匹配自己的安装路径 (这段是从网上copy的)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;`#! /bin/bash``# chkconfig: - 85 15``PATH=/usr/local/nginx``DESC=``&quot;nginx daemon&quot;``NAME=nginx``DAEMON=$PATH/sbin/$NAME``CONFIGFILE=$PATH/$NAME.conf``PIDFILE=$PATH/logs/$NAME.pid``SCRIPTNAME=/etc/init.d/$NAME``set` `-e``[ -x ``&quot;$DAEMON&quot;` `] || exit 0``do_start() {``$DAEMON -c $CONFIGFILE || echo -n ``&quot;nginx already running&quot;``}``do_stop() {``$DAEMON -s stop || echo -n ``&quot;nginx not running&quot;``}``do_reload() {``$DAEMON -s reload || echo -n ``&quot;nginx can't reload&quot;``}``case` `&quot;$1&quot;` `in``start)``echo -n ``&quot;Starting $DESC: $NAME&quot;``do_start``echo ``&quot;.&quot;``;;``stop)``echo -n ``&quot;Stopping $DESC: $NAME&quot;``do_stop``echo ``&quot;.&quot;``;;``reload|graceful)``echo -n ``&quot;Reloading $DESC configuration...&quot;``do_reload``echo ``&quot;.&quot;``;;``restart)``echo -n ``&quot;Restarting $DESC: $NAME&quot;``do_stop``do_start``echo ``&quot;.&quot;``;;``*)``echo ``&quot;Usage: $SCRIPTNAME {start|stop|reload|restart}&quot;` `&amp;gt;&amp;amp;2``exit 3``;;``esac``exit 0`&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置执行权限&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;`chmod a+x /etc/init.d/nginx`&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注册成服务&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;`chkconfig --add nginx`&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置开机启动&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;`chkconfig nginx ``on`&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重启, 查看nginx服务是否自动启动&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;`shutdown -h 0 -r``ss -apn|grep nginx`&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对nginx服务执行停止/启动/重新读取配置文件操作&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;`#启动nginx服务``systemctl start nginx.service``#停止nginx服务``systemctl stop nginx.service``#重启nginx服务``systemctl restart nginx.service``#重新读取nginx配置(这个最常用, 不用停止nginx服务就能使修改的配置生效)``systemctl reload nginx.service`&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;mysql安装&quot;&gt;MySQL安装：&lt;/h2&gt;
&lt;h3 id=&quot;linux-yum-rpm&quot;&gt;Linux yum-rpm&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@localhost src]# rpm -qa |grep mysql

[root@localhost src]# wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm

[root@localhost src]# rpm -ivh mysql-community-release-el7-5.noarch.rpm

[root@localhost src]# yum dpdate

[root@localhost src]# yum install mysql-server 


[root@localhost src]# chown mysql:mysql -R /var/lib/mysql   设置权限

[root@localhost src]# mysqld --initialize 初始化mysql

[root@localhost src]# systemctl start mysqld  启动mysql
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;php环境&quot;&gt;PHP环境：&lt;/h2&gt;
&lt;h3 id=&quot;编译安装php-fpm&quot;&gt;编译安装php-fpm&lt;/h3&gt;
&lt;p&gt;PHP-FPM是一个PHP FastCGI管理器，是只用于PHP的&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;安装依赖包&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# yum -y install libmcrypt-devel mhash-devel libxslt-devel \
libjpeg libjpeg-devel libpng libpng-dvevl freetype freetype-devel libxml2 libxml2-devel \
zlib zlib-devel glibc glibc-devel glib2 glib2-devel bzip2 bzip2-devel \
ncurses ncurses-devel curl curl-devel e2fsprogs e2fsprogs-devel \
krb5 krb5-devel libidn libidn-devel openssl openssl-devel


# yum -y install libzip 
# wget http://103.40.19.56/lnmp/libzip-1.3.2.tar.gz 
# tar -zxvf libzip-1.3.2.tar.gz cd libzip-1.3.2 
# ./configure 
# make &amp;amp;&amp;amp; make install

# wget ftp://mcrypt.hellug.gr/pub/crypto/mcrypt/attic/libmcrypt/libmcrypt-2.5.7.tar.gz
# tar -zxvf libmcrypt-2.5.7.tar.gz
# cd libmcrypt-2.5.7
# ./configure  –prefix=/usr/local
# make &amp;amp;&amp;amp; make install&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;源码安装PHP：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# cd /usr/local/src
# wget http://php.net/get/php-5.6.27.tar.gz/from/a/mirror
# tar -zxvf php-5.6.27.tar.gz
# ./configure --prefix=/usr/local/php  --enable-fpm --with-mcrypt \
--enable-mbstring --enable-pdo --with-curl --disable-debug  --disable-rpath \
--enable-inline-optimization --with-bz2  --with-zlib --enable-sockets \
--enable-sysvsem --enable-sysvshm --enable-pcntl --enable-mbregex \
--with-mhash --enable-zip --with-pcre-regex --with-pdo-mysql --with-mysqli \
--with-gd --with-jpeg-dir --with-freetype-dir --enable-calendar\
# make &amp;amp;&amp;amp; make install&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;我在执行configure时，发生报错：Please reinstall the libzip distribution 于是我删除了旧版的libzip“&lt;u&gt;yum remove libzip&lt;/u&gt;”，之后下载libzip源码包进行本地执行configure+make&amp;amp;&amp;amp;make install&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;执行libzip的安装：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# wget https://libzip.org/download/libzip-1.5.2.tar.gz
# tar -zxf libzip-1.2.0.tar.gz

# cd libzip-1.2.0

# ./configure

# make &amp;amp;&amp;amp; make install&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PHP安装新问题：安装执行configure时报错&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;configure: error: off_t undefined; check your library configuration&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;vim /etc/ld.so.conf 
#添加如下几行
/usr/local/lib64
/usr/local/lib
/usr/lib
/usr/lib64 
#保存退出
:wq
ldconfig -v # 执行命令，使之生效&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;报错：configure: WARNING: unrecognized options: --with-mcrypt&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;解决方法：PHP 7.2+不支持 --with-mcrypt ; --enable-gd-native-ttf&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# ./configure --prefix=/usr/local/php  --enable-fpm \
--enable-mbstring --enable-pdo --with-curl --disable-debug  --disable-rpath \
--enable-inline-optimization --with-bz2  --with-zlib --enable-sockets \
--enable-sysvsem --enable-sysvshm --enable-pcntl --enable-mbregex \
--with-mhash --enable-zip --with-pcre-regex --with-pdo-mysql --with-mysqli \
--with-gd --with-jpeg-dir --with-freetype-dir --enable-calendar\&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;其它错误可以参考&lt;a href=&quot;https://blog.csdn.net/qq_24334941/article/details/79808823&quot;&gt;百度/Google解决(常见php安装的方案)&lt;/a&gt;！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;至此！PHP-fpm安装的基本流程结束了，下一步就需要配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;用户配置文件&quot;&gt;用户配置文件&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;为php提供配置文件：php.ini&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# cp php.ini-production /usr/local/php/lib/php.ini&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;为php-fpm提供配置文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# cd /usr/local/php
# cp etc/php.fpm.conf.default etc/php-fpm.conf
# vi etc/php-fpm.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;vi打开php-fpm.conf文件：&lt;/p&gt;
&lt;p&gt;将文件的尾部的索引；修改成实际的目录&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;include=/usr/local/php/etc/php-fpm.d/*.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加用户和组：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;useradd mirror
groupadd -g mirror mirror&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认情况下，etc/php-fpm.d/目录下有一个“www .conf.defalut”用户配置文件&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# cp /usr/local/php/etc/php-fpm.d/www.conf.default /usr/local/php/etc/php-fpm.d/www.conf
# vi /usr/local/php/etc/php-fpm.d/www.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改“www.conf&quot;文件中的user和group的value；添加用户和组&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;user = mirror
group = mirror&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;启动php-fpm服务&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# /usr/local/php/sbin/php-fpm
# ps aux | grep php-fpm [验证服务启动]
# netstat -tln | grep 9000 [验证网络端口是否使用]&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@localhost /]# ps aux | grep php-fpm
root      41831  0.0  0.3 221264  6220 ?        Ss   08:54   0:00 php-fpm: master process (/usr/local/php/etc/php-fpm.conf)
mirror    41832  0.0  0.2 221264  5748 ?        S    08:54   0:00 php-fpm: pool www
mirror    41833  0.0  0.2 221264  5748 ?        S    08:54   0:00 php-fpm: pool www
root      41835  0.0  0.0 110292   916 pts/0    R+   08:54   0:00 grep --color=auto php-fpm
[root@localhost /]# netstat -tln | grep 9000
tcp        0      0 127.0.0.1:9000          0.0.0.0:*               LISTEN   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;至此！php-fpm服务启动成功！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;nginxphp环境配置&quot;&gt;Nginx+PHP环境配置&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;打开nginx.conf（nginx配置文件）&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@localhost nginx]# vi ./nginx.conf


#user  nobody;
worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       mime.types;
    default_type  application/octet-stream;

    #log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
    #                  '$status $body_bytes_sent &quot;$http_referer&quot; '
    #                  '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';

    #access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;

    server {
        listen       80;
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
            root   html;
            index  index.html index.htm;
        }

        #error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }

        # proxy the PHP scripts to Apache listening on 127.0.0.1:80
        #
        #location ~ \.php$ {
        #    proxy_pass   http://127.0.0.1;
        #}

        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
        #
        #location ~ \.php$ {
        #    root           html;
        #    fastcgi_pass   127.0.0.1:9000;
        #    fastcgi_index  index.php;
        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
        #    include        fastcgi_params;
        #}

        # deny access to .htaccess files, if Apache's document root
        # concurs with nginx's one
        #
        #location ~ /\.ht {
        #    deny  all;
        #}
    }


    # another virtual host using mix of IP-, name-, and port-based configuration
    #
    #server {
    #    listen       8000;
    #    listen       somename:8080;
    #    server_name  somename  alias  another.alias;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}


    # HTTPS server
    #
    #server {
    #    listen       443 ssl;
    #    server_name  localhost;

    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;

    #    ssl_session_cache    shared:SSL:1m;
    #    ssl_session_timeout  5m;

    #    ssl_ciphers  HIGH:!aNULL:!MD5;
    #    ssl_prefer_server_ciphers  on;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;修改server配置块中的location和php后端请求配置块&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;  server {
        listen       80;
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
            root   html;
            index  index.html index.htm index.php
        }

        #error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }

        # proxy the PHP scripts to Apache listening on 127.0.0.1:80
        #
        #location ~ \.php$ {
        #    proxy_pass   http://127.0.0.1;
        #}

        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
        #
        location ~ \.php$ {
            root           html;
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
            fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
            include        fastcgi_params;
        }

        # deny access to .htaccess files, if Apache's document root
        # concurs with nginx's one
        #
        #location ~ /\.ht {
        #    deny  all;
        #}
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;在location配置块中添加index.php首页&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;php请求和后端php-fpm模块进行通信，需要配置location ~ .php$配置块&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;​ root：配置php程序文件的根目录&lt;/p&gt;
&lt;p&gt;*** 修改配置文件的第一行：”user“属性为我们之前配置的用户**，表示nginx的权限&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;至此！我们的Nginx和php的环境完成简单的配置！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;大功告成&quot;&gt;大功告成&lt;/h3&gt;
&lt;h4 id=&quot;启动步骤&quot;&gt;启动步骤：&lt;/h4&gt;
&lt;h4 id=&quot;phpinfo&quot;&gt;phpinfo():&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1512305/201909/1512305-20190914022108226-1867414837.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Nginx的目录html中添加一个php文件：”index.php“&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;&amp;lt;?php
    phpinfo();
?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;测试数据库连接&quot;&gt;测试数据库连接：&lt;/h4&gt;
&lt;p&gt;编写一个连接数据库行为的php文件：”mysql.php“&lt;/p&gt;
&lt;p&gt;&lt;em&gt;php和mysql之间的连接操作依靠的是”mysqli“&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&amp;lt;?php
    $conn = mysqli_connect(&quot;127.0.0.1&quot;,&quot;root&quot;,&quot;926498&quot;);
    if(! $conn ) {
        echo &quot;连接失败&quot;.mysqli_connect_error();
    } else {
        echo &quot;连接成功&quot;;
    }
?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;至此！PHP+Nginx+MySQL环境完成了基本的搭建!&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 13 Sep 2019 18:22:00 +0000</pubDate>
<dc:creator>王宇阳</dc:creator>
<og:description>PHP+Nginx环境搭建 作者：王宇阳（ Mirror ）^_^ 参考文章： ​ 'Nginx+PHP+MySQL安装参考' ​ 'PHP源码安装经验' ​ 'PHP源码环境搭建过程中常见问题' C</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wangyuyang1016/p/11518203.html</dc:identifier>
</item>
<item>
<title>4.Sentinel源码分析— Sentinel是如何做到降级的？ - luozhiyun</title>
<link>http://www.cnblogs.com/luozhiyun/p/11517918.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luozhiyun/p/11517918.html</guid>
<description>&lt;p&gt;各位中秋节快乐啊，我觉得在这个月圆之夜有必要写一篇源码解析，以表示我内心的高兴~&lt;/p&gt;
&lt;p&gt;Sentinel源码解析系列：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/luozhiyun/p/11439993.html&quot;&gt;1.Sentinel源码分析—FlowRuleManager加载规则做了什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/luozhiyun/p/11451557.html&quot;&gt;2. Sentinel源码分析—Sentinel是如何进行流量统计的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/luozhiyun/p/11489128.html&quot;&gt;3. Sentinel源码分析— QPS流量控制是如何实现的？&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;在我的第二篇文章里面&lt;a href=&quot;https://www.cnblogs.com/luozhiyun/p/11451557.html&quot;&gt;2. Sentinel源码分析—Sentinel是如何进行流量统计的？&lt;/a&gt;里面介绍了整个Sentinel的主流程是怎样的。所以降级的大致流程可以概述为：&lt;br/&gt;1. 设置降级策略，是根据平均响应时间还是异常比例来进行降级的&lt;br/&gt;2. 根据资源创建一系列的插槽&lt;br/&gt;3. 依次调用插槽，根据设定的插槽类型来进行降级&lt;/p&gt;
&lt;p&gt;我们先来看个例子，方便大家自己断点跟踪：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static final String KEY = &quot;abc&quot;;
private static final int threadCount = 100;
private static int seconds = 60 + 40;

public static void main(String[] args) throws Exception {
         
        List&amp;lt;DegradeRule&amp;gt; rules = new ArrayList&amp;lt;DegradeRule&amp;gt;();
        DegradeRule rule = new DegradeRule();
        rule.setResource(KEY);
        // set threshold rt, 10 ms
        rule.setCount(10);
        rule.setGrade(RuleConstant.DEGRADE_GRADE_RT);
        rule.setTimeWindow(10);
        rules.add(rule);
        DegradeRuleManager.loadRules(rules);

    for (int i = 0; i &amp;lt; threadCount; i++) {
        Thread entryThread = new Thread(new Runnable() {

            @Override
            public void run() {
                while (true) {
                    Entry entry = null;
                    try {
                        TimeUnit.MILLISECONDS.sleep(5);
                        entry = SphU.entry(KEY);
                        // token acquired
                        pass.incrementAndGet();
                        // sleep 600 ms, as rt
                        TimeUnit.MILLISECONDS.sleep(600);
                    } catch (Exception e) {
                        block.incrementAndGet();
                    } finally {
                        total.incrementAndGet();
                        if (entry != null) {
                            entry.exit();
                        }
                    }
                }
            }
        });
        entryThread.setName(&quot;working-thread&quot;);
        entryThread.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其他的流程基本上和第二篇文章里介绍的差不多，这篇文章来介绍Sentinel的主流程，Sentinel的降级策略全部都是在DegradeSlot中进行操作的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DegradeSlot&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DegradeSlot extends AbstractLinkedProcessorSlot&amp;lt;DefaultNode&amp;gt; {
    @Override
    public void entry(Context context, ResourceWrapper resourceWrapper, DefaultNode node, int count, boolean prioritized, Object... args)
        throws Throwable {
        DegradeRuleManager.checkDegrade(resourceWrapper, context, node, count);
        fireEntry(context, resourceWrapper, node, count, prioritized, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;DegradeSlot会直接调用DegradeRuleManager进行降级的操作，我们直接进入到DegradeRuleManager.checkDegrade方法中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DegradeRuleManager#checkDegrade&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void checkDegrade(ResourceWrapper resource, Context context, DefaultNode node, int count)
    throws BlockException {
    //根据resource来获取降级策略
    Set&amp;lt;DegradeRule&amp;gt; rules = degradeRules.get(resource.getName());
    if (rules == null) {
        return;
    }
    
    for (DegradeRule rule : rules) {
        if (!rule.passCheck(context, node, count)) {
            throw new DegradeException(rule.getLimitApp(), rule);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法逻辑也是非常的清晰，首先是根据资源名获取到注册过的降级规则，然后遍历规则集合调用规则的passCheck，如果返回false那么就抛出异常进行降级。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DegradeRule#passCheck&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public boolean passCheck(Context context, DefaultNode node, int acquireCount, Object... args) {
    //返回false直接进行降级
    if (cut.get()) {
        return false;
    }
    //降级是根据资源的全局节点来进行判断降级策略的
    ClusterNode clusterNode = ClusterBuilderSlot.getClusterNode(this.getResource());
    if (clusterNode == null) {
        return true;
    }
    //根据响应时间降级策略
    if (grade == RuleConstant.DEGRADE_GRADE_RT) {
        //获取节点的平均响应时间
        double rt = clusterNode.avgRt();
        if (rt &amp;lt; this.count) {
            passCount.set(0);
            return true;
        }
        //rtSlowRequestAmount默认是5
        // Sentinel will degrade the service only if count exceeds.
        if (passCount.incrementAndGet() &amp;lt; rtSlowRequestAmount) {
            return true;
        }
        //    根据异常比例降级
    } else if (grade == RuleConstant.DEGRADE_GRADE_EXCEPTION_RATIO) {
        double exception = clusterNode.exceptionQps();
        double success = clusterNode.successQps();
        double total = clusterNode.totalQps();
        // If total amount is less than minRequestAmount, the request will pass.
        if (total &amp;lt; minRequestAmount) {
            return true;
        }

        // In the same aligned statistic time window,
        // &quot;success&quot; (aka. completed count) = exception count + non-exception count (realSuccess)
        double realSuccess = success - exception;
        if (realSuccess &amp;lt;= 0 &amp;amp;&amp;amp; exception &amp;lt; minRequestAmount) {
            return true;
        }

        if (exception / success &amp;lt; count) {
            return true;
        }
        //    根据异常数降级
    } else if (grade == RuleConstant.DEGRADE_GRADE_EXCEPTION_COUNT) {
        double exception = clusterNode.totalException();
        if (exception &amp;lt; count) {
            return true;
        }
    }
    //根据设置的时间窗口进行重置
    if (cut.compareAndSet(false, true)) {
        ResetTask resetTask = new ResetTask(this);
        pool.schedule(resetTask, timeWindow, TimeUnit.SECONDS);
    }

    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法首先会去获取cut的值，如果是true那么就直接进行限流操作。然后会根据resource获取ClusterNode全局节点。往下分别根据三种不同的策略来进行降级。&lt;/p&gt;
&lt;h3 id=&quot;degrade_grade_rt根据响应时间进行降级&quot;&gt;DEGRADE_GRADE_RT根据响应时间进行降级&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;if (grade == RuleConstant.DEGRADE_GRADE_RT) {
    //获取节点的平均响应时间
    double rt = clusterNode.avgRt();
    if (rt &amp;lt; this.count) {
        passCount.set(0);
        return true;
    }
    //rtSlowRequestAmount默认是5
    // Sentinel will degrade the service only if count exceeds.
    if (passCount.incrementAndGet() &amp;lt; rtSlowRequestAmount) {
        return true;
    } 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是根据响应时间进行降级，那么会获取clusterNode的平均响应时间，如果平均响应时间大于所设定的count（默认是毫秒），那么就调用passCount加1，如果passCount大于5，那么直接降级。&lt;/p&gt;
&lt;p&gt;所以看到这里我们应该知道根据平均响应时间降级前几个请求即使响应过长也不会立马降级，而是要等到第六个请求到来才会进行降级。&lt;/p&gt;
&lt;p&gt;我们进入到clusterNode的avgRt方法中看一下是如何获取到clusterNode的平均响应时间的。&lt;/p&gt;
&lt;p&gt;clusterNode是StatisticNode的实例&lt;br/&gt;&lt;strong&gt;StatisticNode#avgRt&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;java public double avgRt() { //获取当前时间窗口内调用成功的次数 long successCount = rollingCounterInSecond.success(); if (successCount == 0) { return 0; } //获取窗口内的响应时间 return rollingCounterInSecond.rt() * 1.0 / successCount; }&lt;/code&gt;e&lt;/p&gt;
&lt;p&gt;这个方法主要是调用rollingCounterInSecond获取成功次数，然后再获取窗口内的响应时间，用总响应时间除以次数得到平均每次成功调用的响应时间。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/luozhiyun/p/11439993.html&quot;&gt;1.Sentinel源码分析—FlowRuleManager加载规则做了什么？&lt;/a&gt;中，我已经具体讲述了StatisticNode里面的rollingCounterInMinute实现原理，rollingCounterInMinute是按分钟进行统计的时间窗口。现在我们来讲一下rollingCounterInSecond按秒来进行统计的时间窗口。&lt;/p&gt;
&lt;p&gt;在StatisticNode里面初始化rollingCounterInSecond：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private transient volatile Metric rollingCounterInSecond = new ArrayMetric(SampleCountProperty.SAMPLE_COUNT,
    IntervalProperty.INTERVAL);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个初始化的方法里，会传入两个参数，SampleCountProperty.SAMPLE_COUNT的值是2，&lt;br/&gt;IntervalProperty.INTERVAL的值是1000。&lt;/p&gt;
&lt;p&gt;我们进入到ArrayMetric的构造方法中：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private final LeapArray&amp;lt;MetricBucket&amp;gt; data;
public ArrayMetric(int sampleCount, int intervalInMs) {
    this.data = new OccupiableBucketLeapArray(sampleCount, intervalInMs);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在创建ArrayMetric实例的时候会给data创建一个OccupiableBucketLeapArray实例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OccupiableBucketLeapArray&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public OccupiableBucketLeapArray(int sampleCount, int intervalInMs) {
    // This class is the original &quot;CombinedBucketArray&quot;.
    super(sampleCount, intervalInMs);
    this.borrowArray = new FutureBucketLeapArray(sampleCount, intervalInMs);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;OccupiableBucketLeapArray继承LeapArray这个抽象类，初始化的时候会调用父类的构造器：&lt;br/&gt;&lt;strong&gt;LeapArray&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public LeapArray(int sampleCount, int intervalInMs) {
    AssertUtil.isTrue(sampleCount &amp;gt; 0, &quot;bucket count is invalid: &quot; + sampleCount);
    AssertUtil.isTrue(intervalInMs &amp;gt; 0, &quot;total time interval of the sliding window should be positive&quot;);
    //intervalInMs是sampleCount的整数
    AssertUtil.isTrue(intervalInMs % sampleCount == 0, &quot;time span needs to be evenly divided&quot;);
    //每个小窗口的时间跨度
    this.windowLengthInMs = intervalInMs / sampleCount;
    //窗口的长度
    this.intervalInMs = intervalInMs;
    //窗口个数
    this.sampleCount = sampleCount;

    this.array = new AtomicReferenceArray&amp;lt;&amp;gt;(sampleCount);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;OccupiableBucketLeapArray在初始化的时候也会创建一个FutureBucketLeapArray实例赋值给borrowArray。&lt;/p&gt;
&lt;p&gt;FutureBucketLeapArray也是继承LeapArray：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public FutureBucketLeapArray(int sampleCount, int intervalInMs) {
    // This class is the original &quot;BorrowBucketArray&quot;.
    super(sampleCount, intervalInMs);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直接通过调用父类LeapArray的构造方法进行初始化。&lt;/p&gt;
&lt;p&gt;到这里rollingCounterInSecond的创建过程讲完了。&lt;/p&gt;
&lt;p&gt;下面我们再回到StatisticNode中，在调用StatisticNode的avgRt方法的时候会调用rollingCounterInSecond.success()方法获取当前时间窗口的调用成功次数：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ArrayMetric#success&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public long success() {
    //设置或更新当前的时间窗口
    data.currentWindow();
    long success = 0;
    //获取窗口里有效的Bucket
    List&amp;lt;MetricBucket&amp;gt; list = data.values();
    for (MetricBucket window : list) {
        success += window.success();
    }
    return success;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的data是的父类是LeapArray，LeapArray里面有一个array数组，用来记录时间窗口，在我们这里是基于秒钟的时间窗口，所以array的大小为2。data的结构图我直接从&lt;a href=&quot;https://www.cnblogs.com/luozhiyun/p/11439993.html&quot;&gt;1.Sentinel源码分析—FlowRuleManager加载规则做了什么？&lt;/a&gt;中拿过来：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204119/201909/1204119-20190913230054147-1186661522.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只不过这里的WindowWrap数组元素只有两个，每一个WindowWrap元素由MetricBucket对象构成，用来统计数据，如：通过次数、阻塞次数、异常次数等~&lt;/p&gt;
&lt;p&gt;调用data的currentWindow方法会调用到LeapArray的currentWindow方法中去：&lt;br/&gt;&lt;strong&gt;LeapArray#currentWindow&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public WindowWrap&amp;lt;T&amp;gt; currentWindow(long timeMillis) {
    if (timeMillis &amp;lt; 0) {
        return null;
    }
    //通过当前时间判断属于哪个窗口
    int idx = calculateTimeIdx(timeMillis);
    //计算出窗口开始时间
    // Calculate current bucket start time.
    long windowStart = calculateWindowStart(timeMillis);

    while (true) {
        //获取数组里的老数据
        WindowWrap&amp;lt;T&amp;gt; old = array.get(idx);
        if (old == null) {
           
            WindowWrap&amp;lt;T&amp;gt; window = new WindowWrap&amp;lt;T&amp;gt;(windowLengthInMs, windowStart, newEmptyBucket(timeMillis));
            if (array.compareAndSet(idx, null, window)) {
                // Successfully updated, return the created bucket.
                return window;
            } else {
                // Contention failed, the thread will yield its time slice to wait for bucket available.
                Thread.yield();
            }
            // 如果对应时间窗口的开始时间与计算得到的开始时间一样
            // 那么代表当前即是我们要找的窗口对象，直接返回
        } else if (windowStart == old.windowStart()) {
             
            return old;
        } else if (windowStart &amp;gt; old.windowStart()) { 
            //如果当前的开始时间小于原开始时间，那么就更新到新的开始时间
            if (updateLock.tryLock()) {
                try {
                    // Successfully get the update lock, now we reset the bucket.
                    return resetWindowTo(old, windowStart);
                } finally {
                    updateLock.unlock();
                }
            } else {
                // Contention failed, the thread will yield its time slice to wait for bucket available.
                Thread.yield();
            }
        } else if (windowStart &amp;lt; old.windowStart()) {
            //一般来说不会走到这里
            // Should not go through here, as the provided time is already behind.
            return new WindowWrap&amp;lt;T&amp;gt;(windowLengthInMs, windowStart, newEmptyBucket(timeMillis));
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我简单介绍一下这个方法，这个方法的详细讲解已经在第一篇源码分析里做了。&lt;/p&gt;
&lt;p&gt;这个方法里面会根据当前的时间戳来计算出array数组里面的index，然后去array数组中找相应的数据，如果节点已经存在，那么用CAS更新一个新的节点；如果节点是新的，那么直接返回；如果节点失效了，设置当前节点，清除所有失效节点。&lt;/p&gt;
&lt;p&gt;这里我直接引用&lt;a href=&quot;https://www.cnblogs.com/luozhiyun/p/11439993.html&quot;&gt;1.Sentinel源码分析—FlowRuleManager加载规则做了什么？&lt;/a&gt;中的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. 如果array数据里面的bucket数据如下所示：
  NULL      B4
|_______|_______|
800     1000    1200   
    ^
   time=888
正好当前时间所对应的槽位里面的数据是空的，那么就用CAS更新

2. 如果array里面已经有数据了，并且槽位里面的窗口开始时间和当前的开始时间相等，那么直接返回
      B3      B4
 ||_______|_______||___
800     1000    1200  timestamp
      ^
    time=888

3. 例如当前时间是1676，所对应窗口里面的数据的窗口开始时间小于当前的窗口开始时间，那么加上锁，然后设置槽位的窗口开始时间为当前窗口开始时间，并把槽位里面的数据重置
   (old)
             B0      
 |_______||_______|
 ...    1200     1400
    ^
  time=1676&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再回到ArrayMetric的success方法中，往下走调用data.values()方法：&lt;br/&gt;&lt;strong&gt;LeapArray#success&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public List&amp;lt;T&amp;gt; values(long timeMillis) {
    if (timeMillis &amp;lt; 0) {
        return new ArrayList&amp;lt;T&amp;gt;();
    }
    int size = array.length();
    List&amp;lt;T&amp;gt; result = new ArrayList&amp;lt;T&amp;gt;(size);

    for (int i = 0; i &amp;lt; size; i++) {
        WindowWrap&amp;lt;T&amp;gt; windowWrap = array.get(i);
        if (windowWrap == null || isWindowDeprecated(timeMillis, windowWrap)) {
            continue;
        }
        result.add(windowWrap.value());
    }
    return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法就是用来获取所有有效的MetricBucket，并返回。&lt;br/&gt;然后通过调用MetricBucket的success方法获取被成功调用的次数。&lt;/p&gt;
&lt;p&gt;我们接着来看ArrayMetric的rt方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public long rt() {
    data.currentWindow();
    long rt = 0;
    //获取当前时间窗口的统计数据
    List&amp;lt;MetricBucket&amp;gt; list = data.values();
    //统计当前时间窗口的平均相应时间之和
    for (MetricBucket window : list) {
        rt += window.rt();
    }
    return rt;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法和上面的success方法差不多，获取所有的MetricBucket的rt数据求和返回。&lt;br/&gt;然后就可以通过rt方法返回的时间总和除以成功调用的总和求得平均数。&lt;/p&gt;
&lt;p&gt;我们再回到DegradeRule的passCheck方法中的响应时间降级策略中：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;if (grade == RuleConstant.DEGRADE_GRADE_RT) {
    //获取节点的平均响应时间
    double rt = clusterNode.avgRt();
    if (rt &amp;lt; this.count) {
        passCount.set(0);
        return true;
    }
    //rtSlowRequestAmount默认是5
    // Sentinel will degrade the service only if count exceeds.
    if (passCount.incrementAndGet() &amp;lt; rtSlowRequestAmount) {
        return true;
    }
    //    根据异常比例降级
}
//省略
return false;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果求得的平均响应时间小于设置的count时间，那么就重置passCount并返回true，表示不抛出异常；如果有连续5次的响应时间都超过了count，那么就返回false抛出异常进行降级。&lt;/p&gt;
&lt;h3 id=&quot;degrade_grade_exception_ratio根据异常比例降级&quot;&gt;DEGRADE_GRADE_EXCEPTION_RATIO根据异常比例降级&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;if (grade == RuleConstant.DEGRADE_GRADE_EXCEPTION_RATIO) {
    //获取每秒异常的次数
    double exception = clusterNode.exceptionQps();
    //获取每秒成功的次数
    double success = clusterNode.successQps();
    //获取每秒总调用次数
    double total = clusterNode.totalQps();
    // If total amount is less than minRequestAmount, the request will pass.
    // 如果总调用次数少于5，那么不进行降级
    if (total &amp;lt; minRequestAmount) {
        return true;
    }

    // In the same aligned statistic time window,
    // &quot;success&quot; (aka. completed count) = exception count + non-exception count (realSuccess)
    double realSuccess = success - exception;
    if (realSuccess &amp;lt;= 0 &amp;amp;&amp;amp; exception &amp;lt; minRequestAmount) {
        return true;
    }

    if (exception / success &amp;lt; count) {
        return true;
    } 
}
。。。
return false;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法中获取成功调用的Qps和异常调用的Qps，验证后，然后求一下比率，如果没有大于count，那么就返回true，否则返回false抛出异常。&lt;/p&gt;
&lt;p&gt;我们再进入到exceptionQps方法中看一下：&lt;br/&gt;&lt;strong&gt;StatisticNode#exceptionQps&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public double exceptionQps() {
    return rollingCounterInSecond.exception() / rollingCounterInSecond.getWindowIntervalInSec();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;rollingCounterInSecond.getWindowIntervalInSec方法是表示窗口的时间长度，用秒来表示。这里返回的是1。&lt;br/&gt;&lt;strong&gt;ArrayMetric#exception&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public long exception() {
    data.currentWindow();
    long exception = 0;
    List&amp;lt;MetricBucket&amp;gt; list = data.values();
    for (MetricBucket window : list) {
        exception += window.exception();
    }
    return exception;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法和我上面分析的差不多，大家看看就好了。&lt;/p&gt;
&lt;h3 id=&quot;根据异常数降级degrade_grade_exception_count&quot;&gt;根据异常数降级DEGRADE_GRADE_EXCEPTION_COUNT&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;if (grade == RuleConstant.DEGRADE_GRADE_EXCEPTION_COUNT) {
    double exception = clusterNode.totalException();
    if (exception &amp;lt; count) {
        return true;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据异常数降级是非常的直接的，直接根据统计的异常总次数判断是否超过count。&lt;/p&gt;
&lt;p&gt;到这里就讲完了降级的实现咯~~&lt;/p&gt;
</description>
<pubDate>Fri, 13 Sep 2019 15:02:00 +0000</pubDate>
<dc:creator>luozhiyun</dc:creator>
<og:description>各位中秋节快乐啊，我觉得在这个月圆之夜有必要写一篇源码解析，以表示我内心的高兴~ Sentinel源码解析系列： '1.Sentinel源码分析—FlowRuleManager加载规则做了什么？' '</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/luozhiyun/p/11517918.html</dc:identifier>
</item>
<item>
<title>搭建自己的技术博客系列（二）把 Hexo 博客部署到 GitHub 上 - 黄小斜</title>
<link>http://www.cnblogs.com/xll1025/p/11517887.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xll1025/p/11517887.html</guid>
<description>&lt;h2 id=&quot;在github上建一个新仓库&quot;&gt;1、在GitHub上建一个新仓库&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1092007/201909/1092007-20190913224940923-229831427.png&quot;/&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; title=&quot;点击并拖拽以移动&quot;/&gt;​&lt;/p&gt;
&lt;h2 id=&quot;配置git的ssh-key&quot;&gt;2、配置Git的SSH KEY&lt;/h2&gt;
&lt;p&gt;生成SSH添加到GitHub&lt;br/&gt;回到你的git bash中，&lt;/p&gt;
&lt;p&gt;git config --global user.name &quot;yourname&quot;&lt;br/&gt;git config --global user.email &quot;youremail&quot;&lt;/p&gt;
&lt;p&gt;这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。&lt;/p&gt;
&lt;p&gt;可以用以下两条，检查一下你有没有输对&lt;/p&gt;
&lt;p&gt;git config user.name&lt;br/&gt;git config user.email&lt;/p&gt;
&lt;p&gt;然后创建SSH,一路回车&lt;/p&gt;
&lt;p&gt;ssh-keygen -t rsa -C &quot;youremail&quot;&lt;/p&gt;
&lt;p&gt;这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。&lt;/p&gt;
&lt;p&gt;ssh，简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。&lt;/p&gt;
&lt;p&gt;而后在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key&lt;br/&gt;把你的id_rsa.pub里面的信息复制进去。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1092007/201909/1092007-20190913224941615-76667433.png&quot;/&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; title=&quot;点击并拖拽以移动&quot;/&gt;​&lt;/p&gt;
&lt;h2 id=&quot;更改-hexo-配置文件_config.yml&quot;&gt;3、更改 Hexo 配置文件_config.yml&lt;/h2&gt;
&lt;p&gt;这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 _config.yml，翻到最后，修改为&lt;br/&gt;YourgithubName就是你的GitHub账户&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1092007/201909/1092007-20190913224942930-1017631356.png&quot;/&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; title=&quot;点击并拖拽以移动&quot;/&gt;​&lt;/p&gt;
&lt;p&gt;deploy:&lt;br/&gt;  type: git&lt;br/&gt;  repo: &lt;a href=&quot;https://github.com/YourgithubName/YourgithubName.github.io.git&quot; class=&quot;uri&quot;&gt;https://github.com/YourgithubName/YourgithubName.github.io.git&lt;/a&gt;&lt;br/&gt;  branch: master&lt;/p&gt;
&lt;p&gt;这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。&lt;/p&gt;
&lt;p&gt;npm install hexo-deployer-git --save&lt;br/&gt;然后&lt;/p&gt;
&lt;p&gt;hexo clean&lt;br/&gt;hexo generate&lt;br/&gt;hexo deploy&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1092007/201909/1092007-20190913224943973-2010931492.png&quot;/&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; title=&quot;点击并拖拽以移动&quot;/&gt;​&lt;img src=&quot;https://img2018.cnblogs.com/blog/1092007/201909/1092007-20190913224944271-95303355.png&quot;/&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; title=&quot;点击并拖拽以移动&quot;/&gt;​&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1092007/201909/1092007-20190913224944855-1664085111.png&quot;/&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; title=&quot;点击并拖拽以移动&quot;/&gt;​&lt;/p&gt;
&lt;p&gt;这样就可以成功地把hexo博客部署到Github上了。&lt;/p&gt;
&lt;p&gt;打开&lt;a href=&quot;https://h2pl.github.io/&quot; class=&quot;uri&quot;&gt;https://h2pl.github.io/&lt;/a&gt;就可以看到效果啦。&lt;/p&gt;
</description>
<pubDate>Fri, 13 Sep 2019 14:50:00 +0000</pubDate>
<dc:creator>黄小斜</dc:creator>
<og:description>1、在GitHub上建一个新仓库 ​ 2、配置Git的SSH KEY 生成SSH添加到GitHub 回到你的git bash中， git config global user.name 'yourna</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xll1025/p/11517887.html</dc:identifier>
</item>
<item>
<title>实时统计每天pv,uv的sparkStreaming结合redis结果存入mysql供前端展示 - 柯广的博客</title>
<link>http://www.cnblogs.com/data-magnifier/p/11516156.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/data-magnifier/p/11516156.html</guid>
<description>&lt;p&gt;最近有个需求，实时统计pv,uv，结果按照date,hour,pv,uv来展示，按天统计，第二天重新统计，当然了实际还需要按照类型字段分类统计pv,uv,比如按照date,hour,pv,uv,type来展示。这里介绍最基本的pv,uv的展示。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;155599&lt;/td&gt;
&lt;td&gt;306053&lt;/td&gt;
&lt;td&gt;2018-07-27&lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;关于什么是pv,uv，可以参见这篇博客:&lt;a href=&quot;https://blog.csdn.net/petermsh/article/details/78652246&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/petermsh/article/details/78652246&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180728105552761?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RkeHlncQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;基本流程&quot;/&gt;&lt;br/&gt;日志数据从flume采集过来，落到hdfs供其它离线业务使用，也会sink到kafka，sparkStreaming从kafka拉数据过来，计算pv,uv，uv是用的redis的set集合去重，最后把结果写入mysql数据库，供前端展示使用。&lt;/p&gt;

&lt;h4 id=&quot;pv的计算&quot;&gt;1）pv的计算&lt;/h4&gt;
&lt;p&gt;拉取数据有两种方式，基于received和direct方式，这里用direct直拉的方式，用的mapWithState算子保存状态，这个算子与updateStateByKey一样，并且性能更好。当然了实际中数据过来需要经过清洗，过滤，才能使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义一个状态函数&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 实时流量状态更新函数
  val mapFunction = (datehour:String, pv:Option[Long], state:State[Long]) =&amp;gt; {
    val accuSum = pv.getOrElse(0L) + state.getOption().getOrElse(0L)
    val output = (datehour,accuSum)
    state.update(accuSum)
    output
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; 计算pv
 val stateSpec = StateSpec.function(mapFunction)
 val helper_count_all = helper_data.map(x =&amp;gt; (x._1,1L)).mapWithState(stateSpec).stateSnapshots().repartition(2)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就很容易的把pv计算出来了。&lt;/p&gt;
&lt;h4 id=&quot;uv的计算&quot;&gt;2）uv的计算&lt;/h4&gt;
&lt;p&gt;uv是要全天去重的，每次进来一个batch的数据，如果用原生的reduceByKey或者groupByKey对配置要求太高，在配置较低情况下，我们申请了一个93G的redis用来去重，原理是每进来一条数据，将date作为key，guid加入set集合，20秒刷新一次，也就是将set集合的尺寸取出来，更新一下数据库即可。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;helper_data.foreachRDD(rdd =&amp;gt; {
        rdd.foreachPartition(eachPartition =&amp;gt; {
        // 获取redis连接
          val jedis = getJedis
          eachPartition.foreach(x =&amp;gt; {
            val date:String = x._1.split(&quot;:&quot;)(0)
            val key = date
            // 将date作为key，guid(x._2)加入set集合
            jedis.sadd(key,x._2)
            // 设置存储每天的数据的set过期时间，防止超过redis容量，这样每天的set集合，定期会被自动删除
            jedis.expire(key,ConfigFactory.rediskeyexists)
          })
          // 关闭连接
          closeJedis(jedis)
        })
      })&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;结果保存到数据库&quot;&gt;3）结果保存到数据库&lt;/h4&gt;
&lt;p&gt;结果保存到mysql，数据库，20秒刷新一次数据库，前端展示刷新一次，就会重新查询一次数据库，做到实时统计展示pv,uv的目的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
    * 插入数据
    * @param data (addTab(datehour)+helperversion)
    * @param tbName
    * @param colNames
    */
  def insertHelper(data: DStream[(String, Long)], tbName: String, colNames: String*): Unit = {
    data.foreachRDD(rdd =&amp;gt; {
      val tmp_rdd = rdd.map(x =&amp;gt; x._1.substring(11, 13).toInt)
      if (!rdd.isEmpty()) {
        val hour_now = tmp_rdd.max() // 获取当前结果中最大的时间，在数据恢复中可以起作用
        rdd.foreachPartition(eachPartition =&amp;gt; {
          try {
            val jedis = getJedis
            val conn = MysqlPoolUtil.getConnection()
            conn.setAutoCommit(false)
            val stmt = conn.createStatement()
            eachPartition.foreach(x =&amp;gt; {
              val datehour = x._1.split(&quot;\t&quot;)(0)
              val helperversion = x._1.split(&quot;\t&quot;)(1)
              val date_hour = datehour.split(&quot;:&quot;)
              val date = date_hour(0)
              val hour = date_hour(1).toInt

              val colName0 = colNames(0) // date
              val colName1 = colNames(1) // hour
              val colName2 = colNames(2) // count_all
              val colName3 = colNames(3) // count
              val colName4 = colNames(4) // helperversion
              val colName5 = colNames(5) // datehour
              val colName6 = colNames(6) // dh

              val colValue0 = addYin(date)
              val colValue1 = hour
              val colValue2 = x._2.toInt
              val colValue3 = jedis.scard(date + &quot;_&quot; + helperversion) // // 2018-07-08_10.0.1.22
              val colValue4 = addYin(helperversion)
              var colValue5 = if (hour &amp;lt; 10) &quot;'&quot; + date + &quot; 0&quot; + hour + &quot;:00 &quot; + helperversion + &quot;'&quot; else &quot;'&quot; + date + &quot; &quot; + hour + &quot;:00 &quot; + helperversion + &quot;'&quot;
              val colValue6 = if(hour &amp;lt; 10) &quot;'&quot; + date + &quot; 0&quot; + hour + &quot;:00'&quot; else &quot;'&quot; + date + &quot; &quot; + hour + &quot;:00'&quot;

              var sql = &quot;&quot;
              if (hour == hour_now) { // uv只对现在更新
                sql = s&quot;insert into ${tbName}(${colName0},${colName1},${colName2},${colName3},${colName4},${colName5}) values(${colValue0},${colValue1},${colValue2},${colValue3},${colValue4},${colValue5}) on duplicate key update ${colName2} =  ${colValue2},${colName3} = ${colValue3}&quot;
              } else {
                sql = s&quot;insert into ${tbName}(${colName0},${colName1},${colName2},${colName4},${colName5}) values(${colValue0},${colValue1},${colValue2},${colValue4},${colValue5}) on duplicate key update ${colName2} =  ${colValue2}&quot;
              }
              stmt.addBatch(sql)
            })
            closeJedis(jedis)
            stmt.executeBatch() // 批量执行sql语句
            conn.commit()
            conn.close()
          } catch {
            case e: Exception =&amp;gt; {
              logger.error(e)
              logger2.error(HelperHandle.getClass.getSimpleName + e)
            }
          }
        })
      }
    })
  }
  
// 计算当前时间距离次日零点的时长（毫秒）
def resetTime = {
    val now = new Date()
    val todayEnd = Calendar.getInstance
    todayEnd.set(Calendar.HOUR_OF_DAY, 23) // Calendar.HOUR 12小时制
    todayEnd.set(Calendar.MINUTE, 59)
    todayEnd.set(Calendar.SECOND, 59)
    todayEnd.set(Calendar.MILLISECOND, 999)
    todayEnd.getTimeInMillis - now.getTime
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;数据容错&quot;&gt;4）数据容错&lt;/h4&gt;
&lt;p&gt;流处理消费kafka都会考虑到数据丢失问题，一般可以保存到任何存储系统，包括mysql,hdfs,hbase,redis,zookeeper等到。这里用SparkStreaming自带的checkpoint机制来实现应用重启时数据恢复。&lt;/p&gt;
&lt;h5 id=&quot;checkpoint&quot;&gt;checkpoint&lt;/h5&gt;
&lt;p&gt;这里采用的是checkpoint机制，在重启或者失败后重启可以直接读取上次没有完成的任务，从kafka对应offset读取数据。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 初始化配置文件
ConfigFactory.initConfig()

val conf = new SparkConf().setAppName(ConfigFactory.sparkstreamname)
conf.set(&quot;spark.streaming.stopGracefullyOnShutdown&quot;,&quot;true&quot;)
conf.set(&quot;spark.streaming.kafka.maxRatePerPartition&quot;,consumeRate)
conf.set(&quot;spark.default.parallelism&quot;,&quot;24&quot;)
val sc = new SparkContext(conf)

while (true){
    val ssc = StreamingContext.getOrCreate(ConfigFactory.checkpointdir + DateUtil.getDay(0),getStreamingContext _ )
    ssc.start()
    ssc.awaitTerminationOrTimeout(resetTime)
    ssc.stop(false,true)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;checkpoint是每天一个目录，在第二天凌晨定时销毁StreamingContext对象，重新统计计算pv,uv。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;h3 id=&quot;注意&quot;&gt;注意&lt;/h3&gt;
&lt;p&gt;ssc.stop(false,true)表示优雅地销毁StreamingContext对象，不能销毁SparkContext对象，ssc.stop(true,true)会停掉SparkContext对象，程序就直接停了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;应用迁移或者程序升级&quot;&gt;应用迁移或者程序升级&lt;/h5&gt;
&lt;p&gt;在这个过程中，我们把应用升级了一下，比如说某个功能写的不够完善，或者有逻辑错误，这时候都是需要修改代码，重新打jar包的，这时候如果把程序停了，新的应用还是会读取老的checkpoint，可能会有两个问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;执行的还是上一次的程序，因为checkpoint里面也有序列化的代码；&lt;/li&gt;
&lt;li&gt;直接执行失败，反序列化失败；&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;其实有时候，修改代码后不用删除checkpoint也是可以直接生效，经过很多测试，我发现如果对数据的过滤操作导致数据过滤逻辑改变，还有状态操作保存修改，也会导致重启失败，只有删除checkpoint才行，可是实际中一旦删除checkpoint，就会导致上一次未完成的任务和消费kafka的offset丢失，直接导致数据丢失，这种情况下我一般这么做。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;这种情况一般是在另外一个集群，或者把checkpoint目录修改下，我们是代码与配置文件分离，所以修改配置文件checkpoint的位置还是很方便的。然后两个程序一起跑，除了checkpoint目录不一样，会重新建，都插入同一个数据库，跑一段时间后，把旧的程序停掉就好。以前看官网这么说，只能记住不能清楚明了，只有自己做时才会想一下办法去保证数据准确。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;日志&quot;&gt;5）日志&lt;/h4&gt;
&lt;p&gt;日志用的log4j2，本地保存一份，ERROR级别的日志会通过邮件发送到手机。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;val logger = LogManager.getLogger(HelperHandle.getClass.getSimpleName)
  // 邮件level=error日志
  val logger2 = LogManager.getLogger(&quot;email&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;分享一个大神的人工智能教程。零基础！通俗易懂！风趣幽默！还带黄段子！希望你也加入到人工智能的队伍中来！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.captainbed.net/blog-ikeguang&quot;&gt;点击浏览教程&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我的微信公众号，专注于大数据分析与挖掘，感兴趣可以关注，看一看，瞧一瞧！&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1165270/201909/1165270-20190913224052237-831556719.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 13 Sep 2019 14:43:00 +0000</pubDate>
<dc:creator>柯广的博客</dc:creator>
<og:description>SparkStreaming实时消费kafka数据，结合redis实时统计pv,uv，结果保存到mysql。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/data-magnifier/p/11516156.html</dc:identifier>
</item>
<item>
<title>Python学习之旅：用Python制作一个打字训练小工具 - TM0831</title>
<link>http://www.cnblogs.com/TM0831/p/11481198.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/TM0831/p/11481198.html</guid>
<description>&lt;h2&gt;一、写在前面&lt;/h2&gt;
&lt;p&gt;　　说道程序员，你会想到什么呢？有人认为程序员象征着高薪，有人认为程序员都是死肥宅，还有人想到的则是996和 ICU。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450803/201909/1450803-20190907155424221-1187067668.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　别人眼中的程序员：飞快的敲击键盘、酷炫的切换屏幕、各种看不懂的字符代码。&lt;/p&gt;
&lt;p&gt;　　然而现实中的程序员呢？对于很多程序员来说，没有百度和 Google 解决不了的问题，也没有 ctrl + c 和 ctrl + v 实现不了的功能。&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450803/201909/1450803-20190907161418149-613612544.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　那么身为一个程序员，要怎么让自己看起来更加“专业”呢？答案就是加快自己的打字速度了，敲的代码可能是错的，但这个13却是必须装的！&lt;/p&gt;
&lt;p&gt;　　然而还是有不少人打字不那么快的，可能就需要训练下了，但是既然身为程序员，为何不自己写一个训练打字的小工具出来呢？&lt;/p&gt;

&lt;h2&gt;二、基本思路&lt;/h2&gt;
&lt;p&gt;　　使用 PyQT5 开发 GUI，实现显示句子并让用户输入，然后将输入的内容和给出的句子进行比对，同时记录所用的时间，最后将正确率输出来。为了能够持续打字输入，还需要做一个“下一句”的功能。在实现了这两个基本的功能后，一个简单的打字训练小工具就做出来了。&lt;/p&gt;

&lt;h2&gt;三、界面设计&lt;/h2&gt;
&lt;h3&gt;1.环境配置&lt;/h3&gt;
&lt;p&gt;　　PyQT5 的开发环境配置在上一篇博客中已经说过了，因而这里不再赘述，如果不清楚的可以点&lt;a href=&quot;https://www.cnblogs.com/TM0831/p/11488892.html&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;查看。&lt;/p&gt;
&lt;h3&gt;2.界面设计&lt;/h3&gt;
&lt;p&gt; 　　要进行界面设计，得先打开 QtDesigner，然后新建项目，选择 Widget：&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450803/201909/1450803-20190913205351477-892308497.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　然后就往里面拖控件就好了，这还是很方便的，主要用的控件包括 Label、Text Edit、Push Button等，双击控件之后可以在右侧修改控件的各种属性。最终设计出的界面如下：&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450803/201909/1450803-20190913210109566-1032016196.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.生成 Python 代码&lt;/h3&gt;
&lt;p&gt;　　在设计完界面之后，将生成的结果保存下来，会得到一个 .ui 为后缀的文件。这个文件我们还是无法直接使用的，需要转变成 Python 代码才行。此时就需要使用 pyuic5 命令了，不懂的可以点&lt;a href=&quot;https://www.cnblogs.com/TM0831/p/11488892.html&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;查看我的上篇博客。&lt;/p&gt;

&lt;h2&gt;四、槽函数&lt;/h2&gt;
&lt;h3&gt; 1.槽函数简介&lt;/h3&gt;
&lt;p&gt;　　要进行功能设计，就得先知道槽函数。槽是普通的 C++ 成员函数，槽在 Qt 开发软件中是一个很重要的概念，在 Qt 里与信号连接的就是槽，我们一般称之为槽函数。&lt;/p&gt;
&lt;p&gt;　　在使用信号的时候，有四个参数：&lt;/p&gt;
&lt;p&gt;　　1）sender：发出信号的对象；&lt;/p&gt;
&lt;p&gt;　　2）signal：发送对象发出的信号；&lt;/p&gt;
&lt;p&gt;　　3）receiver：接收信号的对象；&lt;/p&gt;
&lt;p&gt;　　4）slot：接收对象在接收到信号之后所需要调用的函数（槽函数）。&lt;/p&gt;
&lt;h3&gt;2.使用方法&lt;/h3&gt;
&lt;h4&gt;（1）第一种方法&lt;/h4&gt;
&lt;p&gt;　　第一步，在 QtDesigner 中点击 “Edit Signals/Slots”，然后左键点击按钮后将鼠标拖到另一个 Label 上：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450803/201909/1450803-20190913212639252-787289808.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　第二步，在弹出的设置框中选择具体的方法及功能。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450803/201909/1450803-20190913212947778-1125763596.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　这样做很简单，但是也有缺陷，问题在于不能自定义方法，只能使用给定的方法。&lt;/p&gt;
&lt;h4&gt;（2）第二种方法&lt;/h4&gt;
&lt;p&gt;　　在右下角找到 “Signal/Slot Editor” 并点击，然后就可以点击 “+” 创建信号了。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450803/201909/1450803-20190913213438425-248025814.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　这种方法能够让我们自定义了，但是也不算方便，尤其是当你不知道具体要实现什么方法的时候。&lt;/p&gt;
&lt;h4&gt;（3）第三种方法&lt;/h4&gt;
&lt;p&gt;　　使用 connect() 方法，传入的参数为一个方法名称。例如：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;pre&gt;
btn.clicked.connect(func)
&lt;/pre&gt;&lt;/blockquote&gt;

&lt;h2&gt;五、功能实现&lt;/h2&gt;
&lt;h3&gt;1.继承函数&lt;/h3&gt;
&lt;p&gt;　　使用 pyuic5 生成 py 文件中定义了一个 Ui_Form 类，其中包含了对各种控件的定义等，如果我们要增加其他功能，且直接在这个 py 文件中修改的话，那么之后要更新界面之类的就不会不方便了，所以最好的方法是继承 Ui_Form 类，然后在继承类中添加修改。参考代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; PyQt5 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; QtWidgets
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; typing.ui &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Ui_Form
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyForm(Ui_Form, QtWidgets.QWidget):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         super(MyForm, self).&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        self.setupUi(self)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     app =&lt;span&gt; QtWidgets.QApplication(sys.argv)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     my_form =&lt;span&gt; MyForm()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    my_form.show()
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     sys.exit(app.exec_())
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.隐藏显示控件&lt;/h3&gt;
&lt;p&gt;　　有时候我们可能会需要将某些控件隐藏起来，这里简单介绍几种方法。&lt;/p&gt;
&lt;p&gt;　　1）setHidden(bool)    设置控件是否隐藏；&lt;/p&gt;
&lt;p&gt;　　2）hide() 隐藏控件；&lt;/p&gt;
&lt;p&gt;　　这两种隐藏的方法会完全隐藏控件，即不保留控件所占的位置。但如果要保留位置的话，可以使用下面这种方法：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;pre&gt;
# 将透明度设置为0，达到隐藏且保留位置的目的&lt;br/&gt;op = QtWidgets.QGraphicsOpacityEffect()&lt;br/&gt;op.setOpacity(0)&lt;br/&gt;self.lable.setGraphicsEffect(op)
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h3&gt;3.判断输入内容 &lt;/h3&gt;
&lt;p&gt;　　这一功能的实现需要在点击“提交”按钮时获取输入框中的内容，再和给出的文本进行对比，最后将结果返回显示出来。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; click(self):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    点击按钮时调用
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    :return: 
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    self.get_time()
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     the_input =&lt;span&gt; self.textEdit.toPlainText()
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算准确率&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     count =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(the_input)):
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; the_input[i] ==&lt;span&gt; self.text[i]:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             count += 1
&lt;span&gt;13&lt;/span&gt;     accuracy = count / len(self.text) * 100
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(accuracy)&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    self.show_label()
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置提示信息&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     info = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;有点可惜，你的正确率是:  %.2f%%  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % accuracy &lt;span&gt;if&lt;/span&gt; accuracy != 100 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;恭喜你全对了呢！继续加油哦！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     self.info_lable.setText(info)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　对于我这种懒人来说，点击按钮这种操作都是费力的，所以最好加入一个快捷键，这样就方便多了，可以使用如下方法设置：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;pre&gt;
# 设置快捷键&lt;br/&gt;self.submit_btn.setShortcut('ctrl+e')
&lt;/pre&gt;&lt;/blockquote&gt;

&lt;h2&gt;六、运行结果&lt;/h2&gt;
&lt;p&gt;　　最终运行结果的截图如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450803/201909/1450803-20190913220218940-1269687937.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提交之后还可以点击下一句继续训练：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450803/201909/1450803-20190913220256308-2134978844.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;完整代码已上传到 &lt;a href=&quot;https://github.com/TM0831/PythonCode/tree/master/typing&quot; target=&quot;_blank&quot;&gt;GitHub&lt;/a&gt;！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 13 Sep 2019 14:24:00 +0000</pubDate>
<dc:creator>TM0831</dc:creator>
<og:description>一、写在前面 说道程序员，你会想到什么呢？有人认为程序员象征着高薪，有人认为程序员都是死肥宅，还有人想到的则是996和 ICU。 别人眼中的程序员：飞快的敲击键盘、酷炫的切换屏幕、各种看不懂的字符代码</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/TM0831/p/11481198.html</dc:identifier>
</item>
<item>
<title>kubernetes ConfigMap和Secret：配置应用程序 - 姚红</title>
<link>http://www.cnblogs.com/yaohong/p/11505670.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yaohong/p/11505670.html</guid>
<description>&lt;h2&gt;7.1.配置容器化应用程序&lt;/h2&gt;
&lt;h3&gt;7.2.向容器传递命令行参数&lt;/h3&gt;
&lt;h3&gt;7.2.1.待Docker中定义命令与参数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.了解ENTRYPOINT与CMD&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　ENTRYPOINT定义容器启动时被调用的可以执行程序&lt;/p&gt;
&lt;p&gt;　　CMD指定传递给ENTRYP的参数&lt;/p&gt;
&lt;p&gt;dockerfile 内容如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
FROM daocloud.io/centos:latest

ADD aaa /usr/local/aaa

CMD [&quot;-f&quot;,&quot;/var/log/aa.log&quot;]
ENTRYPOINT [&quot;tail&quot;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当启动镜像时，容器启动时执行如下命令：tail -f /var/log/aa.log&lt;/p&gt;
&lt;p&gt;或者在docker run &amp;lt;images&amp;gt; &amp;lt;arguments&amp;gt; 中指定，arguments会覆盖CMD中内容&lt;/p&gt;
&lt;h3&gt;7.2.2.在kubernetes中覆盖命令行和参数&lt;/h3&gt;
&lt;p&gt; 在k8s中定义容器时，镜像的ENTRYPOINT和CMD都可以被覆盖，仅需在容器定义中设置熟悉command和args的值&lt;/p&gt;
&lt;p&gt;对应参数如下：&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;Docker&lt;/td&gt;
&lt;td&gt;kubernetes&lt;/td&gt;
&lt;td&gt;描述&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ENTRYPOINT&lt;/td&gt;
&lt;td&gt;command&lt;/td&gt;
&lt;td&gt;容器中运行的可执行文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;CMD&lt;/td&gt;
&lt;td&gt;args&lt;/td&gt;
&lt;td&gt;传给可执行文件的参数&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;



&lt;p&gt;相关yml代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
kind: pod
spec:
  containers:
  - image: some/image
    command: [&quot;/bin/command&quot;]
    args: [&quot;args1&quot;,&quot;args2&quot;,&quot;args3&quot;]
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;7.3.为容器设置环境变量&lt;/h2&gt;
&lt;h3&gt;7.3.1.在容器定义中指定环境变量&lt;/h3&gt;
&lt;p&gt;与容器的命令和参数设置相同，环境变量列表无法在pod创建后被修改。&lt;/p&gt;
&lt;p&gt;在pod的yml文件中设置容器环境变量代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
kind: pod
spec:
  containers:
  - image: luksa/fortune:env
    env:
    - name: INTERVAL
      value: &quot;30&quot;
    name: value-test-yh
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;7.3.2.在环境变量值中引用其他环境变量&lt;/h3&gt;
&lt;p&gt;使用$( VAR )引用环境变量，&lt;/p&gt;
&lt;p&gt;相关ym代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
env:
- name: FIRST_VAR
  value: &quot;foo&quot;
- name: SECOND_VAR
  value: &quot;$(FIRST_VAR)bar&quot;   //最终变量值为foobar
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;7.4.利用ConfigMap解耦配置&lt;/h2&gt;
&lt;h3&gt;7.4.1.ConfigMap介绍&lt;/h3&gt;
&lt;p&gt;kubernetes允许将配置选项分离到独立的资源对象ConfigMap中，本质上就是一个键/值对映射，值可以是短字面变量，也可以是完整的配置文件。&lt;/p&gt;
&lt;p&gt;应用无须直接读取ConfigMap，甚至根本不需要知道其是否存在。&lt;/p&gt;
&lt;p&gt;映射的内容通过环境变量或者卷文件的形式传递给容器，而并非直接传递给容器，命令行参数的定义中也是通过$(ENV_VAR)语法变量&lt;/p&gt;
&lt;h3&gt;7.4.2.创建ConfigMap&lt;/h3&gt;
&lt;p&gt;使用kubectl creat configmap创建ConfigMap中间不用加-f。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.使用指令创建ConfigMap&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
#kubectl creat configmap configmap-yaohong --from-literal=foo=bar --from-literal=sleep-interval=25
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.从文件内容创建ConfigMap条目&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
#kubectl create configmap my-conf-yh --from-file=config-file.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用如下命令，会将文件内容存储在自定义的条目下。与字面量使用相同&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
#kubectl create configmap my-conf-yh --from-file=customkey=config-file.conf 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3.从文件夹创建ConfigMap&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
#kubectl create configmap my-conf-yh --from-file=/path/to/dir
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4.合并不同选项&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
#kubectl create configmap my-conf-yh 
  --from-file=/path/to/dir/
  --from-file=bar=foobar.conf
  --from-literal=some=thing
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;5.获取ConfigMap&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
#kubectl -n &amp;lt;namespace&amp;gt; get configmap
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;7.4.3.给容器传递ConfigMap条目作为环境变量&lt;/h3&gt;
&lt;p&gt;引用环境变量中的参数值给当前变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
apiVersion: v1
kind: pod
metadata:
  name: fortune-env-from-configmap
spec:
  containers:
  - image: luksa/fortune:env
    env:
    - name: INTERVAL                  //设置环境变量
      valueFrom:
        configMapkeyRef:
          name: fortune-configmap     
          key: sleep-interval         //变量的值取自fortune-configmap的slee-interval对应的值
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;7.4.4.一次性传递ConfigMap的所有条目作为环境变量&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
apiVersion: v1
kind: pod
metadata:
  name: fortune-env-from-configmap
spec:
  containers:
  - image: luksa/fortune:env
    envFrom:
    - prefix: CONFIG_
      confgMapRef:
        name: my-confg-map    //引用my-config-map的ConfigMap并在变量前面都加上CONFIG_
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;7.4.5.使用ConfigMap卷将条目暴露为文件&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
apiVersion: v1
kind: pod
metadata:
  name: configmap-volume-yh
spec:
  containers:
  - image: nginx:aplin
    name: web-server
    volumeMounts:
    ...
    - name: config&lt;br/&gt;defaultMode: &quot;6600&quot;     //设置文件的权限为rw-rw
      mountPath: /etc/nginx/con.conf&lt;br/&gt;subPath: my.conf        //subPath字段可以用于挂载卷中某个独立的文件或者文件夹，而且不覆盖该卷下其他文件
    ...
  volume:
  ...
  - name: config
    configMap:
      name: fortune-config     //引用fortune-config configMap的卷，然后挂载在/etc/nginx/conf.d
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以使用如下命令查看到/etc/nginx/conf.d文件下面包含fortune-config&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
#kubectl exec config-volume-yh -c web-server ls /etc/nginx/conf.d
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;7.5.使用Secert给容器传递敏感数据&lt;/h2&gt;
&lt;h3&gt;7.5.1.介绍Secert&lt;/h3&gt;
&lt;p&gt;Secret结构和ConfigMap类似，均是键/值对的映射。&lt;/p&gt;
&lt;p&gt;使用方法也和ConfigMap一样，可以：&lt;/p&gt;
&lt;p&gt;　　1.将Secret条目作为环境变量传递给容器，&lt;/p&gt;
&lt;p&gt;　　2.将Secret条目暴露为卷中文件&lt;/p&gt;
&lt;p&gt; ConfigMap存储非敏感的文本配置数据，采用Secret存储天生敏感的数据&lt;/p&gt;
&lt;h3&gt;7.5.2.默认令牌Secret&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.查看secret&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
# kubectl get secrets 
NAME                  TYPE                                  DATA   AGE
default-token-x9cjb   kubernetes.io/service-account-token   3      78d
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.描述secret&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
# kubectl describe secrets default-token-x9cjb 
Name:         default-token-x9cjb
Namespace:    default
Labels:       &amp;lt;none&amp;gt;
Annotations:  kubernetes.io/service-account.name: default
              kubernetes.io/service-account.uid: 64a41a09-98ce-11e9-9fa5-fa163e6fdb6b

Type:  kubernetes.io/service-account-token

Data
====
token:      eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5lduaW8vc2VydmljZTxCv6HdtP-ZW3ZC2IKKR5YBhaokFIl35mix79pU4Ia2pJ_fuPTBGNyrCHyNQYH4ex5DhND3_b2puQmn8RSErQ
ca.crt:     1298 bytes
namespace:  7 bytes
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;7.5.3.创建Secret&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.创建一个名为https-yh的generic secret&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
#kubectl create secret generic https-yh --from-file=https.key  --from-file=https.cert  --from-file=foo
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;61&quot;&gt; &lt;/p&gt;
&lt;p data-source-line=&quot;61&quot;&gt;&lt;strong&gt;2.创建一个secret.yaml文件，内容用base64编码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ echo -n 'admin' | base64
YWRtaW4=
$ echo -n '1f2d1e2e67df' | base64
MWYyZDFlMmU2N2Rm
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;70&quot;&gt;yaml文件内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  username: YWRtaW4=
  password: MWYyZDFlMmU2N2Rm
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p data-source-line=&quot;83&quot;&gt;创建：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ kubectl create -f ./secret.yaml
secret &quot;mysecret&quot; created
&lt;/pre&gt;&lt;/div&gt;

&lt;p id=&quot;解析secret中内容&quot; data-source-line=&quot;90&quot;&gt;&lt;strong&gt;解析Secret中内容&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
$ kubectl get secret mysecret -o yaml
apiVersion: v1
data:
  username: YWRtaW4=
  password: MWYyZDFlMmU2N2Rm
kind: Secret
metadata:
  creationTimestamp: 2016-01-22T18:41:56Z
  name: mysecret
  namespace: default
  resourceVersion: &quot;164619&quot;
  selfLink: /api/v1/namespaces/default/secrets/mysecret
  uid: cfee02d6-c137-11e5-8d73-42010af00002
type: Opaque
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p data-source-line=&quot;109&quot;&gt;base64解码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ echo 'MWYyZDFlMmU2N2Rm' | base64 --decode
1f2d1e2e67df
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;7.5.4.对比ConfigMap与Secret&lt;/h3&gt;
&lt;p&gt;Secret的条目内容会进行Base64格式编码，而ConfigMap直接以纯文本展示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.为二进制数据创建Secret&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Base64可以将二进制数据转换为纯文本，并以YAML或Json格式进行展示&lt;/p&gt;
&lt;p&gt;　　但要注意Secret的大小限制是1MB&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.stringDate字段介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Secret可以通过StringDate字段设置条目的纯文本&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
kind: Secret
apiVersion: v1
stringDate:
  foo: plain txt
date:
  https.cert: HGIOPUPSDF63456BJ3BBJL34563456BLKJBK634563456BLBKJBLKJ63456BLK3456LK
  http.key: OHOPGPIU42342345OIVBGOI3456345OVB6O3456BIPO435B6IPU345UI
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;7.5.5.在pod中使用Secret&lt;/h3&gt;
&lt;p data-source-line=&quot;118&quot;&gt;secret可以作为数据卷挂载或者作为环境变量暴露给Pod中的容器使用，也可以被系统中的其他资源使用。比如可以用secret导入与外部系统交互需要的证书文件等。&lt;/p&gt;
&lt;p data-source-line=&quot;120&quot;&gt;在Pod中以文件的形式使用secret&lt;/p&gt;
&lt;ol data-source-line=&quot;122&quot;&gt;&lt;li&gt;创建一个Secret，多个Pod可以引用同一个Secret&lt;/li&gt;
&lt;li&gt;修改Pod的定义，在&lt;code&gt;spec.volumes[]&lt;/code&gt;加一个volume，给这个volume起个名字，&lt;code&gt;spec.volumes[].secret.secretName&lt;/code&gt;记录的是要引用的Secret名字&lt;/li&gt;
&lt;li&gt;在每个需要使用Secret的容器中添加一项&lt;code&gt;spec.containers[].volumeMounts[]&lt;/code&gt;，指定&lt;code&gt;spec.containers[].volumeMounts[].readOnly = true&lt;/code&gt;，&lt;code&gt;spec.containers[].volumeMounts[].mountPath&lt;/code&gt;要指向一个未被使用的系统路径。&lt;/li&gt;
&lt;li&gt;修改镜像或者命令行使系统可以找到上一步指定的路径。此时Secret中&lt;code&gt;data&lt;/code&gt;字段的每一个key都是指定路径下面的一个文件名&lt;/li&gt;
&lt;/ol&gt;&lt;p data-source-line=&quot;127&quot;&gt;下面是一个Pod中引用Secret的列子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
  - name: mypod
    image: redis
    volumeMounts:
    - name: foo
      mountPath: &quot;/etc/foo&quot;
      readOnly: true
  volumes:
  - name: foo
    secret:
      secretName: mysecret
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p data-source-line=&quot;148&quot;&gt;每一个被引用的Secret都要在&lt;code&gt;spec.volumes&lt;/code&gt;中定义&lt;/p&gt;
&lt;p data-source-line=&quot;150&quot;&gt;如果Pod中的多个容器都要引用这个Secret那么每一个容器定义中都要指定自己的&lt;code&gt;volumeMounts&lt;/code&gt;，但是Pod定义中声明一次&lt;code&gt;spec.volumes&lt;/code&gt;就好了。&lt;/p&gt;
&lt;p data-source-line=&quot;153&quot;&gt;映射secret key到指定的路径&lt;/p&gt;
&lt;p data-source-line=&quot;155&quot;&gt;可以控制secret key被映射到容器内的路径，利用&lt;code&gt;spec.volumes[].secret.items&lt;/code&gt;来修改被映射的具体路径&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
  - name: mypod
    image: redis
    volumeMounts:
    - name: foo
      mountPath: &quot;/etc/foo&quot;
      readOnly: true
  volumes:
  - name: foo
    secret:
      secretName: mysecret
      items:
      - key: username
        path: my-group/my-username
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p data-source-line=&quot;179&quot;&gt;发生了什么呢？&lt;/p&gt;
&lt;ul data-source-line=&quot;181&quot;&gt;&lt;li&gt;username被映射到了文件&lt;code&gt;/etc/foo/my-group/my-username&lt;/code&gt;而不是&lt;code&gt;/etc/foo/username&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;password没有变&lt;/li&gt;
&lt;/ul&gt;&lt;p data-source-line=&quot;184&quot;&gt;Secret文件权限&lt;/p&gt;
&lt;p data-source-line=&quot;186&quot;&gt;可以指定secret文件的权限，类似linux系统文件权限，如果不指定默认权限是&lt;code&gt;0644&lt;/code&gt;，等同于linux文件的&lt;code&gt;-rw-r--r--&lt;/code&gt;权限&lt;/p&gt;
&lt;p data-source-line=&quot;188&quot;&gt;设置默认权限位&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
  - name: mypod
    image: redis
    volumeMounts:
    - name: foo
      mountPath: &quot;/etc/foo&quot;
  volumes:
  - name: foo
    secret:
      secretName: mysecret
      defaultMode: 256
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p data-source-line=&quot;209&quot;&gt;上述文件表示将secret挂载到容器的&lt;code&gt;/etc/foo&lt;/code&gt;路径，每一个key衍生出的文件，权限位都将是&lt;code&gt;0400&lt;/code&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;211&quot;&gt;由于JSON不支持八进制数字，因此用十进制数256表示0400，如果用yaml格式的文件那么就很自然的使用八进制了&lt;/p&gt;
&lt;p data-source-line=&quot;213&quot;&gt;同理可以单独指定某个key的权限&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
  - name: mypod
    image: redis
    volumeMounts:
    - name: foo
      mountPath: &quot;/etc/foo&quot;
  volumes:
  - name: foo
    secret:
      secretName: mysecret
      items:
      - key: username
        path: my-group/my-username
        mode: 511
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p data-source-line=&quot;237&quot;&gt;从volume中读取secret的值&lt;/p&gt;
&lt;p data-source-line=&quot;239&quot;&gt;值得注意的一点是，以文件的形式挂载到容器中的secret，他们的值已经是经过base64解码的了，可以直接读出来使用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
$ ls /etc/foo/
username
password
$ cat /etc/foo/username
admin
$ cat /etc/foo/password
1f2d1e2e67df
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p data-source-line=&quot;251&quot;&gt;被挂载的secret内容自动更新&lt;/p&gt;
&lt;p data-source-line=&quot;253&quot;&gt;也就是如果修改一个Secret的内容，那么挂载了该Secret的容器中也将会取到更新后的值，但是这个时间间隔是由kubelet的同步时间决定的。最长的时间将是一个同步周期加上缓存生命周期(period+ttl)&lt;/p&gt;
&lt;blockquote data-source-line=&quot;255&quot; readability=&quot;4.5205479452055&quot;&gt;
&lt;p&gt;特例：以&lt;a href=&quot;https://kubernetes.io/docs/concepts/storage/volumes/#using-subpath&quot;&gt;subPath&lt;/a&gt;形式挂载到容器中的secret将不会自动更新&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-source-line=&quot;258&quot;&gt;以环境变量的形式使用Secret&lt;/p&gt;
&lt;ol data-source-line=&quot;260&quot;&gt;&lt;li&gt;创建一个Secret，多个Pod可以引用同一个Secret&lt;/li&gt;
&lt;li&gt;修改pod的定义，定义环境变量并使用&lt;code&gt;env[].valueFrom.secretKeyRef&lt;/code&gt;指定secret和相应的key&lt;/li&gt;
&lt;li&gt;修改镜像或命令行，让它们可以读到环境变量&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
apiVersion: v1
kind: Pod
metadata:
  name: secret-env-pod
spec:
  containers:
  - name: mycontainer
    image: redis
    env:
      - name: SECRET_USERNAME
        valueFrom:
          secretKeyRef:
            name: mysecret
            key: username
      - name: SECRET_PASSWORD
        valueFrom:
          secretKeyRef:
            name: mysecret
            key: password
  restartPolicy: Never
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p data-source-line=&quot;287&quot;&gt;容器中读取环境变量，已经是base64解码后的值了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ echo $SECRET_USERNAME
admin
$ echo $SECRET_PASSWORD
1f2d1e2e67df
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;296&quot;&gt;使用imagePullSecrets&lt;/p&gt;
&lt;p data-source-line=&quot;298&quot;&gt;创建一个专门用来访问镜像仓库的secret，当创建Pod的时候由kubelet访问镜像仓库并拉取镜像，具体描述文档在&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;a href=&quot;https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod&quot;&gt;这里&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;300&quot;&gt;设置自动导入的imagePullSecrets&lt;/p&gt;
&lt;p data-source-line=&quot;302&quot;&gt;可以手动创建一个，然后在serviceAccount中引用它。所有经过这个serviceAccount创建的Pod都会默认使用关联的imagePullSecrets来拉取镜像，&lt;a href=&quot;https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 13 Sep 2019 13:54:00 +0000</pubDate>
<dc:creator>姚红</dc:creator>
<og:description>7.1.配置容器化应用程序 7.2.向容器传递命令行参数 7.2.1.待Docker中定义命令与参数 1.了解ENTRYPOINT与CMD ENTRYPOINT定义容器启动时被调用的可以执行程序 CM</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yaohong/p/11505670.html</dc:identifier>
</item>
<item>
<title>Python 为了提升性能，竟运用了共享经济 - 豌豆花下猫</title>
<link>http://www.cnblogs.com/pythonista/p/11517762.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pythonista/p/11517762.html</guid>
<description>&lt;p&gt;大家或许知道，Python 为了提高内存的利用效率，采用了一套共用对象内存的分配策略。&lt;/p&gt;
&lt;p&gt;例如，对于那些数值较小的数字对象（[-5, 256]）、布尔值对象、None 对象、较短的字符串对象（&lt;strong&gt;通常&lt;/strong&gt; 是 20）等等，字面量相等的对象实际上是同一个对象。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 共用内存地址的例子
a = 100
b = 100
s = &quot;python_cat&quot;
t = &quot;python_cat&quot;

id(a) == id(b) # 结果：True
id(s) == id(t) # 结果：True&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我很早的时候曾写过一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s/vCs6QvJU2J6L0rIWDKQPUQ&quot;&gt;Python中的“特权种族”是什么？&lt;/a&gt;》，把这些对象统称为“特权种族”，它们是 Python 在内存管理机制上使用的优化技巧。&lt;/p&gt;
&lt;p&gt;前不久，我还写了一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s/8f259oIGCQtY6KFSx4KW6Q&quot;&gt;Python 内存分配时的小秘密&lt;/a&gt;》，也是介绍内存管理的技巧。&lt;/p&gt;
&lt;p&gt;这两篇文章有所区别：&lt;strong&gt;旧文主要涉及了内存共用与对象驻留的机制，而新文介绍的是内存分配、动态扩容以及内存回收的相关机制。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它们令我不由自主地想到两个词：&lt;strong&gt;共享经济与供需平衡。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你没有读过那两篇文章，我强烈建议你先回看一下，然后再看看我的联想是否有道理：那几类特权种族对象其实是在共享内存，表面上的不同对象，其实是在循环利用；至于供需平衡也好理解，创建某些对象时，按照预期的诉求去分配内存，在扩容时则灵活调节，达到了供需之间的平衡。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;透过现象看本质，Python 可以很有趣。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是，Python 的有趣之处还不止于此，本文要继续分享另一种内存管理机制，在某种程度上，它实现了共享经济与供需平衡的融合，我们从中可揭开 Python 的另一重身份……&lt;/p&gt;
&lt;h2 id=&quot;不可变对象的共享经济&quot;&gt;1、不可变对象的共享经济&lt;/h2&gt;
&lt;p&gt;上面列出的&quot;特权种族&quot;都是不可变对象（而“供需平衡”主要出现于可变对象），对于这些不变的对象，当出现多处使用时，共用一个对象似乎是种不错的优化方法。&lt;/p&gt;
&lt;p&gt;我曾有一种猜想：&lt;strong&gt;Python 的不可变对象都可能是特权种族。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我没有试图去完全证实它，本文只想考察其中一种不可变对象：元组。它是不可变对象，那么，是否有共用对象的机制呢？&lt;/p&gt;
&lt;p&gt;下面把它跟列表作一下对比：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 空对象的差别
a = []
b = []
c = ()
d = ()

print(id(a)==id(b))  # 结果：False
print(id(c)==id(d))  # 结果：True&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由此可见，两个空列表是不同的对象，而两个空元组其实是同一个对象。这至少说明了，空元组在内存中只有一个，它属于已提到的特权种族。&lt;/p&gt;
&lt;p&gt;将实验延伸到集合与字典，它们是可变对象，你会发现结果跟列表一样，存在多个副本，即不是特权种族。我就不举例了。&lt;/p&gt;
&lt;p&gt;由上述的实验结果，还能引出两个问题，但是它们偏离了本文主题，我不打算深入辨析，简单列一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;除了空元组，还有什么样的元组是“特权种族”？（PS：从元素的数量、类型、元素自身的大小考虑，就我小范围试验，还没发现。所以，空元组是独特的唯一？）&lt;/li&gt;
&lt;li&gt;编译期与运行期有所区别，这在之前写字符串的 intern 机制时（《&lt;a href=&quot;https://mp.weixin.qq.com/s/M2uHVqaHe_nyO5jT60V_6Q&quot;&gt;Intern机制的软肋&lt;/a&gt;》）也分析过。（PS：print(id([]) == id([]))，结果为 True，与上例先赋值再比较不同。）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;可变对象的共享经济&quot;&gt;2、可变对象的共享经济&lt;/h2&gt;
&lt;p&gt;空元组体现了共享经济，但由于它是不可变对象，所以不存在动态扩容，就只体现了极少的供需平衡。&lt;/p&gt;
&lt;p&gt;作为对照，列表等可变对象充分表现了供需平衡，却似乎没办法体现共享经济。&lt;/p&gt;
&lt;p&gt;比如说，我们把一个列表想象成一个可自增的杯子（毕竟它是某种容器），再把它的元素想象成不同种类的液体（水、可乐、酒……）。&lt;/p&gt;
&lt;p&gt;那么，我们的问题是：两杯东西是否可以共享为一个对象呢？或者说，有没有可能共享那只杯子呢？这样就可以节省内存（在那篇讲小秘密的文章中展示过：“空杯子”占用的内存可不少），提升效率啦。&lt;/p&gt;
&lt;p&gt;对于第一个问题，答案为否，验证过程略。对于第二个问题，在上一节中，我们已验证过两个空杯子（即空列表），答案也为否。&lt;/p&gt;
&lt;p&gt;但是，第二个问题还有其它的可能！下面让我们换一种实验方法：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 实验版本：Python 3.6.1
a = [[] for i in range(4)]
print(id(a))

for i in range(len(a)):
    print(f'{i} -- {id(a[i])}')
    # a[i] = 1 # PS：可去除注释，再执行一次，结果的顺序有差别

del a
print(&quot;after del&quot;)

b = [[] for i in range(4)]
print(id(b))

for i in range(len(b)):
    print(f'{i} -- {id(b[i])}')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码在不同环境中，执行结果可能有所差异。我执行的一次结果如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;2012909395656
0 -- 2012909395272
1 -- 2012909406472
2 -- 2012909395208
3 -- 2012909395144
after del
2012909395656
0 -- 2012909395272
1 -- 2012909406472
2 -- 2012909395208
3 -- 2012909395144&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分析结果可知：列表对象在被回收之后，并不会彻底消除，它的内存地址会传递给新创建的列表，也就是说，新创建的列表其实共享了旧列表的内存地址！&lt;/p&gt;
&lt;p&gt;再结合前面的例子，我们可以说，先后静态创建的两个列表会分配不同的内存地址，但是，经过动态回收之后，先后创建的列表可能是同一个内存地址！（注意：这里说的是“可能”，因为在新列表创建前，若有其它地方也在创建列表，那后者可能夺去先机。）&lt;/p&gt;
&lt;p&gt;延伸到其它基本的可变对象，例如集合与字典，也有同样的共享策略，其目的显而易见：&lt;strong&gt;循环利用这些对象的“残躯”，可以避免内存碎片，提高执行性能。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;共享一只杯子，总比重新创造一只杯子，要更高效便捷，对吧？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1573275/201909/1573275-20190913215223808-17133157.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Python 解释器在实现这个机制时，使用了一个叫做&lt;code&gt;free_list&lt;/code&gt; 的全局变量，其工作原理是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当创建新的对象时，则检查 free_list 内是否有可用对象，有则取出使用，没有则创建&lt;/li&gt;
&lt;li&gt;当这些对象被析构时，则检查 free_list 是否有剩余空间，有则存入其中&lt;/li&gt;
&lt;li&gt;某类对象存入 free_list 时，只保留“躯壳”，而清空其内部所有的元素（即只共享杯子，不共享杯中物）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1573275/201909/1573275-20190913215224168-1026680925.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图片来源：&lt;a href=&quot;https://dwz.cn/QWD6RxOx&quot; class=&quot;uri&quot;&gt;https://dwz.cn/QWD6RxOx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;好了，现在我们可以说，列表、集合与字典这些可变对象，它们都不是前文所说的特权种族，但是，在它们背后都藏着循环使用的共享思想，这一点却是相通的。&lt;/p&gt;
&lt;p&gt;Python 解释器在内存管理上真是煞费苦心啊，在那些司空见惯的基本对象上，它施加了诸多的小魔法，在我们毫不觉察的时候，它们有条不紊地运作，而当我们终于见识清楚后，就不得不感叹它的精妙了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Python 算得上是一个精打细算的“经济学家”了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;回顾全文，最后作一个小结：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;较小的数字、较短的字符串、布尔值与空元组等不可变对象，它们存在着“共享经济”的机制，提升了内存的使用效率&lt;/li&gt;
&lt;li&gt;列表、集合与字典等可变对象，它们存在着预分配及超额分配等“供需平衡”的机制，提升了内存的分配效率&lt;/li&gt;
&lt;li&gt;列表等对象还存在着共享“容器外壳”的机制，循环利用空闲资源，综合提升程序性能&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;PS：本文写作过半时，我觉得应该把它写入“喵星来客”系列，但思前想后，最终作罢了（主要是懒）。它们的思辨力及洞察力是一脉相承的，若你喜欢本文的话，我推荐阅读“喵星来客”系列（其中两篇）：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/YQbk0smMTCexsi3Ytd2AzA&quot;&gt;Python对象的身份迷思：从全体公民到万物皆数&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/q0QvAqXcZzURH3aZ5gZm8A&quot;&gt;Python对象的空间边界：独善其身与开放包容&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1573275/201909/1573275-20190913215228864-846002058.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;公众号【&lt;strong&gt;Python猫&lt;/strong&gt;】， 本号连载优质的系列文章，有喵星哲学猫系列、Python进阶系列、好书推荐系列、技术写作、优质英文推荐与翻译等等，欢迎关注哦。&lt;/p&gt;
</description>
<pubDate>Fri, 13 Sep 2019 13:52:00 +0000</pubDate>
<dc:creator>豌豆花下猫</dc:creator>
<og:description>大家或许知道，Python 为了提高内存的利用效率，采用了一套共用对象内存的分配策略。 例如，对于那些数值较小的数字对象（[ 5, 256]）、布尔值对象、None 对象、较短的字符串对象（ 通常 是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pythonista/p/11517762.html</dc:identifier>
</item>
<item>
<title>增强学习Q-learning分析与演示（入门） - 嘘，小点声</title>
<link>http://www.cnblogs.com/bai2018/p/11517584.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bai2018/p/11517584.html</guid>
<description>&lt;h2&gt;一些说明、参阅&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MorvanZhou/Reinforcement-learning-with-tensorflow/blob/master/contents/1_command_line_reinforcement_learning/treasure_on_right.py&quot; target=&quot;_blank&quot;&gt;https://github.com/MorvanZhou/Reinforcement-learning-with-tensorflow/blob/master/contents/1_command_line_reinforcement_learning/treasure_on_right.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/simoninithomas/Deep_reinforcement_learning_Course/blob/master/Q%20learning/FrozenLake/Q%20Learning%20with%20FrozenLake.ipynb&quot; target=&quot;_blank&quot;&gt;https://github.com/simoninithomas/Deep_reinforcement_learning_Course/blob/master/Q%20learning/FrozenLake/Q%20Learning%20with%20FrozenLake.ipynb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hhh5460/p/10134018.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/hhh5460/p/10134018.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://baijiahao.baidu.com/s?id=1597978859962737001&amp;amp;wfr=spider&amp;amp;for=pc&quot; target=&quot;_blank&quot;&gt;http://baijiahao.baidu.com/s?id=1597978859962737001&amp;amp;wfr=spider&amp;amp;for=pc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/29db50000e3f&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/29db50000e3f&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;问题提出&lt;/h2&gt;
&lt;p&gt;为了实现自走的路径，并尽量避免障碍，设计一个路径。&lt;/p&gt;
&lt;p&gt;如图所示，当机器人在图中的任意网格中时，怎样让它明白周围环境，最终到达目标位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1325410/201909/1325410-20190913190658633-1585694373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;这里给出一个运行结果：&lt;/p&gt;
&lt;p&gt;首先给他们编号如下：作为位置的标识。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1325410/201909/1325410-20190913190620555-135378774.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后利用Q-Learning的奖赏机制，完成数据表单更新，最终更新如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1325410/201909/1325410-20190913190957545-1163988404.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 在机器人实际选择路径时，按照该表中的最大值选择，最终走到24号位置，并避开了红色方块。&lt;/p&gt;
&lt;p&gt;如初始位置在4时候，首先选择了最大值向左到3，然后在3处选择了最大值向下，然后到8处选择了向下，等等，最终完成路径的选择。而这种选择正是使用Q-Learning实现的。&lt;/p&gt;
&lt;h2&gt;Q-learning的想法&lt;/h2&gt;
&lt;h3&gt;奖赏机制&lt;/h3&gt;
&lt;p&gt;在一个陌生的环境中，机器人首先的方向是随机选择的，当它从起点开始出发时，选择了各种各样的方法，完成路径。&lt;/p&gt;
&lt;p&gt;但是在机器人碰到红色方块后，给予惩罚，则经过多次后，机器人会避开惩罚位置。&lt;/p&gt;
&lt;p&gt;当机器人碰到蓝色方块时，给予奖赏，经过多次后，机器人倾向于跑向蓝色方块的位置。&lt;/p&gt;
&lt;h3&gt;具体公式&lt;/h3&gt;
&lt;p&gt;完成奖赏和惩罚的过程表达，就是用值表示吧。&lt;/p&gt;
&lt;p&gt;首先建立的表是空表的，就是说，如下这样的表是空的，所有值都为0：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1325410/201909/1325410-20190913202901112-707939030.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;p&gt; 在每次行动后，根据奖惩情况，更新该表，完成学习过程。在实现过程中，将奖惩情况也编制成一张表。表格式如上图类似。&lt;/p&gt;
&lt;p&gt;而奖惩更新公式为：&lt;/p&gt;
&lt;p&gt;贝尔曼方程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1325410/201909/1325410-20190913193611764-1519985420.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中的&lt;img src=&quot;https://img2018.cnblogs.com/blog/1325410/201909/1325410-20190913193648685-446585025.png&quot; alt=&quot;&quot;/&gt;表示当前的Q表，就是上图25行4列的表单。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1325410/201909/1325410-20190913193813349-1902029716.png&quot; alt=&quot;&quot;/&gt;表示学习率，&lt;img src=&quot;https://img2018.cnblogs.com/blog/1325410/201909/1325410-20190913193830251-2081206178.png&quot; alt=&quot;&quot;/&gt;表示下一次行为会得到的奖惩情况，&lt;img src=&quot;https://img2018.cnblogs.com/blog/1325410/201909/1325410-20190913193900060-1126183545.png&quot; alt=&quot;&quot;/&gt;表示一个贪婪系数，在这里的公式中，就是说，如果它的数值比较大，则更倾向于对远方的未来奖赏。&lt;/p&gt;
&lt;p&gt;（该式子在很多网页文本中并没有固定的格式，如贪婪系数，在有些时候是随着步数的增加而递减的（可能）。&lt;/p&gt;

&lt;p&gt; 推荐阅读：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/29db50000e3f&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/29db50000e3f&lt;/a&gt;&lt;/p&gt;

&lt;p&gt; 等，其中包括了更新Q表中的一些过程。&lt;/p&gt;
&lt;h2&gt;代码实现-准备过程&lt;/h2&gt;


&lt;p&gt;不得不说的是该代码参阅了：&lt;a href=&quot;https://github.com/MorvanZhou/Reinforcement-learning-with-tensorflow/blob/master/contents/1_command_line_reinforcement_learning/treasure_on_right.py&quot; target=&quot;_blank&quot;&gt;https://github.com/MorvanZhou/Reinforcement-learning-with-tensorflow/blob/master/contents/1_command_line_reinforcement_learning/treasure_on_right.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;他的代码讲解：&lt;a href=&quot;https://morvanzhou.github.io/tutorials/machine-learning/reinforcement-learning/2-1-general-rl/&quot; target=&quot;_blank&quot;&gt;https://morvanzhou.github.io/tutorials/machine-learning/reinforcement-learning/2-1-general-rl/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;他设计了一种方案实现了机器人在一维空间中如何移动，但是不涉及障碍物的问题，并使用了较高的编程能力，有显示路径过程。&lt;/p&gt;
&lt;p&gt;而本文侧重于如何表示出路径，完成思路示例。&lt;/p&gt;
&lt;p&gt;导入对应的库函数，并建立问题模型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import numpy as np
import pandas as pd
import time
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
N_STATES = 25   # the length of the 2 dimensional world
ACTIONS = ['left', 'right','up','down']     # available actions
EPSILON = 0.3   # greedy police
ALPHA = 0.8     # learning rate
GAMMA = 0.9    # discount factor
MAX_EPISODES = 100   # maximum episodes
FRESH_TIME = 0.00001    # fresh time for one move
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;创建Q表的函数：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
def build_q_table(n_states, actions):
    table = pd.DataFrame(
        np.zeros((n_states, len(actions))),     # q_table initial values
        columns=actions,    # actions's name
    )
    return table
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;行为选择的函数：&lt;/h3&gt;
&lt;p&gt;行为选择过程中，使用这样长的表示也就是为了表达：在边界时候，机器人的路径有些不能选的，要不就超出索引的表格了。。&lt;/p&gt;
&lt;p&gt;当贪婪系数更小时，更倾向于使用随机方案，或者当表初始时所有数据都为0，则使用随机方案进行行为选择。&lt;/p&gt;
&lt;p&gt;当np.random.uniform()&amp;lt; =EPSILON时，则使用已经选择过的最优方案完成Qlearning的行为选择，也就是说，机器人并不会对远方的未知目标表示贪婪。（这里的表达是和上述公式的贪婪系数大小的作用是相反过来的）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;49&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
def choose_action(state, q_table):
    state_actions = q_table.iloc[state, :]
    if (np.random.uniform() &amp;gt; EPSILON) or ((state_actions == 0).all()):  # act non-greedy or state-action have no value
        if state==0:
            action_name=np.random.choice(['right','down'])
        elif state&amp;gt;0 and state&amp;lt;4:
            action_name=np.random.choice(['right','down','left'])
        elif state==4:
            action_name=np.random.choice(['left','down'])
        elif state==5 or state==15 or state==10 :
            action_name=np.random.choice(['right','up','down'])
        elif state==9 or state==14 or state==19 :
            action_name=np.random.choice(['left','up','down'])
        elif state==20:
            action_name=np.random.choice(['right','up'])
        elif state&amp;gt;20 and state&amp;lt;24:    
            action_name=np.random.choice(['right','up','left'])
        elif state==24:
            action_name=np.random.choice(['left','up'])
        else:
            action_name=np.random.choice(ACTIONS)
    else:   # act greedy
        action_name = state_actions.idxmax()    # replace argmax to idxmax as argmax means a different function in newer version of pandas
    return action_name
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;奖赏表达：&lt;/h3&gt;
&lt;p&gt;函数中参数S，表示state（状态），a表示action（行为），行为0到3分别表示左右上下。该表中，给出了在当前状态下，下一个方向会导致的奖惩情况。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
def get_init_feedback_table(S,a):
    tab=np.ones((25,4))
    tab[8][1]=-10;tab[4][3]=-10;tab[14][2]=-10
    tab[11][1]=-10;tab[13][0]=-10;tab[7][3]=-10;tab[17][2]=-10
    tab[16][0]=-10;tab[20][2]=-10;tab[10][3]=-10;
    tab[18][0]=-10;tab[16][1]=-10;tab[22][2]=-1;tab[12][3]=-10
    tab[23][1]=50;tab[19][3]=50
    return tab[S,a]
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;获取奖惩：&lt;/h3&gt;
&lt;p&gt;该函数调用了上一个奖惩表示的函数，获得奖惩信息，其中的参数S，A，同上。&lt;/p&gt;
&lt;p&gt;当状态S，A符合了下一步获得最终的结果时，则结束（终止），表示完成了目标任务。否则更新位置S&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
def get_env_feedback(S, A):
    action={'left':0,'right':1,'up':2,'down':3};
    R=get_init_feedback_table(S,action[A])
    if (S==19 and action[A]==3) or (S==23 and action[A]==1):
        S = 'terminal'
        return S,R
    if action[A]==0:
        S-=1
    elif action[A]==1:
        S+=1
    elif action[A]==2:
        S-=5
    else:
        S+=5  
    return S, R
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;代码实现-开始训练&lt;/h2&gt;
&lt;p&gt;首先初始化Q表，然后设定初始路径就是在0位置（也就是说每次机器人，从位置0开始出发）&lt;/p&gt;
&lt;p&gt;训练迭代次数MAX_EPISODES已经在之前设置。&lt;/p&gt;
&lt;p&gt;在每一代的训练过程中，选择行为（随机或者使用Q表原有），然后根据选择的行为和当前的位置，获得奖惩情况：S_, R&lt;/p&gt;
&lt;p&gt;当没有即将发生的行为不会到达最终目的地时候，使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
q_target = R + GAMMA * q_table.iloc[S_, :].max()
q_table.loc[S, A] += ALPHA * (q_target - q_table.loc[S, A])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　这两行完成q表的更新。（对照贝尔曼方程）&lt;/p&gt;
&lt;p&gt;当完成时候，即终止，开始下一代的训练。&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
def rl():
    # main part of RL loop
    q_table = build_q_table(N_STATES, ACTIONS)
    for episode in range(MAX_EPISODES):
        S = 0
        is_terminated = False

        while not is_terminated:
            A = choose_action(S, q_table)
            S_, R = get_env_feedback(S, A)  # take action &amp;amp; get next state and reward
            if S_ != 'terminal':
                q_target = R + GAMMA * q_table.iloc[S_, :].max()   # next state is not terminal
            else:
                print(1)
                q_target = R     # next state is terminal
                is_terminated = True    # terminate this episode

            q_table.loc[S, A] += ALPHA * (q_target - q_table.loc[S, A])  # update
            S = S_  # move to next state
    return q_table

if __name__ == &quot;__main__&quot;:
    q_table = rl()
    print('\r\nQ-table:\n')
    print(q_table)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;效果-总结&lt;/h2&gt;
&lt;p&gt;效果其实和开头一样，调整合适的参数，最终输出的q表自然有对应的影响。&lt;/p&gt;
&lt;p&gt;明显可以得到的是，贪婪系数会影响训练时间等。&lt;/p&gt;
&lt;p&gt;所有代码就是以上。可以使用eclipse的pydev下进行运行，调试。并观察没一步对表格的影响&lt;/p&gt;

</description>
<pubDate>Fri, 13 Sep 2019 12:32:00 +0000</pubDate>
<dc:creator>嘘，小点声</dc:creator>
<og:description>一些说明、参阅 https://github.com/MorvanZhou/Reinforcement-learning-with-tensorflow/blob/master/contents/1_</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bai2018/p/11517584.html</dc:identifier>
</item>
<item>
<title>Java EE—最轻量级的企业框架? - 锅外的大佬</title>
<link>http://www.cnblogs.com/liululee/p/11517579.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liululee/p/11517579.html</guid>
<description>&lt;p&gt;&lt;em&gt;确保高效发展进程的建议&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;很久以前，J2EE，特别是应用程序服务器被认为过于臃肿和“重量级”。对于开发人员来说，使用此技术开发应用程序会非常繁琐且令人沮丧。但是，由于 J2EE 框架的名称已更改为Java EE，因此该假设不再适用。 Java EE 与其他企业框架相比区别在哪以及框架&lt;em&gt;轻量级&lt;/em&gt;的标准是什么？&lt;/p&gt;
&lt;p&gt;在选择技术时，需要考虑的最重要方面之一是开发人员在开发过程中的生产力。工程师应该花费尽可能多的时间来实现用例和创收功能，因为这将使公司朝着目标前进。&lt;/p&gt;
&lt;p&gt;所选择的技术和方法应该最大限度地缩短开发人员的时间。具体哪些时间呢:等待构建，测试和部署; 配置应用; 实施与业务用例无关的管道; 并配置构建环境和外部依赖项。 但是大多数可用技术都没有这样做。&lt;/p&gt;

&lt;p&gt;与其他框架相比，Java EE 的最大优势之一是使用的API的标准化。标准听起来可能很无聊而且不够创新 - 从本质上讲，这是真的，因为Java规范请求（JSR）已经成为行业内过去已经过充分证明的结果。 但使用这些标准有几个优点。&lt;/p&gt;

&lt;p&gt;Java EE中的特定API - 例如上下文和依赖注入（CDI），JAX-RS，JSON 处理（JSR 353）和 Bean验证 - 可以很好地协同工作，并且可以无缝地相互组合。 最重要的是，CDI 被用作应用程序组件之间的“粘合剂”。 该规范包含诸如&lt;em&gt;“如果容器支持规范 A 和 B，那么 A 必须与 B 无缝集成并良好地工作。”&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;例如，JAX-RS 支持 JSONP 类型，例如&lt;code&gt;JsonObject&lt;/code&gt;用作请求或响应实体，它支持调用Bean 校验功能 - 如果验证失败，则包括正确的HTTP状态代码（参见清单1）。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Path(&quot;duke&quot;) 
public class DukeResource {           
    @GET          
    public JsonObject getDuke() {                   
        return Json.createObjectBuilder().add(&quot;name&quot;, &quot;Duke&quot;).build();         
    }     
    @POST         
    public void create(@Valid @NotPlayedYet Game game) {    
                // game object has been validated at this point         
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;清单1. JAX-RS的JSONP和Bean Validation集成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 JSONP 类型意味着内容类型将是 &lt;code&gt;application / json&lt;/code&gt;，并且如果验证失败，将发送HTTP状态代码 &lt;code&gt;400 Bad Request&lt;/code&gt;。 这无需编写任何配置代码就能使一切都完成。&lt;/p&gt;
&lt;p&gt;另一个例子是 CDI 使开发人员能够通过 &lt;code&gt;@Inject&lt;/code&gt; 将任何 bean 和用户定义的对象注入 Java EE托管组件。 请参阅清单2，了解一个 bean 验证 &lt;code&gt;Validator&lt;/code&gt;，它直接使用另一个 CDI 托管bean。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class GameNotPlayedValidator implements ConstraintValidator&amp;lt;NotPlayedYet, Game&amp;gt; {          
    @Inject          
    GameHistory history;          
    public void initialize(NotPlayedYet constraint) {                 
        // no initialization needed         
    }      

    public boolean isValid(Game game, ConstraintValidatorContext context) {                   
        return !history.exists(game);        
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;清单2. bean 验证的 CDI 集成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;集成是规范的一个主要方面，可以提供直接的开发人员体验。开发人员可以依赖应用程序服务器进行集成和配置工作，从而可以专注于应用程序的业务逻辑。&lt;/p&gt;
&lt;h2 id=&quot;按配置约定驱动开发&quot;&gt;3.按配置约定驱动开发&lt;/h2&gt;
&lt;p&gt;由于 Java EE 的配置约定驱动方法，大多数实际应用程序不需要大量配置。 繁琐的 XML 描述符的日子结束了。 对于简单的 Java EE 应用程序，您不需要单个 XML 文件。&lt;/p&gt;
&lt;p&gt;由于声明性注释，一个简单的带注释的普通旧 Java 对象（POJO）处理 HTTP 请求（&lt;code&gt;@Path&lt;/code&gt;），或分别作为 Enterprise JavaBeans（EJB）bean（&lt;code&gt;@ Stateless&lt;/code&gt;） - 包括事务，监视或拦截器。过去，这些方法已在各种框架中得到很好的证明，并已在 Java EE 中进行了标准化。&lt;/p&gt;
&lt;p&gt;如果需要，XML 描述符仍可用于部署时配置，但是配置约定有助于最大限度地提高开发人员的工作效率。&lt;/p&gt;

&lt;p&gt;少数实际企业项目在部署工件中没有任何额外依赖项的情况下工作。 但这些依赖关系的理由主要是由技术驱动 - 例如包括日志记录或实体映射框架或 Apache Commons 或 Google Guava 等常用库 - 而不是用例。&lt;/p&gt;
&lt;p&gt;Java EE 7 - 尤其是与 Java 8 一起使用时 - 具有足够的功能来覆盖大多数用例而没有任何其他依赖性。开箱即用的内容大部分都可以用最少量的代码来实现，例如，通过 CDI 提供商的可注入配置，通过拦截器的断路器（查看 Adam Bien 的开源库），或通过复杂的收集操作 Java 8 lambda 表达式和流。&lt;/p&gt;
&lt;p&gt;当然，你可以争辩说不要在这里重新发明轮子。 但实际上，为了节省一些自编写的代码行，将兆字节的外部依赖项包含在部署工件中并没有多大意义。&lt;/p&gt;
&lt;p&gt;经验表明，最大的问题不是直接引入的依赖，而是传递的依赖。传递的依赖经常与应用程序服务器上已有的库版本冲突，并导致具有挑战性的冲突。在一天的工作时间内，开发人员要花费更多时间来管理这些冲突，而不是聚焦在将小功能实现到项目中所需的时间。这主要适用于具有技术驱动而非用例驱动的依赖关系的情况。&lt;/p&gt;
&lt;p&gt;有关简单的 Java EE 7 项目Maven项目对象模型（POM）的文件启发，请参阅清单 3，该文档受Adam Bien的启发 &lt;a href=&quot;https://github.com/AdamBien/javaee7-essentials-archetype&quot;&gt;Java EE 7 Essentials Archetype&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         
     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         
     xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;     
 &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;     
 &amp;lt;groupId&amp;gt;com.sebastian-daschner&amp;lt;/groupId&amp;gt;     
 &amp;lt;artifactId&amp;gt;game-of-duke&amp;lt;/artifactId&amp;gt;     
 &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;     
 &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt;      

 &amp;lt;dependencies&amp;gt;         
     &amp;lt;dependency&amp;gt;             
          &amp;lt;groupId&amp;gt;javax&amp;lt;/groupId&amp;gt;             
          &amp;lt;artifactId&amp;gt;javaee-api&amp;lt;/artifactId&amp;gt;             
          &amp;lt;version&amp;gt;7.0&amp;lt;/version&amp;gt;             
          &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;         
     &amp;lt;/dependency&amp;gt;     
 &amp;lt;/dependencies&amp;gt;      

 &amp;lt;build&amp;gt;         
     &amp;lt;finalName&amp;gt;game-of-duke&amp;lt;/finalName&amp;gt;     
 &amp;lt;/build&amp;gt;      

 &amp;lt;properties&amp;gt;         
     &amp;lt;maven.compiler.source&amp;gt;1.8&amp;lt;/maven.compiler.source&amp;gt;         
     &amp;lt;maven.compiler.target&amp;gt;1.8&amp;lt;/maven.compiler.target&amp;gt;         
     &amp;lt;failOnMissingWebXml&amp;gt;false&amp;lt;/failOnMissingWebXml&amp;gt;         
     &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;     
     &amp;lt;/properties&amp;gt; 
&amp;lt;/project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;清单3. Java EE 7 Maven POM 文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当然，有时应用程序确实需要集成对于实现软件目标至关重要的库。但是，这些依赖关系需要通过业务需求来证明。一般来说，它很有意义，可以节省时间和精力来最小化外部生产库。&lt;/p&gt;
&lt;p&gt;对于测试依赖关系，这是一个不同的故事，因为库，例如JUnit，Mockito或者在某些情况下，Arquillian - 是至关重要的。 但同样，关注测试依赖项列表也是有意义的。&lt;/p&gt;

&lt;p&gt;由于应用程序服务器知道Java EE API，因此该API不必包含在部署 artifact 中。 只包含业务逻辑 - 只需最少的胶水代码和交叉关注点。&lt;/p&gt;
&lt;p&gt;因此，这些千字节大小的工件可以使构建时间非常短，因为构建过程不需要复制很多东西。这可以在每个构建上产生几秒钟的差异。 如果总结开发人员和持续集成（CI）服务器所花费的所有额外时间，那就会产生很大的不同。项目建设的频率越高 - 对于持续交付（CD）情景尤其如此 - 影响越大。&lt;/p&gt;
&lt;p&gt;除了较短的构建时间外，小型部署 artifacts 还可确保较短的发布和部署时间。 由于实现已经包含在运行时中，所以在所有情况下，移动部件花费的时间都是最小的。&lt;/p&gt;

&lt;p&gt;这正是Java EE成为Docker等容器技术的完美框架的原因。Docker 镜像基于图层，构建图像时，基本图像已包含操作系统，Java运行时和应用程序。因此，在每个构建中添加的唯一内容是部署工件的最后一个千字节薄层。与胖WAR或独立JAR方法相比，这节省了时间和存储 - 不仅在每个构建上，而且在图像版本化或发布版本时 。&lt;/p&gt;
&lt;p&gt;无论在哪个阶段，拥有精简的部署 artifacts 都可以实现非常快速和高效的部署管道。&lt;/p&gt;

&lt;p&gt;J2EE 应用程序服务器是重量级软件在启动和部署时间，安装大小和资源占用空间方面的体现。 但是在 Java EE 的新世界中，这已不再适用。&lt;/p&gt;
&lt;p&gt;所有现代Java EE 7应用程序服务器（如WildFly，Payara，WebSphere Liberty，Profile和TomEE）都可在几秒钟内启动和部署。由于内部，全面的模块化，他们只能加载所需的组件并尽快部署精简的应用程序 artifacts。&lt;/p&gt;
&lt;p&gt;现在的安装尺寸和占地面积非常合理。 应用程序服务器不会消耗比简单的 servlet 容器更多的东西，但它具有完整的 Java EE 功能。 有趣的是，现在运行的浏览器实例消耗更多内存。&lt;/p&gt;
&lt;p&gt;话虽如此，每个服务器只部署一个应用程序是可能的，也可以是合理的 - 无论是在容器中还是在内部。 通过“每个容器每个应用程序服务器一个应用程序”方法，您可以为现代微服务架构提供高效且灵活的解决方案。&lt;/p&gt;
&lt;h2 id=&quot;打包&quot;&gt;8.打包&lt;/h2&gt;
&lt;p&gt;在打包过程中，不应该继续使用EAR文件了。将整个应用程序部署在独立的专门的服务器上，要求我们在那个环境中必须可以访问所有的组件方法，这样做可以节省更多的构建和部署时间。除此之外，这还避免了EAR文件倾向于导致的类加载层次结构问题。&lt;/p&gt;
&lt;p&gt;在大多数云和微服务部署中，使用独立的JAR包。 它们包含应用程序和运行时实现。 在Java EE领域，这种方法可以使用特定于供应商的工具链来实现，例如 WildFly Swarm，Payara Micro 或TomEE Embedded。&lt;/p&gt;
&lt;p&gt;但是，由于上述原因，我强烈建议尽可能将业务逻辑与运行时分开。 这意味着将应用程序打包在仅包含应用程序代码的WAR文件中。&lt;/p&gt;
&lt;p&gt;在我看来，如果由于公司“政治”问题而不是技术原因而无法控制安装或操作流程，则独立 JAR 文件是一种有用的解决方法。 然后运送部署工件中所需的所有内容并且只需要 JRE 时可以解决相当多的非技术问题。&lt;/p&gt;

&lt;p&gt;企业项目最有效的解决方案之一如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;仅在提供 API 时使用 Java EE 7 和 Java 8&lt;/li&gt;
&lt;li&gt;构建一个千字节大小的 WAR 文件，其中仅包含业务逻辑和最小管道（例如 JAX-RS 资源或JPA）&lt;/li&gt;
&lt;li&gt;构建 Docker 镜像 - 仅将 WAR 文件添加到包含已配置的应用程序服务器的基础镜像&lt;/li&gt;
&lt;li&gt;通过使用容器部署应用程序的 CD 管道进行传送&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;“重量级 Java EE”的日子肯定结束了。 Java EE 中包含的 API 提供了高效且愉快的开发人员体验以及标准内的无缝集成。 特别是，将应用程序代码与运行时分离的方法可实现快速，高效的开发过程。&lt;/p&gt;
&lt;p&gt;通过由多个供应商发起的新&lt;a href=&quot;https://microprofile.io/&quot;&gt;MicroProfile&lt;/a&gt;计划，将来可能会进一步缩小Java EE所需的组件。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;原文：https://community.oracle.com/docs/DOC-1008823&lt;/p&gt;
&lt;p&gt;作者：Sebastian Daschner&lt;/p&gt;
&lt;h2 id=&quot;译者keepgoingpawnhttpsblog.csdn.nethengji666&quot;&gt;译者：[KeepGoingPawn](https://blog.csdn.net/hengji666&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;9月福利，关注公众号&lt;br/&gt;​&lt;br/&gt;后台回复：004，领取8月翻译集锦!&lt;br/&gt;​&lt;br/&gt;往期福利回复：001，002, 003即可领取！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1692986/201909/1692986-20190913202941698-421685184.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 13 Sep 2019 12:30:00 +0000</pubDate>
<dc:creator>锅外的大佬</dc:creator>
<og:description>_确保高效发展进程的建议_ 很久以前，J2EE，特别是应用程序服务器被认为过于臃肿和“重量级”。对于开发人员来说，使用此技术开发应用程序会非常繁琐且令人沮丧。但是，由于 J2EE 框架的名称已更改为J</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liululee/p/11517579.html</dc:identifier>
</item>
</channel>
</rss>