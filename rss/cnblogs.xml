<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>兄弟俩畅游Tomcat城市的SpringMVC科技园区 - 编程新说(李新杰)</title>
<link>http://www.cnblogs.com/lixinjie/p/a-story-about-springmvc-and-tomcat.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lixinjie/p/a-story-about-springmvc-and-tomcat.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br class=&quot;Apple-interchange-newline&quot;/&gt;
Tomcat城市&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;Tomcat这座城市的历史相当悠久了，经历过几次大的变迁后，呈现出非常明显的地域特征。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;从城市往西走，过了城乡结合部以后，可以说是满目疮痍、一片破败，这就是Servlet地区，这座城市一开始就是从这个地方发展起来的。&lt;/p&gt;&lt;p&gt;哎，这都是很多年前的老黄历了，只有一些老人才知道这些，现在的年轻人都不到这个地方来了，于是就荒芜了，快成无人区了。&lt;/p&gt;&lt;p&gt;城市的中央是Struts地区，人们习惯称它为老城区。矮矮的居民楼，窄窄的街道，三五成群的老旧工厂。&lt;/p&gt;&lt;p&gt;虽然现在没落了，但是置身其中，你依然能够感受到它曾经辉煌过的痕迹，那时也应该是灯红酒绿、人声鼎沸、好不热闹。&lt;/p&gt;&lt;p&gt;现在这里只剩下一些老年人了，年轻人觉得这里太陈旧了，都纷纷搬走了，偶尔能见到几个，那是回来看望父母的。&lt;/p&gt;&lt;p&gt;从城市往东走，出了老城进入新区，高楼大厦、玻璃幕墙，大宽马路、人流成河。红灯绿灯、南来北往，车声人声、声声不息。&lt;/p&gt;&lt;p&gt;这里充满了大量的年轻人，节奏感、时尚感、科技感，有梦想、有压力、有希望。没错，这就是大名鼎鼎、闻名遐迩的SpringMVC地区。&lt;/p&gt;&lt;p&gt;技术的发展就像城市的变迁，有新区就有老城。所谓长江后浪推前浪，一浪更比一浪浪，真是够浪，嗯，golang。&lt;/p&gt;&lt;p&gt;编程新说注：&lt;br/&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;第一代web应用Jsp+Servlet，现在基本没人用了，成了无人区了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;第二代web应用Struts1.x、Struts2，曾经辉煌时很多人用，现在都是进入维护期的老项目了，就像老城区。&lt;/p&gt;&lt;p&gt;第三代web应用SpringMVC，现在如日中天，依然是主战场，就如同城市的新区。&lt;br/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;br/&gt;不过SpringMVC并非固若金汤，它的挑战者已经出现，就是响应式web应用，它现在不仅要面临外患，还有来自内忧的困扰。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;请看之前写过的这篇文章“&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247483994&amp;amp;idx=1&amp;amp;sn=fb09e943331e89abcb99d8304ea6b677&amp;amp;chksm=fc3339aacb44b0bc2a120c79efebb46a43ce5b4d3148992d86b2841a89bb46bf5d8863e065ea&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;爸爸又给Spring MVC生了个弟弟叫Spring WebFlux&lt;/a&gt;”，了解更多的“同室操戈”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;破旧的火车站&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;request奉主人之命，坐了“一夜”的火车，“长途跋涉”后来到了tomcat城市，按照约定，他的弟弟response会来这里接他。request刚下了车，他弟弟就迎了上来，没想到他跑到站台上来接自己了。&lt;/p&gt;&lt;p&gt;request边走边四处打量着，这座车站虽然略显破旧，但结构设计合理，层层叠叠、环环相扣，真是建筑之美啊。&lt;/p&gt;&lt;p&gt;他突然意识到自己是第一次来这里，还不知道路怎么走，看到不远处有一老者在扫地，打算前去问路。眼看就要到了，不料被四个人“截胡”了。&lt;/p&gt;&lt;p&gt;其中两个人说他们要找一个叫MyServlet的人，老者说出门往西走就行了。另外两个人说要找一个叫FilterDispatcher的人，老者说出门往前走就行了。&lt;/p&gt;&lt;p&gt;看着他们四人离去的背影，老者无奈地摇了摇头，又自顾自地开始扫地。request上去询问为何这般，老者解释道，这四位可是稀客啊，现在像他们这样的人已经很少了。几乎都是去找DispatcherServlet的人。&lt;/p&gt;&lt;p&gt;request说道，我们就是要去找DispatcherServlet呀，老者说，出门跟着人流走，保证能找到。为了礼貌，request询问了老者的姓名，老者说，他是Wrapper，在这里工作十几年了。&lt;/p&gt;&lt;p&gt;request和response跟老者道谢后，就离开了。出门后，好不容易挤上了一辆公交，一路向东奔去。&lt;/p&gt;&lt;p&gt;编程新说注：&lt;br/&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;MyServlet一般是一个刚毕业的学生起的名字。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;FilterDispatcher是Struts2的核心控制器。&lt;/p&gt;&lt;p&gt;DispatcherServlet是SpringMVC的核心控制器。&lt;/p&gt;&lt;p&gt;Wrapper是Tomcat内部的一种容器组件，负责Servlet的调用执行。&lt;br/&gt;&lt;/p&gt;
&lt;/blockquote&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;SpringMVC科技园区&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;“前方到站SpringMVC科技园，有下车的乘客，请携带好随身物品，从后门下车”，两兄弟好不容易挤到后门，下车了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;眼前的这个科技园四四方方，里面的高大建筑布局合理。门前的宽大道路干净笔直，向南北无限延伸。旁边的小路绿树成荫、鲜花满地。&lt;/p&gt;&lt;p&gt;这里的一切都极具现代化都市气息，兄弟俩早已忘我。一阵急促的嘈杂声响起，哦，原来是绿灯亮了，可以过马路了，随机又淹没在人群中。&lt;/p&gt;&lt;p&gt;两兄弟在园区门口被保安拦下，“恁俩是弄啥嘞？”，保安问道。两兄弟一听，咦，河南人，心里乐了。说道，“老乡，俺是来找一个叫DispatcherServlet的人”。保安道，“那中，他一般都可忙啦，恁俩先去那边树荫下凉快凉快吧”。&lt;/p&gt;&lt;p&gt;一会儿功夫，有一个中年微胖男人来到了门口，就是他了。两兄弟表明来意后，request递上了一张“介绍信”，上面似乎写着：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190922224431096-5472142.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;br/&gt;DispatcherServlet看后，心里暗骂一句，这是哪个小兔崽子在写着玩呢。不过人既然已经来了，那就按照程序走吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;他就带着两兄弟来到了一个房间门口，说先进去检查一下，看看有没有“携带大件行李物品”。只见response准备进去，一把被他拉回来，说你不用去，只要你哥哥去就行了。&lt;/p&gt;&lt;p&gt;request来到门前，只见上面写着checkMultipart，推门而入，有个叫MultipartResolver的工作人员，正准备对他搜查，一看Content-Type，嘟囔着说原来只是普通表单提交没有附件，随即放弃了对request的检查，让他直接出去了。&lt;/p&gt;&lt;p&gt;request一脸懵逼，他原以为来到这里后，会有人专门带着他参观，给他讲解，端茶倒水啥的。谁知就像进了医院体检一样，拿个“单子”乱跑。&lt;/p&gt;&lt;p&gt;正在郁闷着的request在走过一个叫getHandler的房间门口时，被叫停了，他知道又该进去被检查了。一个叫RequestMappingHandlerMapping的家伙坐在电脑后面，request赶紧递上自己的单子。&lt;/p&gt;&lt;p&gt;那个家伙瞄了一眼单子后，在输入框里敲上“POST /users”关键字，点击搜索按钮，只见结果的第一条就是一个叫UserController的小伙子。并把这个小伙子的信息打印到一张纸上给了request。&lt;/p&gt;&lt;p&gt;request接过纸，边往外走边看，只见上面写着：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190922225120115-1772547577.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;br/&gt;request又是一脸懵逼，这都什么玩意儿呀。不过定睛一看，发现了熟悉的字眼儿。如UserController、registerUser、User。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;request隐隐约约当中记得自己的主人写过一些和他们相关的东西，好像是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190922225339248-2146978247.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;br/&gt;此时，request仿佛明白了，刚才那个家伙根据我的“单子”，使用电脑搜索，为我开了个“方子”。说UserController这个小伙子的registerUser方法“可以治我的病”，其中User是方法入参。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;request正准备沾沾自喜，怎么脑门突然一阵疼痛，莫非是得意忘形受了诅咒，哦，不是，是撞到门上了。揉了揉脑袋，便出了门。&lt;/p&gt;&lt;p&gt;三人一行继续往前走，request心里明白，现在这充其量叫作“做检查”，后面非给我来一个“大的修里”不可。又在一个叫做getHandlerAdapter的房间门口停住了。&lt;/p&gt;&lt;p&gt;不过这次两兄弟都在外面等着，是DispatcherServlet亲自拿着给request开的“方子”进去了。不一会他就出来了，又带出来一位叫RequestMappingHandlerAdapter的人，说这位是高级技工，由他来完成一部分核心工作。&lt;/p&gt;&lt;p&gt;这位高级技工带着两兄弟向自己的地盘走去，来到了一个写着handle的门前，推开门一起进入。这是一个非常大的房间，里面有好多的工作人员和机器设备，两兄弟明白，是时候了，重大的事情将在这里发生。&lt;/p&gt;&lt;p&gt;高级技工让两兄弟躺到工作台上，然后让所有人员各就各位，接着就是“生死看淡，不服就干”，于是，一切井然有序地开始了。&lt;/p&gt;&lt;p&gt;一个叫ServletInvocableHandlerMethod的家伙是本次的主要操盘手，他依次点名了自己的队友和检查了要用的设备，一切正常，下面正式开始了。&lt;/p&gt;&lt;p&gt;操盘手拿到给request开的“方子”，发现需要调用registerUser方法，于是先通过反射拿到这个方法的参数，再经过一番解析后变成了MethodParameter类型啦，对，它就表示方法的参数。&lt;/p&gt;&lt;p&gt;操盘手让他的队友ParameterNameDiscoverer去查看下参数的名字是什么，队友拿到参数，惊奇地发现上面有个@ModelAttribute(&quot;user&quot;)注解，于是从注解中读到了user，它就是参数的名字了。&lt;/p&gt;&lt;p&gt;操盘手又让他的队友HandlerMethodArgumentResolver去想办法把参数值搞定，队友也发现了@ModelAttribute(&quot;user&quot;)注解，说明这个参数是个模型数据，而且不是简单类型。于是先打开设备ModelAndViewContainer，发现设备里并没有一个叫user的数据。&lt;/p&gt;&lt;p&gt;队友明白，需要自己来生成这样的一个参数了。先拿到参数类型User，然后反射一下构造函数，发现正好有个默认无参的，通过它就new出了一个User类型的对象了。&lt;/p&gt;&lt;p&gt;队友接着反射一下它的属性，发现有4个，username、password、email、age。接着从request中恰巧能找出这4个名称的值，使用WebDataBinderFactory设备把数据类型合理转化后，设置给了user对象。这样队友就把参数值给准备好了。&lt;/p&gt;&lt;p&gt;有了registerUser方法和user参数后，还要知道在哪个对象上调用才行啊，于是操盘手根据方法所在的类型UserController，去容器中找到它的bean实例，接着就在该实例上通过反射发起了方法调用，传进去入参，并获取返回结果。&lt;/p&gt;&lt;p&gt;操盘手拿到返回结果，简单检查后发现返回结果不为null，再检查request的弟弟response，发现没有出现错误，而且还没有执行结束。于是在ModelAndViewContainer设备上把该请求标记为尚未处理完。&lt;/p&gt;&lt;p&gt;然后把返回结果交给队友HandlerMethodReturnValueHandler去处理，队友发现方法所在的类UserController上标有@ResponseBody注解（是作为@RestController的元注解出现的），瞬间就明白方法的返回值是直接作为web请求的响应的。&lt;/p&gt;&lt;p&gt;由于方法的返回值是要直接写入response的，所以就完事了，不用考虑视图解析这一块了。因此队友就在ModelAndViewContainer设备上把本次请求标记为已处理完成。&lt;/p&gt;&lt;p&gt;接着就把方法的返回值交给自己的好朋友HttpMessageConverter去处理，好朋友看了request的“单子”一眼，发现上面有Accept：application/json，瞬间也明白了，原来他想要的是JSON格式呀。&lt;/p&gt;&lt;p&gt;于是把方法返回值发给合作伙伴Jackson，不一会给他发回了结果，{&quot;code&quot;:0,&quot;desc&quot;:&quot;success&quot;}，好朋友把这个结果甩给了response，叫他拿好了。&lt;/p&gt;&lt;p&gt;好朋友完成了队友的任务，队友完成了操盘手的任务，操盘手向高级技工报告，任务已成功完成，请检阅。&lt;/p&gt;&lt;p&gt;高级技工本来打算输出一个ModelAndView作为处理结果呢，一检查ModelAndViewContainer设备发现请求已被处理完了。罢了，那就返回一个null吧。&lt;/p&gt;&lt;p&gt;门开了，两兄弟出来了，哥哥request已被“消耗殆尽”，弟弟response“满载而归”。DispatcherServlet早已在此等候，他看到高级技工手里只有一个null，于是记录了一句话，“No view rendering, null ModelAndView returned.”。&lt;/p&gt;&lt;p&gt;两兄弟和DispatcherServlet道谢后来到了园区大门口，接着和老乡保安挥手告别。此时天色已晚，挤上一辆公交车后，直奔火车站而去。&lt;br/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;就此一别，再无相见&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一路摇摇晃晃来到火车站，天已完全黑透了。返程的列车早已整装待发，弟弟response拉着哥哥的手准备一起上车，被哥哥拒绝了，哥哥说按照剧情应该只有你一个人回去。我的使命已完成了。&lt;/p&gt;&lt;p&gt;弟弟并不明白哥哥是什么意思，就问道那我们还能不能再见面。哥哥笑着说傻孩子，“当然可以了”。弟弟高兴地跳上了车。&lt;/p&gt;&lt;p&gt;伴着一声长鸣，列车启动，兄弟俩互相挥手告别，列车渐渐消失在黑夜的黑中。弟弟没有看到哥哥微笑的眼角流下了流水。&lt;/p&gt;&lt;p&gt;只有哥哥心里明白，他和弟弟，就此一别，再无相见。转身向车站外走去，看到那个老者依然在自顾自的扫着地。&lt;/p&gt;&lt;p&gt;黑白无常拿着脚镣手铐，早已在此“恭候多时”，有气无力的request全然无法反抗，任由这“二鬼”拖着去“阴曹地府”接受JVM的轮回。&lt;/p&gt;&lt;p&gt;也许老天不愿意看到一个光荣完成使命的人就这般的“烟消玉损”，就派出了钟馗来解救他。钟馗打跑了黑白无常，希望带request“永生”。&lt;/p&gt;&lt;p&gt;request婉言拒绝，说我非“三界五行”之外，我依然是凡人，依然有自己的宿命。这是任何人都无法逃离的自然规律。&lt;/p&gt;&lt;p&gt;顷刻，一束白光从天而降，洒满request的全身，只见request张开双臂，身轻如燕般的飞向光的源头，不一会便没有了踪迹。&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;（END）&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;作者&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是工作超过&lt;/span&gt;&lt;span&gt;&lt;strong&gt;10年&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;的码农，现在任架构师。喜欢研究技术，崇尚简单快乐。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;追求以通俗易懂的语言解说技术，希望所有的读者都能看懂并记住。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;下面是公众号和知识星球的二维码，欢迎关注！&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/76066/201904/76066-20190419093441100-1622885471.jpg&quot; alt=&quot;&quot;/&gt;      &lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://img2018.cnblogs.com/blog/76066/201904/76066-20190419132131137-250931220.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 24 Sep 2019 00:14:00 +0000</pubDate>
<dc:creator>编程新说(李新杰)</dc:creator>
<og:description>Tomcat城市 Tomcat这座城市的历史相当悠久了，经历过几次大的变迁后，呈现出非常明显的地域特征。 从城市往西走，过了城乡结合部以后，可以说是满目疮痍、一片破败，这就是Servlet地区，这座城</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lixinjie/p/a-story-about-springmvc-and-tomcat.html</dc:identifier>
</item>
<item>
<title>.NET Conf 2019 大会上发布.NET Core 3.0 - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/11576192.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/11576192.html</guid>
<description>&lt;p&gt;北京时间今天凌晨如期在.NET Conf 上发布.NET Core 3.0,Keynotes 由Scott Hunter 主演，主要围绕.NET Core 3.0的新特性和社区展开。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075401028-1566468099.png&quot;&gt;&lt;img width=&quot;244&quot; height=&quot;134&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075401686-62509612.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多功能性&lt;/strong&gt;是.Net Core 成为我们的生活一部分的最好解释。如果您是Web开发人员还是想开发桌面或移动应用程序，如果您是游戏开发人员或想要从事机器学习，.NET Core就在您身边。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075402125-686274970.png&quot;&gt;&lt;img width=&quot;244&quot; height=&quot;136&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075402521-325079730.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.xamarin.com/&quot;&gt;Xamarin&lt;/a&gt;  使得我们使用&lt;strong&gt;Microsoft&lt;/strong&gt;知识开发跨平台移动应用程序，&lt;a href=&quot;https://unity3d.com/&quot;&gt;Unity&lt;/a&gt;用于开发游戏。您还可以使用&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/uwp/get-started/universal-application-platform-guide&quot;&gt;UWP&lt;/a&gt; 构建桌面应用程序 。&lt;em&gt;Asp.net Core&lt;/em&gt;也是开发功能强大的基于Web的应用程序的主要参与者，提供了惊人的&lt;strong&gt;SPA Angular&lt;/strong&gt;模板以及&lt;a href=&quot;https://www.asp.net/signalr&quot;&gt;SignalR&lt;/a&gt;的实时应用程序等等。&lt;/p&gt;
&lt;p&gt;云原生计算的发展驱动着各个企业转向遵循云原生原则（启动速度快、内存占用低）的 .NET Core。.NET Core 对Docker容器的支持非常好，这使您可以轻松地将应用程序部署到云端，您只需单击几下即可在云上进行开发和部署。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dotnet.microsoft.com/apps/machinelearning-ai/ml-dotnet&quot;&gt;ML.NET&lt;/a&gt; 是面向.NET开发人员的机器学习框架，当我们谈论微软 Azure中的认知服务时，我们真的在谈论商品化的&lt;strong&gt;AI&lt;/strong&gt;（人工智能），ML.NET 赋予我们的应用程序员AI能力。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blazor.net/&quot;&gt;Blazor&lt;/a&gt;  也将接管一些JavaScript功能，不需要懂 AngularJS, React, Vue, 充分利用 .NET 的稳定性和一致性，让我们成为全栈的Web开发人员。&lt;/p&gt;
&lt;p&gt;.NET Core吸引人的功能还有很多，像高性能，开源，宇宙第一的开发人员工具等等。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075402895-1852008584.png&quot;&gt;&lt;img width=&quot;244&quot; height=&quot;140&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075403236-1857475221.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET Core 从2016年发布1.0 到现在的3.0， 已经有非常多的客户在使用，在国内网易，腾讯是大家比较熟悉的大公司，微软自己的搜索引擎bing 和dot.net网站 已经升级到最新的.NET Core 3.0，博客园也使用.NET Core 3.0完成了.NET向.NET Core 的升级。可以说.NET Core已经经过了血雨历练，如果是.NET 1.0/2.0还在犹豫，那么现在可以大胆升级到.NET Core 3.0，有众多的合作伙伴也提供了很多支持工具和控件.关于.NET Core 3.0 官方博客&lt;a href=&quot;https://devblogs.microsoft.com/dotnet/announcing-net-core-3-0/&quot;&gt;https://devblogs.microsoft.com/dotnet/announcing-net-core-3-0/,同事&lt;/a&gt;也发布了Visual Studio 2019 16.3 &lt;a href=&quot;https://devblogs.microsoft.com/visualstudio/dot-net-core-support-in-visual-studio-2019-version-16-3/&quot;&gt;https://devblogs.microsoft.com/visualstudio/dot-net-core-support-in-visual-studio-2019-version-16-3/&lt;/a&gt; 和 Visual Studio 8.3 for mac &lt;a href=&quot;https://devblogs.microsoft.com/visualstudio/visual-studio-2019-for-mac-version-8-3/&quot;&gt;https://devblogs.microsoft.com/visualstudio/visual-studio-2019-for-mac-version-8-3/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075403587-1216120549.png&quot;&gt;&lt;img width=&quot;244&quot; height=&quot;140&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075403964-1496644963.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075404349-1068911476.png&quot;&gt;&lt;img width=&quot;244&quot; height=&quot;139&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075404791-1115024255.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET Core 的诞生背景是在云原生应用的开发，.NET Core对微服务的支持一流，昨天我特意写了一篇文章《&lt;a href=&quot;https://www.cnblogs.com/shanyou/p/11566850.html&quot;&gt;进击的.NET 在云原生时代的蜕变&lt;/a&gt;》，特别是k8s 让.NET Core如虎添翼。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;体积更小&lt;/strong&gt;：对于微服务分布式架构而言，更小的体积意味着更少的下载带宽，更快的分发下载速度，.NET Core 的镜像体积都很小，alpine的镜像更小，带上应用程序通常80M。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;启动速度更快&lt;/strong&gt;：对于传统单体应用，启动速度与运行效率相比不是一个关键的指标。原因是，这些应用重启和发布频率相对较低。然而对于需要快速迭代、水平扩展的微服务应用而言，更快的的启动速度就意味着更高的交付效率，和更加快速的回滚。尤其当你需要发布一个有数百个副本的应用时，缓慢的启动速度就是时间杀手。对于Serverless 应用而言，端到端的冷启动速度则更为关键，即使底层容器技术可以实现百毫秒资源就绪，如果应用无法在 500ms 内完成启动，用户就会感知到访问延迟。这里我拿AWS Lambda来举例，因为各大云厂商都是以AWS是模仿的目标，AWS Lambda中可用的所有语言都是高级的，而不是像Assembler，C / C ++或Objective C那样。从脚本语言到JavaScript和Python，再到像Java和C＃到Go这样被编译为二进制文件的托管运行时的语言，所有语言都是他们有自己的长处。在基准测试中，最重要的.NET Core是 冠军，具体参看&lt;a href=&quot;https://react-etc.net/entry/aws-lambda-benchmarks-node-js-python-java-c-go-dotnet-core&quot;&gt;https://react-etc.net/entry/aws-lambda-benchmarks-node-js-python-java-c-go-dotnet-core&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;占用资源更少&lt;/strong&gt;：运行时更低的资源占用，意味着更高的部署密度和更低的计算成本。.NET Core的 CLR启动速度非常快，降低启动时资源消耗，可以减少资源争抢，更好保障其他应用 SLA。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;支持水平扩&lt;/strong&gt;展：.NET Core 3.0默认更好的支持Docker资源限制，官方团队也在努力让.NET Core成为真正的容器运行时，使其在低内存环境中具有容器感知功能并高效运行。 具体可以参看文章《&lt;a href=&quot;https://www.cnblogs.com/edison0621/p/11041725.html&quot;&gt;从CLR GC到CoreCLR GC看.NET Core对云原生的支持&lt;/a&gt;》，随着内存成本的下降和虚拟化的流行，大内存配比已经成为趋势。所以我们一般是采用水平扩展的方式，同时部署多个应用副本，在一个计算节点中可能运行一个应用的多个副本来提升资源利用率。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075405125-1934840119.png&quot;&gt;&lt;img width=&quot;244&quot; height=&quot;142&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075405442-321651936.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075405717-114056776.png&quot;&gt;&lt;img width=&quot;244&quot; height=&quot;140&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075406015-1987631898.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075406364-249140324.png&quot;&gt;&lt;img width=&quot;244&quot; height=&quot;140&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075406686-709007935.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET Core 3.0已经演变成为了一个全栈开发平台，grpc + worker servie + Web Apis + Identity。 微软的.NET团队直接参与了gRpc ，Identity Server4，Swagger相关项目的开发工作，他们和asp.net core可以完美集成。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075407224-1498972505.png&quot;&gt;&lt;img width=&quot;244&quot; height=&quot;140&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075407782-85637401.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075408074-420545220.png&quot;&gt;&lt;img width=&quot;244&quot; height=&quot;140&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075408332-1637785362.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075408764-1800903445.png&quot;&gt;&lt;img width=&quot;244&quot; height=&quot;140&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075409262-1457994071.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075409615-303480597.png&quot;&gt;&lt;img width=&quot;244&quot; height=&quot;134&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075409927-272815467.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075410285-1798607771.png&quot;&gt;&lt;img width=&quot;244&quot; height=&quot;139&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075410609-17614548.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075410904-1312667830.png&quot;&gt;&lt;img width=&quot;244&quot; height=&quot;139&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075411180-756258533.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075411524-1806293483.png&quot;&gt;&lt;img width=&quot;244&quot; height=&quot;141&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075411923-1787376396.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075412255-736438304.png&quot;&gt;&lt;img width=&quot;244&quot; height=&quot;141&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075412614-474693773.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075413356-107902182.png&quot;&gt;&lt;img width=&quot;244&quot; height=&quot;140&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075413850-1472924427.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075414183-2061110806.png&quot;&gt;&lt;img width=&quot;244&quot; height=&quot;140&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075414481-18214135.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075414803-395389539.png&quot;&gt;&lt;img width=&quot;244&quot; height=&quot;140&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075415129-1246462460.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075415606-1520179046.png&quot;&gt;&lt;img width=&quot;244&quot; height=&quot;141&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075416185-1722301641.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075416614-61805821.png&quot;&gt;&lt;img width=&quot;244&quot; height=&quot;139&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075417020-1634470036.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075417339-881850.png&quot;&gt;&lt;img width=&quot;244&quot; height=&quot;139&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075417554-122031773.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075417901-501921098.png&quot;&gt;&lt;img width=&quot;244&quot; height=&quot;141&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075418219-117770806.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075418662-163436622.png&quot;&gt;&lt;img width=&quot;244&quot; height=&quot;141&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075419178-564059664.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET Core 3.0 下载 &lt;a href=&quot;https://dotnet.microsoft.com/download&quot;&gt;https://dotnet.microsoft.com/download&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075419625-1072968623.png&quot;&gt;&lt;img width=&quot;244&quot; height=&quot;131&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190924075420002-1849990453.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容丰富多次，最后放上视频，视频我已经放在腾讯视频上。&lt;br/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 23 Sep 2019 23:54:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<og:description>北京时间今天凌晨如期在.NET Conf 上发布.NET Core 3.0,Keynotes 由Scott Hunter 主演，主要围绕.NET Core 3.0的新特性和社区展开。多功能性是.Net</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shanyou/p/11576192.html</dc:identifier>
</item>
<item>
<title>React + TypeScript 默认 Props 的处理 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/react_typescript_default_props.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/react_typescript_default_props.html</guid>
<description>&lt;h2&gt;React 中的默认 Props&lt;/h2&gt;
&lt;p&gt;通过组件的 &lt;code&gt;defaultProps&lt;/code&gt; 属性可为其 &lt;code&gt;Props&lt;/code&gt; 指定默认值。&lt;/p&gt;
&lt;p&gt;以下示例来自 &lt;a href=&quot;https://reactjs.org/docs/typechecking-with-proptypes.html#default-prop-values&quot; rel=&quot;nofollow&quot;&gt;React 官方文档 - Default Prop Values&lt;/a&gt;：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Greeting&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;Component&lt;/span&gt; {
  &lt;span class=&quot;pl-en&quot;&gt;render&lt;/span&gt;() {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; (
      &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;h1&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;Hello, {&lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;props&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;name&lt;/span&gt;}&lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;/&lt;/span&gt;h1&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
    );
  }
}

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; Specifies the default values for props:&lt;/span&gt;
&lt;span class=&quot;pl-smi&quot;&gt;Greeting&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;defaultProps&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; {
  name&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;Stranger&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
};

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; Renders &quot;Hello, Stranger&quot;:&lt;/span&gt;
&lt;span class=&quot;pl-smi&quot;&gt;ReactDOM&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;render&lt;/span&gt;(
  &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;Greeting &lt;span class=&quot;pl-k&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;,
  &lt;span class=&quot;pl-c1&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;getElementById&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;example&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;)
);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果编译过程使用了 Babel 的 &lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot; rel=&quot;nofollow&quot;&gt;transform-class-properties&lt;/a&gt; 插件，还可以这么写：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Greeting&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;Component&lt;/span&gt; {
  &lt;span class=&quot;pl-k&quot;&gt;static&lt;/span&gt; defaultProps &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; {
    name&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;stranger&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
  }

  &lt;span class=&quot;pl-en&quot;&gt;render&lt;/span&gt;() {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; (
      &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;Hello, {&lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;props&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;name&lt;/span&gt;}&lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;/&lt;/span&gt;div&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
    )
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;加入 TypeScript&lt;/h2&gt;
&lt;p&gt;加入 TypeScript 后&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-tsx&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Props&lt;/span&gt; {
  name&lt;span class=&quot;pl-k&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;;
}

&lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Greeting&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;pl-e&quot;&gt;Component&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;Props&lt;/span&gt;, {}&amp;gt; {
  &lt;span class=&quot;pl-k&quot;&gt;static&lt;/span&gt; defaultProps &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; {
    name: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;stranger&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
  };

  render() {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;div&lt;/span&gt;&amp;gt;Hello, &lt;span class=&quot;pl-pse&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;props&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;&amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;div&lt;/span&gt;&amp;gt;;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时不支持直接通过类访问 &lt;code&gt;defaultProps&lt;/code&gt; 来赋值以设置默认属性，因为 &lt;code&gt;React.Component&lt;/code&gt; 类型上并没有该属性。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 🚨Property 'defualtProps' does not exist on type 'typeof Greeting'.ts(2339)&lt;/span&gt;
&lt;span class=&quot;pl-smi&quot;&gt;Greeting&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;defualtProps&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; {
  name: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;stranger&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
};
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;默认属性的类型&lt;/h3&gt;
&lt;p&gt;上面虽然实现了通过 &lt;code&gt;defaultProps&lt;/code&gt; 来指定属性的默认值，但 &lt;code&gt;defaultProps&lt;/code&gt; 的类型是不受约束的，和 &lt;code&gt;Props&lt;/code&gt; 没有关联上。以至于我们可以在 &lt;code&gt;defaultProps&lt;/code&gt; 里面放任何值，显然这是不科学的。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
class Greeting extends React.Component&amp;lt;Props, {}&amp;gt; {
  static defaultProps = {
    name: &quot;stranger&quot;,
    // 并不会报错
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;    foo: 1,&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;    bar: {},&lt;/span&gt;
  };
 // ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同时对于同一字段，我们不得不书写两次代码。一次是定义组件的 &lt;code&gt;Props&lt;/code&gt;，另一次是在 &lt;code&gt;defaultProps&lt;/code&gt; 里。如果属性有增删或名称有变更，两个地方都需要改。&lt;/p&gt;
&lt;p&gt;为了后面演示方便，现在给组件新增一个必填属性 &lt;code&gt;age:number&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Props&lt;/span&gt; {
  age&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;number&lt;/span&gt;;
  name&lt;span class=&quot;pl-k&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;;
}

&lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Greeting&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;pl-e&quot;&gt;Component&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;Props&lt;/span&gt;, {}&amp;gt; {
  &lt;span class=&quot;pl-k&quot;&gt;static&lt;/span&gt; defaultProps &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; {
    name: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;stranger&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
  };

  render() {
    &lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; { name, age } &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;props&lt;/span&gt;;
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; (
      &amp;lt;&lt;span class=&quot;pl-en&quot;&gt;div&lt;/span&gt;&amp;gt;
        &lt;span class=&quot;pl-smi&quot;&gt;Hello&lt;/span&gt;, {&lt;span class=&quot;pl-v&quot;&gt;name&lt;/span&gt;}, &lt;span class=&quot;pl-smi&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;is&lt;/span&gt; {&lt;span class=&quot;pl-v&quot;&gt;age&lt;/span&gt;}
      &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
    );
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过可选属性抽取出来，利用 &lt;code&gt;typeof&lt;/code&gt; 获取其类型和必传属性结合来形成组件的 &lt;code&gt;Props&lt;/code&gt; 可解决上面提到的两个问题。&lt;/p&gt;
&lt;p&gt;所以优化后的代码成了：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-tsx&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; defaultProps &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; {
  name: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;stranger&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
};

&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Props&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; {
  age&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;number&lt;/span&gt;;
} &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Partial&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;defaultProps&lt;/span&gt;&amp;gt;;

&lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Greeting&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;pl-e&quot;&gt;Component&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;Props&lt;/span&gt;, {}&amp;gt; {
  &lt;span class=&quot;pl-k&quot;&gt;static&lt;/span&gt; defaultProps &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;defaultProps&lt;/span&gt;;

  render() {
    &lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; { name, age } &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;props&lt;/span&gt;;
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; (
      &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;div&lt;/span&gt;&amp;gt;
        Hello, &lt;span class=&quot;pl-pse&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;, my age is &lt;span class=&quot;pl-pse&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;
      &amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;div&lt;/span&gt;&amp;gt;
    );
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意我们的 &lt;code&gt;Props&lt;/code&gt; 是通过和 &lt;code&gt;typeof defaultProps&lt;/code&gt; 组合而形成的，可选属性中的 &lt;code&gt;name&lt;/code&gt; 字段在整个代码中只书写了一次。&lt;/p&gt;
&lt;p&gt;当我们更新了 &lt;code&gt;defaultProps&lt;/code&gt; 时整个组件的 &lt;code&gt;Props&lt;/code&gt; 也同步更新，所以 &lt;code&gt;defaultProps&lt;/code&gt; 中的字段一定是组件所需要的字段。&lt;/p&gt;
&lt;h2&gt;默认值的判空检查优化&lt;/h2&gt;
&lt;p&gt;讲道理，如果属性提供了默认值，在使用时，可不再需要判空，因为其一定是有值的。但 TypeScript 在编译时并不知道，因为有默认值的属性是被定义成可选的 &lt;code&gt;?&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;比如我们尝试访问 &lt;code&gt;name&lt;/code&gt; 属性的长度，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-tsx&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Greeting&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;pl-e&quot;&gt;Component&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;Props&lt;/span&gt;, {}&amp;gt; {
  &lt;span class=&quot;pl-k&quot;&gt;static&lt;/span&gt; defaultProps &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;defaultProps&lt;/span&gt;;

  render() {
    &lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; { name } &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;props&lt;/span&gt;;
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; (
      &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;div&lt;/span&gt;&amp;gt;
        &lt;span class=&quot;pl-pse&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; 🚨Object is possibly 'undefined'.ts(2532) &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;
        name length is &lt;span class=&quot;pl-pse&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;name&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;
      &amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;div&lt;/span&gt;&amp;gt;
    );
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为此时我们的 &lt;code&gt;Props&lt;/code&gt; 实际上是：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Props&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; {
  age&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;number&lt;/span&gt;;
} &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Partial&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;defaultProps&lt;/span&gt;&amp;gt;;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 相当于：&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Props&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; {
  age&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;number&lt;/span&gt;;
  name&lt;span class=&quot;pl-k&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修正方法有多个，最简单的是使用&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-assertion-operator&quot; rel=&quot;nofollow&quot;&gt;非空判定符/Non-null assertion operator&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;非空判定符&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-md&quot;&gt;&lt;span class=&quot;pl-md&quot;&gt;-&lt;/span&gt; name length is {name.length}&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt; name length is {name!.length}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这意味着每一处使用的地方都需要做类似的操作，当程序复杂起来时不太可控。但多数情况下应付日常使用，这样已经够了。&lt;/p&gt;
&lt;h3&gt;类型转换&lt;/h3&gt;
&lt;p&gt;因为组件内部有默认值的保证，所以字段不可能为空，因此，可对组件内部使用非空的属性类型来定义组件，而对外仍暴露原来的版本。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
const Greeting = class extends React.Component&amp;lt;
&lt;span class=&quot;pl-md&quot;&gt;&lt;span class=&quot;pl-md&quot;&gt;-&lt;/span&gt;  Props,&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;  Props &amp;amp; typeof defaultProps,&lt;/span&gt;
  {}
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;&amp;gt;&lt;/span&gt; {&lt;/span&gt;
  static defaultProps = defaultProps;

  render() {
    const { name } = this.props;
    return (
      &amp;lt;div&amp;gt;
&lt;span class=&quot;pl-md&quot;&gt;&lt;span class=&quot;pl-md&quot;&gt;-&lt;/span&gt;        name length is {name!.length}&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;        name length is {name.length}&lt;/span&gt;
      &amp;lt;/div&amp;gt;
    );
  }
&lt;span class=&quot;pl-md&quot;&gt;&lt;span class=&quot;pl-md&quot;&gt;-&lt;/span&gt;};&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;} as React.ComponentClass&amp;lt;Props&amp;gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过 &lt;code&gt;as React.ComponentClass&amp;lt;Props&amp;gt;&lt;/code&gt; 的类型转换，对外使用 &lt;code&gt;Greeting&lt;/code&gt; 时属性中 &lt;code&gt;name&lt;/code&gt; 还是可选的，但组件内部实际使用的是 &lt;code&gt;Props &amp;amp; typeof defaultProps&lt;/code&gt;，而不是 &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; 版本的，所以规避了字段可能为空的报错。&lt;/p&gt;
&lt;h3&gt;通过高阶组件的方式封装默认属性的处理&lt;/h3&gt;
&lt;p&gt;通过定义一个高阶组件比如 &lt;code&gt;withDefaultProps&lt;/code&gt; 将需要默认属性的组件包裹，将默认值的处理放到高阶组件中，同样可解决上述问题。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-tsx&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; withDefaultProps&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;object&lt;/span&gt;, &lt;span class=&quot;pl-en&quot;&gt;DP&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Partial&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;P&lt;/span&gt;&amp;gt;&amp;gt;(
  &lt;span class=&quot;pl-v&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;DP&lt;/span&gt;,
  &lt;span class=&quot;pl-v&quot;&gt;component&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;ComponentType&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;P&lt;/span&gt;&amp;gt;,
) {
  &lt;span class=&quot;pl-smi&quot;&gt;component&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;defaultProps&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;dp&lt;/span&gt;;
  &lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;RequiredProps&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Omit&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;P&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;keyof&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;DP&lt;/span&gt;&amp;gt;;
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;component&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;ComponentType&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-c1&quot;&gt;any&lt;/span&gt;&amp;gt;) &lt;span class=&quot;pl-k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;ComponentType&lt;/span&gt;&amp;lt;
    &lt;span class=&quot;pl-en&quot;&gt;RequiredProps&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;DP&lt;/span&gt;
  &amp;gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们的组件则可以这样来写：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-tsx&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; defaultProps &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; {
  name: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;stranger&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
};

&lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Props&lt;/span&gt; {
  name&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;;
  age&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;number&lt;/span&gt;;
}

&lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; _Greeting &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;pl-e&quot;&gt;Component&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;Props&lt;/span&gt;, {}&amp;gt; {
  &lt;span class=&quot;pl-k&quot;&gt;public&lt;/span&gt; render() {
    &lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; { name } &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;props&lt;/span&gt;;
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;div&lt;/span&gt;&amp;gt;name length is &lt;span class=&quot;pl-pse&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;name&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;&amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;div&lt;/span&gt;&amp;gt;;
  }
};

&lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;export&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; Greeting &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;withDefaultProps&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;defaultProps&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;_Greeting&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种方式就比较通用一些，将 &lt;code&gt;withDefaultProps&lt;/code&gt; 抽取成一个公共组件，后续其他组件都可使用。但此种情况下就没有很好地利用已经定义好的默认值 &lt;code&gt;defaultProps&lt;/code&gt; 中的字段，书写 &lt;code&gt;Props&lt;/code&gt; 时还需要重复写一遍字段名。&lt;/p&gt;
&lt;h2&gt;相关资源&lt;/h2&gt;
</description>
<pubDate>Mon, 23 Sep 2019 16:11:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>React 中的默认 Props 通过组件的 defaultProps 属性可为其 Props 指定默认值。 以下示例来自 React 官方文档 Default Prop Values： class</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Wayou/p/react_typescript_default_props.html</dc:identifier>
</item>
<item>
<title>在.NET Core中使用DispatchProxy“实现”非公开的接口 - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/11575686.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/11575686.html</guid>
<description>&lt;blockquote readability=&quot;2.300518134715&quot;&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://www.strathweb.com/2019/09/implementing-a-non-public-interface-in-net-core-with-dispatchproxy/&quot;&gt;“Implementing” a non-public interface in .NET Core with DispatchProxy&lt;/a&gt;&lt;br/&gt;原文作者：Filip W.&lt;br/&gt;译文地址：&lt;a href=&quot;https://www.cnblogs.com/lwqlun/p/11575686.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/lwqlun/p/11575686.html&lt;/a&gt;&lt;br/&gt;译者：Lamond Lu&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;反射是.NET中一个非常强大的概念，对于每一个C#开发人员来说，迟早都会使用到这个它。在许多场景中，反射都非常有用，例如程序集扫描，类型发现或者各种程序组合使用。&lt;/p&gt;
&lt;p&gt;然而，它经常被用来绕过你正在使用的依赖项的public接口 - 修改它们或者访问依赖项做着未曾预想的内容。这就是说，这种“黑客入侵”的方式对于C#开发来说非常的典型，尽管有一定的风险，但是它可能有时候是让你摆脱编码困境的唯一方法。&lt;/p&gt;
&lt;p&gt;如果你被迫公开一个非public(例如可能是internal的)接口的实现，那么事情就开始变得有趣了。针对这个问题，“基本的”反射已经不能带来任何帮助了，所以让我们来一起看一下我们应该如何实现这个需求。&lt;/p&gt;

&lt;p&gt;想想一下，你正在使用一个第三方库，在这个库中包含一下的内部类&lt;strong&gt;&lt;code&gt;Greeter&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;internal class Greeter
{
    public static void Greet(IGreeting greeting)
    {
        Console.WriteLine(greeting.Message);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在呢，我们希望通过反射，使用这个类型，执行它其中定义的&lt;code&gt;Greet&lt;/code&gt;方法。为了实现这个需求，你需要一个实现&lt;code&gt;IGreeting&lt;/code&gt;接口的实现类实例，因为它是&lt;code&gt;Greet&lt;/code&gt;方法所需的参数。&lt;code&gt;IGreeting&lt;/code&gt;接口的代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;internal interface IGreeting
{
    string Message { get; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里需要注意的是，这里没有任何一个你可以直接使用的&lt;code&gt;IGreeting&lt;/code&gt;接口的实现。相反的，要使用&lt;code&gt;Greeter&lt;/code&gt;类，你就必须自己提供一个&lt;code&gt;IGreeting&lt;/code&gt;接口的实现。&lt;/p&gt;
&lt;p&gt;当然，使用C#实现一个接口很简单 - 但是如何实现一个通过反射提取到的接口？好吧，这有一点问题，不是么？下面的代码，也对此进行了说明，注意该示例代码中的类与&lt;code&gt;Greeter&lt;/code&gt;和&lt;code&gt;IGreeting&lt;/code&gt;类型存在于不同的程序集中。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;class Program
{
    static void Main(string[] args)
    {
        // 查找非公开Greeter类型                
        var greeterType = Assembly.Load(&quot;Library&quot;).GetType(&quot;Library.Greeter&quot;);
        
        // 提取Greet方法
        var greetMethod = internalType.GetMethod(&quot;Greet&quot;, BindingFlags.Public | BindingFlags.Static);
 
        // 尝试执行方法，然而...
        // ...我们需要一个IGreeting接口类型的实例，我们该怎么办?
        var greeting = greetMethod.Invoke(null, new[] { ??? });
        Console.WriteLine();
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;下面让我们来使用&lt;code&gt;DispatchProxy&lt;/code&gt;类。这个类型自.NET Core诞生之日起，就已经存在了，它提供了实例化代理对象和处理器方法分发的机制。&lt;code&gt;DispatchProxy&lt;/code&gt;类的典型用法如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;var proxy = DispatchProxy.Create&amp;lt;IFoo, FooProxy&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这我们的示例中，&lt;code&gt;IFoo&lt;/code&gt;是我们需要实现的接口。&lt;code&gt;DispatchProxy&lt;/code&gt;的强大功能如下：它允许我们创建一个&lt;code&gt;FooProxy&lt;/code&gt;类型，该类型可以像&lt;code&gt;IFoo&lt;/code&gt;一样被使用，且不需要真正&quot;实现它&quot;。（或者它也可以转发给另一个实际上模拟&lt;code&gt;IFoo&lt;/code&gt;接口的类型）&lt;/p&gt;
&lt;p&gt;但是，当使用以上API的时候，代理类实现的接口类型需要在编译时被知晓，这对于我们当前的用例不太理想 - 因为在非public的接口情况下，我们只能在运行时才能抓住它。不过不用担心，我们将使用反射解决这个问题。以下的代码说明了我们的做法(假设&lt;code&gt;IFoo&lt;/code&gt;是非public的):&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;var internalType = Assembly.Load(&quot;Library&quot;).GetType(&quot;IFoo&quot;);
var proxy = typeof(DispatchProxy)
    .GetMethod(nameof(DispatchProxy.Create))
    .MakeGenericMethod(internalType, typeof(FooProxy))
    .Invoke(null, null);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后就很简单了，我们使用与之前相同的Api, 但是我们可以动态的提供必要的参数类型，而不必在编译时才知道它们才能在泛型中使用。&lt;/p&gt;
&lt;p&gt;在我们特定的&lt;code&gt;Greeting&lt;/code&gt;例子中，用于创建代理的方法如下：（为了更清晰的分离，我们将它封装在一个工厂类中）。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class GreetingFactory
{
    public static object Create()
    {
        var internalType = Assembly.Load(&quot;Library&quot;).GetType(&quot;Library.IGreeting&quot;);
        return typeof(DispatchProxy)
            .GetMethod(nameof(DispatchProxy.Create))
            .MakeGenericMethod(internalType, typeof(GreetingProxy))
            .Invoke(null, null);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，谜题的最后一块碎片就是实现&lt;code&gt;GreetingProxy&lt;/code&gt;了。如下的代码展示了&lt;code&gt;GreetingProxy&lt;/code&gt;类的实现，它是&lt;code&gt;DispatchProxy&lt;/code&gt;的一个子类。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class GreetingProxy : DispatchProxy
{
    private GreetingImpl _impl;
 
    public GreetingProxy()
    {
        _impl = new GreetingImpl();
    }
 
    protected override object Invoke(MethodInfo targetMethod, object[] args)
    {
        return _impl.GetType().GetMethod(targetMethod.Name).Invoke(_impl, args);
    }
 
    private class GreetingImpl // : 不实现IGreeting, 但是模拟了它
    {
        public string Message =&amp;gt; &quot;hello world&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如你所见，这个类充当了潜在调用者与&lt;code&gt;IGreeting&lt;/code&gt;实际实现之间的网关，毕竟这就是代理的主要作用。这个&quot;实现&quot;（我用引号引起来，因为我们并不是真正实现非public接口），或者更确切的说，使用私有类&lt;code&gt;GreetingImpl&lt;/code&gt;的形式模仿接口类型，并包含了必要的public属性&lt;code&gt;Message&lt;/code&gt;。这里并不是必须要要这么做，这只是我自己喜欢的一种实现方式。&lt;/p&gt;
&lt;p&gt;每当代用代理类的时候，我们都会可以根据请求的接口成员获得&lt;code&gt;MethodInfo&lt;/code&gt;信息 - 因此，我们只需将其重定向到结构相同的隐藏实现&lt;code&gt;GreetingImpl&lt;/code&gt;的相应成员即可。&lt;/p&gt;
&lt;p&gt;最后，我们的代码看起来应该是这样的。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;class Program
{
    static void Main(string[] args)
    {
        var internalType = Assembly.Load(&quot;Library&quot;).GetType(&quot;Library.Greeter&quot;);
        var greetMethod = internalType.GetMethod(&quot;Greet&quot;, BindingFlags.Public | BindingFlags.Static);
 
        var proxy = GreetingFactory.Create();
        Console.WriteLine(greetMethod.Invoke(null, new[] { proxy }));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么，这个方法到底是用来做什么的呢？它通过代理对象，调用了&lt;code&gt;GreetingImpl&lt;/code&gt;中定义的方法，打印出了&quot;Hello World&quot;。当然，最终的结果是我们设法“实现”并使用了非公开API中的非public接口。&lt;/p&gt;

&lt;p&gt;就像其他所有东西一样，我觉着答案 - 取决于 -毕竟它是一个高度专业化的API。这种技术（代理对象）经常会在ORM和其他Mock框架中使用。另外，如果你使用的是复杂的第三方框架或库，并且需要使用大量的反射，那么你迟早会用到&lt;code&gt;DispatchProxy&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;实际上，如果你对真实需求的例子感兴趣， 你可以来看看我们的OmniSharp项目。OmniSharp项目使用Roslyn编译器为VSCode等许多代码编辑器提供代码感知功能。但是不幸的是，Roslyn并不会提供大量public API, 所以我们不得不大量使用反射。实际上，我们还必须在许多地方使用&lt;code&gt;DispatchProxy&lt;/code&gt;才能向用户提供一些特定功能，例如从类型中提取接口。一方面，这不是很友好，因为东西很容易崩溃，但是对于客户的价值是毋庸置疑的，所以我们还是选择这样做。&lt;/p&gt;
</description>
<pubDate>Mon, 23 Sep 2019 15:38:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>原文地址： '“Implementing” a non public interface in .NET Core with DispatchProxy' 原文作者：Filip W. 译文地址： 译者</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lwqlun/p/11575686.html</dc:identifier>
</item>
<item>
<title>PopUpWindow 的使用笔记 - huansky</title>
<link>http://www.cnblogs.com/huansky/p/11574932.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huansky/p/11574932.html</guid>
<description>&lt;p&gt;最接做需求的时候，碰到了 PopUpWindow，但是也没做过多了解，就是照搬别人的代码改改逻辑。后面视觉看了之后，说让我加一些动画效果，使用起来更加舒服。可是我看别人以前也没有写，于是就开始捣鼓 PopUpWindow。同时也写一篇文章记录下，后续忘了也可以查看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/916005/201909/916005-20190923225720485-2091743187.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;相关方法解读&lt;/h2&gt;
&lt;h3&gt;1）几个常用的构造方法&lt;/h3&gt;
&lt;blockquote class=&quot;default&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;我们在文档中可以看到，提供给我们的PopupWindow的构造方法有九种之多，这里只贴实际 开发中用得较多的几个构造方法：&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;public PopupWindow (Context context)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;public PopupWindow(View contentView, int width, int height)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;public PopupWindow(View contentView)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;public PopupWindow(View contentView, int width, int height, boolean focusable)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;参数就不用多解释了吧，contentView是PopupWindow显示的View，focusable是否显示焦点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;2）常用的一些方法&lt;/h3&gt;
&lt;blockquote class=&quot;default&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;下面介绍几个用得较多的一些方法，其他的可自行查阅文档：&lt;/p&gt;
&lt;ul readability=&quot;11&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;setContentView(View contentView)：设置PopupWindow显示的View&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;getContentView()：获得PopupWindow显示的View&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;showAsDropDown(View anchor)：相对某个控件的位置（正左下方），无偏移&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;showAsDropDown(View anchor, int xoff, int yoff)：相对某个控件的位置，有偏移&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;showAtLocation(View parent, int gravity, int x, int y)： 相对于父控件的位置（例如正中央Gravity.CENTER，下方Gravity.BOTTOM等），可以设置偏移或无偏移 PS:parent这个参数只要是activity中的view就可以了！&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;setWidth/setHeight：设置宽高，也可以在构造方法那里指定好宽高， 除了可以写具体的值，还可以用WRAP_CONTENT或MATCH_PARENT， popupWindow的width和height属性直接和第一层View相对应。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;setFocusable(true)：设置焦点，PopupWindow弹出后，所有的触屏和物理按键都由PopupWindows 处理。其他任何事件的响应都必须发生在PopupWindow消失之后，（home 等系统层面的事件除外）。 比如这样一个PopupWindow出现的时候，按back键首先是让PopupWindow消失，第二次按才是退出 activity，准确的说是想退出activity你得首先让PopupWindow消失，因为不并是任何情况下按back PopupWindow都会消失，必须在PopupWindow设置了背景的情况下 。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;setAnimationStyle(int)：设置动画效果&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2&gt;创建布局&lt;/h2&gt;
&lt;p&gt;PopUpWindow 就是一个容器，是需要编写对应的布局文件，布局比较简单具体如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LinearLayout &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
    android:clipChildren&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;
    android:orientation&lt;/span&gt;&lt;span&gt;=&quot;vertical&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;View
        &lt;/span&gt;&lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/empty_view&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;100dp&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_weight&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;
        &lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LinearLayout
        &lt;/span&gt;&lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/container&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;200dp&quot;&lt;/span&gt;&lt;span&gt;
        android:background&lt;/span&gt;&lt;span&gt;=&quot;@color/colorPrimary&quot;&lt;/span&gt;&lt;span&gt;
        android:orientation&lt;/span&gt;&lt;span&gt;=&quot;vertical&quot;&lt;/span&gt;&lt;span&gt;
        android:gravity&lt;/span&gt;&lt;span&gt;=&quot;center_vertical&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView
            &lt;/span&gt;&lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/title&quot;&lt;/span&gt;&lt;span&gt;
            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;60dp&quot;&lt;/span&gt;&lt;span&gt;
            android:text&lt;/span&gt;&lt;span&gt;=&quot;test&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;LinearLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;LinearLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意其中这行代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
android:layout_weight=&quot;1&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于其他 view 没有使用这个属性，默认为0，使用该属性的view将剩余的空间铺满。这样就相当于为我们设置了一个蒙层了。&lt;/p&gt;
&lt;p&gt;写好布局后，需要将布局文件传到容器中去。&lt;/p&gt;

&lt;h2&gt;PopUpWindow 使用&lt;/h2&gt;
&lt;p&gt;由于相关代码比较长，直接附上完整代码，方便大家查看。&lt;/p&gt;
&lt;p&gt;完整代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TestActivity &lt;span&gt;extends&lt;/span&gt; AppCompatActivity &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; View.OnClickListener {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; PopupWindow mPopupWindow;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ViewGroup mContentView;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Button mBtn;

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(Bundle savedInstanceState) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onCreate(savedInstanceState);
        setContentView(R.layout.activity_test);
        mBtn &lt;/span&gt;=&lt;span&gt; (Button) findViewById(R.id.result);
        mPopupWindow &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; PopupWindow(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        mPopupWindow.setContentView(getContentView(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;));
        mPopupWindow.setHeight(ViewGroup.LayoutParams.MATCH_PARENT);
        mPopupWindow.setWidth(ViewGroup.LayoutParams.MATCH_PARENT);
        mPopupWindow.setClippingEnabled(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果不设置PopupWindow的背景，有些版本就会出现一个问题：无论是点击外部区域还是Back键都无法dismiss弹框&lt;/span&gt;
        mPopupWindow.setBackgroundDrawable(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ColorDrawable(getResources().getColor(R.color
                .empty_view_background)));
        mPopupWindow.setOutsideTouchable(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        mPopupWindow.setFocusable(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        mPopupWindow.update();
        mBtn.setOnClickListener(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * popup window view 初始化
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; View
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; View getContentView(Context ctx) {
        mContentView &lt;/span&gt;=&lt;span&gt; (ViewGroup) LayoutInflater.from(ctx)
                .inflate(R.layout.popup, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        View emptyViewAbovePanel &lt;/span&gt;=&lt;span&gt; mContentView.findViewById(R.id.empty_view);
        emptyViewAbovePanel.setOnClickListener(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mContentView;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onClick(View v) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; v.getId();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i ==&lt;span&gt; R.id.empty_view) {
            Animation animation &lt;/span&gt;= AnimationUtils.loadAnimation(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, R.anim.pop_gone);
            mContentView.startAnimation(animation);
            animation.setAnimationListener(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Animation.AnimationListener() {
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onAnimationStart(Animation animation) {

                }

                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onAnimationEnd(Animation animation) {
                    mPopupWindow.dismiss();
                }

                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onAnimationRepeat(Animation animation) {

                }
            });
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (i ==&lt;span&gt; R.id.result) {
            mContentView.startAnimation(AnimationUtils.loadAnimation(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, R.anim.pop_in));
            mPopupWindow.showAsDropDown(mBtn, &lt;/span&gt;50, 50&lt;span&gt;);
        }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 上面的代码设置了蒙层，出场入场的动画效果。&lt;/p&gt;

&lt;h2&gt;动画设置&lt;/h2&gt;
&lt;p&gt;出场动画文件xml：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;set &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;translate
        &lt;/span&gt;&lt;span&gt;android:duration&lt;/span&gt;&lt;span&gt;=&quot;400&quot;&lt;/span&gt;&lt;span&gt;
        android:fromXDelta&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;
        android:fromYDelta&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;
        android:toXDelta&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;
        android:toYDelta&lt;/span&gt;&lt;span&gt;=&quot;100%&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进场动画文件xml：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;set &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;translate
        &lt;/span&gt;&lt;span&gt;android:duration&lt;/span&gt;&lt;span&gt;=&quot;400&quot;&lt;/span&gt;&lt;span&gt;
        android:fromXDelta&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;
        android:fromYDelta&lt;/span&gt;&lt;span&gt;=&quot;100%&quot;&lt;/span&gt;&lt;span&gt;
        android:toXDelta&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;
        android:toYDelta&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 为什么出场动画不用 PopUpWindow 默认动画设置呢。这是因为视觉只希望下面蓝色部分有动画效果，蒙层不需要这个动画效果。因此我们就必须添加额外的处理逻辑。如果采用默认的动画设置效果，将会使得蒙层也有动画效果。&lt;/p&gt;
&lt;p&gt;在资源文件的values的style.xml中添加如下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;pop_animation&quot;&lt;/span&gt;&lt;span&gt; parent&lt;/span&gt;&lt;span&gt;=&quot;android:Animation&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;item &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;android:windowEnterAnimation&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;@anim/pop_in&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;item &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;android:windowExitAnimation&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;@anim/pop_gone&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;android:windowEnterAnimation:为窗体进入时执行；&lt;br/&gt;android:windowExitAnimation：为窗体退出时执行；&lt;/p&gt;
&lt;p&gt;将其使用到PopupWindow中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;mPopupWindow.setAnimationStyle(R.style.pop_animation);
mPopupWindow.showAtLocation(view, Gravity.CENTER, &lt;/span&gt;0, 0);
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;line-numbers language-css&quot;&gt;&lt;span&gt;setAnimationStyle() 即是为 PopupWindow 添加动画的方法，由于 PopupWindow 不能像其他的 View 一样使用 ObjectAnimator, 所以使用动画需要在 style 中定义，并且使用 PopupWindow 的 setAnimationStyle() 方法。这样的话就可以使用。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;line-numbers language-css&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;line-numbers language-css&quot;&gt;蒙层的处理&lt;/h2&gt;
&lt;p class=&quot;line-numbers language-css&quot;&gt;除了上面的我的蒙层方法，还有其他添加蒙层的方法：&lt;/p&gt;
&lt;h3 class=&quot;line-numbers language-css&quot;&gt;1）添加一层view&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addMaskView(IBinder token) {
    WindowManager.LayoutParams p &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WindowManager.LayoutParams();
    p.width &lt;/span&gt;=&lt;span&gt; WindowManager.LayoutParams.MATCH_PARENT;
    p.height &lt;/span&gt;=&lt;span&gt; WindowManager.LayoutParams.MATCH_PARENT;
    p.format &lt;/span&gt;=&lt;span&gt; PixelFormat.TRANSLUCENT;
    p.type &lt;/span&gt;=&lt;span&gt; WindowManager.LayoutParams.TYPE_APPLICATION_PANEL;
    p.token &lt;/span&gt;=&lt;span&gt; token;
    p.windowAnimations &lt;/span&gt;=&lt;span&gt; android.R.style.Animation_Toast;
    maskView &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; View(context);
    maskView.setBackgroundColor(&lt;/span&gt;0x7f000000&lt;span&gt;);
    maskView.setFitsSystemWindows(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    maskView.setOnKeyListener(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; OnKeyListener() {
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; onKey(View v, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; keyCode, KeyEvent event) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (keyCode ==&lt;span&gt; KeyEvent.KEYCODE_BACK) {
                removeMaskView();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    });
    wm.addView(maskView, p);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在消失的时候进行移除：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dismiss() {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (maskView != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        wm.removeViewImmediate(maskView);
        maskView &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.dismiss();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2) 透明度&lt;/h3&gt;
&lt;p&gt;还有人是直接使用透明度来实现的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; bgAlpha(&lt;span&gt;float&lt;/span&gt;&lt;span&gt; alpha) {
    WindowManager.LayoutParams lp &lt;/span&gt;=&lt;span&gt; ((Activity)context).getWindow().getAttributes();
    lp.alpha &lt;/span&gt;= alpha;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0.0-1.0&lt;/span&gt;
&lt;span&gt;    ((Activity)context).getWindow().setAttributes(lp);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 23 Sep 2019 15:29:00 +0000</pubDate>
<dc:creator>huansky</dc:creator>
<og:description>最接做需求的时候，碰到了 PopUpWindow，但是也没做过多了解，就是照搬别人的代码改改逻辑。后面视觉看了之后，说让我加一些动画效果，使用起来更加舒服。可是我看别人以前也没有写，于是就开始捣鼓 P</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huansky/p/11574932.html</dc:identifier>
</item>
<item>
<title>Elasticsearch(9) --- 聚合查询(Bucket聚合) - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/11575408.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/11575408.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;上一篇讲了Elasticsearch聚合查询中的&lt;strong&gt;Metric聚合&lt;/strong&gt;：&lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/11556764.html&quot;&gt;Elasticsearch(8) --- 聚合查询(Metric聚合)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;说明&lt;/code&gt; 本文主要参考于Elasticsearch 官方文档 7.3版本。 &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket.html#search-aggregations-bucket&quot;&gt;Bucket Aggregations&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;概念&lt;/code&gt;：&lt;strong&gt;Bucket&lt;/strong&gt; 可以理解为一个桶，它会遍历文档中的内容，凡是符合某一要求的就放入一个桶中，分桶相当与 SQL 中的 &lt;strong&gt;group by&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这篇博客讲的桶的关键字有：&lt;code&gt;Terms Aggregation&lt;/code&gt; 、&lt;code&gt;Filter Aggregation&lt;/code&gt;、&lt;code&gt;Histogram Aggregation&lt;/code&gt;、&lt;code&gt;Range Aggregation&lt;/code&gt; 、&lt;code&gt;Date Aggregation&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;一创建索引数据&quot;&gt;&lt;span&gt;一、创建索引、数据&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;创建索引&quot;&gt;1、创建索引&lt;/h4&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;DELETE cars
PUT cars
{
  &quot;mappings&quot;: {
      &quot;properties&quot;: {
        &quot;price&quot;: {
          &quot;type&quot;:&quot;long&quot;
        },
        &quot;color&quot;: {
          &quot;type&quot;:&quot;keyword&quot;
        },
        &quot;brand&quot;: {
          &quot;type&quot;:&quot;keyword&quot;
        },
        &quot;sellTime&quot;: {
          &quot;type&quot;:&quot;date&quot;
        }
      }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;属性字段：价格、颜色、品牌、销售时间&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;添加索引数据&quot;&gt;2、添加索引数据&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;POST /cars/_bulk
{ &quot;index&quot;: {}}
{ &quot;price&quot; : 80000, &quot;color&quot; : &quot;red&quot;, &quot;brand&quot; : &quot;BMW&quot;, &quot;sellTime&quot; : &quot;2014-01-28&quot; }
{ &quot;index&quot;: {}}
{ &quot;price&quot; : 85000, &quot;color&quot; : &quot;green&quot;, &quot;brand&quot; : &quot;BMW&quot;, &quot;sellTime&quot; : &quot;2014-02-05&quot; }
{ &quot;index&quot;: {}}
{ &quot;price&quot; : 120000, &quot;color&quot; : &quot;green&quot;, &quot;brand&quot; : &quot;Mercedes&quot;, &quot;sellTime&quot; : &quot;2014-03-18&quot; }
{ &quot;index&quot;: {}}
{ &quot;price&quot; : 105000, &quot;color&quot; : &quot;blue&quot;, &quot;brand&quot; : &quot;Mercedes&quot;, &quot;sellTime&quot; : &quot;2014-04-02&quot; }
{ &quot;index&quot;: {}}
{ &quot;price&quot; : 72000, &quot;color&quot; : &quot;green&quot;, &quot;brand&quot; : &quot;Audi&quot;, &quot;sellTime&quot; : &quot;2014-05-19&quot; }
{ &quot;index&quot;: {}}
{ &quot;price&quot; : 60000, &quot;color&quot; : &quot;red&quot;, &quot;brand&quot; : &quot;Audi&quot;, &quot;sellTime&quot; : &quot;2014-06-05&quot; }
{ &quot;index&quot;: {}}
{ &quot;price&quot; : 40000, &quot;color&quot; : &quot;red&quot;, &quot;brand&quot; : &quot;Audi&quot;, &quot;sellTime&quot; : &quot;2014-07-01&quot; }
{ &quot;index&quot;: {}}
{ &quot;price&quot; : 35000, &quot;color&quot; : &quot;blue&quot;, &quot;brand&quot; : &quot;Honda&quot;, &quot;sellTime&quot; : &quot;2014-08-12&quot; }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;查看是否成功&quot;&gt;3、查看是否成功&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;命令&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GET /_cat/count/cars?v&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到该索引存在，并且有8条文档数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190923223608157-1281012717.jpg&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;二terms-aggregation&quot;&gt;&lt;span&gt;二、Terms Aggregation&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;官方7.3文档&lt;/strong&gt;：&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-terms-aggregation.html&quot;&gt;Terms Aggregation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;概念&lt;/code&gt; : 根据某一项的每个唯一的值的聚合。&lt;/p&gt;
&lt;h4 id=&quot;根据品牌分桶&quot;&gt;1、根据品牌分桶&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;GET cars/_search?size=0
{
    &quot;aggs&quot; : {
        &quot;genres&quot; : {
            &quot;terms&quot; : { &quot;field&quot; : &quot;brand&quot; } 
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190923223617989-1710439827.jpg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;分桶后只显示文档数量前3的桶&quot;&gt;2、分桶后只显示文档数量前3的桶&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;GET cars/_search?size=0
{
    &quot;aggs&quot; : {
        &quot;cars&quot; : {
            &quot;terms&quot; : {
                &quot;field&quot; : &quot;brand&quot;,
                &quot;size&quot; : 3
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190923223627006-491459054.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看出文档数量前三的桶。&lt;/p&gt;
&lt;h4 id=&quot;分桶后排序&quot;&gt;3、分桶后排序&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;GET cars/_search?size=0
{
    &quot;aggs&quot; : {
        &quot;genres&quot; : {
            &quot;terms&quot; : {
                &quot;field&quot; : &quot;brand&quot;,
                &quot;order&quot; : { &quot;_count&quot; : &quot;asc&quot; }
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;显示文档数量大于3的桶&quot;&gt;4、显示文档数量大于3的桶&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;GET cars/_search?size=0
{
    &quot;aggs&quot; : {
        &quot;brands&quot; : {
            &quot;terms&quot; : {
                &quot;field&quot; : &quot;brand&quot;,
                &quot;min_doc_count&quot;: 3
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;使用精确指定的词条进行分桶&quot;&gt;5、使用精确指定的词条进行分桶&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;GET /cars/_search?size=0
{
    &quot;aggs&quot; : {
        &quot;JapaneseCars&quot; : {
             &quot;terms&quot; : {
                 &quot;field&quot; : &quot;brand&quot;,
                 &quot;include&quot; : [&quot;BMW&quot;, &quot;Audi&quot;]
             }
         }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里也只展示些常用的，更多有关Terms Aggregation那就看官网吧。&lt;/p&gt;
&lt;h2 id=&quot;三-filter-aggregation&quot;&gt;&lt;span&gt;三、 Filter Aggregation&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;官方文档&lt;/strong&gt;： &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-filter-aggregation.html&quot;&gt;Filter Aggregation&lt;/a&gt; 和 &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-filters-aggregation.html&quot;&gt;Filters Aggregation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Filter概念&lt;/code&gt;：指具体的域和具体的值，可以说是在 Terms Aggregation 的基础上进行了过滤，只对特定的值进行了聚合。&lt;/p&gt;
&lt;h4 id=&quot;过滤获取品牌为bmw的桶并求该桶平均值&quot;&gt;1、过滤获取品牌为BMW的桶，并求该桶平均值&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;GET /cars/_search?size=0
{
    &quot;aggs&quot; : {
        &quot;brands&quot; : {
            &quot;filter&quot; : { &quot;term&quot;: { &quot;brand&quot;: &quot;BMW&quot; } },
            &quot;aggs&quot; : {
                &quot;avg_price&quot; : { &quot;avg&quot; : { &quot;field&quot; : &quot;price&quot; } }
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190923223640243-1293650096.jpg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;过滤获取品牌为bmw的或者color为绿色的桶&quot;&gt;2、过滤获取品牌为BMW的或者color为绿色的桶&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Filters概念&lt;/code&gt; : Filter Aggreagtion 只能指定一个过滤条件，响应也只是单个桶。如果想要只对多个特定值进行聚合，使用 Filter Aggreagtion 只能进行多次请求。&lt;/p&gt;
&lt;p&gt;而使用 Filters Aggreagation 就可以解决上述的问题，它可以指定多个过滤条件，也是说可以对多个特定值进行聚合。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GET /cars/_search?size=0
{
  &quot;size&quot;: 0,
  &quot;aggs&quot; : {
    &quot;cars&quot; : {
      &quot;filters&quot; : {
        &quot;filters&quot; : {
          &quot;colorBucket&quot; :   { &quot;match&quot; : { &quot;color&quot; : &quot;red&quot;   }},
          &quot;brandBucket&quot; : { &quot;match&quot; : { &quot;brand&quot; : &quot;Audi&quot; }}
        }
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190923223701562-77635999.jpg&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;四histogram-aggreagtion&quot;&gt;&lt;span&gt;四、Histogram Aggreagtion&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;官方文档&lt;/strong&gt;：&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-histogram-aggregation.html&quot;&gt;Histogram Aggreagtion&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;概念&lt;/code&gt; Histogram与Terms聚合类似，都是数据分组，区别是Terms是按照Field的值分组，而Histogram可以按照指定的间隔对Field进行分组&lt;/p&gt;
&lt;h4 id=&quot;根据价格区间为10000分桶&quot;&gt;1、根据价格区间为10000分桶&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;GET /cars/_search?size=0
{
    &quot;aggs&quot; : {
        &quot;prices&quot; : {
            &quot;histogram&quot; : {
                &quot;field&quot; : &quot;price&quot;,
                &quot;interval&quot; : 10000
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190923223712384-1234879270.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;根据价格区间为10000分桶同时如果桶中没有文档就不显示桶&quot;&gt;2、根据价格区间为10000分桶，同时如果桶中没有文档就不显示桶&lt;/h4&gt;
&lt;p&gt;上面的分桶我们可以发现价格在5000～6000 的文档没有也显示为0，我们想把如果桶中没有文档就不显示该桶&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GET /cars/_search?size=0
{
    &quot;aggs&quot; : {
        &quot;prices&quot; : {
            &quot;histogram&quot; : {
                &quot;field&quot; : &quot;price&quot;,
                &quot;interval&quot; : 10000,
                 &quot;min_doc_count&quot; : 1
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190923223722702-222942277.jpg&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;五range-aggregation&quot;&gt;&lt;span&gt;五、Range Aggregation&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;官方文档&lt;/strong&gt;：&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-range-aggregation.html&quot;&gt;Range Aggregation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;概念&lt;/code&gt;: 根据用户传递的范围参数作为桶，进行相应的聚合。在同一个请求中，可以传递多组范围，每组范围作为一个桶。&lt;/p&gt;
&lt;h4 id=&quot;根据价格区间分桶&quot;&gt;1、根据价格区间分桶&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;GET /cars/_search?size=0
{
    &quot;aggs&quot; : {
        &quot;price_ranges&quot; : {
            &quot;range&quot; : {
                &quot;field&quot; : &quot;price&quot;,
                &quot;ranges&quot; : [
                    { &quot;to&quot; : 50000 },
                    { &quot;from&quot; : 5000, &quot;to&quot; : 80000 },
                    { &quot;from&quot; : 80000 }
                ]
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190923223732005-152251744.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们也可以指定key的名称&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GET /cars/_search?size=0
{
    &quot;aggs&quot; : {
        &quot;price_ranges&quot; : {
            &quot;range&quot; : {
                &quot;field&quot; : &quot;price&quot;,
                &quot;ranges&quot; : [
                    { &quot;key&quot; : &quot;xiaoyu&quot;,  &quot;to&quot; : 50000 },
                    {  &quot;key&quot; : &quot;baohan&quot;, &quot;from&quot; : 5000, &quot;to&quot; : 80000 },
                    {  &quot;key&quot; : &quot;dayu&quot;, &quot;from&quot; : 80000 }
                ]
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190923223745334-496705400.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;六-date-aggregation&quot;&gt;&lt;span&gt;六、 Date Aggregation&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;官方文档&lt;/strong&gt;： &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-datehistogram-aggregation.html&quot;&gt;Date Histogram Aggregation&lt;/a&gt; 和 &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-daterange-aggregation.html&quot;&gt;Date Range Aggregation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Date Histogram概念&lt;/code&gt; 针对于时间格式数据的直方图聚合，基本的特性与 Histogram Aggregation 一致。&lt;/p&gt;
&lt;h4 id=&quot;按月分桶显示每个月的销量&quot;&gt;1、按月分桶显示每个月的销量&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt; 官方文档这里不是interval而是calendar_interval，但是按照这样操作会报错，不知道是什么原因&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;POST /cars/_search?size=0
{
    &quot;aggs&quot; : {
        &quot;sales_over_time&quot; : {
            &quot;date_histogram&quot; : {
                &quot;field&quot; : &quot;sellTime&quot;,
                &quot;interval&quot; : &quot;1M&quot;,
                &quot;format&quot; : &quot;yyyy-MM-dd&quot; 
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190923223754438-834042842.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;根据指定时间区间分桶&quot;&gt;2、根据指定时间区间分桶&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Date Range概念&lt;/code&gt; ：针对于时间格式数据的范围聚合，基本的特性与 Range Aggreagtion 一致。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;POST /cars/_search?size=0
{
    &quot;aggs&quot;: {
        &quot;range&quot;: {
            &quot;date_range&quot;: {
                &quot;field&quot;: &quot;sellTime&quot;,
                &quot;format&quot;: &quot;MM-yyyy&quot;,
                &quot;ranges&quot;: [
                    { &quot;to&quot;: &quot;now-10M/M&quot; }, 
                    { &quot;from&quot;: &quot;now-10M/M&quot; } 
                ]
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的意思是10个月前的分为一个桶，10个月前之后的分为一个桶&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190923223804604-1709057873.png&quot;/&gt;&lt;/p&gt;

&lt;h3 id=&quot;参考&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1、Elasticsearch核心技术与实战---阮一鸣(eBay Pronto平台技术负责人&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html&quot;&gt;ES7.3版官方聚合查询API&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://my.oschina.net/bingzhong/blog/1917915&quot;&gt;Elasticsearch聚合——Bucket Aggregations&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;https://www.jianshu.com/p/f79309adb63b&quot;&gt;ElasticSearch-聚合bucket&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt; 我相信，无论今后的道路多么坎坷，只要抓住今天，迟早会在奋斗中尝到人生的甘甜。抓住人生中的一分一秒，胜过虚度中的一月一年！(14）&lt;/code&gt;
&lt;/pre&gt;

</description>
<pubDate>Mon, 23 Sep 2019 14:56:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>Elasticsearch(9) 聚合查询(Bucket聚合) 上一篇讲了Elasticsearch聚合查询中的 Metric聚合 ： 'Elasticsearch(8) 聚合查询(Metric聚合)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qdhxhz/p/11575408.html</dc:identifier>
</item>
<item>
<title>【数据结构】什么是AVL树 - 写代码的木公</title>
<link>http://www.cnblogs.com/54chensongxia/p/11575467.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/54chensongxia/p/11575467.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;二叉查找树的一个局限性就是有可能退化成一个链表，这种情况下二叉查找树的效率就会急剧下降变成0(n)。而AVL树可以很好地解决BST的这种困境。本篇博客会介绍AVL树的基本特点和相关操作。&lt;/p&gt;
&lt;p&gt;文章参考自博客：&lt;a href=&quot;https://www.jianshu.com/p/a47d88f962e0&quot;&gt;二叉树-你可能需要知道的知识点&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;什么是avl树-1&quot;&gt;1. 什么是AVL树&lt;/h2&gt;
&lt;p&gt;任何两个子树的高度差最大是1，这样的二叉树叫做AVL树。&lt;/p&gt;
&lt;p&gt;先来确定几个概念：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;平衡因子：将二叉树上节点的左子树高度减去右子树高度的值称为该节点的平衡因子BF(Balance Factor)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;最小不平衡子树：距离插入节点最近的，且平衡因子的绝对值大于1的节点为根的子树。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775037/201909/1775037-20190923223420240-506440828.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;左边二叉树的节点45的BF = 1，插入节点43后，节点45的BF=2。&lt;br/&gt;节点45是距离插入点43最近的BF不在[-1,1]范围内的节点，因此以节点45为根的子树为最小不平衡子树。&lt;/p&gt;
&lt;h2 id=&quot;节点的实现&quot;&gt;2. 节点的实现&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class AVLTreeNode&amp;lt;T extends Comparable&amp;gt; {

    // 存储的数据-用于排序
    T key;

    // 节点高度-用于计算父节点的BF
    int height;

    // 左儿子 &amp;amp; 右儿子
    AVLTreeNode&amp;lt;T&amp;gt; left;
    AVLTreeNode&amp;lt;T&amp;gt; right;
    
    public AVLTreeNode() {
    }

    public AVLTreeNode(T key, AVLTreeNode&amp;lt;T&amp;gt; left, AVLTreeNode&amp;lt;T&amp;gt; right) {
        this.key = key;
        this.left = left;
        this.right = right;
        this.height = 0;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;节点的定义还是比较简单的，相对于之前的定义多了一个height属性用于计算父节点的BF。&lt;/p&gt;
&lt;p&gt;树的定义&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class AVLTree&amp;lt;T extends Comparable&amp;gt; {
    // 定义树的根节点
    AVLTreeNode&amp;lt;T&amp;gt; root;

    public AVLTree() {
        root = null;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取树的高度&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public int height() {
        return height(root);
    }

    private int height(AVLTreeNode&amp;lt;T&amp;gt; tree) {
        if (tree != null){
            return tree.height;
        }
        return 0;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本文章将空树的高度定义为0，高度以树的层次为准，根节点的高度为1，依次类推。&lt;/p&gt;
&lt;h2 id=&quot;avl树的调整&quot;&gt;3. AVL树的调整&lt;/h2&gt;
&lt;p&gt;如果在AVL树中进行插入或删除节点后，可能导致AVL树失去平衡。这种不平衡可能出现在下面四种情况中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对a的左儿子的左子树进行一次插入。（LL）&lt;/li&gt;
&lt;li&gt;对a的左儿子的右子树进行一次插入。（LR）&lt;/li&gt;
&lt;li&gt;对a的右儿子的左子树进行一次插入。（RL）&lt;/li&gt;
&lt;li&gt;对a的右儿子的右子树进行一次插入。（RR）&lt;br/&gt;其中1、4是关于a点的镜像对称，2、3是关于a点的镜像对称。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第一种情况（1、4）需要通过对树的一次单旋转完成调整。&lt;br/&gt;第二种情况（2、3）需要通过对树的一次双旋转完成调整。&lt;/p&gt;
&lt;h3 id=&quot;ll旋转&quot;&gt;3.1 LL旋转&lt;/h3&gt;
&lt;p&gt;在左子树上插入左孩子导致AVL树失衡,&quot;根的左子树的高度&quot;比&quot;根的右子树的高度&quot;大2。针对该情况，我们需要进行单右旋转来完成对树的调整。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775037/201909/1775037-20190923224251937-1197190382.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中左边是旋转之前的树，右边是旋转之后的树。从中可以发现，旋转之后的树又变成了AVL树，而且该旋转只需要一次即可完成。&lt;br/&gt;对于LL旋转，你可以这样理解为：LL旋转是围绕&quot;失去平衡的AVL根节点&quot;进行的，也就是节点4；而且由于是LL情况，就将节点4进行一次顺时针旋转。&lt;/p&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * 进行一次单右旋转
     *
     * @param node 最小失衡树根节点
     */
    private AVLTreeNode&amp;lt;T&amp;gt; rightRotation(AVLTreeNode&amp;lt;T&amp;gt; node) {
        AVLTreeNode&amp;lt;T&amp;gt; left = node.left;
        node.left = left.right;
        left.right = node;
        // 更新高度
        node.height = Math.max(height(node.left), height(node.right)) + 1;
        left.height = Math.max(height(left.left), height(left.right)) + 1;
        return left;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;rr旋转&quot;&gt;3.2 RR旋转&lt;/h3&gt;
&lt;p&gt;在右子树插入右孩子导致AVL失衡时，我们需要进行单左旋调整。旋转围绕最小失衡子树的根节点进行。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775037/201909/1775037-20190923224643336-742382300.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * 进行一次单左旋转
     *
     * @param node 最小失衡树根节点
     */
    private AVLTreeNode&amp;lt;T&amp;gt; leftRotation(AVLTreeNode&amp;lt;T&amp;gt; node) {
        AVLTreeNode&amp;lt;T&amp;gt; right = node.right;
        node.right = right.left;
        right.left = node;

        // 更新高度
        node.height = Math.max(height(node.left), height(node.right)) + 1;
        right.height = Math.max(height(right.left), height(right.right)) + 1;

        return right;

    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;rl旋转&quot;&gt;3.3 RL旋转&lt;/h3&gt;
&lt;p&gt;“在右子树上插入左孩子导致AVL树失衡&quot;,此时我们需要进行先右旋后左旋的调整。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775037/201909/1775037-20190923224827893-1410255606.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    /**
     * 先右旋后左旋
     *
     * @param node 失衡树根节点
     * @return 旋转后的根节点
     */
    private AVLTreeNode&amp;lt;T&amp;gt; rightLeftRotation(AVLTreeNode&amp;lt;T&amp;gt; node) {
        node.right = rightRoation(node.right);

        return leftRoation(node);

    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;lr旋转&quot;&gt;3.4 LR旋转&lt;/h3&gt;
&lt;p&gt;“在左子树上插入右孩子导致AVL树失衡&quot;,此时我们需要进行先左旋后右旋的调整。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775037/201909/1775037-20190923224933833-1255675592.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    /**
     * 先左旋后右旋
     *
     * @param node 失衡树根节点
     * @return 旋转后的根节点
     */
    private AVLTreeNode&amp;lt;T&amp;gt; leftRightRotation(AVLTreeNode&amp;lt;T&amp;gt; node) {
        node.left = leftRoation(node.left);

        return rightLeftRoation(node);

    }


&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 23 Sep 2019 14:51:00 +0000</pubDate>
<dc:creator>写代码的木公</dc:creator>
<og:description>什么是AVL树 [TOC] 二叉查找树的一个局限性就是有可能退化成一个链表，这种情况下二叉查找树的效率就会急剧下降变成0(n)。而AVL树可以很好地解决BST的这种困境。本篇博客会介绍AVL树的基本特</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/54chensongxia/p/11575467.html</dc:identifier>
</item>
<item>
<title>理解 Spring 注解编程模型 - justmehyp</title>
<link>http://www.cnblogs.com/justmehyp/p/11575394.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/justmehyp/p/11575394.html</guid>
<description>&lt;p&gt;Spring 中有一个概念叫「元注解」(Meta-Annotation)，通过元注解，实现注解的「派生性」，官方的说法是「Annotation Hierarchy」。&lt;/p&gt;
&lt;h2&gt;什么是元注解&lt;/h2&gt;
&lt;p&gt;所谓元注解，即标注在注解上的注解。这种方式所形成的注解层级结构中，元注解在层级结构的上面，我叫它父注解(Super Annotation)， 被注解的注解在层级结构的下面，叫它子注解(Sub Annotation）。引入元注解的目的是为了实现属性重写(Attribute Override) 的目的。&lt;/p&gt;
&lt;p&gt;举个简单的例子：&lt;br/&gt;有 一个类 Home 和 2 个注解，1 个叫 @Parent，另一个叫 @Child ，@Parent 标注在 @Child 上，@Child 标注在 Home 上，它们都只有一个属性，叫 name， 如果 @Parent.name 的默认值是 'John'，而 @Child.name 的默认值是 'Jack'。&lt;br/&gt;这时，从 Home 上获取 @Child.name，应该返回 'Jack'，这毫无悬念。&lt;br/&gt;那么，如果获取 @Parent.name，应该返回什么呢？根据 Spring 注解的「派生性」，@Child.name override @Parent.name，所以返回结果也是 'Jack'。&lt;/p&gt;
&lt;p&gt;上述例子中的类和注解，代码大致如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Parent {
    String name() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;John&quot;&lt;span&gt;;
}

@Parent
@&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Child {
    String name() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;Jack&quot;&lt;span&gt;;
}

@Child
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Home { }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注解层级结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Parent
    @Child
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相对于「属性重写」，还有另一个概念是「属性别名」(Alias)，属性别名之间是互相等价的。&lt;br/&gt;我们给上面的 @Child 加一个属性 value，并且使用 @AliasFor ，使 @Child.name 和 @Child.value 互相成为别名，并且默认值为空字符串：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Child {
    @AliasFor(&lt;/span&gt;&quot;name&quot;&lt;span&gt;)
    String value() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
 
    @AliasFor(&lt;/span&gt;&quot;value&quot;&lt;span&gt;)
    String name() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;标注在 Home 上时，给 @Child.value 设置值为 &quot;Jack&quot;:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@Child(&quot;Jack&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Home { }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时，无论是获取 @Child.name 还是获取 @Child.value，其结果总是相同的，都是 &quot;Jack&quot;。说明了属性别名之间的等价性。&lt;/p&gt;
&lt;h2&gt;属性别名 和 属性重写&lt;/h2&gt;
&lt;p&gt;属性别名 和 属性重写 其实是两个完全不同的概念，但是如果不加区分，模糊概念的话，就会对一些现象不符合预期而感到意外。 考虑以下案例，分别给出 @A.a1、@A.a2、@B.a1、@B.b、@C.c、@C.b 的值：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-java&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
@&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; A {
    String a1() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;1&quot;&lt;span&gt;;
    String a2() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;1&quot;&lt;span&gt;;
}

@A
@&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; B {
    String a1() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;2&quot;&lt;span&gt;;
    
    @AliasFor(value &lt;/span&gt;= &quot;a2&quot;, annotation = A.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    String b() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;2&quot;&lt;span&gt;;
}

@B
@&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; C {
    @AliasFor(value &lt;/span&gt;= &quot;a1&quot;, annotation = B.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)   
    String c() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;3&quot;&lt;span&gt;;

    String b() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;3&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在我没有弄清概念之前，我觉得答案应该是：@A.a1、@A.a2、@B.a1、@B.b、@C.c、@C.b 全都是 &quot;3&quot;。&lt;br/&gt;理由如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@C.c 是 @B.a1 的别名，@B.a1 重写 @A.a1 ，所以这 3 者是一条链上的，它们的值应该相等, 是 &quot;3&quot;。&lt;/li&gt;
&lt;li&gt;@C.b 重写 @B.b，@B.b 是 @A.a2 的别名，所以这 3 者 也是一条链上的，它们的值也应该相等，是 &quot;3&quot;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而结果却是，我错了，@B.a1、@B.b、@C.c、@C.b 的值是 &quot;3&quot;， 但 @A.a1、@A.a2 的值是 &quot;2&quot;。&lt;br/&gt;至于为什么，我们先来认真理解一下 属性别名 和 属性重写 这 2 个概念吧。&lt;/p&gt;
&lt;p&gt;援引官方 Wiki &lt;code&gt;https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model&lt;/code&gt;, 其中有关于这两个概念的澄清。在 「Attribute Aliases and Overrides」 一节中，官方原文如下：&lt;/p&gt;
&lt;p&gt;An attribute alias is an alias from one annotation attribute to another annotation attribute. Attributes within a set of aliases can be used interchangeably and are treated as equivalent. Attribute aliases can be categorized as follows.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Explicit Aliases: if two attributes in one annotation are declared as aliases for each other via @AliasFor, they are explicit aliases.&lt;/li&gt;
&lt;li&gt;Implicit Aliases: if two or more attributes in one annotation are declared as explicit overrides for the same attribute in a meta-annotation via @AliasFor, they are implicit aliases.&lt;/li&gt;
&lt;li&gt;Transitive Implicit Aliases: given two or more attributes in one annotation that are declared as explicit overrides for attributes in meta-annotations via @AliasFor, if the attributes effectively override the same attribute in a meta-annotation following the law of transitivity, they are transitive implicit aliases.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;An attribute override is an annotation attribute that overrides (or shadows) an annotation attribute in a meta-annotation. Attribute overrides can be categorized as follows.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Implicit Overrides: given attribute A in annotation @One and attribute A in annotation @Two, if @One is meta-annotated with @Two, then attribute A in annotation @One is an implicit override for attribute A in annotation @Two based solely on a naming convention (i.e., both attributes are named A).&lt;/li&gt;
&lt;li&gt;Explicit Overrides: if attribute A is declared as an alias for attribute B in a meta-annotation via @AliasFor, then A is an explicit override for B.&lt;/li&gt;
&lt;li&gt;Transitive Explicit Overrides: if attribute A in annotation @One is an explicit override for attribute B in annotation @Two and B is an explicit override for attribute C in annotation @Three, then A is a transitive explicit override for C following the law of transitivity.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;属性别名，有 3 种， 分别是 显式别名，隐式别名 和 传递隐式别名, 「属性别名」 只能发生在同一个注解内部。比如：&lt;/p&gt;
&lt;p&gt;显式别名(互相@AliasFor)，@A.a1 和 @A.a2，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-java&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; A {
    @AliasFor(&lt;/span&gt;&quot;a2&quot;&lt;span&gt;)
    String a1() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;

    @AliasFor(&lt;/span&gt;&quot;a1&quot;&lt;span&gt;)
    String a2() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;隐式别名(@AliasFor到同一个属性)，@B.b1 和 @B.b2&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-java&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
@&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; A {
    String a() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
}

@A
@&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; B {
    @AliasFor(value &lt;/span&gt;= &quot;a&quot;, annotation = A.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    String b1() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;

    @AliasFor(value &lt;/span&gt;= &quot;a&quot;, annotation = A.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    String b2() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;传递隐式别名(最终@AliasFor到同一个属性) @C.c1 和 @C.c2&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-java&quot; readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
@&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; A {
    String a() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
}

@A
@&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; B {
    @AliasFor(value &lt;/span&gt;= &quot;a&quot;, annotation = A.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    String b() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
}

@B
@&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; C {
    @AliasFor(value &lt;/span&gt;= &quot;a&quot;, annotation = A.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    String c1() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;

    @AliasFor(value &lt;/span&gt;= &quot;b&quot;, annotation = B.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    String c2() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;属性重写，也有 3 种，分别是 隐式重写，显式重写 和 传递显式重写，「属性重写」只能发生在注解之间。比如：&lt;/p&gt;
&lt;p&gt;隐式重写(同名属性)， @B.a 重写 @A.a&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-java&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; A {
    String a() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
}

@A
@&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; B {
    String a() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;显式重写(需要@AliasFor)，@B.b 重写 @A.a&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-java&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
@&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; A {
    String a() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
}

@A
@&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; B {
    @AliasFor(value &lt;/span&gt;= &quot;a&quot;, annotation = A.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    String b() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;传递显式重写(需要 @AliasFor)，由于 @C.c 重写 @B.b， @B.b 重写 @A.a， 所以 @C.c 也 重写 @A.a&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-java&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
@&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; A {
    String a() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
}

@A
@&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; B {
    @AliasFor(value &lt;/span&gt;= &quot;a&quot;, annotation = A.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    String b() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
}

@B
@&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; C {
    @AliasFor(value &lt;/span&gt;= &quot;b&quot;, annotation = B.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    String c() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;理解清楚之后，我们回到刚才的题目，样例重贴如下：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-java&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
@&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; A {
    String a1() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;1&quot;&lt;span&gt;;

    String a2() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;1&quot;&lt;span&gt;;
}

@A
@&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; B {
    String a1() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;2&quot;&lt;span&gt;;
    
    @AliasFor(value &lt;/span&gt;= &quot;a2&quot;, annotation = A.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    String b() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;2&quot;&lt;span&gt;;
}

@B
@&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; C {
    @AliasFor(value &lt;/span&gt;= &quot;a1&quot;, annotation = B.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)   
    String c() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;3&quot;&lt;span&gt;;

    String b() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;3&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;解答步骤是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于注解 @C，@C.c = &quot;3&quot;, @C.b = &quot;3&quot;&lt;/li&gt;
&lt;li&gt;对于注解 @B, @B.a1 被 @C.c 显式重写, 所以 @B.a1 = @C.c = &quot;3&quot;； @B.b 被 @C.b 隐式重写，所以 @B.b = @C.b = &quot;3&quot;&lt;/li&gt;
&lt;li&gt;对于注解 @A, @A.a1 被 @B.a1 隐式重写，所以 @A.a1 = @B.a1 = &quot;2&quot;; @A.a2 被 @B.b 显式重写，所以 @A.a2 = @B.b = &quot;2&quot;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以看到 @A 和 @C 之间没有任何关系。这里也根本没有「属性别名」的存在，不是用了 @AliasFor 就是 「属性别名」的。&lt;br/&gt;对于「显式传递重写」，像上面 &quot;@A.a1 被 @B.a1 隐式重写， @B.a1 被 @C.c 显式重写&quot;，或者 &quot;@A.a2 被 @B.b 显式重写， B.b 被 @C.b 隐式重写&quot;， 重写关系是不会传递的。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;属性别名，有 3 种， 分别是 显式别名，隐式别名 和 传递隐式别名, 「属性别名」 只能发生在同一个注解内部。 属性重写，也有 3 种，分别是 隐式重写，显式重写 和 传递显式重写，「属性重写」只能发生在注解之间。&lt;/p&gt;
&lt;h2&gt;后记&lt;/h2&gt;
&lt;p&gt;Spring 对于注解编程模型的代码实现，主要在 AnnotatedElementUtils 这个类中，做试验可以使用这个方法：AnnotatedElementUtils#getMergedAnnotationAttributes。&lt;/p&gt;
&lt;p&gt;需要注意的是，「隐式重写」不适用于 value 属性，貌似 value 属性是一个相对特殊的属性。&lt;/p&gt;
&lt;p&gt;以下示例， @B.value 不会 隐式重写 @A.value&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-java&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; A {
    String value() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;a&quot;&lt;span&gt;;
}

@A
@&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; B {
    String value() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;b&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;但只要属性名不是 value，都可以 隐式重写 , @B.xxx 隐式重写 @A.xxx&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-java&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; A {
    String xxx() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;a&quot;&lt;span&gt;;
}

@A
@&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; B {
    String xxx() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;b&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;我跟了以下源码，发现源码中确实对 value 属性做了特殊判断，代码位置在 &lt;code&gt;org.springframework.core.annotation.AnnotatedElementUtils.MergedAnnotationAttributesProcessor#postProcess&lt;/code&gt; 方法中，代码片段如下；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Implicit annotation attribute override based on convention&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!AnnotationUtils.VALUE.equals(attributeName) &amp;amp;&amp;amp;&lt;span&gt; attributes.containsKey(attributeName)) {
        overrideAttribute(element, annotation, attributes, attributeName, attributeName);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，AnnotationUtils.VALUE 是一个常量，其值为 &quot;value&quot;。暂时没有找到官方说明为什么要对 value 属性做特殊处理。猜测是很多注解只有一个属性， 为了编程方便，因为不需要 @A(value = &quot;hello world) 这样使用， 只需要 @A(&quot;hello world&quot;) 即可。这种情况下，如果隐式重写，可能不是编码者想要的结果。&lt;/p&gt;
&lt;p&gt;值得一提的是，显式重写 没有这种特殊处理，以下示例 @B.value 会显式重写 @A.value:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-java&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; A {

    String value() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;a&quot;&lt;span&gt;;
}

@A
@&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; B {

    @AliasFor(annotation &lt;/span&gt;= A.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    String value() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;b&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;本文讨论所涉及的 Spring Boot 版本 &amp;gt;= 2.0.2.RELEASE。&lt;/p&gt;

</description>
<pubDate>Mon, 23 Sep 2019 14:35:00 +0000</pubDate>
<dc:creator>justmehyp</dc:creator>
<og:description>理解 Spring 注解编程模型 Spring 中有一个概念叫「元注解」(Meta-Annotation)，通过元注解，实现注解的「派生性」，官方的说法是「Annotation Hierarchy」。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/justmehyp/p/11575394.html</dc:identifier>
</item>
<item>
<title>闭包与作用域再次深究 - 牙疼哥哥</title>
<link>http://www.cnblogs.com/pomelott/p/11575027.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pomelott/p/11575027.html</guid>
<description>&lt;p&gt;最近看到一个有意思的函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
        function test (arr) {
            var temp = []
            for (var i =0;  i&amp;lt;arr.length; i++) {
                (function() {
                    var j = i;
                    temp[i] = function () {
                        return j
                    }
                })()
                
            }
            return temp
        }　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么以下的结果会打印出什么呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
var arr = [1,2,3,4,5]
var arrFn = test(arr)
console.log(arrFn[0])　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果是：0；&lt;/p&gt;
&lt;p&gt;那么继续test函数换成以下两种又会是什么结果呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
        function test2 (arr) {
            var temp = []
            for (var i =0;  i&amp;lt;arr.length; i++) {
                
                temp[i] = function () {
                    return i
                }
                
            }
            return temp
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
        function test3 (arr) {
            var temp = []
            for (var i =0;  i&amp;lt;arr.length; i++) {
                (function() {
                    temp[i] = function () {
                        return i
                    }
                })()
                
            }
            return temp
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;test2是网上比较常见的，结果是我们在读取i的时候，i已经全部变为5；test3和test只有两行代码不同，但是结果却完全不一样。&lt;/p&gt;
&lt;p&gt;之前曾经理解是因为我们调用的时候for循环已经执行完，所以会拿到i为5。但是其实这只是表象，最核心的其实只有一句话：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;闭包通过引用而不是值（非引用）来获取他们外部的变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为是引用类型，所以在for执行完之后，i变为了5，引用类型也就继而变为5.&lt;/p&gt;
&lt;p&gt;在test中添加了一行可以验证的代码就是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
var j = i;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过在局部作用域声明非引用类型，将单次循环是的引用类型保存下来，那么就能获取我们想要的结果了。&lt;/p&gt;
&lt;p&gt;还有其他方法，通过自执行函数传递参数，将引用类型变为非引用类型都是一个原理：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
        function test4 (arr) {
            var temp = []
            for (var i =0;  i&amp;lt;arr.length; i++) {
                (function(j) {
                    temp[i] = function () {
                        return j;
                    }
                })(i)
                
            }
            return temp
        }　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;其次就是在IIFE来创建局部作用域的时候，需要注意不能再作用域外部使用break与continue，这样的写法是不合法的。&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 23 Sep 2019 13:36:00 +0000</pubDate>
<dc:creator>牙疼哥哥</dc:creator>
<og:description>最近看到一个有意思的函数 那么以下的结果会打印出什么呢？ 结果是：0； 那么继续test函数换成以下两种又会是什么结果呢？ test2是网上比较常见的，结果是我们在读取i的时候，i已经全部变为5；te</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pomelott/p/11575027.html</dc:identifier>
</item>
<item>
<title>spring boot 整合mybatis 的xml版本【包括逆向工程以及分页插件】 - ericling</title>
<link>http://www.cnblogs.com/ericling/p/11574996.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ericling/p/11574996.html</guid>
<description>&lt;p&gt;逆向工程很方便，可以直接根据数据库和配置文件生成pojo，mapper接口和相应的映射文件。&lt;/p&gt;
&lt;p&gt;xml版本和全注解版本其实差不多，大部分情况下，都会保留xml文件方便其他人去扩展新的dml方法。&lt;/p&gt;
&lt;p&gt;文章旨在记录ssm项目的搭建过程，除了本文所提到的逆向工程极大的方便了应用的开发效率，还有两个比较常用的mybatis扩展框架。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;common mapper https://github.com/abel533/Mapper/wiki&lt;/li&gt;
&lt;li&gt;mybatisplus https://mp.baomidou.com/guide/quick-start.html&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;好了，废话不多说，下面就是完整的搭建过程。&lt;/p&gt;
&lt;p&gt;首先是项目的依赖，完整的pom文件如下：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;com.example&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;demo-boot-mybatis-xml&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;

    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.1.3.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
        &amp;lt;project.reporting.outputEncoding&amp;gt;UTF-8&amp;lt;/project.reporting.outputEncoding&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.0.1&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;5.1.35&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- 分页插件 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.github.pagehelper&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;pagehelper-spring-boot-starter&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.2.10&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- alibaba的druid数据库连接池 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;druid-spring-boot-starter&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.1.16&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
            &amp;lt;!-- mybatis generator 自动生成代码插件 --&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.mybatis.generator&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;mybatis-generator-maven-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;1.3.5&amp;lt;/version&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;configurationFile&amp;gt;${basedir}/src/main/resources/generator/generatorConfig.xml&amp;lt;/configurationFile&amp;gt;
                    &amp;lt;overwrite&amp;gt;true&amp;lt;/overwrite&amp;gt;
                    &amp;lt;verbose&amp;gt;true&amp;lt;/verbose&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;


&amp;lt;/project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;application.yml文件配置&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;server:
  port: 8080

spring:

  datasource:
    name: test
    type: com.alibaba.druid.pool.DruidDataSource
    druid:
      driver-class-name: com.mysql.jdbc.Driver
      url: jdbc:mysql://127.0.0.1:3306/db_test?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;allowPublicKeyRetrieval=true&amp;amp;useSSL=false&amp;amp;serverTimezone=GMT%2B8
      username: root
      password: root


mybatis:
  mapper-locations: classpath:mapper/*.xml  #注意：一定要对应mapper映射xml文件的所在路径
  type-aliases-package: com.example.model  # 注意：对应实体类的路径

#pagehelper分页插件
pagehelper:
  helperDialect: mysql
  reasonable: true
  supportMethodsArguments: true
  params: count=countSql
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试的数据库脚本&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE TABLE t_user(
  user_id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
  user_name VARCHAR(255) NOT NULL ,
  password VARCHAR(255) NOT NULL ,
  phone VARCHAR(255) NOT NULL
) ENGINE=INNODB AUTO_INCREMENT=1000 DEFAULT CHARSET=utf8;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置mybatis-generator自动生成代码的相关配置&lt;/p&gt;
&lt;p&gt;${basedir}/src/main/resources/generator/generatorConfig.xml&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE generatorConfiguration
        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&amp;gt;
&amp;lt;generatorConfiguration&amp;gt;
    &amp;lt;!-- 数据库驱动:选择你的本地硬盘上面的数据库驱动包--&amp;gt;
    &amp;lt;classPathEntry  location=&quot;D:\code\repository\mysql\mysql-connector-java\5.1.47\mysql-connector-java-5.1.47.jar&quot;/&amp;gt;
    &amp;lt;context id=&quot;DB2Tables&quot;  targetRuntime=&quot;MyBatis3&quot;&amp;gt;
        &amp;lt;commentGenerator&amp;gt;
            &amp;lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&amp;gt;
            &amp;lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&amp;gt;
            &amp;lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&amp;gt;
        &amp;lt;/commentGenerator&amp;gt;

        &amp;lt;!--数据库链接URL，用户名、密码 --&amp;gt;
        &amp;lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://127.0.0.1:3306/db_test?characterEncoding=utf-8&quot; userId=&quot;root&quot; password=&quot;root&quot;/&amp;gt;
        &amp;lt;javaTypeResolver&amp;gt;
            &amp;lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&amp;gt;
        &amp;lt;/javaTypeResolver&amp;gt;

        &amp;lt;!-- 生成模型的包名和位置--&amp;gt;
        &amp;lt;javaModelGenerator targetPackage=&quot;com.example.model&quot; targetProject=&quot;src/main/java&quot;&amp;gt;
            &amp;lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&amp;gt;
            &amp;lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&amp;gt;
        &amp;lt;/javaModelGenerator&amp;gt;

        &amp;lt;!-- 生成映射文件的包名和位置--&amp;gt;
        &amp;lt;sqlMapGenerator targetPackage=&quot;mapper&quot; targetProject=&quot;src/main/resources&quot;&amp;gt;
            &amp;lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&amp;gt;
        &amp;lt;/sqlMapGenerator&amp;gt;

        &amp;lt;!-- 生成DAO的包名和位置--&amp;gt;
        &amp;lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.example.mapper&quot; targetProject=&quot;src/main/java&quot;&amp;gt;
            &amp;lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&amp;gt;
        &amp;lt;/javaClientGenerator&amp;gt;


        &amp;lt;!-- 要生成的表 tableName是数据库中的表名或视图名 domainObjectName是实体类名--&amp;gt;
        &amp;lt;table tableName=&quot;t_user&quot; domainObjectName=&quot;User&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;/&amp;gt;
    &amp;lt;/context&amp;gt;
&amp;lt;/generatorConfiguration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行maven插件org.mybatis.generator:mybatis-generator-maven-plugin:1.3.2:generate&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&quot;C:\Program Files\Java\jdk1.8.0_191\bin\java.exe&quot; -Dmaven.multiModuleProjectDirectory=D:\ideaworkspace_demo\demo-boot-mybatis-xml -Dmaven.home=D:\software\idea\plugins\maven\lib\maven3 -Dclassworlds.conf=D:\software\idea\plugins\maven\lib\maven3\bin\m2.conf -javaagent:D:\software\idea\lib\idea_rt.jar=6721:D:\software\idea\bin -Dfile.encoding=UTF-8 -classpath D:\software\idea\plugins\maven\lib\maven3\boot\plexus-classworlds-2.5.2.jar org.codehaus.classworlds.Launcher -Didea.version=2018.3.5 org.mybatis.generator:mybatis-generator-maven-plugin:1.3.2:generate
[INFO] Scanning for projects...
[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building demo-boot-mybatis-xml 1.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- mybatis-generator-maven-plugin:1.3.2:generate (default-cli) @ demo-boot-mybatis-xml ---
[INFO] Connecting to the Database
Tue Apr 09 11:16:14 CST 2019 WARN: Establishing SSL connection without server's identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn't set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to 'false'. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.
[INFO] Introspecting table t_user
log4j:WARN No appenders could be found for logger (org.mybatis.generator.internal.db.DatabaseIntrospector).
log4j:WARN Please initialize the log4j system properly.
log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.
[INFO] Generating Record class for table t_user
[INFO] Generating Mapper Interface for table t_user
[INFO] Generating SQL Map for table t_user
[INFO] Saving file UserMapper.xml
[INFO] Saving file User.java
[INFO] Saving file UserMapper.java
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 1.180 s
[INFO] Finished at: 2019-04-09T11:16:14+08:00
[INFO] Final Memory: 15M/245M
[INFO] ------------------------------------------------------------------------

Process finished with exit code 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上步骤就可以使用generator自动生成model和dao层的代码了。&lt;/p&gt;
&lt;p&gt;把mybatis的mapper加入到IoC容器中。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.example;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
//此注解会把该包下的mapper添加到spring的ioc容器中
@MapperScan(&quot;com.example.mapper&quot;)
public class MybatisApplication {
    public static void main(String[] args) {
        SpringApplication.run(MybatisApplication.class, args);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.example.mapper;

import com.example.model.User;
import org.springframework.stereotype.Repository;

import java.util.List;

public interface UserMapper {
    int deleteByPrimaryKey(Integer userId);

    int insert(User record);

    int insertSelective(User record);

    User selectByPrimaryKey(Integer userId);

    int updateByPrimaryKeySelective(User record);

    int updateByPrimaryKey(User record);

    List&amp;lt;User&amp;gt; selectAll();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上就是项目的基本搭建过程,idea可能会提示mapper无法注入，因为idea并不知道MapperScan注解已经把那些接口添加到容器中了，实际并不影响正常运行。&lt;/p&gt;
&lt;p&gt;项目源码：https://github.com/lingEric/demo-boot-mybatis-xml&lt;/p&gt;
</description>
<pubDate>Mon, 23 Sep 2019 13:32:00 +0000</pubDate>
<dc:creator>ericling</dc:creator>
<og:description>逆向工程很方便，可以直接根据数据库和配置文件生成pojo，mapper接口和相应的映射文件。 xml版本和全注解版本其实差不多，大部分情况下，都会保留xml文件方便其他人去扩展新的dml方法。 文章旨</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ericling/p/11574996.html</dc:identifier>
</item>
</channel>
</rss>