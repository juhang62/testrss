<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>如何在ASP.NET Core中使用Azure Service Bus Queue - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/10760227.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/10760227.html</guid>
<description>&lt;blockquote readability=&quot;4.4083044982699&quot;&gt;
&lt;p&gt;原文：USING AZURE SERVICE BUS QUEUES WITH ASP.NET CORE SERVICES&lt;br/&gt;作者：&lt;a href=&quot;https://damienbod.com/author/damienbod/&quot;&gt;damienbod&lt;/a&gt;&lt;br/&gt;译文：如何在ASP.NET Core中使用Azure Service Bus Queue&lt;br/&gt;地址：&lt;a href=&quot;https://www.cnblogs.com/lwqlun/p/10760227.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/lwqlun/p/10760227.html&lt;/a&gt;&lt;br/&gt;作者：Lamond Lu&lt;br/&gt;源代码： &lt;a href=&quot;https://github.com/lamondlu/AzureServiceBusMessaging&quot; class=&quot;uri&quot;&gt;https://github.com/lamondlu/AzureServiceBusMessaging&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201904/65831-20190424064000213-1994864212.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文展示了如何使用Azure Service Bus Queue, 实现2个ASP.NET Core Api应用之间的消息传输。&lt;/p&gt;

&lt;p&gt;你可以从官网文档中了解到如何配置一个Azure Service Bus Queue.&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-create-namespace-portal&quot; class=&quot;uri&quot;&gt;https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-create-namespace-portal&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里我们使用Queue或者Topic来实现消息传输。Queue是一种消息传输类型，一旦一个消息被一个消费者接收了，该消息就会从Queue中被移除。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;与Queue不同，Topic提供的是一对多的通讯方式。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;整个应用的实现如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201904/65831-20190424063513187-1948883499.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Api 1负责发送消息&lt;/li&gt;
&lt;li&gt;Api 2负责监听Azure Service Bus，并处理接收到的消息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里我们首先需要引入** &lt;a href=&quot;https://www.nuget.org/packages/Microsoft.Azure.ServiceBus&quot;&gt;Microsoft.Azure.ServiceBus&lt;/a&gt; ** 程序集。&lt;strong&gt;&lt;a href=&quot;https://www.nuget.org/packages/Microsoft.Azure.ServiceBus&quot;&gt;Microsoft.Azure.ServiceBus&lt;/a&gt;&lt;/strong&gt;是Azure Service Bus的客户端库。针对Service Bus的连接字符串我们保存在项目的User Secret中。当部署项目的时候，我们可以使用Azure Key Valut来设置这个Secret值。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在Visual Studio中，右键点击API1, API2项目属性，选择Manage User Secrets就可以管理当前项目使用的所有私密信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了发送向Azure Service Bus Queue发送消息，我们需要创建一个&lt;code&gt;SendMessage&lt;/code&gt;方法，并接收一个消息参数。这里我们创建了一个我们自己的消息内容类型&lt;code&gt;MyPayload&lt;/code&gt;, 将当前该&lt;code&gt;MyPayload&lt;/code&gt;对象序列化成Json字符串， 添加到一个&lt;code&gt;Message&lt;/code&gt;对象中。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using Microsoft.Azure.ServiceBus;
using Microsoft.Extensions.Configuration;
using Newtonsoft.Json;
using System.Text;
using System.Threading.Tasks;
 
namespace ServiceBusMessaging
{
    public class ServiceBusSender
    {
        private readonly QueueClient _queueClient;
        private readonly IConfiguration _configuration;
        private const string QUEUE_NAME = &quot;simplequeue&quot;;
 
        public ServiceBusSender(IConfiguration configuration)
        {
            _configuration = configuration;
            _queueClient = new QueueClient(
            _configuration
                .GetConnectionString(&quot;ServiceBusConnectionString&quot;), 
                QUEUE_NAME);
        }
         
        public async Task SendMessage(MyPayload payload)
        {
            string data = JsonConvert.SerializeObject(payload);
            Message message = new Message(Encoding.UTF8.GetBytes(data));
 
            await _queueClient.SendAsync(message);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在API 1和API 2中，我们需要将&lt;code&gt;ServiceBusSender&lt;/code&gt;注册到应用程序的IOC容器中。这里为了测试方便，我们同时注册&lt;code&gt;Swagger&lt;/code&gt;服务。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc();
 
    services.AddScoped&amp;lt;ServiceBusSender&amp;gt;();
 
    services.AddSwaggerGen(c =&amp;gt;
    {
        c.SwaggerDoc(&quot;v1&quot;, new Info
        {
            Version = &quot;v1&quot;,
            Title = &quot;Payload View API&quot;,
        });
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们就可以在控制器中通过构造函数注入的方式使用这个服务了。&lt;/p&gt;
&lt;p&gt;在API1中，我们创建一个POST方法，这个方法会将API接收到&lt;code&gt;Payload&lt;/code&gt;对象发送到Azure Service Bus Queue中。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[HttpPost]
[ProducesResponseType(typeof(Payload), StatusCodes.Status200OK)]
[ProducesResponseType(typeof(Payload), StatusCodes.Status409Conflict)]
public async Task&amp;lt;IActionResult&amp;gt; Create([FromBody][Required]Payload request)
{
    if (data.Any(d =&amp;gt; d.Id == request.Id))
    {
        return Conflict($&quot;data with id {request.Id} already exists&quot;);
    }
 
    data.Add(request);
 
    // Send this to the bus for the other services
    await _serviceBusSender.SendMessage(new MyPayload
    {
        Goals = request.Goals,
        Name = request.Name,
        Delete = false
    });
 
    return Ok(request);
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;为了监听Azure Service Bus Queue, 并处理接收到的消息，我们创建了一个新类&lt;code&gt;ServiceBusConsumer&lt;/code&gt;，&lt;code&gt;ServiceBusConsumer&lt;/code&gt;实现了&lt;code&gt;IServiceBusConsumer&lt;/code&gt;接口。&lt;/p&gt;
&lt;p&gt;Queue的连接字符串是使用&lt;code&gt;IConfiguration&lt;/code&gt;读取的。 &lt;code&gt;RegisterOnMessageHandlerAndReceiveMessages&lt;/code&gt;方法负责注册消息处理程序&lt;code&gt;ProcessMessagesAsync&lt;/code&gt;处理消息。&lt;code&gt;ProcessMessagesAsync&lt;/code&gt;方法会将得到的消息转换成对象，并调用&lt;code&gt;IProcessData&lt;/code&gt;接口完成最终的消息处理。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using Microsoft.Azure.ServiceBus;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
 
namespace ServiceBusMessaging
{
    public interface IServiceBusConsumer
    {
        void RegisterOnMessageHandlerAndReceiveMessages();
        Task CloseQueueAsync();
    }
 
    public class ServiceBusConsumer : IServiceBusConsumer
    {
        private readonly IProcessData _processData;
        private readonly IConfiguration _configuration;
        private readonly QueueClient _queueClient;
        private const string QUEUE_NAME = &quot;simplequeue&quot;;
        private readonly ILogger _logger;
 
        public ServiceBusConsumer(IProcessData processData, 
            IConfiguration configuration, 
            ILogger&amp;lt;ServiceBusConsumer&amp;gt; logger)
        {
            _processData = processData;
            _configuration = configuration;
            _logger = logger;
            _queueClient = new QueueClient(
              _configuration.GetConnectionString(&quot;ServiceBusConnectionString&quot;), QUEUE_NAME);
        }
 
        public void RegisterOnMessageHandlerAndReceiveMessages()
        {
            var messageHandlerOptions = new MessageHandlerOptions(ExceptionReceivedHandler)
            {
                MaxConcurrentCalls = 1,
                AutoComplete = false
            };
 
            _queueClient.RegisterMessageHandler(ProcessMessagesAsync, messageHandlerOptions);
        }
 
        private async Task ProcessMessagesAsync(Message message, CancellationToken token)
        {
            var myPayload = JsonConvert.DeserializeObject&amp;lt;MyPayload&amp;gt;(Encoding.UTF8.GetString(message.Body));
            _processData.Process(myPayload);
            await _queueClient.CompleteAsync(message.SystemProperties.LockToken);
        }
 
        private Task ExceptionReceivedHandler(ExceptionReceivedEventArgs exceptionReceivedEventArgs)
        {
            _logger.LogError(exceptionReceivedEventArgs.Exception, &quot;Message handler encountered an exception&quot;);
            var context = exceptionReceivedEventArgs.ExceptionReceivedContext;
 
            _logger.LogDebug($&quot;- Endpoint: {context.Endpoint}&quot;);
            _logger.LogDebug($&quot;- Entity Path: {context.EntityPath}&quot;);
            _logger.LogDebug($&quot;- Executing Action: {context.Action}&quot;);
 
            return Task.CompletedTask;
        }
 
        public async Task CloseQueueAsync()
        {
            await _queueClient.CloseAsync();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;IProcessData&lt;/code&gt;接口存在于类库项目&lt;code&gt;ServiceBusMessaging&lt;/code&gt;中，它是用来处理消息的。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public interface IProcessData
{
    void Process(MyPayload myPayload);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Api 2中，我们创建一个&lt;code&gt;ProcessData&lt;/code&gt;类，它实现了&lt;code&gt;IProcessData&lt;/code&gt;接口。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class ProcessData : IProcessData
{
    public void Process(MyPayload myPayload)
    {
        DataServiceSimi.Data.Add(new Payload
        {
            Name = myPayload.Name,
            Goals = myPayload.Goals
        });
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;这里为了简单测试，我们创建了一个静态类&lt;code&gt;DataServiceSimi&lt;/code&gt;，其中存放了API2中所有保存&lt;code&gt;Payload&lt;/code&gt;对象。同时，我们还创建了一个新的控制器&lt;code&gt;ViewPayloadMessagesController&lt;/code&gt;，在其中添加了一个GET Action,并返回了静态类&lt;code&gt;DataServiceSimi&lt;/code&gt;中的所有数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[Route(&quot;api/[controller]&quot;)]
[ApiController]
public class ViewPayloadMessagesController : ControllerBase
{
    [HttpGet]
    [ProducesResponseType(StatusCodes.Status200OK)]
    public ActionResult&amp;lt;List&amp;lt;Payload&amp;gt;&amp;gt; Get()
    {
        return Ok(DataServiceSimi.Data);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后我们还需要将&lt;code&gt;ProcessData&lt;/code&gt;注册到API2的IOC容器中。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc();

    services.AddSingleton&amp;lt;IServiceBusConsumer, ServiceBusConsumer&amp;gt;();
    services.AddTransient&amp;lt;IProcessData, ProcessData&amp;gt;();
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;现在我们分别启用2个Api项目，并在Api 1的Swagger文档界面，调用POST请求，添加一个Payload&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201904/65831-20190424063528295-439703521.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;操作完成之后，我们访问Api 2的/api/ViewPayloadMessages, 获得结果如下，Api 1发出的消息出现在了Api 2的结果集中，这说明Api 2从Azure Service Bus Queue中获取了消息，并保存在了自己的静态类&lt;code&gt;DataServiceSimi&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201904/65831-20190424063534587-491136796.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 23 Apr 2019 22:40:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>原文：USING AZURE SERVICE BUS QUEUES WITH ASP.NET CORE SERVICES 作者： 'damienbod' 译文：如何在ASP.NET Core中使用Az</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/10760227.html</dc:identifier>
</item>
<item>
<title>Leetcode 1-10 - FANG_YANG</title>
<link>http://www.cnblogs.com/fydeblog/p/10760040.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fydeblog/p/10760040.html</guid>
<description>&lt;p&gt;这篇文章介绍Leetcode1到10题的解决思路和相关代码。&lt;/p&gt;
&lt;h2 id=&quot;two-sum&quot;&gt;1. Two sum&lt;/h2&gt;
&lt;p&gt;问题描述：给定一个整数数组，返回两个数字的索引，使它们加起来等于一个特定的目标。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常规方法：使用双重循环，第一重从左往右固定索引，计算需要查找的结果，第二层循环从固定索引出发依次向右查找第一层计算的结果。时间复杂度&lt;span class=&quot;math inline&quot;&gt;\(O(n^2)\)&lt;/span&gt;, 空间复杂度&lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;.&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def twoSum(nums: List[int], target: int) -&amp;gt; List[int]:
    nums_len = len(nums)
    for ind1 in range(nums_len):
        value = target - nums[ind1]
        for ind2 in range(ind1+1, nums_len):
            if value == nums[ind2]:
                return [ind1, ind2]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;行程哈希表(第一次行程遍历nums生成字典，第二次遍历nums找结果）: 首先，构建dict&amp;lt;num, index&amp;gt;的字典（哈希表），存入对应的值和索引，遍历map, 计算target-num, 利用哈希表常数时间的寻址，只要在字典中找到的索引不与当前索引一样，即找到结果。时间复杂度&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;, 空间复杂度&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;.&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def twoSum(nums: List[int], target: int) -&amp;gt; List[int]:
    nums_dict = {value: index for index, value in enumerate(nums)}
    for i, num in enumerate(nums):
        find_value = target - num
        if find_value in nums_dict and nums_dict[find_value] != i:
            return [i, nums_dict[find_value]]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;单行程哈希表（遍历一次nums）：与上面一种的区别在于不先将所有的值和索引都放入map中，在遍历中依次放入，少了一次遍历的时间，速度更快占用内存更小。时间复杂度&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;, 空间复杂度&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def twoSum(nums: List[int], target: int) -&amp;gt; List[int]:
    nums_dict = {}
    for i, num in enumerate(nums):
        find_value = target - num
        if find_value in nums_dict:
            return [i, nums_dict[find_value]]
        nums_dict[num] = i&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行时间与内存占用比较：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;常规&lt;/td&gt;
&lt;td&gt;3244ms&lt;/td&gt;
&lt;td&gt;13.9Mb&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;双行程&lt;/td&gt;
&lt;td&gt;56ms&lt;/td&gt;
&lt;td&gt;15Mb&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;单行程&lt;/td&gt;
&lt;td&gt;40ms&lt;/td&gt;
&lt;td&gt;14.1Mb&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;add-two-numbers&quot;&gt;2. Add Two Numbers&lt;/h2&gt;
&lt;p&gt;问题描述：给定两个非空链表，表示两个非负整数。这些数字以相反的顺序存储，它们的每个节点都包含一个数字。将这两个数字相加并以链表的形式返回。可以假设这两个数字不包含任何前导零，除了数字0本身。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)
Output: 7 -&amp;gt; 0 -&amp;gt; 8
Explanation: 342 + 465 = 807.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法：建立一个新的ListNode，依次对l2和l3的每个元素进行相加，这里重要的是对进位的判断，还要考虑两个ListNode的长度不一样，以及长度不一样，最后相加的时候是否有进位，有进位则还要考虑没有结束的ListNode与进位的相加，相加完是否还有进位。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution:
    def addTwoNumbers(self, l1, l2):
        &quot;&quot;&quot;
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        head = l3 = ListNode(0)  #相当于双指针指同一个listNode，l3构建head的next, 会在后面发生变化
        carry_flag = 0 
        while( l1 and l2 ): #循环依次按位相加，直到至少一个listnode为空
            l3.next = ListNode(0)
            l3 = l3.next
            temp = l1.val + l2.val + carry_flag
            if temp &amp;lt; 10:
                l3.val = temp
                carry_flag = 0
            else:
                l3.val = temp - 10
                carry_flag = 1
            l1 = l1.next
            l2 = l2.next
        if l1: #如果l1非空，将l1剩余的listnode赋给l3.next,相当于l3的高位数
            l3.next = l1
            carry_flag, l3 = self.control_carry(carry_flag, l3) #让l3.next与carry_flag进行运算，直到进位符为0或者l3为空退出循环， 返回l3和进位符。
        if l2: 
            l3.next = l2
            carry_flag, l3 = self.control_carry(carry_flag, l3)
        if not l1 and not l2:# l1和l2同时为空，并且有进位，让l3.next为1
            if carry_flag == 1:
                l3.next = ListNode(1)
        if carry_flag == 1: # 例如，l2剩余的部分赋给l3.next, 但carry_flag为1，并且在control_carry中一为1，比较高位都是9，最终进位为1，需要添加最高位为1.
            l3.next = ListNode(1)
        return head.next

    def control_carry(self, carry_flag, l3):
        while(carry_flag):
            if l3.next:
                l3 = l3.next
            else:
                break
            temp1 = l3.val + carry_flag
            if temp1 &amp;lt; 10:
                l3.val = temp1
                carry_flag = 0
            else:
                l3.val = temp1 - 10
                carry_flag = 1
        return carry_flag, l3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Times = 76ms, memory_usage = 13.2Mb&lt;/p&gt;
&lt;h2 id=&quot;longest-substring-without-repeating-characters&quot;&gt;3. Longest Substring Without Repeating Characters&lt;/h2&gt;
&lt;p&gt;问题描述: 给定一个字符串，在不重复字符的情况下找出最长子字符串的长度。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;Input: &quot;abcabcbb&quot;
Output: 3 
Explanation: The answer is &quot;abc&quot;, with the length of 3. 

Input: &quot;bbbbb&quot;
Output: 1
Explanation: The answer is &quot;b&quot;, with the length of 1.

Input: &quot;pwwkew&quot;
Output: 3
Explanation: The answer is &quot;wke&quot;, with the length of 3. 
             Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我的方法：循环遍历字符串的每个字符，对每个字符相加，新加入的字符要查找前面的字符串是否存在新加入的字符，不存在继续下一个字符，存在比较当前最大长度。Times = 76ms, memory_usage = 13.2Mb&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def lengthOfLongestSubstring(self, s: str) -&amp;gt; int:
    max_length = 0
    longest_sub_str = ''
    for i, elem in enumerate(s):
        longest_sub_str += elem
        if len(longest_sub_str) &amp;gt; 1:
            if elem in longest_sub_str[:-1]:
                if max_length &amp;lt; len(longest_sub_str) - 1:
                    max_length = len(longest_sub_str) - 1
                same_char_index = longest_sub_str[:-1].find(longest_sub_str[-1])
                longest_sub_str = longest_sub_str[same_char_index+1:]
    if len(longest_sub_str) &amp;gt; max_length:
        return len(longest_sub_str)
    else:
        return max_length&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更好的方法：使用哈希表&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int lengthOfLongestSubstring(string s) {
    //建立ascii码的字典，字典的键代表字符，字典的值代表字符所在的索引，初始为0
    int m[256] = {0}, res = 0, left = 0;
    for (int i = 0; i &amp;lt; s.size(); ++i) {
        //if中第一个条件判断当前s[i]是否出现过，第二个条件是当出现重复字符时，更换left的位置为重复的字符的前一个索引
        if (m[s[i]] == 0 || m[s[i]] &amp;lt; left) {
            res = max(res, i - left + 1);
        } else {
            left = m[s[i]];
        }
        m[s[i]] = i + 1;
    }
    return res;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面这个与上面类似，用到了unordered_map构建字典:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int lengthOfLongestSubstring(string s) {
    int res = 0, left = 0, i = 0, n = s.size();
    unordered_map&amp;lt;char, int&amp;gt; m;
    for (int i = 0; i &amp;lt; n; ++i) {
        left = max(left, m[s[i]]);
        m[s[i]] = i + 1;
        res = max(res, i - left + 1);
    }
    return res;
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;问题描述: 有两个大小分别为m和n的排序数组nums1和nums2。求两个排序数组的中值。总的运行时复杂度应该是O(log(m+n))。您可以假设nums1和nums2不能同时为空。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;nums1 = [1, 3]
nums2 = [2]
The median is 2.0

nums1 = [1, 2]
nums2 = [3, 4]
The median is (2 + 3)/2 = 2.5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法：建立一个新的列表，长度是输入两个列表长度之和，两个列表依次倒序比较，大的放入新列表的相应位置，当其中至少一个列表为空时，退出循环，还得将那个列表为空最后pop出的数与非空列表进行比较，找到小于那个书即终止，将剩余的数赋值给新列表。Times = 64ms, memory_usage = 13.4Mb&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Solution:
    def getMiddleValue(self, nums, nums_len):
        if nums_len % 2 == 0:
            mid_idx = nums_len // 2
            return (nums[mid_idx] + nums[mid_idx - 1])/2.0
        else:
            return nums[(nums_len - 1) // 2]/1.0
    
    def dealTheRest(self, res, nums, num1, num2, lens):
        while num1 &amp;gt; num2 and nums:
            res[lens - 1] = num1
            num1 = nums.pop()
            lens -= 1
        if nums:
            res[lens - 1] = num2
            res[lens - 2] = num1
            res[0:lens - 2] = nums
        else:
            if num1 &amp;gt; num2:
                res[lens - 1] = num1
                res[lens - 2] = num2
            else:
                res[lens - 1] = num2
                res[lens - 2] = num1
        return res

    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&amp;gt; float:
        if not nums1:
            return self.getMiddleValue(nums2, len(nums2))
        if not nums2:
            return self.getMiddleValue(nums1, len(nums1))
        lens = len(nums1) + len(nums2)
        res = [0]*lens
        num1 = nums1.pop()
        num2 = nums2.pop()
        if not nums1 and not nums2:
            return (num1 + num2)/2.0
        while nums1 and nums2:
            if num1 &amp;gt; num2:
                res[lens - 1] = num1
                num1 = nums1.pop()
            else:
                res[lens - 1] = num2
                num2 = nums2.pop()
            lens -= 1
        if nums1:
            res = self.dealTheRest(res, nums1, num1, num2, lens)
        if nums2:
            res = self.dealTheRest(res, nums2, num2, num1, lens)
        return self.getMiddleValue(res, len(res))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还可以进一步优化，不需要将新的list全部填满，判断列表长度之和是否为偶数，是则新列表长度为2，否则长度为1，只存储中间的值，存储完即返回，后面的值无需比较，这种方法在大规模数据下更快占用内存更小。在提交后想到的，有兴趣的可以自己动手试试。&lt;/p&gt;
&lt;p&gt;另外在Leetcode上发现更简单的方法，使用系统自带的sorted函数，简洁很快。Times = 56ms&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&amp;gt; float:
    num = sorted(nums1 + nums2)
    leng = len(num)
    median = 0
    if ( (leng%2) == 1):
        median = num[(leng-1)//2]
    else:
        median = (num[leng//2] + num[leng//2 - 1]) / 2
    return median&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;longest-palindromic-substring&quot;&gt;5. Longest Palindromic Substring ❤️&lt;/h2&gt;
&lt;p&gt;给定一个字符串s，找出s中最长的回文子串。可以假设s的最大长度为1000。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;Input: &quot;babad&quot;
Output: &quot;bab&quot;
Note: &quot;aba&quot; is also a valid answer.

Input: &quot;cbbd&quot;
Output: &quot;bb&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法1：暴力搜索，两个循环确定左右索引&lt;span class=&quot;math inline&quot;&gt;\(i,j\)&lt;/span&gt;，判断中间&lt;span class=&quot;math inline&quot;&gt;\([i, j)\)&lt;/span&gt;代表的字符串是否是回文，与最大回文比较，长就替换，时间复杂度太高&lt;span class=&quot;math inline&quot;&gt;\(O(n^3)\)&lt;/span&gt;. Times = 8904ms&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Solution:
    def longestPalindrome(self, s: str) -&amp;gt; str:
        longestPStr = ''
        for i in range(len(s), 0, -1):
            for j in range(len(s)):
                if s[j:i] == s[j:i][::-1]:
                    if len(s[j:i]) &amp;gt; len(longestPStr):
                        longestPStr = s[j:i]
                if len(longestPStr) &amp;gt; i:
                    return longestPStr
        return longestPStr&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法2：以当前索引为中间，往外扩张判断字符串是否为回文数，不符合回文数退出内层循环，取最大字符串。参考自&lt;a href=&quot;https://leetcode.com/problems/longest-palindromic-substring/discuss/2954/Python-easy-to-understand-solution-with-comments-(from-middle-to-two-ends)&quot;&gt;答案&lt;/a&gt;。这个方法占用了O(n)的空间，可以使用&lt;span class=&quot;math inline&quot;&gt;\([begin, end)\)&lt;/span&gt;降至&lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;. Times = 932ms.&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Solution:
    def longestPalindrome(self, s: str) -&amp;gt; str:
        res = ''
        for i in range(len(s)):
            odd  = self.palindromeAt(s, i, i)
            even = self.palindromeAt(s, i, i+1)
            res = max(res, odd, even, key=len)
        return res
        
    def palindromeAt(self, s, l, r):    
        while l &amp;gt;= 0 and r &amp;lt; len(s) and s[l] == s[r]:
            l -= 1
            r += 1
        return s[l+1:r]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法3: 这种方法比较巧妙，当想s增加一个字符时，最长的回文数可能加1，加2或者不动，所以处理的方式就是建立一个最长回文数长度maxLen，跟踪这个长度，当前索引为i，判断&lt;span class=&quot;math inline&quot;&gt;\(s[i-maxLen-1:i+1]\)&lt;/span&gt;(对应'abba')和&lt;span class=&quot;math inline&quot;&gt;\(s[i-maxLen:i+1]\)&lt;/span&gt;(对应'aba')是否为回文数，对最大maxlen加上对应的长度。参考自&lt;a href=&quot;https://leetcode.com/problems/longest-palindromic-substring/discuss/2925/Python-O(n2)-method-with-some-optimization-88ms&quot;&gt;答案&lt;/a&gt;. Times = 88ms&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Solution:
    def longestPalindrome(self, s):
        if len(s)==0:
            return 0
        maxLen=1
        start=0
        for i in xrange(len(s)):
            if i-maxLen &amp;gt;=1 and s[i-maxLen-1:i+1]==s[i-maxLen-1:i+1][::-1]:
                start=i-maxLen-1
                maxLen+=2
                continue

            if i-maxLen &amp;gt;=0 and s[i-maxLen:i+1]==s[i-maxLen:i+1][::-1]:
                start=i-maxLen
                maxLen+=1
        return s[start:start+maxLen]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法4：非常巧妙，时间复杂度达到&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;，这个方法的名字是==Manacher‘s Algorithm==，也叫马拉车方法，方法建立了一个数组，数组第i个元素表示以 i 为中心的最长回文的半径，利用回文数的对称性，在一个大的回文数后面的索引可以利用对称性映射前面而大大简化计算。算法细节描述请参考&lt;a href=&quot;https://segmentfault.com/a/1190000008484167?utm_source=tag-newest&quot;&gt;博客&lt;/a&gt;，讲得非常好，墙裂推荐，以下代码来自&lt;a href=&quot;http://www.cnblogs.com/grandyang/p/4475985.html&quot;&gt;博客&lt;/a&gt;。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class Solution {
public:
    string longestPalindrome(string s) {
        if (s.size() &amp;lt; 2) return s;
        string t = &quot;$#&quot;;
        for (int i = 0; i &amp;lt; s.size(); ++i){
            t += s[i];
            t += '#';
        }
        vector&amp;lt;int&amp;gt; p(t.size(), 0);
        int mx = 0, id = 0, resLen = 0, resCenter = 0;
        for (int i = 1; i &amp;lt; t.size(); ++i){
            p[i] = mx &amp;gt; i ? min( p[2 * id - i], mx - i ) : 1;
            while (t[ i + p[i] ] == t[ i - p[i] ]) ++p[i];
            if (mx &amp;lt; i + p[i]){
                mx = i + p[i];
                id = i;
            }
            if (resLen &amp;lt; p[i]){
                resLen = p[i];
                resCenter = i;
            }
        }
        return s.substr((resCenter - resLen) / 2, resLen - 1);
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;zigzag-conversion&quot;&gt;6. ZigZag Conversion&lt;/h2&gt;
&lt;p&gt;描述：字符串“PAYPALISHIRING”在给定行数上以之字形书写，如下所示:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;P   A   H   N
A P L S I I G
Y   I   R&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后逐行读取:“PAHNAPLSIIGYIR”编写代码，该代码将接受一个字符串，并在给定行数的情况下进行转换:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;string convert(string s, int numRows);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3
Output: &quot;PAHNAPLSIIGYIR&quot;

Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4
Output: &quot;PINALSIGYAHRPI&quot;
Explanation:

P     I    N
A   L S  I G
Y A   H R
P     I&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法：首先审好题，观看结果解释，是以旋转翻转Z的形状进行排列的，根据这一性质，就可以找到字符按周期排列规则，生成对应行数的vector, 存放每一行的字符，最后相加起来。Times = 88ms&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Solution:
    def convert(self, s: str, numRows: int) -&amp;gt; str:
        if numRows == 1:
            return s
        dict = {i:'' for i in range(numRows)}
        law_len = 2 * numRows - 2
        for i, e in enumerate(s):
            temp = i % law_len
            if temp &amp;gt; numRows - 1:
                temp = (numRows - 1) - (temp - (numRows - 1))
            dict[temp] += e
        res = ''
        for i in range(numRows):
            res += dict[i]
        return res&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;reverse-integer&quot;&gt;7. Reverse Integer&lt;/h2&gt;
&lt;p&gt;问题描述：给定一个32位带符号整数，对其进行反数运算. 超过int的最大值或者最小值，返回相应最大值或最小值&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;Input: 123
Output: 321

Input: -123
Output: -321

Input: 120
Output: 21&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法1：使用循环对输入整数按10取余，取余后取整除以10，然后余数循环乘10，直到取整除以为0停止循环，得到最后反转的数。Times = 72ms, memory_usage = 13.3Mb&lt;/p&gt;
&lt;p&gt;注意：在python3中，-123%10是不等于3的，这点是个坑，所以python3实现中加入了负号的判断。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Solution:
    def reverse(self, x: int) -&amp;gt; int:
        a = 0
        max = 2**31
        if x==0 or x &amp;gt; max-1 or x &amp;lt; -max:
            return 0
        
        if x &amp;lt; 0:
            x = -x
            flag_neg = True
        else:
            flag_neg = False
        
        while(x != 0):
            a = a*10 + x%10
            x //= 10
        
        if a &amp;lt; max-1 and a &amp;gt; -max:
            return a if not flag_neg else -a
        else:
            return 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法2：更加粗暴，直接判断整数是否为负数，标识符用字符来表示，是负数则'-'，不是则空字符，直接将整数转成字符串反转加上前面的标识符符号，后面判断越界即可, 更快. Times = 56ms, memory_usage = 13.3Mb&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Solution:
    def reverse(self, x: int) -&amp;gt; int:
        if x==0:
            return 0

        max = 2**31
        if x &amp;gt; max-1 or x &amp;lt; -max:
            return 0

        a = 0
        if x &amp;lt; 0:
            x = -x
            flag_neg = '-'
        else:
            flag_neg = ''
        
        a = int(flag_neg + str(x)[::-1])
        
        if a &amp;lt; max-1 and a &amp;gt; -max:
            return a
        else:
            return 0&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;string-to-integer-atoi&quot;&gt;8. String to Integer (atoi)&lt;/h2&gt;
&lt;p&gt;问题描述: 实现将字符串转换为整数的atoi。&lt;/p&gt;
&lt;p&gt;函数首先丢弃尽可能多的空白字符，直到找到第一个非空白字符。然后，从这个字符开始，取一个可选的初始正负号，后跟尽可能多的数字，并将它们解释为一个数值。&lt;/p&gt;
&lt;p&gt;字符串可以包含构成整数的字符之后的附加字符，这些字符将被忽略，并且对函数的行为没有影响。&lt;/p&gt;
&lt;p&gt;如果不能执行有效的转换，则返回一个零值。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;Input: &quot;42&quot;
Output: 42

Input: &quot;   -42&quot;
Output: -42
Explanation: The first non-whitespace character is '-', which is the minus sign.
             Then take as many numerical digits as possible, which gets 42.

Input: &quot;4193 with words&quot;
Output: 4193
Explanation: Conversion stops at digit '3' as the next character is not a numerical digit.

Input: &quot;words and 987&quot;
Output: 0
Explanation: The first non-whitespace character is 'w', which is not a numerical 
             digit or a +/- sign. Therefore no valid conversion could be performed.

Input: &quot;-91283472332&quot;
Output: -2147483648
Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer.
             Thefore INT_MIN (−231) is returned.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法：首先判断字符的长度，长度为0，返回0，长度为1，判断是否为数字，不为数字，返回0，还要判断整个str是否都是空格，是则返回0；然后找到第一个不是空格的索引，在这个索引下依次递加查询数字，在查询之前要判断第一个字母是否为负号或者正号，建立了一个符号标志，然后依次生成数字，终止条件是发现字符不是数字，另外，这里为了防止溢出，在c++中使用long类型进行数字的计算，在循环的过程中会判断是否超过了整形的最大值，超过返回最大值或者最小值。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Solution:
    def myAtoi(self, str: str) -&amp;gt; int:
        if len(str) == 0 or not str.strip(): return 0;
        if len(str) == 1 and not str.isdigit():
            return 0
        ls = list(str.strip())
        if not ls[0].isdigit() and ls[0] != '-' and ls[0] != '+':
            return 0
        elif ls[0] == '-':
            flag = '-'
            begin = 1
        elif ls[0] == '+':
            flag = '+'
            begin = 1
        else:
            begin = 0
            flag = '+'
        res = ''
        for i in range(begin, len(ls)):
            if ls[i].isdigit():
                res += ls[i]
            else:
                break
        if not res:
            return 0
        if flag == '-':
            return max(-2**31, -int(res))
        else:
            return min(2**31 - 1, int(res))&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;palindrome-number&quot;&gt;9. Palindrome Number&lt;/h2&gt;
&lt;p&gt;问题描述：给定一个整数，判断是否是回文数&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;Input: 121
Output: true

Input: -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.

Input: 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法: 数值判断，两种情况，第一种数的位数是偶数，如1881，可以除10取余再乘以10的方法对低位数进行逆序，最后判断18=18，第二种数的位数是奇数，如18281，同样按照上面方法，最后判断18=182/10，循环条件是逆序的数大于剩余的数即停止。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class Solution {
public:
    bool isPalindrome(int x) {
        if (x &amp;lt; 0 || (x % 10 == 0 &amp;amp;&amp;amp; x != 0))
            return false;
        int res = 0;
        while(x &amp;gt; res){
            res = res * 10 + x % 10;
            x /= 10;
        }
        return x == res || x == res/10;
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;regular-expression-matching&quot;&gt;10. Regular Expression Matching&lt;/h2&gt;
&lt;p&gt;问题描述：给定一个输入字符串和一个模式，实现正则表达式匹配并支持'.'和'*'.&lt;/p&gt;
&lt;p&gt;'.'匹配任何单个字符。'*'匹配前一个元素的零个或多个. 匹配应该覆盖整个输入字符串(而不是部分)。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;Input:
s = &quot;aa&quot;
p = &quot;a&quot;
Output: false
Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.

Input:
s = &quot;aa&quot;
p = &quot;a*&quot;
Output: true
Explanation: '*' means zero or more of the precedeng element, 'a'. Therefore, by repeating 'a' once, it becomes &quot;aa&quot;.

Input:
s = &quot;ab&quot;
p = &quot;.*&quot;
Output: true
Explanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.

Input:
s = &quot;aab&quot;
p = &quot;c*a*b&quot;
Output: true
Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches &quot;aab&quot;.

Input:
s = &quot;mississippi&quot;
p = &quot;mis*is*p*.&quot;
Output: false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法：基于动态规划，如果&lt;span class=&quot;math inline&quot;&gt;\(s[0..i)\)&lt;/span&gt;匹配&lt;span class=&quot;math inline&quot;&gt;\(P[0..j]\)&lt;/span&gt;, 定义状态&lt;span class=&quot;math inline&quot;&gt;\(P[i][j]\)&lt;/span&gt;为真, 否则为假。状态方程为:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;a. P[i][j] = P[i - 1][j - 1], if p[j - 1] != ‘*’ &amp;amp;&amp;amp; (s[i - 1] == p[j - 1] || p[j - 1] == ‘.’); 
b. P[i][j] = P[i][j - 2], if p[j - 1] == ‘*’ and the pattern repeats for 0 times;
c. P[i][j] = P[i - 1][j] &amp;amp;&amp;amp; (s[i - 1] == p[j - 2] || p[j - 2] == ‘.’), if p[j - 1] == ‘*’ and the pattern repeats for at least 1 times. &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将三种情况合在一起，得到下面的解决方案。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Solution:
    def isMatch(self, s: str, p: str) -&amp;gt; bool:
        m, n = len(s), len(p)
        dp = [[False for _ in range(n+1)] for _ in range(m+1)]
        dp[0][0] = True
        for i in range(0, m+1):
            for j in range(1, n+1):
                if p[j - 1] == '*':
                    dp[i][j] = dp[i][j - 2] or (i &amp;gt; 0 and (s[i - 1] == p[j - 2] or p[j -2] == '.') and dp[i - 1][j])
                else:
                    dp[i][j] = i &amp;gt; 0 and dp[i - 1][j - 1] and (s[i - 1] == p[j - 1] or p[j - 1] == '.')
        return dp[m][n]&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 23 Apr 2019 16:24:00 +0000</pubDate>
<dc:creator>FANG_YANG</dc:creator>
<og:description>这篇文章介绍Leetcode1到10题的解决思路和相关代码</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fydeblog/p/10760040.html</dc:identifier>
</item>
<item>
<title>理解 KMP 算法 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/understanding_kmp_algorithm.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/understanding_kmp_algorithm.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm&quot; rel=&quot;nofollow&quot;&gt;KMP（The Knuth-Morris-Pratt Algorithm）&lt;/a&gt;算法用于字符串匹配，从字符串中找出给定的子字符串。但它并不是很好理解和掌握。而理解它概念中的部分匹配表，是理解 KMP 算法的关键。&lt;/p&gt;
&lt;p&gt;这里的讨论绕开其背后晦涩难懂的逻辑，着重从其运用上来理解它。&lt;/p&gt;
&lt;h2&gt;字符串查找&lt;/h2&gt;
&lt;p&gt;比如从字符串 &lt;code&gt;abcdef&lt;/code&gt; 中找出 &lt;code&gt;abcdg&lt;/code&gt; 子字符串。&lt;/p&gt;
&lt;p&gt;朴素的解法，我们可以这样做，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分别取出第一位进行匹配，如果相同再取出各自的第二位。&lt;/li&gt;
&lt;li&gt;如果不同，则将索引后移一位，从总字符串第二位开始，重复步骤一。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这种朴素解法的弊端在于，每次匹配失败，索引只后移一位，有很多冗余操作，效率不高。&lt;/p&gt;
&lt;p&gt;在进行第一轮匹配中，即索引为 0 时，我们能够匹配出前四个字符 &lt;code&gt;abcd&lt;/code&gt; 是相等的，后面发现想要的 &lt;code&gt;g&lt;/code&gt; 与真实的 &lt;code&gt;e&lt;/code&gt; 不符，标志着索引为 0 的情况匹配失败，开始查看索引为 1 时，但因为我们在第一轮匹配中，已经知道了总字符串中前四个字符的长相，但还是需要重复地挨个进行匹配。&lt;/p&gt;
&lt;h2&gt;部分匹配表/Partial Match Table&lt;/h2&gt;
&lt;p&gt;以长度为 8 的字符串 &lt;code&gt;abababca&lt;/code&gt;，为例，其部分匹配表格为：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
char:  &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; a &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; b &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; a &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; b &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; a &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; b &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; c &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; a &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
index: &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 0 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 1 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 2 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 3 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 4 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 5 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 6 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 7 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 
value: &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 0 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 0 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 1 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 2 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 3 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 4 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 0 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 1 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 &lt;code&gt;value&lt;/code&gt; 行便是部分匹配表的值。&lt;/p&gt;
&lt;h3&gt;子集&lt;/h3&gt;
&lt;p&gt;对于上面示例字符串，假如我们观察第 &lt;code&gt;index&lt;/code&gt; 为 2 的位置，那么我们得到了字符串的一个子集 &lt;code&gt;aba&lt;/code&gt;，如果我们观察 &lt;code&gt;index&lt;/code&gt; 为 7 的位置，那得到的是整个字符串，这点是很显然的。当我们观察的位置不同时，表示我们关注的字符串中的子集不同，因为子字符串发生了变化。&lt;/p&gt;
&lt;h3&gt;前缀 &amp;amp; 后缀&lt;/h3&gt;
&lt;p&gt;对于给定的字符串，从末尾开始去掉一个或多个字符，剩下的部分都叫作该字符串的&lt;strong&gt;真前缀（Proper prefix）&lt;/strong&gt;，后面简称前缀。这里「真」不是「真·前缀」的意思，联想一下数学里面集合的「真子集」。比如 &lt;code&gt;banana&lt;/code&gt;，其前缀有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;b&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ba&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ban&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bana&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;banan&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;同理，从首部开始，去掉一个或多个字条，剩下的部分是该字符串的&lt;strong&gt;真后缀（Proper suffix）&lt;/strong&gt;。还是 &lt;code&gt;banana&lt;/code&gt;，其后缀有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;anana&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nana&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ana&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;na&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;部分匹配值&lt;/h3&gt;
&lt;p&gt;可以看到，所有前缀和后缀在数量上是对称的，那么我们可以从前缀中找出一个，与后缀进行匹配，先不关心做这个匹配的意义。以最开始的文本 &lt;code&gt;abababca&lt;/code&gt; 为例。&lt;/p&gt;
&lt;p&gt;假如我们观察 &lt;code&gt;index&lt;/code&gt; 为 2 的位置，此时子字符串为 &lt;code&gt;aba&lt;/code&gt;，其前后缀分别为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;前缀：&lt;code&gt;a&lt;/code&gt;，&lt;code&gt;ab&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;后缀：&lt;code&gt;ba&lt;/code&gt;，&lt;code&gt;a&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;将前缀依次在后缀中去匹配，这里前后缀列表中能够匹配上的只有 &lt;code&gt;a&lt;/code&gt; 这个子字符串，其长度为 1，所以将这个观测结果填入表中记下来，与开始看到的部分匹配表吻合了。&lt;/p&gt;
&lt;p&gt;再比如来观察 &lt;code&gt;index&lt;/code&gt; 为 3 的位置，此时得到的子字符串为 &lt;code&gt;abab&lt;/code&gt;，此时的前后缀为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;前缀：&lt;code&gt;a&lt;/code&gt;，&lt;code&gt;ab&lt;/code&gt;，&lt;code&gt;aba&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;后缀：&lt;code&gt;bab&lt;/code&gt;，&lt;code&gt;ab&lt;/code&gt;，&lt;code&gt;b&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此时可观察出其匹配项为 &lt;code&gt;ab&lt;/code&gt;，长度为 2，也与上面部分匹配表中的值吻合。&lt;/p&gt;
&lt;p&gt;再比如来观察 &lt;code&gt;index&lt;/code&gt; 为 5 的位置，此时子字符串为 &lt;code&gt;ababab&lt;/code&gt;，前后缀为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;前缀：&lt;code&gt;a&lt;/code&gt;，&lt;code&gt;ab&lt;/code&gt;，&lt;code&gt;aba&lt;/code&gt;，&lt;code&gt;abab&lt;/code&gt;，&lt;code&gt;ababa&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;后缀：&lt;code&gt;babab&lt;/code&gt;，&lt;code&gt;abab&lt;/code&gt;，&lt;code&gt;bab&lt;/code&gt;，&lt;code&gt;ab&lt;/code&gt;，&lt;code&gt;b&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后拿前缀中每个元素与后缀中的元素进行匹配，最后找出有两个匹配项，&lt;/p&gt;
&lt;p&gt;我们取长的这个 &lt;code&gt;abab&lt;/code&gt;，其长度为 4。&lt;/p&gt;
&lt;p&gt;所以现在再来看上面的部分匹配表，一是能理解其值是怎么来的，二是能理解其表示的意义，即，&lt;strong&gt;所有前缀与后缀的匹配项中长度最长的那一个的长度。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们继续，进行到 &lt;code&gt;index&lt;/code&gt; 为 6 时，子字符串为 &lt;code&gt;abababc&lt;/code&gt;，可以预见，前后缀中找不到匹配。因为所有前缀都不包含 &lt;code&gt;c&lt;/code&gt;，而所有后缀都包含 &lt;code&gt;c&lt;/code&gt;。所以此时部分匹配值为 0。&lt;/p&gt;
&lt;p&gt;再继续就到字符串末尾了，即整个字符串 &lt;code&gt;abababca&lt;/code&gt;。也可以预见，因为所有前缀都以 &lt;code&gt;a&lt;/code&gt; 开始，并且所有后缀都以 &lt;code&gt;a&lt;/code&gt; 结尾，所以此时的部分匹配值最少为 1。继续会发现，因为后面的后缀开始有 &lt;code&gt;c&lt;/code&gt; 的加入，使得后缀都包含 &lt;code&gt;ca&lt;/code&gt;，而前缀中能够包含 &lt;code&gt;c&lt;/code&gt; 的只有 &lt;code&gt;abababc&lt;/code&gt;，而该长度 7 与同等长度的后缀 &lt;code&gt;bababca&lt;/code&gt; 不匹配。至此就可以得出结论，匹配结果就是 1，没有更长的匹配了。&lt;/p&gt;
&lt;h2&gt;部分匹配表的使用&lt;/h2&gt;
&lt;p&gt;利用上面的部分匹配值，我们在进行字符串查找时，不必每次失败后只移动一位，而是可以移动多位，去掉一些冗余的匹配。这里有个公式如下：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;If a partial match of length partial_match_length is found and table[partial_match_length] &amp;gt; 1, we may skip ahead partial_match_length - table[partial_match_length - 1] characters.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果匹配过程中，匹配到了部分值为 &lt;code&gt;partial_match_length&lt;/code&gt;，即目前找出前 &lt;code&gt;partial_match_length&lt;/code&gt; 个字符是匹配的，将这个长度减一作为部分匹配表格中的 &lt;code&gt;index&lt;/code&gt; 代入，查找其对应的 &lt;code&gt;value&lt;/code&gt; 即 &lt;code&gt;table[partial_match_length-1]&lt;/code&gt;，那么我们可以向前移动的步长为 &lt;code&gt;partial_match_length - table[partial_match_length - 1]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;下面是本文开始时的那个部分匹配表:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
char:  &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; a &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; b &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; a &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; b &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; a &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; b &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; c &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; a &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
index: &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 0 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 1 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 2 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 3 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 4 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 5 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 6 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 7 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 
value: &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 0 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 0 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 1 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 2 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 3 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 4 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 0 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 1 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;假设需要从 &lt;code&gt;bacbababaabcbab&lt;/code&gt; 中查找 &lt;code&gt;abababca&lt;/code&gt;，根据上面的公式我们来走一遍。&lt;/p&gt;
&lt;p&gt;首次匹配发生在总字符串的第二个字符，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
bacbababaabcbab
 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
 abababca
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时匹配的长度为 1，部分匹配表中索引为 1-1=0 的位置对应的部分匹配值为 0，所以我们可以向前移动的距离是 &lt;code&gt;1-0&lt;/code&gt; 1。其实也相当于没有跳跃，就是正常的本次匹配失败，索引后移一位的情况。这里没有节省任何成本。&lt;/p&gt;
&lt;p&gt;继续直到再次发生匹配，此时匹配到的情况如下：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
bacbababaabcbab
    &lt;span class=&quot;pl-k&quot;&gt;|||||&lt;/span&gt;
    abababca
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在匹配到的长度是 5，部分匹配表中 5-1=4 对应的部分匹配值为 3，所以我们可以向前移动 5-3=2，此时一下子就可以移动两位了。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
    上一次的位置
    &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 最新移动到的位置
    &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
bacbababaabcbab
    xx&lt;span class=&quot;pl-k&quot;&gt;|||&lt;/span&gt;
      abababca
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时匹配到的长度为 3， 查找到 &lt;code&gt;table[partial_match_length-1]&lt;/code&gt; 即 index 为 2 对应的值为 1，所以可向前移动的距离为 3-1=2。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
bacbababaabcbab
      xx&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
        abababca
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时我们需要查找的字符串其长度已经超出剩余可用来匹配的字符串了，所以可直接结束匹配，得到结论：没有查找到结果。&lt;/p&gt;
&lt;h2&gt;JavaScript 中的实现&lt;/h2&gt;
&lt;p&gt;以下是来自 &lt;a href=&quot;https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/knuth-morris-pratt/knuthMorrisPratt.js&quot;&gt;trekhleb/javascript-algorithms&lt;/a&gt; 中 JavaScript 版本的 KMP 算法实现：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt; * &lt;span class=&quot;pl-k&quot;&gt;@see&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;https://www.youtube.com/watch?v=GTJr8OvyEVQ&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt; * &lt;span class=&quot;pl-k&quot;&gt;@param&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;{string}&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;word&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt; * &lt;span class=&quot;pl-k&quot;&gt;@return&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;{number[]}&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt; &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;buildPatternTable&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;word&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;patternTable&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;];
  &lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; prefixIndex &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;;
  &lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; suffixIndex &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;;

  &lt;span class=&quot;pl-k&quot;&gt;while&lt;/span&gt; (suffixIndex &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;word&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;length&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (word[prefixIndex] &lt;span class=&quot;pl-k&quot;&gt;===&lt;/span&gt; word[suffixIndex]) {
      patternTable[suffixIndex] &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; prefixIndex &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;;
      suffixIndex &lt;span class=&quot;pl-k&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;;
      prefixIndex &lt;span class=&quot;pl-k&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;;
    } &lt;span class=&quot;pl-k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (prefixIndex &lt;span class=&quot;pl-k&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;) {
      patternTable[suffixIndex] &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;;
      suffixIndex &lt;span class=&quot;pl-k&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;;
    } &lt;span class=&quot;pl-k&quot;&gt;else&lt;/span&gt; {
      prefixIndex &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; patternTable[prefixIndex &lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;];
    }
  }

  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; patternTable;
}

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt; * &lt;span class=&quot;pl-k&quot;&gt;@param&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;{string}&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;text&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt; * &lt;span class=&quot;pl-k&quot;&gt;@param&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;{string}&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;word&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt; * &lt;span class=&quot;pl-k&quot;&gt;@return&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;{number}&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt; &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;knuthMorrisPratt&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;text&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;word&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;word&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;;
  }

  &lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; textIndex &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;;
  &lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; wordIndex &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;;

  &lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;patternTable&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;buildPatternTable&lt;/span&gt;(word);

  &lt;span class=&quot;pl-k&quot;&gt;while&lt;/span&gt; (textIndex &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;text&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;length&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (text[textIndex] &lt;span class=&quot;pl-k&quot;&gt;===&lt;/span&gt; word[wordIndex]) {
      &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; We've found a match.&lt;/span&gt;
      &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (wordIndex &lt;span class=&quot;pl-k&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;word&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;) {
        &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; (textIndex &lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;word&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;length&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;;
      }
      wordIndex &lt;span class=&quot;pl-k&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;;
      textIndex &lt;span class=&quot;pl-k&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;;
    } &lt;span class=&quot;pl-k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (wordIndex &lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;) {
      wordIndex &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; patternTable[wordIndex &lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;];
    } &lt;span class=&quot;pl-k&quot;&gt;else&lt;/span&gt; {
      wordIndex &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;;
      textIndex &lt;span class=&quot;pl-k&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;;
    }
  }

  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;时间复杂度&lt;/h2&gt;
&lt;p&gt;因为算法中涉及两部分字符串的线性对比，其时间复杂度为两字符串长度之和，假设需要搜索的关键词长度为 k，总字符串长度为 m，则时间复杂度为 O(k+m)。&lt;/p&gt;
&lt;h2&gt;相关资源&lt;/h2&gt;
</description>
<pubDate>Tue, 23 Apr 2019 15:46:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>KMP（The Knuth Morris Pratt Algorithm）算法用于字符串匹配，从字符串中找出给定的子字符串。但它并不是很好理解和掌握。而理解它概念中的部分匹配表，是理解 KMP 算法的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wayou/p/understanding_kmp_algorithm.html</dc:identifier>
</item>
<item>
<title>一个小实例理解js 原型和继承 - 凡尘yang</title>
<link>http://www.cnblogs.com/yangboy/p/10759911.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangboy/p/10759911.html</guid>
<description>&lt;p&gt;&lt;span&gt;导语1：一个构造函数的原型对象，其实就是这个构造函数的一个属性而已，属性名叫prototype,值是一个对象，对象中有一些属性和方法，所以每个构造函数的实例对象都拥有这些属性和方法的使用权。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;导语2：构造函数需要用 &lt;span&gt;new&lt;/span&gt; 操作符来调用，它本身没有任何意义，只有实例化后才有生命，当然你也可以把它当普通函数使用，那this就是指向window了（意义不大）。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;导语3：对于构造函数实例化出一个对象经历了什么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　  我们看下面这个例子：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1641685/201904/1641685-20190423232014742-1183615044.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这个例子充分说明了，大佬们创造出构造函数这种东西，是有特殊用处的，本身没什么意义，在实例化后瞬间有了生命。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;好了有这些准备工作后，我们开始写一个构造函数+原型用法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;废话不多说直接上代码！！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1641685/201904/1641685-20190423232448601-266701614.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1，这个例子中有个构造函数，名字叫GetElem,参数期望传入的是一个元素的id,可以获取这个id的元素；&lt;/p&gt;
&lt;p&gt;2，实例化一个叫domOne的对象，它传入一个实参为：“old”;所以它可以获取这个id为old的元素&lt;/p&gt;
&lt;p&gt;3，在构造函数的原型上定义一个方法叫：changeInner 作用是如果传入了实参就用实参来改变元素的内容&lt;/p&gt;
&lt;p&gt;4，在构造函数的原型上定义一个方法叫：on作用是根据事件类型和对应函数干一些事情；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;domOne这个实例化对象中并没有这两个方法，但是没关系，它的原型对象上拥有啊！！！所以可以直接用；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;您一定会问为何不直接把方法写在构造函数中不就省事了？原因是这样的话，每实例化一个对象都要在实例化过程中创建这些方法，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果实例化太多就消耗性能，而放在原型对象上就只需要做一次。这也是构造函数+原型优于工厂模式的方面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 最后一张图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1641685/201904/1641685-20190423234009939-920993104.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 方法可以链接起来写的原因是  在每个方法中  &lt;span&gt;return this &lt;span&gt;(this指向的是实例对象，当然可以继续调用它可以调用的方法啦！！！)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;






</description>
<pubDate>Tue, 23 Apr 2019 15:45:00 +0000</pubDate>
<dc:creator>凡尘yang</dc:creator>
<og:description>导语1：一个构造函数的原型对象，其实就是这个构造函数的一个属性而已，属性名叫prototype,值是一个对象，对象中有一些属性和方法，所以每个构造函数的实例对象都拥有这些属性和方法的使用权。 导语2：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangboy/p/10759911.html</dc:identifier>
</item>
<item>
<title>麒麟子Cocos Creator实用技巧一：如何正确地显示微信头像 - 麒麟子(Alex)</title>
<link>http://www.cnblogs.com/qilinzi/p/10759840.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qilinzi/p/10759840.html</guid>
<description>&lt;p&gt;不管是游戏App，还是H5，又或者是微信小游戏。但凡接入了微信登录的应用，都可能需要显示微信头像。&lt;/p&gt;
&lt;p&gt;在Cocos Creator中，我们常见的显示方法像下面这样&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
var headimg = 'http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erD6MOUwRKV9NyBAqnoFDTnltzAe2zWOkKxyDOFibVBb1ZV5CaATJwYAuNqZ5sXMBC4c8iacaHDf8RA/132'&lt;span&gt;;

cc.loader.load({url:headimg,type:'jpg'},function&lt;span&gt;(err,tex){
    self.icon.spriteFrame = new&lt;span&gt; cc.SpriteFrame(tex);
});&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;Click and drag to move&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样做大部分情况下是没有问题的。但容易踩到两个坑&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;假如用户在微信中上传的头像不是jpg格式，将会显示为黑屏&lt;/li&gt;
&lt;li&gt;假如是H5中使用上述代码，会提示跨域访问&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;而最近（今天日期 2019-04-22）新出了一个奇怪的事情，就是Android系统7.0+的机器，在4G网下无法正常显示微信头像。 包括腾讯的欢乐斗地主里的排行榜也显示不出来。&lt;/p&gt;

&lt;p&gt;这个问题我猜测，是4G的Android 7.0+的HTTP头和其他环境下不一样，导致腾讯拒绝了头像访问。 应该是封杀某音的时候，误伤。&lt;/p&gt;
&lt;p&gt;解决这个问题最直接的办法，就是在自己的服务器上，配置一条NGINX转发协议。 &lt;/p&gt;

&lt;p&gt;假如，我们的外网IP或者域名是 h5.ooxx.cn, 端口是80，或者其他的。 我们修改上面的访问方式为如下&lt;/p&gt;

&lt;p&gt;这样改的原因如下&lt;/p&gt;
&lt;p&gt;1、假如你做的是H5项目，h5.ooxx.cn域名刚好就是你的页面加载域名，那么你将处于同域中，不再有跨域问题&lt;/p&gt;
&lt;p&gt;2、当我们请求最后合成的url时，NGINX会将url参数作为请求地址，转发出去，并且将获取到的信息，原路返回。 而我们添加的proxy_redirect off; 将会抹去我们系统机型为我们添加的各种HTTP HEADER。 不会再出现Android 7.0+ 4G网加载不了的问题。&lt;/p&gt;
&lt;p&gt;3、添加 &amp;amp;sb=213.jpg参数，是为了让cc.loader.load函数识别到这是一个图片加载。 但由于不是强制的填写type，即使PNG也是可以正常显示的。&lt;/p&gt;

&lt;p&gt;以上就是麒麟子在做项目的时候，解决微信头像，以及一些第三方服务器图片的最终方案。 希望能够帮助到大家。&lt;/p&gt;
</description>
<pubDate>Tue, 23 Apr 2019 15:28:00 +0000</pubDate>
<dc:creator>麒麟子(Alex)</dc:creator>
<og:description>最近（今天日期 2019-04-22）新出了一个奇怪的事情，就是Android系统7.0+的机器，在4G网下无法正常显示微信头像。 包括腾讯的欢乐斗地主里的排行榜也显示不出来。 这个问</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qilinzi/p/10759840.html</dc:identifier>
</item>
<item>
<title>数据结构——基于java的链表实现（真正理解链表这种数据结构） - 会炼钢的小白龙</title>
<link>http://www.cnblogs.com/baixianlong/p/10759599.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baixianlong/p/10759599.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;原创不易，如需转载，请注明出处&lt;a href=&quot;https://www.cnblogs.com/baixianlong/p/10759599.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/baixianlong/p/10759599.html&lt;/a&gt;，否则将追究法律责任！！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;什么是链表&quot;&gt;1、什么是链表？&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。如下图所示，在数据结构中，a1里面的指针存储着a2的地址，这样一个链接一个，就形成了链表。&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/04/21/5cbc2f37397e0.png&quot; alt=&quot;链表001.png&quot;/&gt;&lt;ul&gt;&lt;li&gt;相邻元素之间通过指针链接&lt;/li&gt;
&lt;li&gt;最后一个元素的后继指针为NULL&lt;/li&gt;
&lt;li&gt;在程序执行过程中，链表的长度可以增加或缩小&lt;/li&gt;
&lt;li&gt;链表的空间能够按需分配&lt;/li&gt;
&lt;li&gt;没有内存空间的浪费&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;链表的优缺点&quot;&gt;2、链表的优缺点？&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;优点：
&lt;ul&gt;&lt;li&gt;插入和删除时不需移动其他元素, 只需改变指针,效率高。&lt;/li&gt;
&lt;li&gt;链表各个节点在内存中空间不要求连续，空间利用率高。&lt;/li&gt;
&lt;li&gt;大小没有固定，拓展很灵活。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ul&gt;&lt;li&gt;查找数据时效率低，因为不具有随机访问性。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;链表的种类&quot;&gt;3、链表的种类？&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;有单链表、双向链表、循环单链表、循环双链表等等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/04/21/5cbc30c7ae6a3.png&quot; alt=&quot;单链01.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;链表类的创建以下均已单链表为基准&quot;&gt;1、链表类的创建（以下均已单链表为基准）&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;public class SingleLinkedList {
    //head为头节点，他不存放任何的数据，只是充当一个指向链表中真正存放数据的第一个节点的作用
    public Node head = new Node();  

    //内部类,定义node节点,使用内部类的最大好处是可以和外部类进行私有操作的互相访问
    class Node{
        public int val;  //int类型会导致head节点的val为0，不影响我们学习
        public Node next;
        public Node(){}
        public Node(int val){
            this.val = val;
        }
    } 

    //下面就可以自定义各种链表操作。。。
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;链表添加结点&quot;&gt;2、链表添加结点&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;//找到链表的末尾结点，把新添加的数据作为末尾结点的后续结点
public void add(int data){
    if (head.next == null){
        head.next = new Node(data);
        return;
    }
    Node temp = head;
    while (temp.next != null){
        temp = temp.next;
    }
    temp.next = new Node(data);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;链表删除节点&quot;&gt;3、链表删除节点&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;//把要删除结点的前结点指向要删除结点的后结点，即直接跳过待删除结点
public boolean deleteNode(int index){
    if (index &amp;lt; 0 || index &amp;gt; length() ){
        return false;
    }
    if (index == 1){ //删除头结点
        head = head.next;
        return true;
    }
    Node preNode = head;
    Node curNode = preNode.next;
    int i = 2;
    while (curNode!=null){
        if (index == i){
            preNode.next = curNode.next;  //指向删除节点的后一个节点
            break;
        }
        preNode = curNode;
        curNode = preNode.next;
        i++;
    }
    return true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;链表长度节点获取以及链表遍历&quot;&gt;4、链表长度、节点获取以及链表遍历&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;//获取链表长度
public int length(){
    int length = 0;
    Node temp = head;
    while (temp.next!=null){
        length++;
        temp = temp.next;
    }
    return length;
}


//获取最后一个节点
public Node getLastNode(){
    Node temp = head;
    while (temp.next != null){
        temp = temp.next;
    }
    return temp;
}


//获取第index节点
public Node getNodeByIndex(int index){
    if(index&amp;lt;1 || index&amp;gt;length()){
        return null;
    }
    Node temp = head;
    int i = 1;
    while (temp.next != null){
        temp = temp.next;
        if (index==i){
            break;
        }
        i++;
    }
    return temp;
}


//打印节点
public void printLink(){
    Node curNode = head;
    while(curNode !=null){
        System.out.print(curNode.val+&quot; &quot;);
        curNode = curNode.next;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;查找单链表中的倒数第n个结点&quot;&gt;5、查找单链表中的倒数第n个结点&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;//两个指针，第一个指针向前移动k-1次，之后两个指针共同前进，当前面的指针到达末尾时，后面的指针所在的位置就是倒数第k个位置
public Node findReverNode(int index){
    if(index&amp;lt;1 || index&amp;gt;length()){
        return null;
    }
    Node first = head;
    Node second = head;
    for (int i = 0; i &amp;lt; index - 1; i++) {
        second = second.next;
    }
    while (second.next != null){
        first = first.next;
        second = second.next;
    }
    return first;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;查找单链表中的中间结点&quot;&gt;6、查找单链表中的中间结点&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;//也是设置两个指针first和second，只不过这里是，两个指针同时向前走，second指针每次走两步，
//first指针每次走一步，直到second指针走到最后一个结点时，此时first指针所指的结点就是中间结点。
public Node findMiddleNode(){
    Node slowPoint = head;
    Node quickPoint = head;
    //链表结点个数为奇数时,返回的是中间结点；链表结点个数为偶数时，返回的是中间两个结点中的前个
    while(quickPoint != null &amp;amp;&amp;amp; quickPoint.next != null){
        slowPoint = slowPoint.next;
        quickPoint = quickPoint.next.next;
    }
    return slowPoint;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;从尾到头打印单链表&quot;&gt;7、从尾到头打印单链表&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;//方法一：先反转链表，再输出链表，需要链表遍历两次(不建议这么做,改变了链表的结构)
。。。
//方法二、通过递归来实现（链表很长的时候，就会导致方法调用的层级很深，有可能造成StackOverflowError）
public void reservePrt(Node node){
    if(node != null){
        reservePrt(node.next);
        System.out.print(node.val+&quot; &quot;);
    }
}

//方法三、把链表中的元素放入栈中再输出，需要维护额外的栈空间
public void reservePrt2(Node node){
    if(node != null){
        Stack&amp;lt;Node&amp;gt; stack = new Stack&amp;lt;Node&amp;gt;();  //新建一个栈
        Node current = head;
        //将链表的所有结点压栈
        while (current != null) {
            stack.push(current);  //将当前结点压栈
            current = current.next;
        }
        //将栈中的结点打印输出即可
        while (stack.size() &amp;gt; 0) {
            System.out.print(stack.pop().val+&quot; &quot;);  //出栈操作
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;单链表的反转1-2-3-4变为4-3-2-1&quot;&gt;8、单链表的反转(1-&amp;gt;2-&amp;gt;3-&amp;gt;4变为4-&amp;gt;3-&amp;gt;2-&amp;gt;1)&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;//从头到尾遍历原链表，每遍历一个结点，将其摘下放在新链表的最前端。注意链表为空和只有一个结点的情况。时间复杂度为O（n）
public void reserveLink(){
    Node curNode = head;
    Node preNode = null;
    while (curNode.next != null){
        Node nextNode = curNode.next;
        //主要理解以下逻辑
        curNode.next = preNode; //将current的下一个结点指向新链表的头结点
        preNode = curNode;  //将改变了指向的cruNode赋值给preNode
        curNode = nextNode;
    }
    curNode.next = preNode;
    preNode = curNode;
    head = preNode;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;判断链表是否有环&quot;&gt;9、判断链表是否有环&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/04/22/5cbdd05e3c71b.png&quot; alt=&quot;链表环.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//设置快指针和慢指针，慢指针每次走一步，快指针每次走两步,当快指针与慢指针相等时，就说明该链表有环
public boolean isRinged(){
    if(head == null){
        return false;
    }
    Node slow = head;
    Node fast = head;
    while(fast.next != null &amp;amp;&amp;amp; fast.next.next != null){
        slow = slow.next;
        fast = fast.next.next;
        if(fast == slow){
            return true;
        }
    }
    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;取出有环链表中环的长度&quot;&gt;10、取出有环链表中，环的长度&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/04/21/5cbc918d0ada8.png&quot; alt=&quot;单链环01.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//获取环的相遇点
public Node getFirstMeet(){
    if(head == null){
        return null;
    }
    Node slow = head;
    Node fast = head;
    while(fast.next != null &amp;amp;&amp;amp; fast.next.next != null){
        slow = slow.next;
        fast = fast.next.next;
        if(fast == slow){
            return slow;
        }
    }
    return null;
}

//首先得到相遇的结点，这个结点肯定是在环里，我们可以让这个结点对应的指针一直往下走，直到它回到原点，就可以算出环的长度
public int getCycleLength(){
    Node current = getFirstMeet(); //获取相遇点
    int length = 0;
    while (current != null) {
        current = current.next;
        length++;
        if (current == getFirstMeet()) {  //当current结点走到原点的时候
            return length;
        }
    }
    return length;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;判断两个链表是否相交&quot;&gt;11、判断两个链表是否相交&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;//两个链表相交，则它们的尾结点一定相同，比较两个链表的尾结点是否相同即可
public boolean isCross(Node head1, Node head2){
    Node temp1 = head1;
    Node temp2 = head2;
    while(temp1.next != null){
        temp1 = temp1.next;
    }
    while(temp2.next != null){
        temp2 = temp2.next;
    }
    if(temp1 == temp2){
        return true;
    }
    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如果链表相交求链表相交的起始点&quot;&gt;12、如果链表相交，求链表相交的起始点&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/04/22/5cbdcd3084d07.png&quot; alt=&quot;链表相交01.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; /**
 * 如果链表相交，求链表相交的起始点：
 * 1、首先判断链表是否相交，如果两个链表不相交，则求相交起点没有意义
 * 2、求出两个链表长度之差：len=length1-length2
 * 3、让较长的链表先走len步
 * 4、然后两个链表同步向前移动，每移动一次就比较它们的结点是否相等，第一个相等的结点即为它们的第一个相交点
 */
public Node findFirstCrossPoint(SingleLinkedList linkedList1, SingleLinkedList linkedList2){
    //链表不相交
    if(!isCross(linkedList1.head,linkedList2.head)){
        return null;
    }else{
        int length1 = linkedList1.length();//链表1的长度
        int length2 = linkedList2.length();//链表2的长度
        Node temp1 = linkedList1.head;//链表1的头结点
        Node temp2 = linkedList2.head;//链表2的头结点
        int len = length1 - length2;//链表1和链表2的长度差

        if(len &amp;gt; 0){//链表1比链表2长，链表1先前移len步        
            for(int i=0; i&amp;lt;len; i++){
                temp1 = temp1.next;
            }
        }else{//链表2比链表1长，链表2先前移len步
            for(int i=0; i&amp;lt;len; i++){
                temp2 = temp2.next;
            }
        }
        //链表1和链表2同时前移,直到找到链表1和链表2相交的结点
        while(temp1 != temp2){
            temp1 = temp1.next;
            temp2 = temp2.next;
        }
        return temp1;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;合并两个有序的单链表将1-2-3和1-3-4合并为1-1-2-3-3-4&quot;&gt;13、合并两个有序的单链表（将1-&amp;gt;2-&amp;gt;3和1-&amp;gt;3-&amp;gt;4合并为1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;3-&amp;gt;4）&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;//两个参数代表的是两个链表的头结点
//方法一
public Node mergeLinkList(Node head1, Node head2) {
    if (head1 == null &amp;amp;&amp;amp; head2 == null) {  //如果两个链表都为空
        return null;
    }
    if (head1 == null) {
        return head2;
    }
    if (head2 == null) {
        return head1;
    }
    Node head; //新链表的头结点
    Node current;  //current结点指向新链表
    // 一开始，我们让current结点指向head1和head2中较小的数据，得到head结点
    if (head1.val &amp;lt;= head2.val) {
        head = head1;
        current = head1;
        head1 = head1.next;
    } else {
        head = head2;
        current = head2;
        head2 = head2.next;
    }

    while (head1 != null &amp;amp;&amp;amp; head2 != null) {
        if (head1.val &amp;lt;= head2.val) {
            current.next = head1;  //新链表中，current指针的下一个结点对应较小的那个数据
            current = current.next; //current指针下移
            head1 = head1.next;
        } else {
            current.next = head2;
            current = current.next;
            head2 = head2.next;
        }
    }
    //合并剩余的元素
    if (head1 != null) { //说明链表2遍历完了，是空的
        current.next = head1;
    }
    if (head2 != null) { //说明链表1遍历完了，是空的
        current.next = head2;
    }
    return head;
}


//方法二：递归法
public Node merge(Node head1, Node head2) {
        if(head1 == null){
            return head2;
        }
        if(head2 == null){
            return head1;
        }
        Node head = null;
        if(head1.val &amp;lt;= head2.val){
            head = head1;
            head.next = merge(head1.next,head2);
        }else{
            head = head2;
            head.next = merge(head1,head2.next);
        }
        return head;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;到此单链表的一些常见操作展示的差不多了,如有兴趣可继续深入研究~~~&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;双向链表java.util中的linkedlist就是双链的一种实现&quot;&gt;1、双向链表（java.util中的LinkedList就是双链的一种实现）&lt;/h2&gt;
&lt;p&gt;　　双向链表(双链表)是链表的一种。和单链表一样，双链表也是由节点组成，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/04/22/5cbde41abdf46.png&quot; alt=&quot;双向链表.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;优点：对于链表中一个给的的结点，可以从两个方向进行操，双向链表相对单链表更适合元素的查询工作。&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ul&gt;&lt;li&gt;每个结点需要再添加一个额外的指针，因此需要更多的空间开销。&lt;/li&gt;
&lt;li&gt;结点的插入或者删除更加费时。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;以下是双链的相关实现和操作其实单链弄明白了双链只不过多维护了个前节点&quot;&gt;以下是双链的相关实现和操作(其实单链弄明白了，双链只不过多维护了个前节点)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/04/23/5cbf1f5bf37d0.jpg&quot; alt=&quot;双链插入.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/04/23/5cbf1f5c14cbe.jpg&quot; alt=&quot;双链删除.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/04/23/5cbf1fa0c68e3.jpg&quot; alt=&quot;双链尾插.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/04/23/5cbf1fa0c7c90.jpg&quot; alt=&quot;双链尾删.jpg&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class DoubleLink&amp;lt;T&amp;gt; {

    // 表头
    private DNode&amp;lt;T&amp;gt; mHead;
    // 节点个数
    private int mCount;

    // 双向链表“节点”对应的结构体
    private class DNode&amp;lt;T&amp;gt; {
        public DNode prev;
        public DNode next;
        public T value;

        public DNode(T value, DNode prev, DNode next) {
            this.value = value;
            this.prev = prev;
            this.next = next;
        }
    }

    // 构造函数
    public DoubleLink() {
        // 创建“表头”。注意：表头没有存储数据！
        mHead = new DNode&amp;lt;T&amp;gt;(null, null, null);
        mHead.prev = mHead.next = mHead;
        // 初始化“节点个数”为0
        mCount = 0;
    }

    // 返回节点数目
    public int size() {
        return mCount;
    }

    // 返回链表是否为空
    public boolean isEmpty() {
        return mCount==0;
    }

    // 获取第index位置的节点
    private DNode&amp;lt;T&amp;gt; getNode(int index) {
        if (index&amp;lt;0 || index&amp;gt;=mCount)
            throw new IndexOutOfBoundsException();

        // 正向查找
        if (index &amp;lt;= mCount/2) {
            DNode&amp;lt;T&amp;gt; node = mHead.next;
            for (int i=0; i&amp;lt;index; i++)
                node = node.next;

            return node;
        }

        // 反向查找
        DNode&amp;lt;T&amp;gt; rnode = mHead.prev;
        int rindex = mCount - index -1;
        for (int j=0; j&amp;lt;rindex; j++)
            rnode = rnode.prev;

        return rnode;
    }

    // 获取第index位置的节点的值
    public T get(int index) {
        return getNode(index).value;
    }

    // 获取第1个节点的值
    public T getFirst() {
        return getNode(0).value;
    }

    // 获取最后一个节点的值
    public T getLast() {
        return getNode(mCount-1).value;
    }

    // 将节点插入到第index位置之前
    public void insert(int index, T t) {
        if (index==0) {
            DNode&amp;lt;T&amp;gt; node = new DNode&amp;lt;T&amp;gt;(t, mHead, mHead.next);
            mHead.next.prev = node;
            mHead.next = node;
            mCount++;
            return ;
        }

        DNode&amp;lt;T&amp;gt; inode = getNode(index);
        DNode&amp;lt;T&amp;gt; tnode = new DNode&amp;lt;T&amp;gt;(t, inode.prev, inode);
        inode.prev.next = tnode;
        inode.next = tnode;
        mCount++;
        return ;
    }

    // 将节点插入第一个节点处。
    public void insertFirst(T t) {
        insert(0, t);
    }

    // 将节点追加到链表的末尾
    public void appendLast(T t) {
        DNode&amp;lt;T&amp;gt; node = new DNode&amp;lt;T&amp;gt;(t, mHead.prev, mHead);
        mHead.prev.next = node;
        mHead.prev = node;
        mCount++;
    }

    // 删除index位置的节点
    public void del(int index) {
        DNode&amp;lt;T&amp;gt; inode = getNode(index);
        inode.prev.next = inode.next;
        inode.next.prev = inode.prev;
        inode = null;
        mCount--;
    }

    // 删除第一个节点
    public void deleteFirst() {
        del(0);
    }

    // 删除最后一个节点
    public void deleteLast() {
        del(mCount-1);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;循环单链表循环双链表操作和单链双链是一样的不赘述了&quot;&gt;2、循环单链表、循环双链表（操作和单链、双链是一样的，不赘述了）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/04/23/5cbf21b0d752a.png&quot; alt=&quot;单向循环002.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/04/23/5cbf21b0d1df4.png&quot; alt=&quot;双向循环002.png&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;本文主要是对于链表这种数据结构的介绍和认知，明白链表的优劣势。&lt;/li&gt;
&lt;li&gt;重点是要学会对于单链的操作，体会它的一些独到之处，至于其它衍生链表，举一反三而已！！！&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;个人博客地址：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;0.94186046511628&quot;&gt;
&lt;blockquote readability=&quot;1.2558139534884&quot;&gt;
&lt;p&gt;cnblogs:&lt;a href=&quot;https://www.cnblogs.com/baixianlong&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/baixianlong&lt;/a&gt;&lt;br/&gt;csdn:&lt;a href=&quot;https://blog.csdn.net/tiantuo6513&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/tiantuo6513&lt;/a&gt;&lt;br/&gt;segmentfault:&lt;a href=&quot;https://segmentfault.com/u/baixianlong&quot; class=&quot;uri&quot;&gt;https://segmentfault.com/u/baixianlong&lt;/a&gt;&lt;br/&gt;github:&lt;a href=&quot;https://github.com/xianlongbai&quot; class=&quot;uri&quot;&gt;https://github.com/xianlongbai&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 23 Apr 2019 14:52:00 +0000</pubDate>
<dc:creator>会炼钢的小白龙</dc:creator>
<og:description>原创不易，如需转载，请注明出处 'https://www.cnblogs.com/baixianlong/p/10759599.html' ，否则将追究法律责任！！！ 一、链表介绍 1、什么是链表？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/baixianlong/p/10759599.html</dc:identifier>
</item>
<item>
<title>记一次重大生产事故，在那 0.1s 我想辞职不干了！ - 悟空聊架构</title>
<link>http://www.cnblogs.com/jackson0714/p/case1.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jackson0714/p/case1.html</guid>
<description>
&lt;div class=&quot;note&quot; readability=&quot;99&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.那是一个阳光明媚的下午，老婆和她的闺蜜正在美丽的湖边公园闲逛（我是拎包拍照的）。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.突然&lt;/strong&gt;接到甲方运营小妹的微信：有个顾客线上付款了，但是没有到账，后台卡在微信支付成功（正常状态是充值成功）。&lt;/p&gt;
&lt;p&gt;我第一反应是第三方充值系统挂了吧，然后让运营小妹查下后台的异常提示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.过了2分钟之后&lt;/strong&gt;，我还是不放心，用手机（当时没有背电脑出门）登陆后台看了下，发现后台已经进不去了，猜测可能是我的网络不好（公园的移动信号不给力，只有1格信号）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.过了10分钟&lt;/strong&gt;，客服小妹没有用微信联系我，而是直接给我打电话了，反应&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;（1）后台登陆不进去了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  （2）前端已经打不开了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  （3）很多用户未充值成功，&lt;strong&gt;&lt;span&gt;客服群要炸了！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.这个时候&lt;/strong&gt;我意识到我们系统&lt;span&gt;可能挂了&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.电话挂了后&lt;/strong&gt;，赶紧给我们运维老大打了个电话，反馈我们的后台不能访问了，是不是系统性能有问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7.运维老大过了几分钟回了电话&lt;/strong&gt;：&lt;span&gt;DB服务器的CPU到100%了，有2个慢查询，先让我解决慢查询问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我有点没办法了，我在外面，看不了代码，也提交不了代码改动啊！运维老大说他那边先看看怎么处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8.这个时候&lt;/strong&gt;，甲方拉了个群，将各方项目经理+开发负责人都拨通了，我发现我们项目经理没接入进去（他当时在忙其他事情）。我知道甲方老大肯定会审问我。&lt;/p&gt;
&lt;p&gt;作为开发负责人，跟我聊这里功能该怎么实现，我可以跟你说清楚，遇到这种特大事故我也不知道怎么处理。&lt;/p&gt;
&lt;p&gt;甲方开始追问各方的负责人，到底是哪方问题，语气非常严肃。各方的负责人也是非常客气，都说是在排查。等问到我们这一方的时候，我说到是我们系统出了问题，运维老大正在处理。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;然后甲方就开始斥责了：什么时候能好？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我：这个不好说。运维正在看。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;甲方：到底能不能修好？（后面说的脏话我就不在这里提了，大家自己去想吧。）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;9.那个时刻&lt;/strong&gt;，我好想怼回去，我哪知道什么时候能好。但我不能怼啊，各方老大们都在呢，而且我不敢惹甲方。很想跟PM说辞职不干了&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;10.这个时候，我们的PM接入了&lt;/strong&gt;，甲方就转向我们PM了，PM回复大概1个小时能恢复。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;11.然后&lt;/strong&gt;PM就打电话给我了，问了我怎么导致挂的，我说有慢查询，然后他跟我说运维进行了一定的扩容，但还是不起作用，运维正在升级最高配置，估计1个小时候能好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;12.这个时候&lt;/strong&gt;我的心算是安定了一点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;13.事情还没完&lt;/strong&gt;，线上大批客服都付款了，但是没有充值成功该怎么处理？是走手动退款，还是等系统恢复后，自动开始充值？&lt;/p&gt;
&lt;p&gt;这里要提一点，我们的系统会将订单存到队列里面，然后从队列里面取一部分订单进行充值，如果贸然退款，可能会出现充值成功，而钱退了的情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;14.离问题已经过去了半个小时&lt;/strong&gt;，线上已经有很多顾客开始投诉了，要求退款，运营方和店员都很焦急，而后台系统无法登陆，根本无法进行任何操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;15.又过了半个小时&lt;/strong&gt;，PM告诉甲方我们的服务已经恢复，我终于可以登陆后台查看数据了，但是由于手机信号不好，我只能跑到信号稍好的地方登陆后台（也只有2格信号），发现已经有很多笔订单都卡在支付成功那一块，没有进行下一步的充值，而我也不敢轻易进行退款，因为系统会从这些未充值订单中一条条进行充值操作，&lt;span&gt;退款后会导致账不平，那就更麻烦了&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;16.等了5分钟后&lt;/strong&gt;，发现有几笔订单确实在服务器恢复后进行了自动充值，所以我认为所有异常订单都会进行自动充值。于是我跟运营小妹反馈那些订单都会自动冲上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;17.我还是太天真了，过了几分钟后&lt;/strong&gt;，有很多订单还是卡在支付成功的状态，没有进行下一步充值操作，这个时候我意识到问题的严重性，得赶紧回家了，跟PM说我半个小时能到家，到家后，我来排查这些异常订单。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;18.然后&lt;/strong&gt;走到老婆和她闺蜜旁边，很不好意思的告诉她们，我得回家一趟，而且必须马上，线上出问题了，老婆是见过这种场面的，知道我周末经常需要处理线上问题，闺蜜也很能理解，唯一遗憾的是，她们啥都没玩到就得回去了，感谢老婆和她闺蜜的理解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;19.到家后&lt;/strong&gt;，我开始排查问题，发现异常订单不可能进行自动充值操作了，只能走手动退款了，然后告诉他们这些订单都需要手动退款。晚上9点能搞定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;20.到9点了&lt;/strong&gt;，这些订单都处理完了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;21.事情告一段落。&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;解决慢查询的方案很简单：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一张表数据量为40w，缺少索引&lt;/p&gt;
&lt;p&gt;第二张表数据量为16w，缺少索引&lt;/p&gt;
&lt;p&gt;加了两个索引后，问题顺利解决。（MongoDB在数据量几十万的级别也会出现慢查询）&lt;/p&gt;
&lt;p&gt;这是当时慢查询的监控图，慢查询数量最高时到达500个。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;file:///C:/Users/ADMINI~1/AppData/Local/Temp/enhtmlclip/Image(1).png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;data:image/png;base64,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&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;（1）第三方在他们的前端没做节流，用户频繁点击按钮来调用我们的接口，加快了服务器宕机。&lt;/p&gt;

&lt;p&gt;（1）上线前一定要做压测。（后来多方都进行了接口压测。）&lt;/p&gt;
&lt;p&gt;（2）为避免忘加索引，建议每张表的高频查询都加上索引，不论今后数据量是多还是少。&lt;/p&gt;
&lt;p&gt;（3）前端高频操作，需要做节流&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;其实主要是技术能力不足，想出去找个好岗位好平台的也不好找（怕别人不要），&lt;span&gt;还是多练练技术吧~~~&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; 不喜勿喷~~&lt;/p&gt;

&lt;div id=&quot;MySignature&quot; readability=&quot;9.9811866859624&quot;&gt;
&lt;p&gt;&lt;br/&gt;作　　者：&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/jackson0714/&quot; target=&quot;_blank&quot;&gt;Jackson0714&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;出　　处：&lt;a href=&quot;http://www.cnblogs.com/jackson0714/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/jackson0714/&lt;/a&gt;&lt;br/&gt;关于作者：专注于微软平台的项目开发。如有问题或建议，请多多赐教！&lt;br/&gt;版权声明：本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;br/&gt;特此声明：所有评论和私信都会在第一时间回复。也欢迎园子的大大们指正错误，共同进步。或者&lt;a href=&quot;http://msg.cnblogs.com/msg/send/jackson0714&quot;&gt;直接私信&lt;/a&gt;我&lt;br/&gt;声援博主：如果您觉得文章对您有帮助，可以点击文章右下角&lt;strong&gt;&lt;span&gt;【&lt;a id=&quot;post-up&quot; onclick=&quot;votePost(5111347,'Digg')&quot; href=&quot;javascript:void(0);&quot;&gt;推荐&lt;/a&gt;】&lt;/span&gt;&lt;/strong&gt;一下。您的鼓励是作者坚持原创和持续写作的最大动力！&lt;br/&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;
&lt;h2&gt;公众号：悟空聊架构&lt;/h2&gt;
&lt;/p&gt;
&lt;br/&gt;&lt;div&gt;&lt;img class=&quot;img_avatar&quot; src=&quot;https://images.cnblogs.com/cnblogs_com/jackson0714/809472/o_wkljg.png&quot; alt=&quot;jackson0714&quot; width=&quot;190&quot; height=&quot;190&quot; data-bd-imgshare-binded=&quot;1&quot;/&gt;&lt;img class=&quot;img_avatar&quot; src=&quot;https://images.cnblogs.com/cnblogs_com/jackson0714/809472/o_qrcode_wkljg.jpg&quot; alt=&quot;jackson0714&quot; width=&quot;190&quot; height=&quot;190&quot; data-bd-imgshare-binded=&quot;1&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 23 Apr 2019 14:48:00 +0000</pubDate>
<dc:creator>悟空聊架构</dc:creator>
<og:description>一、发生了什么？ 1.那是一个阳光明媚的下午，老婆和她的闺蜜正在美丽的湖边公园闲逛（我是拎包拍照的）。 2.突然接到甲方运营小妹的微信：有个顾客线上付款了，但是没有到账，后台卡在微信支付成功（正常状态</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jackson0714/p/case1.html</dc:identifier>
</item>
<item>
<title>[区块链\BTC原理\源码]用 Go 构建一个区块链原型 - 勋爵</title>
<link>http://www.cnblogs.com/X-knight/p/10759493.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/X-knight/p/10759493.html</guid>
<description>&lt;div readability=&quot;53.441929133858&quot;&gt;
&lt;h2&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文构建了一个使用工作量证明机制（POW）的类BTC的区块链。将区块链持久化到一个Bolt数据库中，然后会提供一个简单的命令行接口，用来完成一些与区块链的交互操作。这篇文章目的是希望帮助大家理解BTC源码的架构，所以主要专注于的实现原理及存储上，暂时忽略了 “分布式” 这个部分。严格意义上还不能算是一个完全意义上的区块链系统。&lt;/p&gt;
&lt;h2&gt;开发环境&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;语言：GO;&lt;/p&gt;
&lt;p&gt;数据库：BoltDB;&lt;/p&gt;
&lt;p&gt;IDE： Goland或其他工具都可以;&lt;/p&gt;
&lt;p&gt;系统：不限，本文使用windows。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;BoltDB数据库&lt;/h3&gt;
&lt;p&gt;实际上，选择任何一个数据库都可以，本文先用的是BoltDB。在比特币白皮书中，并没有提到要使用哪一个具体的数据库，它完全取决于开发者如何选择。现在是比特币的一个参考实现，Bitcoin core使用的是是LevelDB。&lt;/p&gt;
&lt;p&gt;BoltDB安装及使用可以参考&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/X-knight/p/10753833.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;《BoltDB简单使用教程》&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BoltDB有如下优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;非常简单和简约&lt;/li&gt;
&lt;li&gt;用 Go 实现&lt;/li&gt;
&lt;li&gt;不需要运行一个服务器&lt;/li&gt;
&lt;li&gt;能够允许我们构造想要的数据结构&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;由于 Bolt 意在用于提供一些底层功能，简洁便成为其关键所在。它的API 并不多，并且仅关注值的获取和设置。仅此而已。&lt;/p&gt;
&lt;p&gt;Bolt 使用键值存储，数据被存储为键值对（key-value pair，就像 Golang 的 map）。键值对被存储在 bucket 中，这是为了将相似的键值对进行分组（类似 RDBMS 中的表格）。因此，为了获取一个值，你需要知道一个 bucket 和一个键（key）。&lt;/p&gt;
&lt;p&gt;需要&lt;span&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/span&gt;的一个事情是，Bolt 数据库没有数据类型：键和值都是字节数组（byte array）。鉴于需要在里面存储 Go 的结构（准确来说，也就是存储&lt;strong&gt;（块）Block&lt;/strong&gt;），我们需要对它们进行序列化，也就说，实现一个从 Go struct 转换到一个 byte array 的机制，同时还可以从一个 byte array 再转换回 Go struct。虽然我们将会使用 &lt;a href=&quot;https://link.jianshu.com?t=https://golang.org/pkg/encoding/gob/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;encoding/gob&lt;/a&gt; 来完成这一目标，但实际上也可以选择使用 &lt;strong&gt;JSON&lt;/strong&gt;, &lt;strong&gt;XML&lt;/strong&gt;, &lt;strong&gt;Protocol Buffers&lt;/strong&gt; 等等。之所以选择使用 &lt;strong&gt;encoding/gob&lt;/strong&gt;, 是因为它很简单，而且是 Go 标准库的一部分。&lt;/p&gt;
&lt;h2&gt;数据库结构&lt;/h2&gt;
&lt;p&gt;在开始实现持久化的逻辑之前，我们首先需要决定到底要如何在数据库中进行存储。为此，我们可以参考 Bitcoin Core 的做法：&lt;/p&gt;
&lt;p&gt;简单来说，Bitcoin Core 使用两个 “bucket” 来存储数据：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;其中一个 bucket 是 &lt;strong&gt;blocks&lt;/strong&gt;，它存储了描述一条链中所有块的元数据&lt;/li&gt;
&lt;li&gt;另一个 bucket 是 &lt;strong&gt;chainstate&lt;/strong&gt;，存储了一条链的状态，也就是当前所有的未花费的交易输出，和一些元数据&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;此外，出于性能的考虑，Bitcoin Core 将每个区块（block）存储为磁盘上的不同文件。如此一来，就不需要仅仅为了读取一个单一的块而将所有（或者部分）的块都加载到内存中。但是，为了简单起见，我们并不会实现这一点。&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;blocks&lt;/strong&gt; 中，&lt;strong&gt;key -&amp;gt; value&lt;/strong&gt; 为：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;b&lt;/code&gt; + 32 字节的 block hash&lt;/td&gt;
&lt;td&gt;block index record&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;f&lt;/code&gt; + 4 字节的 file number&lt;/td&gt;
&lt;td&gt;file information record&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;l&lt;/code&gt; + 4 字节的 file number&lt;/td&gt;
&lt;td&gt;the last block file number used&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;R&lt;/code&gt; + 1 字节的 boolean&lt;/td&gt;
&lt;td&gt;是否正在 reindex&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;F&lt;/code&gt; + 1 字节的 flag name length + flag name string&lt;/td&gt;
&lt;td&gt;1 byte boolean: various flags that can be on or off&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;t&lt;/code&gt; + 32 字节的 transaction hash&lt;/td&gt;
&lt;td&gt;transaction index record&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;在 &lt;strong&gt;chainstate&lt;/strong&gt;，&lt;strong&gt;key -&amp;gt; value&lt;/strong&gt; 为：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;c&lt;/code&gt; + 32 字节的 transaction hash&lt;/td&gt;
&lt;td&gt;unspent transaction output record for that transaction&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;B&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;32 字节的 block hash: the block hash up to which the database represents the unspent transaction outputs&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;因为目前还没有交易，所以我们只需要 &lt;strong&gt;blocks&lt;/strong&gt; bucket。另外，正如上面提到的，我们会将整个数据库存储为单个文件，而不是将区块存储在不同的文件中。所以，我们也不会需要文件编号（file number）相关的东西。最终，我们会用到的键值对有：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;32 字节的 block-hash -&amp;gt; block 结构&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l&lt;/code&gt; -&amp;gt; 链中最后一个块的 hash&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这就是实现持久化机制所有需要了解的内容了。&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;系统实现&lt;/h2&gt;
&lt;h3&gt;1.区块文件block.go&lt;/h3&gt;
&lt;p&gt;该部分主要包括：&lt;/p&gt;
&lt;p&gt;对区块结构的定义；创建区块的方法&lt;strong&gt;&lt;span&gt;NewBlock（）&lt;/span&gt;&lt;/strong&gt;；区块的序列化&lt;strong&gt;&lt;span&gt;Serialize（）&lt;/span&gt;&lt;/strong&gt;与反序列化&lt;strong&gt;&lt;span&gt;Deserialize（）&lt;/span&gt;&lt;/strong&gt;函数；以及创世区块的生成&lt;strong&gt;&lt;span&gt;NewGenesisBlock()&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个区块的结构Block&lt;/span&gt;
type Block &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;版本号&lt;/span&gt;
&lt;span&gt;    Version int64
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父区块头哈希值&lt;/span&gt;
    PreBlockHash []&lt;span&gt;byte&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前区块的Hash值, 为了简化代码&lt;/span&gt;
    Hash []&lt;span&gt;byte&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Merkle根&lt;/span&gt;
    MerkleRoot []&lt;span&gt;byte&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;时间戳&lt;/span&gt;
&lt;span&gt;    TimeStamp int64
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;难度值&lt;/span&gt;
&lt;span&gt;    Bits int64
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;随机值&lt;/span&gt;
&lt;span&gt;    Nonce int64

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交易信息&lt;/span&gt;
    Data []&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提供一个创建区块的方法&lt;/span&gt;
func NewBlock(data &lt;span&gt;string&lt;/span&gt;, preBlockHash []&lt;span&gt;byte&lt;/span&gt;) *&lt;span&gt;Block {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; block Block
    block &lt;/span&gt;=&lt;span&gt; Block{
        Version:      &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
        PreBlockHash: preBlockHash,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Hash TODO&lt;/span&gt;
        MerkleRoot: []&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;{},
        TimeStamp:  time.Now().Unix(),
        Bits:       targetBits,
        Nonce:      &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
        Data:       []&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;(data)}
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;block.SetHash()&lt;/span&gt;
    pow := NewProofOfWork(&amp;amp;&lt;span&gt;block)
    nonce, hash :&lt;/span&gt;=&lt;span&gt; pow.Run()
    block.Nonce &lt;/span&gt;=&lt;span&gt; nonce
    block.Hash &lt;/span&gt;=&lt;span&gt; hash

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;amp;&lt;span&gt;block
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 Block 序列化为一个字节数组&lt;/span&gt;
func (block *Block) Serialize() []&lt;span&gt;byte&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; buffer bytes.Buffer
    encoder :&lt;/span&gt;= gob.NewEncoder(&amp;amp;&lt;span&gt;buffer)

    err :&lt;/span&gt;=&lt;span&gt; encoder.Encode(block)
    CheckErr(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Serialize&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, err)

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; buffer.Bytes()
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将字节数组反序列化为一个 Block&lt;/span&gt;
func Deserialize(data []&lt;span&gt;byte&lt;/span&gt;) *&lt;span&gt;Block {

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; len(data) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nil
    }

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; block Block

    decoder :&lt;/span&gt;=&lt;span&gt; gob.NewDecoder(bytes.NewReader(data))
    err :&lt;/span&gt;= decoder.Decode(&amp;amp;&lt;span&gt;block)
    CheckErr(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Deserialize&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, err)

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;amp;&lt;span&gt;block
}


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创世块&lt;/span&gt;
func NewGenesisBlock() *&lt;span&gt;Block {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; NewBlock(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Genesis Block&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, []&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;{})
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2.区块链blockChain.go&lt;/h3&gt;
&lt;p&gt;该部分内容主要包括：&lt;/p&gt;
&lt;pre&gt;
定义一个区块链结构&lt;strong&gt;&lt;span&gt;BlockChain结构体&lt;/span&gt;&lt;/strong&gt;；
&lt;/pre&gt;
&lt;pre&gt;
提供一个创建BlockChain的方法&lt;strong&gt;&lt;span&gt;NewBlockChain()&lt;/span&gt;&lt;/strong&gt;；
&lt;/pre&gt;
&lt;pre readability=&quot;4&quot;&gt;
提供一个添加区块的方法&lt;strong&gt;&lt;span&gt;AddBlock(data string&lt;/span&gt;&lt;/strong&gt;&lt;span readability=&quot;2&quot;&gt;&lt;strong&gt;&lt;span&gt;)&lt;/span&gt;&lt;/strong&gt;；&lt;p&gt;迭代器对区块进行遍历。&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; dbFile = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;blockchain.db&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; blocksBucket = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bucket&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; lastHashKey = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个区块链结构BlockChain&lt;/span&gt;
type BlockChain &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;blocks []*Block
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据库的操作句柄&lt;/span&gt;
    db *&lt;span&gt;bolt.DB
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;tail尾巴，表示最后一个区块的哈希值
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在链的末端可能出现短暂分叉的情况，所以选择tail其实也就是选择了哪条链&lt;/span&gt;
    tail []&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提供一个创建BlockChain的方法&lt;/span&gt;
func NewBlockChain() *&lt;span&gt;BlockChain {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打开一个 BoltDB 文件
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;func Open(path string, mode os.FileMode, options *Options) (*DB, error)&lt;/span&gt;
    db, err := bolt.Open(dbFile, &lt;span&gt;0600&lt;/span&gt;&lt;span&gt;, nil)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;utils中的校验函数，校验错误&lt;/span&gt;
    CheckErr(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NewBlockChain1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, err)

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; lastHash []&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;

    err &lt;/span&gt;= db.Update(func(tx *&lt;span&gt;bolt.Tx) error {
        bucket :&lt;/span&gt;= tx.Bucket([]&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;(blocksBucket))

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果数据库中不存在bucket,要去创建创世区块，将数据填写到数据库的bucket中&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; bucket ==&lt;span&gt; nil {
            fmt.Println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No existing blockchain found. Creating a new one...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            genesis :&lt;/span&gt;=&lt;span&gt; NewGenesisBlock()

            bucket, err :&lt;/span&gt;= tx.CreateBucket([]&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;(blocksBucket))
            CheckErr(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NewBlockChain2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, err)

            err &lt;/span&gt;=&lt;span&gt; bucket.Put(genesis.Hash, genesis.Serialize())
            CheckErr(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NewBlockChain3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, err)

            err &lt;/span&gt;= bucket.Put([]&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;(lastHashKey), genesis.Hash)
            CheckErr(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NewBlockChain4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, err)
            lastHash &lt;/span&gt;=&lt;span&gt; genesis.Hash
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接读取最后区块的哈希值&lt;/span&gt;
            lastHash = bucket.Get([]&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;(lastHashKey))
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nil
    })

    CheckErr(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;db.Update&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, err)

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;amp;&lt;span&gt;BlockChain{db, lastHash}
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提供一个添加区块的方法&lt;/span&gt;
func (bc *BlockChain) AddBlock(data &lt;span&gt;string&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; preBlockHash []&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;

    err :&lt;/span&gt;= bc.db.View(func(tx *&lt;span&gt;bolt.Tx) error {
        bucket :&lt;/span&gt;= tx.Bucket([]&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;(blocksBucket))
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; bucket ==&lt;span&gt; nil {
            os.Exit(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        }

        preBlockHash &lt;/span&gt;= bucket.Get([]&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;(lastHashKey))
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nil
    })
    CheckErr(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AddBlock-View&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, err)

    block :&lt;/span&gt;=&lt;span&gt; NewBlock(data, preBlockHash)
    err &lt;/span&gt;= bc.db.Update(func(tx *&lt;span&gt;bolt.Tx) error {
        bucket :&lt;/span&gt;= tx.Bucket([]&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;(blocksBucket))
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; bucket ==&lt;span&gt; nil {
            os.Exit(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        }

        err &lt;/span&gt;=&lt;span&gt; bucket.Put(block.Hash, block.Serialize())
        CheckErr(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AddBlock1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, err)

        err &lt;/span&gt;= bucket.Put([]&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;(lastHashKey), block.Hash)
        CheckErr(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AddBlock2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, err)
        bc.tail &lt;/span&gt;=&lt;span&gt; block.Hash
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nil
    })
    CheckErr(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AddBlock-Update&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, err)
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;迭代器，就是一个对象，它里面包含了一个游标，一直向前/后移动，完成整个容器的遍历&lt;/span&gt;
type BlockChainIterator &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
    currentHash []&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;
    db          &lt;/span&gt;*&lt;span&gt;bolt.DB
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建迭代器，同时初始化为指向最后一个区块&lt;/span&gt;
func (bc *BlockChain) NewIterator() *&lt;span&gt;BlockChainIterator {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;amp;&lt;span&gt;BlockChainIterator{bc.tail, bc.db}
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回链中的下一个块&lt;/span&gt;
func (it *BlockChainIterator) Next() (block *&lt;span&gt;Block) {

    err :&lt;/span&gt;= it.db.View(func(tx *&lt;span&gt;bolt.Tx) error {
        bucket :&lt;/span&gt;= tx.Bucket([]&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;(blocksBucket))
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; bucket ==&lt;span&gt; nil {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nil
        }
        data :&lt;/span&gt;=&lt;span&gt; bucket.Get(it.currentHash)
        block &lt;/span&gt;=&lt;span&gt; Deserialize(data)
        it.currentHash &lt;/span&gt;=&lt;span&gt; block.PreBlockHash
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nil
    })
    CheckErr(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Next&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, err)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3.工作量证明机制POW.go&lt;/h3&gt;
&lt;p&gt;该部分主要包括：&lt;/p&gt;
&lt;p&gt;创建POW的方法&lt;strong&gt;&lt;span&gt;NewProofOfWork(block *Block)&lt;/span&gt;&lt;/strong&gt; ；&lt;/p&gt;
&lt;p&gt;计算哈希值的方法&lt;em id=&quot;__mceDel&quot;&gt; &lt;/em&gt;&lt;strong&gt;&lt;span&gt;Run() (int64, []byte)&lt;/span&gt;&lt;/strong&gt;&lt;em id=&quot;__mceDel&quot;&gt;；&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个工作量证明的结构ProofOfWork&lt;/span&gt;
type ProofOfWork &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
    block &lt;/span&gt;*&lt;span&gt;Block
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;目标值&lt;/span&gt;
    target *&lt;span&gt;big.Int
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;难度值常量&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; targetBits = &lt;span&gt;20&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建POW的方法&lt;/span&gt;
func NewProofOfWork(block *Block) *&lt;span&gt;ProofOfWork {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;000000000000000... 01&lt;/span&gt;
    target := big.NewInt(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;0x1000000000000...00&lt;/span&gt;
    target.Lsh(target, &lt;span&gt;uint&lt;/span&gt;(&lt;span&gt;256&lt;/span&gt;-&lt;span&gt;targetBits))

    pow :&lt;/span&gt;=&lt;span&gt; ProofOfWork{block: block, target: target}
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;amp;&lt;span&gt;pow
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给Run()准备数据&lt;/span&gt;
func (pow *ProofOfWork) PrepareData(nonce int64) []&lt;span&gt;byte&lt;/span&gt;&lt;span&gt; {
    block :&lt;/span&gt;=&lt;span&gt; pow.block
    tmp :&lt;/span&gt;= [][]&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
            需要将block中的不同类型都转化为byte，以便进行连接
        &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        IntToByte(block.Version),
        block.PreBlockHash,
        block.MerkleRoot,
        IntToByte(block.TimeStamp),
        IntToByte(nonce),
        IntToByte(targetBits),
        block.Data}
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;func Join(s [][]byte, sep []byte) []byte&lt;/span&gt;
    data := bytes.Join(tmp, []&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;{})
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; data
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算哈希值的方法&lt;/span&gt;
func (pow *ProofOfWork) Run() (int64, []&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;伪代码
    for nonce {
        hash := sha256(block数据 + nonce)
        if 转换（Hash）&amp;lt; pow.target{
            找到了
        }else{
        nonce++
        }
    }
    return nonce，hash{:}
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.拼装数据
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.哈希值转成big.Int类型&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; hash [&lt;span&gt;32&lt;/span&gt;]&lt;span&gt;byte&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; nonce int64 = &lt;span&gt;0&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; hashInt big.Int

    fmt.Println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Begin Minding...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    fmt.Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;target hash :    %x\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, pow.target.Bytes())

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; nonce &amp;lt;&lt;span&gt; math.MaxInt64 {
        data :&lt;/span&gt;=&lt;span&gt; pow.PrepareData(nonce)
        hash &lt;/span&gt;=&lt;span&gt; sha256.Sum256(data)

        hashInt.SetBytes(hash[:])
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Cmp compares x and y and returns:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   -1 if x &amp;lt;  y
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    0 if x == y
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   +1 if x &amp;gt;  y
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;func (x *Int) Cmp(y *Int) (r int) {&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; hashInt.Cmp(pow.target) == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt; {
            fmt.Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;found hash  :%x,nonce :%d\n,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, hash, nonce)
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;fmt.Printf(&quot;not found nonce,current nonce :%d,hash : %x\n&quot;, nonce, hash)&lt;/span&gt;
            nonce++&lt;span&gt;
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nonce, hash[:]
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;校验函数&lt;/span&gt;
func (pow *ProofOfWork) IsValid() &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; hashInt big.Int

    data :&lt;/span&gt;=&lt;span&gt; pow.PrepareData(pow.block.Nonce)
    hash :&lt;/span&gt;=&lt;span&gt; sha256.Sum256(data)
    hashInt.SetBytes(hash[:])

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; hashInt.Cmp(pow.target) == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;4.命令函交互CLI.go&lt;/h3&gt;
&lt;p&gt;注意这部分需要使用标准库里面的 &lt;a href=&quot;https://link.jianshu.com/?t=https://golang.org/pkg/flag/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;flag&lt;/a&gt; 包来解析命令行参数；&lt;/p&gt;
&lt;p&gt;首先，创建两个子命令: &lt;strong&gt;&lt;span&gt;&lt;code&gt;addblock&lt;/code&gt; &lt;/span&gt;&lt;/strong&gt;和 &lt;strong&gt;&lt;span&gt;&lt;code&gt;printchain&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;, 然后给 &lt;code&gt;addblock&lt;/code&gt; 添加&lt;strong&gt;&lt;span&gt; --&lt;code&gt;data&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt; 标志。&lt;code&gt;printchain&lt;/code&gt; 没有标志；&lt;/p&gt;
&lt;p&gt;然后，检查用户输入的命令并解析相关的 &lt;code&gt;flag&lt;/code&gt; 子命令；&lt;/p&gt;
&lt;p&gt;最后检查解析是哪一个子命令，并调用相关函数执行。&lt;/p&gt;
&lt;p&gt;具体如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为是多行的，所以用反引号`···`包一下，可以实现多行字符串的拼接，不需要转义！
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;命令行提示&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; usage =&lt;span&gt; `
Usage:
  addBlock &lt;/span&gt;-data BLOCK_DATA    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;add a block to the blockchain&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  printChain                   &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;print all the blocks of the blockchain&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
`
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; AddBlockCmdString = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;addBlock&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; PrintChainCmdString = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;printChain&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出提示函数&lt;/span&gt;
func (cli *&lt;span&gt;CLI) printUsage() {
    fmt.Println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Invalid input!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    fmt.Println(usage)
    os.Exit(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数检查函数&lt;/span&gt;
func (cli *&lt;span&gt;CLI) validateArgs() {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; len(os.Args) &amp;lt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt; {
        fmt.Println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;invalid input!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        cli.printUsage()
    }
}

func (cli &lt;/span&gt;*&lt;span&gt;CLI) Run() {
    cli.validateArgs()

    addBlockCmd :&lt;/span&gt;=&lt;span&gt; flag.NewFlagSet(AddBlockCmdString, flag.ExitOnError)
    printChainCmd :&lt;/span&gt;=&lt;span&gt; flag.NewFlagSet(PrintChainCmdString, flag.ExitOnError)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;func (f *FlagSet) String(name string, value string, usage string) *string&lt;/span&gt;
    addBlocCmdPara := addBlockCmd.String(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Block data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt; os.Args[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;] {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; AddBlockCmdString:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加动作&lt;/span&gt;
        err := addBlockCmd.Parse(os.Args[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;:])
        CheckErr(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Run()1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, err)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; addBlockCmd.Parsed() {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; *addBlocCmdPara == &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt; {
                fmt.Println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;addBlock data not should be empty!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                cli.printUsage()
            }
            cli.AddBlock(&lt;/span&gt;*&lt;span&gt;addBlocCmdPara)
        }
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; PrintChainCmdString:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印输出&lt;/span&gt;
        err := printChainCmd.Parse(os.Args[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;:])
        CheckErr(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Run()2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, err)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; printChainCmd.Parsed() {
            cli.PrintChain()
        }
    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;命令不符合规定，输出提示信息&lt;/span&gt;
&lt;span&gt;        cli.printUsage()
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;区块链操作演示效果：&lt;/h2&gt;
&lt;p&gt;首先 go build 编译程序；输入不带--data参数的错误命令，查看提示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/762938/201904/762938-20190423221917262-397182405.gif&quot; alt=&quot;&quot; width=&quot;656&quot; height=&quot;392&quot;/&gt;&lt;/p&gt;

&lt;p&gt;输入交易信息，查看pow运算：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/762938/201904/762938-20190423222410639-1884912665.gif&quot; alt=&quot;&quot; width=&quot;719&quot; height=&quot;275&quot;/&gt;&lt;/p&gt;

&lt;p&gt;打印区块链已有区块信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/762938/201904/762938-20190423222724295-1437655203.gif&quot; alt=&quot;&quot; width=&quot;707&quot; height=&quot;313&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 23 Apr 2019 14:31:00 +0000</pubDate>
<dc:creator>勋爵</dc:creator>
<og:description>摘要 本文构建了一个使用工作量证明机制（POW）的类BTC的区块链。将区块链持久化到一个Bolt数据库中，然后会提供一个简单的命令行接口，用来完成一些与区块链的交互操作。这篇文章目的是希望帮助大家理解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/X-knight/p/10759493.html</dc:identifier>
</item>
<item>
<title>[Active Learning] 01 A Brief Introduction to Active Learning - wuliytTaotao</title>
<link>http://www.cnblogs.com/wuliytTaotao/p/10758963.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuliytTaotao/p/10758963.html</guid>
<description>&lt;p&gt;本文将简单介绍什么是主动学习（Active Learning，AL），为什么需要主动学习，主动学习和监督学习、弱监督学习、半监督学习、无监督学习之间是什么关系。最后再简单介绍主动学习的分类。（这里介绍的主动学习是机器学习的一个子领域。）&lt;/p&gt;
&lt;h2 id=&quot;什么是主动学习&quot;&gt;什么是主动学习？&lt;/h2&gt;
&lt;p&gt;主动学习（Active Learning），有些时候也叫 “query learning”，是机器学习的一个子领域。&lt;/p&gt;
&lt;p&gt;主动学习背后一个关键的假设：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个机器学习算法如果能够自行选择从哪些数据进行学习，通过较少的训练数据，它将表现得更好。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;If the learning algorithm can choose the data from which it learns, it will perform better with less training.[1]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;主动学习之所以叫主动学习，是因为算法从数据集中主动地选择一些数据进行标注，而不是被动地选择。&lt;/p&gt;
&lt;h3 id=&quot;主动学习-vs.-被动学习&quot;&gt;主动学习 vs. 被动学习&lt;/h3&gt;
&lt;p&gt;被动学习（passive learning）被认为是从数据集中随机选择（randomly select）数据进行标注。&lt;/p&gt;
&lt;p&gt;而主动学习选择要标注的样本时，有一些 criteria 进行指导，这就是主动学习和被动学习的区别。&lt;/p&gt;
&lt;p&gt;不过被动学习似乎叫的不多，一般用 random selection 与主动学习的 criteria 比较就好。&lt;/p&gt;
&lt;h2 id=&quot;为什么需要主动学习&quot;&gt;为什么需要主动学习？&lt;/h2&gt;
&lt;p&gt;数据标注的成本高昂，迫使我们想要用更少的标注数据来获得更有效的模型，这就是主动学习产生的原因。&lt;/p&gt;
&lt;h2 id=&quot;主动学习与监督学习弱监督学习半监督学习无监督学习之间的关系&quot;&gt;主动学习与监督学习、弱监督学习、半监督学习、无监督学习之间的关系？&lt;/h2&gt;
&lt;p&gt;我们根据训练数据集标签的情况来划分这几者：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;监督学习（Supervised learning）任务中，数据集的标签都是完整而精确的。&lt;/li&gt;
&lt;li&gt;无监督学习（Unsupervised learning）任务中，数据集是不含标签的。&lt;/li&gt;
&lt;li&gt;弱监督学习（Weakly-supervised learning）任务中，数据集的标签分为三种情况：（这三种情况可能同时出现）
&lt;ul&gt;&lt;li&gt;部分数据有标签，部分数据没有标签。一般有标签的数据占少数，大部分数据没有标签。(Incompelet supervison）&lt;/li&gt;
&lt;li&gt;数据都有标签，但是标签的粒度不够。例如，在图像语义分割中，细粒度的标签应该是 pixel-level 的，但给出的标签仅仅是 image-level 的，这就是标签的粒度不够。(Inexact supervison)&lt;/li&gt;
&lt;li&gt;数据都有标签，但是标签有很多错误。(Inaccurate supervison)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;center readability=&quot;2&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1351564/201904/1351564-20190423222639794-1146127967.png&quot; width=&quot;900px&quot;/&gt;&lt;p&gt;Fig. 1 [2] Illustration of three typical types of weak supervision.&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;而主动学习对应弱监督学习的第一种情况，少部分数据含标签，但是大部分数据不含标签。&lt;/p&gt;
&lt;p&gt;主动学习和半监督学习是什么关系？两者都可以认为是弱监督学习第一种情况的处理方式，但两者也有不一样的地方，比如主动学习需要人工标注数据，而半监督学习不要。&lt;/p&gt;
&lt;h2 id=&quot;主动学习的种类&quot;&gt;主动学习的种类？&lt;/h2&gt;
&lt;center readability=&quot;2&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1351564/201904/1351564-20190423225229018-1392472490.png&quot; width=&quot;800px&quot;/&gt;&lt;p&gt;Fig. 2 [1] Categories of active learning.&lt;/p&gt;
&lt;/center&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;第一种是“Membership query synthesis”，字面意思上很难理解，不过这种方式的 instance 是算法从整个可能的样本空间中生成的，模型从头开始生成一个 instance 然后送去 oracle 打标签。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第二种是“steam-based active learning”，每一次我们能够得到一个 sample，然后判断其是否要送去 oracle 打标签。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;第三种是“&lt;strong&gt;pool-based active learning&lt;/strong&gt;”，初始时，我们就有很多 unlabeled data，只需要从这些 unlabeled data 中选择数据送到 oracle 打标签。（&lt;em&gt;这种情况是最常见的&lt;/em&gt;。）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;center readability=&quot;2&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1351564/201904/1351564-20190423230910594-755792939.png&quot; width=&quot;600px&quot;/&gt;&lt;p&gt;Fig. 3 [1] Pool-based active learning.&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;可能会有一个疑问，主动学习中的 oracle 是什么？oracle 可以是一个专家，打标签百分之百正确；也可以是很多拥有不同专业知识的人，打标签不是百分百对，如众包。&lt;/p&gt;
&lt;h2 id=&quot;主动学习的一个例子&quot;&gt;主动学习的一个例子&lt;/h2&gt;
&lt;center readability=&quot;2&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1351564/201904/1351564-20190423231239058-8382494.png&quot; width=&quot;800px&quot;/&gt;&lt;p&gt;Fig. 4 [1] An example of pool-based active learning.&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;Example from [1]：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;(a) A toy data set of 400 instances, evenly sampled from two class Gaussians.&lt;/li&gt;
&lt;li&gt;(b) A logistic regression model trained with 30 labeled instances randomly drawn from the problem domain.(accuracy:70%)&lt;/li&gt;
&lt;li&gt;(c) A logistic regression model trained with 30 actively queried instances using uncertainty sampling.(accuracy:90%)&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;p&gt;[1] ﻿Burr Settles.(2009). Active Learning Literature Survey. Computer Sciences Technical Report 1648, University of Wisconsin-Madison.&lt;br/&gt;[2] Zhou, Z.-H. (2018). A brief introduction to weakly supervised learning. National Science Review, 5(1), 44–53. &lt;a href=&quot;https://doi.org/10.1093/nsr/nwx106&quot; class=&quot;uri&quot;&gt;https://doi.org/10.1093/nsr/nwx106&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 23 Apr 2019 14:24:00 +0000</pubDate>
<dc:creator>wuliytTaotao</dc:creator>
<og:description>本文简单介绍什么是主动学习，为什么需要主动学习，主动学习和监督学习、弱监督学习、半监督学习、无监督学习之间是什么关系，主动学习又有哪些种类。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuliytTaotao/p/10758963.html</dc:identifier>
</item>
<item>
<title>c++智能指针和二叉树(1): 图解层序遍历和逐层打印二叉树 - apocelipes</title>
<link>http://www.cnblogs.com/apocelipes/p/10758692.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/apocelipes/p/10758692.html</guid>
<description>&lt;p&gt;二叉树是极为常见的数据结构，关于如何遍历其中元素的文章更是数不胜数。&lt;/p&gt;
&lt;p&gt;然而大多数文章都是讲解的前序/中序/后序遍历，有关逐层打印元素的文章并不多，已有文章的讲解也较为晦涩读起来不得要领。本文将用形象的图片加上清晰的代码帮助你理解层序遍历的实现，同时我们使用现代c++提供的智能指针来简化树形数据结构的资源管理。&lt;/p&gt;
&lt;p&gt;那么现在让我们进入正题。&lt;/p&gt;
&lt;h2 id=&quot;使用智能指针构建二叉树&quot;&gt;使用智能指针构建二叉树&lt;/h2&gt;
&lt;p&gt;我们这里所要实现的是一个简单地模拟了二叉搜索树的二叉树，提供符合二叉搜索树的要求的插入功能个中序遍历。同时我们使用shared_ptr来管理资源。&lt;/p&gt;
&lt;p&gt;现在我们只实现&lt;code&gt;insert&lt;/code&gt;和&lt;code&gt;ldr&lt;/code&gt;两个方法，其余方法的实现并不是本文所关心的内容，不过我们会在后续的文章中逐个介绍：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;struct BinaryTreeNode: public std::enable_shared_from_this&amp;lt;BinaryTreeNode&amp;gt; {
    explicit BinaryTreeNode(const int value = 0)
    : value_{value}, left{std::shared_ptr&amp;lt;BinaryTreeNode&amp;gt;{}}, right{std::shared_ptr&amp;lt;BinaryTreeNode&amp;gt;{}}
    {}

    void insert(const int value)
    {
        if (value &amp;lt; value_) {
            if (left) {
                left-&amp;gt;insert(value);
            } else {
                left = std::make_shared&amp;lt;BinaryTreeNode&amp;gt;(value);
            }
        }

        if (value &amp;gt; value_) {
            if (right) {
                right-&amp;gt;insert(value);
            } else {
                right = std::make_shared&amp;lt;BinaryTreeNode&amp;gt;(value);
            }
        }
    }

    // 中序遍历
    void ldr()
    {
        if (left) {
            left-&amp;gt;ldr();
        }

        std::cout &amp;lt;&amp;lt; value_ &amp;lt;&amp;lt; &quot;\n&quot;;

        if (right) {
            right-&amp;gt;ldr();
        }
    }

    // 分层打印
    void layer_print();

    int value_;
    // 左右子节点
    std::shared_ptr&amp;lt;BinaryTreeNode&amp;gt; left;
    std::shared_ptr&amp;lt;BinaryTreeNode&amp;gt; right;

private:
    // 层序遍历
    std::vector&amp;lt;std::shared_ptr&amp;lt;BinaryTreeNode&amp;gt;&amp;gt; layer_contents();
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们的node对象继承自&lt;code&gt;enable_shared_from_this&lt;/code&gt;，通常这不是必须的，但是为了在层序遍历时方便操作，我们需要从&lt;code&gt;this&lt;/code&gt;构造智能指针，因此这步是必须的。&lt;code&gt;insert&lt;/code&gt;会将比root小的元素插入左子树，比root大的插入到右子树；&lt;code&gt;ldr&lt;/code&gt;则是最为常规的中序遍历，这里实现它是为了以常规方式查看tree中的所有元素。&lt;/p&gt;
&lt;p&gt;值得注意的是，对于node节点我们最好使用&lt;code&gt;make_shared&lt;/code&gt;进行创建，而不是将其初始化为全局/局部对象，否则在层序遍历时会因为&lt;code&gt;shared_ptr&lt;/code&gt;的析构进而导致对象被销毁，从而引发未定义行为。&lt;/p&gt;
&lt;p&gt;现在假设我们有一组数据：[3, 1, 0, 2, 5, 4, 6, 7]，将第一个元素作为root，将所有数据插入我们的树中会得到如下的一棵二叉树：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;auto root = std::make_shared&amp;lt;BinaryTreeNode&amp;gt;(3);
root-&amp;gt;insert(1);
root-&amp;gt;insert(0);
root-&amp;gt;insert(2);
root-&amp;gt;insert(5);
root-&amp;gt;insert(4);
root-&amp;gt;insert(6);
root-&amp;gt;insert(7);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201904/1434464-20190423201508944-1300410269.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到节点一共分成了四层，现在我们需要逐层打印，该怎么做呢？&lt;/p&gt;
&lt;h2 id=&quot;层序遍历&quot;&gt;层序遍历&lt;/h2&gt;
&lt;p&gt;其实思路很简单，我们采用广度优先的思路，先将节点的孩子都打印，然后再去打印子节点的孩子。&lt;/p&gt;
&lt;p&gt;以上图为例，我们先打印根节点的值&lt;code&gt;3&lt;/code&gt;，然后我们再打印它的所有子节点的值，是&lt;code&gt;1&lt;/code&gt;和&lt;code&gt;5&lt;/code&gt;，然后是左右子节点的子节点，以此类推。。。。。。&lt;/p&gt;
&lt;p&gt;说起来很简单，但是代码写起来却会遇到麻烦。我们不能简单得像中序遍历时那样使用递归来解决问题（事实上可以用改进的递归算法），因为它会直接来到叶子节点处，这不是我们想要的结果。不过不要紧，我们可以借助于队列，把子节点队列添加到队列末尾，然后从队列开头也就是根节点处遍历，将其子节点添加进队列，随后再对第二个节点做同样的操作，遇到一行结束的地方，我们使用&lt;code&gt;nullptr&lt;/code&gt;做标记。&lt;/p&gt;
&lt;p&gt;先看具体的代码：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;std::vector&amp;lt;std::shared_ptr&amp;lt;BinaryTreeNode&amp;gt;&amp;gt;
BinaryTreeNode::layer_contents()
{
    std::vector&amp;lt;std::shared_ptr&amp;lt;BinaryTreeNode&amp;gt;&amp;gt; nodes;
    // 先添加根节点，根节点自己就会占用一行输出，所以添加了作为行分隔符的nullptr
    // 因为需要保存this，所以这是我们需要继承enable_shared_from_this是理由
    // 同样是因为这里，当返回的结果容器析构时this的智能指针也会析构
    // 如果我们使用了局部变量则this的引用计数从1减至0，导致对象被销毁，而使用了make_shared创建的对象引用计数是从2到1，没有问题
    nodes.push_back(shared_from_this());
    nodes.push_back(nullptr);
    // 我们使用index而不是迭代器，是因为添加元素时很可能发生迭代器失效，处理这一问题将会耗费大量精力，而index则无此烦恼
    for (int index = 0; index &amp;lt; nodes.size(); ++index) {
        if (!nodes[index]) {
            // 子节点打印完成或已经遍历到队列末尾
            if (index == nodes.size()-1) {
                break;
            }

            nodes.push_back(nullptr); // 添加分隔符
            continue;
        }

        if (nodes[index]-&amp;gt;left) { // 将当前节点的子节点都添加进队列
            nodes.push_back(nodes[index]-&amp;gt;left);
        }
        if (nodes[index]-&amp;gt;right) {
            nodes.push_back(nodes[index]-&amp;gt;right);
        }
    }

    return nodes;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码本身并不复杂，重要的是其背后的思想。&lt;/p&gt;
&lt;h2 id=&quot;算法图解&quot;&gt;算法图解&lt;/h2&gt;
&lt;p&gt;如果你第一遍并没有读懂这段代码也不要紧，下面我们有请图解上线：&lt;/p&gt;
&lt;p&gt;首先是循环开始时的状态，第一行的内容已经确定了(^代表空指针)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201904/1434464-20190423201452992-1527421922.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们从首元素开始遍历，第一个遍历到的是root，他有两个孩子，值分别是1和5：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201904/1434464-20190423201440648-1914754628.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着索引值+1，这次遍历到的是nullptr，因为不是在队列末尾，所以我们简单添加一个nullptr在队列末尾，这样第二行的节点就都在队列中了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201904/1434464-20190423201429147-470424451.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随后我们开始遍历第二行的节点，将它们的子节点作为第三行的内容放入队列，最后加上一个行分隔符，以此类推：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201904/1434464-20190423201415859-14995617.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简单来说，就是通过队列来缓存上一行的所有节点，然后再根据上一行的缓存得到下一行的所有节点，循环往复直到二叉树的最后一层。当然不只是二叉树，其他多叉树的层序遍历也可以用类似的思想实现。&lt;/p&gt;
&lt;p&gt;好了，知道了如何获取每一行的内容，我们就能逐行处理节点了：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void BinaryTreeNode::layer_print()
{
    auto nodes = layer_contents();
    for (auto iter = nodes.begin(); iter != nodes.end(); ++iter) {
        // 空指针代表一行结束，这里我们遇到空指针就输出换行符
        if (*iter) {
            std::cout &amp;lt;&amp;lt; (*iter)-&amp;gt;value_ &amp;lt;&amp;lt; &quot; &quot;;
        } else {
            std::cout &amp;lt;&amp;lt; &quot;\n&quot;;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如你所见，这个方法足够简单，我们把节点信息保存在额外的容器中是为了方便做进一步的处理，如果只是打印的话大可不必这么麻烦，不过简单通常是有代价的。对于我们的实现来说，分隔符的存在简化了我们对层级之间的区分，然而这样会导致浪费至少log2(n)+1个vector的存储空间，某些情况下可能引起性能问题，而且通过合理得使用计数变量可以避免这些额外的空间浪费。当然具体的实现读者可以自己挑战一下，原理和我们上面介绍的是类似的因此就不在赘述了，也可以参考园内其他的博客文章。&lt;/p&gt;
&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;最后让我们看看完整的测试程序，记住要用make_shared创建root实例：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int main()
{
    auto root = std::make_shared&amp;lt;BinaryTreeNode&amp;gt;(3);
    root-&amp;gt;insert(1);
    root-&amp;gt;insert(0);
    root-&amp;gt;insert(2);
    root-&amp;gt;insert(5);
    root-&amp;gt;insert(4);
    root-&amp;gt;insert(6);
    root-&amp;gt;insert(7);
    root-&amp;gt;ldr();
    std::cout &amp;lt;&amp;lt; &quot;\n&quot;;
    root-&amp;gt;layer_print();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201904/1434464-20190423201351864-258722781.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到上半部分是中序遍历的结果，下半部分是层序遍历的输出，而且是逐行打印的，不过我们没有做缩进。所以不太美观。&lt;/p&gt;
&lt;p&gt;另外你可能已经发现了，我们没有写任何有关资源释放的代码，没错，这就是智能指针的威力，只要注意资源的创建，剩下的事都可以放心得交给智能指针处理，我们可以把更多的精力集中在算法和功能的实现上。&lt;/p&gt;
&lt;p&gt;智能指针和层序遍历的内容到这里就结束了，在下一篇文章中我们还将看到智能指针和二叉树的更多操作。&lt;/p&gt;
&lt;p&gt;如有错误和疑问欢迎指出！&lt;/p&gt;
</description>
<pubDate>Tue, 23 Apr 2019 12:18:00 +0000</pubDate>
<dc:creator>apocelipes</dc:creator>
<og:description>二叉树是极为常见的数据结构，关于如何遍历其中元素的文章更是数不胜数。 然而大多数文章都是讲解的前序/中序/后序遍历，有关逐层打印元素的文章并不多，已有文章的讲解也较为晦涩读起来不得要领。本文将用形象的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/apocelipes/p/10758692.html</dc:identifier>
</item>
</channel>
</rss>