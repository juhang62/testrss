<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>《HelloGitHub》第 42 期 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/11604781.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/11604781.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;兴趣是最好的老师，&lt;strong&gt;HelloGitHub&lt;/strong&gt; 就是帮你找到兴趣！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201909/759200-20190928203659552-668177940.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;分享 GitHub 上有趣、入门级的开源项目。&lt;/p&gt;
&lt;p&gt;这是一个面向&lt;strong&gt;编程新手&lt;/strong&gt;、&lt;strong&gt;热爱编程&lt;/strong&gt;、&lt;strong&gt;对开源社区感兴趣&lt;/strong&gt; 人群的月刊，月刊的内容包括：&lt;strong&gt;各种编程语言的项目&lt;/strong&gt;、&lt;strong&gt;让生活变得更美好的工具&lt;/strong&gt;、&lt;strong&gt;书籍、学习笔记、教程等&lt;/strong&gt;，这些开源项目大多都是非常容易上手，而且非常 Cool。主要是希望大家能动手用起来，加入到&lt;strong&gt;开源社区&lt;/strong&gt;中。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;会编程的可以贡献代码&lt;/li&gt;
&lt;li&gt;不会编程的可以反馈使用这些工具中的 Bug&lt;/li&gt;
&lt;li&gt;帮着宣传你觉得优秀的项目&lt;/li&gt;
&lt;li&gt;Star 项目⭐️&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在浏览、参与这些项目的过程中，你将学习到&lt;strong&gt;更多编程知识&lt;/strong&gt;、&lt;strong&gt;提高编程技巧&lt;/strong&gt;、&lt;strong&gt;找到编程的乐趣&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;🎉 最后 &lt;a href=&quot;https://hellogithub.com&quot;&gt;HelloGitHub&lt;/a&gt; 这个项目就诞生了 🎉&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;3.5882352941176&quot;&gt;
&lt;p&gt;&lt;strong&gt;以下为本期内容&lt;/strong&gt;｜每个月 &lt;strong&gt;28&lt;/strong&gt; 号发布最新一期｜&lt;a href=&quot;https://github.com/521xueweihan/HelloGitHub#%E5%86%85%E5%AE%B9&quot;&gt;点击查看往期内容&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;c-项目&quot;&gt;C 项目&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/haifenghuang/linq4c&quot;&gt;linq4c&lt;/a&gt;：如果你想在 C 中使用隔壁 C# 的 linq 方法，那么不妨来使用这个项目！这是它的 C 语言版。实现了 linq 的大部分方法（60+）。现在它还在不断完善中，欢迎更多的小伙伴加入共同维护&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;bool WhereCallback(void *item) {
    char *str= (char *)item;
    return str[0] == 'h';
}

void *SelectCallback(void *item) {
    return newStr(&quot;%s_1&quot;, (char *)item);
}

char *str1 = &quot;huang&quot;, *str2 = &quot;hai&quot;, *str3 = &quot;feng&quot;;

ArrayList array = arrlist_new();
arrlist_append(array, str1);
arrlist_append(array, str2);
arrlist_append(array, str3);

Linq *lq = From(array);
ArrayList result = 
    lq
    -&amp;gt;Where(lq, WhereCallback)
    -&amp;gt;Select(lq, SelectCallback)
    -&amp;gt;ToArray(lq);

for(int i = 0; i &amp;lt; arrlist_size(result); i++) {
    printf(&quot;%s\n&quot;, arrlist_get(result, i));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201909/759200-20190928203717327-460295491.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;c-项目-1&quot;&gt;C++ 项目&lt;/h3&gt;
&lt;p&gt;2、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/vesoft-inc/nebula&quot;&gt;nebula&lt;/a&gt;：Nebula Graph 是一款开源图数据库，目标是为超大规模的图数据提供高并发、低延时的读、写及计算服务。目前是世界上唯一能够容纳千亿个顶点和万亿条边、并提供毫秒级查询延时的图数据库解决方案。特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;全对称分布式架构&lt;/li&gt;
&lt;li&gt;可扩展&lt;/li&gt;
&lt;li&gt;高可用&lt;/li&gt;
&lt;li&gt;数据强一致&lt;/li&gt;
&lt;li&gt;类 SQL 查询语言&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201909/759200-20190928203746128-1259887932.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;css-项目&quot;&gt;CSS 项目&lt;/h3&gt;
&lt;p&gt;3、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/chokcoco/iCSS&quot;&gt;iCSS&lt;/a&gt;：该项目围绕 CSS 话题，讲述了 CSS 相关的技巧、动画实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201909/759200-20190928203800931-1652728740.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;go-项目&quot;&gt;Go 项目&lt;/h3&gt;
&lt;p&gt;4、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/kubesphere/kubesphere&quot;&gt;kubesphere&lt;/a&gt;：一款在主流容器调度平台 Kubernetes 之上构建的企业级分布式多租户容器管理平台。提供简单易用的操作界面以及向导式操作方式，在降低用户使用容器调度平台学习成本的同时，极大降低开发、测试、运维的日常工作的复杂度。&lt;a href=&quot;https://kubesphere.io/docs/zh-CN/&quot;&gt;中文文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201909/759200-20190928203818895-574034152.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/caarlos0/starcharts&quot;&gt;starcharts&lt;/a&gt;：生成 GitHub 星图的项目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201909/759200-20190928203830871-1687282657.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/hoanhan101/ultimate-go&quot;&gt;ultimate-go&lt;/a&gt;：该项目是作者在学习 Go 过程中，对 Go 源码以及涉及到的相关的计算机基础知识的心得与总结。适合 Go 学习者阅读与学习。快来和作者一起深入了解 Go 源码，了解背后的计算机理论和 Go 的设计思想&lt;/p&gt;
&lt;h3 id=&quot;java-项目&quot;&gt;Java 项目&lt;/h3&gt;
&lt;p&gt;7、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/alibaba/easyexcel&quot;&gt;easyexcel&lt;/a&gt;：使用简单、上手快速、占用内存小且避免内存溢出的 Java 处理 Excel 工具。示例代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
* 最简单的读
* &amp;lt;p&amp;gt;1. 创建excel对应的实体对象 参照{@link DemoData}
* &amp;lt;p&amp;gt;2. 由于默认异步读取excel，所以需要创建excel一行一行的回调监听器，参照{@link DemoDataListener}
* &amp;lt;p&amp;gt;3. 直接读即可
*/
@Test
public void simpleRead() {
    String fileName = TestFileUtil.getPath() + &quot;demo&quot; + File.separator + &quot;demo.xlsx&quot;;
    // 这里 需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭
    EasyExcel.read(fileName, DemoData.class, new DemoDataListener()).sheet().doRead();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;8、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/ornicar/lila&quot;&gt;lila&lt;/a&gt;：一款基于 Scala 语言，完全免费、开源、没有广告、支持多语言的在线国际象棋游戏。&lt;a href=&quot;https://lichess.org/&quot;&gt;在线试玩&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201909/759200-20190928203844870-1689132929.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;9、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/jtablesaw/tablesaw&quot;&gt;tablesaw&lt;/a&gt;：一款包括数据框和可视化库，可用于加载、转换、过滤和汇总数据的 Java 实用程序。用 Tablesaw 处理数据会节省您的时间和精力，它还支持描述性统计，并且能够与 Smile 机器学习库完美集成。最近两年数据分析师职业大火，做好数据分析，就离不开数据可视化框架。Java 工程师掌握一种数据可视化库势在必行，示例代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class BoxExample {

  public static void main(String[] args) throws Exception {
    Table table = Table.read().csv(&quot;../data/tornadoes_1950-2014.csv&quot;);

    Layout layout = Layout.builder().title(&quot;Tornado Injuries by Scale&quot;).build();

    BoxTrace trace =
        BoxTrace.builder(table.categoricalColumn(&quot;scale&quot;), table.nCol(&quot;injuries&quot;)).build();
    Plot.show(new Figure(layout, trace));
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201909/759200-20190928203911498-1302022690.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;10、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/bbottema/simple-java-mail&quot;&gt;simple-java-mail&lt;/a&gt;：一个轻量级 Java 邮件框架，支持复杂、自定义的发送电子邮件业务。包括经过身份验证的代理、附件、嵌入式图像、自定义标头和属性、强大的地址验证等，亮点是支持身份代理等功能，防止其他其他邮件服务拦截邮件&lt;/p&gt;
&lt;p&gt;11、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/xuexiangjys/XUpdate&quot;&gt;XUpdate&lt;/a&gt;：一套基于 Android 的全量版本更新整体解决方案。它除了提供 Android SDK 外，还附带了 Spring Boot 搭建的后台服务以及 Vue.js 编写的后台管理界面。主要解决中小企业 Android 版本管理混乱的问题，提供可定制化的解决方案。该框架提供了完全可插拔的版本更新，同时为了让使用者使用方便，还提供了后台服务和管理界面，使用的都是现下最流行的技术。完全做到灵活、方便，并提供了大量丰富的文档供大家参阅&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;XUpdate.newBuild(getActivity())
.updateUrl(mUpdateUrl)
.isAutoMode(true) // 如果需要完全无人干预、自动更新，需要 root 权限【静默安装需要】
.update();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201909/759200-20190928203927436-2137539026.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;javascript-项目&quot;&gt;JavaScript 项目&lt;/h3&gt;
&lt;p&gt;12、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/gd4Ark/star-battle&quot;&gt;star-battle&lt;/a&gt;：一个使用 JavaScript ES6、Canvas 开发的飞船射击类游戏。&lt;a href=&quot;https://4ark.me/star-battle/&quot;&gt;在线试玩&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201909/759200-20190928203942400-1556157412.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;13、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/zhning12/markdown-nice&quot;&gt;markdown-nice&lt;/a&gt;：能够自定义样式的 Markdown 编辑器。支持内容和自定义样式浏览器中实时保存、上传图片、脚注、公式等，输出的内容可一件复制到微信公众号、知乎、掘金、博客园和 CSDN 等一系列平台。极大的减轻了微信公众号文章的排版和编辑工作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201909/759200-20190928203959796-729114887.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;14、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/marktext/marktext&quot;&gt;marktext&lt;/a&gt;：一个简单且优雅的开源 Markdown 编辑器，支持 Linux、macOS 和 Windows &lt;a href=&quot;https://github.com/marktext/marktext#download-and-install&quot;&gt;下载地址&lt;/a&gt;。功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;实时预览（所见即所得）和简洁明了的界面&lt;/li&gt;
&lt;li&gt;Markdown 扩展，例如数学表达式和 emoji 表情&lt;/li&gt;
&lt;li&gt;输出 HTML 和 PDF 文件&lt;/li&gt;
&lt;li&gt;各种编辑模式：源代码模式、打字机模式、专注模式&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201909/759200-20190928204010331-852051309.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;15、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/cmiscm/leonsans&quot;&gt;leonsans&lt;/a&gt;：这是一个用 JS 编写的 Sans Serif 半衬线字体。Leon Sans 允许动态更改字体粗细并在 HTML 5 的 Canvas 元素中创建自定义动画、效果或形状，&lt;a href=&quot;https://leon-kim.com/&quot;&gt;点击&lt;/a&gt;查看动画效果。PS：这个字体是作者来庆祝他刚出生的婴儿 Leon 的哦&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201909/759200-20190928204020103-2080914333.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;16、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/lsqy/taro-music&quot;&gt;taro-music&lt;/a&gt;：基于 Taro 与网易云音乐 API 开发的网易云音乐小程序。技术栈为 typescript+taro+taro-ui+redux 目前主要是着重小程序端的展示，可以通过项目学习上述几个技术栈的使用和实战，从而能够快速使用 Taro 开发一个属于你自己的小程序，目前已实现的主要功能点如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户登陆&lt;/li&gt;
&lt;li&gt;我的关注列表&lt;/li&gt;
&lt;li&gt;最近播放列表&lt;/li&gt;
&lt;li&gt;歌曲播放页面&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201909/759200-20190928204030724-45899948.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;objective-c-项目&quot;&gt;Objective-C 项目&lt;/h3&gt;
&lt;p&gt;17、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/SunshineBrother/JHBlog&quot;&gt;JHBlog&lt;/a&gt;：该项目整理了作者从初级 iOS 开发到中级的晋级之路的相关知识集合&lt;/p&gt;
&lt;h3 id=&quot;python-项目&quot;&gt;Python 项目&lt;/h3&gt;
&lt;p&gt;18、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/healthchecks/healthchecks&quot;&gt;healthchecks&lt;/a&gt;：基于 Python3 和 Django2 的 Cron 定时任务监控工具，同时支持多种定时任务失败时的告警方式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201909/759200-20190928204058365-964242337.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;19、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/kingname/GeneralNewsExtractor&quot;&gt;GeneralNewsExtractor&lt;/a&gt;：基于《基于文本及符号密度的网页正文提取方法》论文用 Python 实现的正文抽取器，可以用来提取 HTML 中正文的内容、作者、标题。之前我看到这篇论文也想实现该抽取工具，但是我因为懒癌晚期躺下了，感谢&lt;a href=&quot;https://github.com/kingname&quot;&gt;kingname&lt;/a&gt; ‘带趟’ ✌️&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201909/759200-20190928204113204-970505448.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;20、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/bokeh/bokeh&quot;&gt;bokeh&lt;/a&gt;：一个交互式的数据可视化 Python 库，专注于在 Web 浏览器中实现美观、直接的数据可视化功能。使用它可以让你快速和轻松地创建交互式图表、仪表板和数据可视化程序。流式数据集的可视化效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201909/759200-20190928204125755-450485688.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;ruby-项目&quot;&gt;Ruby 项目&lt;/h3&gt;
&lt;p&gt;21、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/janx/ruby-pinyin&quot;&gt;ruby-pinyin&lt;/a&gt;：可以把汉字转化为对应的拼音的库，同时能够较好的处理多音字的情况。正确处理多音字，示例代码如下：&lt;/p&gt;
&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;PinYin.of_string('南京市长江大桥', :unicode)
return [&quot;nán&quot;, &quot;jīng&quot;, &quot;shì&quot;, &quot;cháng&quot;, &quot;jiāng&quot;, &quot;dà&quot;, &quot;qiáo&quot;]

能够正确的将“长”转为“chang2”，而不是“zhang3”&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;swift-项目&quot;&gt;Swift 项目&lt;/h3&gt;
&lt;p&gt;22、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/EFPrefix/EFQRCode&quot;&gt;EFQRCode&lt;/a&gt;：一个轻量级的、用来生成和识别二维码的纯 Swift 库，可根据输入的水印图和图标产生艺术二维码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201909/759200-20190928204154481-1196354684.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;其它&quot;&gt;其它&lt;/h3&gt;
&lt;p&gt;23、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/viraptor/reverse-interview&quot;&gt;reverse-interview&lt;/a&gt;：如果当面试官问“你还有什么要问我的吗？”的时候你毫无头绪，那这个项目正是你所需要的。&lt;a href=&quot;https://github.com/yifeikong/reverse-interview-zh&quot;&gt;中文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;24、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/wei/pull&quot;&gt;pull&lt;/a&gt;：一个 GitHub App，它可以让 fork 的仓库自动同步，保持和原仓库同步的神器。很多同学参与开源时会 fork 项目，但无法取得原项目的最新更新。此 Github App 可以很好的解决这个问题，截至目前已有几万仓库使用，截至目前已经自动生成了 70 万个 PR，该数字还在持续增加。注意：如果 master 有更改需要备份后使用，具体见&lt;a href=&quot;https://github.com/wei/pull#readme&quot;&gt;英文文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201909/759200-20190928204206371-1747368534.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;25、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/zerosoul/chinese-colors&quot;&gt;chinese-colors&lt;/a&gt;：中国传统颜色在线手册，&lt;a href=&quot;https://colors.ichuantong.cn/&quot;&gt;在线体验&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201909/759200-20190928204226867-782462710.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;26、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/denisidoro/navi&quot;&gt;navi&lt;/a&gt;：命令行辅助工具，有了它再也不用担心找不到历史输入过的命令、忘记命令等诸多烦恼&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201909/759200-20190928204235563-527062183.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;教程&quot;&gt;教程&lt;/h3&gt;
&lt;p&gt;27、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/doocs/advanced-java&quot;&gt;advanced-java&lt;/a&gt;：一份 Java 工程师进阶知识点集合，内容涵盖：高并发、分布式、高可用、微服务等领域知识。这些知识点不局限于 Java 语言，后端的同学也可以从中收获很多，&lt;a href=&quot;https://doocs.github.io/advanced-java&quot;&gt;在线阅读&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;28、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/goldbergyoni/nodebestpractices&quot;&gt;nodebestpractices&lt;/a&gt;：《Node.js 最佳实践》&lt;a href=&quot;https://github.com/goldbergyoni/nodebestpractices/blob/master/README.chinese.md&quot;&gt;中文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201909/759200-20190928204253229-1658118673.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;29、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/Q-Angelo/Nodejs-Roadmap&quot;&gt;Nodejs-Roadmap&lt;/a&gt;：Node.js 技术栈学习指南。内容侧重于 Node.js 服务端，包含：Node.js 基础知识、Node.js 核心模块、主流框架实践、缓存、数据库、消息中间件、DevOps、HTTP 协议以及 Node.js 在微服务等，&lt;a href=&quot;https://www.nodejs.red/&quot;&gt;在线阅读&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;30、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/microsoft/c9-python-getting-started&quot;&gt;c9-python-getting-started&lt;/a&gt;：微软出品的零基础 Python 入门教程，内容浅显易懂。包含示例代码、演示的 PPT、&lt;a href=&quot;https://www.youtube.com/playlist?list=PLlrxD0HtieHhS8VzuMCfQD4uJ9yne1mE6&quot;&gt;配套的 Youtube 视频&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;机器学习&quot;&gt;机器学习&lt;/h3&gt;
&lt;p&gt;31、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/InsaneLife/ChineseNLPCorpus&quot;&gt;ChineseNLPCorpus&lt;/a&gt;：中文自然语言处理数据集&lt;/p&gt;
&lt;p&gt;32、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/brightmart/albert_zh&quot;&gt;albert_zh&lt;/a&gt;：海量中文预训练 ALBERT 模型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201909/759200-20190928204320447-634120547.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;33、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/Windsooon/cherry&quot;&gt;cherry&lt;/a&gt;：简单易用的文本分类器。适用多种语言，自带两个预训练模型，使用预训练模型进行分类只需一行代码。使用自己的数据集进行定制训练也只需要十行代码。轻松达到高精确率，召回率。同时该库支持自定义分词算法、分类算法等。示例代码：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; res = cherry.classify(model='harmful', text=['她们对计算机很有热情，也希望学习到数据分析，网络爬虫，人工智能等方面的知识，从而运用在她们工作上'])
&amp;gt;&amp;gt;&amp;gt; res.word_list
[(2, '她们'), (1, '网络'), (1, '热情'), (1, '方面'), (1, '数据分析'), (1, '希望'), (1, '工作'), (1, '学习'), (1, '从而')]
&amp;gt;&amp;gt;&amp;gt; res.probability
# 返回结果分别对应 赌博，正常，政治，色情 4个 类别的概率
array([[4.43336608e-03, 9.95215198e-01, 3.51419231e-04, 1.68657851e-08]])&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;“看完了，还不够？&lt;a href=&quot;https://github.com/521xueweihan/HelloGitHub#%E5%86%85%E5%AE%B9&quot;&gt;&amp;lt;往期内容&amp;gt;&lt;/a&gt; | 还不过瘾，那就看看每天更新的前端日报吧 &lt;a href=&quot;https://daily.fairyever.com/&quot;&gt;&amp;lt;今日前端&amp;gt;&lt;/a&gt;”&lt;/p&gt;&lt;p&gt;如果你发现了好玩、有意义的开源项目 &lt;a href=&quot;https://github.com/521xueweihan/HelloGitHub/issues/new&quot;&gt;点击这里&lt;/a&gt; 分享你觉得有趣的项目。&lt;/p&gt;
&lt;h2 id=&quot;声明&quot;&gt;声明&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;欢迎转载，请注明出处和作者，同时保留声明。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 29 Sep 2019 00:31:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>兴趣是最好的老师， HelloGitHub 就是帮你找到兴趣！ 简介 分享 GitHub 上有趣、入门级的开源项目。 这是一个面向 编程新手 、 热爱编程 、 对开源社区感兴趣 人群的月刊，月刊的内容</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/11604781.html</dc:identifier>
</item>
<item>
<title>JVM调优（一）——参数查询和问题排查 - 徐杰</title>
<link>http://www.cnblogs.com/xujie09/p/jvm.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xujie09/p/jvm.html</guid>
<description>&lt;h2 id=&quot;jvm的参数类型&quot;&gt;JVM的参数类型&lt;/h2&gt;
&lt;h3 id=&quot;标准参数&quot;&gt;标准参数&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;-help&lt;/li&gt;
&lt;li&gt;-server -client&lt;/li&gt;
&lt;li&gt;-version -showversion&lt;/li&gt;
&lt;li&gt;-cp -classpath&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;x参数&quot;&gt;X参数&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;-Xint: 解释执行&lt;/li&gt;
&lt;li&gt;-Xcomp:第一次使用就编译成本地代码&lt;/li&gt;
&lt;li&gt;-Xmixed:混合模式，JVM自己来决定是否编译成本地代码&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;xx参数&quot;&gt;XX参数&lt;/h3&gt;
&lt;h4 id=&quot;特点&quot;&gt;特点&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;非标准化参数&lt;/li&gt;
&lt;li&gt;相对不稳定&lt;/li&gt;
&lt;li&gt;主要用于JVM调优和Debug&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;分类&quot;&gt;分类&lt;/h4&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Boolean类型&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;格式：-XX:[+-]&amp;lt;name&amp;gt;表示启用或禁用name属性
比如：
-XX:+UseConcMarkSweepGC
-XX:+UseG1GC&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;非Boolean类型&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;格式：-XX:&amp;lt;name&amp;gt;=&amp;lt;value&amp;gt; 表示name属性的值是value
比如：
-XX:MaxGCPauseMilis=500
XX:GCTimeRatio=19&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;示例&quot;&gt;示例&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;-Xms等价于-XX:InitialHeapSize //初始化的堆大小&lt;/li&gt;
&lt;li&gt;-Xms等价于-XX:MaxHeapSize //最大堆大小&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;运行时jvm参数查看&quot;&gt;运行时JVM参数查看&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;-XX:+PrintFlagsInitial   //查看初始值
-XX:+PrintFlagsFinal   //查看最终的值
-XX:+UnlockExperimentalVMOptions   //解锁实验参数
-XX:+UnlockDiagnosticVMOptions  //解锁诊断参数
-XX:+PrintCommandLineFlags  //打印命令行参数&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;printflagsfinal&quot;&gt;PrintFlagsFinal&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;c:/Users/xujie/AppData/Roaming/Typora/typora-user-images/1569671403867.png&quot; alt=&quot;1569671403867&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;c:/Users/xujie/AppData/Roaming/Typora/typora-user-images/1569671560784.png&quot; alt=&quot;1569671560784&quot;/&gt;&lt;/p&gt;
&lt;p&gt;=表示默认值&lt;/p&gt;
&lt;p&gt;:=被用户户或者JVM修改后的值&lt;/p&gt;
&lt;h4 id=&quot;jps&quot;&gt;jps&lt;/h4&gt;
&lt;p&gt;查看java进程，类似Linux 中的ps&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;c:/Users/xujie/AppData/Roaming/Typora/typora-user-images/1569671892159.png&quot; alt=&quot;1569671892159&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;jinfo&quot;&gt;jinfo&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;jinfo -flag MaxHeapSize xxxx(进程号)   //查看最大堆内存&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;c:/Users/xujie/AppData/Roaming/Typora/typora-user-images/1569671942784.png&quot; alt=&quot;1569671942784&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;jinfo -flag UseConcMarkSweepGC xxx(进程号)     //查看是否使用了这个GC
jinfo -flag UseG1GC xxx(进程号)    //是否使用了G1回收器
jinfo -flag UseParallelGC xxx(进程号)  //是否使用了并行回收器 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;c:/Users/xujie/AppData/Roaming/Typora/typora-user-images/1569672105632.png&quot; alt=&quot;1569672105632&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;jstat查看虚拟机统计信息&quot;&gt;jstat查看虚拟机统计信息&lt;/h2&gt;
&lt;p&gt;命令格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;options:-class,-compiler,-gc,-printcompilation&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;类装载&quot;&gt;类装载&lt;/h3&gt;
&lt;p&gt;查看类加载信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;jstat -class xxx(进程号)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;c:/Users/xujie/AppData/Roaming/Typora/typora-user-images/1569673720935.png&quot; alt=&quot;1569673720935&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;说明：
3176(进程号)
1000（1000毫秒，没隔1秒）
10（一共输出10次）
3176这个进程，没隔1s输出一次，一共输出10次&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;垃圾收集&quot;&gt;垃圾收集&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;-gc/-gcutil/-gccause/-gcnew/-gccold&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;gc输出结果&quot;&gt;-gc输出结果&lt;/h4&gt;
&lt;p&gt;S0C/S1C/S0U/S1U:S0和S1的总量与使用量&lt;/p&gt;
&lt;p&gt;EC/EU:Eden区总量和使用量&lt;/p&gt;
&lt;p&gt;OC/OU:Old区总量与使用量&lt;/p&gt;
&lt;p&gt;MC/MU:Metaspace区总量与使用量&lt;/p&gt;
&lt;p&gt;CCSC/CCSU:压缩类空间总量与使用量&lt;/p&gt;
&lt;p&gt;YGC/YGCT:youngGC的次数与时间&lt;/p&gt;
&lt;p&gt;FGC/FGCT:FullGC的次数与时间&lt;/p&gt;
&lt;p&gt;GCT:总的GC时间&lt;/p&gt;
&lt;h4 id=&quot;使用&quot;&gt;使用&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;jstat -gc xxx(进程号) 1000 10   //动态输出，没隔1s输出一次，一共输出10次&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;jit编译&quot;&gt;JIT编译&lt;/h3&gt;
&lt;h4 id=&quot;查看jit编译信息&quot;&gt;查看JIT编译信息&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;jstat -compiler PID
jstat -printcompilation PID&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;jmapmat实战内存溢出&quot;&gt;jmap+MAT实战内存溢出&lt;/h2&gt;
&lt;h3 id=&quot;jvm内存结构&quot;&gt;jvm内存结构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;c:/Users/xujie/AppData/Roaming/Typora/typora-user-images/1569675319637.png&quot; alt=&quot;1569675319637&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;如何导出内存映像文件&quot;&gt;如何导出内存映像文件&lt;/h3&gt;
&lt;h4 id=&quot;内存溢出自动导出&quot;&gt;内存溢出自动导出&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;设置两个参数：
-XX:+HeapDumpOnOutOfMemoryError     //开启功能
-XX:HeapDumpPath=./     //导出到什么路径&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;使用jmap命令手动导出&quot;&gt;使用jmap命令手动导出&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;jmap -dump:format=b,file=help.hprof
format=b 导出的格式是二进制的文件&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;mat分析内存溢出&quot;&gt;MAT分析内存溢出&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;下载MAT工具&lt;/li&gt;
&lt;li&gt;将导出的映像文件导入到MAT中，进行分析&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;jstack实战死循环与死锁&quot;&gt;jstack实战死循环与死锁&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;线程的状态：&lt;/p&gt;
&lt;p&gt;1、new&lt;/p&gt;
&lt;p&gt;2、running&lt;/p&gt;
&lt;p&gt;3、blocked&lt;/p&gt;
&lt;p&gt;4、waiting&lt;/p&gt;
&lt;p&gt;5、timed_waiting&lt;/p&gt;
&lt;p&gt;6、terminated&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;实战死循环导致cpu飙高&quot;&gt;实战死循环导致cpu飙高&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;查看cpu负载：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;top //查看laod average,发现cpu非常高；&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在top列表里找到cpu占用高的进程&lt;/li&gt;
&lt;li&gt;通过jstack PID &amp;gt; xxx.txt ,通过jstack将该进程的信息打印到xxx.txt的文件中&lt;/li&gt;
&lt;li&gt;对进程内部的线程所占用资源情况进行分析：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;top -p PID -H   #查看某个进程内部线程占用情况&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现有5个线程占用的cpu非常高：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;c:/Users/xujie/AppData/Roaming/Typora/typora-user-images/1569714766323.png&quot; alt=&quot;1569714766323&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将上图分析出来的PID(十进制)转换成十进制：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;printf &quot;%x&quot; 8247
2037&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;在之前步骤里导出的jstack信息的文件中，搜索上个步骤转换出来的十六进制PID&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;0x2037 表示一个十六进制的数：2037&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;搜索出来之后，就能够看到该线程的堆栈信息了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;c:/Users/xujie/AppData/Roaming/Typora/typora-user-images/1569715297769.png&quot; alt=&quot;1569715297769&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;实战死锁导致cpu飙高&quot;&gt;实战死锁导致cpu飙高&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;查看项目进程号&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ps -ef | grep tomcat&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;通过jstack PID &amp;gt; xxx.txt ,通过jstack将该进程的信息打印到xxx.txt的文件中&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拉取到文末&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;c:/Users/xujie/AppData/Roaming/Typora/typora-user-images/1569716077324.png&quot; alt=&quot;1569716077324&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该分析工具能准确的找到项目中存在的的死锁和位置&lt;/p&gt;
</description>
<pubDate>Sun, 29 Sep 2019 00:18:00 +0000</pubDate>
<dc:creator>徐杰</dc:creator>
<og:description>JVM的参数类型 标准参数 help server client version showversion cp classpath X参数 Xint: 解释执行 Xcomp:第一次使用就编译成本地代码</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xujie09/p/jvm.html</dc:identifier>
</item>
<item>
<title>品Spring：注解之王@Configuration和它的一众“小弟们” - 编程新说(李新杰)</title>
<link>http://www.cnblogs.com/lixinjie/p/taste-spring-010.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lixinjie/p/taste-spring-010.html</guid>
<description>&lt;p&gt;&lt;span&gt;其实对Spring的了解达到一定程度后，你就会发现，无论是使用Spring框架开发的应用，还是Spring框架本身的开发都是围绕着&lt;/span&gt;&lt;span&gt;注解&lt;/span&gt;&lt;span&gt;构建起来的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;空口无凭，那就说个最普通的例子吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Spring中要启用一项XXX功能，标准做法就是用@EnableXXX这种“启用”类型的注解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么这种类型的注解一般都做了什么呢？分析一下吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看过本号文章的人都知道，Spring的核心就是bean定义和bean，如果我想增加某方面的功能，只需写若干个类，并作为bean定义注册到容器中即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此“启用”类型的注解表面上看起来是启用某项功能，&lt;/span&gt;&lt;span&gt;背后其实就是注册了一系列相关的bean定义到容器中&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大家都非常熟悉的，启用事务管理功能的注解，@EnableTransactionManagement，如下图01：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925220955805-1663625596.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;还有启用定时任务的注解，@EnableScheduling，如下图02：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925221002027-191627596.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;还有启动异步支持的注解，@EnableAsync，如下图03：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925221007528-1585705529.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;这类注解其实很多，就先看这三个吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相信大家已经发现了一个规律，这三个注解在定义时都使用&lt;/span&gt;&lt;span&gt;@Import&lt;/span&gt;&lt;span&gt;注解引入了某个类，最终目的当然是为了注册bean定义。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;之前的文章中已经说过多遍，这种方法叫做通过&lt;/span&gt;&lt;span&gt;编程&lt;/span&gt;&lt;span&gt;的方式（或称写代码的方式）注册bean定义。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种方式非常的灵活，因为@Import注解引入的类其实是两个&lt;/span&gt;&lt;span&gt;著名&lt;/span&gt;&lt;span&gt;接口的实现类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这两个接口，之前也提到过很多次了，就是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ImportSelector&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ImportBeanDefinitionRegistrar&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在实现接口时，可以按照自己关注的因素，来自主可控的（或称有选择性的）注册bean定义，这就是灵活性的原因。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;@Import除了可以引入这两个接口外，还可以引入被@Configuration注解标注的类或没有被注解标注的普通类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再次赘述一下这种方式的典型用法：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用于Spring框架自身的开发，以及第三方框架与Spring的整合开发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;熟悉Spring的朋友都应该知道，@EnableXXX注解和@Import注解都必须（直接或间接）和@Configuration注解放到一起才会起作用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是Spring规定的，主要是和Spring的源码实现有关。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以整体就是，@Configuration类引入了@EnableXXX注解或@Import注解，@EnableXXX注解又引入了@Import注解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而@Import注解又引入了那两个接口的实现类以编程方式注册bean定义，这里注册的bean定义同样还可以是@Configuration类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;@Import注解还可以再次引入@Configuration类。因此，&lt;/span&gt;&lt;span&gt;我们成功的从@Configuration类出发后又回到了@Configuration类&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后可以继续重复这个动作，一直进行下去。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这就像原子弹爆炸的&lt;/span&gt;&lt;span&gt;链式反应&lt;/span&gt;&lt;span&gt;一样，从最初的一个引爆点，然后开启逐个自我引爆的模式，越来越大，一发不可收拾。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以Spring就是采用这种模式，&lt;/span&gt;&lt;span&gt;最初的引爆点必须是一个@Configuration类&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;自我的引爆模式是@Import注解&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从最初的那一个基点，向容器中引入新的类，再以引入的新类作为基点，再次引入新的类，这种爆炸模型，非常强大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了@Import可以引入新类外，@ComponentScan注解也以扫描jar包的方式引入新的类。只不过扫描的方式&lt;/span&gt;&lt;span&gt;通常用于用户程序而非框架开发&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可见Spring程序就是围绕着注解构建起来的，&lt;/span&gt;&lt;span&gt;从最初的一个@Configuration类&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;配合使用@Import和@ComponentScan&lt;/span&gt;&lt;span&gt;，逐渐壮大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以最初的这一个@Configuration类&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;是在应用启动前&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;显式的（或称特意的）注册到容器中的&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SpringBoot就是非常标准的这个样子的&lt;/span&gt;&lt;span&gt;。它的主类就是一个@Configuration类，然后再使用@Import和@ComponentScan注解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看看下面的注解源码，确实是这样子的，如下图0405：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925221015866-1310974051.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925221020830-1131021701.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;终于可以下&lt;/span&gt;&lt;span&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;了：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;@Configuration就是注解之王，是老大，其余的注解围绕在它周围，是小弟们。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;按照江湖规矩，老大得罩着小弟们，所以负责处理@Configuration注解的类也要负责处理其它的注解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;编程新说注&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：究竟有哪些注解可以和@Configuration一起使用，在上一篇文章中已写明。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前看来，主要是&lt;strong&gt;这样&lt;/strong&gt;的：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在容器启动前使用编程的方式可以注册bean定义，如SpringBoot的主类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在容器启动后，@Import和@ComponentScan都可以注册bean定义，@Bean方法也可以。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然它们功能相似，但侧重点其实是不同的，当然可以放到一起使用，但必须做到心中有数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果使用不当的话，可能会发生“重叠”，如一个类即被引入了，也被扫描了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而且还可能被引入多次，扫描多次，当然，即使这样也不一定报错，因为Spring做了处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Spring采用了类似&lt;/span&gt;&lt;span&gt;&lt;strong&gt;先入为主&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;的做法：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先是容器启动前通过编程方式注册的类。这些类在后面无论是被扫描还是被引入，都不会再被注册。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其次是如果先通过扫描方式注册的类，引入时不再注册。如果先通过引入方式注册的类，扫描时不再注册。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后是如果先通过扫描方式注册的类，再次扫描时不再注册。如果先通过引入方式注册的类，再次引入时不再注册。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这就像幂等处理一样，给上层用户留有较宽的余地，在最终使用时没有那么严格。多了一些随意。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;编程新说注&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：在显式注册bean定义时，如果beanName已存在，会抛出异常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果这些注解在一起出现的话，注册bean定义也是有&lt;/span&gt;&lt;span&gt;先后顺序&lt;/span&gt;&lt;span&gt;的：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第一，容器启动前，注册的@Configuration类的bean定义。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;编程新说注&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：下面的这些内容都是依附于@Configuration类的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二，@ComponentScan注解扫描的bean定义。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第三，使用ImportSelector接口引入的bean定义（非ImportBeanDefinitionRegistrar接口的实现类）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第四，使用@Import引入的普通类的bean定义。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第五，类的@Bean方法引入的bean定义。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第六，使用@ImportResource注解引入的XML文件里的bean定义。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第七，使用ImportBeanDefinitionRegistrar接口引入的bean定义。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第八，@Configuration类实现的接口里的@Bean方法（默认方法）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第九，@Configuration类的父类&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接着就是把父类当作新的@Configuration类，再次重复第二到第九。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;整个bean定义的注册过程，就是以容器为依托，一遍一遍的执行，直到容器中的bean定义再无增多为止。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面就描述其中的一遍：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第一，从容器中拿出尚未处理过的所有@Configuration类&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二，从这一批@Configuration类中解析出所有需要被注册的类&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第三，将这一批@Configuration类标记为已处理过&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第四，将刚刚解析出来的类进行bean定义注册，这些类里面可能还含有@Configuration类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来进行循环执行即可。直到某一次执行完后，容器中的bean定义数量没有变化，表明已全部处理完毕。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再说一个&lt;/span&gt;&lt;span&gt;外部类&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;内部类&lt;/span&gt;&lt;span&gt;的事情，颇有意思：&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code readability=&quot;2&quot;&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Outter&lt;/span&gt; &lt;/span&gt;{&lt;p&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Inner&lt;/span&gt; &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;先来看两个&lt;/span&gt;&lt;span&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当外部类上有注解时，分别使用@ComponentScan和@Import作用于外部类，此时注册的bean定义是谁？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当把外部类上的注解去掉时，分别使用@ComponentScan和@Import作用于外部类，此时注册的bean定义是谁？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;来看看&lt;/span&gt;&lt;span&gt;&lt;strong&gt;答案&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;吧：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当外部类有注解时，@ComponentScan和@Import都会把Outter和Inner注册bean定义。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当外部类没有注解时，@ComponentScan会注册Inner类，@Import会注册Outter类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面来&lt;/span&gt;&lt;span&gt;&lt;strong&gt;解释&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;JVM规范规定，每个字节码文件只能包含一个类，因此嵌套类会单独编译成一个字节码文件。与它的外部类是互相独立的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而@ComponentScan注解是按字节码文件扫描的，所以此时内部类都会被注册，即使外部类上没有注解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当@Import引入一个类时，不管该类上是否有注解，该类本身一定会被注册bean定义。所以外部类总是被注册。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是，只有外部类上有注解时，才会去处理它的内部类。且内部类上必须也要有注解才行。因为源码就是这样写的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后看看&lt;/span&gt;&lt;span&gt;SpringBoot&lt;/span&gt;&lt;span&gt;应用注册的&lt;/span&gt;&lt;span&gt;前几个&lt;/span&gt;&lt;span&gt;bean定义，如下图06：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925221036156-2119978737.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;可见第一个注册的bean定义，就是用来处理标有@Configuration注解的类的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第六个注册的是&lt;/span&gt;&lt;strong&gt;&lt;span&gt;主类&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;的bean定义。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; 热门文章集锦 &amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484219&amp;amp;idx=1&amp;amp;sn=e6c39138e44ce8f0c91aba4873fb42cd&amp;amp;chksm=fc3338cbcb44b1dde7ae372ed66b40bdf4f755d711008810eb837a8f78d884f00956ae7ce7a7&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;毕业10年，我有话说&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247483949&amp;amp;idx=1&amp;amp;sn=200c9ac4f8e4e877b0b253d45205712a&amp;amp;chksm=fc3339ddcb44b0cb5ac2957dbed41b2f9e11fbba14967d00f97012806a9d6af364b0f8135eee&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】我是如何面试别人List相关知识的，深度有点长文&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247483989&amp;amp;idx=1&amp;amp;sn=cf9ce5c3f7981c16b71047b868b1c1ab&amp;amp;chksm=fc3339a5cb44b0b3df524ce684e8cd76ab6d15a2ccf26ec2425ecbcdd26bc777b95a06994189&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;我是如何在毕业不久只用1年就升为开发组长的&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247483994&amp;amp;idx=1&amp;amp;sn=fb09e943331e89abcb99d8304ea6b677&amp;amp;chksm=fc3339aacb44b0bc2a120c79efebb46a43ce5b4d3148992d86b2841a89bb46bf5d8863e065ea&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;爸爸又给Spring MVC生了个弟弟叫Spring WebFlux&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484017&amp;amp;idx=1&amp;amp;sn=a2055640b142fc4cfa5a9901d22ec57f&amp;amp;chksm=fc333981cb44b09782c196da25dc613b38a9ede52de073bfaaaef6214a9deb294b6527091892&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】我是如何在面试别人Spring事务时“套路”对方的&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484029&amp;amp;idx=1&amp;amp;sn=44b05473af37fe008bb9659a35d1a9de&amp;amp;chksm=fc33398dcb44b09bbd25a7e14e7100419988479fbeb4bda7787f1b93dd932ec699dfd793df04&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】Spring事务面试考点吐血整理（建议珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484158&amp;amp;idx=1&amp;amp;sn=1ca952ba9166c5ccf0e3f40622335fc5&amp;amp;chksm=fc33390ecb44b01898bb2500ba61a15e38487a23f5c0405d738cc4c272cd705d2dbbf1a3f8e7&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】我是如何在面试别人Redis相关知识时“软怼”他的&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484164&amp;amp;idx=1&amp;amp;sn=390d911b19812d22aebd3f0f6522004c&amp;amp;chksm=fc3338f4cb44b1e20bc2344474586934a2b148f92eefdaecf134d57af10f64310579e196904a&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】吃透了这些Redis知识点，面试官一定觉得你很NB（干货 | 建议珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484184&amp;amp;idx=1&amp;amp;sn=37007efde0cc93e48c55a133dc9cc8d4&amp;amp;chksm=fc3338e8cb44b1fea0ed4af7f01de658e8a1bc7f573cb5bde2701d9b09ba14747139d2bcea39&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】如果你这样回答“什么是线程安全”，面试官都会对你刮目相看（建议珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484195&amp;amp;idx=1&amp;amp;sn=95c3acdaeb0f6a1d61f152550c3d2669&amp;amp;chksm=fc3338d3cb44b1c55f6046f6280da863d3514cca3ce50ef29e2d53b0eafe2b7efef062c51c27&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】迄今为止把同步/异步/阻塞/非阻塞/BIO/NIO/AIO讲的这么清楚的好文章（快快珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484201&amp;amp;idx=1&amp;amp;sn=7cf45aff64eecdff58d2acea8fb7c9fa&amp;amp;chksm=fc3338d9cb44b1cfc6b5c797a005c91ed19b0dd06587fdfb2e7b553e2b03104a145380a7a990&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】一篇文章帮你彻底搞清楚“I/O多路复用”和“异步I/O”的前世今生（深度好文，建议珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484206&amp;amp;idx=1&amp;amp;sn=9547fdad111ac1a8ac9311cb9e76b9dc&amp;amp;chksm=fc3338decb44b1c89aee789e80e32989ea43232321397cc265c99b1d0ce4057e6563bc00a3d3&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】如果把线程当作一个人来对待，所有问题都瞬间明白了&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484214&amp;amp;idx=1&amp;amp;sn=0f677e8b0d61b5a5317a274cc8b33cbc&amp;amp;chksm=fc3338c6cb44b1d06aa20533aafb0b7b709b3bd88dbf6af6b8f3cb91288e4afc585ecb77489a&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Java多线程通关———基础知识挑战&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484224&amp;amp;idx=1&amp;amp;sn=78a994d8311dd0abf3f9419108ff363a&amp;amp;chksm=fc3338b0cb44b1a6803dbeb8540c17ce753f1878e3b7cc86cf6508e81dc32736f84d7224f166&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：帝国的基石&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; 品Spring系列文章 &amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484224&amp;amp;idx=1&amp;amp;sn=78a994d8311dd0abf3f9419108ff363a&amp;amp;chksm=fc3338b0cb44b1a6803dbeb8540c17ce753f1878e3b7cc86cf6508e81dc32736f84d7224f166&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：帝国的基石&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484229&amp;amp;idx=1&amp;amp;sn=b552914c42963d06306d35f1d8332284&amp;amp;chksm=fc3338b5cb44b1a39d0762b2fd94d8870fcbc520b0713964d9a453d8466d781897707de8cd8f&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：bean定义上梁山&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484244&amp;amp;idx=1&amp;amp;sn=d500b3ed748331687028b78d567222a8&amp;amp;chksm=fc3338a4cb44b1b23f5dd9bef1cc66950a1ded23151a05b38716f4ec46ff960cdda5d8022e8f&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：实现bean定义时采用的“先进生产力”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484249&amp;amp;idx=1&amp;amp;sn=dfbdca65a2b64b0ac951f90b301e73a0&amp;amp;chksm=fc3338a9cb44b1bfafee072597430dae91d4dd8b4787e4af0896f9ce45b258fd5d3634169a5d&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：注解终于“成功上位”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484259&amp;amp;idx=1&amp;amp;sn=791a5726b9b7bf41e4e64053cfbc7ffa&amp;amp;chksm=fc333893cb44b1851d2052423392551ca9188c4fc0a33f412ddda13af9e0dc6655966a668964&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：能工巧匠们对注解的“加持”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484301&amp;amp;idx=1&amp;amp;sn=a5557c4c285cb07a052238d3de2a2585&amp;amp;chksm=fc33387dcb44b16b487edee0ab4c755de394d19dd4a0acd2532af0e49e95eb7988628e93157b&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：SpringBoot和Spring到底有没有本质的不同？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484319&amp;amp;idx=1&amp;amp;sn=89d925e6128109444c2ec40111a9f217&amp;amp;chksm=fc33386fcb44b179dcee6ef522e2252420658c0342759a9d6d9795bf90b144f6284c72fe808d&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：负责bean定义注册的两个“排头兵”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484337&amp;amp;idx=1&amp;amp;sn=398a1f718cc8b5a711ba9f45a6d9074b&amp;amp;chksm=fc333841cb44b157da33d685daedda001cb59abb64aa6152c3d4096d43c8d92bff8ae5d084ed&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：SpringBoot轻松取胜bean定义注册的“第一阶段”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484358&amp;amp;idx=1&amp;amp;sn=21fc717c7815ae41103e3e2e4f5520df&amp;amp;chksm=fc333836cb44b120fd9073b6075580109d5665afbd0f50abe43e8a5aea42e066c759dcdb8157&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：SpringBoot发起bean定义注册的“二次攻坚战”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;作者&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是工作超过&lt;/span&gt;&lt;span&gt;&lt;strong&gt;10年&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;的码农，现在任架构师。喜欢研究技术，崇尚简单快乐。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;追求以通俗易懂的语言解说技术，希望所有的读者都能看懂并记住。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;下面是公众号和知识星球的二维码，欢迎关注！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201904/76066-20190419093441100-1622885471.jpg&quot; alt=&quot;&quot;/&gt;      &lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://img2018.cnblogs.com/blog/76066/201904/76066-20190419132131137-250931220.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 29 Sep 2019 00:09:00 +0000</pubDate>
<dc:creator>编程新说(李新杰)</dc:creator>
<og:description>其实对Spring的了解达到一定程度后，你就会发现，无论是使用Spring框架开发的应用，还是Spring框架本身的开发都是围绕着注解构建起来的。空口无凭，那就说个最普通的例子吧。在Spring中要启</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lixinjie/p/taste-spring-010.html</dc:identifier>
</item>
<item>
<title>设计模式-结构型-组合模式 - 酷学大叔</title>
<link>http://www.cnblogs.com/az4215/p/11602936.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/az4215/p/11602936.html</guid>
<description>&lt;p&gt;&lt;span&gt;组合模式（Composite）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　组合模式又叫部分整体模式，它是一种将对象组合成树状的层次结构模式，用来表示&quot;部分-整体&quot;的关系，使用户对单个对象和组合对象具有一致的访问性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;组合模式的角色：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1）抽象构建（Component）：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2）树叶构件（Leaf）：是组合中的叶节点对象，它没有子节点，用于实现抽象构件角色中 声明的公共接口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3）树枝构件（Composite）：是组合中的分支节点对象，它有子节点。它实现了抽象构件角色中声明的接口，它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild() 等方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1445321/201909/1445321-20190928151928249-1619063979.png&quot; alt=&quot;&quot; width=&quot;475&quot; height=&quot;213&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Create a tree structure&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         Composite root = &lt;span&gt;new&lt;/span&gt; Composite(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         root.Add(&lt;span&gt;new&lt;/span&gt; Leaf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Leaf A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         root.Add(&lt;span&gt;new&lt;/span&gt; Leaf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Leaf B&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         Composite comp = &lt;span&gt;new&lt;/span&gt; Composite(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Composite X&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         comp.Add(&lt;span&gt;new&lt;/span&gt; Leaf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Leaf XA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         comp.Add(&lt;span&gt;new&lt;/span&gt; Leaf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Leaf XB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        root.Add(comp);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         root.Add(&lt;span&gt;new&lt;/span&gt; Leaf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Leaf C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Add and remove a leaf&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         Leaf leaf = &lt;span&gt;new&lt;/span&gt; Leaf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Leaf D&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        root.Add(leaf);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        root.Remove(leaf);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Recursively display tree&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         root.Display(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Component
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _name;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Component(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;._name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Add(Component c);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Remove(Component c);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Display(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; depth);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Leaf : Component
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Leaf(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         : &lt;span&gt;base&lt;/span&gt;&lt;span&gt;(name)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Add(Component c)
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cannot add to a leaf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Remove(Component c)
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cannot remove from a leaf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Display(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; depth)
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         Console.WriteLine(&lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, depth) +&lt;span&gt; _name);
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; 
&lt;span&gt;66&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Composite : Component
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; List&amp;lt;Component&amp;gt; _children = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Component&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; 
&lt;span&gt;70&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Composite(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;         : &lt;span&gt;base&lt;/span&gt;&lt;span&gt;(name)
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; 
&lt;span&gt;75&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Add(Component component)
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt;        _children.Add(component);
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; 
&lt;span&gt;80&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Remove(Component component)
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt; &lt;span&gt;        _children.Remove(component);
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt; 
&lt;span&gt;85&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Display(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; depth)
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt;         Console.WriteLine(&lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, depth) +&lt;span&gt; _name);
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt; 
&lt;span&gt;89&lt;/span&gt;         &lt;span&gt;foreach&lt;/span&gt; (Component component &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _children)
&lt;/span&gt;&lt;span&gt;90&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;91&lt;/span&gt;             component.Display(depth + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;92&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;93&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;94&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 极简版如下，将显示部分可以拿到客户端进行：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Create a tree structure&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         Component root = &lt;span&gt;new&lt;/span&gt; Component(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         root.Add(&lt;span&gt;new&lt;/span&gt; Component(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Leaf A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         root.Add(&lt;span&gt;new&lt;/span&gt; Component(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Leaf B&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         Component comp = &lt;span&gt;new&lt;/span&gt; Component(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Composite X&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         comp.Add(&lt;span&gt;new&lt;/span&gt; Component(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Leaf XA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         comp.Add(&lt;span&gt;new&lt;/span&gt; Component(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Leaf XB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        root.Add(comp);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         root.Add(&lt;span&gt;new&lt;/span&gt; Component(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Leaf C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Add and remove a leaf&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         Component leaf = &lt;span&gt;new&lt;/span&gt; Component(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Leaf D&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        root.Add(leaf);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        root.Remove(leaf);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 由客户端显示，Component只进行组合&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Component
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _name;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; List&amp;lt;Component&amp;gt; _children = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Component&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Component(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;._name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Add(Component c)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        _children.Add(c);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Remove(Component c)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        _children.Remove(c);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;Component&amp;gt;&lt;span&gt; GetChild()
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _children;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;是不是恍然大悟，就是我们在做权限管理的时候用到的一对多的关系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;组合模式的优缺点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　优点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　1）组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的单个对象还是组合对象，这简化了客户端代码；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　2）更容易在组合体内加入新的对象，客户端不会因为加入新的对象而更改源代码，满足OCP原则。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　缺点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　1）设计较复杂，客户端需要花更多的时间理清类之间的层次关系；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　2）不容易限制容器中的构件；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　3）不容易用继承的方法来增加构件的新功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考：&lt;a href=&quot;https://www.cnblogs.com/libingql/p/3496345.html&quot;&gt;https://www.cnblogs.com/libingql/p/3496345.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 28 Sep 2019 23:25:00 +0000</pubDate>
<dc:creator>酷学大叔</dc:creator>
<og:description>组合模式（Composite）： 定义： 组合模式又叫部分整体模式，它是一种将对象组合成树状的层次结构模式，用来表示&amp;quot;部分-整体&amp;quot;的关系，使用户对单个对象和组合对象具有一致的访问性</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/az4215/p/11602936.html</dc:identifier>
</item>
<item>
<title>一次线上接口超时的排查过程 - JackieZheng</title>
<link>http://www.cnblogs.com/bigdataZJ/p/timeout-troubleshooting.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bigdataZJ/p/timeout-troubleshooting.html</guid>
<description>&lt;h3 id=&quot;1&quot;&gt;&lt;span&gt;1、事件还原&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;昨天下午，收到一个504的告警，显然这是一个超时告警。当时由于手头有其他事情，没在意，就只是瞄了一眼，但是引起告警的方法很熟悉，是我写的，第一反应有点诧异。&lt;/p&gt;
&lt;p&gt;诧异之后，继续处理手头的工作。&lt;/p&gt;
&lt;p&gt;一小时过后，又收到同样的告警，显然不是偶尔，肯定是哪儿出问题了，于是开始排查。&lt;/p&gt;
&lt;p&gt;报警的接口是一个Controller层ControllerA的getControllerAMethod接口，其调用了多个微服务，并最终拼装结果数据进行返回。出问题的是ServiceM，ServiceM服务里的getServiceMMethod方法逻辑也很简单，主要是两次数据库查询，从MySQL数据库取到数据并返回给调用方。&lt;/p&gt;
&lt;p&gt;调用链如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/201909/619240-20190929000831068-395811113.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2&quot;&gt;&lt;span&gt;2、环境介绍&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;语言：&lt;/strong&gt;Go&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DB：&lt;/strong&gt;MySQL&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据库交互：&lt;/strong&gt;database/sql（公司在此基础上做了一些定制和封装，本质还是database/sql）&lt;/p&gt;
&lt;p&gt;下面开始介绍这个问题的具体排查过程。&lt;/p&gt;

&lt;h3 id=&quot;3sql&quot;&gt;&lt;span&gt;3、本能反应：从sql语句入手&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;拿到告警，从告警信息和对应的日志详情信息来看，属于超时问题。&lt;/p&gt;
&lt;p&gt;第一反应是查看sql语句是否是慢查询（虽然打心里知道这个可能性极低），sql语句很简单，形如&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
select a, b, c from tableA where a in (a1,a2,a3)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不看执行计划也知道是可以命中索引的。&lt;/p&gt;
&lt;p&gt;但还是看了下执行计划和真实的执行情况，分析结果和响应时间都相当可观，没有任何问题。&lt;/p&gt;
&lt;p&gt;本能反应的排查就是这么索然无味，开始下一步排查。&lt;/p&gt;

&lt;h3 id=&quot;4context&quot;&gt;&lt;span&gt;4、上游排查：是否context时间耗尽&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;既然是超时问题，有可能是上游超时，也可能是下游超时，第一步排查已经排除了下游因为慢查询导致超时的可能性。&lt;/p&gt;
&lt;p&gt;那会不会是上游超时呢？显然是有可能的，毕竟我们知道Go的context可以一路传递下去，所有服务调用都共用设置的总的时间额度。&lt;/p&gt;
&lt;p&gt;而且从上图可以发现ServiceM也是在上游接口的最后一步，所以如果上面的服务占用耗时过多，就会导致ServiceM的时间额度被压缩的所剩无几。&lt;/p&gt;
&lt;p&gt;但是从日志排查可以发现，在ServiceM层看getServiceMethod方法对应sql查询几乎都是几十毫秒返回。&lt;/p&gt;
&lt;p&gt;从这个情况来看，不像是因为上游时间不够导致的超时。&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3 id=&quot;5rows&quot;&gt;&lt;span&gt;5、下游初步排查：rows成主要怀疑对象&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;既然上游时间额度充足，那问题还是大概率出在下游服务接口上。&lt;/p&gt;
&lt;p&gt;于是开始仔细阅读getServiceMMethod方法代码，下面是代码功能的伪代码实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
rows, err = db.query(sql1)
if err != nil {
  ...
}

defer rows.Close()
for rows.Next() {
  rows.scan(...)
}

rows, err = db.query(sql2)
if err != nil {
  ...
}

defer rows.Close()
for rows.Next() {
  rows.scan(...)
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;看完代码，开始有点小兴奋，我想没错了，大概就是这个rows的问题了。&lt;/p&gt;
&lt;p&gt;在《Go组件学习——database/sql数据库连接池你用对了吗》这篇我主要介绍了有关rows没有正常关闭带来的坑。所以开始联想是否是因为在遍历rows过程中没有正确关闭数据库连接，造成连接泄露，以至于后面的查询拿不到连接导致超时。&lt;/p&gt;
&lt;p&gt;原因我已经分析的清清楚楚，但是具体是哪一步除了问题呢，唯一能想到的是这里两次查询使用的是同一个rows对象，是不是某种情况导致在前一次已经关闭了连接而下一次查询直接使用了关闭的连接而导致超时呢？&lt;/p&gt;
&lt;p&gt;此时报警开始越来越频繁，于是将这里两次查询由原来的一个rows接收改为使用两个rows分别接收并关闭，然后提交代码，测试通过后开始上线。&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3 id=&quot;6&quot;&gt;&lt;span&gt;6、短暂的风平浪静&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;代码上线后，效果立竿见影。&lt;/p&gt;
&lt;p&gt;告警立马停止，日志也没有再出现超时的信息了，一切又恢复到了往日的平静，这让我坚信，我应该是找到原因并解决问题了吧。&lt;/p&gt;
&lt;p&gt;回到家后，心里还是有些不踏实，从11点开始，我拿出电脑，开始各种模拟、验证和还原告警的原因。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;7、三小时后，意识到风平浪静可能是假象&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;从11点开始，一直到两点，整整三个小时，我不但没有找到原因，反而发现我的解决方式可能并没有解决问题。&lt;/p&gt;
&lt;p&gt;因为出问题的代码并不复杂，如上所示，即只有两个Select查询。&lt;/p&gt;
&lt;p&gt;于是我写了一段一样的代码在本地测试，跑完后并没有出现超时或者拿不到连接的情况。甚至，我将maxConn和IdleConn都设置为1也无不会出现超时。&lt;/p&gt;
&lt;p&gt;除非，像文章《Go组件学习——database/sql数据库连接池你用对了吗》里说的一样，在row.Next()过程中提前退出且没有rows.Close()语句，才会造成下一次查询拿不到连接的情况，即如下代码所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
func oneConnWithRowsNextWithError() {
        db, _ := db.Open(&quot;mysql&quot;, &quot;root:rootroot@/dqm?charset=utf8&amp;amp;parseTime=True&amp;amp;loc=Local&quot;)

        db.SetMaxOpenConns(1)
        rows, err := db.Query(&quot;select * from test where name = 'jackie' limit 10&quot;)
        if err != nil {
                fmt.Println(&quot;query error&quot;)
        }

        i := 1
        for rows.Next() {
                i++
                if i == 3 {
                        break
                }
                fmt.Println(&quot;close&quot;)
        }

        row, _ := db.Query(&quot;select * from test&quot;)
        fmt.Println(row, rows)
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;但是原来的代码是有defer rows.Close()方法的，这个连接最终肯定是会关闭的，不会出现内存泄露的情况。&lt;/p&gt;
&lt;p&gt;这一刻，我想到了墨菲定律（因为没有真正解决问题，问题还回再次出现）。&lt;/p&gt;
&lt;p&gt;于是，我又开始扒源码，结合日志，发现一条重要线索，就是很多查询任务都是被主动cancel的。没错，这个cancel就是context.Timeout返回的cancel（这段代码是我司在database/sql基础上丰富的功能）。&lt;/p&gt;
&lt;p&gt;cancel触发的条件是执行database/sql中的QueryContext方法返回了err&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
// QueryContext executes a query that returns rows, typically a SELECT.
// The args are for any placeholder parameters in the query.
func (db *DB) QueryContext(ctx context.Context, query string, args ...interface{}) (*Rows, error) {
        var rows *Rows
        var err error
        for i := 0; i &amp;lt; maxBadConnRetries; i++ {
                rows, err = db.query(ctx, query, args, cachedOrNewConn)
                if err != driver.ErrBadConn {
                        break
                }
        }
        if err == driver.ErrBadConn {
                return db.query(ctx, query, args, alwaysNewConn)
        }
        return rows, err
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第一反应还是上游时间不够，直接cancel context导致的，但是这个原因我们在前面已经排除了。&lt;/p&gt;
&lt;p&gt;于是把这段代码一直往下翻了好几层，还一度怀疑到我们自研代码中的一个参数叫QueryTimeout是否配置过小，但是去看了一眼配置（这一眼很重要，后面会说），发现是800ms，显然是足够的。&lt;/p&gt;
&lt;p&gt;带着越来越多的问题，我心不甘情不愿的去睡觉了。&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3 id=&quot;8&quot;&gt;&lt;span&gt;8、墨菲定律还是显灵了&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;今天下午一点，我又收到了这个熟悉的告警，该来的总会来的（但是只收到一次告警）。&lt;/p&gt;
&lt;p&gt;前面说了，这个cancel可能是一个重要信息，所以问题的原因是没跑了，肯定是因为超时，超时可能是因为拿不到连接。&lt;/p&gt;
&lt;p&gt;因为getServiceMMethod已经排查一通了，并没有连接泄露的情况，但是其他地方会不会有泄漏呢？于是排查了ServiceM服务的所有代码，对于使用到rows对象的代码检查是否有正常关闭。&lt;/p&gt;
&lt;p&gt;排查后，希望破灭。&lt;/p&gt;
&lt;p&gt;到此为止，我打心里已经排除了是连接泄露的问题了。&lt;/p&gt;
&lt;p&gt;期间，我还问了我们DBA，因为我翻了下日志，今天上午8点左右有几条查询都在几百毫秒，怀疑是DB状态异常导致的。DBA给我的回复是数据库非常正常。&lt;/p&gt;
&lt;p&gt;我自己也看了监控，DB的状态和往日相比没有什么流量异常，也没有连接池数量的大起大落。&lt;/p&gt;
&lt;p&gt;同事说了前几天上了新功能，量比以前大，于是我也看了下新功能对应的代码，也没发现问题。&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3 id=&quot;9&quot;&gt;&lt;span&gt;9、准备&quot;曲线救国&quot;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;我想要的根本原因还没有找到，于是开始想是否可以通过其他方式来规避这个未知的问题呢。毕竟解决问题的最好方式就是不解决（换另一种方式）。&lt;/p&gt;
&lt;p&gt;准备将ServiceM方法的超时时间调大。&lt;/p&gt;
&lt;p&gt;也准备在ServiceM服务的getServiceMMethod方法添加缓存，通过缓存来抵挡一部分请求量。&lt;/p&gt;
&lt;p&gt;行吧，就到此为止，明天先用这两招试试看。&lt;/p&gt;
&lt;p&gt;于是，我准备站起来活动活动，顺便在脑海里盘点下这个告警的来龙去脉。&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3 id=&quot;10&quot;&gt;&lt;span&gt;10、灵机一动，我找到了真相&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;上游告警，下游超时 -&amp;gt;&lt;/p&gt;
&lt;p&gt;排除上游时间不够 -&amp;gt;&lt;/p&gt;
&lt;p&gt;排除下游rows未关闭 -&amp;gt;&lt;/p&gt;
&lt;p&gt;排除数据库状态不稳定 -&amp;gt;&lt;/p&gt;
&lt;p&gt;确定是下游超时 -&amp;gt;&lt;/p&gt;
&lt;p&gt;怀疑是拿不到连接 -&amp;gt;&lt;/p&gt;
&lt;p&gt;拿不到连接，拿不到连接， 拿不到连接&lt;/p&gt;
&lt;p&gt;于是又去翻数据库参数配置，刚上面是为了翻QueryTimeout参数，依稀记得这里的连接池设置不大。翻到配置看了下，idleConn=X，maxConn=Y。&lt;/p&gt;
&lt;p&gt;再去看了一眼getServiceMMethod方法的QPS监控，我觉得我找到了真相。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/201909/619240-20190929000842221-1216358696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从凌晨到早上八点，QPS一直在上升，一直到8点左右，突破Y，而maxConn=Y。&lt;/p&gt;
&lt;p&gt;所以应该是超过maxConn，导致后面的查询任务拿不到连接只能等待，等待到超时时间后还是没有拿到连接，所以触发上面说的cancel，从而也导致在上游看到的超时告警都是ServiceM的getServiceMMethod执行了超时时间，因为一直在等待。&lt;/p&gt;
&lt;p&gt;那么为什么图中有超过Y的时候没有一直报警呢，我理解应该是这期间有其他任务已经执行完查询任务将连接放回连接池，后面来的请求就可以直接使用了，毕竟还会有一个超时时间的等待窗口。&lt;/p&gt;
&lt;p&gt;那么为什么之前没有出现这种报警呢，我理解是之前量比较小，最近同事上线了新功能，导致该接口被调用次数增加，才凸显了这个问题。&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3 id=&quot;11&quot;&gt;&lt;span&gt;11、 总结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;其实，最后原因可能很简单，就是量起来了，配置的连接数显得小了，导致后来的查询任务拿不到连接超时了。&lt;/p&gt;
&lt;p&gt;但是这个超时横跨Controller层到Service以及最底层的DB层，而每一层都可能会导致超时，所以排查相对比较困难。&lt;/p&gt;
&lt;p&gt;下面是一些马后炮要点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最近改动的代码需要格外重视。如果以前长时间没有告警，最近上完新代码告警了，大概率和上线有关系（本次超时其实和新上线代码也有关系，虽然代码本身没有问题，但是新上线后流量变大了）&lt;/li&gt;
&lt;li&gt;善用工具。用好监控和日志等系统工具，从中找出有用的线索和联系。&lt;/li&gt;
&lt;li&gt;自上而下排查并追踪。针对不好定位的bug，可以按照一定顺序比如调用顺序依次检查、验证、排除，直到找到原因。&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Sat, 28 Sep 2019 16:17:00 +0000</pubDate>
<dc:creator>JackieZheng</dc:creator>
<og:description>一个接口超时，多次线上报警，一次修复上线，治标不治本。从上游接口到底层数据库，一一排查并排除可能，最终找到引起超时的原因。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bigdataZJ/p/timeout-troubleshooting.html</dc:identifier>
</item>
<item>
<title>Java 世界的盘古和女娲 —— Zygote - 秉心说</title>
<link>http://www.cnblogs.com/bingxinshuo/p/11605340.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bingxinshuo/p/11605340.html</guid>
<description>&lt;blockquote readability=&quot;2.6551724137931&quot;&gt;
&lt;p&gt;本文基于 Android 9.0 , 代码仓库地址 ： &lt;a href=&quot;https://github.com/lulululbj/android_9.0.0_r45&quot;&gt;android_9.0.0_r45&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文中源码链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lulululbj/android_9.0.0_r45/blob/master/frameworks/base/core/java/com/android/internal/os/Zygote.java&quot;&gt;Zygote.java&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lulululbj/android_9.0.0_r45/blob/master/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java&quot;&gt;ZygoteInit.java&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lulululbj/android_9.0.0_r45/blob/master/frameworks/base/core/java/com/android/internal/os/ZygoteServer.java&quot;&gt;ZygoteServer.java&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lulululbj/android_9.0.0_r45/blob/master/frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java&quot;&gt;ZygoteConnection.java&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lulululbj/android_9.0.0_r45/blob/master/frameworks/base/core/java/com/android/internal/os/RuntimeInit.java&quot;&gt;RuntimeInit.java&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;仔细看看下面这张 Android 体系图，找一下 &lt;code&gt;Zygote&lt;/code&gt; 在什么地方。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/800205/201909/800205-20190928225249499-883803461.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图来自 &lt;a href=&quot;http://gityuan.com/android/&quot;&gt;Gityuan 博客&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;纵观整个 Android 体系结构，底层内核空间以 Linux Kernel 为核心，上层用户空间以 C++/Java 组成的 Framework 层组成，通过系统调用来连接用户空间和内核空间。而用户空间又分为 Native 世界和 Java 世界，通过 JNI 技术进行连接。Native 世界的 &lt;code&gt;init&lt;/code&gt; 进程是所有用户进程的祖先，其 pid 为 1 。&lt;code&gt;init&lt;/code&gt; 进程通过解析 &lt;code&gt;init.rc&lt;/code&gt; 文件创建出 &lt;code&gt;Zygote&lt;/code&gt; 进程，&lt;code&gt;Zygote&lt;/code&gt; 进程人如其名，翻译成中文就是 &lt;strong&gt;受精卵&lt;/strong&gt; 的意思。它是 Java 世界的中的第一个进程，也是 Android 系统中的第一个 Java 进程，颇有盘古开天辟地之势。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Zygote&lt;/code&gt; 创建的第一个进程就是 &lt;code&gt;System Server&lt;/code&gt;，&lt;code&gt;System Server&lt;/code&gt; 负责管理和启动整个 Java Framework 层。创建完 &lt;code&gt;System Server&lt;/code&gt; 之后，&lt;code&gt;Zygote&lt;/code&gt; 就会完全进入受精卵的角色，等待进行无性繁殖，创建应用进程。所有的应用进程都是由 &lt;code&gt;Zygote&lt;/code&gt; 进程 fork 而来的，称之为 Java 世界的女娲也不足为过。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Zygote&lt;/code&gt; 的启动过程是从 Native 层开始的，这里不会 Native 层作过多分析，直接进入其在 Java 世界的入口 &lt;code&gt;ZygoteInit.main()&lt;/code&gt; :&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String argv[]) {
    ZygoteServer zygoteServer = new ZygoteServer();

    // Mark zygote start. This ensures that thread creation will throw
    // an error.
    ZygoteHooks.startZygoteNoThreadCreation();

    // Zygote goes into its own process group.
    // 设置进程组 ID
    // pid 为 0 表示设置当前进程的进程组 ID
    // gid 为 0 表示使用当前进程的 PID 作为进程组 ID
    try {
        Os.setpgid(0, 0);
    } catch (ErrnoException ex) {
        throw new RuntimeException(&quot;Failed to setpgid(0,0)&quot;, ex);
    }

    final Runnable caller;
    try {
        ......
        RuntimeInit.enableDdms(); // 启用 DDMS

        boolean startSystemServer = false;
        String socketName = &quot;zygote&quot;;
        String abiList = null;
        boolean enableLazyPreload = false;
        for (int i = 1; i &amp;lt; argv.length; i++) { // 参数解析
            if (&quot;start-system-server&quot;.equals(argv[i])) {
                startSystemServer = true;
            } else if (&quot;--enable-lazy-preload&quot;.equals(argv[i])) {
                enableLazyPreload = true;
            } else if (argv[i].startsWith(ABI_LIST_ARG)) {
                abiList = argv[i].substring(ABI_LIST_ARG.length());
            } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {
                socketName = argv[i].substring(SOCKET_NAME_ARG.length());
            } else {
                throw new RuntimeException(&quot;Unknown command line argument: &quot; + argv[i]);
            }
        }

        if (abiList == null) {
            throw new RuntimeException(&quot;No ABI list supplied.&quot;);
        }

        // 1. 注册服务端 socket，这里的 IPC 不是 Binder 通信
        zygoteServer.registerServerSocketFromEnv(socketName); 
        // In some configurations, we avoid preloading resources and classes eagerly.
        // In such cases, we will preload things prior to our first fork.
        if (!enableLazyPreload) {
            bootTimingsTraceLog.traceBegin(&quot;ZygotePreload&quot;);
            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,
                SystemClock.uptimeMillis());
            preload(bootTimingsTraceLog); // 2. 预加载操作
            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,
                SystemClock.uptimeMillis());
            bootTimingsTraceLog.traceEnd(); // ZygotePreload
        } else {
            Zygote.resetNicePriority(); // 设置线程优先级为 NORM_PRIORITY (5)
        }

        // Do an initial gc to clean up after startup
        gcAndFinalize(); // 3. 强制进行一次垃圾收集

        Zygote.nativeSecurityInit();

        // Zygote process unmounts root storage spaces.
        Zygote.nativeUnmountStorageOnInit();

        ZygoteHooks.stopZygoteNoThreadCreation();

        if (startSystemServer) {
            // 4. 启动SystemServer 进程
            Runnable r = forkSystemServer(abiList, socketName, zygoteServer); 

            // {@code r == null} in the parent (zygote) process, and {@code r != null} in the
            // child (system_server) process.
            if (r != null) {
                r.run(); // 由 RuntimeInit.java 中的 MethodAndArgsCaller 反射调用SystemServer 的 main() 方法
                return;
            }
        }

        Log.i(TAG, &quot;Accepting command socket connections&quot;);

        // The select loop returns early in the child process after a fork and
        // loops forever in the zygote.
        // 5. 循环等待处理客户端请求
        caller = zygoteServer.runSelectLoop(abiList);
    } catch (Throwable ex) {
        Log.e(TAG, &quot;System zygote died with exception&quot;, ex);
        throw ex;
    } finally {
        zygoteServer.closeServerSocket(); // 关闭并释放 socket 连接
    }

    // We're in the child process and have exited the select loop. Proceed to execute the
    // command.
    if (caller != null) {
        caller.run();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;省去部分不是那么重要的代码，&lt;code&gt;ZygoteInit.main()&lt;/code&gt; 方法大致可以分为以下五个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;registerServerSocketFromEnv&lt;/code&gt;， 注册服务端 socket，用于跨进程通信，这里并没有使用 Binder 通信。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;preload()&lt;/code&gt;，进行预加载操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gcAndFinalize()&lt;/code&gt;，在 forkSystemServer 之前主动进行一次垃圾回收&lt;/li&gt;
&lt;li&gt;&lt;code&gt;forkSystemServer()&lt;/code&gt;，创建 SystemServer 进程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;runSelectLoop()&lt;/code&gt;，循环等待处理客户端发来的 socket 请求&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面基本上就是 Zygote 的全部使命了，下面按照这个流程来详细分析。&lt;/p&gt;
&lt;h2 id=&quot;registerserversocketfromenv&quot;&gt;registerServerSocketFromEnv&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;gt; ZygoteServer.java

void registerServerSocketFromEnv(String socketName) {
    if (mServerSocket == null) {
        int fileDesc;
        final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName;
        try {
            // 从环境变量中获取 socket 的 fd
            String env = System.getenv(fullSocketName);
            fileDesc = Integer.parseInt(env);
        } catch (RuntimeException ex) {
            throw new RuntimeException(fullSocketName + &quot; unset or invalid&quot;, ex);
        }

        try {
            FileDescriptor fd = new FileDescriptor();
            fd.setInt$(fileDesc); // 设置文件描述符
            mServerSocket = new LocalServerSocket(fd); // 创建服务端 socket
            mCloseSocketFd = true;
        } catch (IOException ex) {
            throw new RuntimeException(
                    &quot;Error binding to local socket '&quot; + fileDesc + &quot;'&quot;, ex);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先从环境变量中获取 socket 的文件描述符 fd，然后根据 fd 创建服务端 &lt;code&gt;LocalServerSocket&lt;/code&gt;，用于 IPC 通信。这里的环境变量是在 init 进程创建 Zygote 进程时设置的。&lt;/p&gt;
&lt;h2 id=&quot;preload&quot;&gt;preload()&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;gt; ZygoteInit.java

static void preload(TimingsTraceLog bootTimingsTraceLog) {
        ......
        preloadClasses(); // 预加载并初始化 /system/etc/preloaded-classes 中的类
        ......
        preloadResources(); // 预加载系统资源
        ......
        nativePreloadAppProcessHALs(); // HAL?
        ......
        preloadOpenGL(); // 预加载 OpenGL
        ......
        preloadSharedLibraries(); // 预加载 共享库，包括 android、compiler_rt、jnigraphics 这三个库
        preloadTextResources(); // 预加载文字资源
        // Ask the WebViewFactory to do any initialization that must run in the zygote process,
        // for memory sharing purposes.
        // WebViewFactory 中一些必须在 zygote 进程中进行的初始化工作，用于共享内存
        WebViewFactory.prepareWebViewInZygote();
        warmUpJcaProviders();

        sPreloadComplete = true;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;preload()&lt;/code&gt; 方法主要进行一些类，资源，共享库的预加载工作，以提升运行时效率。下面依次来看一下都预加载了哪些内容。&lt;/p&gt;
&lt;h3 id=&quot;preloadclasses&quot;&gt;preloadClasses()&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;gt; ZygoteInit.java

private static void preloadClasses() {
    ......
    InputStream is;
    try {
        // /system/etc/preloaded-classes
        is = new FileInputStream(PRELOADED_CLASSES);
    } catch (FileNotFoundException e) {
        Log.e(TAG, &quot;Couldn't find &quot; + PRELOADED_CLASSES + &quot;.&quot;);
        return;
    }

    try {
        BufferedReader br
            = new BufferedReader(new InputStreamReader(is), 256);

        int count = 0;
        String line;
        while ((line = br.readLine()) != null) {
            // Skip comments and blank lines.
            line = line.trim();
            if (line.startsWith(&quot;#&quot;) || line.equals(&quot;&quot;)) {
                continue;
            }

            try {
                // Load and explicitly initialize the given class. Use
                // Class.forName(String, boolean, ClassLoader) to avoid repeated stack lookups
                // (to derive the caller's class-loader). Use true to force initialization, and
                // null for the boot classpath class-loader (could as well cache the
                // class-loader of this class in a variable).
                Class.forName(line, true, null);
                count++;
            } catch (ClassNotFoundException e) {
                Log.w(TAG, &quot;Class not found for preloading: &quot; + line);
            } catch (UnsatisfiedLinkError e) {
                Log.w(TAG, &quot;Problem preloading &quot; + line + &quot;: &quot; + e);
            } catch (Throwable t) {
                ......
            }
        }
    } catch (IOException e) {
        Log.e(TAG, &quot;Error reading &quot; + PRELOADED_CLASSES + &quot;.&quot;, e);
    } finally {
        IoUtils.closeQuietly(is);
        ......
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只保留了核心逻辑代码。读取 &lt;code&gt;/system/etc/preloaded-classes&lt;/code&gt; 文件，并通过 &lt;code&gt;Class.forName()&lt;/code&gt; 方法逐行加载文件中声明的类。提前预加载系统常用的类无疑可以提升运行时效率，但是这个预加载常用类的工作通常都会很重。搜索整个源码库，在 &lt;code&gt;/frameworks/base/config&lt;/code&gt; 目录下发现一份 &lt;code&gt;preloaded-classes&lt;/code&gt; 文件，打开这个文件，一共 &lt;code&gt;6558&lt;/code&gt; 行，这就意味着要提前加载数千个类，这无疑会消耗很长时间，以增加 Android 系统启动时间的代价提升了运行时的效率。&lt;/p&gt;
&lt;h3 id=&quot;preloadresources&quot;&gt;preloadResources()&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;gt; ZygoteInit.java

private static void preloadResources() {
    final VMRuntime runtime = VMRuntime.getRuntime();

    try {
        mResources = Resources.getSystem();
        mResources.startPreloading();
        if (PRELOAD_RESOURCES) {
            TypedArray ar = mResources.obtainTypedArray(
                    com.android.internal.R.array.preloaded_drawables);
            int N = preloadDrawables(ar);
            ar.recycle();
            ......
            ar = mResources.obtainTypedArray(
                    com.android.internal.R.array.preloaded_color_state_lists);
            N = preloadColorStateLists(ar);
            ar.recycle();

            if (mResources.getBoolean(
                    com.android.internal.R.bool.config_freeformWindowManagement)) {
                ar = mResources.obtainTypedArray(
                    com.android.internal.R.array.preloaded_freeform_multi_window_drawables);
                N = preloadDrawables(ar);
                ar.recycle();
            }
        }
        mResources.finishPreloading();
    } catch (RuntimeException e) {
        Log.w(TAG, &quot;Failure preloading resources&quot;, e);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从源码中可知，主要加载的资源有：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;com.android.internal.R.array.preloaded_drawables&lt;/p&gt;
&lt;p&gt;com.android.internal.R.array.preloaded_color_state_lists&lt;/p&gt;
&lt;p&gt;com.android.internal.R.array.preloaded_freeform_multi_window_drawables&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;preloadsharedlibraries&quot;&gt;preloadSharedLibraries()&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;gt; ZygoteInit.java

private static void preloadSharedLibraries() {
    Log.i(TAG, &quot;Preloading shared libraries...&quot;);
    System.loadLibrary(&quot;android&quot;);
    System.loadLibrary(&quot;compiler_rt&quot;);
    System.loadLibrary(&quot;jnigraphics&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;预加载了三个共享库，&lt;code&gt;libandroid.so&lt;/code&gt; 、&lt;code&gt;libcompiler_rt.so&lt;/code&gt; 和 &lt;code&gt;libjnigraphics.so&lt;/code&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;gcandfinalize&quot;&gt;gcAndFinalize()&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;gt; ZygoteInit.java

static void gcAndFinalize() {
    final VMRuntime runtime = VMRuntime.getRuntime();

    /* runFinalizationSync() lets finalizers be called in Zygote,
     * which doesn't have a HeapWorker thread.
     */
    System.gc();
    runtime.runFinalizationSync();
    System.gc();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;forkSystemServer()&lt;/code&gt; 之前会主动进行一次 GC 操作。&lt;/p&gt;
&lt;h2 id=&quot;forksystemserver&quot;&gt;forkSystemServer()&lt;/h2&gt;
&lt;p&gt;主动调用 GC 之后，Zygote 就要去做它的大事 —— fork SystemServer 进程了。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;gt; ZygoteInit.java

private static Runnable forkSystemServer(String abiList, String socketName,
    
    ......
    
    /* Hardcoded command line to start the system server */
    // 启动参数
    String args[] = {
        &quot;--setuid=1000&quot;,
        &quot;--setgid=1000&quot;,
        &quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023,1024,1032,1065,3001,3002,3003,3006,3007,3009,3010&quot;,
        &quot;--capabilities=&quot; + capabilities + &quot;,&quot; + capabilities,
        &quot;--nice-name=system_server&quot;, // 进程名
        &quot;--runtime-args&quot;,
        &quot;--target-sdk-version=&quot; + VMRuntime.SDK_VERSION_CUR_DEVELOPMENT,
        &quot;com.android.server.SystemServer&quot;, // 加载类名
    };
    ZygoteConnection.Arguments parsedArgs = null;

    int pid;

    try {
        parsedArgs = new ZygoteConnection.Arguments(args);
        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);
        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);

        boolean profileSystemServer = SystemProperties.getBoolean(
                &quot;dalvik.vm.profilesystemserver&quot;, false);
        if (profileSystemServer) {
            parsedArgs.runtimeFlags |= Zygote.PROFILE_SYSTEM_SERVER;
        }

        /* Request to fork the system server process
         * fork system_server 进程
         */
        pid = Zygote.forkSystemServer(
                parsedArgs.uid, parsedArgs.gid,
                parsedArgs.gids,
                parsedArgs.runtimeFlags,
                null,
                parsedArgs.permittedCapabilities,
                parsedArgs.effectiveCapabilities);
    } catch (IllegalArgumentException ex) {
        throw new RuntimeException(ex);
    }

    /* For child process */
    // pid == 0 表示子进程，从这里开始进入 system_server 进程
    if (pid == 0) {
        if (hasSecondZygote(abiList)) { // 如果有第二个 Zygote
            waitForSecondaryZygote(socketName);
        }

        zygoteServer.closeServerSocket(); // 关闭并释放从 Zygote copy 过来的 socket
        return handleSystemServerProcess(parsedArgs); // 完成新创建的 system_server 进程的剩余工作
    }

    /**
     * 注意 fork() 函数式一次执行，两次返回（两个进程对同一程序的两次执行）。
     * pid &amp;gt; 0  说明还是父进程。pid = 0 说明进入了子进程
     * 所以这里的 return null 依旧会执行 
     */
    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的启动参数可以看到，&lt;code&gt;SystemServer&lt;/code&gt; 进程的 &lt;code&gt;uid&lt;/code&gt; 和 &lt;code&gt;gid&lt;/code&gt; 都是 1000，进程名是 &lt;strong&gt;&lt;code&gt;system_server&lt;/code&gt;&lt;/strong&gt; ，其最后要加载的类名是 &lt;strong&gt;&lt;code&gt;com.android.server.SystemServer&lt;/code&gt;&lt;/strong&gt; 。准备好一系列参数之后通过 &lt;code&gt;ZygoteConnection.Arguments()&lt;/code&gt; 拼接，接着调用 &lt;code&gt;Zygote.forkSystemServer()&lt;/code&gt; 方法真正的 fork 出子进程 &lt;code&gt;system_server&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;gt; Zygote.java

public static int forkSystemServer(int uid, int gid, int[] gids, int runtimeFlags,
        int[][] rlimits, long permittedCapabilities, long effectiveCapabilities) {
    VM_HOOKS.preFork();
    // Resets nice priority for zygote process.
    resetNicePriority();
    int pid = nativeForkSystemServer(
            uid, gid, gids, runtimeFlags, rlimits, permittedCapabilities, effectiveCapabilities);
    // Enable tracing as soon as we enter the system_server.
    if (pid == 0) {
        Trace.setTracingEnabled(true, runtimeFlags);
    }
    VM_HOOKS.postForkCommon();
    return pid;
}

native private static int nativeForkSystemServer(int uid, int gid, int[] gids, int runtimeFlags,
        int[][] rlimits, long permittedCapabilities, long effectiveCapabilities);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后的 &lt;code&gt;fork()&lt;/code&gt; 操作是在 native 层完成的。再回到 &lt;code&gt;ZygoteInit.forkSystemServer()&lt;/code&gt; 中执行 fork() 之后的逻辑处理：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;if(pid == 0){
    ......
    return handleSystemServerProcess(parsedArgs);
}

return null;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按正常逻辑思维，这两处 &lt;code&gt;return&lt;/code&gt; 只会执行一次，其实不然。&lt;code&gt;fork()&lt;/code&gt; 函数是一次执行，两次返回。说的更严谨一点是 &lt;strong&gt;两个进程对用一个程序的两次执行&lt;/strong&gt;。当 &lt;code&gt;pid == 0&lt;/code&gt; 时，说明现在处于子进程，当 &lt;code&gt;pid &amp;gt; 0&lt;/code&gt; 时，说明处于父进程。在刚 fork 出子进程的时候，父子进程的数据结构基本是一样的，但是之后就分道扬镳了，各自执行各自的逻辑。所以上面的代码段中会有两次返回值，子进程 (system_server) 中会返回执行 &lt;code&gt;handleSystemServerProcess(parsedArgs)&lt;/code&gt; 的结果，父进程 (zygote) 会返回 &lt;code&gt;null&lt;/code&gt;。对于两个不同的返回值又会分别做什么处理呢？我们回到 &lt;code&gt;ZygoteInit.main()&lt;/code&gt; 中：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;if (startSystemServer) {
        Runnable r = forkSystemServer(abiList, socketName, zygoteServer);

        // {@code r == null} in the parent (zygote) process, and {@code r != null} in the
        // child (system_server) process.
        // r == null 说明是在 zygote 进程
        // r != null 说明是在 system_server 进程
        if (r != null) {
            r.run(); 
            return;
        }
    }
    
    // 循环等待处理客户端请求
    caller = zygoteServer.runSelectLoop(abiList);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;子进程 system_server 返回的是一个 Runnable，执行 &lt;code&gt;r.run()&lt;/code&gt;，然后就直接 return 了。而父进程 zygote 返回的是 null，所以不满足 if 的判断条件，继续往下执行 &lt;code&gt;runSelectLoop&lt;/code&gt; 。父子进程就此分道扬镳，各干各的事。&lt;/p&gt;
&lt;p&gt;下面就来分析 &lt;code&gt;runSelectLoop()&lt;/code&gt; 和 &lt;code&gt;handleSystemServerProcess()&lt;/code&gt; 这两个方法，看看 &lt;code&gt;Zygote&lt;/code&gt; 和 &lt;code&gt;SystemServer&lt;/code&gt; 这对父子进程继续做了些什么工作。&lt;/p&gt;
&lt;h2 id=&quot;handlesystemserverprocess&quot;&gt;handleSystemServerProcess&lt;/h2&gt;
&lt;p&gt;到这里其实已经脱离 Zygote 的范畴了，本准备放在下一篇 &lt;code&gt;SystemServer&lt;/code&gt; 源码解析中再介绍，可是这里不写又觉得 Zygote 介绍的不完整，索性就一并说了。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;gt; ZygoteInit.java

private static Runnable handleSystemServerProcess(ZygoteConnection.Arguments parsedArgs) {
    // set umask to 0077 so new files and directories will default to owner-only permissions.
    // umask一般是用在你初始创建一个目录或者文件的时候赋予他们的权限
    Os.umask(S_IRWXG | S_IRWXO);

    // 设置当前进程名为 &quot;system_server&quot;
    if (parsedArgs.niceName != null) { 
        Process.setArgV0(parsedArgs.niceName);
    }

    final String systemServerClasspath = Os.getenv(&quot;SYSTEMSERVERCLASSPATH&quot;);
    if (systemServerClasspath != null) {
        // dex 优化操作
        performSystemServerDexOpt(systemServerClasspath);
        // Capturing profiles is only supported for debug or eng builds since selinux normally
        // prevents it.
        boolean profileSystemServer = SystemProperties.getBoolean(
                &quot;dalvik.vm.profilesystemserver&quot;, false);
        if (profileSystemServer &amp;amp;&amp;amp; (Build.IS_USERDEBUG || Build.IS_ENG)) {
            try {
                prepareSystemServerProfile(systemServerClasspath);
            } catch (Exception e) {
                Log.wtf(TAG, &quot;Failed to set up system server profile&quot;, e);
            }
        }
    }

    if (parsedArgs.invokeWith != null) { // invokeWith 一般为空
        String[] args = parsedArgs.remainingArgs;
        // If we have a non-null system server class path, we'll have to duplicate the
        // existing arguments and append the classpath to it. ART will handle the classpath
        // correctly when we exec a new process.
        if (systemServerClasspath != null) {
            String[] amendedArgs = new String[args.length + 2];
            amendedArgs[0] = &quot;-cp&quot;;
            amendedArgs[1] = systemServerClasspath;
            System.arraycopy(args, 0, amendedArgs, 2, args.length);
            args = amendedArgs;
        }

        WrapperInit.execApplication(parsedArgs.invokeWith,
                parsedArgs.niceName, parsedArgs.targetSdkVersion,
                VMRuntime.getCurrentInstructionSet(), null, args);

        throw new IllegalStateException(&quot;Unexpected return from WrapperInit.execApplication&quot;);
    } else {
        ClassLoader cl = null;
        if (systemServerClasspath != null) {
            // 创建类加载器，并赋给当前线程
            cl = createPathClassLoader(systemServerClasspath, parsedArgs.targetSdkVersion);
                
            Thread.currentThread().setContextClassLoader(cl);
        }

        /*
         * Pass the remaining arguments to SystemServer.
         */
        return ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);
    }

    /* should never reach here */
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置进程名为 &lt;code&gt;system_server&lt;/code&gt;，执行 dex 优化，给当前线程设置类加载器，最后调用 &lt;code&gt;ZygoteInit.zygoteInit()&lt;/code&gt; 继续处理剩余参数。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static final Runnable zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) {
    ......
    // Redirect System.out and System.err to the Android log.
    // 重定向 System.out 和 System.err 到 Android log
    RuntimeInit.redirectLogStreams();

    RuntimeInit.commonInit(); // 一些初始化工作
    ZygoteInit.nativeZygoteInit(); // native 层初始化
    return RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader); // 调用入口函数
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重定向 Log，进行一些初始化工作。这部分不细说了，点击文章开头给出的源码链接，大部分都做了注释。最后调用 &lt;code&gt;RuntimeInit.applicationInit()&lt;/code&gt; ，继续追进去看看。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;gt; RuntimeInit.java

protected static Runnable applicationInit(int targetSdkVersion, String[] argv,
        ClassLoader classLoader) {
        
    ......
    final Arguments args = new Arguments(argv); // 解析参数

    ......
    // 寻找 startClass 的 main() 方法。这里的 startClass 是 com.android.server.SystemServer
    return findStaticMain(args.startClass, args.startArgs, classLoader);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的 &lt;code&gt;startClass&lt;/code&gt; 参数是 &lt;code&gt;com.android.server.SystemServer&lt;/code&gt;。&lt;code&gt;findStaticMain()&lt;/code&gt; 方法看名字就能知道它的作用是找到 &lt;code&gt;main()&lt;/code&gt; 函数，这里是要找到 &lt;code&gt;com.android.server.SystemServer&lt;/code&gt; 类的 &lt;code&gt;main()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected static Runnable findStaticMain(String className, String[] argv,
        ClassLoader classLoader) {
    Class&amp;lt;?&amp;gt; cl;

    try {
        cl = Class.forName(className, true, classLoader);
    } catch (ClassNotFoundException ex) {
        throw new RuntimeException(
                &quot;Missing class when invoking static main &quot; + className,
                ex);
    }

    Method m;
    try {
        // 寻找 main() 方法
        m = cl.getMethod(&quot;main&quot;, new Class[] { String[].class });
    } catch (NoSuchMethodException ex) {
        throw new RuntimeException(
                &quot;Missing static main on &quot; + className, ex);
    } catch (SecurityException ex) {
        throw new RuntimeException(
                &quot;Problem getting static main on &quot; + className, ex);
    }

    int modifiers = m.getModifiers();
    if (! (Modifier.isStatic(modifiers) &amp;amp;&amp;amp; Modifier.isPublic(modifiers))) {
        throw new RuntimeException(
                &quot;Main method is not public and static on &quot; + className);
    }

    /*
     * This throw gets caught in ZygoteInit.main(), which responds
     * by invoking the exception's run() method. This arrangement
     * clears up all the stack frames that were required in setting
     * up the process.
     * 返回一个 Runnable，在 Zygote 的 main() 方法中执行器 run() 方法
     * 之前的版本是抛出一个异常，在 main() 方法中捕获
     */
    return new MethodAndArgsCaller(m, argv);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;找到 main() 方法并构建一个 Runnable 对象 &lt;code&gt;MethodAndArgsCaller&lt;/code&gt; 。这里返回的 &lt;code&gt;Runnable&lt;/code&gt; 对象会在哪里执行呢？又要回到文章开头的 &lt;code&gt;ZygoteInit.main()&lt;/code&gt; 函数了，在 &lt;code&gt;forkSystemServer()&lt;/code&gt; 之后，子进程执行 &lt;code&gt;handleSystemServerProcess()&lt;/code&gt; 并返回一个 &lt;code&gt;Runnable&lt;/code&gt; 对象，在 &lt;code&gt;ZygoteInit.main()&lt;/code&gt; 中会执行其 &lt;code&gt;run()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;再来看看 &lt;code&gt;MethodAndArgsCaller&lt;/code&gt; 的 &lt;code&gt;run()&lt;/code&gt; 方法吧！&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;static class MethodAndArgsCaller implements Runnable {
    /** method to call */
    private final Method mMethod;

    /** argument array */
    private final String[] mArgs;

    public MethodAndArgsCaller(Method method, String[] args) {
        mMethod = method;
        mArgs = args;
    }

    public void run() {
        try {
            mMethod.invoke(null, new Object[] { mArgs });
        } catch (IllegalAccessException ex) {
            throw new RuntimeException(ex);
        } catch (InvocationTargetException ex) {
            Throwable cause = ex.getCause();
            if (cause instanceof RuntimeException) {
                throw (RuntimeException) cause;
            } else if (cause instanceof Error) {
                throw (Error) cause;
            }
            throw new RuntimeException(ex);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就一件事，执行参数中的 &lt;code&gt;method&lt;/code&gt;。这里的 &lt;code&gt;method&lt;/code&gt; 就是 &lt;code&gt;com.android.server.SystemServer&lt;/code&gt; 的 &lt;code&gt;main()&lt;/code&gt; 方法。到这里，&lt;code&gt;SystemServer&lt;/code&gt; 就要正式工作了。&lt;/p&gt;
&lt;p&gt;其实在老版本的 Android 源码中，并不是通过这种方法执行 &lt;code&gt;SystemServer.main()&lt;/code&gt; 的。老版本的 &lt;code&gt;MethodAndArgsCaller&lt;/code&gt; 是 &lt;code&gt;Exception&lt;/code&gt; 的子类，在这里会直接抛出异常，然后在 &lt;code&gt;ZygoteInit.main()&lt;/code&gt; 方法中进行捕获，捕获之后执行其 &lt;code&gt;run()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SystemServer&lt;/code&gt; 的具体分析就放到下篇文章吧，本篇的主角还是 &lt;code&gt;Zygote&lt;/code&gt; ！&lt;/p&gt;
&lt;p&gt;看到这里，&lt;code&gt;Zygote&lt;/code&gt; 已经完成了一件人生大事，孵化出了 &lt;code&gt;SystemServer&lt;/code&gt; 进程。但是作为 “女娲” ，造人的任务还是停不下来，任何一个应用进程的创建还是离不开它的。&lt;code&gt;ZygoteServer.runSlectLoop()&lt;/code&gt; 给它搭好了和客户端之前的桥梁。&lt;/p&gt;
&lt;h2 id=&quot;runselectloop&quot;&gt;runSelectLoop&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;gt; ZygoteServer.java

Runnable runSelectLoop(String abiList) {
    ArrayList&amp;lt;FileDescriptor&amp;gt; fds = new ArrayList&amp;lt;FileDescriptor&amp;gt;();
    ArrayList&amp;lt;ZygoteConnection&amp;gt; peers = new ArrayList&amp;lt;ZygoteConnection&amp;gt;();

    // mServerSocket 是之前在 Zygote 中创建的
    fds.add(mServerSocket.getFileDescriptor());
    peers.add(null);

    while (true) {
        StructPollfd[] pollFds = new StructPollfd[fds.size()];
        for (int i = 0; i &amp;lt; pollFds.length; ++i) {
            pollFds[i] = new StructPollfd();
            pollFds[i].fd = fds.get(i);
            pollFds[i].events = (short) POLLIN;
        }
        try {
            // 有事件来时往下执行，没有时就阻塞
            Os.poll(pollFds, -1);
        } catch (ErrnoException ex) {
            throw new RuntimeException(&quot;poll failed&quot;, ex);
        }
        for (int i = pollFds.length - 1; i &amp;gt;= 0; --i) {
            if ((pollFds[i].revents &amp;amp; POLLIN) == 0) {
                continue;
            }

            if (i == 0) { // 有新客户端连接
                ZygoteConnection newPeer = acceptCommandPeer(abiList);
                peers.add(newPeer);
                fds.add(newPeer.getFileDesciptor());
            } else { // 处理客户端请求
                try {
                    ZygoteConnection connection = peers.get(i);
                    final Runnable command = connection.processOneCommand(this);

                    ......
                } catch (Exception e) {
                   ......
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;mServerSocket&lt;/code&gt; 是 &lt;code&gt;ZygoteInit.main()&lt;/code&gt; 中一开始就建立的服务端 socket，用于处理客户端请求。一看到 &lt;code&gt;while(true)&lt;/code&gt; 就肯定会有阻塞操作。&lt;code&gt;Os.poll()&lt;/code&gt; 在有事件来时往下执行，否则就阻塞。当有客户端请求过来时，调用 &lt;code&gt;ZygoteConnection.processOneCommand()&lt;/code&gt; 方法来处理。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;processOneCommand()&lt;/code&gt; 源码很长，这里就贴一下关键部分：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;......
pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,
        parsedArgs.runtimeFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,
        parsedArgs.niceName, fdsToClose, fdsToIgnore, parsedArgs.startChildZygote,
        parsedArgs.instructionSet, parsedArgs.appDataDir);

try {
    if (pid == 0) {
        // in child 进入子进程
        zygoteServer.setForkChild();

        zygoteServer.closeServerSocket();
        IoUtils.closeQuietly(serverPipeFd);
        serverPipeFd = null;

        return handleChildProc(parsedArgs, descriptors, childPipeFd,
                parsedArgs.startChildZygote);
    } else {
        // In the parent. A pid &amp;lt; 0 indicates a failure and will be handled in
        // handleParentProc.
        IoUtils.closeQuietly(childPipeFd);
        childPipeFd = null;
        handleParentProc(pid, descriptors, serverPipeFd);
        return null;
    }
} finally {
            IoUtils.closeQuietly(childPipeFd);
            IoUtils.closeQuietly(serverPipeFd);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;乍一看是不是感觉有点眼熟？没错，这一块的逻辑和 &lt;code&gt;forkSystemServer()&lt;/code&gt; 很相似，只是这里 fork 的是普通应用进程，调用的是 &lt;code&gt;forkAndSpecialize()&lt;/code&gt; 方法。中间的代码调用就不在这详细分析了，最后还是会调用到 &lt;code&gt;findStaticMain()&lt;/code&gt; 执行应用进程的对应 &lt;code&gt;main()&lt;/code&gt; 方法，感兴趣的同学可以到我的源码项目 &lt;a href=&quot;https://github.com/lulululbj/android_9.0.0_r45&quot;&gt;android_9.0.0_r45&lt;/a&gt; 阅读相关文件，注释还是比较多的。&lt;/p&gt;
&lt;p&gt;还有一个问题，上面只分析了 Zygote 接收到客户端请求并响应，那么这个客户端可能是谁呢？具体又是如何与 Zygote 通信的呢？关于这个问题，后续文章中肯定会写到，关注我的 Github 仓库 &lt;a href=&quot;https://github.com/lulululbj/android_9.0.0_r45&quot;&gt;android_9.0.0_r45&lt;/a&gt;，所有文章都会第一时间同步过去。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;来一张时序图总结全文 ：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/800205/201909/800205-20190928225250170-1719934374.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后想说说如何阅读 AOSP 源码和开源项目源码。我的看法是，不要上来就拼命死磕，一行一行的非要全部看懂。首先要理清脉络，能大致的理出来一个时序图，然后再分层细读。这个细读的过程中碰到不懂的知识点就得自己去挖掘，比如文中遇到的 &lt;code&gt;forkSystemServer()&lt;/code&gt; 为什么会返回两次？当然，对于实在超出自己知识范畴的内容，也可以选择性的暂时跳过，日后再战。最后的最后，来篇技术博客吧！理清，看懂，表达，都会逐步加深你对源码的了解程度，还能分享知识，反馈社区，何乐而不为呢？&lt;/p&gt;
&lt;p&gt;下篇文章会具体说说 &lt;code&gt;SystemServer&lt;/code&gt; 进程具体都干了些什么。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;文章首发微信公众号： &lt;strong&gt;&lt;code&gt;秉心说&lt;/code&gt;&lt;/strong&gt; ， 专注 Java 、 Android 原创知识分享，LeetCode 题解。&lt;/p&gt;
&lt;p&gt;更多最新原创文章，扫码关注我吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/800205/201909/800205-20190928225251514-1932720024.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 28 Sep 2019 14:53:00 +0000</pubDate>
<dc:creator>秉心说</dc:creator>
<og:description>本文基于 Android 9.0 , 代码仓库地址 ： 'android_9.0.0_r45' 文中源码链接： 'Zygote.java' 'ZygoteInit.java' 'ZygoteServe</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bingxinshuo/p/11605340.html</dc:identifier>
</item>
<item>
<title>机器学习之SVM调参实例 - |旧市拾荒|</title>
<link>http://www.cnblogs.com/xiaoyh/p/11604168.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoyh/p/11604168.html</guid>
<description>&lt;p&gt;&lt;span&gt;这次我们将了解在机器学习中支持向量机的使用方法以及一些参数的调整。支持向量机的基本原理就是将低维不可分问题转换为高维可分问题，在前面的博客具体介绍过了，这里就不再介绍了。&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;57-支持向量机&quot;&gt;&lt;span&gt;首先导入相关标准库：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
%matplotlib inline
import numpy as np
import matplotlib.pyplot as plt
from scipy import stats

import seaborn as sns;sns.set() # 使用seaborn的默认设置
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;作为一个例子，首先我们随机生成一些数据，考虑分类任务的简单情况，其中两个类别的点是良好分隔的：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 随机来点数据  make_blobs为聚类产生数据集
from sklearn.datasets.samples_generator import make_blobs

# center：产生数据的中心点，默认值3
X, y = make_blobs(n_samples=50, centers=2, random_state=0, cluster_std=0.60)
plt.scatter(X[:, 0], X[:, 1], c=y, s=50, cmap='autumn')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;画出的散点图为当前数据的分布情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1126989/201909/1126989-20190928174813335-1184419257.png&quot; alt=&quot;&quot; width=&quot;405&quot; height=&quot;282&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们将尝试绘制分离两组数据的直线，从而创建分类模型。对于这里所示的二维数据，这是我们可以手动完成的任务。 但是立刻我们看到一个问题：有两个以上的可能的分界线可以完美地区分两个类！&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;55&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
xfit = np.linspace(-1, 3.5)
plt.scatter(X[:, 0], X[:, 1], c=y, s=50, cmap='autumn')
plt.plot([0.6], [2.1], 'x', color='red', markeredgewidth=2, markersize=10)

for m, b in [(1, 0.65), (0.5, 1.6), (-0.2, 2.9)]:
    plt.plot(xfit, m * xfit + b, '-k')

plt.xlim(-1, 3.5)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这些是三个不同的分隔直线，然而，这些分隔直线能够完全区分这些样例。  显然，我们简单的直觉，“在分类之间划线”是不够的，我们需要进一步思考，根据支持向量机的思想，这样划分的效果不太理想。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1126989/201909/1126989-20190928174859597-340308744.png&quot; alt=&quot;&quot; width=&quot;378&quot; height=&quot;277&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;支持向量机提供了一种改进方法。 直觉是这样的：我们并非在分类之间，简单绘制一个零宽度的直线，而是画出边距为一定宽度的直线，直到最近的点。 这是一个例子：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;60&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
xfit = np.linspace(-1, 3.5)
plt.scatter(X[:, 0], X[:, 1], c=y, s=50, cmap='autumn')

for m, b, d in [(1, 0.65, 0.33), (0.5, 1.6, 0.55), (-0.2, 2.9, 0.2)]:
    yfit = m * xfit + b
    plt.plot(xfit, yfit, '-k')
    plt.fill_between(xfit, yfit - d, yfit + d, edgecolor='none',
                     color='#AAAAAA', alpha=0.4) # alpha透明度

plt.xlim(-1, 3.5);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如图所示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1126989/201909/1126989-20190928175001932-625239345.png&quot; alt=&quot;&quot; width=&quot;377&quot; height=&quot;247&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在支持向量机中，边距最大化的直线是我们将选择的最优模型。 支持向量机是这种最大边距估计器的一个例子。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们来看看这个数据的实际结果：我们将使用 sklearn 的支持向量分类器，对这些数据训练 SVM 模型。 目前，我们将使用一个线性核并将&lt;code&gt;C&lt;/code&gt;参数设置为一个默认的数值。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from sklearn.svm import SVC  # Support Vector Classifier
model = SVC(kernel='linear') # 线性核函数
model.fit(X, y)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;得到的SVM模型为&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SVC(C=1.0, cache_size=200, class_weight=None, coef0=0.0,
    decision_function_shape='ovr', degree=3, gamma='auto_deprecated',
    kernel='linear', max_iter=-1, probability=False, random_state=None,
    shrinking=True, tol=0.001, verbose=False)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;为了更好展现这里发生的事情，让我们创建一个辅助函数，为我们绘制 SVM 的决策边界。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;60&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
#绘图函数
def plot_svc_decision_function(model, ax=None, plot_support=True):
    &quot;&quot;&quot;Plot the decision function for a 2D SVC&quot;&quot;&quot;
    if ax is None:
        ax = plt.gca() # get子图
    xlim = ax.get_xlim()
    ylim = ax.get_ylim()
    
    # create grid to evaluate model
    x = np.linspace(xlim[0], xlim[1], 30)
    y = np.linspace(ylim[0], ylim[1], 30)
    Y, X = np.meshgrid(y, x) # 生成网格点和坐标矩阵
    xy = np.vstack([X.ravel(), Y.ravel()]).T     # 堆叠数组
    P = model.decision_function(xy).reshape(X.shape)
    
    # plot decision boundary and margins
    ax.contour(X, Y, P, colors='k',
               levels=[-1, 0, 1], alpha=0.5,
               linestyles=['--', '-', '--']) # 生成等高线 - -
    
    # plot support vectors
    if plot_support:
        ax.scatter(model.support_vectors_[:, 0],
                   model.support_vectors_[:, 1],
                   s=300, linewidth=1, facecolors='none');
    ax.set_xlim(xlim)
    ax.set_ylim(ylim)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;绘出决策边界&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
plt.scatter(X[:, 0], X[:, 1], c=y, s=50, cmap='autumn')
plot_svc_decision_function(model);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1126989/201909/1126989-20190928175154732-148893538.png&quot; alt=&quot;&quot; width=&quot;393&quot; height=&quot;265&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是最大化两组点之间的间距的分界线，那中间这条线就是我们最终的决策边界了。 请注意，一些训练点碰到了边缘， 这些点是这种拟合的关键要素，被称为支持向量。 在 Scikit-Learn 中，这些点存储在分类器的&lt;code&gt;support_vectors_&lt;/code&gt;属性中：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
model.support_vectors_
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;得到的支持向量的结果&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;array([[0.44359863, 3.11530945],
       [2.33812285, 3.43116792],
       [2.06156753, 1.96918596]])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在支持向量机只有位于支持向量上面的点才会对决策边界有影响，也就是说不管有多少的点是非支持向量，那对最终的决策边界都不会产生任何影响。我们可以看到这一点，例如，如果我们绘制该数据集的前 60 个点和前120个点获得的模型：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;61&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
def plot_svm(N=10, ax=None):
    X, y = make_blobs(n_samples=200, centers=2,
                      random_state=0, cluster_std=0.60)
    X = X[:N]
    y = y[:N]
    model = SVC(kernel='linear', C=1E10)
    model.fit(X, y)
    
    ax = ax or plt.gca()
    ax.scatter(X[:, 0], X[:, 1], c=y, s=50, cmap='autumn')
    ax.set_xlim(-1, 4)
    ax.set_ylim(-1, 6)
    plot_svc_decision_function(model, ax)

fig, ax = plt.subplots(1, 2, figsize=(16, 6))
fig.subplots_adjust(left=0.0625, right=0.95, wspace=0.1)
for axi, N in zip(ax, [60, 120]):
    plot_svm(N, axi)
    axi.set_title('N = {0}'.format(N))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;观察可以发现分别使用60个和120个数据点，决策边界却没有发生变化。所有只要支持向量没变，其他的数据怎么加无所谓！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1126989/201909/1126989-20190928175349513-1459985154.png&quot; alt=&quot;&quot; width=&quot;925&quot; height=&quot;320&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;首先我们先用线性的核来看一下在下面这样比较难的数据集上还能分了吗？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from sklearn.datasets.samples_generator import make_circles
X, y = make_circles(100, factor=.1, noise=.1) # 二维圆形数据 factor 内外圆比例 (0,1)

clf = SVC(kernel='linear').fit(X, y)

plt.scatter(X[:, 0], X[:, 1], c=y, s=50, cmap='autumn')
plot_svc_decision_function(clf, plot_support=False);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;数据集如图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1126989/201909/1126989-20190928175443582-98933827.png&quot; alt=&quot;&quot; width=&quot;374&quot; height=&quot;247&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很明显，用线性分类分不了了，那咋办呢？试试高维核变换吧！&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;49&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
#加入了新的维度r
from mpl_toolkits import mplot3d
r = np.exp(-(X ** 2).sum(1))
def plot_3D(elev=30, azim=30, X=X, y=y):
    ax = plt.subplot(projection='3d')
    ax.scatter3D(X[:, 0], X[:, 1], r, c=y, s=50, cmap='autumn')
    ax.view_init(elev=elev, azim=azim) # 设置3D视图的角度  一般都为45
    ax.set_xlabel('x')
    ax.set_ylabel('y')
    ax.set_zlabel('r')

plot_3D(elev=45, azim=45, X=X, y=y)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;画出刚才的数据集的一个3维图像&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1126989/201909/1126989-20190928175544890-269011765.png&quot; alt=&quot;&quot; width=&quot;396&quot; height=&quot;268&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在 Scikit-Learn 中，我们可以通过使用&lt;code&gt;kernel&lt;/code&gt;模型超参数，将线性核更改为 RBF（径向基函数，也叫高斯核函数）核来进行核变换，先暂时不管C参数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
#加入径向基函数
clf = SVC(kernel='rbf', C=1E6)
clf.fit(X, y)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;得到的SVM模型为&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SVC(C=1000000.0, cache_size=200, class_weight=None, coef0=0.0,
    decision_function_shape='ovr', degree=3, gamma='auto_deprecated',
    kernel='rbf', max_iter=-1, probability=False, random_state=None,
    shrinking=True, tol=0.001, verbose=False)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;再次进行分类任务&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
#这回牛逼了！
plt.scatter(X[:, 0], X[:, 1], c=y, s=50, cmap='autumn')
plot_svc_decision_function(clf)
plt.scatter(clf.support_vectors_[:, 0], clf.support_vectors_[:, 1],
            s=300, lw=1, facecolors='none');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;分类结果如图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1126989/201909/1126989-20190928175757268-1378013428.png&quot; alt=&quot;&quot; width=&quot;395&quot; height=&quot;257&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用这种核支持向量机，我们学习一个合适的非线性决策边界。这种核变换策略在机器学习中经常被使用！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;软间隔问题主要是调节C参数， 当C趋近于无穷大时：意味着分类严格不能有错误， 当C趋近于很小的时：意味着可以有更大的错误容忍&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
X, y = make_blobs(n_samples=100, centers=2,
                  random_state=0, cluster_std=0.8)
plt.scatter(X[:, 0], X[:, 1], c=y, s=50, cmap='autumn');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;先看看有噪声点的数据的分布&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1126989/201909/1126989-20190928175848655-1529077931.png&quot; alt=&quot;&quot; width=&quot;369&quot; height=&quot;248&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面的分布看起来要严格地进行划分的话，似乎不太可能，我们可以进行软间隔调整看看&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;64&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
X, y = make_blobs(n_samples=100, centers=2,
                  random_state=0, cluster_std=0.8)

fig, ax = plt.subplots(1, 2, figsize=(16, 6))
fig.subplots_adjust(left=0.0625, right=0.95, wspace=0.1)

for axi, C in zip(ax, [10.0, 0.1]):
    model = SVC(kernel='linear', C=C).fit(X, y)
    axi.scatter(X[:, 0], X[:, 1], c=y, s=50, cmap='autumn')
    plot_svc_decision_function(model, axi)
    axi.scatter(model.support_vectors_[:, 0],
                model.support_vectors_[:, 1],
                s=300, lw=1, facecolors='none');
    axi.set_title('C = {0:.1f}'.format(C), size=14)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以比较不同C参数模型地结果，在实际应用中可以适当调整以提高模型的泛化能力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1126989/201909/1126989-20190928175943554-1365454443.png&quot; alt=&quot;&quot; width=&quot;839&quot; height=&quot;296&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面再看另一个参数gamma值，这个参数只是在高斯核函数里面才有。这个参数控制着模型的复杂程度，这个值越大，模型越复杂，值越小，模型就越精简。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;64&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
X, y = make_blobs(n_samples=100, centers=2,
                  random_state=0, cluster_std=1.1)

fig, ax = plt.subplots(1, 2, figsize=(16, 6))
fig.subplots_adjust(left=0.0625, right=0.95, wspace=0.1)

for axi, gamma in zip(ax, [10.0, 0.1]):
    model = SVC(kernel='rbf', gamma=gamma).fit(X, y)
    axi.scatter(X[:, 0], X[:, 1], c=y, s=50, cmap='autumn')
    plot_svc_decision_function(model, axi)
    axi.scatter(model.support_vectors_[:, 0],
                model.support_vectors_[:, 1],
                s=300, lw=1, facecolors='none');
    axi.set_title('gamma = {0:.1f}'.format(gamma), size=14)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以比较一下，当这个参数较大时，可以看出模型分类效果很好，但泛化不太好。当这个参数较小时，可以看出模型里面有些分类是有错误的，但是这个泛化能力更好，一般也应有的更多。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1126989/201909/1126989-20190928180032513-2082148970.png&quot; alt=&quot;&quot; width=&quot;936&quot; height=&quot;330&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;通过这次简单的练习，对支持向量机模型有了更加深刻的理解，学习了在支持向量机中SVM的基本使用，以及软间隔参数的调整，还有核函数变化和gamma值等一些参数的比较。 &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 28 Sep 2019 14:04:00 +0000</pubDate>
<dc:creator>|旧市拾荒|</dc:creator>
<og:description>一、任务 这次我们将了解在机器学习中支持向量机的使用方法以及一些参数的调整。支持向量机的基本原理就是将低维不可分问题转换为高维可分问题，在前面的博客具体介绍过了，这里就不再介绍了。 首先导入相关标准库</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaoyh/p/11604168.html</dc:identifier>
</item>
<item>
<title>大文件分割、命名脚本 - Python - HoLoong</title>
<link>http://www.cnblogs.com/helongBlog/p/11605099.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/helongBlog/p/11605099.html</guid>
<description>&lt;p&gt;工作中经常会收到测试同学、客户同学提供的日志文件，其中不乏几百M一G的也都有，毕竟压测一晚上产生的日志量还是很可观的，xDxD，因此不可避免的需要对日志进行分割，通常定位问题需要针对时间点，因此最好对分割后的日志文件使用文件中日志的开始、结束时间点来命名，这样使用起来最为直观，下面给大家分享两个脚本，分别作分割、命名，希望能够给大家提供一点点帮助；&lt;/p&gt;
&lt;h2 id=&quot;大文件分割&quot;&gt;大文件分割&lt;/h2&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li&gt;python split_big_file.py&lt;/li&gt;
&lt;li&gt;输入文件全路径名&lt;/li&gt;
&lt;li&gt;输入期望的分割后每个小文件的行数&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;Just wait.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; # -*- coding:utf-8 -*-

 import os,re,shutil
 import platform

 sys_name = platform.system().lower()
 SPLIT_CHAR = '\\' if sys_name.find('windows') != -1 else '/'

 print('input big files`s path:')
 _path = raw_input()
 names = []
 pathes = []
 if os.path.isfile(_path):
     print('is file')
     names.append(_path)
 else:
     print('is nothing')
 '''
 elif os.path.isdir(_path):
     print('This is dir')
     pathes = os.listdir(_path)
     print('pathes='+str(pathes))
     for i in range(len(pathes)):
         fullpath = _path+SPLIT_CHAR+pathes[i]
         print('fullpath='+fullpath)
         if os.path.isfile(fullpath):
             names.append(fullpath)
             files.append(open(fullpath).read().split('\n'))
 '''

 print(len(names))

 line_num = int(raw_input('every file`line num = '))
 print('line number='+str(line_num))

 for i in range(len(names)):
     _name = names[i]
     ori_name = _name.split(SPLIT_CHAR)[len(_name.split(SPLIT_CHAR))-1]
     dir_name = _name.replace(ori_name,'DIR_'+ori_name)
     dir_name = dir_name.replace('.','_')
     print ori_name
     print dir_name
     os.system('mkdir '+dir_name)
     count = 1
     print '已处理：'+str(count)+'行'
     part_file = open(dir_name+SPLIT_CHAR+str(0)+'.part.txt','w')
     with open(_name, 'rb') as f:
         for line in f:
         if count%line_num == 0:
             part_file.close()
             part_file = open(dir_name+SPLIT_CHAR+str(int(count/line_num))+'.part.txt','w')
         part_file.write(line+'\n')
         count+=1
         if count%100000 == 0:
             print '已处理：'+str(count)+'行'
     print '已处理：'+str(count)+'行'
     os.system('python ./get_name_logfile.py '+dir_name)&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;文件按照开始结束行时间戳重命名&quot;&gt;文件按照开始、结束行时间戳重命名&lt;/h2&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;python get_name_logfile.py log.txt&lt;/li&gt;
&lt;li&gt;python get_name_logfile.py logs&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;参数选择文件或者文件夹均可，如果是文件夹，则会针对文件夹中的每个文件做处理（不会递归到文件夹下文件夹中的文件哦）；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    # -*- coding:utf-8 -*-


    import os,re,shutil
    import sys
    import platform

    sys_name = platform.system().lower()
    SPLIT_CHAR = '\\' if sys_name.find('windows') != -1 else '/'

    _path = sys.argv[1]
    names = []
    files = []
    pathes = []
    if os.path.isfile(_path):
        print('is file')
        names[0] = _path
    elif os.path.isdir(_path):
        print('This is dir')
        pathes = os.listdir(_path)
        print('pathes='+str(pathes))
        for i in range(len(pathes)):
            fullpath = _path+SPLIT_CHAR+pathes[i]
            print('fullpath='+fullpath)
            if os.path.isfile(fullpath):
                names.append(fullpath)
    else:
        print('is nothing')
        
    print(len(names))

    #   日期格式 ： 05-26 18:20:42.093   r'\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}'
    #   
    #   05-26 18:20:43.093：r'\d{2}-\d{2} {1,}\d{2}:\d{2}:\d{2}.\d{1,10}'

    date_reg = r'\d{2}-\d{2} {1,}\d{2}:\d{2}:\d{2}.\d{1,10}'
    time_reg = r'\d{2}:\d{2}:\d{2}.\d{1,10}'

    for i in range(len(names)):
        _name = names[i]
        print('name='+_name)
        # head 尝试在10行内查找日期
        head_len = 10
        start_time = '(start_time-'
        _file_ = open(_name, 'rb')
        reads = _file_.read()
        _file = reads.split('\n')
        if len(_file)/2 &amp;lt; 10:
            head_len = len(_file)/2
        for j in range(head_len):
            res = re.search(date_reg, _file[j])
            if res!=None and res.group(0)!=None:
                start_time = res.group(0)
                print('start_time='+start_time)
                break
        # tail
        tail_len = len(_file)-head_len
        end_time = '-end_time)'
        for j in range(len(_file)-1,tail_len-1,-1):
            res = re.search(time_reg, _file[j])
            if res!=None and res.group(0)!=None:
                end_time = res.group(0)
                print('end_time='+end_time)
                break
        _file_.close()
        ori_name = _name.split(SPLIT_CHAR)[len(_name.split(SPLIT_CHAR))-1]
        print('ori_name='+ori_name)
        new_name = start_time.replace(':','-')+'__'+end_time.replace(':','-')+os.path.splitext(ori_name)[1]
        print('new_name='+new_name)
        print(&quot;copy %s %s&quot; % (_name, _name.replace(ori_name,new_name)))
        #os.system (&quot;copy %s %s&quot; % (_name, _name.replace(ori_name,new_name)))
        shutil.copy(_name,_name.replace(ori_name,new_name))
        os.system (&quot;rm -rf &quot;+_name)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;大家可以到我的Github上看看有没有其他需要的东西，目前主要是自己做的机器学习项目、Python各种脚本工具、数据分析挖掘项目以及Follow的大佬、Fork的项目等：&lt;br/&gt;&lt;a href=&quot;https://github.com/NemoHoHaloAi&quot; class=&quot;uri&quot;&gt;https://github.com/NemoHoHaloAi&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 28 Sep 2019 14:02:00 +0000</pubDate>
<dc:creator>HoLoong</dc:creator>
<og:description>日志文件分割、命名 工作中经常会收到测试同学、客户同学提供的日志文件，其中不乏几百M一G的也都有，毕竟压测一晚上产生的日志量还是很可观的，xDxD，因此不可避免的需要对日志进行分割，通常定位问题需要针</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/helongBlog/p/11605099.html</dc:identifier>
</item>
<item>
<title>对cpu与load的理解及线上问题处理思路解读 - 五月的仓颉</title>
<link>http://www.cnblogs.com/xrq730/p/11041741.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xrq730/p/11041741.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2019双11还有不到2个月就要到来了，大家也都知道服务器在大促期间由于流量的增加势必导致机器的cpu与load变高。&lt;/span&gt;&lt;span&gt;因此趁着这个时机正好再好好学习、巩固一下cpu和load的概念，为双11做准备的同时也是增加自己的技能储备。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不过cpu和load这块真的还是很需要积累的，我自己经验尚浅，感觉还是有许多写的不到位与不对的地方，也是希望如果有错误，大家可以帮助指正。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;top命令&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;既然说了cpu和load，那总需要监控吧，没有监控就不知道cpu和load，后面的一切也就无从谈起了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;top命令是最常见的查看cpu和load的命令，&lt;/span&gt;&lt;span&gt;拿我自己虚拟机上装的ubuntu系统执行一下top命令（默认3秒刷1次，-d可指定刷新时间）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/801753/201906/801753-20190619112115464-1159095756.png&quot; alt=&quot;&quot; width=&quot;602&quot; height=&quot;188&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;做了一张表格比较详细地解释了每一部分的含义，其中重要属性做了标红加粗：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/801753/201909/801753-20190928153957669-97998610.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内存与SWAP输出格式是一样的，因此放在了一起写。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;cpu如何计算&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当我们执行top命令的时候，看到里面的值（主要是cpu和load）值是一直在变的，因此有必要简单了解一下Linux系统中cpu的计算方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;cpu分为系统cpu和进程、线程cpu，&lt;span&gt;系统cpu&lt;/span&gt;的统计值位于&lt;span&gt;&lt;strong&gt;/proc/stat&lt;/strong&gt;&lt;/span&gt;下（以下的截图未截全）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/801753/201906/801753-20190619214504798-1297192392.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;cpu、cpu0后面的这些数字都和前面的us、sy、ni这些对应，具体哪个对应哪个值不重要，感兴趣的可以网上查一下文档。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;进程cpu&lt;/strong&gt;&lt;/span&gt;的统计值位于&lt;span&gt;&lt;strong&gt;/proc/{pid}/stat&lt;/strong&gt;&lt;/span&gt;下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/801753/201906/801753-20190619214423028-82470305.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;线程cpu&lt;/strong&gt;&lt;/span&gt;的统计值位于&lt;span&gt;&lt;strong&gt;/proc/{pid}/task/{threadId}/stat&lt;/strong&gt;&lt;/span&gt;下： &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/801753/201906/801753-20190619215527839-2055018869.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里面的所有值都是&lt;span&gt;&lt;strong&gt;从系统启动时间到当前时间的一个值&lt;/strong&gt;&lt;/span&gt;。因此，对于cpu的计算的做法是，采样两个足够短的时间t1、t2：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;将t1的所有cpu使用情况求和，得到s1&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将t2的所有cpu使用情况求和，得到s2&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;s2 - s1得到这个时间间隔内的所有时间totalCpuTime&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;第一次的空闲idle1 - 第二次的空闲idle2，获取采样时间内的空闲时间&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;cpu使用率 = 100 * (totalCpuTime - idle) / totalCpuTime&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;其他时间例如us、sy、ni都是类似的计算方式，总结起来说，&lt;span&gt;&lt;strong&gt;cpu这个值反应的是某个采样时间内的cpu使用情况&lt;/strong&gt;&lt;span&gt;。因此有时候cpu很高，但是打印线程堆栈出来发现高cpu的线程在查询数据库等待中，不要觉得奇怪，因为cpu统计的是采样时间内的数据。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设top观察某段时间用户空间cpu一直很高，那么意味着这段时间用户的程序一直在占据着cpu做事情。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;对load的理解&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于load的含义，其实有些文章把它跟行车过桥联系在一起是比较恰当和好理解的：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;一个单核的处理器可以形象得比喻成一条单车道，车辆依次行驶在这条单车道上，前车驶过之后后车才可以行驶。&lt;br/&gt;如果前面没有车辆，那么你顺利通过；如果车辆众多，那么你需要等待前车通过之后才可以通过。

因此，需要些特定的代号表示目前的车流情况，例如：
    ·等于&lt;/span&gt;&lt;span&gt;0.00，&lt;/span&gt;表示目前桥面上没有任何的车流。实际上这种情况&lt;span&gt;0.00&lt;/span&gt;和&lt;span&gt;1.00&lt;/span&gt;&lt;span&gt;之间是相同的，总而言之很通畅，过往的车辆可以丝毫不用等待的通过
    ·等于&lt;/span&gt;&lt;span&gt;1.00，&lt;/span&gt;&lt;span&gt;表示刚好是在这座桥的承受范围内。这种情况不算糟糕，只是车流会有些堵，不过这种情况可能会造成交通越来越慢
    ·大于&lt;/span&gt;&lt;span&gt;1.00&lt;/span&gt;，那么说明这座桥已经超出负荷，交通严重的拥堵。那么情况有多糟糕? 例如&lt;span&gt;2.00&lt;/span&gt;的情况说明车流已经超出了桥所能承受的一倍，那么将有多余过桥一倍的车辆正在焦急的等待&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;但是比喻终归是比喻，从比喻中我们了解了，load表示的是系统的一个能力，但是我们却不知道什么样的任务会被归到load的计算中。关于具体怎么样的任务会被归到load的计算中，可以使用man uptime命令看一下Linux对于load的解释：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/801753/201906/801753-20190619211749529-532378503.png&quot; alt=&quot;&quot; width=&quot;625&quot; height=&quot;283&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大致意思就是说，系统load是处于运行状态或者不可中断状态的进程的平均数（标红部分表示被算入load的内容）。一个处于运行状态的进程表示&lt;span&gt;&lt;strong&gt;正在使用cpu或者等待使用cpu&lt;/strong&gt;&lt;/span&gt;，一个不可中断状态的进程表示&lt;span&gt;&lt;strong&gt;正在等待IO&lt;/strong&gt;&lt;/span&gt;，例如磁盘IO。load的平均值通过3个时间间隔来展示，就是我们看到的1分钟、5分钟、15分钟，load值和cpu核数有关，单核cpu的load=1表示系统一直处在负载状态，但是4核cpu的load=1表示系统有75%的空闲。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;特别注意，&lt;span&gt;&lt;strong&gt;load指的是所有核的平均值&lt;/strong&gt;&lt;/span&gt;，这和cpu的值是有区别的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还有一个重要的点是，查了资料发现，虽然上面一直强调的是&quot;进程&quot;，但是&lt;span&gt;&lt;strong&gt;进程中的线程数也是会被当作不同的进程来计算的&lt;/strong&gt;&lt;/span&gt;，假如一个进程产生1000个线程同时运行，那运行队列的长度就是1000，load average就是1000。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;请求数和load的关系&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之前我自己一直有个误区：当成千上万的请求过来，且在排队的时候，后面的请求得不到处理，load值必然会升高。认真思考之后，这个观点可真是大错特错，因此特别作为一段写一下和大家分享。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以Redis为例，我们都知道Redis是单线程模型的，这意味着同一时间可以有无数个请求过来，但是同一时间只有一个命令会被处理（图片来源&lt;a href=&quot;https://www.processon.com/view/5c2ddab0e4b0fa03ce89d14f&quot;&gt;https://www.processon.com/view/5c2ddab0e4b0fa03ce89d14f&lt;/a&gt;）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/801753/201909/801753-20190928171602787-1715103501.png&quot; alt=&quot;&quot; width=&quot;988&quot; height=&quot;288&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;单独的一条线程接到就绪的命令之后，会将命令转给事件分发器，事件分发器根据命令的类型执行对应的命令处理逻辑。由于只有一条线程，只要后面排队的命令足够多到让这条线程一个接一个不停地处理命令，那么load表现就等于1。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;整个过程中，回看load这个值，它和请求数没有任何关系，真正和load相关的是&lt;span&gt;&lt;strong&gt;工作线程&lt;/strong&gt;&lt;/span&gt;数量，main线程是工作线程、Timer是工作线程、GC线程也是工作线程，&lt;/span&gt;&lt;span&gt;load是以&lt;span&gt;&lt;strong&gt;线程/进程&lt;/strong&gt;&lt;/span&gt;作为统计指标，无论请求数是多少，最终都需要线程去处理，而工作线程的处理性能直接决定了最终的load值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;举个例子，假设一个服务中有一个线程池，线程池中线程数量固定为64：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;正常来说一个任务执行时间为10ms，线程拿到任务10ms处理完，很快回归线程池等待下一个任务到来，自然很少有处于运行状态或者等待IO的线程，从一个统计周期来看load表现为很低&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;某段时间由于系统问题，一个任务10s都处理不完，相当于线程一直在处理任务，在load的统计周期里面就体现出的值=64（不考虑这64条线程外的场景）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;因此，总而言之，搞清楚load值和请求数、线程数的关系非常重要，想清楚这些才能正确地进行下一步的工作。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;load高、cpu高的问题排查思路&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先抛出一个观点：&lt;span&gt;&lt;strong&gt;cpu高不是问题，由cpu高引起的load高才是问题，load是判断系统能力指标的依据&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为什么这么说呢，以单核cpu为例，当我们日常cpu在20%、30%的时候其实对cpu资源是浪费的，这意味着绝大多数时候cpu并没有在做事，理论上来说一个系统极限cpu利用率可以达到100%，这意味着cpu完全被利用起来了处理计算密集型任务，例如for循环、md5加密、new对象等等。但是实际不可能出现这种情况，因为应用程序中不消耗cpu的IO不存在是几乎不可能的，例如读取数据库或者读取文件，因此cpu不是越高越好，通常75%是一个需要引起警戒的经验值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意前面提到的是&quot;引起警戒&quot;，意味着cpu高不一定是问题，但是需要去看一下，尤其是日常的时候，因为通常日常流量不大，cpu是不可能打到这么高的。如果只是普通的代码中确实在处理正常业务那没问题，如果代码里面出现了死循环（例如JDK1.7中经典的HashMap扩容引发的死循环问题），那么几条线程一直占着cpu，最后就会造成load的增高。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在一个Java应用中，排查cpu高的思路通常比较简单，有比较固定的做法：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;ps -ef | grep java，查询Java应用的进程pid&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;top -H -p pid，查询占用cpu最高的线程pid&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将10进制的线程pid转成16进制的线程pid，例如2000=0x7d0&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;jstack 进程pid | grep -A 20 '0x7d0'，查找nid匹配的线程，查看堆栈，定位引起高cpu的原因&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;网上有很多文章写到这里就停了，实践过程中并不是这样。因为cpu是时间段内的统计值、jstack是一个瞬时堆栈只记录瞬时状态，两个根本不是一个维度的事，因此完全有可能从打印出来的堆栈行号中看到代码停留在以下地方：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;不消耗cpu的网络IO&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;for (int i = 0, size = list.size(); i &amp;lt; size; i++) {...}&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;调用native方法&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;如果完全按照上面那一套步骤做的话碰到这种情况就傻眼了，冥思苦想半天却不得其解，根本不明白为什么这种代码会导致高cpu。针对可能出现的这种情况，实际排查问题的时候&lt;span&gt;&lt;strong&gt;jstack建议打印5次至少3次&lt;/strong&gt;&lt;/span&gt;，根据多次的堆栈内容，再结合相关&lt;span&gt;&lt;strong&gt;代码段&lt;/strong&gt;&lt;/span&gt;进行分析，定位高cpu出现的原因，&lt;span&gt;&lt;strong&gt;高cpu可能是代码段中某个bug导致的而不是堆栈打印出来的那几行导致的&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外，cpu高的情况还有一种可能的原因，假如一个4核cpu的服务器我们看到总的cpu达到了100%+，按1之后观察每个cpu的us，只有一个达到了90%+，其他都在1%左右（下图只是演示top按1之后的效果并非真实场景）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/801753/201909/801753-20190927164622638-1328093925.png&quot; alt=&quot;&quot; width=&quot;638&quot; height=&quot;107&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种情况下可以重点考虑是不是频繁FullGC引起的。因为我们知道FullGC的时候会有Stop The World这个动作，多核cpu的服务器，除了GC线程外，在Stop The World的时候都是会挂起的，直到Stop The World结束。以几种老年代垃圾收集器为例：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;Serial Old收集器，全程Stop The World&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Parallel Old收集器，全程Stop The World&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;CMS收集器，它在初始标记与并发标记两个过程中，为了准确标记出需要回收的对象，都会Stop The World，但是相比前两种大大减少了系统停顿时间&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;无论如何，当真正发生Stop The World的时候，就会出现GC线程在占用cpu工作而其他线程挂起的情况，自然表现也就为某个cpu的us很高而且他cpu的us很低。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;针对FullGC的问题，排查思路通常为：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;ps -ef | grep java，查询Java应用的进程pid&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;jstat -gcutil pid 1000 1000，每隔1秒打印一次内存情况共打印1000次，观察老年代（O）、MetaSpace（MU）的内存使用率与FullGC次数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;确认有频繁的FullGC的发生，查看GC日志，每个应用GC日志配置的路径不同&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;jmap -dump:format=b,file=filename pid，保留现场&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;重启应用，迅速止血，避免引起更大的线上问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;dump出来的内容，结合MAT分析工具分析内存情况，排查FullGC出现的原因&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;如果FullGC只是发生在老年代区，比较有经验的开发人员还是容易发现问题的，一般都是一些代码bug引起的。MetaSpace发生的FullGC经常会是一些诡异、隐晦的问题，很多和引入的第三方框架使用不当有关或者就是第三方框架有bug导致的，排查起来就很费时间。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;那么频繁FullGC之后最终会导致load如何变化呢？这个我没有验证过和看过具体数据，只是通过理论分析，如果所有线程都是空闲的，只有GC线程在一直做FullGC，那么load最后会趋近于1。但是实际不可能，因为如果没有其他线程在运行，怎么可能导致频繁FullGC呢。所以，在其他线程处理任务的情况下Stop The World之后，cpu挂起，任务得不到处理，更大可能的是load会一直升高。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;最后顺便提一句，前面一直在讲FullGC，频繁的YoungGC也是会导致load升高的，之前看到过的一个案例是，Object转xml，xml转Object，代码中每处都new XStream()去进行xml序列化与反序列化，回收速度跟不上new的速度，YoungGC次数陡增。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;load高、cpu低的问题排查思路&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于load的部分，我们可以看到会导致load高的几个因素：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;线程正在使用cpu&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;线程正在等待使用cpu&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;线程在执行不可被打断的IO操作&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;既然cpu不高，load高，那么线程要么在进行io要么在等待使用cpu。不过对于后者&quot;等待使用cpu&quot;我这里存疑，比如线程池里面10个线程，任务来的很慢，每次只会用到1个线程，那么9个线程都是在等待使用cpu，但是这9个线程明显是不会占据系统资源的，因此我认为自然也不会消耗cpu，所以这个点不考虑。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因此，在cpu不高的情况下假如load高，大概率io高才是罪魁祸首，它导致的是任务一直在跑，迟迟处理不完，线程无法回归线程池中。首先简单讲讲磁盘io，既然wa表示的是磁盘io等待cpu的百分比，那么我们可以看下wa确认下是不是磁盘io导致的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/801753/201909/801753-20190928195211804-982283736.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果是，那么按照cpu高同样的方式打印一下堆栈，查看文件io的部分进行分析，排查原因，例如是不是多线程都在读取本地一个超大的文件到内存。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;磁盘io导致的load高，我相信这毕竟是少数，因为Java语言的特点，应用程序更多的高io应当是在处理网络请求，例如：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;从数据库中获取数据&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;从Redis中获取数据&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;调用Http接口从支付宝获取数据&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;通过dubbo获取某服务中的数据&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;针对这种情况，我觉得首先我们应该对整个系统架构的依赖比较熟悉，例如我画一个草图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/801753/201909/801753-20190928200147480-66116604.png&quot; alt=&quot;&quot; width=&quot;681&quot; height=&quot;218&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对依赖方的调用任何一个出现比较高的耗时都会增加自身系统的load，出现load高的建议排查方式为：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;查日志，无论是HBase、MySql、Redis调用还是通过http、dubbo调用接口，调用超时，拿连接池中的连接超时，通常都会有错误日志抛出来，只要系统里面没有捕获异常之后不打日志直接吞掉一般都能查到相关的异常&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对于dubbo、http的调用，建议做好监控埋点，输出接口名、方法入参（控制大小）、是否成功、调用时长等必要参数，有些时候可能没有超时，但是调用2秒、3秒一样会导致load升高，所以这种时候需要查看方法调用时长进行下一步动作&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如果上面的步骤还是没用或者没有对接口调用做埋点，那么还是万能的打印堆栈吧，连续打印五次十次，看一下每次的堆栈是否大多都指向同一个接口的调用，网络io的话，堆栈的最后几行一般都有&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;number&quot;&gt;&lt;span class=&quot;number&quot;&gt;&lt;span class=&quot;number&quot;&gt;&lt;span class=&quot;number&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;variable&quot;&gt;at java&lt;span class=&quot;variable&quot;&gt;.net&lt;span class=&quot;variable&quot;&gt;.SocketInputStream&lt;span class=&quot;variable&quot;&gt;.read(SocketInputStream&lt;span class=&quot;variable&quot;&gt;.java:&lt;span class=&quot;number&quot;&gt;129)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;Java应用load高的几种原因总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前面说了这么多，这里总结一下load高可能的一些原因：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;死循环或者不合理的大量循环操作，如果不是循环操作，按照现代cpu的处理速度来说处理一大段代码也就一会会儿的事，基本对能力无消耗&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;频繁的YoungGC&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;频繁的FullGC&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;高磁盘IO&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;高网络IO&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;系统load高通常都是由于某段发布的代码有bug或者引入某些第三方jar而又使用不合理导致的，因此注意首先区分load高，是由于cpu高导致的还是io高导致的，根据不同的场景采取不同定位问题的方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当束手无策时，jstack打印堆栈多分析分析吧，或许能灵光一现能找到错误原因。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;结语&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先有理论，把理论想透了，实战碰到问题的时候才能头脑清楚。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;坦白讲，cpu和load高排查是一个很偏实战的事情，这方面我还也有很长一条路需要走，身边在这块经验比我丰富的同事多得很。很多人有问过我，项目比较简单，根本没有这种线上问题需要我去排查怎么办？这个问题只能说，平时多积累、多实战是唯一途径，假如没有实战机会，那么推荐三种方式：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;自己通过代码模拟各种异常，例如FullGC、死锁、死循环，然后利用工具去查，可能比较简单，但是万丈高楼平地起，再复杂的东西都是由简单的变化过来的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;多上服务器上敲敲top、sar、iostat这些命令，熟记每个命令的作用及输出参数的含义&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;去网上找一下其他人处理FullGC、cpu高方法的文章，站在巨人的肩膀上，看看前人走过的路，总结记录一些实用的点&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;当真的有实战机会来的时候把握住，即使是同事排查的问题，也可以在事后搞清楚问题的来龙去脉，久而久之自然这方面的能力就会提高上去。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 28 Sep 2019 13:58:00 +0000</pubDate>
<dc:creator>五月的仓颉</dc:creator>
<og:description>前言 2019双11还有不到2个月就要到来了，大家也都知道服务器在大促期间由于流量的增加势必导致机器的cpu与load变高。因此趁着这个时机正好再好好学习、巩固一下cpu和load的概念，为双11做准</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xrq730/p/11041741.html</dc:identifier>
</item>
<item>
<title>Unity项目 - DeathtrapDungeon死亡地牢 - SouthBegonia</title>
<link>http://www.cnblogs.com/SouthBegonia/p/11604918.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SouthBegonia/p/11604918.html</guid>
<description>&lt;p&gt;&lt;strong&gt;死亡地牢&lt;/strong&gt;是一款 &lt;strong&gt;2D-Roguelike&lt;/strong&gt; 的地牢冒险游戏。手握利刃，斩杀怪物，在凶险的地牢内生存下去。但注意，敌人也并非善茬，保持警惕，取舍果断，足智多谋才是制胜的关键。&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/SouthBegonia/DeathtrapDungeon&quot;&gt;DeathtrapDungeon - SouthBegonia&lt;/a&gt;&lt;br/&gt;试玩下载：&lt;a href=&quot;https://pan.baidu.com/s/1YhGINK1zqLKmD6bp1C29tA&quot;&gt;DeathtrapDounge 提取码:wekp&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1688704/201909/1688704-20190928211533251-195674383.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1688704/201909/1688704-20190928211548635-1758543195.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1688704/201909/1688704-20190928211742134-5588213.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1688704/201909/1688704-20190928211618431-173180102.gif&quot;/&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;总控系统：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;GameManager.cs：单例模式，统一管理各类的实例，及游戏数据(经验，金币，各类Sprite)，升级系统，UI管理，场景管理，存读档机制等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;生命值系统：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Fighter.cs：生命值，最大生命值，击退系数；伤害系统&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Player&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Player.cs：Rage怒气系统；换皮肤，死亡重生等&lt;/li&gt;
&lt;li&gt;Mover.cs：移动系统&lt;/li&gt;
&lt;li&gt;Weapon：武器攻击系统，Rage技能系统&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Enemy&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Enemy.cs：大部分敌人的类，包含经验值，追逐攻击系统，死亡复活系统等&lt;/li&gt;
&lt;li&gt;Enemy_Chest.cs：宝箱怪&lt;/li&gt;
&lt;li&gt;Trap.cs：陷阱&lt;/li&gt;
&lt;li&gt;Boss0.cs：最终boss&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;GUI&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FloatingTextManager/FloatingText.cs：浮动文本显示系统&lt;/li&gt;
&lt;li&gt;CharacterMenu.cs：菜单栏系统&lt;/li&gt;
&lt;li&gt;CharacterHUD.cs：玩家生命值，经验值，怒气值显示，死亡页面&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;场景&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CameraFollow.cs：相机跟随系统&lt;/li&gt;
&lt;li&gt;Portal.cs：不同场景传送门&lt;/li&gt;
&lt;li&gt;Portal_Door.cs：当前场景传送门&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;交互物件&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;NPCTextPerson.cs：NPC交互&lt;/li&gt;
&lt;li&gt;Chest.cs：宝箱&lt;/li&gt;
&lt;li&gt;Crate.cs：可破坏物件&lt;/li&gt;
&lt;li&gt;HealingFountain：治愈泉水&lt;/li&gt;
&lt;li&gt;Door.cs：开关门&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;p&gt;游戏的核心机制，如战斗，场景切换，物体交互等&lt;strong&gt;已成型&lt;/strong&gt;，且Tilemap完善(地面层，上下墙壁层，地表物件层，碰撞层)，除了基本的静态Tiles外，还有几个AnimatedTile(泉水，熔岩等)，及ChestBrush宝箱笔刷方便宝箱的摆放设置等等。如想要自行&lt;strong&gt;定制关卡&lt;/strong&gt;，完全可以基于此脚本系统下，对Tilemap的重绘、游戏数值、场景物件摆放、NPC台词等即可。&lt;/p&gt;
&lt;p&gt;此外，&lt;a href=&quot;https://itch.io/game-assets&quot;&gt;itch.io&lt;/a&gt;网站内含有大量优秀的2D绘图资源，可按需合法使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1688704/201909/1688704-20190928211702664-1369000020.gif&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;关于武器挥动进行攻击的animation&lt;/strong&gt;：
&lt;ol&gt;&lt;li&gt;武器的Swing动画时间建议大于0.3s，否则间隔过短即便每次都能攻击到敌人但不足以有效推开敌人而被攻击&lt;/li&gt;
&lt;li&gt;武器劈砍至水平的时间建议在前半时间内完成，因为涉及武器的碰撞伤害；水平下的武器碰撞器范围较长,利于和敌人保持距离,并造成伤害&lt;/li&gt;
&lt;li&gt;最好模拟真实情况下的劈砍动作,我将其分为以下几部分:
&lt;ul&gt;&lt;li&gt;p1:武器抬起并后仰，此过程速度适中，禁用collider&lt;/li&gt;
&lt;li&gt;p2:从90'到0'进行主劈砍动作.此过程前半速度快,后半速度极快，启用collider&lt;/li&gt;
&lt;li&gt;p3:0'到-20'最终劈砍动作.此过程不在于速度,而在于保持帧数(时间)&lt;/li&gt;
&lt;li&gt;p4:武器收回，速度快，禁用Collider&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1688704/201909/1688704-20190928211647918-820959590.gif&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Tilemap的绘制&lt;/strong&gt;：
&lt;ol&gt;&lt;li&gt;最好在确定美术资源时即确定整体绘制的像素信息，场景风格等，假若后期要添加其他要素，风格不同很不应景&lt;/li&gt;
&lt;li&gt;Tile的类型最好也确定，使用普通tile+animation物体，或是RuleTile实现各类功能&lt;/li&gt;
&lt;li&gt;瓦片的渲染顺序体现在Tilemap的顺序(例如上墙wall层，下墙壁ScreenWall层；上层可被player遮挡，下层可遮挡player)&lt;/li&gt;
&lt;li&gt;非瓦片物体的渲染顺序体现在SpriteRenderer里的SortingLayer和OrderLayer；合理设置遮挡与被遮挡关系&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2D碰撞问题&lt;/strong&gt;：
&lt;ul&gt;&lt;li&gt;所有物体最好处于同一z=0平面，否则一些碰撞检测容易出问题&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
</description>
<pubDate>Sat, 28 Sep 2019 13:21:00 +0000</pubDate>
<dc:creator>SouthBegonia</dc:creator>
<og:description>目录 '游戏原型' '项目演示' '绘图资源' '代码实现' '注意事项' '技术探讨' '参考来源' 游戏原型 死亡地牢 是一款 2D Roguelike 的地牢冒险游戏。手握利刃，斩杀怪物，在凶险</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/SouthBegonia/p/11604918.html</dc:identifier>
</item>
</channel>
</rss>