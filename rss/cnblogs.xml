<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>快速搞懂.NET 5/.NET Core应用程序的发布部署 - Eric zhou</title>
<link>http://www.cnblogs.com/tianqing/p/14403255.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tianqing/p/14403255.html</guid>
<description>&lt;p&gt;.NET Framework时代，.NET 应用程序大多直接部署运行在Windows服务器上，当然也可以通过Mono部署运行在Linux上。无论部署exe，还是IIS站点、或是Windows Service，编译后的程序直接copy、简单配置部署上即可。&lt;/p&gt;
&lt;p&gt;有了.NET Core之后，.NET应用程序完美支持跨平台部署，.NET 5 Release后，沿袭了.NET Core应用程序发布模式。&lt;/p&gt;
&lt;p&gt;支持跨平台部署运行，.NET 5/.NET Core的应用程序面临着多平台，多场景的部署需求。比如说：部署在Windows、Linux、MaxOS...，OS层面是否需要部署.NET Runtime运行时，.NET Runtime运行时的版本选择，等等。&lt;/p&gt;
&lt;p&gt;因此，今天我们研究一下.NET 5/.NET Core应用程序的部署发布。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、两种应用程序发布模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;  1. 以&lt;span&gt;自包含&lt;/span&gt;的方式发布应用程序&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      这种模式包含.NET运行时和应用程序及其依赖项的应用程序。我们可以在未安装.NET运行时的操作系统上运行它。&lt;/p&gt;
&lt;p&gt;      总结一句话：把.NET Runtime运行时打包到程序运行目录中，应用程序运行的主机不需要安装.NET Runtime运行时。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;  2. 以&lt;span&gt;依赖于框架&lt;/span&gt;的方式发布应用程序&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      生成一个仅包含应用程序本身及其依赖项的应用程序。应用程序的运行环境必须单独安装.NET运行时。&lt;/p&gt;
&lt;p&gt;      总结一句话：不包含.NET Runtime运行时，只有应用程序本身和依赖的应用程序。应用程序运行的主机需要单独安装应用程序所需的.NET Runtime运行时。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、NET 5/.NET Core的应用程序的发布指令：&lt;span&gt;dotnet publish&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  dotnet publish -将应用程序及其依赖项发布到指定的文件夹中，以方便后续部署到目标托管系统。&lt;/p&gt;
&lt;p&gt;  关于dotnet publish的使用说明，可以参考以下链接：&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-publish?WT.mc_id=DT-MVP-5003918&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-publish?WT.mc_id=DT-MVP-5003918&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
dotnet publish [&amp;lt;PROJECT&amp;gt;|&amp;lt;SOLUTION&amp;gt;] [-c|--configuration &amp;lt;CONFIGURATION&amp;gt;&lt;span&gt;]
    [&lt;/span&gt;-f|--framework &amp;lt;FRAMEWORK&amp;gt;] [--force] [--&lt;span&gt;interactive]
    [&lt;/span&gt;--manifest &amp;lt;PATH_TO_MANIFEST_FILE&amp;gt;] [--no-build] [--no-&lt;span&gt;dependencies]
    [&lt;/span&gt;--no-restore] [--nologo] [-o|--output &amp;lt;OUTPUT_DIRECTORY&amp;gt;&lt;span&gt;]
    [&lt;/span&gt;-p:PublishReadyToRun=&lt;span&gt;true&lt;/span&gt;] [-p:PublishSingleFile=&lt;span&gt;true&lt;/span&gt;] [-p:PublishTrimmed=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;]
   &lt;span&gt; [&lt;/span&gt;&lt;/span&gt;&lt;span&gt;-r|--runtime &amp;lt;RUNTIME_IDENTIFIER&amp;gt;] [--self-contained [true|false&lt;/span&gt;&lt;span&gt;&lt;span&gt;]]&lt;/span&gt;
    [&lt;/span&gt;--no-self-contained] [-v|--verbosity &amp;lt;LEVEL&amp;gt;&lt;span&gt;]
    [&lt;/span&gt;--version-suffix &amp;lt;VERSION_SUFFIX&amp;gt;&lt;span&gt;]

dotnet publish &lt;/span&gt;-h|--help
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   dotnet publish 将编译应用程序，读取其在项目文件中指定的依赖项，然后将结果文件集发布到目录中。输出包括&lt;strong&gt;以下内容&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;具有dll扩展名的程序集中的中间语言（IL）代码。&lt;/li&gt;
&lt;li&gt;一个.deps.json文件，其中包含项目的&lt;strong&gt;所有依赖项&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;一个.runtimeconfig.json文件，它指定应用程序期望的共享运行时，以及该运行时的其他配置选项（例如，垃圾收集类型）。&lt;/li&gt;
&lt;li&gt;应用程序依赖的应用程序，从NuGet缓存目录复制到输出文件夹中。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    从上述描述中，我们可以发现，通过dotnet publish指令，我们可以编译应用程序，生成并输出指定运行环境的交付物。&lt;/p&gt;
&lt;p&gt;    我们新建一个.NET 5的Console应用程序，同时引用Newtonsoft.Json Nuget包。&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://img2020.cnblogs.com/blog/23525/202102/23525-20210215100258536-931010907.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    Main函数的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; NET5PublishExample
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; msg = Newtonsoft.Json.JsonConvert.SerializeObject(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello .NET 5!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(msg);
            Console.ReadKey();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  首先，&lt;strong&gt;编译一下这个工程dotnet build，这一步很重要&lt;/strong&gt;。然后，使用命令行执行dotnet publish指令：&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://img2020.cnblogs.com/blog/23525/202102/23525-20210215100416528-1452400556.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   我们看一下F:\GitHub\Source\Repos\NET5PublishExample\bin\Debug\net5.0\publish\目录下生成的文件：&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://img2020.cnblogs.com/blog/23525/202102/23525-20210215100542635-1095656403.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    正如上面所说，输出包括&lt;strong&gt;以下内容&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;具有dll扩展名的程序集中的中间语言（IL）代码：&lt;span&gt;&lt;strong&gt;NET5PublishExample.dll&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;一个.deps.json文件，其中包含项目的&lt;strong&gt;所有依赖项&lt;/strong&gt;。&lt;span&gt;&lt;strong&gt;NET5PublishExample.deps.json&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;一个.runtimeconfig.json文件，它指定应用程序期望的共享运行时，以及该运行时的其他配置选项（例如，垃圾收集类型）。&lt;span&gt;&lt;strong&gt;NET5PublishExample.runtimeconfig.json&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;应用程序依赖的应用程序，从NuGet缓存目录复制到输出文件夹中。&lt;span&gt;&lt;strong&gt;Newtonsoft.Json.dll&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;     同时，还生成了一个Windows平台的可执行文件：NET5PublishExample.exe，双击可以执行：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     &lt;img src=&quot;https://img2020.cnblogs.com/blog/23525/202102/23525-20210215101502295-1647363979.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     另外，使用dotnet NET5PublishExample.dll，也可以直接执行：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     &lt;img src=&quot;https://img2020.cnblogs.com/blog/23525/202102/23525-20210215101651583-77752588.jpg&quot; alt=&quot;&quot; width=&quot;871&quot; height=&quot;196&quot; loading=&quot;lazy&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     然后有几个疑问：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     NET5PublishExample.dll是不是可以跨平台运行？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     在Linux、MacOS平台下有没有对应的可执行文件？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     带着这2个问题，我们继续往下研究？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、dotnet publish生成的可执行文件和跨平台二进制文件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     自包含的方式发布应用程序，依赖于框架的方式发布应用程序。这两种发布模式默认情况下都会生成特定于平台的可执行文件和跨平台二进制文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     &lt;span&gt;&lt;strong&gt;1. 可执行文件&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     可执行文件不是跨平台的。它们特定于操作系统和CPU体系结构。因为Windows和linux下的可执行文件的结构和内容是不同的，所以可执行文件是分操作系统的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     创建可执行文件时，同时可以选择将应用程序发布为自包含或依赖于框架。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     以自包含的方式发布应用程序包括该应用程序的.NET运行时，并且该应用程序的用户不必担心在运行该应用程序之前安装.NET。可以直接执行！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     发布为与框架相关的应用程序不包括.NET运行时和库。仅包括应用程序和第三方依赖项。需要安装.NET 运行时。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     这里我们示例2个平台的可执行文件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     &lt;strong&gt;① windows-x64平台&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     &lt;img src=&quot;https://img2020.cnblogs.com/blog/23525/202102/23525-20210215102930042-733051941.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      &lt;strong&gt;② Linux-x64平台&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       使用的dotnet publish指令 &lt;strong&gt;dotnet publish -r linux-x64 --self-contained false&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       &lt;img src=&quot;https://img2020.cnblogs.com/blog/23525/202102/23525-20210215103352126-2061405546.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       生成的可执行文件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       &lt;img src=&quot;https://img2020.cnblogs.com/blog/23525/202102/23525-20210215103358665-716887890.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     &lt;span&gt;&lt;strong&gt;2. &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;跨平台的二进制文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     将应用程序发布为依赖于框架的dll文件形式时，就会&lt;strong&gt;创建跨平台的二进制文件&lt;/strong&gt;。该dll文件以项目命名。例如，如果您有一个名为应用程序NET5PublishExample，文件名为NET5PublishExample.dll创建。&lt;/p&gt;
&lt;p&gt;     以这种方式发布的应用程序dotnet &amp;lt;filename.dll&amp;gt;可以通过命令运行，&lt;span&gt;&lt;strong&gt;可以在任何平台上运行。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、关于自包含的发布选项&lt;/strong&gt;和示例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    以自包含的方式发布应用会生成&lt;strong&gt;特定于平台的可执行文件&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;    输出发布文件夹包含应用程序的所有组件，&lt;strong&gt;包括.NET库和目标运行时&lt;/strong&gt;。该应用程序与其他.NET应用程序隔离，并且&lt;strong&gt;不使用本地安装的.NET运行时&lt;/strong&gt;。因此无需下载并安装.NET 运行时。&lt;/p&gt;
&lt;p&gt;    可执行二进制文件针对指定的目标平台生成。例如，如果您有一个名为NET5PublishExample的应用程序，并且发布了Windows的自包含可执行文件，则会创建NET5PublishExample.exe文件。对于Linux或macOS发布，将创建一个NET5PublishExample文件。目标平台和体系结构-r &amp;lt;RID&amp;gt;由dotnet publish命令的参数指定。有关RID的更多信息，请参见&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/core/rid-catalog?WT.mc_id=DT-MVP-5003918&quot; target=&quot;_blank&quot;&gt;.NET RID目录&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;    如果应用程序具有特定于平台的依赖项，例如包含特定于平台的依赖项的NuGet程序包，则这些依赖项将与应用程序一起复制到publish文件夹中。&lt;/p&gt;
&lt;p&gt;    这种模式的优势有哪些呢？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;    &lt;strong&gt;控制.NET版本：&lt;/strong&gt;可以控制与应用程序一起部署的.NET版本。&lt;/li&gt;
&lt;li&gt;    &lt;strong&gt;指定运行的平台：&lt;/strong&gt;因为必须为每个平台发布应用程序，所以我们需要确定应用程序将在何处运行。如果.NET引入了新平台，则必须先发布针对该平台的版本，然后才能在该平台上运行您的应用程序。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;    同时也带来了以下问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;    &lt;strong&gt;更大的部署内容：&lt;/strong&gt;应用程序包括.NET运行时和所有应用程序依赖项，所以所需的下载大小和硬盘空间大于依赖于框架的版本。&lt;/li&gt;
&lt;li&gt;    &lt;strong&gt;难以更新.NET版本.NET Runtime：&lt;/strong&gt;（随应用程序分发）只能通过发布新版本的应用程序进行升级。但是，.NET将根据应用程序运行的计算机上框架库的需要更新关键的安全补丁。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;    例如：&lt;/p&gt;
&lt;p&gt;    示例1：发布一个独立的应用程序，创建macOS 64位可执行文件，同时包含了.NET 运行时&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dotnet publish -r osx-x64
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    生成的文件列表如下：包含macOS 64可执行文件NET5PublishExample，以及包含了对应macOS 64平台下的.NET 运行时&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://img2020.cnblogs.com/blog/23525/202102/23525-20210215164137156-1687454182.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      示例2：发布一个独立的应用程序，创建Windows 64位可执行文件，同时包含了.NET 运行时&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 dotnet publish -r win-x64
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    生成的文件列表如下：包含Windows 64可执行文件NET5PublishExample.exe，以及包含了对应Windows 64平台下的.NET 运行时&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://img2020.cnblogs.com/blog/23525/202102/23525-20210215164525305-1976389519.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;    &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、关于依赖框架的发布选项和示例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;  &lt;/strong&gt;&lt;/span&gt;发布为依赖框架的应用程序是&lt;strong&gt;跨平台的&lt;/strong&gt;，并且&lt;strong&gt;不包含&lt;/strong&gt;.NET运行时。应用程序的运行&lt;strong&gt;需要单独安装指定版本的.NET运行时&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;  应用程序的跨平台二进制文件可以使用dotnet &amp;lt;filename.dll&amp;gt;命令运行，并且可以在任何平台上运行。如果应用程序使用具有特定于平台的实现的NuGet包，则所有平台的依赖项都将与应用程序一起复制到publish文件夹中。&lt;/p&gt;
&lt;p&gt;  可以通过将-r &amp;lt;RID&amp;gt; --self-contained false参数传递给dotnet publish命令来为特定平台创建可执行文件。当-r参数被省略，为当前平台创建一个可执行文件。具有目标平台特定于平台的依赖关系的任何NuGet软件包都将复制到publish文件夹中。&lt;/p&gt;
&lt;p&gt;  这种模式带来的优势有：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;  &lt;strong&gt;小型部署：&lt;/strong&gt;仅分发应用程序及其依赖项。.NET运行时和库由用户安装，所有应用共享运行时。&lt;/li&gt;
&lt;li&gt;  &lt;strong&gt;跨平台：&lt;/strong&gt;应用程序和任何基于.NET的库都可以在其他操作系统上运行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;  使用最新的.NET运行时：&lt;/strong&gt;该应用程序使用目标系统上安装的最新运行时（在.NET的目标主要，次要家族中）。这意味着应用程序会自动使用最新的.NET运行时修补版本。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;   同时也带来了以下问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;   &lt;strong&gt;需要预安装.NET 运行时&lt;/strong&gt;：仅在主机系统上已安装应用目标的.NET运行时版本时，应用才能运行。&lt;/li&gt;
&lt;li&gt;   &lt;strong&gt;.NET可能会更改：&lt;/strong&gt;.NET运行时和库可能会在运行该应用程序的计算机上更新。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;   例如：&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;示例1：&lt;/strong&gt;发布一个当前平台的依赖框架的跨平台应用程序，不包含.NET 运行时，将与dll文件一起创建一个针对当前平台的可执行文件。   &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
dotnet publish
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   &lt;img src=&quot;https://img2020.cnblogs.com/blog/23525/202102/23525-20210215165845550-173052874.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   使用dotnet NET5PublishExample.dll，可以直接运行（本机已经安装.NET运行时，&lt;strong&gt;NET5PublishExample.dll是跨平台的二进制文件&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt; 示例2：&lt;/strong&gt;发布一个依赖框架的跨平台应用程序（Linux 64位），不包含.NET 运行时，将创建一个Linux 64位可执行文件以及dll文件。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dotnet publish -r linux-x64 --self-contained &lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/23525/202102/23525-20210215170312595-921260958.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      使用&lt;strong&gt;dotnet NET5PublishExample.dll&lt;/strong&gt;，可以直接运行（本机已经安装.NET运行时，&lt;strong&gt;NET5PublishExample.dll是跨平台的二进制文件&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2020.cnblogs.com/blog/23525/202102/23525-20210215170447038-2015892566.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;strong&gt;六、ReadyToRun编译选项&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   通过将应用程序程序集编译为ReadyToRun（R2R）格式，可以&lt;strong&gt;改善.NET应用程序的启动时间和延迟&lt;/strong&gt;。R2R是一种&lt;strong&gt;提前（AOT）编译&lt;/strong&gt;的形式。&lt;/p&gt;
&lt;p&gt;   R2R二进制文件通过减少应用程序加载时即时（JIT）编译器需要完成的工作量来提高启动性能。与JIT产生的代码相比，&lt;span&gt;&lt;strong&gt;&lt;em&gt;二进制文件包含相似的本机代码&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;   但是，R2R二进制文件较大，因为它们既包含中间语言（IL）代码（某些情况下仍然需要此代码）和同一代码的本机版本。仅当发布针对特定运行时环境（RID）（例如Linux x64或Windows x64）的应用程序时，R2R才可用。&lt;/p&gt;
&lt;p&gt;   总结一下：&lt;strong&gt;&lt;span&gt;通过R2R方式，可以直接将代码编译为Native Code，减少.NET 程序第一次加载时JIT编译带来的性能消耗，以提升.NET应用的首次加载性能。&lt;/span&gt;&lt;/strong&gt;类似于ngen的程序集预加载。&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/framework/tools/ngen-exe-native-image-generator?WT.mc_id=DT-MVP-5003918&quot; target=&quot;_blank&quot;&gt;关于Ngen可以参考这个链接：ngen&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;   对应的dotnet publish指令选项：   dotnet publish -c Release -r win-x64 -p:PublishReadyToRun=true&lt;/p&gt;

&lt;p&gt;   以上是.NET 5/.NET Core应用程序的发布部署的一些研究和分享。&lt;/p&gt;
&lt;p&gt;   推荐一个不错的知识链接：&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/core/deploying/#publish-framework-dependent?WT.mc_id=DT-MVP-5003918&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/dotnet/core/deploying/#publish-framework-dependent?WT.mc_id=DT-MVP-5003918&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;周国庆&lt;/p&gt;
&lt;p&gt;2020/2/15&lt;/p&gt;
</description>
<pubDate>Tue, 16 Feb 2021 00:01:00 +0000</pubDate>
<dc:creator>Eric zhou</dc:creator>
<og:description>.NET Framework时代，.NET 应用程序大多直接部署运行在Windows服务器上，当然也可以通过Mono部署运行在Linux上。无论部署exe，还是IIS站点、或是Windows Serv</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tianqing/p/14403255.html</dc:identifier>
</item>
<item>
<title>Asp.Net Core Grpc 入门实践 - 从此启程</title>
<link>http://www.cnblogs.com/fancunwei/p/14405938.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fancunwei/p/14405938.html</guid>
<description>&lt;p&gt;gRPC 是一种与语言无关的高性能远程过程调用 (RPC) 框架。&lt;br/&gt;在 gRPC 中，客户端应用程序可以直接调用不同计算机上的服务器应用程序上的方法，就像它是本地对象一样，从而更轻松地创建分布式应用程序和服务。它基于定义服务的想法，指定了参数和返回类型的远程过程调用的方法。服务器端实现这个接口并运行grpc服务来处理客户端的请求，客户端调用相同的方法完成请求。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/380359/202102/380359-20210215224828522-325135764.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.grpc.io/docs/what-is-grpc/introduction/&quot; target=&quot;_blank&quot;&gt;grpc官网&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/grpc/?view=aspnetcore-5.0&quot; target=&quot;_blank&quot;&gt;.NET 上的 gRPC 的简介&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;gRPC 的主要优点是：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;现代高性能轻量级 RPC 框架。&lt;br/&gt;协定优先 API 开发，默认使用协议缓冲区(Protocol Buffers)，允许与语言无关的实现。&lt;br/&gt;可用于多种语言的工具，以生成强类型服务器和客户端。&lt;br/&gt;支持客户端、服务器和双向流式处理调用。&lt;br/&gt;使用 Protobuf 二进制序列化减少对网络的使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这些优点使 gRPC 适用于：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;效率至关重要的轻量级微服务。&lt;br/&gt;需要多种语言用于开发的 Polyglot 系统。&lt;br/&gt;需要处理流式处理请求或响应的点对点实时服务。&lt;br/&gt;低延迟、高度可扩展的分布式系统。&lt;br/&gt;开发与云服务器通信的移动客户端。&lt;br/&gt;设计一个需要准确、高效且独立于语言的新协议。&lt;br/&gt;分层设计，以启用扩展，例如。身份验证、负载平衡、日志记录和监控等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;protocol-buffers&quot;&gt;Protocol Buffers&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/overview&quot; target=&quot;_blank&quot;&gt;protocol-buffers详细介绍&lt;/a&gt;&lt;br/&gt;在C#中会生成一个名为FirstMessage的类，基本格式如下：&lt;br/&gt;first.proto&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;syntax=&quot;proto3&quot;; //指定协议版本

package my.project;//C# namespace MyProject

option csharp_namespace=&quot;GrpcDemo.Protos&quot;; //生成C#代码时命名空间

message FirstMessage{
  int32 id=1;
  string name=2;
  bool is_male=3;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;定义服务：&quot;&gt;定义服务：&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;指定输入HelloRequest和输出HelloReply,以及方法名SayHello&lt;br/&gt;C#会生成对应的类和方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;// The greeter service definition.

service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;指定字段数据类型&quot;&gt;指定字段数据类型&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/380359/202102/380359-20210215230559872-1416051658.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;字段编号&quot;&gt;字段编号&lt;/h3&gt;
&lt;p&gt;每个字段都会有一个唯一的字段编号，这个非常重要。json中传递数据是以字段名为key,protobuf 是以字段编号为主，所以不要轻易变化编号。&lt;br/&gt;范围 1 到 15 中的字段编号需要一个字节进行编码，范围 16 到 2047 中的字段编号需要两个字节。所以需要为使用频繁的字段编号预留字段号1到15，并且为可能添加的元素预留一点字段号。&lt;/p&gt;
&lt;h2 id=&quot;指定字段规则&quot;&gt;指定字段规则&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;required：必填效验?&lt;/li&gt;
&lt;li&gt;optional ?&lt;/li&gt;
&lt;li&gt;repeated 可以出现多次，类似list&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;四种定义方式&quot;&gt;四种定义方式&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.grpc.io/docs/what-is-grpc/core-concepts/#rpc-life-cycle&quot; target=&quot;_blank&quot;&gt;Rpc生命周期对比&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;一元unary-rpc&quot;&gt;一元Unary RPC&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;rpc SayHello(HelloRequest) returns (HelloResponse);&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/380359/202102/380359-20210215233306952-1536665425.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;服务流server-streaming-rpcs&quot;&gt;服务流Server streaming Rpcs&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse);&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/380359/202102/380359-20210215233317042-529742184.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;客户端流client-streaming-rpcs&quot;&gt;客户端流Client streaming RPCs&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse);&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/380359/202102/380359-20210215233337388-223443299.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;双向流bidirectional-streaming-rpcs&quot;&gt;双向流Bidirectional streaming RPCs&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;rpc BidiHello(stream HelloRequest) returns (stream HelloResponse);&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/380359/202102/380359-20210216074220693-1489156400.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以传递特定的Rpc信息（如身份信息）。形式为键值对。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var md = new Metadata {
                { &quot;username&quot;,&quot;zhangsan&quot;},
                { &quot;role&quot;,&quot;administrator&quot;}
            };
//或者
var headers = new Metadata();
    headers.Add(&quot;Authorization&quot;, $&quot;Bearer {token}&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;channels-渠道&quot;&gt;Channels 渠道&lt;/h2&gt;
&lt;p&gt;gRPC 通道提供与指定主机和端口上的 gRPC 服务器的连接。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using var channel = GrpcChannel.ForAddress(&quot;https://localhost:5001&quot;);
var client = new EmployeeService.EmployeeServiceClient(channel);
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/protocolbuffers/protobuf/releases&quot; target=&quot;_blank&quot;&gt;下载protobuf&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;解压后，配置环境变量Path: D:\Proto\protoc-3.14.0-win64\bin&lt;br/&gt;然后cmd确认安装成功：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;C:\Users\Administrator&amp;gt;protoc --version
libprotoc 3.14.0
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;环境说明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;visual studio 2019 16.8.5
C:\Users\Administrator&amp;gt;dotnet --version
5.0.103
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;服务端&quot;&gt;服务端&lt;/h2&gt;
&lt;p&gt;演示特别说明：&lt;br/&gt;1、client流采用分批上传图片演示。&lt;br/&gt;2、服务端流采用将list数据分批传回客户端。&lt;/p&gt;
&lt;p&gt;新建Gprc服务项目（或普通asp.netcore web项目）&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/380359/202102/380359-20210215235120440-49435671.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;1、需要依赖以下nuget包&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Grpc.AspNetCore&lt;br/&gt;Grpc.Tools&lt;br/&gt;Grpc.Net.Client 控制台需要&lt;br/&gt;Google.Protobuf&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2、然后新建 Protos文件夹，定义proto文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;syntax=&quot;proto3&quot;;
option csharp_namespace=&quot;GrpcDemo.Protos&quot;;

message Employee{
 int32 id=1;
 int32 no=2;
 string firstName=3;
 string lastName=4;
 float salary=5;//薪水
}

message GetByNoRequest{
 int32 no=1;
}

message EmployeeResonse{
Employee employee=1;
}

message GetAllReqeust{}

message AddPhotoRequest{
bytes data=1;
}
message AddPhotoResponse{
 bool isOk=1;
}

message EmployeeRequest{
Employee employee=1;
}

service EmployeeService{
//Unary Rpc示例
 rpc GetByNo(GetByNoRequest) returns(EmployeeResonse);
 //server streaming Rpc示例
 rpc GetAll(GetAllReqeust) returns(stream EmployeeResonse);
 //client streaming Rpc示例
 rpc AddPhoto(stream AddPhotoRequest) returns(AddPhotoResponse);
 //双向Rpc示例
 rpc SaveAll(stream EmployeeRequest) returns(stream EmployeeResonse);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置proto属性，&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/380359/202102/380359-20210215235756695-1910884156.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;然后编译，会生成一个服务定义类以及相关的方法。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/380359/202102/380359-20210216000319148-977129559.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：EmployeeService.EmployeeServiceBase是有Grpc组件根据proto文件生成的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;    public class MyEmployeeService : EmployeeService.EmployeeServiceBase
    {
        private readonly ILogger&amp;lt;MyEmployeeService&amp;gt; _logger;
        public MyEmployeeService(ILogger&amp;lt;MyEmployeeService&amp;gt; logger)
        {
            _logger = logger;
        }
        /// &amp;lt;summary&amp;gt;
        /// Unary Rpc
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;request&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;context&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public override async Task&amp;lt;EmployeeResonse&amp;gt; GetByNo(GetByNoRequest request, ServerCallContext context)
        {
            Console.WriteLine(&quot;\r\nGrpcServer即将为你演示 一元Unary Rpc&quot;);

            MetadataProcess(context);

            var data = InmemoryData.Employees.FirstOrDefault(m =&amp;gt; m.No == request.No);
            if (data != null)
            {
                return await Task.FromResult(new EmployeeResonse()
                {
                    Employee = data
                });
            }
            throw new Exception(&quot;异常&quot;);
        }

        private void MetadataProcess(ServerCallContext context)
        {
            var metaData = context.RequestHeaders;
            foreach (var item in metaData)
            {
                _logger.LogInformation($&quot;key:{item.Key},value:{item.Value}&quot;);
            }
        }

        /// &amp;lt;summary&amp;gt;
        /// 服务流Server streaming Rpcs
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;request&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;responseStream&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;context&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public override async Task GetAll(GetAllReqeust request, IServerStreamWriter&amp;lt;EmployeeResonse&amp;gt; responseStream, ServerCallContext context)
        {
            Console.WriteLine(&quot;\r\nGrpcServer即将为你演示 服务流Server streaming Rpcs&quot;);

            MetadataProcess(context);
            foreach (var employee in InmemoryData.Employees)
            {
                Console.WriteLine($&quot;responseStream.Write:{employee}&quot;);
                await responseStream.WriteAsync(new EmployeeResonse()
                {
                    Employee = employee
                });
            }
        }
        /// &amp;lt;summary&amp;gt;
        /// 客户端流Client streaming RPCs 
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;requestStream&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;context&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public override async Task&amp;lt;AddPhotoResponse&amp;gt; AddPhoto(IAsyncStreamReader&amp;lt;AddPhotoRequest&amp;gt; requestStream, ServerCallContext context)
        {
            Console.WriteLine(&quot;\r\nGrpcServer即将为你演示 客户端流Client streaming RPCs &quot;);
            MetadataProcess(context);

            var data = new List&amp;lt;byte&amp;gt;();
            while (await requestStream.MoveNext())
            {
                Console.WriteLine($&quot;Received:{requestStream.Current.Data.Length}&quot;);
                data.AddRange(requestStream.Current.Data);
            }

            Console.WriteLine($&quot;Received file with{data.Count} bytes&quot;);

            return new AddPhotoResponse { IsOk = true };
        }

        /// &amp;lt;summary&amp;gt;
        /// 双向流Bidirectional streaming RPCs
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;requestStream&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;responseStream&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;context&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public override async Task SaveAll(IAsyncStreamReader&amp;lt;EmployeeRequest&amp;gt; requestStream, IServerStreamWriter&amp;lt;EmployeeResonse&amp;gt; responseStream, ServerCallContext context)
        {
            Console.WriteLine(&quot;\r\nGrpcServer即将为你演示 双向流Bidirectional streaming RPCs&quot;);

            while (await requestStream.MoveNext()) {

                var employee = requestStream.Current.Employee;
                Console.WriteLine($&quot;requestStream.Current:{employee}&quot;);
                lock (this)
                {
                    InmemoryData.Employees.Add(employee);
                }
                Console.WriteLine($&quot;responseStream.Write:{employee}&quot;);
                await responseStream.WriteAsync(new EmployeeResonse()
                {
                    Employee = employee
                });
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;客户端&quot;&gt;客户端&lt;/h2&gt;
&lt;p&gt;同上面新建Console项目，并引用以下nuget包：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Google.Protobuf&lt;br/&gt;Grpc.Net.Client&lt;br/&gt;Google.Protobuf&lt;br/&gt;Grpc.Tools&lt;br/&gt;新建protos文件夹，复制proto文件（或引用其他管理方案，如在线地址），然后编译生成解决方案：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/380359/202102/380359-20210216000908316-1597268805.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;创建通道&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;   static async Task Main(string[] args)
        {
            using var channel = GrpcChannel.ForAddress(&quot;https://localhost:5001&quot;);
            var client = new EmployeeService.EmployeeServiceClient(channel);
            var md = new Metadata {
                { &quot;username&quot;,&quot;zhangsan&quot;},
                { &quot;role&quot;,&quot;administrator&quot;},
                { &quot;Authorization&quot;, $&quot;Bearer xxxxxxxxxxxxxxxxxx&quot; }
            };

            Console.WriteLine(&quot;\r\nGrpcClient即将为你演示 一元Unary Rpc&quot;);
                        await GetByNoAsync(client, md);

            Console.WriteLine(&quot;\r\nGrpcClient即将为你演示 服务流Server streaming Rpcs&quot;);
            await GetAll(client, md);

            Console.WriteLine(&quot;\r\nGrpcClient即将为你演示 客户端流Client streaming RPCs &quot;);
            await AddPhoto(client,md);

            Console.WriteLine(&quot;\r\nGrpcClient即将为你演示 双向流Bidirectional streaming RPCs&quot;);
            await SaveAll(client, md);
            Console.WriteLine(&quot;Press Any key Exit!&quot;);
            Console.Read();
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后对接服务端四种服务流方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
        /// &amp;lt;summary&amp;gt;
        /// Unary RPC一元RPC
        /// &amp;lt;/summary&amp;gt;
        static async Task GetByNoAsync(EmployeeServiceClient client, Metadata md)
        {

            //一元
            var response = await client.GetByNoAsync(new GetByNoRequest()
            {
                No = 1
            }, md);

            Console.WriteLine($&quot;Reponse:{response}&quot;);
        }

        /// &amp;lt;summary&amp;gt;
        /// server-stream
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;client&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;md&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        static async Task GetAll(EmployeeServiceClient client, Metadata md)
        {
            using var call = client.GetAll(new GetAllReqeust() { });
            var responseStream = call.ResponseStream;
            while (await responseStream.MoveNext())
            {
                Console.WriteLine(responseStream.Current.Employee);
            }

        }

        /// &amp;lt;summary&amp;gt;
        /// client-stream
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;client&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;md&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        static async Task AddPhoto(EmployeeServiceClient client, Metadata md)
        {
            FileStream fs = File.OpenRead(&quot;Q1.png&quot;);
            using var call = client.AddPhoto(md);
            var stram = call.RequestStream;

            while (true)
            {
                byte[] buffer = new byte[1024];
                int numRead = await fs.ReadAsync(buffer, 0, buffer.Length);
                if (numRead == 0)
                {
                    break;
                }
                if (numRead &amp;lt; buffer.Length)
                {
                    Array.Resize(ref buffer, numRead);
                }
                await stram.WriteAsync(new AddPhotoRequest()
                {
                    Data = ByteString.CopyFrom(buffer)
                });
            }

            await stram.CompleteAsync();
            var res = await call.ResponseAsync;


            Console.WriteLine(res.IsOk);
        }

        /// &amp;lt;summary&amp;gt;
        /// 双向流
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;client&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;md&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        static async Task SaveAll(EmployeeServiceClient client, Metadata md)
        {
            var employees = new List&amp;lt;Employee&amp;gt;() {
             new Employee(){ Id=10, FirstName=&quot;F10&quot;, LastName=&quot;L10&quot;, No=10, Salary=10 },
             new Employee(){ Id=11, FirstName=&quot;F11&quot;, LastName=&quot;L11&quot;, No=11, Salary=11 },
             new Employee(){ Id=12, FirstName=&quot;F12&quot;, LastName=&quot;L12&quot;, No=12, Salary=12 },
            };

            using var call = client.SaveAll(md);
            var requestStream = call.RequestStream;
            var responseStream = call.ResponseStream;

            var responseTask = Task.Run(async () =&amp;gt;
            {
                while (await responseStream.MoveNext())
                {
                    Console.WriteLine($&quot;response:{responseStream.Current.Employee}&quot;);
                }
            });

            foreach (var employee in employees) {
                await requestStream.WriteAsync(new EmployeeRequest()
                {
                    Employee = employee
                });
            }
            await requestStream.CompleteAsync();
            await responseTask;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;效果演示如下：&quot;&gt;效果演示如下：&lt;/h3&gt;
&lt;p&gt;客户端：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GrpcClient即将为你演示 一元Unary Rpc
Reponse:{ &quot;employee&quot;: { &quot;id&quot;: 1, &quot;no&quot;: 1, &quot;firstName&quot;: &quot;FN1&quot;, &quot;lastName&quot;: &quot;LN1&quot;, &quot;salary&quot;: 1 } }

GrpcClient即将为你演示 服务流Server streaming Rpcs
{ &quot;id&quot;: 1, &quot;no&quot;: 1, &quot;firstName&quot;: &quot;FN1&quot;, &quot;lastName&quot;: &quot;LN1&quot;, &quot;salary&quot;: 1 }
{ &quot;id&quot;: 2, &quot;no&quot;: 2, &quot;firstName&quot;: &quot;FN1&quot;, &quot;lastName&quot;: &quot;LN1&quot;, &quot;salary&quot;: 1 }
{ &quot;id&quot;: 3, &quot;no&quot;: 3, &quot;firstName&quot;: &quot;FN1&quot;, &quot;lastName&quot;: &quot;LN1&quot;, &quot;salary&quot;: 1 }
{ &quot;id&quot;: 4, &quot;no&quot;: 4, &quot;firstName&quot;: &quot;FN1&quot;, &quot;lastName&quot;: &quot;LN1&quot;, &quot;salary&quot;: 1 }

GrpcClient即将为你演示 客户端流Client streaming RPCs
True

GrpcClient即将为你演示 双向流Bidirectional streaming RPCs
response:{ &quot;id&quot;: 10, &quot;no&quot;: 10, &quot;firstName&quot;: &quot;F10&quot;, &quot;lastName&quot;: &quot;L10&quot;, &quot;salary&quot;: 10 }
response:{ &quot;id&quot;: 11, &quot;no&quot;: 11, &quot;firstName&quot;: &quot;F11&quot;, &quot;lastName&quot;: &quot;L11&quot;, &quot;salary&quot;: 11 }
response:{ &quot;id&quot;: 12, &quot;no&quot;: 12, &quot;firstName&quot;: &quot;F12&quot;, &quot;lastName&quot;: &quot;L12&quot;, &quot;salary&quot;: 12 }
Press Any key Exit!
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;服务端输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GrpcServer即将为你演示 一元Unary Rpc
info: GrpcDemo.Services.MyEmployeeService[0]
      key:authorization,value:Bearer xxxxxxxxxxxxxxxxxx
info: GrpcDemo.Services.MyEmployeeService[0]
      key:user-agent,value:grpc-dotnet/2.35.0.0
info: GrpcDemo.Services.MyEmployeeService[0]
      key:username,value:zhangsan
info: GrpcDemo.Services.MyEmployeeService[0]
      key:role,value:administrator

GrpcServer即将为你演示 服务流Server streaming Rpcs
info: GrpcDemo.Services.MyEmployeeService[0]
      key:user-agent,value:grpc-dotnet/2.35.0.0
responseStream.Write:{ &quot;id&quot;: 1, &quot;no&quot;: 1, &quot;firstName&quot;: &quot;FN1&quot;, &quot;lastName&quot;: &quot;LN1&quot;, &quot;salary&quot;: 1 }
responseStream.Write:{ &quot;id&quot;: 2, &quot;no&quot;: 2, &quot;firstName&quot;: &quot;FN1&quot;, &quot;lastName&quot;: &quot;LN1&quot;, &quot;salary&quot;: 1 }
responseStream.Write:{ &quot;id&quot;: 3, &quot;no&quot;: 3, &quot;firstName&quot;: &quot;FN1&quot;, &quot;lastName&quot;: &quot;LN1&quot;, &quot;salary&quot;: 1 }
responseStream.Write:{ &quot;id&quot;: 4, &quot;no&quot;: 4, &quot;firstName&quot;: &quot;FN1&quot;, &quot;lastName&quot;: &quot;LN1&quot;, &quot;salary&quot;: 1 }

GrpcServer即将为你演示 客户端流Client streaming RPCs
info: GrpcDemo.Services.MyEmployeeService[0]
      key:authorization,value:Bearer xxxxxxxxxxxxxxxxxx
info: GrpcDemo.Services.MyEmployeeService[0]
      key:user-agent,value:grpc-dotnet/2.35.0.0
info: GrpcDemo.Services.MyEmployeeService[0]
      key:username,value:zhangsan
info: GrpcDemo.Services.MyEmployeeService[0]
      key:role,value:administrator
Received:1024
Received:1024
Received:1024
Received:1024
Received:1024
Received:1024
Received:1024
Received:1024
Received:1024
Received:573
Received file with9789 bytes

GrpcServer即将为你演示 双向流Bidirectional streaming RPCs
requestStream.Current:{ &quot;id&quot;: 10, &quot;no&quot;: 10, &quot;firstName&quot;: &quot;F10&quot;, &quot;lastName&quot;: &quot;L10&quot;, &quot;salary&quot;: 10 }
responseStream.Write:{ &quot;id&quot;: 10, &quot;no&quot;: 10, &quot;firstName&quot;: &quot;F10&quot;, &quot;lastName&quot;: &quot;L10&quot;, &quot;salary&quot;: 10 }
requestStream.Current:{ &quot;id&quot;: 11, &quot;no&quot;: 11, &quot;firstName&quot;: &quot;F11&quot;, &quot;lastName&quot;: &quot;L11&quot;, &quot;salary&quot;: 11 }
responseStream.Write:{ &quot;id&quot;: 11, &quot;no&quot;: 11, &quot;firstName&quot;: &quot;F11&quot;, &quot;lastName&quot;: &quot;L11&quot;, &quot;salary&quot;: 11 }
requestStream.Current:{ &quot;id&quot;: 12, &quot;no&quot;: 12, &quot;firstName&quot;: &quot;F12&quot;, &quot;lastName&quot;: &quot;L12&quot;, &quot;salary&quot;: 12 }
responseStream.Write:{ &quot;id&quot;: 12, &quot;no&quot;: 12, &quot;firstName&quot;: &quot;F12&quot;, &quot;lastName&quot;: &quot;L12&quot;, &quot;salary&quot;: 12 }
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/grpc/diagnostics?view=aspnetcore-5.0&quot; target=&quot;_blank&quot;&gt;日志配置&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[从 gRPC 创建 JSON Web API]（&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/grpc/httpapi?view=aspnetcore-5.0%EF%BC%89&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/aspnet/core/grpc/httpapi?view=aspnetcore-5.0）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/fancunwei/FiveFan/tree/main&quot; target=&quot;_blank&quot;&gt;GrpcDemo和GrpcDemo.Client&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://grpc.io/docs/&quot; target=&quot;_blank&quot;&gt;Grpc官网&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1eE411T7GC?from=search&amp;amp;seid=9896969874245634164&quot; target=&quot;_blank&quot;&gt;gRPC in C#*2/Go/C++&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;感谢观看，本篇实践到此结束。&lt;/p&gt;
</description>
<pubDate>Mon, 15 Feb 2021 17:06:00 +0000</pubDate>
<dc:creator>从此启程</dc:creator>
<og:description>Grpc简介 gRPC 是一种与语言无关的高性能远程过程调用 (RPC) 框架。 在 gRPC 中，客户端应用程序可以直接调用不同计算机上的服务器应用程序上的方法，就像它是本地对象一样，从而更轻松地创</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fancunwei/p/14405938.html</dc:identifier>
</item>
<item>
<title>计量经济学导论10：ARIMA模型 - 李旭东东东东东阿东</title>
<link>http://www.cnblogs.com/lixddd/p/14405934.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lixddd/p/14405934.html</guid>
<description>&lt;p&gt;主要介绍了时间序列分析中的AR，MA，ARMA等重要的典型模型的性质和选择方法。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;409.08196381715&quot;&gt;


&lt;h2 id=&quot;滞后算子&quot;&gt;滞后算子&lt;/h2&gt;
&lt;p&gt;在这一节中，我们主要介绍时间序列分析中的几类经典的时间序列模型。为了简化模型设定，我们需要引入&lt;u&gt;滞后算子&lt;/u&gt;的概念。&lt;/p&gt;
&lt;p&gt;滞后算子的定义非常容易理解，满足以下性质：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathscr{B}X_t=X_{t-1}\)&lt;/span&gt; ；&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathscr{B}^2X_t=\mathscr{B}(\mathscr{B}X_t)=\mathscr{B}(X_{t-1})=X_{t-2}\)&lt;/span&gt; ；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;即称 &lt;span class=&quot;math inline&quot;&gt;\(\mathscr{B}\)&lt;/span&gt; 为时间 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt; 的向后推移算子或滞后算子。&lt;/p&gt;
&lt;p&gt;引入滞后算子之后，我们可以定义&lt;u&gt;滞后算子多项式&lt;/u&gt;如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 阶滞后算子多项式：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;\[B(\mathscr{B})=b_0+b_1\mathscr{B}+b_2\mathscr{B}^2+\cdots+b_m\mathscr{B}^m=\sum_{i=0}^mb_i\mathscr{B}^i \ . \]&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无穷阶滞后算子多项式：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;\[B(\mathscr{B})=b_0+b_1\mathscr{B}+b_2\mathscr{B}^2+\cdots=\sum_{i=0}^\infty b_i\mathscr{B}^i \ . \]&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;特别地，若 &lt;span class=&quot;math inline&quot;&gt;\(|\varphi|&amp;lt;1\)&lt;/span&gt; ，根据 Taylor 级数计算公式有：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;\[\frac{1}{1-\varphi\mathscr{B}}=1+\varphi\mathscr{B}+\varphi^2\mathscr{B}^2+\varphi^3\mathscr{B}^3+... \ . \]&lt;/p&gt;
&lt;p&gt;在滞后算子的基础上，我们可以逐一讨论时间序列模型。&lt;/p&gt;
&lt;h2 id=&quot;模型-1&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\({\rm MA}(q)\)&lt;/span&gt; 模型&lt;/h2&gt;
&lt;p&gt;首先我们讨论滑动平均模型的性质，滞后阶数为 &lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt; 的滑动平均模型简称为 &lt;span class=&quot;math inline&quot;&gt;\({\rm MA}(q)\)&lt;/span&gt; 模型。在计量经济学所研究的时间序列模型中，一般滞后阶数不会很高，所以我们先从 &lt;span class=&quot;math inline&quot;&gt;\({\rm MA}(1)\)&lt;/span&gt; 模型开始讨论，其性质更为重要也更便于讨论。&lt;/p&gt;
&lt;h3 id=&quot;模型-2&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\({\rm MA}(1)\)&lt;/span&gt; 模型&lt;/h3&gt;
&lt;p&gt;一般地， &lt;span class=&quot;math inline&quot;&gt;\({\rm MA}(1)\)&lt;/span&gt; 模型的&lt;u&gt;模型设定&lt;/u&gt;如下：&lt;/p&gt;
&lt;p&gt;\[y_t=u_t+\theta u_{t-1} \ , \]&lt;/p&gt;
&lt;p&gt;\[u_t\sim{\rm WN}(0,\,\sigma^2) \ . \]&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(\{u_t\}\)&lt;/span&gt; 是白噪声序列。满足上述模型设定的序列 &lt;span class=&quot;math inline&quot;&gt;\(\{y_t\}\)&lt;/span&gt; 称为 &lt;span class=&quot;math inline&quot;&gt;\({\rm MA}(1)\)&lt;/span&gt; 序列。&lt;/p&gt;
&lt;p&gt;首先，我们讨论 &lt;span class=&quot;math inline&quot;&gt;\({\rm MA}(1)\)&lt;/span&gt; 序列的&lt;u&gt;平稳性&lt;/u&gt;，通过计算我们可以得到 &lt;span class=&quot;math inline&quot;&gt;\(\{y_t\}\)&lt;/span&gt; 序列具有如下性质：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\({\rm E}(y_t)=0\)&lt;/span&gt; ；&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\({\rm Var}(y_t)=(1+\theta^2)\sigma^2\)&lt;/span&gt; ；&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\gamma(k)={\rm Cov}(y_t,\,y_{t+k})={\rm E}[(u_t+\theta u_{t-1})(u_{t+k}+\theta u_{t+k-1})]= \left\{ \begin{array}{lll} \theta\sigma^2 &amp;amp;, &amp;amp; k=1\\ 0 &amp;amp;,&amp;amp; k\geq2 \end{array} \right.\)&lt;/span&gt; .&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此，&lt;span class=&quot;math inline&quot;&gt;\({\rm MA}(1)\)&lt;/span&gt; 序列是一个平稳时间序列。可以看出， &lt;span class=&quot;math inline&quot;&gt;\({\rm MA}(1)\)&lt;/span&gt; 序列的自协方差函数是 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; 步截尾的。根据已经计算得到的自协方差函数，可以计算自相关函数 ACF ：&lt;/p&gt;
&lt;p&gt;\[\rho(k)=\frac{\gamma(k)}{\gamma(0)}= \left\{ \begin{array}{lll} \dfrac{\theta}{1+\theta^2} &amp;amp;, &amp;amp; k=1\\ 0 &amp;amp;,&amp;amp; {\rm otherwise} \end{array} \right. \ . \]&lt;/p&gt;
&lt;p&gt;可以看出 &lt;span class=&quot;math inline&quot;&gt;\({\rm MA}(1)\)&lt;/span&gt; 序列的 ACF 也是 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; 步截尾的。&lt;/p&gt;
&lt;p&gt;对于 &lt;span class=&quot;math inline&quot;&gt;\({\rm MA}(1)\)&lt;/span&gt; 序列，如果 &lt;span class=&quot;math inline&quot;&gt;\(|\theta|&amp;lt;1\)&lt;/span&gt; ，称 &lt;span class=&quot;math inline&quot;&gt;\(\{y_t\}\)&lt;/span&gt; 为可逆的 &lt;span class=&quot;math inline&quot;&gt;\({\rm MA}(1)\)&lt;/span&gt; 序列。下面我们利用滞后算子的推导方式来讨论 &lt;span class=&quot;math inline&quot;&gt;\({\rm MA}(1)\)&lt;/span&gt; 序列的&lt;u&gt;可逆性质&lt;/u&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;可以用滞后算子表示 &lt;span class=&quot;math inline&quot;&gt;\({\rm MA}(1)\)&lt;/span&gt; 序列并进行“逆变换”&lt;/p&gt;
&lt;p&gt;\[y_t=(1+\theta\mathscr{B})u_t \ , \]&lt;/p&gt;
&lt;p&gt;\[\dfrac{y_t}{1+\theta\mathscr{B}}=u_t \ , \]&lt;/p&gt;
&lt;p&gt;\[y_t=u_t-(-\theta)y_{t-1}-(-\theta)^2y_{t-2}-\cdots \ . \]&lt;/p&gt;
&lt;p&gt;以上过程被称为 &lt;span class=&quot;math inline&quot;&gt;\({\rm MA}(1)\)&lt;/span&gt; 序列的无限自回归表示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面的最后一个式子说明对于可逆的 &lt;span class=&quot;math inline&quot;&gt;\({\rm MA}\)&lt;/span&gt; 模型，可以利用 &lt;span class=&quot;math inline&quot;&gt;\({\rm AR}(\infty)\)&lt;/span&gt; 模型来建模。&lt;/p&gt;
&lt;p&gt;最后我们来讨论 &lt;span class=&quot;math inline&quot;&gt;\({\rm MA}(1)\)&lt;/span&gt; 序列的偏相关函数 PACF 。仍然是利用自回归的方式求解样本偏相关函数。根据可逆性质和无限自回归表示，我们可以得到：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(y_t=\beta_0+\beta_1y_{t-1}+\varepsilon_t\)&lt;/span&gt; ,&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(p(1)=\hat\beta_1\approx\theta\)&lt;/span&gt; .&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(y_t=\beta_0+\beta_1y_{t-1}+\cdots+\beta_ky_{t-k}+\varepsilon_t\)&lt;/span&gt; ,&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(p(k)=\hat\beta_k\approx(-1)^{k+1}\theta^k\)&lt;/span&gt; .&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在可逆性条件下 &lt;span class=&quot;math inline&quot;&gt;\(|\theta|&amp;lt;1\)&lt;/span&gt; ，因此 PACF 随 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 逐渐收敛至 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt; ，表现为拖尾。图像中可表现为&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;若 &lt;span class=&quot;math inline&quot;&gt;\(\theta&amp;gt;0\)&lt;/span&gt; 则 PACF 上下摆动收敛于 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt; ；&lt;/li&gt;
&lt;li&gt;若 &lt;span class=&quot;math inline&quot;&gt;\(\theta&amp;lt;0\)&lt;/span&gt; 则 PACF 恒为负并递增收敛于 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt; 。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;模型-3&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\({\rm MA}(q)\)&lt;/span&gt; 模型&lt;/h3&gt;
&lt;p&gt;接下来我们将滑动平均模型推广至一般情况， &lt;span class=&quot;math inline&quot;&gt;\({\rm MA}(q)\)&lt;/span&gt; 模型的模型设定如下：&lt;/p&gt;
&lt;p&gt;\[y_t=u_t+\theta_1u_{t-1}+\theta_2u_{t-2}+\cdots+\theta_qu_{t-q} \ , \]&lt;/p&gt;
&lt;p&gt;\[u_t\sim{\rm WN}(0,\,\sigma^2) \ . \]&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(\{u_t\}\)&lt;/span&gt; 是白噪声序列。满足上述模型设定的序列 &lt;span class=&quot;math inline&quot;&gt;\(\{y_t\}\)&lt;/span&gt; 称为 &lt;span class=&quot;math inline&quot;&gt;\({\rm MA}(q)\)&lt;/span&gt; 序列。&lt;/p&gt;
&lt;p&gt;首先讨论 &lt;span class=&quot;math inline&quot;&gt;\({\rm MA}(q)\)&lt;/span&gt; 序列的平稳性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\({\rm E}(y_t)=0\)&lt;/span&gt; ;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\({\rm Var}(y_t)=(1+\theta_1^2+\cdots+\theta_q^2)\sigma^2\)&lt;/span&gt; ;&lt;/li&gt;
&lt;li&gt;自协方差函数：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;\[\gamma(k)={\rm Cov}(y_t,\,y_{t+k})= \left\{ \begin{array}{lll} (\theta_1+\theta_2\theta_1+...+\theta_q\theta_{q-1})\sigma^2 &amp;amp;, &amp;amp; k=1 \\ \cdots &amp;amp;&amp;amp; \\ (\theta_{q-1}+\theta_q\theta_1)\sigma^2 &amp;amp;,&amp;amp; k=q-1\\ \theta_q\sigma^2&amp;amp;,&amp;amp;k=q \\ 0 &amp;amp;,&amp;amp; k&amp;gt;q \end{array} \right. \]&lt;/p&gt;
&lt;p&gt;因此 &lt;span class=&quot;math inline&quot;&gt;\({\rm MA}(q)\)&lt;/span&gt; 序列是一个平稳时间序列。由于这里的 &lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt; 是有限阶数，因此也称有限 &lt;span class=&quot;math inline&quot;&gt;\({\rm MA}(q)\)&lt;/span&gt; 序列。有根据自协方差函数，我们可以知道 &lt;span class=&quot;math inline&quot;&gt;\({\rm MA}(q)\)&lt;/span&gt; 序列的自协方差函数和自相关函数都是 &lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt; 后截尾的。&lt;/p&gt;
&lt;p&gt;同样的 &lt;span class=&quot;math inline&quot;&gt;\({\rm MA}(q)\)&lt;/span&gt; 序列也具有可逆性，其充要条件为：有限 &lt;span class=&quot;math inline&quot;&gt;\({\rm MA}(q)\)&lt;/span&gt; 序列是可逆的当且仅当特征多项式 &lt;span class=&quot;math inline&quot;&gt;\(\Theta(z)\)&lt;/span&gt; 的根均在单位圆外：&lt;/p&gt;
&lt;p&gt;\[\Theta(z)=\sum_{i=0}^q\theta_iz^i\neq0\ , \ \ \ \ |z|\leq1 \ . \]&lt;/p&gt;
&lt;p&gt;根据 &lt;span class=&quot;math inline&quot;&gt;\({\rm MA}(q)\)&lt;/span&gt; 序列的自相关函数的结尾性质，我们可以通过计算 ACF 来定阶。&lt;/p&gt;
&lt;h2 id=&quot;模型-4&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\({\rm AR}(p)\)&lt;/span&gt; 模型&lt;/h2&gt;
&lt;p&gt;接下来我们讨论自回归模型，简称为 &lt;span class=&quot;math inline&quot;&gt;\({\rm AR}\)&lt;/span&gt; 模型。我们先来看简单的情况。&lt;/p&gt;
&lt;h3 id=&quot;模型-5&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\({\rm AR}(1)\)&lt;/span&gt; 模型&lt;/h3&gt;
&lt;p&gt;一般地， &lt;span class=&quot;math inline&quot;&gt;\({\rm AR}(1)\)&lt;/span&gt; 模型的&lt;u&gt;模型设定&lt;/u&gt;如下：&lt;/p&gt;
&lt;p&gt;\[y_t=\phi y_{t-1+}\varepsilon_t \ , \]&lt;/p&gt;
&lt;p&gt;\[\varepsilon_t\sim{\rm WN}(0,\,\sigma^2) \ . \]&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(\{\varepsilon_t\}\)&lt;/span&gt; 是白噪声序列。满足上述模型设定的序列 &lt;span class=&quot;math inline&quot;&gt;\(\{y_t\}\)&lt;/span&gt; 称为 &lt;span class=&quot;math inline&quot;&gt;\({\rm AR}(1)\)&lt;/span&gt; 序列。容易计算得到 &lt;span class=&quot;math inline&quot;&gt;\(y_t\)&lt;/span&gt; 的期望和方差如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\({\rm E}(y_t)=0\)&lt;/span&gt; ;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\({\rm Var}(y_t)=\dfrac{\sigma^2}{1-\phi^2}\)&lt;/span&gt; .&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了得到自协方差函数，我们对 &lt;span class=&quot;math inline&quot;&gt;\({\rm AR}(1)\)&lt;/span&gt; 模型的两边同时乘一个 &lt;span class=&quot;math inline&quot;&gt;\(y_{t-k}\)&lt;/span&gt; ：&lt;/p&gt;
&lt;p&gt;\[y_ty_{t-k}=\phi y_{t-1}y_{t-k}+\varepsilon_ty_{t-k} \ , \]&lt;/p&gt;
&lt;p&gt;对 &lt;span class=&quot;math inline&quot;&gt;\(k\geq1\)&lt;/span&gt; ，两边同时取数学期望：&lt;/p&gt;
&lt;p&gt;\[{\rm E}(y_ty_{t-k})=\phi {\rm E}(y_{t-1}y_{t-k})+{\rm E}(\varepsilon_ty_{t-k}) \ , \]&lt;/p&gt;
&lt;p&gt;得到下面重要的式子 &lt;strong&gt;Yule-Walker 方程&lt;/strong&gt; ：&lt;/p&gt;
&lt;p&gt;\[\gamma(k)=\phi\gamma(k-1) \ . \]&lt;/p&gt;
&lt;p&gt;这是一个递归方程，如果我们已知初值条件 &lt;span class=&quot;math inline&quot;&gt;\(\gamma(0)\)&lt;/span&gt; ，我们就可以利用 Y-W 方程计算出全体自协方差函数序列。下面推导如何计算 &lt;span class=&quot;math inline&quot;&gt;\(\gamma(0)\)&lt;/span&gt; ：&lt;/p&gt;
&lt;p&gt;对 &lt;span class=&quot;math inline&quot;&gt;\({\rm AR}(1)\)&lt;/span&gt; 模型的两边同时乘一个 &lt;span class=&quot;math inline&quot;&gt;\(y_{t}\)&lt;/span&gt; 并取数学期望&lt;/p&gt;
&lt;p&gt;\[{\rm E}(y_t^2)=\phi {\rm E}(y_ty_{t-1})+{\rm E}(\varepsilon_ty_t)=\phi {\rm E}(y_ty_{t-1})+\phi {\rm E}(\varepsilon_ty_{t-1})+{\rm E}(\varepsilon_t^2) \ . \]&lt;/p&gt;
&lt;p&gt;\[\gamma(0)=\phi\gamma(1)+\sigma^2 \ . \]&lt;/p&gt;
&lt;p&gt;对 Y-W 方程取 &lt;span class=&quot;math inline&quot;&gt;\(k=1\)&lt;/span&gt; 得&lt;/p&gt;
&lt;p&gt;\[\gamma(1)=\phi\gamma(0) \ . \]&lt;/p&gt;
&lt;p&gt;两个方程联立解得：&lt;/p&gt;
&lt;p&gt;\[\gamma(0)=\frac{\sigma^2}{1-\phi^2} \ . \]&lt;/p&gt;
&lt;p&gt;这也是 &lt;span class=&quot;math inline&quot;&gt;\({\rm AR}(1)\)&lt;/span&gt; 序列的方差。&lt;/p&gt;
&lt;p&gt;利用 Y-W 方程和初值条件，我们可以得到一般的自协方差函数：&lt;/p&gt;
&lt;p&gt;\[\gamma(k)=\phi^k\frac{\sigma^2}{1-\phi^2} \ , \]&lt;/p&gt;
&lt;p&gt;可以看出 &lt;span class=&quot;math inline&quot;&gt;\({\rm AR}(1)\)&lt;/span&gt; 序列是平稳序列。但为保证自协方差存在，需要满足&lt;u&gt;平稳性条件&lt;/u&gt;： &lt;span class=&quot;math inline&quot;&gt;\(|\phi|&amp;lt;1\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;进而我们可以得到&lt;u&gt;自相关函数&lt;/u&gt;：&lt;/p&gt;
&lt;p&gt;\[\rho(k)=\phi^k \ . \]&lt;/p&gt;
&lt;p&gt;注意到 &lt;span class=&quot;math inline&quot;&gt;\({\rm AR}(1)\)&lt;/span&gt; 序列的 ACF 是一个逐渐收敛到 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt; 的序列，表现为&lt;u&gt;拖尾&lt;/u&gt;。如果 &lt;span class=&quot;math inline&quot;&gt;\(\phi&amp;gt;0\)&lt;/span&gt; 则 &lt;span class=&quot;math inline&quot;&gt;\(\rho(k)\)&lt;/span&gt; 递减趋近于 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt; ，如果 &lt;span class=&quot;math inline&quot;&gt;\(\phi&amp;lt;0\)&lt;/span&gt; 则 &lt;span class=&quot;math inline&quot;&gt;\(\rho(k)\)&lt;/span&gt; 上下振荡衰减至 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;继续讨论&lt;u&gt;偏相关函数&lt;/u&gt;，不难发现 &lt;span class=&quot;math inline&quot;&gt;\({\rm AR}(1)\)&lt;/span&gt; 序列的 PACF 是 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; 步&lt;u&gt;截尾&lt;/u&gt;的&lt;/p&gt;
&lt;p&gt;\[p(k)= \left\{ \begin{array}{lll} \phi &amp;amp;, &amp;amp; k=1\\ 0 &amp;amp;,&amp;amp; k\geq1 \end{array} \right. \ . \]&lt;/p&gt;
&lt;p&gt;PACF 只是一个连续的总体自回归序列中的最后一期滞后项的自回归系数。如果真实过程实际上是 &lt;span class=&quot;math inline&quot;&gt;\({\rm AR}(1)\)&lt;/span&gt; ，则 &lt;span class=&quot;math inline&quot;&gt;\(p(1)\)&lt;/span&gt; 就是自回归系数 &lt;span class=&quot;math inline&quot;&gt;\(\phi\)&lt;/span&gt; ，所有较长滞后的系数均为零。&lt;/p&gt;
&lt;h3 id=&quot;模型-6&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\({\rm AR}(p)\)&lt;/span&gt; 模型&lt;/h3&gt;
&lt;p&gt;将自回归模型推广至一般情况， &lt;span class=&quot;math inline&quot;&gt;\({\rm AR}(p)\)&lt;/span&gt; 模型的模型设定如下：&lt;/p&gt;
&lt;p&gt;\[y_t=\phi_1y_{t-1}+\phi_2y_{t-2}+...+\phi_py_{t-p}+\varepsilon_t \ , \]&lt;/p&gt;
&lt;p&gt;\[\varepsilon_t\sim{\rm WN}(0,\,\sigma^2) \ . \]&lt;/p&gt;
&lt;p&gt;使用滞后算子多项式可以表示为：&lt;/p&gt;
&lt;p&gt;\[(1-\phi_1\mathscr{B}-\phi_2\mathscr{B}^2-...-\phi_p\mathscr{B}^p)y_t=\varepsilon_t \ . \]&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(\{\varepsilon_t\}\)&lt;/span&gt; 是白噪声序列。满足上述模型设定的序列 &lt;span class=&quot;math inline&quot;&gt;\(\{y_t\}\)&lt;/span&gt; 称为 &lt;span class=&quot;math inline&quot;&gt;\({\rm AR}(p)\)&lt;/span&gt; 序列。&lt;/p&gt;
&lt;p&gt;类似于 &lt;span class=&quot;math inline&quot;&gt;\({\rm AR}(1)\)&lt;/span&gt; 序列的性质，一个 &lt;span class=&quot;math inline&quot;&gt;\({\rm AR}(p)\)&lt;/span&gt; 序列是自协方差平稳的的当且仅当其滞后算子多项式 &lt;span class=&quot;math inline&quot;&gt;\(\Phi(z)\)&lt;/span&gt; 的根都在单位圆的外部。在满足平稳性的条件下， &lt;span class=&quot;math inline&quot;&gt;\({\rm AR}(p)\)&lt;/span&gt; 模型的解可以写为：&lt;/p&gt;
&lt;p&gt;\[y_t=\frac{1}{\Phi(\mathscr{B})}\varepsilon_t \]&lt;/p&gt;
&lt;p&gt;同样的， &lt;span class=&quot;math inline&quot;&gt;\({\rm AR}(p)\)&lt;/span&gt; 序列的偏相关函数具有 &lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt; 步截尾性，因此可以通过计算 PACF 为 &lt;span class=&quot;math inline&quot;&gt;\({\rm AR}(p)\)&lt;/span&gt; 模型定阶。&lt;/p&gt;
&lt;h2 id=&quot;模型-7&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\({\rm ARMA}(p,\,q)\)&lt;/span&gt; 模型&lt;/h2&gt;
&lt;p&gt;关于滑动平均自回归模型我们只做简单的介绍。详细的内容需要参考课程《时间序列分析》。&lt;/p&gt;
&lt;h3 id=&quot;模型-8&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\({\rm ARMA}(1,\,1)\)&lt;/span&gt; 模型&lt;/h3&gt;
&lt;p&gt;先从简单的开始， &lt;span class=&quot;math inline&quot;&gt;\({\rm ARMA}(1,\,1)\)&lt;/span&gt; 模型的&lt;u&gt;模型设定&lt;/u&gt;如下：&lt;/p&gt;
&lt;p&gt;\[y_t=\phi y_{t-1}+\varepsilon_t+\theta\varepsilon_{t-1} \ , \]&lt;/p&gt;
&lt;p&gt;\[\varepsilon_t\sim{\rm WN}(0,\,\sigma^2) \ . \]&lt;/p&gt;
&lt;p&gt;用滞后算子表示的形式为：&lt;/p&gt;
&lt;p&gt;\[(1-\phi\mathscr{B})y_t=(1+\theta\mathscr{B})\varepsilon_t \ . \]&lt;/p&gt;
&lt;p&gt;当 &lt;span class=&quot;math inline&quot;&gt;\(|\phi|&amp;lt;1\)&lt;/span&gt; 时 &lt;span class=&quot;math inline&quot;&gt;\({\rm ARMA}(1,\,1)\)&lt;/span&gt; 序列是平稳的，当 &lt;span class=&quot;math inline&quot;&gt;\(|\theta|&amp;lt;1\)&lt;/span&gt; 时 &lt;span class=&quot;math inline&quot;&gt;\({\rm ARMA}(1,\,1)\)&lt;/span&gt; 序列是可逆的。&lt;/p&gt;
&lt;h3 id=&quot;模型-9&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\({\rm ARMA}(p,\,q)\)&lt;/span&gt; 模型&lt;/h3&gt;
&lt;p&gt;一般地， &lt;span class=&quot;math inline&quot;&gt;\({\rm ARMA}(p,\,q)\)&lt;/span&gt; 模型的&lt;u&gt;模型设定&lt;/u&gt;如下：&lt;/p&gt;
&lt;p&gt;\[y_t=\phi_1y_{t-1}+\phi_2y_{t-2}+...+\phi_py_{t-p}+\varepsilon_t+\theta_1\varepsilon_{t-1}+\theta_2\varepsilon_{t-2}+...+\theta_q\varepsilon_{t-q} \ , \]&lt;/p&gt;
&lt;p&gt;\[\varepsilon_t\sim{\rm WN}(0,\,\sigma^2) \ . \]&lt;/p&gt;
&lt;p&gt;滞后算子形式：&lt;/p&gt;
&lt;p&gt;\[\Phi(\mathscr{B})y_t=\Theta(\mathscr{B})\varepsilon_t \ , \]&lt;/p&gt;
&lt;p&gt;\[\Phi(z)=1-\phi_1z-...-\phi_pz^p \ , \]&lt;/p&gt;
&lt;p&gt;\[\Theta(z)=1+\theta_1z+...+\theta_qz^q \ . \]&lt;/p&gt;
&lt;p&gt;对于一个 &lt;span class=&quot;math inline&quot;&gt;\({\rm ARMA}(p,\,q)\)&lt;/span&gt; 序列：&lt;/p&gt;
&lt;p&gt;当 &lt;span class=&quot;math inline&quot;&gt;\(\Phi(z)\)&lt;/span&gt; 的所有根都在单位圆外时，该序列是平稳的：&lt;/p&gt;
&lt;p&gt;\[y_t=\frac{\Theta(\mathscr{B})}{\Phi(\mathscr{B})}\varepsilon_t \]&lt;/p&gt;
&lt;p&gt;当 &lt;span class=&quot;math inline&quot;&gt;\(\Theta(z)\)&lt;/span&gt; 的所有根都在单位圆外时，该序列是可逆的。&lt;/p&gt;
&lt;p&gt;\[\frac{\Phi(\mathscr{B})}{\Theta(\mathscr{B})}y_t=\varepsilon_t \]&lt;/p&gt;
&lt;p&gt;此外，&lt;span class=&quot;math inline&quot;&gt;\({\rm ARMA}(p,\,q)\)&lt;/span&gt; 模型的 ACF 和 PACF 都是拖尾的，即逐渐收敛到 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt; 的。&lt;/p&gt;
&lt;p&gt;那么我们面临一个问题：如何选择 &lt;span class=&quot;math inline&quot;&gt;\({\rm ARMA}(p,\,q)\)&lt;/span&gt; 模型的滞后阶数以更好的拟合数据。&lt;/p&gt;
&lt;p&gt;在利用回归进行参数估计时，增加滞后期数 &lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt; 或 &lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt; 可以减少残差平方和，但是增加滞后期数也会造成自由度的损失。因此我们需要模型选择的方式。&lt;/p&gt;
&lt;h2 id=&quot;模型的选择&quot;&gt;模型的选择&lt;/h2&gt;
&lt;p&gt;在介绍完五种常见的时间序列模型之后，我们来讨论一下如果根据样本数据的特征来选择我们需要拟合的模型。我们可以根据 ACF 图和 PACF 图来初步判断模型：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;&lt;span class=&quot;math inline&quot;&gt;\({\rm AR}(p)\)&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span class=&quot;math inline&quot;&gt;\({\rm MA}(q)\)&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span class=&quot;math inline&quot;&gt;\({\rm ARMA}(p,\,q)\)&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;ACF&lt;/td&gt;
&lt;td&gt;拖尾&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt; 步截尾&lt;/td&gt;
&lt;td&gt;拖尾&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;PACF&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt; 步截尾&lt;/td&gt;
&lt;td&gt;拖尾&lt;/td&gt;
&lt;td&gt;拖尾&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;由于 &lt;span class=&quot;math inline&quot;&gt;\({\rm ARMA}(p,\,q)\)&lt;/span&gt; 模型的 ACF、PACF 均为拖尾，因此无法通过 ACF、PACF 图像判断 &lt;span class=&quot;math inline&quot;&gt;\({\rm ARMA}\)&lt;/span&gt; 模型的阶数。在实践中，我们还可以通过信息准则等进行判断：&lt;/p&gt;
&lt;p&gt;简单介绍一下 &lt;span class=&quot;math inline&quot;&gt;\({\rm AIC}\)&lt;/span&gt; 信息准则：&lt;/p&gt;
&lt;p&gt;\[{\rm AIC}(k)=\ln\hat\sigma_k^2+\frac{2k}{n} \ , \]&lt;/p&gt;
&lt;p&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\(\hat\sigma^2\)&lt;/span&gt; 为回归模型的残差平方和 &lt;span class=&quot;math inline&quot;&gt;\({\rm SSR}\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;函数的前半部分解释了模型拟合优劣性，我们希望选择拟合程度好的模型，即方差小的模型；增加自由参数可以提高拟合的优良性，同时可能会出现过度拟合，于是引入后半部分用来惩罚那些复杂的模型。最后选择 &lt;span class=&quot;math inline&quot;&gt;\({\rm AIC}\)&lt;/span&gt; 值最小的模型，代表拟合优良性和模型简洁程度综合最佳的模型。实际操作过程中，我们以 &lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt; 的估计为例：假设模型可取阶数的上限为 &lt;span class=&quot;math inline&quot;&gt;\(p_0\)&lt;/span&gt; ，那么我们只需让 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 遍历 &lt;span class=&quot;math inline&quot;&gt;\(0,1,2,...,p_0\)&lt;/span&gt; ，选取 &lt;span class=&quot;math inline&quot;&gt;\({\rm AIC}\)&lt;/span&gt; 值的最小值点即为 &lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt; 的估计。&lt;/p&gt;
&lt;p&gt;还有 &lt;span class=&quot;math inline&quot;&gt;\({\rm BIC}\)&lt;/span&gt;（也称为 &lt;span class=&quot;math inline&quot;&gt;\({\rm SIC}\)&lt;/span&gt;）等信息准则，不同的信息准则会对模型的复杂性在不同的角度和强度上进行惩罚。&lt;/p&gt;
&lt;p&gt;\[{\rm BIC}(k)=\ln\hat\sigma_k^2+\frac{k\ln n}{n} \ . \]&lt;/p&gt;
&lt;h2 id=&quot;弱相依时间序列&quot;&gt;弱相依时间序列&lt;/h2&gt;
&lt;p&gt;当 &lt;span class=&quot;math inline&quot;&gt;\(h\)&lt;/span&gt; 无限增大时，如果 &lt;span class=&quot;math inline&quot;&gt;\(y_t\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(y_{t+h}\)&lt;/span&gt; 是“近乎独立”的，则这个序列被称为弱相依的（weakly dependent）。注意这个概念与时间序列是否平稳无关。&lt;/p&gt;
&lt;p&gt;在回归分析中使用弱相依序列之前不需要对它们做任何操作，可以直接使用 OLS 估计，因为这些序列的平均值满足大数定律和中心极限定理。&lt;/p&gt;
&lt;p&gt;含时间趋势的时间序列不是平稳序列，但是它是一个弱相依的时间序列。&lt;/p&gt;
&lt;p&gt;\[y_t=\alpha+\beta t+u_t \ , \]&lt;/p&gt;
&lt;p&gt;\[u_t\sim {\rm i.i.d.}\ {\rm WN}(0,\,\sigma_u^2) \ . \]&lt;/p&gt;
&lt;p&gt;\[{\rm E}(y_t)={\rm E}(\alpha+\beta t+u_t)=\alpha+\beta t \ , \]&lt;/p&gt;
&lt;p&gt;\[\gamma_h={\rm Cov}(y_t,\,y_{t+h})={\rm Cov}(u_t,\,u_{t+h})=0 \ . \]&lt;/p&gt;
&lt;p&gt;如果一个序列是弱相依的，而且在除掉了趋势之后是平稳的，则称其为趋势-平稳过程（trend-stationary process）。&lt;/p&gt;
&lt;h2 id=&quot;模型-10&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\({\rm ARIMA}(p,\,d,\,q)\)&lt;/span&gt; 模型&lt;/h2&gt;
&lt;p&gt;这里我们只简单介绍一些概念。&lt;/p&gt;
&lt;p&gt;对于一个非平稳序列 &lt;span class=&quot;math inline&quot;&gt;\(\{y_t\}\)&lt;/span&gt; 如果经过 &lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt; 次差分之后可以变成一个平稳时间序列，即 &lt;span class=&quot;math inline&quot;&gt;\(y_t\sim {\rm I}(d)\)&lt;/span&gt; ，如何建立时间序列模型？&lt;/p&gt;
&lt;p&gt;首先利用单位根检验找到 &lt;span class=&quot;math inline&quot;&gt;\(y_t\)&lt;/span&gt; 的单整阶数 &lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt; ，通过 &lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt; 次差分变换得到平稳时间序列 &lt;span class=&quot;math inline&quot;&gt;\(\{\Delta^d y_t\}\)&lt;/span&gt; ，对序列 &lt;span class=&quot;math inline&quot;&gt;\(\{\Delta^d y_t\}\)&lt;/span&gt; 建立 &lt;span class=&quot;math inline&quot;&gt;\({\rm ARMA}(p,\,q)\)&lt;/span&gt; 模型即可。&lt;/p&gt;
&lt;p&gt;这样的模型称为 &lt;span class=&quot;math inline&quot;&gt;\({\rm ARIMA}(p,\,d,\,q)\)&lt;/span&gt; 模型。&lt;/p&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;概括一下 &lt;span class=&quot;math inline&quot;&gt;\({\rm ARIMA}(p,\,d,\,q)\)&lt;/span&gt; 模型的建模一般步骤：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step.1&lt;/strong&gt; 先确定差分次数 &lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt; ：对序列进行 ADF 平稳性检验，如果非平稳，则对序列进行差分，并再次进行 ADF 平稳性检验，直到经过 &lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt; 次差分后变成平稳序列，此时 &lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt; 即为差分阶数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step.2&lt;/strong&gt; 确定 &lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt; ，对差分后的序列建立 &lt;span class=&quot;math inline&quot;&gt;\({\rm ARMA}\)&lt;/span&gt; 模型，利用 ACF 和 PACF 图像信息是否截尾和AIC、BIC信息准则确定最佳的参数 &lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step.3&lt;/strong&gt; 建模并估计参数，对回归后的残差序列进行白噪声的 &lt;span class=&quot;math inline&quot;&gt;\(Q\)&lt;/span&gt; 检验。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 15 Feb 2021 17:02:00 +0000</pubDate>
<dc:creator>李旭东东东东东阿东</dc:creator>
<og:description>主要介绍了时间序列分析中的AR，MA，ARMA等重要的典型模型的性质和选择方法。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lixddd/p/14405934.html</dc:identifier>
</item>
<item>
<title>数理统计11：区间估计，t分布，F分布 - 江景景景页</title>
<link>http://www.cnblogs.com/jy333/p/14405891.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jy333/p/14405891.html</guid>
<description>&lt;p&gt;在之前的十篇文章中，我们用了九篇文章的篇幅讨论了点估计的相关知识，现在来稍作回顾。&lt;/p&gt;
&lt;p&gt;首先，我们讨论了&lt;u&gt;正态分布&lt;/u&gt;两个参数——&lt;u&gt;均值&lt;/u&gt;、&lt;u&gt;方差&lt;/u&gt;的点估计，给出了它们的分布信息，并指出它们是&lt;u&gt;相互独立&lt;/u&gt;的；然后，我们讨论到其他的分布族，介绍了点估计的评判标准——&lt;u&gt;无偏性、相合性、有效性&lt;/u&gt;；之后，我们基于无偏性和相合性的讨论给出了常用分布的参数点估计，并介绍了两种常用于寻找点估计量的方法——&lt;u&gt;矩法&lt;/u&gt;与&lt;u&gt;极大似然法&lt;/u&gt;；最后，我们对点估计的有效性进行了讨论，给出了一些验证、寻找&lt;u&gt;UMVUE&lt;/u&gt;的方法，并介绍了&lt;u&gt;CR不等式&lt;/u&gt;，给出了无偏估计&lt;u&gt;效率&lt;/u&gt;的定义。以上就是我们在前九篇文章中提到的主要内容，还顺便介绍了一些常用的分布：&lt;span class=&quot;math inline&quot;&gt;\(\Gamma\)&lt;/span&gt;分布、&lt;span class=&quot;math inline&quot;&gt;\(\beta\)&lt;/span&gt;分布、&lt;span class=&quot;math inline&quot;&gt;\(\chi^2\)&lt;/span&gt;分布。&lt;/p&gt;
&lt;p&gt;今天开始，我们将进入区间估计与假设检验部分。由于本系列为我独自完成的，缺少审阅，&lt;strong&gt;如果有任何错误，欢迎在评论区中指出，谢谢&lt;/strong&gt;！&lt;/p&gt;
&lt;h2 id=&quot;part-1：什么是区间估计&quot;&gt;Part 1：什么是区间估计&lt;/h2&gt;
&lt;p&gt;区间估计同样是参数估计的一种方法，不同于点估计用样本计算出的一个统计量直接作为原始参数的估计，区间估计会根据抽取出的样本，计算出一个基于样本观测值的区间。简单说来，如果对总体&lt;span class=&quot;math inline&quot;&gt;\(f(x;\theta)\)&lt;/span&gt;中的参数&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;作估计，则首先从总体中获得样本&lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol{X}=(X_1,\cdots,X_n)\)&lt;/span&gt;，并确定两个&lt;strong&gt;具有确定大小关系&lt;/strong&gt;的统计量&lt;span class=&quot;math inline&quot;&gt;\(\hat g_1(\boldsymbol{X})\le \hat g_2(\boldsymbol{X})\)&lt;/span&gt;，根据样本观测值计算出的区间&lt;span class=&quot;math inline&quot;&gt;\([\hat g_1(\boldsymbol{X}),\hat g_2(\boldsymbol{X})]\)&lt;/span&gt;就是待估参数&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;的区间估计。&lt;/p&gt;
&lt;p&gt;由此，我们可以看出，区间估计依然是依赖于统计量的，并且往往需要不止一个统计量。区间估计相比于点估计的特点是，区间估计给出了一个相对“粗糙”的范围，这就导致你需要使用这个参数时，不像点估计一样能直接把估计值拿来用；但是，区间估计具有涵盖参数真值的可能，因为当参数空间&lt;span class=&quot;math inline&quot;&gt;\(\Theta\)&lt;/span&gt;的取值连续时，点估计&lt;span class=&quot;math inline&quot;&gt;\(\hat\theta\)&lt;/span&gt;与真值相等的可能性&lt;span class=&quot;math inline&quot;&gt;\(\mathbb{P}(\hat\theta=\theta)=0\)&lt;/span&gt;，但是区间估计包含真值的可能性&lt;span class=&quot;math inline&quot;&gt;\(\mathbb{P}(\theta\in[\hat g_1(\boldsymbol{X}),\hat g_2(\boldsymbol{X})])&amp;gt;0\)&lt;/span&gt;，这使得区间估计比起点估计而言，增加了一定的可靠性。&lt;/p&gt;
&lt;p&gt;这么说可能比较抽象，让我们举一个实际的例子，还记不记得第一篇文章中yhh送我们的橙子？厂家声称一箱子橙子的平均重量是80斤，而我们称量后发现橙子的平均重量是79.9斤，我们不能说厂家的声称是错误的，因为点估计与真值相等的概率为0。然而，我们通过某种手段得到了橙子重量的区间估计是&lt;span class=&quot;math inline&quot;&gt;\([79.5,80.5]\)&lt;/span&gt;斤，则你可能就会认为，橙子的重量极可能就落在这个范围内，与80斤相差不大，因此厂家的声称是可以接受的。&lt;/p&gt;
&lt;p&gt;区间估计还有另一方面的可靠性。在上面的讨论中，我们得到的点估计是79.9斤，如果换一箱橙子，它的重量不可能还是79.9斤了。但是，新一箱橙子的重量可能是70斤吗？可能性有多大？可能是80.1斤吗？可能性又有多大？点估计无法给出直观的感受，它只会让你觉得，80.1斤的概率要比70斤大点儿。但是，如果我们获得了这样的一个区间估计：&lt;span class=&quot;math inline&quot;&gt;\([79.5,80.5]\)&lt;/span&gt;，则你就会觉得80.1斤出现的可能性比较大点，而70斤几乎不可能出现。假如区间估计是&lt;span class=&quot;math inline&quot;&gt;\([60, 100]\)&lt;/span&gt;，则70斤和80.1斤就都很有可能出现了。这就是区间估计带来的好处，能让我们对预测的可能取值有更直观的感受。&lt;/p&gt;
&lt;p&gt;除了这种双侧都用统计量表示的区间估计，还存在一种单侧区间估计，即形如&lt;span class=&quot;math inline&quot;&gt;\((-\infty,u(\boldsymbol{X})]\)&lt;/span&gt;或者&lt;span class=&quot;math inline&quot;&gt;\([l(\boldsymbol{X}),+\infty)\)&lt;/span&gt;的区间估计。这一般代表我们只关注参数的一侧，而不关注另一侧，我们称这种区间估计为单侧区间估计。不过，这种区间估计不是我们所要关注的重点。&lt;/p&gt;
&lt;h2 id=&quot;part-2：如何评价区间估计&quot;&gt;Part 2：如何评价区间估计&lt;/h2&gt;
&lt;p&gt;最早接触过的，用一个区间来表示估计范围的，应该是高中所学的&lt;span class=&quot;math inline&quot;&gt;\(3\sigma\)&lt;/span&gt;原则：正态分布的取值落在&lt;span class=&quot;math inline&quot;&gt;\([\mu-3\sigma,\mu+3\sigma]\)&lt;/span&gt;之外的概率小于0.01。虽然这并非区间估计（务必注意这不是区间估计），但我们也能据此来感受区间估计的两大评价指标：&lt;strong&gt;精度&lt;/strong&gt;、&lt;strong&gt;可靠度&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;精度用区间估计的&lt;strong&gt;平均长度&lt;/strong&gt;来度量。为什么要加入“平均”二字呢？因为区间估计的上界和下界都是统计量，而统计量自身具有两重性，故区间长度&lt;span class=&quot;math inline&quot;&gt;\(\hat g_2(\boldsymbol{X})-\hat g_1(\boldsymbol{X})\)&lt;/span&gt;也是一个随机变量，其平均长度就是&lt;/p&gt;
&lt;p&gt;\[\mathbb{E}[\hat g_2(\boldsymbol{X})-\hat g_1(\boldsymbol{X})]. \]&lt;/p&gt;
&lt;p&gt;可靠度指的是待估参数&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;被包含在区间&lt;span class=&quot;math inline&quot;&gt;\([\hat g_1(\boldsymbol{X}),\hat g_2(\boldsymbol{X})]\)&lt;/span&gt;内的可能性，其量度不像精度那么容易度量，这里需要引入&lt;strong&gt;置信水平（置信度）&lt;/strong&gt;与&lt;strong&gt;置信系数&lt;/strong&gt;的概念。置信水平指的是&lt;span class=&quot;math inline&quot;&gt;\([\hat g_1(\boldsymbol{X}),\hat g_2(\boldsymbol{X})]\)&lt;/span&gt;包含待估参数&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;的概率，一般说来这个概率可能与&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;有关，在这种情况下，置信系数则是&lt;strong&gt;置信水平在&lt;span class=&quot;math inline&quot;&gt;\(\theta\in\Theta\)&lt;/span&gt;上的下确界&lt;/strong&gt;。这样，即使置信水平是一个关于&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;的函数，置信系数也是一个&lt;span class=&quot;math inline&quot;&gt;\([0,1]\)&lt;/span&gt;之间的常数，不过我们之后经常会取置信水平本身就是常数的区间作为待估参数的区间估计。&lt;/p&gt;
&lt;p&gt;显然，精度和可靠度是相互制约的，如果样本容量一定，精度低了可靠度就高，为使置信系数达到&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;，这个区间估计一般是&lt;span class=&quot;math inline&quot;&gt;\(\mathbb{R}\)&lt;/span&gt;。我们应当在精度和可靠度中相互权衡，来挑选合适的置信区间，为此，常使用Neyman建议的方案：&lt;strong&gt;在保证置信系数达到指定要求的前提下，尽可能提高精度&lt;/strong&gt;。即，首先我们需要对区间估计有一个预期的表现，在这个预期表现之下选择平均长度最小的区间估计。当然，预期的表现要合理，不能要一个&lt;span class=&quot;math inline&quot;&gt;\(100\%\)&lt;/span&gt;包含待估参数的蛮横要求，这样区间估计就会很尴尬。现行的教材一般要求这个置信系数是&lt;span class=&quot;math inline&quot;&gt;\(95\%\)&lt;/span&gt;，将其一般化，可以提出如下&lt;strong&gt;置信区间&lt;/strong&gt;的概念。&lt;/p&gt;
&lt;p&gt;设&lt;span class=&quot;math inline&quot;&gt;\([\hat \theta_1,\hat \theta_2]\)&lt;/span&gt;是参数&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;的一个区间估计，其中&lt;span class=&quot;math inline&quot;&gt;\(\hat\theta_1=\hat\theta_1(\boldsymbol{X})\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(\hat\theta_2=\hat\theta_2(\boldsymbol{X})\)&lt;/span&gt;。若对于给定的&lt;span class=&quot;math inline&quot;&gt;\(0&amp;lt;\alpha&amp;lt;1\)&lt;/span&gt;（常取&lt;span class=&quot;math inline&quot;&gt;\(\alpha=0.05\)&lt;/span&gt;），有&lt;/p&gt;
&lt;p&gt;\[\mathbb{P}(\theta\in[\hat\theta_1,\hat\theta_2])\ge 1-\alpha,\quad \forall\theta\in\Theta, \]&lt;/p&gt;
&lt;p&gt;则称&lt;span class=&quot;math inline&quot;&gt;\([\hat\theta_1,\hat\theta_2]\)&lt;/span&gt;是&lt;span class=&quot;math inline&quot;&gt;\(\hat\theta\)&lt;/span&gt;的&lt;strong&gt;置信水平&lt;/strong&gt;为&lt;span class=&quot;math inline&quot;&gt;\(1-\alpha\)&lt;/span&gt;的置信区间，该区间的置信系数就是&lt;span class=&quot;math inline&quot;&gt;\(\inf\limits_{\theta\in\Theta}\mathbb{P}(\theta\in[\hat\theta_1,\hat\theta_2])\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;我想，大多数读者应该此前已经听说过置信区间这个名词，只是不知道其官方定义是什么。注意到，置信区间的定义是基于Neyman建议的，即首要条件是保证置信水平，尽可能让精度小（不一定需要）。如果&lt;span class=&quot;math inline&quot;&gt;\(\mathbb{P}(\theta\in[\hat\theta_1,\hat\theta_2])\)&lt;/span&gt;在&lt;span class=&quot;math inline&quot;&gt;\(\theta\in\Theta\)&lt;/span&gt;上是一个常数，则置信度就是置信系数，这也是我们更经常处理的情况。&lt;/p&gt;
&lt;p&gt;对于单侧区间估计的情形，我们称满足&lt;span class=&quot;math inline&quot;&gt;\(\mathbb{P}(\theta\in[\hat\theta_l,\infty))\ge 1-\alpha\)&lt;/span&gt;或&lt;span class=&quot;math inline&quot;&gt;\(\mathbb{P}(\theta\in(-\infty,\hat\theta_u])\)&lt;/span&gt;的单侧置信区间端点&lt;span class=&quot;math inline&quot;&gt;\(\hat\theta_l,\hat\theta_u\)&lt;/span&gt;为置信水平为&lt;span class=&quot;math inline&quot;&gt;\(1-\alpha\)&lt;/span&gt;的&lt;strong&gt;置信限&lt;/strong&gt;。也就是说，“限”即上限或下限，描述的是单侧的置信区间。&lt;/p&gt;
&lt;p&gt;这样，我们就把区间估计部分的基本概念给阐释了一遍，但至于如何寻找区间估计，相信大多数读者依然不明白。这没有关系，阅读以上的部分，你只要明白Neyman的建议，以及什么叫置信区间、置信水平即可。&lt;/p&gt;
&lt;h2 id=&quot;part-3：分布和分布&quot;&gt;Part 3：&lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt;分布和&lt;span class=&quot;math inline&quot;&gt;\(F\)&lt;/span&gt;分布&lt;/h2&gt;
&lt;p&gt;在开始区间估计的寻找之前，我们需要介绍正态分布的另外两个衍生分布：&lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt;分布和&lt;span class=&quot;math inline&quot;&gt;\(F\)&lt;/span&gt;分布，它们在寻找正态分布区间估计的过程中会发挥重要的作用。&lt;/p&gt;
&lt;p&gt;首先是&lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt;分布。设随机变量&lt;span class=&quot;math inline&quot;&gt;\(X\sim N(0,1)\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(Y\sim \chi^2(n)\)&lt;/span&gt;，且&lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(Y\)&lt;/span&gt;相互独立，则&lt;/p&gt;
&lt;p&gt;\[T\xlongequal{def}\frac{X}{\sqrt{Y/n}}\sim t(n), \]&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;为&lt;strong&gt;自由度&lt;/strong&gt;。形式上，分子是标准正态随机变量，分母是&lt;span class=&quot;math inline&quot;&gt;\(\chi^2\)&lt;/span&gt;变量除以其自由度并开根号，&lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt;分布的自由度即&lt;span class=&quot;math inline&quot;&gt;\(\chi^2\)&lt;/span&gt;分布的自由度。&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;书上提到，&lt;span class=&quot;math inline&quot;&gt;\(t(n)\)&lt;/span&gt;分布的密度函数是&lt;/p&gt;
&lt;p&gt;\[p_n(x)=\frac{\Gamma(\frac{n+1}{2})}{\Gamma(\frac{n}{2})\sqrt{n\pi}}\left(1+\frac{x^2}{n} \right)^{-\frac{n+1}{2}}, \]&lt;/p&gt;
&lt;p&gt;这不是一个需要记忆的结论，证明也比较复杂，故在此不给出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;需要注意的是&lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt;分布的一些性质：&lt;/p&gt;
&lt;ol readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt;分布关于原点对称，即其密度函数是偶函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;随着自由度&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;增大，&lt;span class=&quot;math inline&quot;&gt;\(t(n)\)&lt;/span&gt;分布趋近于标准正态分布。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;若&lt;span class=&quot;math inline&quot;&gt;\(T\sim t(n)\)&lt;/span&gt;，则&lt;span class=&quot;math inline&quot;&gt;\(\mathbb{E}(T^r)\)&lt;/span&gt;只有当&lt;span class=&quot;math inline&quot;&gt;\(r&amp;lt;n\)&lt;/span&gt;时存在。特别当&lt;span class=&quot;math inline&quot;&gt;\(n\ge 2\)&lt;/span&gt;时，&lt;/p&gt;
&lt;p&gt;\[\mathbb{E}(T)=0, \]&lt;/p&gt;
&lt;p&gt;当&lt;span class=&quot;math inline&quot;&gt;\(n\ge 3\)&lt;/span&gt;时，&lt;/p&gt;
&lt;p&gt;\[\mathbb{D}(T)=\frac{n}{n-2}. \]&lt;/p&gt;
&lt;p&gt;显然其矩特征随着&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;增大，也趋近于&lt;span class=&quot;math inline&quot;&gt;\(N(0,1)\)&lt;/span&gt;的矩特征。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;自由度为&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;的&lt;span class=&quot;math inline&quot;&gt;\(t(1)\)&lt;/span&gt;分布就是柯西分布，密度为&lt;/p&gt;
&lt;p&gt;\[p(x)=\frac{1}{\pi(1+x^2)}. \]&lt;/p&gt;
&lt;p&gt;其任意阶矩不存在，常用于构造反例。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来介绍&lt;span class=&quot;math inline&quot;&gt;\(F\)&lt;/span&gt;分布。设随机变量&lt;span class=&quot;math inline&quot;&gt;\(X\sim \chi^2(m)\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(Y\sim \chi^2(n)\)&lt;/span&gt;，且&lt;span class=&quot;math inline&quot;&gt;\(X,Y\)&lt;/span&gt;相互独立，则&lt;/p&gt;
&lt;p&gt;\[F\xlongequal{def}\frac{X/m}{Y/n}\sim F(m,n), \]&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(m,n\)&lt;/span&gt;称为&lt;span class=&quot;math inline&quot;&gt;\(F\)&lt;/span&gt;分布的自由度，分子的自由度在前，分母的自由度在后。同样，&lt;span class=&quot;math inline&quot;&gt;\(F\)&lt;/span&gt;分布具有一些常用的性质：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;若&lt;span class=&quot;math inline&quot;&gt;\(Z\sim F(m,n)\)&lt;/span&gt;，则&lt;span class=&quot;math inline&quot;&gt;\(1/Z\sim F(n,m)\)&lt;/span&gt;，这由定义显然。&lt;/li&gt;
&lt;li&gt;若&lt;span class=&quot;math inline&quot;&gt;\(t\sim t(n)\)&lt;/span&gt;，则&lt;span class=&quot;math inline&quot;&gt;\(t^2\sim F(1,n)\)&lt;/span&gt;，这由定义显然。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这样，结合之前已经介绍过的&lt;span class=&quot;math inline&quot;&gt;\(\chi^2\)&lt;/span&gt;分布，我们就将正态分布的三大衍生分布介绍完毕了，尽管它们各自具有一定的性质，但其&lt;strong&gt;构造方式&lt;/strong&gt;是最重要的。这三大分布，都可以由正态分布随机变量构造而成（&lt;span class=&quot;math inline&quot;&gt;\(\chi^2\)&lt;/span&gt;变量也可以视为正态变量），结合正态分布所自带的变换性质，可以呈现出各种各样的变化。&lt;/p&gt;
&lt;p&gt;比如，如果&lt;span class=&quot;math inline&quot;&gt;\(X_1,\cdots,X_n\)&lt;/span&gt;是从正态总体&lt;span class=&quot;math inline&quot;&gt;\(N(\mu,\sigma^2)\)&lt;/span&gt;所抽取的简单随机样本，这里&lt;span class=&quot;math inline&quot;&gt;\(\mu,\sigma^2\)&lt;/span&gt;未知，所以&lt;span class=&quot;math inline&quot;&gt;\(\bar X,S^2\)&lt;/span&gt;的分布中肯定都带有未知参数，如果我们想消除未知参数的影响，可以参考正态分布的标准化过程：&lt;span class=&quot;math inline&quot;&gt;\((U-\mu)/\sigma\sim N(0,1)\)&lt;/span&gt;构造出不含未知参数的统计量。&lt;/p&gt;
&lt;p&gt;首先，由于&lt;span class=&quot;math inline&quot;&gt;\(\bar X\sim N(\mu,\sigma^2/n)\)&lt;/span&gt;，所以&lt;/p&gt;
&lt;p&gt;\[\frac{\sqrt{n}(\bar X-\mu)}{\sigma}\sim N(0,1), \]&lt;/p&gt;
&lt;p&gt;又由于&lt;/p&gt;
&lt;p&gt;\[\frac{(n-1)S^2}{\sigma^2}\sim \chi^2(n-1), \]&lt;/p&gt;
&lt;p&gt;所以有&lt;/p&gt;
&lt;p&gt;\[\frac{\frac{\sqrt{n}(\bar X-\mu)}{\sigma}}{\sqrt{\frac{(n-1)S^2}{\sigma^2}/(n-1)}}=\frac{\sqrt{n}(\bar X-\mu)}{S}\sim t(n-1). \]&lt;/p&gt;
&lt;p&gt;神奇的是，未知参数&lt;span class=&quot;math inline&quot;&gt;\(\sigma\)&lt;/span&gt;被消除了，所以我们得到了一个具有确定分布的统计量。这个方法，在下一篇文章中将发挥重要的作用，其他的变换我们也以后再展开。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;本文的前两个部分是区间估计的基本知识介绍，第三部分是正态分布的另外两个衍生分布，在下一篇文章中，我们将探索构造区间估计的方法。&lt;/p&gt;
</description>
<pubDate>Mon, 15 Feb 2021 16:25:00 +0000</pubDate>
<dc:creator>江景景景页</dc:creator>
<og:description>区间估计，t分布，F分布</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jy333/p/14405891.html</dc:identifier>
</item>
<item>
<title>云原生系列2 部署你的第一个k8s应用 - 李福春</title>
<link>http://www.cnblogs.com/snidget/p/14405714.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snidget/p/14405714.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/268922/202102/268922-20210215225417355-1968470713.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;云原生的概念和理论体系非常的完备，but talk is cheap , show me the code ! 但是作为一名程序员，能动手的咱绝对不多BB，虽然talk并不cheap , 能跟不同层次的人讲明白一件事情，本身就不是一件容易的事情。&lt;/p&gt;&lt;p&gt;引题用的图的意思： hello world !&lt;br/&gt;即部署你的第一个k8s应用。&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;准备你的应用程序；&lt;/li&gt;
&lt;li&gt;编写Dockerfile,制作镜像，并测试；&lt;/li&gt;
&lt;li&gt;编写yaml文件，找一个k8s资源，部署上线；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;初略的步骤，实际每个步骤做到都不简单，可以进一步拆分成很多二级步骤；后面安排单独的一篇来介绍。&lt;/p&gt;&lt;p&gt;为了节约时间，这里直接放一个nginx的例子。&lt;br/&gt;&lt;/p&gt;&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  selector:
    matchLables:
      app: nginx
  replicas: 2
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.7.9
        ports:
        - containerPort: 80
        volumeMounts:
        - mountPath: &quot;/usr/share/nginx/html&quot;
          name: nginx-vol
    volumes:
    - name: nginx-vol
      emptyDir: {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;h2 id=&quot;执行指令&quot;&gt;执行指令&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;kubectl apply -f you.yaml
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;按照标签筛选pod&quot;&gt;按照标签筛选pod&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;kubectl get pods -l app=xxx
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;查看pod对象定义&quot;&gt;查看pod对象定义&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;kubectl describe pod youpodname
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;进入容器内部&quot;&gt;进入容器内部&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;kubectl exec -it youpodname -- /bin/bash
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;h2 id=&quot;删除对象&quot;&gt;删除对象&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;kubectl delete -f you.yaml

kubectl delete deployments/youdeploymentname
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;deployment&quot;&gt;deployment&lt;/h2&gt;
&lt;p&gt;&lt;br/&gt;定义多副本的对象，当pod的定义发生变化的时候，滚动升级&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;pod&quot;&gt;pod&lt;/h2&gt;
&lt;p&gt;&lt;br/&gt;k8s世界中的应用，对应容器组，容器组里面有多个&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;元数据， 分为面向用户的label 和面向内部对象的annotation ;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;spec&quot;&gt;spec&lt;/h2&gt;
&lt;p&gt;&lt;br/&gt;即定义，每个对象的元素不一样，比如deployment 和 pod ;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;volume&quot;&gt;volume&lt;/h2&gt;
&lt;p&gt;&lt;br/&gt;即数据卷。 相对于pod来说，有两种数据卷、&lt;/p&gt;&lt;p&gt;emptyDir: 宿主机上的默认目录&lt;br/&gt;hostPath: 显示指定的宿主机的目录；&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;开发人员开发完程序之后，提供两个文件跟运维对接，提高devops体验；&lt;/p&gt;&lt;p&gt;Dockerfile : 制作镜像，标准化开发和部署环境；&lt;br/&gt;app.yaml： k8s的部署配置文件，标准化部署配置参数；&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/268922/202102/268922-20210215225418495-1476843207.png&quot; alt=&quot;第一个k8s容器化应用.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;原创不易，关注诚可贵，转发价更高！转载请注明出处，让我们互通有无，共同进步，欢迎沟通交流。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 15 Feb 2021 14:54:00 +0000</pubDate>
<dc:creator>李福春</dc:creator>
<og:description>云原生的概念和理论体系非常的完备，but talk is cheap , show me the code ! 但是作为一名程序员，能动手的咱绝对不多BB，虽然talk并不cheap , 能跟不同层次</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/snidget/p/14405714.html</dc:identifier>
</item>
<item>
<title>自己写代码实现邮件发送，再也不用可视化那么麻烦了！ - lalala_py</title>
<link>http://www.cnblogs.com/lalala-py/p/14405699.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lalala-py/p/14405699.html</guid>
<description>&lt;p&gt;原文地址：&lt;a href=&quot;https://www.keketec.club/posts/a6c96c4e/&quot; target=&quot;_blank&quot;&gt;https://www.keketec.club/posts/a6c96c4e/&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;学而知不足，长按关注，精彩不错过&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Python自动批量发送邮件是一种什么体验？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2193560/202101/2193560-20210106180500312-291032448.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;很多时候，我们在发送一些邮件信息的时候，在可视化的界面巴拉巴拉操作一顿，其实就是一些很简单的信息，然后可能发送的收信者比较多，带来很多的麻烦，主要是浪费了我们的时间！&lt;/p&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;准备工作&lt;/h2&gt;
&lt;p&gt;很重要重要重要的准备工作，带你进入代码发送邮件的氛围！&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;看着前面小哥哥把每个订单号都粘贴到邮件里，然后再给一个收件人的联系邮箱，如此熟练的操作，整整做了一个上午，因为需要给每个收件人单独发送，我心里有种说不出来的感觉 ...&lt;/p&gt;
&lt;p&gt;这就像刚刚工作那会儿看着旁边跟我一样的实习生在重复插入sql一样，他居然不知道列编辑，然而要一行一行一个字一个字的敲进去一样的感受。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;如果有不知道的同学也可以私信我，几分钟的事情可能对于不知道这个技巧的同学需要几个小时才能完成&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;进行正题！！！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自动化发邮件之前，首先需要用到的两个重要的 Python 模块：smtplib 和 email&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;smtplib模块主要用来建立服务器链接、服务器断开的工作；&lt;/p&gt;
&lt;p&gt;email模块主要负责邮件的构建，比如收件人、邮件标题、邮件内容等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我用的是python2.7版本，所以安装这两个库：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;pip2.7 install secure-smtplib
pip2.7 install email
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装准备好需要的包，下面就开始发送邮件的操作，实例化操作&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 实例化SMTP
smtp = smtplib.SMTP()
# 链接邮件服务器
smtp.connect(smtp_addr)
# 配置发送邮箱的用户名和密码
smtp.login(login_user, login_passwd)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MIMEText 类是 MIMENonMultipart 类的子类，一般用于用于封装文本类型的邮件&lt;/p&gt;
&lt;p&gt;实例化邮件服务器信息，可以进行相应的配置，邮件的标题、邮件的收发邮件信息、当然还可以进行抄送&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 邮件正文
words = &quot;First Message&quot;
# 配置发送内容msg
msg = MIMEText(words, 'plain', 'utf-8')
# 邮件标题
msg['Subject'] = Header(&quot;MyTestTitle&quot;,'utf-8')
# 发信人地址
msg['from'] = sender
# 收信人地址（支持群发）
msg['to'] = ';'.join([receiver])
# 抄送人地址（支持群发）
msg['Cc'] = ';'.join([receiver])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在完成了以上的操作之后，然后配置自己的信息就可以进行操作发送了。&lt;/p&gt;
&lt;p&gt;当然在我给到的代码中，都是以变量给出的，首先咱们需要初始化&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 发送者邮箱（改为自己的）
sender = &quot;xxx@163.com&quot;
# 接受者邮箱（改为自己的）
receiver = &quot;xxx@qq.com&quot;
# 服务器地址
smtp_addr = &quot;smtp.163.com&quot;
# 邮件服务器账号和密码，自己的163邮箱的登录账号和密码
login_user = &quot;xxx@163.com&quot;
login_passwd = &quot;xxx&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，关键一步，可以发送了，但是记得要关闭连接哦！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数格式：&lt;/strong&gt;&lt;code&gt;sendmail(self, from_addr, to_addrs, msg, mail_options=[], rcpt_options=[])&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 发送邮件
smtp.sendmail(sender, receiver, msg.as_string())
smtp.quit()
print(&quot;邮件发送成功 ^_^ &quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;哈哈，看看我的界面，已经收到了哈！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2193560/202101/2193560-20210106180528301-1177490985.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;跟着试了的同学以及攻城狮们，成功了没有&lt;/p&gt;
&lt;p&gt;需要我发送代码的，给我留言哈，可以公号后台私信我吆！！&lt;/p&gt;
&lt;p&gt;也可以自取哈！地址: &lt;a href=&quot;https://pan.baidu.com/s/1At5rsu59QZ0BLQ6ETpPEvw&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/1At5rsu59QZ0BLQ6ETpPEvw&lt;/a&gt; 密码: s8ew&lt;/p&gt;
&lt;h2 id=&quot;发送其他格式的邮件&quot;&gt;发送其他格式的邮件&lt;/h2&gt;
&lt;p&gt;上述展示了普通格式的邮件发送格式，下面咱们再看看想要发送一些HTML格式的，还有带附件的邮件形式。&lt;/p&gt;
&lt;p&gt;再然后就可以自行发挥发送任何格式和组合的邮件了！&lt;/p&gt;
&lt;h3 id=&quot;1-发送-html-格式的邮件&quot;&gt;1. 发送 HTML 格式的邮件&lt;/h3&gt;
&lt;p&gt;在创建 MIMEText 时，将 _subtype 设置为 “html”，则可发送 html 格式的邮件&lt;/p&gt;
&lt;p&gt;其他步骤和发送纯文本邮件配置和代码格式都一致&lt;/p&gt;
&lt;p&gt;跟上面文本格式邮件对比下哈，会有很清晰的思路：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 普通文本格式
msg = MIMEText(words, 'plain', 'utf-8')
# html 格式
msg = MIMEText(words, 'plain', 'utf-8')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;贴出详细代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 邮件正文
words = &quot;&quot;&quot;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;table border=&quot;1&quot;&amp;gt;
            &amp;lt;tr&amp;gt;
                &amp;lt;th&amp;gt;Python&amp;lt;/th&amp;gt;
                &amp;lt;th&amp;gt;编程爱好者&amp;lt;/th&amp;gt;
            &amp;lt;/tr&amp;gt;
            &amp;lt;tr&amp;gt;
                &amp;lt;td&amp;gt;需要代码的同学&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;加我微信&amp;lt;/td&amp;gt;
            &amp;lt;/tr&amp;gt;
            &amp;lt;tr&amp;gt;
                &amp;lt;td&amp;gt;Johngo106X&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;双手奉上！&amp;lt;/td&amp;gt;
            &amp;lt;/tr&amp;gt;
        &amp;lt;/table&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&quot;&quot;&quot;
# 配置发送内容msg
msg = MIMEText(words, 'html', 'utf-8')
# 邮件标题
msg['Subject'] = Header(&quot;测试发送HTML信息&quot;,'utf-8')
# 发信人地址
msg['from'] = sender
# 收信人地址（支持群发）
msg['to'] = ';'.join([receiver])
# 抄送人地址（支持群发）
msg['Cc'] = ';'.join([receiver])

# 实例化SMTP
smtp = smtplib.SMTP()
# 链接邮件服务器
smtp.connect(smtp_addr)
# 配置发送邮箱的用户名和密码
smtp.login(login_user, login_passwd)
# 发送邮件
smtp.sendmail(sender, receiver, msg.as_string())
smtp.quit()
print(&quot;邮件发送成功!&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一些自定义的变量可以自己设置哈，全量代码可以在网盘中自取！！！&lt;/p&gt;
&lt;p&gt;哈， 再看看 Johngo 的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2193560/202101/2193560-20210106180638283-1752666923.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面再看看重要的附件，是怎么操作的&lt;/p&gt;
&lt;h3 id=&quot;2-发送带有附件的邮件&quot;&gt;2. 发送带有附件的邮件&lt;/h3&gt;
&lt;p&gt;类似的操作方法，不同的操作是实例化发送信息的这块稍有区别&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 配置发送内容msg
msg = MIMEMultipart()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样的我先把代码附上，需要详细代码的请自取&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 邮件正文
words = &quot;&quot;&quot;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;table border=&quot;1&quot;&amp;gt;
            &amp;lt;tr&amp;gt;
                &amp;lt;th&amp;gt;Python&amp;lt;/th&amp;gt;
                &amp;lt;th&amp;gt;编程爱好者&amp;lt;/th&amp;gt;
            &amp;lt;/tr&amp;gt;
            &amp;lt;tr&amp;gt;
                &amp;lt;td&amp;gt;需要代码的同学&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;加我微信&amp;lt;/td&amp;gt;
            &amp;lt;/tr&amp;gt;
            &amp;lt;tr&amp;gt;
                &amp;lt;td&amp;gt;Johngo106X&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;双手奉上！&amp;lt;/td&amp;gt;
            &amp;lt;/tr&amp;gt;
            &amp;lt;tr&amp;gt;
                &amp;lt;td&amp;gt;原文链接&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;xxx&amp;lt;/td&amp;gt;
            &amp;lt;/tr&amp;gt;
        &amp;lt;/table&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&quot;&quot;&quot;
# 配置发送内容msg
msg = MIMEMultipart()
# 邮件正文
msg.attach(payload=MIMEText(words, _subtype=&quot;html&quot;, _charset=&quot;utf-8&quot;))
# 邮件标题
msg['Subject'] = Header(&quot;附件邮件发送测试&quot;,'utf-8')
# 发信人地址
msg['from'] = sender
# 收信人地址（支持群发）
msg['to'] = ';'.join([receiver])
# 抄送人地址（支持群发）
msg['Cc'] = ';'.join([receiver])


for file_path in {&quot;test1.xlsx&quot;, &quot;test2.xlsx&quot;}:
        attachment = MIMEText(_text=open(file_path, &quot;rb&quot;).read(), _subtype=&quot;base64&quot;, _charset=&quot;utf-8&quot;)
        attachment[&quot;Content-Type&quot;] = &quot;application/octet-stream&quot;
        attachment[&quot;Content-Disposition&quot;] = &quot;attachment; filename=%s&quot; % file_path
        msg.attach(payload=attachment)


# 实例化SMTP
smtp = smtplib.SMTP()
# 链接邮件服务器
smtp.connect(smtp_addr)
# 配置发送邮箱的用户名和密码
smtp.login(login_user, login_passwd)
# 发送邮件
smtp.sendmail(sender, receiver, msg.as_string())
smtp.quit()
print(&quot;邮件发送成功!&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样的，咱们看看附件过来了没有&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2193560/202101/2193560-20210106180600843-1580139482.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;end&quot;&gt;End&lt;/h2&gt;
&lt;p&gt;比较简单的几行代码，在某些时候就可以将事情事半功倍，适用于定时发邮件、快速自定义的发送相同文件内容的场景&lt;/p&gt;
&lt;p&gt;代码先放到网盘，就暂且不往github上传了，地址链接: &lt;a href=&quot;https://pan.baidu.com/s/1At5rsu59QZ0BLQ6ETpPEvw&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/1At5rsu59QZ0BLQ6ETpPEvw&lt;/a&gt; 密码: s8ew，自取哈！！&lt;/p&gt;
&lt;p&gt;另外，我给到的是最基本的 Python 自定义发送邮件的操作，拿到手的同学和攻城狮们可以进行再次封装，更加好用一些。同时也可以分享出来&lt;/p&gt;
&lt;p&gt;好了，今天就是有关自定义发送邮件小工具的全部分享内容了，如果感觉对你有些许帮助，还请轻轻点击转发，让更多的人看到，对 Johngo 来说，有莫大的帮助！&lt;/p&gt;
&lt;p&gt;文中有任何错误的地方，烦请不吝赐教。非常感谢!&lt;/p&gt;
</description>
<pubDate>Mon, 15 Feb 2021 14:49:00 +0000</pubDate>
<dc:creator>lalala_py</dc:creator>
<og:description>原文地址：https://www.keketec.club/posts/a6c96c4e/ 学而知不足，长按关注，精彩不错过 Python自动批量发送邮件是一种什么体验？ 前言 很多时候，我们在发送一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lalala-py/p/14405699.html</dc:identifier>
</item>
<item>
<title>MacOS微信逆向分析-Frida - EOF0XF</title>
<link>http://www.cnblogs.com/Huerye/p/14405687.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Huerye/p/14405687.html</guid>
<description>&lt;h2 id=&quot;macos微信逆向分析-frida&quot;&gt;MacOS微信逆向分析-Frida&lt;/h2&gt;
&lt;h3 id=&quot;0前言&quot;&gt;0.前言&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;PC下的微信二次开发相信大家都会了，那么本篇文章将带领大家使用Frida框架对Mac下微信来进行&lt;strong&gt;二次开发&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;PS：还有一种静态注入的方式也不错，但是考虑到大家xcode安装包太大就不在这里展开啦。&lt;/p&gt;
&lt;p&gt;PS：frida如何去使用大家得自己去学，本文不过多展开。&lt;/p&gt;
&lt;p&gt;主要功能涉及如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;微信消息发送&lt;/li&gt;
&lt;li&gt;微信消息监听&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;1微信版本&quot;&gt;1.微信版本&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/Huerye/1068060/o_210215144110image-20210215202805857.png&quot; alt=&quot;image-20210215202805857&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2工具&quot;&gt;2.工具&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;预先善其事，必先利其器！请先准备如下分析工具&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.hopperapp.com/&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;Hopper&lt;/em&gt; Disassembler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stevenygard.com/projects/class-dump/&quot; target=&quot;_blank&quot;&gt;Class-dump&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://frida.re/&quot; target=&quot;_blank&quot;&gt;Frida&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jetbrains.com/&quot; target=&quot;_blank&quot;&gt;Pycharm&lt;/a&gt;(可选)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://code.visualstudio.com/&quot; target=&quot;_blank&quot;&gt;Vscode&lt;/a&gt;（可选）&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;3dump-出头文件&quot;&gt;3.&lt;strong&gt;Dump 出头文件&lt;/strong&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;首先利用Class-Dump拿到微信的头文件，打开终端执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;class-dump -H /Applications/WeChat.app
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;成功执行之后会生成很多的头文件了,如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;-rw-r--r--  1 n  staff   927B  2 15 19:19 WXCPbQcwxtalkPackage.h
-rw-r--r--  1 n  staff   975B  2 15 19:19 WXCPbReportItem.h
-rw-r--r--  1 n  staff   1.7K  2 15 19:19 WXCPbSCAddVoiceGroupMemberResp.h
-rw-r--r--  1 n  staff   772B  2 15 19:19 WXCPbSCCancelCreateVoiceGroupResp.h
-rw-r--r--  1 n  staff   7.2K  2 15 19:19 WXCPbSCCreateVoiceGroupResp.h
-rw-r--r--  1 n  staff   6.9K  2 15 19:19 WXCPbSCEnterVoiceRoomResp.h
-rw-r--r--  1 n  staff   1.1K  2 15 19:19 WXCPbSCExitVoiceRoomResp.h
-rw-r--r--  1 n  staff   1.2K  2 15 19:19 WXCPbSCModifyVoiceGroupInfoResp.h
-rw-r--r--  1 n  staff   872B  2 15 19:19 WXCPbSCSubscribeLargeVideoResp.h
-rw-r--r--  1 n  staff   867B  2 15 19:19 WXCPbSCSubscribeVideoResp.h
-rw-r--r--  1 n  staff   2.0K  2 15 19:19 WXCPbSCVoiceClientSceneReportResp.h
-rw-r--r--  1 n  staff   864B  2 15 19:19 WXCPbSCVoiceGetGroupInfoBatchResp.h
-rw-r--r--  1 n  staff   637B  2 15 19:19 WXCPbSCVoiceMemberWhisperResp.h
-rw-r--r--  1 n  staff   5.9K  2 15 19:19 WXCPbSCVoiceRedirectResp.h
-rw-r--r--  1 n  staff   1.1K  2 15 19:19 WXCPbSCVoiceRoomHelloResp.h
-rw-r--r--  1 n  staff   904B  2 15 19:19 WXCPbSKBuiltinBuffer_t.h
-rw-r--r--  1 n  staff   686B  2 15 19:19 WXCPbSubscribeVideoMember.h
-rw-r--r--  1 n  staff   2.7K  2 15 19:19 WXCPbSwitchVideoGroupResp.h
-rw-r--r--  1 n  staff   1.4K  2 15 19:19 WXCPbVideoGroupMember.h
-rw-r--r--  1 n  staff   671B  2 15 19:19 WXCPbVoiceClientScene.h
-rw-r--r--  1 n  staff   1.2K  2 15 19:19 WXCPbVoiceClientSceneExt.h
-rw-r--r--  1 n  staff   2.9K  2 15 19:19 WXCPbVoiceConf.h
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;4分析&quot;&gt;4.分析&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;首先那么多的文件我们肯定不能一个个的去看，那样效率太低。相信大家做开发为了自己好维护代码，肯定不会给对象随便命名为abc这种吧！不会吧！不会吧！真的有这种人啊！！！但是我相信腾讯的程序员肯定不会这么做！！微信核心的功能是啥？是发消息哦，那么消息的英文是啥？&lt;strong&gt;Message&lt;/strong&gt; ！对就是他。所以我们就先塞选下这个&lt;strong&gt;Message&lt;/strong&gt;！&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# n @ localhost in ~/vscodewsp/wechat/dump [20:58:22]
$ ll |wc -l
    4922

# n @ localhost in ~/vscodewsp/wechat/dump [20:58:29]
$ ll -l |grep Message|wc -l
     157

# n @ localhost in ~/vscodewsp/wechat/dump [20:58:42]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行如上命令我们把文件数从4922个转变到157了。这样就缩小了范围啦！如何再次缩小范围尼！那么就得是看大家的开发习惯啦，我一般做业务我都喜欢写service，controller，这种业务类名，于是我再次....&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# n @ localhost in ~/vscodewsp/wechat/dump [20:58:42]
$ ll -l |grep Message|grep Service|wc -l
       9

# n @ localhost in ~/vscodewsp/wechat/dump [21:02:13]
$ ll -l |grep Message|grep Service
-rw-r--r--  1 n  staff   5.1K  2 15 19:19 FTSFileMessageService.h
-rw-r--r--  1 n  staff   382B  2 15 19:19 IMessageServiceAppExt-Protocol.h
-rw-r--r--  1 n  staff   980B  2 15 19:19 IMessageServiceFileExt-Protocol.h
-rw-r--r--  1 n  staff   381B  2 15 19:19 IMessageServiceFileReTransferExt-Protocol.h
-rw-r--r--  1 n  staff   755B  2 15 19:19 IMessageServiceImageExt-Protocol.h
-rw-r--r--  1 n  staff   780B  2 15 19:19 IMessageServiceVideoExt-Protocol.h
-rw-r--r--  1 n  staff   407B  2 15 19:19 IMessageServiceVideoReTransferExt-Protocol.h
-rw-r--r--  1 n  staff   3.1K  2 15 19:19 MMFTSMessageService.h
-rw-r--r--  1 n  staff    20K  2 15 19:19 MessageService.h

# n @ localhost in ~/vscodewsp/wechat/dump [21:02:25]
$
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;哎呦哎呦，就剩9个文件啦？？？那么这个一个个看也不碍事！！有时间就是任性！！！哼。最终定位到&lt;strong&gt;MessageService.h&lt;/strong&gt; 打开一看，果然尼！真是运气好！&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;- (id)SendLocationMsgFromUser:(id)arg1 toUser:(id)arg2 withLatitude:(double)arg3 longitude:(double)arg4 poiName:(id)arg5 label:(id)arg6;
- (id)SendNamecardMsgFromUser:(id)arg1 toUser:(id)arg2 containingContact:(id)arg3;
- (id)SendStickerStoreEmoticonMsgFromUsr:(id)arg1 toUsrName:(id)arg2 md5:(id)arg3 productID:(id)arg4;
- (id)SendEmoticonMsgFromUsr:(id)arg1 toUsrName:(id)arg2 md5:(id)arg3 emoticonType:(unsigned int)arg4;
- (id)SendImgMessage:(id)arg1 toUsrName:(id)arg2 thumbImgData:(id)arg3 midImgData:(id)arg4 imgData:(id)arg5 imgInfo:(id)arg6;
- (id)SendTextMessage:(id)arg1 toUsrName:(id)arg2 msgText:(id)arg3 atUserList:(id)arg4;
- (id)SendAppMusicMessageFromUser:(id)arg1 toUsrName:(id)arg2 withTitle:(id)arg3 url:(id)arg4 description:(id)arg5 thumbnailData:(id)arg6;
- (id)SendAppURLMessageFromUser:(id)arg1 toUsrName:(id)arg2 withTitle:(id)arg3 url:(id)arg4 description:(id)arg5 thumbnailData:(id)arg6;
- (id)SendAppURLMessageFromUser:(id)arg1 toUsrName:(id)arg2 withTitle:(id)arg3 url:(id)arg4 description:(id)arg5 thumbUrl:(id)arg6 sourceUserName:(id)arg7 sourceDisplayName:(id)arg8;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你看这功能不就来了嘛？Send开头的都是发送消息的函数啊。OK完事。那么就开始搞它！&lt;/p&gt;
&lt;p&gt;PS：其实分析时候还是挺费事的，但是大家自己多动手肯定能找到的！&lt;/p&gt;
&lt;h3 id=&quot;5fridahook验证&quot;&gt;5.FridaHook验证&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;为了验证自己的分析是不是正确的，我们得进行验证啊，怎么验证？frida大法好！执行以下命令：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;frida-trace -m &quot;-[MessageService Send*]&quot; 微信&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ frida-trace -m &quot;-[MessageService Send*]&quot; 微信
Instrumenting...                                                        
-[MessageService SendTextMessageWithString:toUser:]: Auto-generated handler at &quot;/Users/n/vscodewsp/wechat/__handlers__/MessageService/SendTextMessageWithString_toUser_.js&quot;
-[MessageService SendAppURLMessageFromUser:toUsrName:withTitle:url:description:thumbUrl:sourceUserName:sourceDisplayName:]: Auto-generated handler at &quot;/Users/n/vscodewsp/wechat/__handlers__/MessageService/SendAppURLMessageFromUser_toUsrN_eaefd0af.js&quot;
------------------------------------------------------------------------------
-[MessageService SendNamecardMsgFromUser:toUser:containingContact:]: Auto-generated handler at &quot;/Users/n/vscodewsp/wechat/__handlers__/MessageService/SendNamecardMsgFromUser_toUser_c_b5899e8d.js&quot;
Started tracing 18 functions. Press Ctrl+C to stop.  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后会在当前目录生成__handlers__文件夹，里面是frida为我们自动生成的hook脚本文件。我们使用微信发送一条消息试试。&lt;/p&gt;
&lt;p&gt;然后终端会输出一条信息：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;195323 ms -[MessageService SendTextMessage:0x600000b6fae0 toUsrName:0x6503cfa934d442eb msgText:0x6000002ec860 atUserList:0x600000a73570]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个就是触发了发送消息的hook信息啦。&lt;strong&gt;SendTextMessage&lt;/strong&gt; 是不是跟我们在头文件信息里面看到的一样。&lt;/p&gt;
&lt;p&gt;我们找到handles文件夹下&lt;strong&gt;SendTextMessage&lt;/strong&gt;这个js文件，试试修改log输出然后再执行&lt;/p&gt;
&lt;p&gt;&lt;code&gt;frida-trace -m &quot;-[MessageService Send*]&quot; 微信&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到输出变啦&lt;br/&gt;&lt;code&gt;2908 ms -[我的消息测试 SendTextMessage:0x600000b6fae0 toUsrName:0x6503cfa934d442eb msgText:0x6722df8306c2767b atUserList:0x6000009c2760]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如此可以确定我们找到的函数就是发送消息的函数。那么看看能不能打印出自己发送的消息内容&lt;/p&gt;
&lt;p&gt;&lt;code&gt;- (id)SendTextMessage:(id)arg1 toUsrName:(id)arg2 msgText:(id)arg3 atUserList:(id)arg4;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可以看到这个函数一共有4个参数：参数一：暂时不知道。参数二：toUsrName，我们可以知道是消息发送给谁的。参数三：msgText 消息内容，消息四：暂时不知道&lt;/p&gt;
&lt;p&gt;分别把这四个参数给打印出来试试！修改js文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;onEnter(log, args, state) {
    console.log(`-[我的消息测试 SendTextMessage:${args[2]} toUsrName:${args[3]} msgText:${args[4]} atUserList:${args[5]}]`);
    console.log(&quot;arg[1] -&amp;gt; &quot; + new ObjC.Object(args[2]))
    console.log(&quot;arg[2] -&amp;gt; &quot; + new ObjC.Object(args[3]))
    console.log(&quot;arg[3] -&amp;gt; &quot; + new ObjC.Object(args[4]))
    console.log(&quot;arg[4] -&amp;gt; &quot; + new ObjC.Object(args[5]))
  },
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后执行 &lt;code&gt;frida-trace -m &quot;-[MessageService Send*]&quot; 微信&lt;/code&gt; 发送一条消息&lt;/p&gt;
&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/Huerye/1068060/t_210215144119image-20210215213140430.png?a=1613400169856&quot; alt=&quot;image-20210215213140430&quot;/&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;arg[1] -&amp;gt; wxid_*****63i822
arg[2] -&amp;gt; filehelper
arg[3] -&amp;gt; 这个是消息测试
arg[4] -&amp;gt; 
           /* TID 0x307 */
 14534 ms  -[我的消息测试 SendTextMessage:0x600000b6fae0 toUsrName:0x6503cfa934d442eb msgText:0x600000adefd0 atUserList:0x600000add470]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到终端正确响应了，输出的正是我们发送的消息。那么我修改发送内容试试？？添加如下代码：&lt;/p&gt;
&lt;p&gt;​ &lt;code&gt;args[4] = ObjC.classes.NSString.stringWithString_(&quot;MacOS微信分析&quot;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后微信发送任何消息，对方都将收到的是&lt;strong&gt;MacOS微信分析&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/Huerye/1068060/t_210215144124image-20210215214021233.png?a=1613400169856&quot; alt=&quot;image-20210215214021233&quot;/&gt;&lt;p&gt;这样我们就确定了发送文本消息的函数就是这个。那么我们如何主动调用它呢？&lt;/p&gt;
&lt;h3 id=&quot;6hopper分析程序代码&quot;&gt;6.Hopper分析程序代码&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;从上面的分析我们看到发送消息需要四个参数。第一个：通过分析应该是我们自己的微信id，第二个：对方的微信id，第三个：消息内容，第四个：可以为null&lt;/p&gt;
&lt;p&gt;那么就打开hopper拖入微信具体分析分析吧&lt;/p&gt;
&lt;p&gt;应用程序-&amp;gt;微信-&amp;gt;显示包内容-&amp;gt;Contents-&amp;gt;MacOS-&amp;gt;WeChat 拖进hopper然后默认选项即可&lt;/p&gt;
&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/Huerye/1068060/o_210215144131image-20210215215141505.png&quot; alt=&quot;image-20210215215141505&quot;/&gt;&lt;p&gt;在左边输入&lt;strong&gt;SendTextMessage&lt;/strong&gt;搜索我们可以看到上面四个应该是我们所需要的，都打开看下伪代码。（我们分析需要找到函数调用的地方就能知道传参，然后再去分析参数是如何而来。那么除了函数定义地方代码，其余的都可以找到。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MMMessageSendLogic&lt;/strong&gt; ：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;/* @class MMMessageSendLogic */
-(unsigned char)sendTextMessageWithString:(void *)arg2 mentionedUsers:(void *)arg3 {
    r14 = self;
    r15 = [arg2 retain];
    r12 = [arg3 retain];
    r13 = [[CUtility filterStringForTextMessage:r15] retain];
    [r15 release];
    if ([r13 length] != 0x0) {
            stack[-64] = r12;
            rax = [r13 lengthOfBytesUsingEncoding:0x4];
            rbx = rax;
            if (rax &amp;gt;= 0x4001) {
                    rax = [[NSString alloc] initWithFormat:@&quot;ERROR: Text too long, length: %lu, utf8 length: %lu&quot;, [r13 length], rbx];
                    stack[0] = &quot;-[MMMessageSendLogic sendTextMessageWithString:mentionedUsers:]&quot;;
                    [MMLogger logWithMMLogLevel:0x2 module:&quot;ComposeInputView&quot; file:0x103e0e162 line:0x112 func:stack[0] message:rax];
                    [rax release];
                    rax = [NSBundle mainBundle];
                    rax = [rax retain];
                    stack[-72] = rax;
                    r15 = [[rax localizedStringForKey:@&quot;Message.Input.Too.Long.Title&quot; value:@&quot;&quot; table:0x0] retain];
                    rax = [NSBundle mainBundle];
                    rax = [rax retain];
                    r14 = rax;
                    rax = [rax localizedStringForKey:@&quot;Message.Input.Too.Long.Content&quot; value:@&quot;&quot; table:0x0];
                    rax = [rax retain];
                    [NSAlert showAlertSheetWithTitle:r15 message:rax completion:0x0];
                    [rax release];
                    [r14 release];
                    [r15 release];
                    [stack[-72] release];
                    r14 = 0x0;
                    r12 = stack[-64];
            }
            else {
                    rax = [WeChat sharedInstance];
                    rax = [rax retain];
                    r15 = [[rax CurrentUserName] retain];
                    [rax release];
                    rax = [r14 currnetChatContact];
                    rax = [rax retain];
                    r14 = [[rax m_nsUsrName] retain];
                    [rax release];
                    r12 = [[MMServiceCenter defaultCenter] retain];
                    objc_unsafeClaimAutoreleasedReturnValue([[[r12 getService:[MessageService class]] retain] SendTextMessage:r15 toUsrName:r14 msgText:r13 atUserList:stack[-64]]);
                    [rax release];
                    [r12 release];
                    [r14 release];
                    [r15 release];
                    r14 = 0x1;
                    r12 = stack[-64];
                    r13 = r13;
            }
    }
    else {
            rax = [[NSString alloc] initWithFormat:@&quot;ERROR: Text is empty, can't send&quot;];
            stack[0] = &quot;-[MMMessageSendLogic sendTextMessageWithString:mentionedUsers:]&quot;;
            [MMLogger logWithMMLogLevel:0x2 module:&quot;ComposeInputView&quot; file:0x103e0e162 line:0x10c func:stack[0] message:rax];
            [rax release];
            r14 = 0x0;
    }
    [r13 release];
    [r12 release];
    rax = r14 &amp;amp; 0xff;
    return rax;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个伪代码看的就比较清楚了，&lt;/p&gt;
&lt;p&gt;&lt;code&gt;objc_unsafeClaimAutoreleasedReturnValue([[[r12 getService:[MessageService class]] retain] SendTextMessage:r15 toUsrName:r14 msgText:r13 atUserList:stack[-64]]);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到第一个参数是r15，网上追溯r15，&lt;/p&gt;
&lt;p&gt;&lt;code&gt;r15 = [[rax CurrentUserName] retain];&lt;/code&gt; r15是这里赋值的，那么再看看CurrentUserName方法内容。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;-(void *)CurrentUserName {
    if ([self isLoggedIn] != 0x0) {
            rdi = [[CUtility GetCurrentUserName] retain];
    }
    else {
            rdi = 0x0;
    }
    rax = [rdi autorelease];
    return rax;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到是先判断是不是已经登录，然后调用CUtility类里面的GetCurrentUserName方法获得的。那么第一个参数我们就知道了。其余三个参数我们也很容易的可以手动构造。我们编写js脚本代码&lt;/p&gt;
&lt;h3 id=&quot;7编写frida脚本&quot;&gt;7.编写frida脚本&lt;/h3&gt;
&lt;hr/&gt;&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;console.log(&quot;init success&quot;);
function SendTextMessage(wxid, msg) {
    var message = ObjC.chooseSync(ObjC.classes.MessageService)[0]
    var username = ObjC.classes.CUtility.GetCurrentUserName();
    console.log(username)
    console.log(&quot;Type of arg[0] -&amp;gt; &quot; + message)
    var toUsrName = ObjC.classes.NSString.stringWithString_(wxid);
    var msgText = ObjC.classes.NSString.stringWithString_(msg);
    message[&quot;- SendTextMessage:toUsrName:msgText:atUserList:&quot;](username, toUsrName, msgText, null);
}
SendTextMessage(&quot;filehelper&quot;,&quot;主动调用发送信息！&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将以上文本保存js文件，然后执行以下命令：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;frida 微信 --debug --runtime=v8 --no-pause -l test.js&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们就可以看到微信上发送了一条消息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/Huerye/1068060/t_210215144138image-20210215221032552.png?a=1613400169856&quot; alt=&quot;image-20210215221032552&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;8消息监听&quot;&gt;8.消息监听&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;上面我们实现了微信消息的篡改及主动发送功能。那么我们再去看看微信是如何接到消息信息的！每当有人活或者群给我们发送消息的时候电脑或手机上一般都会提示通知，那么通知的英文是什么？&lt;strong&gt;notify&lt;/strong&gt; 翻译就是通知的意思，我们碰碰运气看看能不能找到相关字样。还是在MessageService里面我们找到了&lt;code&gt;- (void)notifyAddMsgOnMainThread:(id)arg1 msgData:(id)arg2;&lt;/code&gt; 这个方法，如何去确定它到底是不是尼？还是继续用frida去进行验证。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;frida-trace -m &quot;-[MessageService notify*]&quot; 微信
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行上述命令&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ frida-trace -m &quot;-[MessageService notify*]&quot; 微信
Instrumenting...                                                        
-[MessageService notifyModMsgOnMainThread:msgData:]: Loaded handler at &quot;/Users/n/vscodewsp/wechat/__handlers__/MessageService/notifyModMsgOnMainThread_msgData_.js&quot;
-[MessageService notifyAppMsgUploadProgress:msgData:uploadedBytes:totalBytes:]: Loaded handler at &quot;/Users/n/vscodewsp/wechat/__handlers__/MessageService/notifyAppMsgUploadProgress_msgDa_9b03499e.js&quot;
-[MessageService notifyVideoMsgUploadProgress:msgData:uploadedBytes:totalBytes:]: Loaded handler at &quot;/Users/n/vscodewsp/wechat/__handlers__/MessageService/notifyVideoMsgUploadProgress_msg_e1db5f92.js&quot;
-[MessageService notifyNewMsgNotificationOnMainThread:msgData:]: Loaded handler at &quot;/Users/n/vscodewsp/wechat/__handlers__/MessageService/notifyNewMsgNotificationOnMainTh_d56d83b5.js&quot;
-[MessageService notifyChatSyncMsgsOnMainThread:msgList:]: Loaded handler at &quot;/Users/n/vscodewsp/wechat/__handlers__/MessageService/notifyChatSyncMsgsOnMainThread_msgList_.js&quot;
-[MessageService notifyChatSyncMessagesMergedOnMainThread:]: Loaded handler at &quot;/Users/n/vscodewsp/wechat/__handlers__/MessageService/notifyChatSyncMessagesMergedOnMainThread_.js&quot;
-[MessageService notifyRevokePatMsgOnMainThread:n64MsgId:]: Loaded handler at &quot;/Users/n/vscodewsp/wechat/__handlers__/MessageService/notifyRevokePatMsgOnMainThread_n64MsgId_.js&quot;
-[MessageService notifyAddRevokePromptMsgOnMainThread:msgData:]: Loaded handler at &quot;/Users/n/vscodewsp/wechat/__handlers__/MessageService/notifyAddRevokePromptMsgOnMainTh_81637ebf.js&quot;
-[MessageService notifyDelMsgOnMainThread:msgData:isRevoke:]: Loaded handler at &quot;/Users/n/vscodewsp/wechat/__handlers__/MessageService/notifyDelMsgOnMainThread_msgData_5bbc2297.js&quot;
-[MessageService notifyMsgDeletedForSessionOnMainThread:]: Loaded handler at &quot;/Users/n/vscodewsp/wechat/__handlers__/MessageService/notifyMsgDeletedForSessionOnMainThread_.js&quot;
-[MessageService notifyDelAllMsgOnMainThread:]: Loaded handler at &quot;/Users/n/vscodewsp/wechat/__handlers__/MessageService/notifyDelAllMsgOnMainThread_.js&quot;
-[MessageService notifyAddMsgListForSessionOnMainThread:]: Loaded handler at &quot;/Users/n/vscodewsp/wechat/__handlers__/MessageService/notifyAddMsgListForSessionOnMainThread_.js&quot;
-[MessageService notifyUnreadCntChangeOnMainThread:]: Loaded handler at &quot;/Users/n/vscodewsp/wechat/__handlers__/MessageService/notifyUnreadCntChangeOnMainThread_.js&quot;
-[MessageService notifyMsgResendOnMainThread:msgData:]: Loaded handler at &quot;/Users/n/vscodewsp/wechat/__handlers__/MessageService/notifyMsgResendOnMainThread_msgData_.js&quot;
-[MessageService notifyImgMsgUploadProgress:msgData:uploadedBytes:totalBytes:]: Loaded handler at &quot;/Users/n/vscodewsp/wechat/__handlers__/MessageService/notifyImgMsgUploadProgress_msgDa_e4e0cd43.js&quot;
-[MessageService notifyAppMsgDownloadProgress:msgData:downloadedBytes:totalBytes:]: Loaded handler at &quot;/Users/n/vscodewsp/wechat/__handlers__/MessageService/notifyAppMsgDownloadProgress_msg_4e191704.js&quot;
-[MessageService notifyUIAndSessionOnMainThread:withMsg:]: Loaded handler at &quot;/Users/n/vscodewsp/wechat/__handlers__/MessageService/notifyUIAndSessionOnMainThread_withMsg_.js&quot;
-[MessageService notifyAddMsgOnMainThread:msgData:]: Loaded handler at &quot;/Users/n/vscodewsp/wechat/__handlers__/MessageService/notifyAddMsgOnMainThread_msgData_.js&quot;
Started tracing 18 functions. Press Ctrl+C to stop. 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到有不少的方法被hook了，但是没事。我们用微信发送一个消息给自己或者其他人都可以看看输出。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;           /* TID 0x307 */
157082 ms  -[MessageService notifyAddMsgOnMainThread:0x6503cfa934d442eb msgData:0x7fd903c9fa00]
           /* TID 0x31e17 */
157092 ms  -[MessageService notifyUnreadCntChangeOnMainThread:0x6503cfa934d442eb]
           /* TID 0xb5c27 */
157228 ms  -[MessageService notifyModMsgOnMainThread:0x6503cfa934d442eb msgData:0x7fd903c9fa00]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到三层相关的调用，那么我们就先看第一个&lt;code&gt;notifyAddMsgOnMainThread&lt;/code&gt; 修改下js文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;  onEnter(log, args, state) {
    log(`-[MessageService notifyAddMsgOnMainThread:${args[2]} msgData:${args[3]}]`);
  },
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以我们上面的经验很快的就可以看出这个应该就是消息接受的方法，msgdata就是我们所需要的消息内容。那么我们还是得继续验证。把参数都打印出来看看。修改添加如下js&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;console.log(&quot;Type of arg[2] -&amp;gt; &quot; + new ObjC.Object(args[2]).$className)
console.log(&quot;Type of arg[3] -&amp;gt; &quot; + new ObjC.Object(args[3]).$className)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两句话是为了输出2个参数的类型。然后也修改下frida命令执行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;frida-trace -m &quot;-[MessageService notifyAddMsgOnMainThread*]&quot; 微信
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到第一个参数是String，第二个参数是MessageData&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ frida-trace -m &quot;-[MessageService notifyAddMsgOnMainThread*]&quot; 微信
Instrumenting...                                                        
-[MessageService notifyAddMsgOnMainThread:msgData:]: Loaded handler at &quot;/Users/n/vscodewsp/wechat/__handlers__/MessageService/notifyAddMsgOnMainThread_msgData_.js&quot;
Started tracing 1 function. Press Ctrl+C to stop.                       
Type of arg[2] -&amp;gt; NSTaggedPointerString
Type of arg[3] -&amp;gt; MessageData
           /* TID 0x307 */
  2170 ms  -[MessageService notifyAddMsgOnMainThread:0x6503cfa934d442eb msgData:0x7fd90401c960]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MessageData是消息的结构体，那么我们就去头文件中搜索一下这个MessageData&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# n @ localhost in ~/vscodewsp/wechat/dump [7:46:01] C:1
$ ll -l|grep MessageData        
-rw-r--r--  1 n  staff   2.5K  2 15 19:19 FTSFileMessageData.h
-rw-r--r--  1 n  staff   2.0K  2 15 19:19 FTSMessageData.h
-rw-r--r--  1 n  staff   794B  2 15 19:19 IMessageDataExt-Protocol.h
-rw-r--r--  1 n  staff   6.2K  2 15 19:19 MMChatMessageDataSource.h
-rw-r--r--  1 n  staff    25K  2 15 19:19 MessageData.h
-rw-r--r--  1 n  staff   550B  2 15 19:19 MessageDataGroup.h
-rw-r--r--  1 n  staff   2.9K  2 15 19:19 MessageDataPackedInfo.h
-rw-r--r--  1 n  staff   262B  2 15 19:19 NSPasteboard-MessageData.h

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到是有MessageData这个文件的。那么我们打开看看&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;@interface MessageData : NSObject &amp;lt;NSPasteboardItemDataProvider, IAppMsgPathMgr, IMsgExtendOperation, NSCopying, WCTTableCoding, WCTColumnCoding&amp;gt;
{
    unsigned int mesLocalID;
    long long mesSvrID;
    NSString *fromUsrName;
    NSString *toUsrName;
    unsigned int messageType;
    NSString *msgContent;
    NSString *msgVoiceText;
    unsigned int m_uiVoiceToTextStatus;
    unsigned int msgStatus;
    unsigned int msgImgStatus;
    NSString *msgRealChatUsr;
    NSString *msgPushContent;
    unsigned int m_uiTranslateStatus;
    NSString *msgSource;
    unsigned int mesDes;
    unsigned int msgSeq;
    BOOL bForward;
    NSData *m_dtThumbnail;
    unsigned int msgCreateTime;
    unsigned int m_uiSendTime;
    unsigned int m_uiDownloadStatus;
    id &amp;lt;IMsgExtendOperation&amp;gt; m_extendInfoWithMsgType;
    id &amp;lt;IMsgExtendOperation&amp;gt; m_extendInfoWithFromUsr;
    BOOL isAutoIncrement;
    BOOL m_bShouldShowAll;
    BOOL m_bIsMultiForwardMessage;
    BOOL m_shouldReloadOriginal;
    BOOL m_bHasOriginalMessage;
    unsigned int IntRes1;
    unsigned int IntRes2;
    unsigned int m_uiFileUploadStatus;
    unsigned int m_uiOriginalImgHeight;
    unsigned int m_uiOriginalImgWidth;
    unsigned int m_uiSrcCreateTime;
    unsigned int _m_nsMsgCrc32;
    unsigned int _m_uiUploadedBytes;
    unsigned int _m_uiDownloadedBytes;
    unsigned int _m_uiTotalBytes;
    int _m_nCdnServerRetCode;
    unsigned int _m_uiResendMessageCount;
    long long lastInsertedRowID;
    NSString *StrRes1;
    NSString *StrRes2;
    MMTranslateResult *m_nsTranslationResult;
    NSString *m_nsFilePath;
    NSString *m_nsVideoPath;
    NSString *m_nsVideoThumbPath;
    NSString *dataMd5;
    MessageData *m_refMessageData;
    MessageDataPackedInfo *m_packedInfo;
    NSString *m_nsSrcUserName;
    NSString *m_nsSrcNickName;
    NSString *m_nsAtUserList;
    NSString *_m_nsImgFileName;
    NSString *_m_nsBigFileErrMsg;
    SecondMsgNode *_secondMsgNode;
    MessageData *_referHostMsg;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看各个属性名应该没问题，就是他。那么我们直接修改js代码进行输出试试。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;         var MessageData = new ObjC.Object(args[3]).$ivars;
    console.log(&quot;fromUsrName -&amp;gt; &quot; + MessageData.fromUsrName)
    console.log(&quot;toUsrName -&amp;gt; &quot; + MessageData.toUsrName)
    console.log(&quot;msgContent -&amp;gt; &quot; + MessageData.msgContent)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行&lt;code&gt;frida-trace -m &quot;-[MessageService notifyAddMsgOnMainThread*]&quot; 微信&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;-[MessageService notifyAddMsgOnMainThread:msgData:]: Loaded handler at &quot;/Users/n/vscodewsp/wechat/__handlers__/MessageService/notifyAddMsgOnMainThread_msgData_.js&quot;
Started tracing 1 function. Press Ctrl+C to stop.                       
Type of arg[2] -&amp;gt; NSTaggedPointerString
Type of arg[3] -&amp;gt; MessageData
fromUsrName -&amp;gt; wxid_pk1reltk63i822
toUsrName -&amp;gt; filehelper
msgContent -&amp;gt; 消息监听测试
           /* TID 0x307 */
 14909 ms  -[MessageService notifyAddMsgOnMainThread:0x6503cfa934d442eb msgData:0x7fd904426980]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上我们可以看到成功接收到别人发送的消息内容。&lt;/p&gt;
&lt;h2 id=&quot;文章完结&quot;&gt;文章完结&lt;/h2&gt;
</description>
<pubDate>Mon, 15 Feb 2021 14:46:00 +0000</pubDate>
<dc:creator>EOF0XF</dc:creator>
<og:description>MacOS微信逆向分析-Frida 0.前言 PC下的微信二次开发相信大家都会了，那么本篇文章将带领大家使用Frida框架对Mac下微信来进行二次开发！ PS：还有一种静态注入的方式也不错，但是考虑到</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Huerye/p/14405687.html</dc:identifier>
</item>
<item>
<title>翻译：《实用的Python编程》01_03_Numbers - codists</title>
<link>http://www.cnblogs.com/codists/p/14405609.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codists/p/14405609.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://github.com/codists/practical-python-zh/blob/main/Notes/Contents.md&quot; target=&quot;_blank&quot;&gt;目录&lt;/a&gt; | &lt;a href=&quot;https://www.cnblogs.com/codists/p/14399755.html&quot; target=&quot;_blank&quot;&gt;上一节 (1.2 第一个程序)&lt;/a&gt; | &lt;a href=&quot;https://www.cnblogs.com/codists/p/14405609.html&quot;&gt;下一节 (1.4 字符串)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本节讨论数学计算。&lt;/p&gt;
&lt;h3 id=&quot;数字类型&quot;&gt;数字类型&lt;/h3&gt;
&lt;p&gt;Python 有 4 种类型的数字：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;布尔型&lt;/li&gt;
&lt;li&gt;整型&lt;/li&gt;
&lt;li&gt;浮点型&lt;/li&gt;
&lt;li&gt;复数（虚数）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;布尔型（bool）&quot;&gt;布尔型（bool）&lt;/h3&gt;
&lt;p&gt;布尔型数字有两个值：&lt;code&gt;True&lt;/code&gt;，&lt;code&gt;False&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;a = True
b = False
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在数值上，它们被计算成值为 &lt;code&gt;1&lt;/code&gt;，&lt;code&gt;0&lt;/code&gt; 的数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;c = 4 + True # 5
d = False
if d == 0:
    print('d is False')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，不要像上面这样写代码，这会很奇怪。&lt;/p&gt;
&lt;h3 id=&quot;整型（int）&quot;&gt;整型（int）&lt;/h3&gt;
&lt;p&gt;任意大小的有符号值，或者以任意数为基数的有符号值。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;a = 37
b = -299392993727716627377128481812241231
c = 0x7fa8      # Hexadecimal
d = 0o253       # Octal
e = 0b10001111  # Binary
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常用操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;x + y      Add
x - y      Subtract
x * y      Multiply
x / y      Divide (produces a float)
x // y     Floor Divide (produces an integer)
x % y      Modulo (remainder)
x ** y     Power
x &amp;lt;&amp;lt; n     Bit shift left
x &amp;gt;&amp;gt; n     Bit shift right
x &amp;amp; y      Bit-wise AND
x | y      Bit-wise OR
x ^ y      Bit-wise XOR
~x         Bit-wise NOT
abs(x)     Absolute value
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;浮点型（float）&quot;&gt;浮点型（float）&lt;/h3&gt;
&lt;p&gt;使用十进制或者指数表示法来指定浮点数的值：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;a = 37.45
b = 4e5 # 4 x 10**5 or 400,000
c = -1.345e-10
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用浮点数表示 &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot; target=&quot;_blank&quot;&gt;IEEE 754&lt;/a&gt; 标准的双精度。这与 C 语言中的 &lt;code&gt;double&lt;/code&gt; 类型相同。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;17 digits of precision&lt;br/&gt;Exponent from -308 to 308&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;请注意，当代表小数时，浮点数是不精确的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; a = 2.1 + 4.2
&amp;gt;&amp;gt;&amp;gt; a == 6.3
False
&amp;gt;&amp;gt;&amp;gt; a
6.300000000000001
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这不是 Python 的问题，而是 CPU 硬件上底层浮点硬件的问题。&lt;/p&gt;
&lt;p&gt;常用操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;x + y      Add
x - y      Subtract
x * y      Multiply
x / y      Divide
x // y     Floor Divide
x % y      Modulo
x ** y     Power
abs(x)     Absolute Value
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了按位运算符之外，浮点数的运算符与整数的运算符是一样的。&lt;/p&gt;
&lt;p&gt;其它数学函数可以在 &lt;code&gt;math&lt;/code&gt; 中找到。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import math
a = math.sqrt(x)
b = math.sin(x)
c = math.cos(x)
d = math.tan(x)
e = math.log(x)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;比较&quot;&gt;比较&lt;/h3&gt;
&lt;p&gt;下面的比较/关系运算符可以应用于数字：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;x &amp;lt; y      Less than
x &amp;lt;= y     Less than or equal
x &amp;gt; y      Greater than
x &amp;gt;= y     Greater than or equal
x == y     Equal to
x != y     Not equal to
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以使用 &lt;code&gt;and&lt;/code&gt;， &lt;code&gt;or&lt;/code&gt;，&lt;code&gt;not&lt;/code&gt; 组成更复杂的布尔表达式。&lt;/p&gt;
&lt;p&gt;这里有一些例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;if b &amp;gt;= a and b &amp;lt;= c:
    print('b is between a and c')

if not (b &amp;lt; a or b &amp;gt; c):
    print('b is still between a and c')
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;转换数字&quot;&gt;转换数字&lt;/h3&gt;
&lt;p&gt;类型名可以被用来将其它数据转换为数字。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;a = int(x)    # Convert x to integer
b = float(x)  # Convert x to float
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;试试下面这些操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; a = 3.14159
&amp;gt;&amp;gt;&amp;gt; int(a)
3
&amp;gt;&amp;gt;&amp;gt; b = '3.14159' # It also works with strings containing numbers
&amp;gt;&amp;gt;&amp;gt; float(b)
3.14159
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;习题&quot;&gt;习题&lt;/h2&gt;
&lt;p&gt;提醒：这些习题假定你正在 &lt;a href=&quot;https://www.cnblogs.com/Work&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;practical-python/Work&lt;/code&gt;&lt;/a&gt; 目录中操作，具体在 &lt;a href=&quot;https://www.cnblogs.com/Work/mortgage.py&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;mortgage.py&lt;/code&gt;&lt;/a&gt; 文件。&lt;/p&gt;
&lt;h3 id=&quot;习题-17：戴夫的抵押贷款&quot;&gt;习题 1.7：戴夫的抵押贷款&lt;/h3&gt;
&lt;p&gt;戴夫决定从 Guido 的抵押贷款、股票投资和比特币交易公司获得 50 万美元的 30 年期固定利率抵押贷款。利率是 5%，每月还款额是 2684.11 美元。&lt;/p&gt;
&lt;p&gt;下面这个程序用于计算戴夫在抵押期内需要支付的总金额：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# mortgage.py

principal = 500000.0
rate = 0.05
payment = 2684.11
total_paid = 0.0

while principal &amp;gt; 0:
    principal = principal * (1+rate/12) - payment
    total_paid = total_paid + payment

print('Total paid', total_paid)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入该程序并执行，你应该会得到答案为 &lt;code&gt;966,279.6&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;习题-18：额外付款&quot;&gt;习题 1.8：额外付款&lt;/h3&gt;
&lt;p&gt;假设戴夫在抵押期的前 12 个月每月额外支付 1000 美元。&lt;/p&gt;
&lt;p&gt;修改程序以包含这部分额外的付款，并且输出已支付的总金额以及所需的月数。&lt;/p&gt;
&lt;p&gt;当你执行这个新程序时，它应该报告 342 个月的总付款额是 &lt;code&gt;929,965.62&lt;/code&gt; 。&lt;/p&gt;
&lt;h3 id=&quot;习题-19：制作一个额外的付款计算器&quot;&gt;习题 1.9：制作一个额外的付款计算器&lt;/h3&gt;
&lt;p&gt;修改程序，以便可以更一般的处理额外的付款信息。做到这一点，以便用户可以设置下面这些变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;extra_payment_start_month = 61
extra_payment_end_month = 108
extra_payment = 1000
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使程序查看这些变量，并适当地计算总付款额 。如果戴夫从抵押期的第五年开始，每月额外支付 1000 每月并支付 4 年，那么他将要支付多少？&lt;/p&gt;
&lt;h3 id=&quot;习题-110：制作表格&quot;&gt;习题 1.10：制作表格&lt;/h3&gt;
&lt;p&gt;修改程序，使其显示迄今为止支付的月数，支付的总金额和剩余的本金。输出看起来应该像下面这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;1 2684.11 499399.22
2 5368.22 498795.94
3 8052.33 498190.15
4 10736.44 497581.83
5 13420.55 496970.98
...
308 874705.88 3478.83
309 877389.99 809.21
310 880074.1 -1871.53
Total paid 880074.1
Months 310
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;习题-111：奖金&quot;&gt;习题 1.11：奖金&lt;/h3&gt;
&lt;p&gt;使用该程序时，请修复程序以纠正发生在上个月的超额支付。&lt;/p&gt;
&lt;h3 id=&quot;习题-112：一个谜&quot;&gt;习题 1.12：一个谜&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;int()&lt;/code&gt; 函数和 &lt;code&gt;float()&lt;/code&gt; 函数可以将其它类型的数据转换为数字类型。示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; int(&quot;123&quot;)
123
&amp;gt;&amp;gt;&amp;gt; float(&quot;1.23&quot;)
1.23
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;考虑到这一点，你能否解释下面这种行为？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; bool(&quot;False&quot;)
True
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/codists/practical-python-zh/blob/main/Notes/Contents.md&quot; target=&quot;_blank&quot;&gt;目录&lt;/a&gt; | &lt;a href=&quot;https://www.cnblogs.com/codists/p/14399755.html&quot; target=&quot;_blank&quot;&gt;上一节 (1.2 第一个程序)&lt;/a&gt; | &lt;a href=&quot;https://www.cnblogs.com/codists/p/14405609.html&quot;&gt;下一节 (1.4 字符串)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：完整翻译见&lt;/span&gt; &lt;a href=&quot;https://github.com/codists/practical-python-zh&quot; target=&quot;_blank&quot;&gt;https://github.com/codists/practical-python-zh&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 15 Feb 2021 14:20:00 +0000</pubDate>
<dc:creator>codists</dc:creator>
<og:description>目录 | 上一节 (1.2 第一个程序) | 下一节 (1.4 字符串) 1.3 数字 本节讨论数学计算。 数字类型 Python 有 4 种类型的数字： 布尔型 整型 浮点型 复数（虚数） 布尔型（</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/codists/p/14405609.html</dc:identifier>
</item>
<item>
<title>SQL优化这么做就对了 - 狼爷</title>
<link>http://www.cnblogs.com/powercto/p/14405583.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/powercto/p/14405583.html</guid>
<description>&lt;p&gt;前期开发不注意SQL优化，后期SQL慢查两眼泪汪汪。本文结合五大步骤跟十大场景给大家讲解SQL优化，希望大家一起交流学习！&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;151.91853360489&quot;&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1133883/202101/1133883-20210131155159255-723442990.jpg&quot; alt=&quot;MySQL&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在应用开发的早期，数据量少，开发人员开发功能时更重视功能上的实现，随着生产数据的增长，很多SQL语句开始暴露出性能问题，对生产的影响也越来越大，有时可能这些有问题的SQL就是整个系统性能的瓶颈。&lt;/p&gt;

&lt;h2 id=&quot;1、通过慢查日志等定位那些执行效率较低的sql语句&quot;&gt;1、通过慢查日志等定位那些执行效率较低的SQL语句&lt;/h2&gt;
&lt;h2 id=&quot;2、explain-分析sql的执行计划&quot;&gt;2、explain 分析SQL的执行计划&lt;/h2&gt;
&lt;p&gt;需要重点关注type、rows、filtered、extra。&lt;/p&gt;
&lt;p&gt;type由上至下，效率越来越高&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ALL 全表扫描&lt;/li&gt;
&lt;li&gt;index 索引全扫描&lt;/li&gt;
&lt;li&gt;range 索引范围扫描，常用语&amp;lt;,&amp;lt;=,&amp;gt;=,between,in等操作&lt;/li&gt;
&lt;li&gt;ref 使用非唯一索引扫描或唯一索引前缀扫描，返回单条记录，常出现在关联查询中&lt;/li&gt;
&lt;li&gt;eq_ref 类似ref，区别在于使用的是唯一索引，使用主键的关联查询&lt;/li&gt;
&lt;li&gt;const/system 单条记录，系统会把匹配行中的其他列作为常数处理，如主键或唯一索引查询&lt;/li&gt;
&lt;li&gt;null MySQL不访问任何表或索引，直接返回结果&lt;br/&gt;虽然上至下，效率越来越高，但是根据cost模型，假设有两个索引idx1(a, b, c),idx2(a, c)，SQL为&quot;select * from t where a = 1 and b in (1, 2) order by c&quot;;如果走idx1，那么是type为range，如果走idx2，那么type是ref；当需要扫描的行数，使用idx2大约是idx1的5倍以上时，会用idx1，否则会用idx2&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Extra&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Using filesort：MySQL需要额外的一次传递，以找出如何按排序顺序检索行。通过根据联接类型浏览所有行并为所有匹配WHERE子句的行保存排序关键字和行的指针来完成排序。然后关键字被排序，并按排序顺序检索行。&lt;/li&gt;
&lt;li&gt;Using temporary：使用了临时表保存中间结果，性能特别差，需要重点优化&lt;/li&gt;
&lt;li&gt;Using index：表示相应的 select 操作中使用了覆盖索引（Coveing Index）,避免访问了表的数据行，效率不错！如果同时出现 using where，意味着无法直接通过索引查找来查询到符合条件的数据。&lt;/li&gt;
&lt;li&gt;Using index condition：MySQL5.6之后新增的ICP，using index condtion就是使用了ICP（索引下推），在存储引擎层进行数据过滤，而不是在服务层过滤，利用索引现有的数据减少回表的数据。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;3、show-profile-分析&quot;&gt;3、show profile 分析&lt;/h2&gt;
&lt;p&gt;了解SQL执行的线程的状态及消耗的时间。&lt;br/&gt;默认是关闭的，开启语句“set profiling = 1;”&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;SHOW PROFILES ;
SHOW PROFILE FOR QUERY  #{id};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;4、trace&quot;&gt;4、trace&lt;/h2&gt;
&lt;p&gt;trace分析优化器如何选择执行计划，通过trace文件能够进一步了解为什么优惠券选择A执行计划而不选择B执行计划。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;set optimizer_trace=&quot;enabled=on&quot;;
set optimizer_trace_max_mem_size=1000000;
select * from information_schema.optimizer_trace;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;5、确定问题并采用相应的措施&quot;&gt;5、确定问题并采用相应的措施&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;优化索引&lt;/li&gt;
&lt;li&gt;优化SQL语句：修改SQL、IN 查询分段、时间查询分段、基于上一次数据过滤&lt;/li&gt;
&lt;li&gt;改用其他实现方式：ES、数仓等&lt;/li&gt;
&lt;li&gt;数据碎片处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;案例1、最左匹配&quot;&gt;案例1、最左匹配&lt;/h2&gt;
&lt;p&gt;索引&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;KEY `idx_shopid_orderno` (`shop_id`,`order_no`)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SQL语句&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select * from _t where orderno=''
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询匹配从左往右匹配，要使用order_no走索引，必须查询条件携带shop_id或者索引(&lt;code&gt;shop_id&lt;/code&gt;,&lt;code&gt;order_no&lt;/code&gt;)调换前后顺序&lt;/p&gt;
&lt;h2 id=&quot;案例2、隐式转换&quot;&gt;案例2、隐式转换&lt;/h2&gt;
&lt;p&gt;索引&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;KEY `idx_mobile` (`mobile`)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SQL语句&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select * from _user where mobile=12345678901
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;隐式转换相当于在索引上做运算，会让索引失效。mobile是字符类型，使用了数字，应该使用字符串匹配，否则MySQL会用到隐式替换，导致索引失效。&lt;/p&gt;
&lt;h2 id=&quot;案例3、大分页&quot;&gt;案例3、大分页&lt;/h2&gt;
&lt;p&gt;索引&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;KEY `idx_a_b_c` (`a`, `b`, `c`)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SQL语句&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select * from _t where a = 1 and b = 2 order by c desc limit 10000, 10;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于大分页的场景，可以优先让产品优化需求，如果没有优化的，有如下两种优化方式，&lt;br/&gt;一种是把上一次的最后一条数据，也即上面的c传过来，然后做“c &amp;lt; xxx”处理，但是这种一般需要改接口协议，并不一定可行。&lt;br/&gt;另一种是采用延迟关联的方式进行处理，减少SQL回表，但是要记得索引需要完全覆盖才有效果，SQL改动如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select t1.* from _t t1, (select id from _t where a = 1 and b = 2 order by c desc limit 10000, 10) t2 where t1.id = t2.id;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;案例4、in--order-by&quot;&gt;案例4、in + order by&lt;/h2&gt;
&lt;p&gt;索引&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;KEY `idx_shopid_status_created` (`shop_id`, `order_status`, `created_at`)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SQL语句&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select * from _order where shop_id = 1 and order_status in (1, 2, 3) order by created_at desc limit 10
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;in查询在MySQL底层是通过n*m的方式去搜索，类似union，但是效率比union高。&lt;br/&gt;in查询在进行cost代价计算时（代价 = 元组数 * IO平均值），是通过将in包含的数值，一条条去查询获取元组数的，因此这个计算过程会比较的慢，所以MySQL设置了个临界值(eq_range_index_dive_limit)，5.6之后超过这个临界值后该列的cost就不参与计算了。因此会导致执行计划选择不准确。默认是200，即in条件超过了200个数据，会导致in的代价计算存在问题，可能会导致Mysql选择的索引不准确。&lt;/p&gt;
&lt;p&gt;处理方式，可以(&lt;code&gt;order_status&lt;/code&gt;, &lt;code&gt;created_at&lt;/code&gt;)互换前后顺序，并且调整SQL为延迟关联。&lt;/p&gt;
&lt;h2 id=&quot;案例5、范围查询阻断，后续字段不能走索引&quot;&gt;案例5、范围查询阻断，后续字段不能走索引&lt;/h2&gt;
&lt;p&gt;索引&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;KEY `idx_shopid_created_status` (`shop_id`, `created_at`, `order_status`)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SQL语句&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select * from _order where shop_id = 1 and created_at &amp;gt; '2021-01-01 00:00:00' and order_status = 10
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;范围查询还有“IN、between”&lt;/p&gt;
&lt;h2 id=&quot;案例6、不等于、不包含不能用到索引的快速搜索。（可以用到icp）&quot;&gt;案例6、不等于、不包含不能用到索引的快速搜索。（可以用到ICP）&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;select * from _order where shop_id=1 and order_status not in (1,2)
select * from _order where shop_id=1 and order_status != 1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在索引上，避免使用NOT、!=、&amp;lt;&amp;gt;、!&amp;lt;、!&amp;gt;、NOT EXISTS、NOT IN、NOT LIKE等&lt;/p&gt;
&lt;h2 id=&quot;案例7、优化器选择不使用索引的情况&quot;&gt;案例7、优化器选择不使用索引的情况&lt;/h2&gt;
&lt;p&gt;如果要求访问的数据量很小，则优化器还是会选择辅助索引，但是当访问的数据占整个表中数据的蛮大一部分时（一般是20%左右），优化器会选择通过聚集索引来查找数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select * from _order where  order_status = 1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询出所有未支付的订单，一般这种订单是很少的，即使建了索引，也没法使用索引。&lt;/p&gt;
&lt;h2 id=&quot;案例8、复杂查询&quot;&gt;案例8、复杂查询&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;select sum(amt) from _t where a = 1 and b in (1, 2, 3) and c &amp;gt; '2020-01-01';
select * from _t where a = 1 and b in (1, 2, 3) and c &amp;gt; '2020-01-01' limit 10;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是统计某些数据，可能改用数仓进行解决；&lt;br/&gt;如果是业务上就有那么复杂的查询，可能就不建议继续走SQL了，而是采用其他的方式进行解决，比如使用ES等进行解决。&lt;/p&gt;
&lt;h2 id=&quot;案例9、asc和desc混用&quot;&gt;案例9、asc和desc混用&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;select * from _t where a=1 order by b desc, c asc
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;desc 和asc混用时会导致索引失效&lt;/p&gt;
&lt;h2 id=&quot;案例10、大数据&quot;&gt;案例10、大数据&lt;/h2&gt;
&lt;p&gt;对于推送业务的数据存储，可能数据量会很大，如果在方案的选择上，最终选择存储在MySQL上，并且做7天等有效期的保存。&lt;br/&gt;那么需要注意，频繁的清理数据，会照成数据碎片，需要联系DBA进行数据碎片处理。&lt;/p&gt;

&lt;/div&gt;</description>
<pubDate>Mon, 15 Feb 2021 14:09:00 +0000</pubDate>
<dc:creator>狼爷</dc:creator>
<og:description>前期开发不注意SQL优化，后期SQL慢查两眼泪汪汪。本文结合五大步骤跟十大场景给大家讲解SQL优化，希望大家一起交流学习！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/powercto/p/14405583.html</dc:identifier>
</item>
<item>
<title>写文章一年了，我用到的工具都在这儿了！ - Robod丶</title>
<link>http://www.cnblogs.com/robod/p/14405448.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/robod/p/14405448.html</guid>
<description>&lt;blockquote readability=&quot;4.8260869565217&quot;&gt;
&lt;p&gt;&lt;strong&gt;好好学习，天天向上&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文已收录至我的Github仓库&lt;a href=&quot;https://github.com/RobodLee/DayDayUP&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;DayDayUP&lt;/strong&gt;&lt;/a&gt;：github.com/RobodLee/DayDayUP，欢迎Star&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_43461520/article/details/113819421&quot; target=&quot;_blank&quot;&gt;⭐⭐⭐⭐⭐&lt;code&gt;转载请注明出处！&lt;/code&gt;⭐⭐⭐⭐⭐&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_43461520/article/details/113819421&quot; target=&quot;_blank&quot;&gt;链接：https://blog.csdn.net/weixin_43461520/article/details/113819421&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_43461520/article/details/113819421&quot; target=&quot;_blank&quot;&gt;⭐⭐⭐⭐⭐&lt;strong&gt;转载请注明出处！&lt;/strong&gt;⭐⭐⭐⭐⭐&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;时间过得真快呀，不知不觉我写文章已经快一年时间了，写这篇文章主要是想分享一下我平时使用的工具以及我踩过的坑。其实一开始我是没考虑过写文章的，觉得自己什么都不知道，写不出来什么，后来还是看了CodeSheep的视频才决定写一写的，说实话写文章给我带来的收获还是非常多的。很多时候学完了一样东西之后，感觉自己懂了，但要用自己的话把它讲明白，确实不是一件容易的事，会发现还有很多细节没搞明白，当我回过头把没明白的地方搞明白后写成文章的时候，对自己又是一次提升。其实写文章就是查漏补缺的过程，不管文章写得怎么样，只要写了肯定就有收获，再不济时间长了很多东西忘了的时候还能拿出来复习不是么。就像我现在一样，写的很多都是没什么深度的笔记，但是这些笔记可以让我以后拿出来复习，写的时候也是一次巩固，而且还可以帮助到一起学习的小伙伴们，何乐而不为呢？&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;文中提及的所有工具用百度都可以搜到，所以我就不提供下载链接了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;文章用什么写&quot;&gt;文章用什么写&lt;/h2&gt;
&lt;p&gt;在写文章之前，先了解一下什么是Markdown，它是一种轻量级标记语言，用一些很简单的标记就可以实现一些特定的样式。我一开始并不知道什么是Markdown，写的第一篇文章《&lt;a href=&quot;https://blog.csdn.net/weixin_43461520/article/details/104402673&quot; target=&quot;_blank&quot;&gt;SSM三大框架的整合&lt;/a&gt;》用的还是Word，用Word写文章难受的一批，代码贴上去一点也不好看，后来我把文章写完准备往CSDN上发的时候，才知道有Markdown这么牛掰的东西，一个&lt;code&gt;#&lt;/code&gt;就是一级标题，两个就是二级标题，加粗就是文字两边各有两个&lt;code&gt;*&lt;/code&gt;号......还支持代码段和表格，然后这些简单的标记通过渲染后就可以变得很美观：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/RobodLee/image_store/raw/master/Other/%E5%86%99%E6%96%87%E7%AB%A0%E4%B8%80%E5%B9%B4%E4%BA%86%EF%BC%8C%E6%88%91%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7%E9%83%BD%E5%9C%A8%E8%BF%99%E5%84%BF%E4%BA%86%EF%BC%81/Markdown%E6%A0%87%E8%AE%B0.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更多Markdown相关的内容，可以参考&lt;a href=&quot;https://www.runoob.com/markdown/md-tutorial.html&quot; target=&quot;_blank&quot;&gt;菜鸟教程&lt;/a&gt;，在平时书写的过程中，尽量不要写一些复杂的标记，因为各个平台对Markdown的支持都不太一样，有些标记可能识别不出来，比如知乎就不支持Markdown的表格，所以我现在都不在知乎发文章了。&lt;/p&gt;
&lt;p&gt;知道了Markdown这种标记语言之后，就该考虑拿什么软件写文章了，我一开始用的是Vscode，它采用的是一边编辑另一边预览的方式，Vscode的缺点就是没有标记提示，有的简单标记确实手动敲起来比较简单，但是遇到复杂的标记，还没有Word来的舒服呢，比如表格标记，写起来就很费劲(也可能是我不知道，不过界面确实不太好看)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/RobodLee/image_store/raw/master/Other/%E5%86%99%E6%96%87%E7%AB%A0%E4%B8%80%E5%B9%B4%E4%BA%86%EF%BC%8C%E6%88%91%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7%E9%83%BD%E5%9C%A8%E8%BF%99%E5%84%BF%E4%BA%86%EF%BC%81/vscode%E7%BC%96%E8%BE%91%E7%95%8C%E9%9D%A2.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后来看了其它博主的推荐，知道了Typora这款神器，它采用的所见即所得的方式，编写和预览在一起，而不是像Vscode一样左右分开，写完标记后直接呈现渲染后的样子，而且还可以通过点击鼠标右键添加样式，这样就算有的标记不记得或者写起来比较复杂，则可以使用鼠标右键进行操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/RobodLee/image_store/raw/master/Other/%E5%86%99%E6%96%87%E7%AB%A0%E4%B8%80%E5%B9%B4%E4%BA%86%EF%BC%8C%E6%88%91%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7%E9%83%BD%E5%9C%A8%E8%BF%99%E5%84%BF%E4%BA%86%EF%BC%81/Typora%E5%8F%B3%E9%94%AE%E7%BC%96%E8%BE%91.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我一般都是简单的标记直接敲，复杂的就用鼠标右键。不过Typora也有缺点，因为它是实时渲染的，所以内容多的话界面就有点卡顿，我之前写《&lt;a href=&quot;https://blog.csdn.net/weixin_43461520/article/details/111827457&quot; target=&quot;_blank&quot;&gt;手摸手带你学CSS&lt;/a&gt;》的时候，写到两万多快三万字时写起来就明显感觉到卡顿，不过也还好，很少写到那么多字。&lt;/p&gt;
&lt;h2 id=&quot;关于图片的问题&quot;&gt;关于图片的问题&lt;/h2&gt;
&lt;p&gt;Markdown是一种纯文本的标记语言，它本身并不能像Word一样直接插入图片，只能通过标记的方式插入图片的链接，本地图片链接或者云端图片链接都可以，但是图片保存在本地的话换台设备就看不到图片了，总不能把图片也跟着复制过去吧，那多麻烦呀！所以我一般都是把图片放在云端，这样不管在哪台设备上，只要能联网就可以显示图片。&lt;/p&gt;
&lt;p&gt;秉承着能白嫖就不花钱的精神，我开始寻找一个免费的图床。免费的东西稳定性才是最重要的，要是用了一段时间图床崩了图片都没了怎么办？刚好我在开始写文章之前看过一篇文章说的是怎么白嫖Github当图床，所以我一开始选择的平台就是Github，但是当我用了一段时间后发现Github图床有个很尴尬的缺点，因为Github的服务器不在国内，所以图片加载起来非常慢。而且因为网络的原因，在Markdown中插入Github的图片是显示不出来的，只有修改了hosts文件才可以显示，所以有的时候在博客园这样的平台发现有的图片显示不了可能用的是Github图床。但是修改了hosts一段时间后我的Github打不开了，当时我一直以为是Github在国内被封了，然后有一天我发现我家的另一台电脑可以访问Github，我才意识到可能是我改了hosts的问题，我把它改回来后又可以访问Github了。这就很尴尬了，不改hosts图片显示不了，改了hosts后Github用不了。所以我又将眼光放在了国内的Gitee上，用了Gitee后发现是真的香，图片加载速度杠杠的，Markdown一打开图片就全加载出来了，就和图片放在本地一样。不过Gitee也有缺点，第一个是Gitee每个账号的容量只有5个G，确实小了点，不过一个账号不够就多注册几个呗，这不是什么大问题，第二个就是每张图片的大小不能超过1MB，超过1MB就不能通过外链访问，所以超过1MB的图片上传之前记得先压缩一下。&lt;/p&gt;
&lt;p&gt;上面说了Gitee可以把图片放在Gitee上，但要是按照传统的操作git的方式上传图片确实太麻烦了，不过好在网上已经有人开发出了可以简化操作的神器——&lt;strong&gt;PicGo&lt;/strong&gt;。Gitee与PicGo配合使用，简直比德芙还丝滑，有的小伙伴可能不知道怎么操作，我来介绍一下：&lt;/p&gt;
&lt;p&gt;首先在Gitee上注册一个账号，然后新建一个仓库专门用来存放图片，然后去获取账号的Token：点击右上角&lt;strong&gt;头像&lt;/strong&gt;，在弹出的下拉框中点击&lt;strong&gt;设置&lt;/strong&gt;，然后在设置界面点击左侧的&lt;strong&gt;私人令牌&lt;/strong&gt;，再点击右上角出现的&lt;strong&gt;生成新令牌&lt;/strong&gt;按钮，把图中的&lt;strong&gt;projects&lt;/strong&gt;勾上，其余的可以不勾。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/RobodLee/image_store/raw/master/Other/%E5%86%99%E6%96%87%E7%AB%A0%E4%B8%80%E5%B9%B4%E4%BA%86%EF%BC%8C%E6%88%91%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7%E9%83%BD%E5%9C%A8%E8%BF%99%E5%84%BF%E4%BA%86%EF%BC%81/gitee%E7%94%9F%E6%88%90%E7%A7%81%E4%BA%BA%E4%BB%A4%E7%89%8C.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击&lt;strong&gt;提交&lt;/strong&gt;按钮后会被要求输入密码，&lt;strong&gt;输完密码&lt;/strong&gt;就可以获取到Token了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/RobodLee/image_store/raw/master/Other/%E5%86%99%E6%96%87%E7%AB%A0%E4%B8%80%E5%B9%B4%E4%BA%86%EF%BC%8C%E6%88%91%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7%E9%83%BD%E5%9C%A8%E8%BF%99%E5%84%BF%E4%BA%86%EF%BC%81/%E7%94%9F%E6%88%90%E7%A7%81%E4%BA%BA%E4%BB%A4%E7%89%8C.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意，token只显示一次，请及时保存下来，没保存就只能重新生成了。&lt;/p&gt;
&lt;p&gt;然后将PicGo下载下来安装好，默认PicGo是不支持Gitee图床的，所以先要下载Gitee的插件，不过下载插件之前电脑上&lt;strong&gt;必须安装node.js，否则插件安装不了&lt;/strong&gt;，我一开始并不知道这一点，所以我插件一直安装不上，这也是我没有一开始就使用Gitee的原因之一。打开PicGo的界面，点击左侧的&lt;strong&gt;插件设置&lt;/strong&gt;，然后&lt;strong&gt;搜索gitee&lt;/strong&gt;，安装&lt;strong&gt;图中圈出的插件&lt;/strong&gt;，等待插件安装完毕。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/RobodLee/image_store/raw/master/Other/%E5%86%99%E6%96%87%E7%AB%A0%E4%B8%80%E5%B9%B4%E4%BA%86%EF%BC%8C%E6%88%91%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7%E9%83%BD%E5%9C%A8%E8%BF%99%E5%84%BF%E4%BA%86%EF%BC%81/picgogitee%E6%8F%92%E4%BB%B6.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;插件安装完成后，依次点击&lt;strong&gt;图床设置&lt;/strong&gt;——&amp;gt;&lt;strong&gt;gitee&lt;/strong&gt;，然后右侧会出现需要填内容的区域，第一个&lt;strong&gt;repo&lt;/strong&gt;是用来设置仓库的，也就是你想将图片上传到哪个仓库，格式为&lt;code&gt;用户名/仓库名&lt;/code&gt;，第二个&lt;strong&gt;branch&lt;/strong&gt;填的是分支，直接填&lt;code&gt;master&lt;/code&gt;主分支即可，第三个&lt;strong&gt;token&lt;/strong&gt;填入刚才获取的&lt;code&gt;私人令牌&lt;/code&gt;，第四个&lt;strong&gt;path&lt;/strong&gt;填写的&lt;strong&gt;文件夹的路径&lt;/strong&gt;，就是你想将图片上传到哪个文件夹，建议为每篇文章单独建一个文件夹，这样方便管理，文件夹路径&lt;strong&gt;不要包含括号&lt;/strong&gt;，有的平台比如CSDN解析不了括号，图片的链接在CSDN中粘贴会解析不出来。最后点击&lt;strong&gt;确定&lt;/strong&gt;即可，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/RobodLee/image_store/raw/master/Other/%E5%86%99%E6%96%87%E7%AB%A0%E4%B8%80%E5%B9%B4%E4%BA%86%EF%BC%8C%E6%88%91%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7%E9%83%BD%E5%9C%A8%E8%BF%99%E5%84%BF%E4%BA%86%EF%BC%81/%E8%AE%BE%E7%BD%AEpicgo%E7%9A%84gitee%E6%8F%92%E4%BB%B6.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以在&lt;strong&gt;PicGo设置&lt;/strong&gt;里面设置一下上传图片的快捷键，然后复制想要上传的图片，再点击上传的快捷键，图片就会开始上传，成功与否都会有提示，如果上传成功图片的链接就会自动保存在剪切板里，直接到Typora中粘贴即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/RobodLee/image_store/raw/master/Other/%E5%86%99%E6%96%87%E7%AB%A0%E4%B8%80%E5%B9%B4%E4%BA%86%EF%BC%8C%E6%88%91%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7%E9%83%BD%E5%9C%A8%E8%BF%99%E5%84%BF%E4%BA%86%EF%BC%81/picgo%E4%B8%8A%E4%BC%A0%E6%88%90%E5%8A%9F.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/RobodLee/image_store/raw/master/Other/%E5%86%99%E6%96%87%E7%AB%A0%E4%B8%80%E5%B9%B4%E4%BA%86%EF%BC%8C%E6%88%91%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7%E9%83%BD%E5%9C%A8%E8%BF%99%E5%84%BF%E4%BA%86%EF%BC%81/%E5%9C%A8%E7%BA%BF%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ScreenToGif&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这是一款在电脑上录制gif图片的工具，有时候为了演示某样东西，可能会用到gif，通过这个工具就可以很方便的将电脑屏幕录制成gif图片，可以调整录制的区域，也可以调整录制的帧数。 不仅可以录制电脑屏幕，也可以录制摄像头和画板，录制完成后可以对gif进行简单的编辑，非常好用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/RobodLee/image_store/raw/master/Other/%E5%86%99%E6%96%87%E7%AB%A0%E4%B8%80%E5%B9%B4%E4%BA%86%EF%BC%8C%E6%88%91%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7%E9%83%BD%E5%9C%A8%E8%BF%99%E5%84%BF%E4%BA%86%EF%BC%81/ScreenToGif%E7%95%8C%E9%9D%A2.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是一款在线的视频转gif图片的工具，有的时候需要录制手机的画面，可以通过手机自带的录屏软件录制视频，然后将视频上传到这个网站转换成gif，而且这个网站是免费的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ProcessOn和draw.io&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这两个都是在线的图片绘制工具，ProcessOn我主要用来绘制流程图和思维导图，不过存储的数量有限，超过限制就要开会员，画思维导图的话XMind也不错。draw.io可以绘制各种图片，还可以将绘制的图片保存到OneDrive和Github等平台。&lt;/p&gt;
&lt;p&gt;对，没错，就是Windows自带的画图软件，虽然功能不多，但简单的编辑图片还是可以的，比如添加文字，修改大小，圈出部分内容等，这个我平时用的还是挺多的。&lt;/p&gt;
&lt;h2 id=&quot;备份到云端&quot;&gt;备份到云端&lt;/h2&gt;
&lt;p&gt;文章写完后就该考虑备份的问题了，毕竟保存在本地还是有丢失的风险，谁也不想辛辛苦苦写的文章突然就没了吧。我一开始是把文章写完后保存到Github上，但这种方式还是太麻烦了，我就在考虑有没有更易用的平台。后来考虑云笔记产品——&lt;strong&gt;有道云笔记&lt;/strong&gt;，它是支持Markdown的，用它写确实不怕文章丢了，但是书写体验和Typora相比差太远了，后来我在想能不能用Typora编辑有道云笔记中的文章。研究了一番，还真的可以，有道云笔记中的文章都会在电脑上有一个本地文件，只要找到本地文件，然后用任意编辑器编辑，点击保存的时候就会自动同步到有道云笔记的服务器了，而且有道云笔记还有类似于git的版本控制的功能，它存储了每一次编辑的内容，如果一不小心删除了部分内容，还可以通过该功能进行回滚，这个功能还是非常Nice的！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/RobodLee/image_store/raw/master/Other/%E5%86%99%E6%96%87%E7%AB%A0%E4%B8%80%E5%B9%B4%E4%BA%86%EF%BC%8C%E6%88%91%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7%E9%83%BD%E5%9C%A8%E8%BF%99%E5%84%BF%E4%BA%86%EF%BC%81/%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在还有一个问题，怎么快速找到某篇文章的本地文件呢？Windows平台上有一款本地文件搜索神器——Everything，不过我要推荐的可不是这个，因为它的界面丑不拉几的，我平时使用的是&lt;strong&gt;uTools&lt;/strong&gt;，这个软件可以安装各种插件，然后通过插件实现不同的功能。里面有两个插件：&lt;strong&gt;本地搜索&lt;/strong&gt;和&lt;strong&gt;QuickTypora&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/RobodLee/image_store/raw/master/Other/%E5%86%99%E6%96%87%E7%AB%A0%E4%B8%80%E5%B9%B4%E4%BA%86%EF%BC%8C%E6%88%91%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7%E9%83%BD%E5%9C%A8%E8%BF%99%E5%84%BF%E4%BA%86%EF%BC%81/uTools%E6%8F%92%E4%BB%B6.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本地搜索是基于Everything的，但要比直接使用它要舒服；QuickTypora可以打开最近使用Typora编辑的Markdown文件，所以使用流程就是👇&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/RobodLee/image_store/raw/master/Other/%E5%86%99%E6%96%87%E7%AB%A0%E4%B8%80%E5%B9%B4%E4%BA%86%EF%BC%8C%E6%88%91%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7%E9%83%BD%E5%9C%A8%E8%BF%99%E5%84%BF%E4%BA%86%EF%BC%81/uTools%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后在Typora中设置一下自动保存，就可以实现写文章自动保存到云端，不过在写文章的过程中有道云笔记要一直放后台运行，不然文章可能会同步失败。&lt;/p&gt;
&lt;h2 id=&quot;文章的发布&quot;&gt;文章的发布&lt;/h2&gt;
&lt;p&gt;文章写完后可以将其发表到各个平台上，我现在主要发表的平台有微信公众号，CSDN，博客园和掘金，除了微信公众号以外，其余几个都是支持Markdown的，只要把自己写的Markdown格式的文章直接复制粘贴过去就可以了。&lt;/p&gt;
&lt;p&gt;微信公众号不支持Markdown，但是也不用担心，有个格式转换的网站：&lt;a href=&quot;https://www.mdnice.com&quot; target=&quot;_blank&quot;&gt;https://www.mdnice.com&lt;/a&gt;。通过这个网站转换后就可以粘贴到微信公众号了，还有各种好看的样式可以选择。最近也出了下载版，不过下载版是收费的，在线使用是免费的。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;好了，以上就是我平时写文章时所用到的所有的工具以及使用方式了，有的是我自己慢慢摸索出来的，还有的是看别人推荐的。每个人使用的习惯不同，现在这套工具我自己用起来还是挺顺手的，所以推荐给大家。&lt;code&gt;觉得不错的话记得给我点个赞！再分享给有需要的人！&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7.463768115942&quot;&gt;
&lt;p&gt;码字不易，可以的话，给我来个&lt;code&gt;点赞&lt;/code&gt;，&lt;code&gt;收藏&lt;/code&gt;，&lt;code&gt;关注&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果你喜欢我的文章，欢迎关注微信公众号 &lt;strong&gt;『 &lt;span&gt;R&lt;/span&gt; &lt;span&gt;o&lt;/span&gt; &lt;span&gt;b&lt;/span&gt; &lt;span&gt;o&lt;/span&gt; &lt;span&gt;d&lt;/span&gt; 』&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文已收录至我的Github仓库&lt;strong&gt;DayDayUP&lt;/strong&gt;：&lt;a href=&quot;https://www.cnblogs.com/robod/p/github.com/RobodLee/DayDayUP&quot; target=&quot;_blank&quot;&gt;github.com/RobodLee/DayDayUP&lt;/a&gt;，欢迎Star&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_43461520/article/details/113819421&quot; target=&quot;_blank&quot;&gt;⭐⭐⭐⭐⭐&lt;code&gt;转载请注明出处！&lt;/code&gt;⭐⭐⭐⭐⭐&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_43461520/article/details/113819421&quot; target=&quot;_blank&quot;&gt;链接：https://blog.csdn.net/weixin_43461520/article/details/113819421&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_43461520/article/details/113819421&quot; target=&quot;_blank&quot;&gt;⭐⭐⭐⭐⭐&lt;strong&gt;转载请注明出处！&lt;/strong&gt;⭐⭐⭐⭐⭐&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/RobodLee/image_store/raw/master/QRcode2.0.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 15 Feb 2021 13:26:00 +0000</pubDate>
<dc:creator>Robod丶</dc:creator>
<og:description>好好学习，天天向上 本文已收录至我的Github仓库DayDayUP：github.com/RobodLee/DayDayUP，欢迎Star ⭐⭐⭐⭐⭐转载请注明出处！⭐⭐⭐⭐⭐ 链接：https:/</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/robod/p/14405448.html</dc:identifier>
</item>
</channel>
</rss>