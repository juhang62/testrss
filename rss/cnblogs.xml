<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>自定义 ocelot 中间件输出自定义错误信息 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/14383810.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/14383810.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;ocelot 中默认的 Response 中间件在出错的时候只会设置 StatusCode 没有具体的信息，想要展示自己定义的错误信息的时候就需要做一些自定义了，对 ocelot 中的 Response 中间件做了一些小改动，实现了输出自定义错误信息的功能。&lt;/p&gt;
&lt;h2 id=&quot;implement&quot;&gt;Implement&lt;/h2&gt;
&lt;p&gt;实现起来其实也很简单，原来的有错误的时候，只设置了 Response 的 StatusCode，我们只需要加一下输出错误信息就可以了，错误信息的格式完全可以自定义，实现代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class CustomResponseMiddleware : Ocelot.Middleware.OcelotMiddleware
{
    private readonly RequestDelegate _next;
    private readonly IHttpResponder _responder;
    private readonly IErrorsToHttpStatusCodeMapper _codeMapper;

    public CustomResponseMiddleware(
        RequestDelegate next,
        IHttpResponder responder,
        IErrorsToHttpStatusCodeMapper codeMapper,
        IOcelotLoggerFactory loggerFactory)
        : base(loggerFactory.CreateLogger&amp;lt;UrlBasedAuthenticationMiddleware&amp;gt;())
    {
        _next = next;
        _responder = responder;
        _codeMapper = codeMapper;
    }

    public async Task Invoke(HttpContext httpContext)
    {
        await _next.Invoke(httpContext);
        if (httpContext.Response.HasStarted)
            return;

        var errors = httpContext.Items.Errors();
        if (errors.Count &amp;gt; 0)
        {
            Logger.LogWarning($&quot;{errors.ToErrorString()} errors found in {MiddlewareName}. Setting error response for request path:{httpContext.Request.Path}, request method: {httpContext.Request.Method}&quot;);

            var statusCode = _codeMapper.Map(errors);
            var error = string.Join(&quot;,&quot;, errors.Select(x =&amp;gt; x.Message));
            httpContext.Response.StatusCode = statusCode;
            // output error
            await httpContext.Response.WriteAsync(error);
        }
        else
        {
            Logger.LogDebug(&quot;no pipeline errors, setting and returning completed response&quot;);

            var downstreamResponse = httpContext.Items.DownstreamResponse();

            await _responder.SetResponseOnHttpContext(httpContext, downstreamResponse);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相比之前的中间件，主要变化就是对于 Error 的处理，感觉这里 ocelot 可以抽象一下，增加一个接口 &lt;code&gt;ErrorResponser&lt;/code&gt; 之类的，现在的 responder 没有直接把错误信息直接传进去造成一些不变，加一个 &lt;code&gt;ErrorResponder&lt;/code&gt; 只处理 Error 相关的逻辑，把错误信息直接传进去，这样用户也就可以更为灵活的注册自己的服务来无侵入的修改发生错误时的行为&lt;/p&gt;
&lt;h2 id=&quot;sample&quot;&gt;Sample&lt;/h2&gt;
&lt;p&gt;要使用这个中间件，就要自己定义 ocelot 中间件的配置，把默认的 Response 中间件替换成自己的中间件即可，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;app.UseOcelot((ocelotBuilder, ocelotConfiguration) =&amp;gt;
{
    // this sets up the downstream context and gets the config
    app.UseDownstreamContextMiddleware();
    // This is registered to catch any global exceptions that are not handled
    // It also sets the Request Id if anything is set globally
    ocelotBuilder.UseExceptionHandlerMiddleware();

    // This is registered first so it can catch any errors and issue an appropriate response
    //ocelotBuilder.UseResponderMiddleware();
    ocelotBuilder.UseMiddleware&amp;lt;CustomResponseMiddleware&amp;gt;();

    ocelotBuilder.UseDownstreamRouteFinderMiddleware();
    ocelotBuilder.UseMultiplexingMiddleware();
    ocelotBuilder.UseDownstreamRequestInitialiser();
    ocelotBuilder.UseRequestIdMiddleware();

    // 自定义中间件，模拟没有权限的情况
    ocelotBuilder.Use((ctx, next) =&amp;gt;
    {
        ctx.Items.SetError(new UnauthorizedError(&quot;No permission&quot;));
        return Task.CompletedTask;
    });
    //ocelotBuilder.UseMiddleware&amp;lt;UrlBasedAuthenticationMiddleware&amp;gt;();

    ocelotBuilder.UseLoadBalancingMiddleware();
    ocelotBuilder.UseDownstreamUrlCreatorMiddleware();
    ocelotBuilder.UseHttpRequesterMiddleware();
}).Wait();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了上面的 Response 中间件，为了测试方便，我还加了一个中间件，直接设置了一个 Error 来方便测试，随便访问一个 Path 来测试一下是不是会有错误信息，可以看到正如预期的结果一样，输出了我们自定义的错误信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202102/489462-20210207082457543-664661676.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;完整示例可以从 Github 上获取 &lt;a href=&quot;https://github.com/WeihanLi/AspNetCorePlayground/tree/master/OcelotDemo&quot; target=&quot;_blank&quot;&gt;https://github.com/WeihanLi/AspNetCorePlayground/tree/master/OcelotDemo&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Sun, 07 Feb 2021 00:25:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>ocelot 输出自定义的错误信息</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/14383810.html</dc:identifier>
</item>
<item>
<title>WebApi Swagger 接口多版本控制 适用于APP接口管理 - oppoic</title>
<link>http://www.cnblogs.com/oppoic/p/14380233.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/oppoic/p/14380233.html</guid>
<description>&lt;p&gt;最近研究了下swagger多版本的维护，网上的文章千篇一律，无法满足我的需求，分享下我的使用场景以及实现&lt;/p&gt;
&lt;p&gt;演示环境：Visual Studio 2019、Asp.NET WebAPI、NET Framework 4.5.2、Swashbuckle.Core 5.6.0&lt;/p&gt;
&lt;p&gt;本文地址：&lt;a href=&quot;https://www.cnblogs.com/oppoic/p/14380233.html&quot;&gt;https://www.cnblogs.com/oppoic/p/14380233.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;一、背景&lt;/h2&gt;
&lt;p&gt;BS应用没有接口版本的概念，因为网站一上线，接口和页面都是新的，服务端不需要维护老接口&lt;/p&gt;
&lt;p&gt;但是对于手机APP，服务端就必须要考虑老版本的接口了，因为用户如果不更新APP，老版本的接口必须存在，这就有了接口版本的概念&lt;/p&gt;
&lt;h2&gt;二、我们的使用场景&lt;/h2&gt;
&lt;p&gt;我司APP开发调服务端接口的时候，喜欢把版本号放到请求Header里面，这个版本号就是APP上架各大商店的版本号，大概是这样的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/401362/202102/401362-20210206112442381-724021002.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图，1.9.9版本APP调用服务端接口，Header里的Version就是1.9.9。迭代到2.0.0，调同样的接口带的版本号就变成了2.0.0，服务端怎么处理呢？&lt;/p&gt;
&lt;p&gt;常规做法是通过路由实现，但实际情况是这样的：上架苹果App Store顺利通过，版本号为1.9.9。但是上架华为应用市场，因为软著的问题被拒了，再次提交版本号就变成了2.0.0。其实APP内部没有任何改变，服务端这个时候再加上2.0.0的所有接口，然后再次发版吗？理想的状态应该是这样：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;版本号可以向前兼容，服务端没有2.0.0版本的接口就自动找1.9.9版本的接口；&lt;/li&gt;
&lt;li&gt;接口可以复用，例：2.0.0版本只修改了1.9.9版本的1个接口，其他接口的实现都是一样的，那就没必要把1.9.9版本的接口都拷贝到2.0.0；&lt;/li&gt;
&lt;li&gt;计算版本号一定要快，因为随着APP的迭代，服务端维护的版本可能特别多，计算慢的话接口访问速度会越来越差&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上需求都实现好了，具体请参考：&lt;a href=&quot;https://www.cnblogs.com/oppoic/p/13367878.html&quot; target=&quot;_blank&quot;&gt;大家是怎么做APP接口的版本控制的？欢迎进来看看我的方案。升级版的Versioning&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接下来才是本篇文章的重点，服务端接口都写好了，怎么提供给前端同事查看呢？&lt;/p&gt;
&lt;h2&gt;三、和swagger结合&lt;/h2&gt;
&lt;p&gt;每次写完接口都录进文档太麻烦了，以后修改还要维护，如果能自动生成文档就好了。swagger就是解决这个问题的&lt;/p&gt;
&lt;p&gt;新建一个空的 &lt;em&gt;&lt;span&gt;Asp.net WebAPI&lt;/span&gt;&lt;/em&gt; 程序（非Core程序）并安装下swagger&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/401362/202102/401362-20210206142949785-179206174.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;Asp.net WebAPI&lt;/em&gt;&lt;/span&gt; 安装的是 &lt;em&gt;&lt;span&gt;Swashbuckle.Core&lt;/span&gt;&lt;/em&gt;，只要安装一个即可，swagger页面、js、css等文件都打包在这个dll里面。结合前篇文章已经实现的服务端接口多版本控制，现在项目结构如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/401362/202102/401362-20210206145035162-1926932524.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看下几个控制器的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Web.Http;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; WebAPISwaggerVersioning.Controllers.v1
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Employee_1_0_0_Controller : ApiController
    {
        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Get()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }
&lt;/span&gt;
&lt;span&gt;        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetEmployee()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GetEmployee:1.0.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.0.0 版本的 &lt;em&gt;&lt;span&gt;Employee&lt;/span&gt;&lt;/em&gt; 控制器有两个虚方法：&lt;em&gt;&lt;span&gt;Get&lt;/span&gt;&lt;/em&gt; 和 &lt;em&gt;&lt;span&gt;GetEmployee，&lt;/span&gt;&lt;/em&gt;因为是虚方法，如果下一个版本同样的接口有变化的话，直接 &lt;em&gt;&lt;span&gt;override&lt;/span&gt;&lt;/em&gt; 即可&lt;/p&gt;
&lt;p&gt;接下来，看看 1.0.1 版本的 &lt;em&gt;&lt;span&gt;Employee&lt;/span&gt;&lt;/em&gt; 控制器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Web.Http;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; WebAPISwaggerVersioning.Controllers.v1
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Employee_1_0_1_Controller &lt;span&gt;: Employee_1_0_0_Controller&lt;/span&gt;
    {
        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Get()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }

        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetEmployeeList()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GetEmployeeList:1.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.0.1 版本的 &lt;em&gt;&lt;span&gt;Employee&lt;/span&gt;&lt;/em&gt; 控制器重写了 1.0.0 版本的 &lt;em&gt;&lt;span&gt;Get&lt;/span&gt;&lt;/em&gt; 方法，并加了一个新的虚方法 &lt;em&gt;&lt;span&gt;GetEmployeeList&lt;/span&gt;&lt;/em&gt;，因为继承了上一个版本，所以还有一个继承过来的方法 &lt;em&gt;&lt;span&gt;GetEmployee&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;再看看 2.0.0 版本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Web.Http;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; WebAPISwaggerVersioning.Controllers.v1;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; WebAPISwaggerVersioning.Controllers.v2
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Employee_2_0_0_Controller &lt;span&gt;: Employee_1_0_1_Controller&lt;/span&gt;
    {
        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Get()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2.0.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }

        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetEmployee()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GetEmployee:2.0.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.0.0 版本接着继承上一个版本，同时重写了 &lt;em&gt;&lt;span&gt;Get&lt;/span&gt;&lt;/em&gt; 和 &lt;em&gt;&lt;span&gt;GetEmployee&lt;/span&gt;&lt;/em&gt; 方法&lt;/p&gt;
&lt;p&gt;swagger的配置类 &lt;em&gt;&lt;span&gt;SwaggerConfig.cs&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Web.Http;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Swashbuckle.Application;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; WebAPISwaggerVersioning
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SwaggerConfig
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Register()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; thisAssembly = &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(SwaggerConfig).Assembly;

            GlobalConfiguration.Configuration
                .EnableSwagger(c &lt;/span&gt;=&amp;gt;&lt;span&gt;
                {
                    c.SingleApiVersion(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;项目名称&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                })
                .EnableSwaggerUi(c &lt;/span&gt;=&amp;gt;&lt;span&gt;
                {
                    c.DocumentTitle(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WebAPISwaggerVersioning&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                });
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 直接运行起来看看效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/401362/202102/401362-20210205232133673-1457560619.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;真的不错，安装了swagger并简单配置就有了这样的效果，但是有几个问题&lt;em&gt;：&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;没有区分版本：1.x 和 2.x 的接口都在一个页面；&lt;/li&gt;
&lt;li&gt;直接把 &lt;strong&gt;控制器名称&lt;/strong&gt; 和 &lt;strong&gt;版本号&lt;/strong&gt; 都读取出来了：&lt;span&gt;&lt;em&gt;/api/Employee_1_0_0_/Get&lt;/em&gt;&lt;/span&gt;，前端调用其实是这样的：&lt;span&gt;&lt;em&gt;/api/Employee/Get&lt;/em&gt;&lt;/span&gt;，版本号携带在请求Header里；&lt;/li&gt;
&lt;li&gt;另外把 继承的方法 也读取出来了：&lt;span&gt;&lt;em&gt;Employee_1_0_1_Controller &lt;/em&gt;&lt;/span&gt;下并没有 &lt;span&gt;&lt;em&gt;GetEmployee&lt;/em&gt;&lt;/span&gt; 方法，继承的方法不需要展示，否则太多了&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现在开始改进&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Register()
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; thisAssembly = &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(SwaggerConfig).Assembly;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; xmlPath = &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}/bin/WebAPISwaggerVersioning.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, AppDomain.CurrentDomain.BaseDirectory);

    GlobalConfiguration.Configuration
        .EnableSwagger(c &lt;/span&gt;=&amp;gt;&lt;span&gt;
        {
            c.&lt;span&gt;MultipleApiVersions&lt;/span&gt;((apiDesc, targetApiVersion) &lt;/span&gt;=&amp;gt; ResolveVersionSupportByRouteConstraint(apiDesc, targetApiVersion), (v) =&amp;gt;&lt;span&gt;
             {
                 v.Version(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;版本1.x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Description(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.x接口文档。点击右上角下拉列表，查看新版本接口&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                 v.Version(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;版本2.x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Description(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;增加了手机号找回密码、财务报销等功能&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
             });
        })
        .EnableSwaggerUi(c &lt;/span&gt;=&amp;gt;&lt;span&gt;
        {
            c.DocumentTitle(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WebAPISwaggerVersioning&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            c.EnableDiscoveryUrlSelector();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下拉列表列出版本信息&lt;/span&gt;
&lt;span&gt;        });
}

&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 返回特定版本下的接口
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;apiDesc&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;targetApiVersion&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; ResolveVersionSupportByRouteConstraint(ApiDescription apiDesc, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; targetApiVersion)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; controllerFullName =&lt;span&gt; apiDesc.ActionDescriptor.ControllerDescriptor.ControllerType.FullName;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; controllerFullName.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).Contains(targetApiVersion, StringComparer.OrdinalIgnoreCase);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过 &lt;em&gt;&lt;span&gt;MultipleApiVersions&lt;/span&gt;&lt;/em&gt; 方法开启了多版本&lt;/p&gt;
&lt;p&gt;注：配置的 v1 和 v2 必须和文件夹名称相同，因为 &lt;em&gt;&lt;span&gt;ResolveVersionSupportByRouteConstraint&lt;/span&gt;&lt;/em&gt; 方法是通过命名空间来区分版本的，运行看下效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/401362/202102/401362-20210206150052978-757892295.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.x 的控制器已经不在这个页面显示了，但是丑陋的 &lt;span&gt;&lt;strong&gt;Employee_1_0_0_&lt;/strong&gt;&lt;/span&gt; 对前端不友好&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
[AttributeUsage(AttributeTargets.Class, AllowMultiple = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SwaggerControllerViewAttribute : Attribute
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 控制器名称
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ControllerName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 版本号
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Version { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Swagger文档显示
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;cName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;控制器名称&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;version&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;版本号&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; SwaggerControllerViewAttribute(&lt;span&gt;string&lt;/span&gt; cName, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; version)
    {
        ControllerName &lt;/span&gt;= &lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(cName) ? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请填写控制器名称&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : cName;
        Version &lt;/span&gt;= &lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(version) ? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请填写版本号&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : version;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;建一个特性 &lt;span&gt;&lt;em&gt;SwaggerControllerViewAttribute&lt;/em&gt;&lt;/span&gt; ，标注到控制器上&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[SwaggerControllerView(&quot;员工&quot;, &quot;v1.0.0&quot;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Employee_1_0_0_Controller : ApiController
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再利用 &lt;span&gt;&lt;em&gt;GroupActionsBy&lt;/em&gt;&lt;/span&gt; 方法读取特性为控制器分组&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
c.&lt;span&gt;GroupActionsBy&lt;/span&gt;(apiDesc =&amp;gt;&lt;span&gt;
 {
     System.Diagnostics.Debug.WriteLine(apiDesc.ID);
     &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; attribute = apiDesc.GetControllerAndActionAttributes&amp;lt;SwaggerControllerViewAttribute&amp;gt;&lt;span&gt;();
     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (attribute.Any())
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; attribute.First().ControllerName + &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; attribute.First().Version;
     &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; apiDesc.ActionDescriptor.ControllerDescriptor.ControllerName;
 });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看下效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/401362/202102/401362-20210206152507778-1681690438.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;标注在控制器上的名称已经读取出来了，再把接口后面的版本号干掉&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 自定义文档过滤器
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CustomDocumentFilter : IDocumentFilter
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Apply
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;swaggerDoc&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;文档&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;schemaRegistry&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;schema注册&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;apiExplorer&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;api概览&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Apply(SwaggerDocument swaggerDoc, SchemaRegistry schemaRegistry, IApiExplorer apiExplorer)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;多版本接口名修正&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; match = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, PathItem&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; path &lt;span&gt;in&lt;/span&gt;&lt;span&gt; swaggerDoc.paths)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; lsXG = path.Key.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lsXG.Count() == &lt;span&gt;4&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; lsXXG = lsXG[&lt;span&gt;2&lt;/span&gt;].Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lsXXG.Count() == &lt;span&gt;5&lt;/span&gt;&lt;span&gt;)
                {
                    match.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + lsXG[&lt;span&gt;1&lt;/span&gt;] + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + lsXXG[&lt;span&gt;0&lt;/span&gt;] + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + lsXG[&lt;span&gt;3&lt;/span&gt;] + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;?version=v&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + lsXXG[&lt;span&gt;1&lt;/span&gt;] + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + lsXXG[&lt;span&gt;2&lt;/span&gt;] + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + lsXXG[&lt;span&gt;3&lt;/span&gt;&lt;span&gt;], path.Value);
                }
            }
        }
        swaggerDoc.paths &lt;/span&gt;=&lt;span&gt; match;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;swaggerDoc.paths&lt;/span&gt;&lt;/em&gt; &lt;span&gt;就是所有接口，继承 &lt;em&gt;&lt;span&gt;IDocumentFilter&lt;/span&gt;&lt;/em&gt; 接口实现 &lt;span&gt;&lt;em&gt;Apply&lt;/em&gt;&lt;/span&gt; 方法，可以自定义接口名称，想怎么显示就怎么显示&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/401362/202102/401362-20210206153237114-525349547.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;接口名称已经修正了，但是有个遗憾，因为 &lt;em&gt;&lt;span&gt;swaggerDoc.paths&lt;/span&gt; &lt;/em&gt;是字典类型的，key不能重复，所以每个接口后面都跟着 &lt;em&gt;&lt;span&gt;version=，&lt;/span&gt;&lt;/em&gt;稍后通过前端注入js把 &lt;em&gt;&lt;span&gt;?version=xxx&lt;/span&gt;&lt;/em&gt; 去掉&lt;/p&gt;
&lt;h2&gt;四、柳暗花明&lt;/h2&gt;
&lt;p&gt;本以为大功告成了，但是注意看 &lt;strong&gt;/api/Employee/GetEmployee?version=v1.0.1&lt;/strong&gt; 这个接口不应该出现，如果把每个继承过来的方法都显示出来了，那简直太乱了，前端只关注本次版本新增（&lt;span&gt;&lt;em&gt;virtual&lt;/em&gt;&lt;/span&gt;）和变更（&lt;span&gt;&lt;em&gt;override&lt;/em&gt;&lt;/span&gt;）的方法&lt;/p&gt;
&lt;p&gt;到这块可把我难住了，试了很久，swagger没有提供任何一个接口可以解决这个问题。距离完美就差一点了，还是不死心，最后通过判断方法的父类解决了：父类是当前控制器就是&lt;strong&gt;新方法&lt;/strong&gt;或者&lt;strong&gt;重写&lt;/strong&gt;的方法，不是肯定就是继承过来的，直接移除不展示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; apiDesc &lt;span&gt;in&lt;/span&gt;&lt;span&gt; apiExplorer.ApiDescriptions)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; key = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; apiDesc.RelativePath;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!swaggerDoc.paths.ContainsKey(key)) &lt;span&gt;continue&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;swaggerDoc.paths是当前选择版本的接口，例：v1&lt;/span&gt;

    &lt;span&gt;var&lt;/span&gt; controllerName =&lt;span&gt; apiDesc.ActionDescriptor.ControllerDescriptor.ControllerType.Name;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; actionName =&lt;span&gt; apiDesc.ActionDescriptor.ActionName;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(controllerName) &amp;amp;&amp;amp; !&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(actionName))
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; t = Type.GetType(apiDesc.ActionDescriptor.ControllerDescriptor.ControllerType.Namespace + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; controllerName);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; baseControllerName =&lt;span&gt; t.GetMethod(actionName).DeclaringType.Name;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (controllerName !=&lt;span&gt; baseControllerName)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key.Contains(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
                    key &lt;/span&gt;= key.Substring(&lt;span&gt;0&lt;/span&gt;, key.IndexOf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, StringComparison.Ordinal));
                swaggerDoc.paths.Remove(key);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;移除继承的Action，避免文档中重复展示&lt;/span&gt;
&lt;span&gt;            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再向前端注入js解决接口后面带 &lt;em&gt;&lt;span&gt;?version=xxx&lt;/span&gt;&lt;/em&gt; 的问题。是的，swagger就是这么灵活，后端前端都可以各种自定义&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
c.InjectJavaScript(thisAssembly, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WebApiSwaggerVersioning.Scripts.swagger.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
$(&quot;#resources_container .resource&quot;).each(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (idx, item) {
    $.each($(item).find(&lt;/span&gt;&quot;.endpoints .endpoint&quot;), &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (i, v) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; path = $(v).find(&quot;.path a&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pathTxt =&lt;span&gt; path.text();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (pathTxt) {
            path.text(pathTxt.substring(&lt;/span&gt;0, pathTxt.indexOf('?'&lt;span&gt;)));
        }
    });
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看看简洁的接口名称&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/401362/202102/401362-20210206154554442-748099785.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接口已经完美了，同时注入的 &lt;span&gt;&lt;em&gt;swagger.js&lt;/em&gt;&lt;/span&gt; 里面还有汉化包，现在可以显示中文了。注：&lt;em&gt;&lt;span&gt;swagger.js&lt;/span&gt;&lt;/em&gt; 需要设置 右键 - 属性 - 生成操作 - 嵌入的资源&lt;/p&gt;
&lt;p&gt;文档里 &lt;em&gt;&lt;span&gt;/api/Employee/Get&lt;/span&gt;&lt;/em&gt; &lt;span&gt;&lt;span&gt;出现了两次，怎么区分调哪个版本呢？通过继承 &lt;span&gt;&lt;em&gt;IOperationFilter&lt;/em&gt;&lt;/span&gt; 实现向请求Header里加自定义参数&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public class AuthHeaderFilter : IOperationFilter
{
    public &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Apply(Operation operation, SchemaRegistry schemaRegistry, ApiDescription apiDescription)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (operation.parameters == &lt;span&gt;null&lt;/span&gt;) operation.parameters = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Parameter&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; string[] { };
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!string.IsNullOrEmpty(operation.operationId)) arr = operation.operationId.Split('_'&lt;span&gt;);
        operation.parameters.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Parameter { name = &quot;version&quot;, @&lt;span&gt;in&lt;/span&gt; = &quot;header&quot;, description = &quot;接口版本号&quot;, type = &quot;string&quot;, @&lt;span&gt;default&lt;/span&gt; = arr.Length &amp;gt; 4 ? arr[1] +
&quot;.&quot; + arr[2] + &quot;.&quot; + arr[3] : &quot;&quot;&lt;span&gt; });

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; filterPipeline = apiDescription.ActionDescriptor.GetFilterPipeline();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否添加权限过滤器&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; isAuthorized = filterPipeline.Select(filterInfo =&amp;gt; filterInfo.Instance).Any(filter =&amp;gt; filter is IAuthorizationFilter);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否允许匿名方法 &lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; allowAnonymous = apiDescription.ActionDescriptor.GetCustomAttributes&amp;lt;AllowAnonymousAttribute&amp;gt;&lt;span&gt;().Any();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isAuthorized &amp;amp;&amp;amp; !&lt;span&gt;allowAnonymous)
        {
            operation.parameters.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Parameter { name = &quot;token&quot;, @&lt;span&gt;in&lt;/span&gt; = &quot;header&quot;, description = &quot;接口token&quot;, required = &lt;span&gt;true&lt;/span&gt;, type = &quot;string&quot;&lt;span&gt; });
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为每个接口的Header里设置了两个参数：&lt;span&gt;&lt;em&gt;version&lt;/em&gt;&lt;/span&gt; 和 &lt;span&gt;&lt;em&gt;token&lt;/em&gt;&lt;/span&gt;，模拟APP端调接口传递的 &lt;strong&gt;版本号&lt;/strong&gt; 和 &lt;strong&gt;鉴权token&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/401362/202102/401362-20210206161026523-1371785379.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;终极效果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/401362/202102/401362-20210206161128905-775615681.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 调下 1.0.1 版本的 &lt;em&gt;&lt;span&gt;Get&lt;/span&gt;&lt;/em&gt; 接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/401362/202102/401362-20210206161224941-1872793965.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试一个不存在的Version&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/401362/202102/401362-20210206175000655-64438996.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前端即便传来了一个服务端没有的Version 1.0.5，也能自动向前找最近一个版本1.0.1的接口 &lt;/p&gt;
&lt;p&gt;至此，大功告成，最后看看对比图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/401362/202102/401362-20210206172309205-1327923360.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;五、结语&lt;/h2&gt;
&lt;p&gt;参考文章&lt;/p&gt;
&lt;p&gt;源码&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://files.cnblogs.com/files/oppoic/SwaggerDemo4Cnblogs.rar&quot; target=&quot;_blank&quot;&gt;点我下载&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 07 Feb 2021 00:20:00 +0000</pubDate>
<dc:creator>oppoic</dc:creator>
<og:description>最近研究了下swagger多版本的维护，网上的文章千篇一律，无法满足我的需求，分享下我的使用场景以及实现 演示环境：Visual Studio 2019、Asp.NET WebAPI、NET Fram</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/oppoic/p/14380233.html</dc:identifier>
</item>
<item>
<title>为何 JVM TLAB 在线程退还给堆的时候需要填充 dummy object - 干货满满张哈希</title>
<link>http://www.cnblogs.com/zhxdick/p/14383801.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhxdick/p/14383801.html</guid>
<description>&lt;p&gt;TLAB 全网最硬核的解析，请参考：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/349173209&quot; target=&quot;_blank&quot;&gt;全网最硬核 JVM TLAB 分析&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;tlab-在何时退还给堆？&quot;&gt;TLAB 在何时退还给堆？&lt;/h2&gt;
&lt;p&gt;有两种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当前 TLAB 不足分配，并且剩余空间小于当前线程最大浪费空间限制时。&lt;/li&gt;
&lt;li&gt;发生 GC 时，在 GC 扫描前的时候。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;什么是-dummy-object？&quot;&gt;什么是 dummy object？&lt;/h2&gt;
&lt;p&gt;是一个被标记为可回收的 &lt;code&gt;int[]&lt;/code&gt; 数组。填充后， GC 扫描会直接标记为可回收。&lt;/p&gt;
&lt;h2 id=&quot;为何填充-dummy-object&quot;&gt;为何填充 dummy object&lt;/h2&gt;
&lt;p&gt;主要保证 GC 的时候扫描高效。由于 TLAB 仅线程内知道哪些被分配了，在 GC 扫描发生时返回 Eden 区，如果不填充的话，外部并不知道哪一部分被使用哪一部分没有，需要做额外的检查，如果填充已经确认会被回收的对象，也就是 dummy object， GC 会直接标记之后跳过这块内存，增加扫描效率。反正这块内存已经属于 TLAB，其他线程在下次扫描结束前是无法使用的。这个 dummy object 就是 int 数组。为了一定能有填充 dummy object 的空间，&lt;strong&gt;一般 TLAB 大小都会预留一个 dummy object 的 header 的空间&lt;/strong&gt;，也是一个 &lt;code&gt;int[]&lt;/code&gt; 的 header，所以 TLAB 的大小不能超过int 数组的最大大小，否则无法用 dummy object 填满未使用的空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每日一刷，轻松提升技术，斩获各种offer：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zhxhash-blog.oss-cn-beijing.aliyuncs.com/qr-code.jpg&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 07 Feb 2021 00:16:00 +0000</pubDate>
<dc:creator>干货满满张哈希</dc:creator>
<og:description>TLAB 全网最硬核的解析，请参考：全网最硬核 JVM TLAB 分析 TLAB 在何时退还给堆？ 有两种情况： 当前 TLAB 不足分配，并且剩余空间小于当前线程最大浪费空间限制时。 发生 GC 时</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhxdick/p/14383801.html</dc:identifier>
</item>
<item>
<title>jackson学习之九：springboot整合(配置文件) - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/14383800.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/14383800.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;blockquote readability=&quot;3.8613861386139&quot;&gt;
&lt;p&gt;这里分类和汇总了欣宸的全部原创(含配套源码)：&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;系列文章汇总&quot;&gt;系列文章汇总&lt;/h3&gt;
&lt;h3 id=&quot;关于springboot整合jackson&quot;&gt;关于springboot整合jackson&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;本文是《jackson学习》系列的第九篇，学习如何在springboot项目中使用jackson，以springboot-2.3.3版本为例，jackson是springboot的默认json处理工具，如下图红框所示，jackson在maven配置中被spring-boot-starter-web间接依赖，可直接使用：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210207081333433-909002255.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在springboot项目中常用的配置方式有两种：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;用properties或yml配置文件来配置，即本篇的内容；&lt;/li&gt;
&lt;li&gt;用配置类来配置，这是下一篇文章的主题；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;本篇概览&quot;&gt;本篇概览&lt;/h3&gt;
&lt;p&gt;今天实战内容如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;开发springboot应用，体验springboot默认支持jackson，包括jackson注解和ObjectMapper实例的注入；&lt;/li&gt;
&lt;li&gt;在&lt;span&gt;application.yml&lt;/span&gt;中添加jackson配置，验证是否生效；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;源码下载&quot;&gt;源码下载&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;如果您不想编码，可以在GitHub下载所有源码，地址和链接信息如下表所示(&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;)：&lt;/li&gt;
&lt;/ol&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;这个git项目中有多个文件夹，本章的应用在&lt;span&gt;jacksondemo&lt;/span&gt;文件夹下，如下图红框所示：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210207081333822-1365721848.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;&lt;span&gt;jacksondemo&lt;/span&gt;是父子结构的工程，本篇的代码在&lt;span&gt;springbootproperties&lt;/span&gt;子工程中，如下图：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210207081334135-664514907.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;开始实战&quot;&gt;开始实战&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;由于同属于《jackson学习》系列文章，因此本篇的springboot工程作为&lt;span&gt;jacksondemo&lt;/span&gt;的子工程存在，pom.xml如下，需要注意的是parent不能使用spring-boot-starter-parent，而是通过dependencyManagement节点来引入springboot依赖：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;artifactId&amp;gt;jacksondemo&amp;lt;/artifactId&amp;gt;
        &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;relativePath&amp;gt;../pom.xml&amp;lt;/relativePath&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;springbootproperties&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;springbootproperties&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;/properties&amp;gt;


    &amp;lt;!--不用spring-boot-starter-parent作为parent时的配置--&amp;gt;
    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-dependencies&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;2.3.3.RELEASE&amp;lt;/version&amp;gt;
                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
                &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
    &amp;lt;/dependencyManagement&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- swagger依赖 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- swagger-ui --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;springfox-swagger-ui&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;启动类很平常：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.springbootproperties;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SpringbootpropertiesApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringbootpropertiesApplication.class, args);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;由于用到了swagger，因此要添加swagger配置：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.springbootproperties;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Contact;
import springfox.documentation.service.Tag;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

@Configuration
@EnableSwagger2
public class SwaggerConfig {

    @Bean
    public Docket createRestApi() {
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo())
                .tags(new Tag(&quot;JsonPropertySerializationController&quot;, &quot;JsonProperty相关测试&quot;))
                .select()
                // 当前包路径
                .apis(RequestHandlerSelectors.basePackage(&quot;com.bolingcavalry.springbootproperties.controller&quot;))
                .paths(PathSelectors.any())
                .build();
    }

    //构建 api文档的详细信息函数,注意这里的注解引用的是哪个
    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                //页面标题
                .title(&quot;SpringBoot整合Jackson(基于配置文件)&quot;)
                //创建人
                .contact(new Contact(&quot;程序员欣宸&quot;, &quot;https://github.com/zq2599/blog_demos&quot;, &quot;zq2599@gmail.com&quot;))
                //版本号
                .version(&quot;1.0&quot;)
                //描述
                .description(&quot;API 描述&quot;)
                .build();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;序列化和反序列化用到的Bean类，可见使用了&lt;span&gt;JsonProperty&lt;/span&gt;属性来设置序列化和反序列化时的json属性名，field0字段刻意没有get方法，是为了验证JsonProperty的序列化能力：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.springbootproperties.bean;

import com.fasterxml.jackson.annotation.JsonProperty;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

import java.util.Date;

@ApiModel(description = &quot;JsonProperty注解测试类&quot;)
public class Test {

    @ApiModelProperty(value = &quot;私有成员变量&quot;)
    @JsonProperty(value = &quot;json_field0&quot;, index = 1)
    private Date field0 = new Date();

    public void setField0(Date field0) {
        this.field0 = field0;
    }

    @ApiModelProperty(value = &quot;来自get方法的字符串&quot;)
    @JsonProperty(value = &quot;json_field1&quot;, index = 0)
    public String getField1() {
        return &quot;111&quot;;
    }

    @Override
    public String toString() {
        return &quot;Test{&quot; +
                &quot;field0=&quot; + field0 +
                '}';
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;测试用的Controller代码如下，很简单只有两个接口，serialization返回序列化结果，deserialization接受客户端请求参数，反序列化成实例，通过toString()来检查反序列化的结果，另外，还通过Autowired注解从spring容器中将ObjectMapper实例直接拿来用：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.springbootproperties.controller;

import com.bolingcavalry.springbootproperties.bean.Test;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&quot;/jsonproperty&quot;)
@Api(tags = {&quot;JsonPropertySerializationController&quot;})
public class JsonPropertySerializationController {

    private static final Logger logger = LoggerFactory.getLogger(JsonPropertySerializationController.class);

    @Autowired
    ObjectMapper mapper;

    @ApiOperation(value = &quot;测试序列化&quot;, notes = &quot;测试序列化&quot;)
    @RequestMapping(value = &quot;/serialization&quot;, method = RequestMethod.GET)
    public Test serialization() throws JsonProcessingException {

        Test test = new Test();
        logger.info(mapper.writeValueAsString(test));

        return test;
    }

    @ApiOperation(value = &quot;测试反序列化&quot;, notes=&quot;测试反序列化&quot;)
    @RequestMapping(value = &quot;/deserialization&quot;,method = RequestMethod.PUT)
    public String deserialization(@RequestBody Test test) {
        return test.toString();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;验证不用配置文件&quot;&gt;验证(不用配置文件)&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;先来看看没有配置文件时，默认的jackson配置的表现，直接在IDEA上运行SpringbootpropertiesApplication；&lt;/li&gt;
&lt;li&gt;浏览器访问http://localhost:8080/swagger-ui.html ，如下图红框1，json_field0和json_field1都是JsonProperty注释，出现在了swagger的model中，这证明jackson注解已经生效：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210207081334892-434458709.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;点击上图的红框2，看看springboot引用返回的序列化结果，如下图：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210207081335669-233523178.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;另外，上述红框中的json格式，每个属性单独一行，像是做了格式化调整的，这是springboot做的？还是swagger展示的时候做的？用浏览器访问http://localhost:8080/jsonproperty/serialization ，结果如下，可见&lt;span&gt;springboot返回的是未经过格式化的json&lt;/span&gt;：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210207081335970-2129579136.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;接下来咱们添加jackson相关的配置信息并验证是否生效；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;添加配置文件并验证&quot;&gt;添加配置文件并验证&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;在&lt;span&gt;resources&lt;/span&gt;目录新增&lt;span&gt;application.yml&lt;/span&gt;文件，内容如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;spring:
  jackson:
    # 日期格式化
    date-format: yyyy-MM-dd HH:mm:ss
    # 序列化相关
    serialization:
      # 格式化输出
      indent_output: true
      # 忽略无法转换的对象
      fail_on_empty_beans: true
    # 反序列化相关
    deserialization:
      # 解析json时，遇到不存在的属性就忽略
      fail_on_unknown_properties: false
    # 设置空如何序列化
    defaultPropertyInclusion: NON_EMPTY
    parser:
      # 允许特殊和转义符
      allow_unquoted_control_chars: true
      # 允许单引号
      allow_single_quotes: true
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;将鼠标放置下图红框位置，再按住Ctlr键，IDEA会弹出一个浮层，提示该配置对应的jackson代码，如下图：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210207081336389-890938956.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;在上图中，按住Ctlr键，用鼠标点击红框位置即可打开此配置对应的jackson源码，如下图：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210207081336719-621472058.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;4. 重新运行springboot应用，用浏览器访问：&lt;a href=&quot;http://localhost:8080/jsonproperty/serialization&quot; target=&quot;_blank&quot;&gt;http://localhost:8080/jsonproperty/serialization&lt;/a&gt; ，结果如下图，可见&lt;span&gt;json_field0&lt;/span&gt;的格式变成了&lt;span&gt;yyyy-MM-dd HH:mm:ss&lt;/span&gt;，而且json输出也做了格式化，证明application.yml中的配置已经生效：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210207081336958-1061131552.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;5. 再来试试反序列化，打开swagger页面，操作和响应如下图所示，注意红框1里面请求参数的格式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210207081337496-1740568860.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;至此，在springboot中通过yml配置jackson的操作实战就完成了，接下来的章节，咱们在配置类中用代码来完成yml的配置；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;你不孤单，欣宸原创一路相伴&quot;&gt;你不孤单，欣宸原创一路相伴&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105068742&quot; target=&quot;_blank&quot;&gt;Java系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086498&quot; target=&quot;_blank&quot;&gt;Spring系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086732&quot; target=&quot;_blank&quot;&gt;Docker系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086794&quot; target=&quot;_blank&quot;&gt;kubernetes系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086850&quot; target=&quot;_blank&quot;&gt;数据库+中间件系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086920&quot; target=&quot;_blank&quot;&gt;DevOps系列&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 07 Feb 2021 00:14:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub 这里分类和汇总了欣宸的全部原创(含配套源码)：https://github.com/zq2599/blog_demos 系列文章汇总 jackson学习之一：基本信息 jac</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/14383800.html</dc:identifier>
</item>
<item>
<title> MiniProfiler性能分析工具— .Net Core中用法 - chaney1992</title>
<link>http://www.cnblogs.com/cwsheng/p/14383498.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cwsheng/p/14383498.html</guid>
<description>&lt;h3&gt;前言：&lt;/h3&gt;
&lt;p&gt;　在日常开发中，应用程序的性能是我们需要关注的一个重点问题。当然我们有很多工具来分析程序性能：如：Zipkin等；但这些过于复杂，需要单独搭建。&lt;/p&gt;
&lt;p&gt;　MiniProfiler就是一款简单，但功能强大的应用新能分析工具；可以帮助我们定位：&lt;strong&gt;SQL性能问题、响应慢&lt;/strong&gt;等问题。&lt;/p&gt;
&lt;p&gt;　本篇文章将介绍MiniProfiler在Asp.Net Core中如何使用&lt;/p&gt;
&lt;h3&gt;一、MiniProfiler介绍&lt;/h3&gt;
&lt;p&gt; 　MiniProfiler是一款针对.NET, Ruby, Go and Node.js的性能分析的轻量级程序。可以对一个页面本身，及该页面通过直接引用、Ajax、Iframe形式访问的其它页面进行监控,监控内容包括数据库内容，并可以显示数据库访问的SQL（支持EF、EF CodeFirst等 ）。并且以很友好的方式展现在页面上。&lt;/p&gt;
&lt;p&gt;    MiniProfiler官网：&lt;a href=&quot;http://miniprofiler.com/&quot; target=&quot;_blank&quot;&gt;http://miniprofiler.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;    MiniProfiler的一个特别有用的功能是它与数据库框架的集成。除了.NET原生的 DbConnection类，MiniProfiler还内置了对实体框架（Entity Framework）以及LINQ to SQL、RavenDb和MongoDB的支持。任何执行的Step都会包括当时查询的次数和所花费的时间。为了检测常见的错误，如N+1反模式，profiler将检测仅有参数值存在差异的多个查询。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;二、MiniProfiler用法&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　1、Nuget包安装：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Mvc&lt;/span&gt;
Install-&lt;span&gt;Package MiniProfiler.AspNetCore.Mvc
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;EF分析添加&lt;/span&gt;
Install-Package MiniProfiler.EntityFrameworkCore
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　2&lt;strong&gt;、配置MiniProfiler：修改Startup.cs&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;a) 注入MiniProfiler&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...其他配置...

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注入MiniProfiler&lt;/span&gt;
    services.AddMiniProfiler(options =&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;访问地址路由根目录；默认为：/mini-profiler-resources&lt;/span&gt;
        options.RouteBasePath = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/profiler&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据缓存时间&lt;/span&gt;
        (options.Storage &lt;span&gt;as&lt;/span&gt; MemoryCacheStorage).CacheDuration = TimeSpan.FromMinutes(&lt;span&gt;60&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;sql格式化设置&lt;/span&gt;
        options.SqlFormatter = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StackExchange.Profiling.SqlFormatters.InlineFormatter();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;跟踪连接打开关闭&lt;/span&gt;
        options.TrackConnectionOpenClose = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;界面主题颜色方案;默认浅色&lt;/span&gt;
        options.ColorScheme =&lt;span&gt; StackExchange.Profiling.ColorScheme.Dark;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;.net core 3.0以上：对MVC过滤器进行分析&lt;/span&gt;
        options.EnableMvcFilterProfiling = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对视图进行分析&lt;/span&gt;
        options.EnableMvcViewProfiling = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;控制访问页面授权，默认所有人都能访问
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;options.ResultsAuthorize;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;要控制分析哪些请求，默认说有请求都分析
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;options.ShouldProfile;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;内部异常处理
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;options.OnInternalError = e =&amp;gt; MyExceptionLogger(e);&lt;/span&gt;
&lt;span&gt;    })
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; AddEntityFramework是要监控EntityFrameworkCore生成的SQL&lt;/span&gt;
&lt;span&gt;    .AddEntityFramework();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　b) 启用MiniProfiler　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory, IMemoryCache cache)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...其他配置

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;该方法必须在app.UseEndpoints以前&lt;/span&gt;
&lt;span&gt;    app.UseMiniProfiler();

    app.UseEndpoints(routes &lt;/span&gt;=&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;    });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　c) MVC项目：&lt;/p&gt;
&lt;p&gt;　　　修改 _ViewImports.cshtml 　　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@using StackExchange.Profiling
@addTagHelper &lt;/span&gt;*, MiniProfiler.AspNetCore.Mvc
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　将MiniProfiler添加到布局文件（Shared/_Layout.cshtml）中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&amp;lt;mini-profiler /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　d) 运行效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/374428/202102/374428-20210207064904871-1611885604.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/374428/202102/374428-20210207064932716-1717162009.png&quot; alt=&quot;&quot; width=&quot;895&quot; height=&quot;610&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;h3&gt;三、 Swagger UI接入MiniProfiler&lt;/h3&gt;
&lt;p&gt;　使用步骤和前面大体一样&lt;/p&gt;
&lt;p&gt;　1、下载Swagger页面：&lt;/p&gt;
&lt;p&gt;　　请先在Github中下载对应版本的swagger页面：https://github.com/domaindrivendev/Swashbuckle.AspNetCore/blob/master/src/Swashbuckle.AspNetCore.SwaggerUI/index.html&lt;/p&gt;
&lt;p&gt;　2、添加到项目中,并设置index.html为：内嵌资源&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/374428/202102/374428-20210207065457846-1013400899.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　3、修改UseSwaggerUI中间件的配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
app.UseSwaggerUI(c =&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;AuditLogDemo项目命名空间&lt;/span&gt;
    c.SwaggerEndpoint(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/swagger/v1/swagger.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AuditLogDemo API V1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    c.IndexStream &lt;/span&gt;= () =&amp;gt; GetType().GetTypeInfo().Assembly.GetManifestResourceStream(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AuditLogDemo.wwwroot.index.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　4、获取MiniProfiler的html代码片段　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取html片段
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;[HttpGet]
[Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GetHtml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult GetHtml()
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; html =&lt;span&gt; MiniProfiler.Current.RenderIncludes(HttpContext);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ok(html.Value);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/374428/202102/374428-20210207070232863-2107249603.png&quot; alt=&quot;&quot; width=&quot;872&quot; height=&quot;489&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　5、在Swagger的Html中添加获取的MiniProfiler片段&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- HTML &lt;span&gt;for&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; distribution bundle build --&amp;gt;
&lt;span&gt;&lt;strong&gt;&amp;lt;script async=&quot;async&quot; id=&quot;mini-profiler&quot; src=&quot;/profiler/includes.min.js?v=4.2.22+4563a9e1ab&quot; 
        data-version=&quot;4.2.22+4563a9e1ab&quot; data-path=&quot;/profiler/&quot; 
        data-current-id=&quot;0601948b-d995-4a86-9cae-33d73ecd2f59&quot; 
        data-ids=&quot;0601948b-d995-4a86-9cae-33d73ecd2f59&quot; 
        data-position=&quot;Left&quot; 
        data-scheme=&quot;Dark&quot; 
        data-authorized=&quot;true&quot; 
        data-max-traces=&quot;15&quot; 
        data-toggle-shortcut=&quot;Alt+P&quot; 
        data-trivial-milliseconds=&quot;2.0&quot; 
        data-ignored-duplicate-execute-types=&quot;Open,OpenAsync,Close,CloseAsync&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/strong&gt;&lt;/span&gt;

&amp;lt;!-- HTML &lt;span&gt;for&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; distribution bundle build --&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;title&amp;gt;%(DocumentTitle)&amp;lt;/title&amp;gt;&lt;span&gt;
    ……&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　6、调用效果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/374428/202102/374428-20210207070921641-1742731682.png&quot; alt=&quot;&quot; width=&quot;970&quot; height=&quot;386&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/374428/202102/374428-20210207071748759-310365915.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　如上图可以查看到所有请求路径及Sql操作耗时，那么如果需要监控指定代码块耗时如何实现呢&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;四、自定义标记：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　 &lt;/strong&gt; 1、添加标记代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; miniPro =&lt;span&gt; MiniProfiler.Current;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (miniPro.Step(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Add AuditLog&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存审计日志&lt;/span&gt;
    &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _auditLogService.SaveAsync(auditInfo);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/374428/202102/374428-20210207072512446-419283003.png&quot; alt=&quot;&quot; width=&quot;804&quot; height=&quot;694&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　2、取消监控方式：　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt;(MiniProfiler.Current.Ignore())
{
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;代码     &lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　3、当然MiniProfiler还有很多其他功能等待解锁：如监控ADO.NET执行耗时，需要使用：ProfileDBConnection 和 ProfileDBCommand对象：&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　1、MiniProfiler使用非常简单&lt;br/&gt;　2、功能满足日常中程序性能优化相关问题&lt;/p&gt;
&lt;h4&gt;其他：　&lt;/h4&gt;
&lt;p&gt;　MiniProfiler的监控列表地址：http://{xxx}/profiler/results-index&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/374428/202102/374428-20210207071404163-2047522593.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;　　&lt;/p&gt;

</description>
<pubDate>Sun, 07 Feb 2021 00:08:00 +0000</pubDate>
<dc:creator>chaney1992</dc:creator>
<og:description>前言： 在日常开发中，应用程序的性能是我们需要关注的一个重点问题。当然我们有很多工具来分析程序性能：如：Zipkin等；但这些过于复杂，需要单独搭建。 MiniProfiler就是一款简单，但功能强大</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cwsheng/p/14383498.html</dc:identifier>
</item>
<item>
<title>技术基础 | 舍弃”读修复概率”特性 - DataStax</title>
<link>http://www.cnblogs.com/datastax/p/14383779.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/datastax/p/14383779.html</guid>
<description>&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;a763a&quot; data-offset-key=&quot;f04tl-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;f04tl-0-0&quot;&gt;读修复这个特性给系统施加了额外的负载，却没有任何实质好处——这就是为什么我们一直以来都会建议大家先关闭这个特性；这也是在下一个Cassandra主要的版本，即Cassandra 4.0版本中，将这个特性完全拿掉的根本原因。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;a763a&quot; data-offset-key=&quot;4hkqp-0-0&quot; readability=&quot;9&quot;&gt;

&lt;p&gt;&lt;span data-offset-key=&quot;4hkqp-0-0&quot;&gt;Apache Cassandra有一个叫做读修复概率(Read Repair Chance)的特性，通常我们都会建议我们的用户关闭这个功能，因为它经常会给你的集群内部增加大约20%的读负载成本，但这样的成本付出却目的不明且效果难保。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;anuev-0-0&quot;&gt;01 &lt;span data-offset-key=&quot;anuev-0-1&quot;&gt;什么是读修复概率？&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;a763a&quot; data-offset-key=&quot;dv34s-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;dv34s-0-0&quot;&gt;Read Repair Chance可以通过两个数据表级别的模式(schema)选项来进行设置：&lt;span data-offset-key=&quot;dv34s-0-1&quot;&gt;read_repair_chance&lt;span data-offset-key=&quot;dv34s-0-2&quot;&gt;和&lt;span data-offset-key=&quot;dv34s-0-3&quot;&gt;dclocal_read_repair_chance&lt;span data-offset-key=&quot;dv34s-0-4&quot;&gt;。这两个选项都代表着在要求的一致性级别(consistency level)之上，协调节点(coordinator node)为了进行读修复而向额外的副本节点(replica node)发送请求的概率。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;a763a&quot; data-offset-key=&quot;7jgup-0-0&quot;&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;7jgup-0-0&quot;&gt;&lt;span data-offset-key=&quot;7jgup-0-0&quot;&gt;read_repair_chance&lt;span data-offset-key=&quot;7jgup-0-1&quot;&gt;的&lt;a class=&quot;Link ztext-link&quot; href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-930&quot; target=&quot;_blank&quot; data-offset-key=&quot;7jgup-1-0&quot; data-editable=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;7jgup-1-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;原始&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span data-offset-key=&quot;7jgup-2-0&quot;&gt;设定&lt;a class=&quot;Link ztext-link&quot; href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-930&quot; target=&quot;_blank&quot; data-offset-key=&quot;7jgup-3-0&quot; data-editable=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;7jgup-3-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;决定&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span data-offset-key=&quot;7jgup-4-0&quot;&gt;了在所有数据中心范围内，向所有副本发送额外请求的概率。而&lt;a class=&quot;Link ztext-link&quot; href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-930&quot; target=&quot;_blank&quot; data-offset-key=&quot;7jgup-5-0&quot; data-editable=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;7jgup-5-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;后来&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span data-offset-key=&quot;7jgup-6-0&quot;&gt;出现的&lt;span data-offset-key=&quot;7jgup-6-1&quot;&gt;dclocal_read_repair_chance&lt;span data-offset-key=&quot;7jgup-6-2&quot;&gt;设定则决定了在本地的数据中心范围内，向所有副本发送额外请求的概率。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;a763a&quot; data-offset-key=&quot;bmm8l-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;bmm8l-0-0&quot;&gt;默认值是&lt;span data-offset-key=&quot;bmm8l-0-1&quot;&gt;read_repair_chance = 0.0&lt;span data-offset-key=&quot;bmm8l-0-2&quot;&gt;以及&lt;span data-offset-key=&quot;bmm8l-0-3&quot;&gt;dclocal_read_repair_chance = 0.1&lt;span data-offset-key=&quot;bmm8l-0-4&quot;&gt;。这意味着跨数据中心的异步读修复默认是被关闭的，而在本地数据中心范围内的异步读修复发生的概率是收到的读取请求数量的10%。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;9ap9i-0-0&quot;&gt;02 &lt;span data-offset-key=&quot;9ap9i-0-1&quot;&gt;读修复的成本几何？&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;a763a&quot; data-offset-key=&quot;2he5k-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;2he5k-0-0&quot;&gt;考虑一下下面的集群部署方案：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;ul class=&quot;public-DraftStyleDefault-ul&quot; data-offset-key=&quot;dvpm8-0-0&quot; readability=&quot;1.5&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;a763a&quot; data-offset-key=&quot;dvpm8-0-0&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;dvpm8-0-0&quot;&gt;在一个单独的数据中心里有一个键空间，其复制因子(replication factor)为3，即RF=3&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;a763a&quot; data-offset-key=&quot;13dkb-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;13dkb-0-0&quot;&gt;默认值是&lt;span data-offset-key=&quot;13dkb-0-1&quot;&gt;dclocal_read_repair_chance = 0.1&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;a763a&quot; data-offset-key=&quot;6ddr1-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;6ddr1-0-0&quot;&gt;客户端读取的一致性级别为LOCAL_QUORUM&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;a763a&quot; data-offset-key=&quot;ch5rl-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ch5rl-0-0&quot;&gt;客户端使用大多数驱动程序默认的token aware policy&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;a763a&quot; data-offset-key=&quot;bfq3-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;bfq3-0-0&quot;&gt;在这种设置之下，集群将有大约10%的读取请求会导致协调节点需要不仅向一个副本节点，而是要向两个副本节点发送消息系统请求。而这会导致大约5%的额外负载。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;a763a&quot; data-offset-key=&quot;7a9i7-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;7a9i7-0-0&quot;&gt;如果要求的一致性级别是Java驱动程序默认的LOCAL_ONE，那么大约有10%的读取请求会导致协调节点将消息系统请求的数量从0增加到2。而这意味着大约20%的读负载的增加。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;a763a&quot; data-offset-key=&quot;29g7e-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;29g7e-0-0&quot;&gt;在&lt;span data-offset-key=&quot;29g7e-0-1&quot;&gt;read_repair_chance = 0.1&lt;span data-offset-key=&quot;29g7e-0-2&quot;&gt;且多数据中心的条件下，情况就更糟糕了。如果有3个RF=3的数据中心，那么10%的读请求会导致协调节点向8个额外的副本节点发送请求，且去往其中的6个副本节点的请求将需要跨数据中心。这种情况下，读负载将会翻倍。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;



&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;a763a&quot; data-offset-key=&quot;3vbq8-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;3vbq8-0-0&quot;&gt;第一张火焰图展示的是&lt;span data-offset-key=&quot;3vbq8-0-1&quot;&gt;dclocal_read_repair_chance = 0.1&lt;span data-offset-key=&quot;3vbq8-0-2&quot;&gt;的默认配置下的情况。当协调节点的代码走到&lt;span data-offset-key=&quot;3vbq8-0-3&quot;&gt;AbstractReadExecutor.getReadExecutor(..)&lt;span data-offset-key=&quot;3vbq8-0-4&quot;&gt;方法时，下一步就会根据表格的&lt;span data-offset-key=&quot;3vbq8-0-5&quot;&gt;ReadRepairDecision&lt;span data-offset-key=&quot;3vbq8-0-6&quot;&gt;参数的值来执行不同路径的代码了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;a763a&quot; data-offset-key=&quot;8othn-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;8othn-0-0&quot;&gt;有关&lt;span data-offset-key=&quot;8othn-0-1&quot;&gt;AlwaysSpeculatingReadExecutor&lt;span data-offset-key=&quot;8othn-0-2&quot;&gt;、&lt;span data-offset-key=&quot;8othn-0-3&quot;&gt;SpeculatingReadExecutor&lt;span data-offset-key=&quot;8othn-0-4&quot;&gt;或&lt;span data-offset-key=&quot;8othn-0-5&quot;&gt;NeverSpeculatingReadExecutor&lt;span data-offset-key=&quot;8othn-0-6&quot;&gt;的栈追踪(stack trace)信息可以帮我们了解系统正在执行哪条路径上的代码，以及到底是read repair chance还是推测性重试(speculative retry)正在被执行。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic2.zhimg.com/80/v2-b44a8fbc4cdac80ba1fc6571b4d7fae1_720w.png&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2392&quot; data-rawheight=&quot;1424&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic2.zhimg.com/v2-b44a8fbc4cdac80ba1fc6571b4d7fae1.png&quot; data-watermark-src=&quot;https://pic4.zhimg.com/v2-1778ba2efeb0462f357b8497adf3e9e3.png&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;a763a&quot; data-offset-key=&quot;4b3i0-0-0&quot;&gt;

&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;4b3i0-0-0&quot;&gt;&lt;span data-offset-key=&quot;4b3i0-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;第二张&lt;a class=&quot;Link ztext-link&quot; href=&quot;https://thelastpickle.com/files/2021-01-12-get_rid_of_repair_repair_chance/flame_away_no_rr.svg&quot; target=&quot;_blank&quot; data-offset-key=&quot;4b3i0-1-0&quot; data-editable=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;4b3i0-1-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;火焰图&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span data-offset-key=&quot;4b3i0-2-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;展示的是当配置被改成&lt;span data-offset-key=&quot;4b3i0-2-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;dclocal_read_repair_chance = 0.0&lt;span data-offset-key=&quot;4b3i0-2-2&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;之后的情况。可以看到&lt;span data-offset-key=&quot;4b3i0-2-3&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;AlwaysSpeculatingReadExecutor&lt;span data-offset-key=&quot;4b3i0-2-4&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;的那支火焰降下去了，这显示出系统运行时的复杂程度降低了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;a763a&quot; data-offset-key=&quot;7o28e-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;7o28e-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;具体来说，复杂度的降低是因为从客户端发来的读请求在这种情况下会被转发给每一个副本节点，而非仅仅转发给一致性级别定义的那些副本。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic2.zhimg.com/80/v2-d74cda16b3f83d54ddd3f51096ef4357_720w.png&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2392&quot; data-rawheight=&quot;1424&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic2.zhimg.com/v2-d74cda16b3f83d54ddd3f51096ef4357.png&quot; data-watermark-src=&quot;https://pic2.zhimg.com/v2-4d3f2d3d45a9fbe85fd0a7ecf2e96021.png&quot;/&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;a763a&quot; data-offset-key=&quot;1iu0a-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;1iu0a-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;这两张火焰图均是在使用Apache Cassandra 3.11.9、Kubernetes和cass-operator、nosqlbench以及async-profiler的情况下生成的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;a763a&quot; data-offset-key=&quot;drj6g-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;drj6g-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;以前，我们需要依赖于已有的tlp-cluster、ccm、tlp-stress和cassandra-stress工具进行测试。而新工具带来的新测试方式格外地简单。通过使用k8s，同样的测试方式可以在本地或针对k8s的基础架构下使用。也就是说，我们无需在用于本地测试的ccm集群和用于云端测试的tlp-cluster中间来回切换。这条适用于所有的地方。我也并不是非要使用AWS做云端测试。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;a763a&quot; data-offset-key=&quot;aa133-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;aa133-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;另外还值得一提的是这些新工具得到了来自DataStax的很多关注和支持，所以向开源社区介绍这些是值得的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;5bjso-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;03 &lt;span data-offset-key=&quot;5bjso-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;用额外的负载换得的好处是什么？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;a763a&quot; data-offset-key=&quot;2r76s-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;2r76s-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;根据用户要求的一致性级别，当协调节点从多个副本节点中的任意一个获得回复后，它就会将这个结果返回给客户端。这也是为什么我们将这个特性称为“异步”读修复——虽然额外的后台负载会间接地影响读取操作的时延，但是这种影响并不是直接的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;a763a&quot; data-offset-key=&quot;5a7r3-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;5a7r3-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;异步的读修复同时意味着返回给客户端的结果不一定是修复后的数据。总的来说，你读取的数据中的10%是一定会在你读取之后被修复的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;a763a&quot; data-offset-key=&quot;59bhh-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;59bhh-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;而这个修复概率并不是对客户端来说被保证的概率，各种Cassandra operator也没法根据它赖以保证磁盘存储的数据的一致性的。事实上，这种修复概率对Cassandra operator没有什么保证，因为大多数不一致的数据都由hints处理，而节点宕机时间长于hint窗口的情况则需要手动修复。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;a763a&quot; data-offset-key=&quot;16kcf-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;16kcf-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;除此之外，使用强一致性的系统（如读写操作都使用QUORUM作为一致性级别的系统）并不会出现这种数据未修复的情况。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;a763a&quot; data-offset-key=&quot;e7n0c-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;e7n0c-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;这种系统需要做repair操作和磁盘上的数据一致性只是为了降低读取操作的时延（通过避免协调节点和副本节点之间因digest不匹配而引起的反复通信），同时确保已经被删除的数据不会被错误地读到（即墓碑都被合理且及时地发送到各个副本）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;a763a&quot; data-offset-key=&quot;difvn-0-0&quot;&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;difvn-0-0&quot;&gt;&lt;span data-offset-key=&quot;difvn-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;所以说，读修复这个特性给系统施加了额外的负载，却没有任何实质好处。这就是为什么我们一直以来都会建议大家先关闭这个特性。&lt;a class=&quot;Link ztext-link&quot; href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-13910&quot; target=&quot;_blank&quot; data-offset-key=&quot;difvn-1-0&quot; data-editable=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;difvn-1-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;这&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span data-offset-key=&quot;difvn-2-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;也是在下一个Cassandra主要的版本，即Cassandra 4.0版本中，将这个特性完全拿掉的根本原因。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;a763a&quot; data-offset-key=&quot;ar2o6-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ar2o6-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;从3.0.17 和3.11.3版本开始，如果你仍在你的数据库表中设置了与这些属性相关的值，你可能会在系统启动时看到如下警告：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;ar2o6-0-0&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dclocal_read_repair_chance table option has been deprecated and will be removed &lt;span&gt;in&lt;/span&gt; version &lt;span&gt;4.0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;9fr0v-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;04 &lt;span data-offset-key=&quot;9fr0v-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;现在就舍弃读修复吧&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;a763a&quot; data-offset-key=&quot;dvqg8-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;dvqg8-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;如果你使用的是4.0版本以前的Cassandra集群，下方代码可关闭异步读修复功能：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;86s96-0-0&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
cqlsh -e &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ALTER TABLE &amp;lt;keyspace_name&amp;gt;.&amp;lt;table_name&amp;gt; WITH read_repair_chance = 0.0 AND dclocal_read_repair_chance = 0.0;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;a763a&quot; data-offset-key=&quot;dbhdi-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;dbhdi-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;如果你已经升级到了Cassandra 4.0，那么你无需任何额外操作，因为读修复相关的设置已经被忽略和删除了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 06 Feb 2021 23:31:00 +0000</pubDate>
<dc:creator>DataStax</dc:creator>
<og:description>读修复这个特性给系统施加了额外的负载，却没有任何实质好处——这就是为什么我们一直以来都会建议大家先关闭这个特性；这也是在下一个Cassandra主要的版本，即Cassandra 4.0版本中，将这个特</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/datastax/p/14383779.html</dc:identifier>
</item>
<item>
<title>Qt update刷新之源码分析(一) - IT文艺男</title>
<link>http://www.cnblogs.com/appsucc/p/14383740.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/appsucc/p/14383740.html</guid>
<description>&lt;p&gt;Qt update刷新之源码分析系列主要结合Qt源码对Qt的刷新机制进行深度剖析，例如要让控件刷新，会调用update函数；那么在调用了update函数后，Qt究竟基于什么原理、执行了什么代码使得屏幕上有变化？ 这篇博文主要讲述从update调用到发送更新请求事件的过程； 这篇博文里面包含了Qt里的顶层窗口、标脏、BackingStore、同步刷新、异步刷新等概念以及技术；&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;118&quot;&gt;
&lt;p&gt;在做GUI开发时，要让控件刷新，会调用update函数；那么在调用了update函数后，Qt究竟基于什么原理、执行了什么代码使得屏幕上有变化？本文就带大家来探究探究其内部源码。&lt;/p&gt;
&lt;p&gt;Qt手册中关于&lt;strong&gt;QWidget::update()&lt;/strong&gt;解释如下：：&lt;/p&gt;
&lt;p&gt;Updates the widget unless updates are disabled or the widget is hidden.&lt;/p&gt;
&lt;p&gt;This function does not cause an immediate repaint; instead it schedules a paint event for processing when Qt returns to the main event loop. This permits Qt to optimize for more speed and less flicker than a call to repaint() does.&lt;/p&gt;
&lt;p&gt;Calling update() several times normally results in just one paintEvent() call.&lt;/p&gt;
&lt;p&gt;Qt normally erases the widget's area before the paintEvent() call. If the Qt::WA_OpaquePaintEvent widget attribute is set, the widget is responsible for painting all its pixels with an opaque color&lt;/p&gt;
&lt;p&gt;对于如上英文，解释如下：：&lt;/p&gt;
&lt;p&gt;刷新控件，除非刷新被禁用或者控件是隐藏的。&lt;/p&gt;
&lt;p&gt;此函数不会导致立即重绘; 相反，它调度一个paint事件，在Qt返回主事件循环时处理。这允许Qt进行优化，以获得比调用repaint()更快的速度和更少的闪烁。&lt;/p&gt;
&lt;p&gt;多次调用update()通常只会导致一次paintEvent()调用。&lt;/p&gt;
&lt;p&gt;Qt通常在调用paintEvent()之前擦除控件区域。如果设置了Qt::WA_OpaquePaintEvent属性，控件用不透明的颜色绘制其所有像素。&lt;/p&gt;
&lt;p&gt;void QWidget::update()源码如下&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;void QWidget::update()&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;{&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     update(rect());&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;}&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即调用update没有传递参数，则默认刷新控件的整个区域，调用如下重载的update函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/371367/202102/371367-20210207032615566-1608521632.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、如果控件是隐藏或者刷新被禁用，则直接返回&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、参数传递的矩形与控件矩形的交集，如果为空，则直接返回&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、如果支持BackingStore(默认支持)，则标脏该控件所属的顶层窗口(TLW:: topLevelWidget缩写)区域，即调用tlwExtra-&amp;gt;backingStoreTracker-&amp;gt;markDirty(r, this);函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/371367/202102/371367-20210207032733495-1491088387.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中入参updateTime的值为UpdateLater，而非UpdateNow；&lt;/p&gt;
&lt;p&gt;函数主体内容如下：：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、把控件加入到dirtyWidgets容器中(addDirtyWidget函数)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、通知tlw进行刷新(sendUpdateRequest函数)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sendUpdateRequest函数如下图所示，其&lt;strong&gt;Post&lt;/strong&gt;一个&lt;strong&gt;QEvent::UpdateRequest&lt;/strong&gt;事件，即放入事件队列中，立即返回；QEvent::UpdateRequest事件的接受者为tlw；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/371367/202102/371367-20210207032903979-2101164971.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到这里，也就明白为什么update是异步刷新了，源码面前了无秘密&lt;/p&gt;
&lt;p&gt;Qt update刷新之源码分析系列会分拆为多个具体的文章，后续我会一一讲解并发布&lt;/p&gt;
&lt;p&gt;由于这里不能发布视频，所以我在这发布了文章，在我的微信公众号里同步发布了详细的PPT以及视频进行详细解说&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 06 Feb 2021 19:45:00 +0000</pubDate>
<dc:creator>IT文艺男</dc:creator>
<og:description>Qt update刷新之源码分析系列主要结合Qt源码对Qt的刷新机制进行深度剖析，例如要让控件刷新，会调用update函数；那么在调用了update函数后，Qt究竟基于什么原理、执行了什么代码使得屏幕</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/appsucc/p/14383740.html</dc:identifier>
</item>
<item>
<title>从0到1实现一个简单计算器 - codevald</title>
<link>http://www.cnblogs.com/codevald/p/14383561.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codevald/p/14383561.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;学习编程语言最重要的就是实践。很多小伙伴在学习完编程语言后，一直停留在基础阶段，只懂一大堆理论知识，而不懂得实践。那么,今天我们一起来动手做一个小计算器，回顾下学习过的知识，同时这也是很多大学计算机专业的期末作业，应该尝试动手并完全理解它，学废了记得点赞收藏加关注哦。&lt;/p&gt;
&lt;h2 id=&quot;开始动手&quot;&gt;开始动手&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;本次实验会用到Java Swing图形组件进行开发&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;主要知识点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Java Swing界面的编程&lt;/li&gt;
&lt;li&gt;计算器运算逻辑的实现&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;一、项目创建&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;打开Eclipse，在文件的菜单File选择 &lt;strong&gt;New -&amp;gt; Java Project&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4d84e776b7e4249935d7b8e8ec22759~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.在&lt;strong&gt;Project name&lt;/strong&gt;一栏填写&lt;strong&gt;项目名称Calculator（自定义）&lt;/strong&gt;,并点击&lt;strong&gt;Finish&lt;/strong&gt;按钮完成创建&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c47f9c265d6a48b99dfb123cbfdb6700~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.创建一个&lt;strong&gt;包package&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0bfec439ee14290b44252c424327ada~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.在创建好的项目目录&lt;strong&gt;src&lt;/strong&gt;上右键点击，菜单中选择 &lt;strong&gt;New -&amp;gt; Class&lt;/strong&gt; 来创建一个类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d231ea5bc7a40a08630e0334e8eb528~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.在新建类的对话框中填写类名 &lt;strong&gt;Calculator(自定义)&lt;/strong&gt;，点击 &lt;strong&gt;Finish&lt;/strong&gt; 按钮完成创建&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad96aecbfe184d4a84b0f56b9aef1f65~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、代码部分&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;未接触过Swing的小伙伴可以先去下面的链接学习下入门的基础知识&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://c.biancheng.net/swing/&quot; target=&quot;_blank&quot;&gt;http://c.biancheng.net/swing/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.编写响应逻辑的实现&lt;/p&gt;
&lt;p&gt;定义存储当前被按下的操作数和操作符，result存储运算的结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75f09dc4a48047428763c249a24386e2~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;定义状态开关&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e39c25831ee4b22bb900e942f48f228~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;定义JButton变量，存储按下的键，定义一个Vector，储存所有的输入&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6008f9989a44bdd90b0bc029130a724~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;UI组件创建&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;创建主窗体，按钮和文本框&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74a88f9da94542f7ba84fb024167ce9c~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.在构造器中完成等效键的设置、UI组件添加进容器、事件处理程序的设计、计算逻辑的实现以及窗口关闭事件的代码编写的工作&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;等效键的设置（即可以通过对应的键盘按键来代替点击它）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea9628abc3e24e8d9f73262552e4cda7~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;文本框对齐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/028c0f657cf14aeeb294e7d3b8b3eeda~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;UI组件添加进容器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/852961fbdf274837adf04bba83fe747c~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cfdabeb58ae4c6c92d25bbfc8e9eee3~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;事件处理程序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;数字键处理逻辑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a81f945c14a3489eaa059633ff4c891a~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运算符处理逻辑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5757c01454be4e19989cfe4408b80fb0~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;清除键处理逻辑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba92b4f4c1f1458a8e91741c79284de7~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;等于键处理逻辑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a79e5f86bca44be0922c2c6b3491cea3~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小数点处理逻辑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb65878574c741ee8ee59eb684a3b01c~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注册监听器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0313b5d8d1b24132add25f99a1684ef0~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;窗口关闭&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f8bf1c2e8a840adbe9030f5d1b780ba~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算逻辑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c3a0b41bd194ecbb268a369faf009cb~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0a356775bc344779a73f5c1df0ff720~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、运行项目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实现效果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/273e753a3c1c484faf0386a7bcab85bf~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、项目总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本次实践练习如何使用Swing进行图形界面的编程以及一些计算逻辑的实现，也只是实现了基本的计算器功能的实现，感兴趣的可以自己动手加一点东西，比如运算符优先级的实现（需要数据结构的实现），进一步提高思考和编程的能力。&lt;/p&gt;
&lt;p&gt;本次项目的源代码已编写打包好。 公众号 &lt;strong&gt;CodeVald&lt;/strong&gt; 后台回复 &lt;strong&gt;计算器&lt;/strong&gt; 即可领取。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有收获的小伙伴记得点赞收藏加关注哦。笔芯。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 06 Feb 2021 15:34:00 +0000</pubDate>
<dc:creator>codevald</dc:creator>
<og:description>前言 学习编程语言最重要的就是实践。很多小伙伴在学习完编程语言后，一直停留在基础阶段，只懂一大堆理论知识，而不懂得实践。那么,今天我们一起来动手做一个小计算器，回顾下学习过的知识，同时这也是很多大学计</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/codevald/p/14383561.html</dc:identifier>
</item>
<item>
<title>使用Python调用SMTP服务自动发送Email - 陆言君</title>
<link>http://www.cnblogs.com/dechinphy/p/smtp.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dechinphy/p/smtp.html</guid>
<description>&lt;p&gt;通过python可以调用smtp第三方邮件服务接口，这使得我们可以通过python直接来发送邮件。在这个功能基础上，我们可以结合Linux的定时任务服务Crontab，来开发一些有意思的项目，比如爬虫等。这里我们就只简单演示一个定时播报随机数的任务示例，很好的结合了crontab定时任务、python任务、smtp播报任务三者的特点，读者可以进行参考。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;133.62427548585&quot;&gt;

&lt;p&gt;假设我们想设计一个定时任务，比如每天定时的用python来测试服务是否在正常运行，但是又不希望每天登录到系统后台去查看服务状态。这里我们就可以采取python的smtp模块进行任务结果广播，申请一个公共邮箱，每次python执行完定时的测试任务后，调用smtp的接口将测试结果广播给需要接收的人的邮箱中。这就使得，我们可以在移动端就能按照我们的意愿实时监测系统的状态。&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;浏览器登录进入&lt;a href=&quot;https://mail.qq.com/&quot; target=&quot;_blank&quot;&gt;QQ邮箱&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;进入设置-账户&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2277440/202102/2277440-20210206212824056-1982572577.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;找到POP3-SMTP服务的位置，点击开启&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2277440/202102/2277440-20210206213008489-1978527190.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;进行一些验证程序&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2277440/202102/2277440-20210206213142501-1555366522.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;开启成功后，系统会给出一串长度为16的随机口令，用来替代密码进行第三方登录&lt;/li&gt;
&lt;li&gt;配置smtp服务器地址和端口号&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2277440/202102/2277440-20210206213631169-284975673.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里我们直接展示成果代码，其中一些隐私信息做了处理：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# smtp_test.py
#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
import smtplib
from email.mime.text import MIMEText
from email.header import Header
 
# 第三方 SMTP 服务
mail_host=&quot;smtp.qq.com&quot;  #设置服务器
mail_user=&quot;your_name@qq.com&quot;    #用户名
mail_pass=&quot;passpasspasspass&quot;   #口令 
 
 
sender = 'your_name@qq.com'
receivers = ['your_target@qq.com']  # 接收邮件，可设置为你的QQ邮箱或者其他邮箱
 
message = MIMEText('Python SMTP 邮件发送测试...', 'plain', 'utf-8')
message['From'] = Header(&quot;SMTP EMAIL&quot;, 'utf-8')
message['To'] =  Header(&quot;TEST MESSAGE&quot;, 'utf-8')
 
subject = 'Python SMTP 邮件测试'
message['Subject'] = Header(subject, 'utf-8')
 
 
try:
    smtpObj = smtplib.SMTP() 
    smtpObj.connect(mail_host, 25)    # 25 为 SMTP 端口号
    smtpObj.login(mail_user,mail_pass)  
    smtpObj.sendmail(sender, receivers, message.as_string())
    print (&quot;邮件发送成功&quot;)
except smtplib.SMTPException:
    import traceback
    traceback.print_exc()
    print (&quot;无法发送邮件&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的服务器配置的SMTP的服务器&lt;code&gt;smtp.qq.com&lt;/code&gt;，对应端口号配置为25，这里的口令和帐号应替换为读者自己的授权口令和帐号。该程序的正常结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[dechin@dechin-manjaro smtp]$ python3 smtp_test.py 
邮件发送成功
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外由于这里采用了&lt;code&gt;tracback&lt;/code&gt;做错误日志采集，因此即使有报错程序也能继续执行，但是会广播错误日志。&lt;/p&gt;
&lt;p&gt;最后通过查询邮箱里面的邮件(有时候可能会被放到垃圾箱里面)，正常情况下可以看到一份这样的邮件：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2277440/202102/2277440-20210206220958429-2104048110.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;crontab是Linux系统下自带的定时任务配置服务，基本使用方法就是通过&lt;code&gt;crontab -l&lt;/code&gt;来查看定时任务，以及通过&lt;code&gt;crontab -e&lt;/code&gt;来编辑定时任务。但是由于自带的编辑器为&lt;code&gt;nano&lt;/code&gt;，使用起来非常的不顺手，所以我们可以将其编辑器配置为&lt;code&gt;vim&lt;/code&gt;再进行使用，相关指令为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[dechin@dechin-manjaro smtp]$ export EDITOR=&quot;/usr/bin/vim&quot; ; crontab -e
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，在当前用户登录界面下，只需要临时配置一次即可一直直接使用&lt;code&gt;crontab -e&lt;/code&gt;进行配置，持久生效需要修改配置文件，这里不展开介绍。&lt;code&gt;crontab&lt;/code&gt;的任务配置可以参考如下介绍(图片来自于参考链接2)：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2277440/202102/2277440-20210206222657066-107719139.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里我们首先创建一个简单的打印随机数的任务，这样如果我们在&lt;code&gt;crontab&lt;/code&gt;中添加一个执行该程序的定时任务，就可以每次产生一个不同的随机数并且将其输出到一个指定的文件中，再通过另外一个&lt;code&gt;smtp&lt;/code&gt;的定时任务进行读取和广播。以下是打印随机数的任务内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;[dechin@dechin-manjaro smtp]$ cat random_job.py 
import random
print (random.random())
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们将前面用到的smtp的任务稍作修改，将随机数读取到邮件标题中：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# smtp_test.py
#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
import smtplib
from email.mime.text import MIMEText
from email.header import Header
 
# 第三方 SMTP 服务
mail_host=&quot;smtp.qq.com&quot;  #设置服务器
mail_user=&quot;your_email@qq.com&quot;    #用户名
mail_pass=&quot;passpasspasspass&quot;   #口令 
 
 
sender = 'your_email@qq.com'
receivers = ['your_target@qq.com']  # 接收邮件，可设置为你的QQ邮箱或者其他邮箱
 
message = MIMEText('Python SMTP 邮件发送测试...', 'plain', 'utf-8')
message['From'] = Header(&quot;SMTP EMAIL&quot;, 'utf-8')
message['To'] =  Header(&quot;TEST MESSAGE&quot;, 'utf-8')

random_number = 1
with open('/home/dechin/projects/2021-python/smtp/random_number.txt', 'r') as file:
    random_number = float(file.readlines()[0])

subject = 'The random number generated is: ' + str(random_number)
message['Subject'] = Header(subject, 'utf-8')
 
 
try:
    smtpObj = smtplib.SMTP() 
    smtpObj.connect(mail_host, 25)    # 25 为 SMTP 端口号
    smtpObj.login(mail_user,mail_pass)  
    smtpObj.sendmail(sender, receivers, message.as_string())
    print (&quot;邮件发送成功&quot;)
except smtplib.SMTPException:
    import traceback
    traceback.print_exc()
    print (&quot;无法发送邮件&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，再配置好&lt;code&gt;crontab&lt;/code&gt;定时任务如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[dechin@dechin-manjaro smtp]$ crontab -l
* * * * * python3 /home/dechin/projects/2021-python/smtp/random_job.py &amp;gt; /home/dechin/projects/2021-python/smtp/random_number.txt
* * * * * python3 /home/dechin/projects/2021-python/smtp/smtp_test.py
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面由于为了尽快的展示定时任务效果因此我们设置为每分钟都执行一次任务，实际场景中不需要这么高频率的定时任务测试。&lt;/p&gt;
&lt;p&gt;最后查看邮箱收件箱，我们发现了一系列的定时任务的内容反馈如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2277440/202102/2277440-20210206223816433-319158192.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;到这里我们的定时监测任务+smtp广播的示例就演示完毕了，如果使用完该定时任务不想再启动，可以关闭crontab服务或者删除相关的crontab条目。&lt;/p&gt;

&lt;p&gt;本文首发链接为：&lt;a href=&quot;https://www.cnblogs.com/dechinphy/p/smtp.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/dechinphy/p/smtp.html&lt;/a&gt;&lt;br/&gt;作者ID：DechinPhy&lt;br/&gt;更多原著文章请参考：&lt;a href=&quot;https://www.cnblogs.com/dechinphy/&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/dechinphy/&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.runoob.com/python/python-email.html&quot; target=&quot;_blank&quot;&gt;https://www.runoob.com/python/python-email.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.runoob.com/linux/linux-comm-crontab.html&quot; target=&quot;_blank&quot;&gt;https://www.runoob.com/linux/linux-comm-crontab.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;</description>
<pubDate>Sat, 06 Feb 2021 14:43:00 +0000</pubDate>
<dc:creator>陆言君</dc:creator>
<og:description>通过python可以调用smtp第三方邮件服务接口，这使得我们可以通过python直接来发送邮件。在这个功能基础上，我们可以结合Linux的定时任务服务Crontab，来开发一些有意思的项目，比如爬虫</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dechinphy/p/smtp.html</dc:identifier>
</item>
<item>
<title>设计模式（十六）——访问者模式 - 十四lin</title>
<link>http://www.cnblogs.com/linzm14/p/14382300.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linzm14/p/14382300.html</guid>
<description>&lt;div class=&quot;Section0&quot; readability=&quot;26&quot;&gt;
&lt;h2&gt;1 测评系统的需求&lt;/h2&gt;
&lt;p&gt;完成测评系统需求&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;1) 将观众分为男人和女人，对歌手进行测评，当看完某个歌手表演后，得到他们对该歌手不同的评价(&lt;span&gt;评价&lt;/span&gt; &lt;span&gt;有不&lt;/span&gt;&lt;span&gt;同的种类，比如&lt;/span&gt; &lt;span&gt;成功、失败&lt;/span&gt; &lt;span&gt;等&lt;/span&gt;)&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257481/202102/2257481-20210206175118511-1037947491.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p class=&quot;16&quot;&gt;2) 传统方案&lt;/p&gt;
&lt;h2&gt;2 传统方式的问题分析&lt;/h2&gt;
&lt;p class=&quot;16&quot;&gt;1) &lt;span&gt;如果系统比较小，还是&lt;/span&gt; ok &lt;span&gt;的，但是考虑系统增加越来越多新的功能时，对代码改动较大，违反了&lt;/span&gt; ocp &lt;span&gt;原则，&lt;/span&gt; &lt;span&gt;不利于维护&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;2) &lt;span&gt;扩展性不好，比如&lt;/span&gt; &lt;span&gt;增加了&lt;/span&gt; &lt;span&gt;新的人员类型，或者管理方法，都不好做&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;3) &lt;span&gt;引出我们会使用新的设计模式&lt;/span&gt; – 访问者模式&lt;/p&gt;
&lt;h2&gt;3 访问者模式基本介绍&lt;/h2&gt;
&lt;p class=&quot;16&quot;&gt;1) 访问者模式（Visitor Pattern），封装一些作用于某种数据结构的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;2) &lt;span&gt;主要将数据结构与数据操作分离，解决&lt;/span&gt; &lt;span&gt;数据结构和操作耦合性问题&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;3) 访问者模式的基本工作原理是：在被访问的类里面加一个对外提供接待访问者的接口&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;4) 访问者模式主要应用场景是：需要对一个对象结构中的对象进行很多不同操作(这些操作彼此没有关联)，同时&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;需要避免让这些操作&quot;污染&quot;这些对象的类，可以选用访问者模式解决&lt;/p&gt;
&lt;h2&gt;4 访问者模式的原理类图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257481/202102/2257481-20210206175157922-1592667043.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;对原理类图的说明-&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;即(访问者模式的角色及职责)&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;1) Visitor &lt;span&gt;是抽象访问者，为该对象结构中的&lt;/span&gt; ConcreteElement &lt;span&gt;的每一个类声明一个&lt;/span&gt; visit 操作&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;2) ConcreteVisitor &lt;span&gt;：是一个具体的访问值&lt;/span&gt; &lt;span&gt;实现每个有&lt;/span&gt; Visitor 声明的操作，是每个操作实现的部分.&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;3) ObjectStructure &lt;span&gt;能枚举它的元素，&lt;/span&gt; &lt;span&gt;可以提供一个高层的接口，用来允许访问者访问元素&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;4) Element &lt;span&gt;定义一个&lt;/span&gt; accept  方法，接收一个访问者对象&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;5) ConcreteElement &lt;span&gt;为具体元素，实现了&lt;/span&gt; accept  方法&lt;/p&gt;
&lt;h2&gt;5 访问者模式应用实例&lt;/h2&gt;
&lt;p&gt;应用实例要求&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;1) 将人分为男人和女人，对歌手进行测评，当看完某个歌手表演后，得到他们对该歌手不同的评价(&lt;span&gt;评价&lt;/span&gt; &lt;span&gt;有不同&lt;/span&gt;&lt;span&gt;的种类，比如&lt;/span&gt; &lt;span&gt;成功、失败&lt;/span&gt; &lt;span&gt;等&lt;/span&gt;)，请使用访问者模式来说实现&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;2) 思路分析和图解(类图)&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257481/202102/2257481-20210206175234572-79391508.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;3) 代码实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.Visitor;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提供一个方法让访问者可以访问&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; accept(Action action);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.Visitor;

&lt;/span&gt;
&lt;/pre&gt;
&lt;p class=&quot;15&quot;&gt;//1. 这里我们使用到了双分派,  &lt;span&gt;即首先在客户端程序中，将具体状态作为参数传递&lt;/span&gt; Woman 中(第一次分派)&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;//2. &lt;span&gt;然后&lt;/span&gt; Woman &lt;span&gt;类调用作为参数的&lt;/span&gt; &quot;具体方法&quot; &lt;span&gt;中方法&lt;/span&gt; getWomanResult, 同时将自己(this)作为参数&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;// 传入，完成第二次的分派&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Women &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Person{

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; accept(Action action) {
        action.getWomenResult(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.Visitor;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Man &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Person{

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; accept(Action action) {
        action.getManResult(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.Visitor;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Action {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 得到男性的测评&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; getManResult(Person person);
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 得到女性的测评&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; getWomenResult(Person person);
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.Visitor;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Success &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Action {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; getManResult(Person person) {
        System.out.println(&lt;/span&gt;&quot;男性观众给的评价是成功！&quot;&lt;span&gt;);

    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; getWomenResult(Person person) {
        System.out.println(&lt;/span&gt;&quot;女性观众给的评价是成功！&quot;&lt;span&gt;);

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.Visitor;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Fail &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Action {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; getManResult(Person person) {
        System.out.println(&lt;/span&gt;&quot;男性观众给的评价是失败！&quot;&lt;span&gt;);

    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; getWomenResult(Person person) {
        System.out.println(&lt;/span&gt;&quot;女性观众给的评价是失败！&quot;&lt;span&gt;);

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.Visitor;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.LinkedList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ObjectStructure {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;Person&amp;gt; persons = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; attach(Person person) {
        persons.add(person);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 移除&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; detach(Person person) {
        persons.remove(person);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 显示&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; display(Action action) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Person person : persons) {
            person.accept(action);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.Visitor;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ObjectStructure objectStructure &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectStructure();
        
        objectStructure.attach(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Women());
        objectStructure.attach(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Man());
        objectStructure.attach(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Women());
        objectStructure.attach(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Man());
        
        Success success &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Success();
        objectStructure.display(success);
        System.out.println(&lt;/span&gt;&quot;==========================&quot;&lt;span&gt;);
        Wait wait &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Wait();
        objectStructure.display(wait);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;15&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257481/202102/2257481-20210206175349476-1780535378.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;Section0&quot; readability=&quot;11&quot;&gt;
&lt;p class=&quot;15&quot;&gt;4) 应用案例的小结-双分派&lt;/p&gt;
&lt;p&gt;-上面提到了双分派，所谓双分派是指不管类怎么变化，我们都能找到期望的方法运行。双分派意味着得到执行的操作取决于请求的种类和两个接收者的类型&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;- &lt;span&gt;以上述实例为例，假设我们要添加一个&lt;/span&gt; &lt;strong&gt;Wait&lt;/strong&gt; &lt;span&gt;的状态类，考察&lt;/span&gt; &lt;strong&gt;Man&lt;/strong&gt; &lt;span&gt;类和&lt;/span&gt; &lt;strong&gt;Woman&lt;/strong&gt; &lt;span&gt;类的反应，由于使用了双分派，只需增加一个&lt;/span&gt; Action 子类即可在客户端调用即可，不需要改动任何其他类的代码。&lt;/p&gt;
&lt;h2&gt;6 访问者模式的注意事项和细节&lt;/h2&gt;
&lt;p class=&quot;15&quot;&gt;1) 访问者模式符合单一职责原则、让程序具有优秀的扩展性、灵活性非常高&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;2) 访问者模式可以对功能进行统一，可以做报表、UI、拦截器与过滤器，适用于数据结构相对稳定的系统&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;1) 具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的, 这样造成了具体元素变更比较困难&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;2) 违背了依赖倒转原则。访问者依赖的是具体元素，而不是抽象元素&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;3) 因此，如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么访问者模式就是比较合适的.&lt;/p&gt;

&lt;p&gt;仅供参考，有错误还请指出！&lt;/p&gt;
&lt;p&gt;有什么想法，评论区留言，互相指教指教。&lt;/p&gt;
</description>
<pubDate>Sat, 06 Feb 2021 14:38:00 +0000</pubDate>
<dc:creator>十四lin</dc:creator>
<og:description>1&amp;#160;测评系统的需求 完成测评系统需求 1) 将观众分为男人和女人，对歌手进行测评，当看完某个歌手表演后，得到他们对该歌手不同的评价(评价 有不同的种类，比如 成功、失败 等) 2)&amp;#160</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/linzm14/p/14382300.html</dc:identifier>
</item>
</channel>
</rss>