<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>使用 Docker 让部署 Django 项目更加轻松 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/11649630.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/11649630.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201908/759200-20190828185611060-1211614569.jpg&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;作者：HelloGitHub-&lt;strong&gt;追梦人物&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3.4027777777778&quot;&gt;
&lt;p&gt;文中涉及的示例代码，已同步更新到 &lt;a href=&quot;https://github.com/HelloGitHub-Team/HelloDjango-blog-tutorial&quot;&gt;HelloGitHub-Team 仓库&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前一系列繁琐的部署步骤让我们感到痛苦。这些痛苦包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;要去服务器上执行 n 条命令&lt;/li&gt;
&lt;li&gt;本地环境和服务器环境不一致，明明本地运行没问题，一部署服务器上就挂挂，死活启动不起来&lt;/li&gt;
&lt;li&gt;如果上面的情况发生了，又要去服务器上执行 n 条命令以解决问题&lt;/li&gt;
&lt;li&gt;本地更新了代码，部署上线后，上述历史又重演一遍，想死的心都有了&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么我们有没有办法，让本地开发环境和线上环境保持一致？这样我们在部署上线前，就可以在本地进行验证，只要验证没问题，我们就有 99% 的把握保证部署上线后也没有问题（1%保留给程序玄学）。&lt;/p&gt;
&lt;p&gt;这个办法就是使用 Docker。&lt;/p&gt;
&lt;p&gt;Docker 是一种容器技术，可以为我们提供一个隔离的运行环境。要使用 Docker，首先我们需要编排一个镜像，镜像就是用来描述这个隔离环境应该是什么样子的，它需要安装哪些依赖，需要运行什么应用等，可以把它类比成一搜货轮的制造图。&lt;/p&gt;
&lt;p&gt;有了镜像，就可以在系统中构建出一个实际隔离的环境，这个环境被称为容器，就好比根据设计图，工厂制造了一条船。工厂也可以制造无数条这样的船。&lt;/p&gt;
&lt;p&gt;容器造好了，只要启动它，隔离环境便运行了起来。由于事先编排好了镜像，因此无论是在本地还是线上，运行的容器内部环境都一样，所以保证了本地和线上环境的一致性，大大减少了因为环境差异导致的各种问题。&lt;/p&gt;
&lt;p&gt;所以，我们首先来编排 Docker 镜像。&lt;/p&gt;
&lt;p&gt;类似于分离 settings.py 文件为 local.py 和 production.py，我们首先建立如下的目录结构，分别用于存放开发环境的镜像和线上环境的镜像：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;HelloDjango-blog-tutorial\
      blog\
      ...
      compose\
            local\
            production\
                  django\
                  nginx\
    ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;local 目录下存放开发环境的 Docker 镜像文件，production 下的 django 文件夹存放基于本项目编排的镜像，由于线上环境还要用到 Nginx，所以 nginx 目录下存放 Nginx 的镜像。&lt;/p&gt;
&lt;h2 id=&quot;线上环境&quot;&gt;线上环境&lt;/h2&gt;
&lt;h3 id=&quot;镜像文件&quot;&gt;镜像文件&lt;/h3&gt;
&lt;p&gt;我们先来在 production\django 目录下编排博客项目线上环境的镜像文件，镜像文件以 Dockerfile 命名：&lt;/p&gt;
&lt;pre class=&quot;dockerfile&quot;&gt;
&lt;code&gt;FROM python:3.6-alpine

ENV PYTHONUNBUFFERED 1

RUN apk update \
  # Pillow dependencies
  &amp;amp;&amp;amp; apk add jpeg-dev zlib-dev freetype-dev lcms2-dev openjpeg-dev tiff-dev tk-dev tcl-dev

WORKDIR /app

RUN pip install pipenv -i https://pypi.douban.com/simple

COPY Pipfile /app/Pipfile
COPY Pipfile.lock /app/Pipfile.lock
RUN pipenv install --system --deploy --ignore-pipfile

COPY . /app

COPY ./compose/production/django/start.sh /start.sh
RUN sed -i 's/\r//' /start.sh
RUN chmod +x /start.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先我们在镜像文件开头使用 &lt;code&gt;FROM python:3.6-alpine&lt;/code&gt; 声明此镜像基于 python:3.6-alpine 基础镜像构建。alpine 是一个 Linux 系统发行版，主打小巧、轻量、安全。我们程序运行需要 Python 环境，因此使用这个小巧但包含完整 Python 环境的基础镜像来构建我们的应用镜像。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ENV PYTHONUNBUFFERED 1&lt;/code&gt; 设置环境变量 PYTHONUNBUFFERED=1&lt;/p&gt;
&lt;p&gt;接下来的一条 RUN 命令安装图像处理包 Pilliow 的依赖，因为如果使用 django 处理图片时，会使用到 Pillow 这个Python 库。&lt;/p&gt;
&lt;p&gt;接着使用 WORKDIR /app 设置工作目录，以后在基于此镜像启动的 Docker 容器中执行的命令，都会以这个目录为当前工作目录。&lt;/p&gt;
&lt;p&gt;然后我们使用命令 &lt;code&gt;RUN pip install pipenv&lt;/code&gt; 安装 pipenv，-i 参数指定 pypi 源，国内一般指定为豆瓣源，这样下载 pipenv 安装包时更快，国外网络可以省略 -i 参数，使用官方的 pypi 源即可。&lt;/p&gt;
&lt;p&gt;然后我们将项目依赖文件 Pipfile 和 Pipfile.lock copy 到容器里，运行 pipenv install 安装依赖。指定 --system 参数后 pipenv 不会创建虚拟环境，而是将依赖安装到容器的 Python 环境里。因为容器本身就是个虚拟环境了，所以没必要再创建虚拟环境。&lt;/p&gt;
&lt;p&gt;接着将这个项目的文件 copy 到容器的 /app 目录下（当然有些文件对于程序运行是不必要的，所以一会儿我们会设置一个 dockerignore 文件，里面指定的文件不会被 copy 到容器里）。&lt;/p&gt;
&lt;p&gt;然后我们还将 start.sh 文件复制到容器的 / 目录下，去掉回车符（windows 专用，容器中是 linux 系统），并赋予了可执行权限。&lt;/p&gt;
&lt;p&gt;start.sh 中就是启动 Gunicorn 服务的命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/sh

python manage.py migrate
python manage.py collectstatic --noinput
gunicorn blogproject.wsgi:application -w 4 -k gthread -b 0.0.0.0:8000 --chdir=/app&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们会让容器启动时去执行此命令，这样就启动了我们的 django 应用。--chdir=/app 表明以 /app 为根目录，这样才能找到 blogproject.wsgi:application。&lt;/p&gt;
&lt;p&gt;在项目根目录下建立 .dockerignore 文件，指定&lt;strong&gt;不&lt;/strong&gt; copy 到容器的文件：&lt;/p&gt;
&lt;pre class=&quot;dockerignore&quot;&gt;
&lt;code&gt;.*
_credentials.py
fabfile.py
*.sqlite3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;线上环境使用 Nginx，同样来编排 Nginx 的镜像，这个镜像文件放到 compose\production\nginx 目录下：&lt;/p&gt;
&lt;pre class=&quot;dockerfile&quot;&gt;
&lt;code&gt;FROM nginx:1.17.1

# 替换为国内源
RUN mv /etc/apt/sources.list /etc/apt/sources.list.bak
COPY ./compose/production/nginx/sources.list /etc/apt/
RUN apt-get update &amp;amp;&amp;amp; apt-get install -y --allow-unauthenticated certbot python-certbot-nginx

RUN rm /etc/nginx/conf.d/default.conf
COPY ./compose/production/nginx/HelloDjango-blog-tutorial.conf /etc/nginx/conf.d/HelloDjango-blog-tutorial.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个镜像基于 nginx:1.17.1 基础镜像构建，然后我们更新系统并安装 certbot 用于配置 https 证书。由于要安装大量依赖， nginx:1.17.1 镜像基于 ubuntu，所以安装会比较慢，我们将软件源替换为国内源，这样稍微提高一下安装速度。&lt;/p&gt;
&lt;p&gt;最后就是把应用的 nginx 配置复制到容器中 nginx 的 conf.d 目录下。里面的内容和直接在系统中配置 nginx 是一样的。&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;upstream hellodjango_blog_tutorial  {
    server hellodjango_blog_tutorial:8000;
}

server {
    server_name  hellodjango-blog-tutorial-demo.zmrenwu.com;

    location /static {
        alias /apps/hellodjango_blog_tutorial/static;
    }

    location / {
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        proxy_pass http://hellodjango_blog_tutorial;
    }

    listen 80;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相比之前直接在宿主机配置 Nginx，这里使用了 Nginx 的 upstream 模块，实际上就是做一个请求转发。Nginx 将所有请求转发给上游 hellodjango_blog_tutorial 模块处理，而 hellodjango_blog_tutorial 这个模块的服务实际就是运行 django 应用的容器 hellodjango_blog_tutorial（接下来会运行这个容器）。&lt;/p&gt;
&lt;p&gt;镜像编排完毕，接下来就可以通过镜像构建容器并运行容器了。但是先等一等，我们有两个镜像，一个是 django 应用的，一个是 Nginx 的，这意味着我们需要构建 2 次容器，并且启动容器 2 次，这会比较麻烦。有没有办法一次构建，一条命令运行呢？答案就是使用 docker-compose。&lt;/p&gt;
&lt;p&gt;docker-compose 将各个容器的镜像，以及构建和运行容器镜像时的参数等编写在一个 ymal 文件里。这样我们只需要一条 build 命令就可以构建多个容器，使用一条命令 up 就可以启动多个容器。&lt;/p&gt;
&lt;p&gt;我们在项目根目录建一个 production.yml 文件来编排 django 容器和 nginx 容器。&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;version: '3'

volumes:
  static:
  database:

services:
  hellodjango_blog_tutorial:
    build:
      context: .
      dockerfile: compose/production/django/Dockerfile
    image: hellodjango_blog_tutorial
    container_name: hellodjango_blog_tutorial
    working_dir: /app
    volumes:
      - database:/app/database
      - static:/app/static
    env_file:
      - .envs/.production
    ports:
      - &quot;8000:8000&quot;
    command: /start.sh

  nginx:
    build:
      context: .
      dockerfile: compose/production/nginx/Dockerfile
    image: hellodjango_blog_tutorial_nginx
    container_name: hellodjango_blog_tutorial_nginx
    volumes:
      - static:/apps/hellodjango_blog_tutorial/static
    ports:
      - &quot;80:80&quot;
      - &quot;443:443&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;version: '3'&lt;/code&gt; 声明 docker-compose 为第三代版本的语法&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;volumes:
  static:
  database:&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;声明了 2 个命名数据卷，分别为 static 和 database。数据卷是用来干嘛的呢？由于 docker 容器是一个隔离环境，一旦容器被删除，容器内的文件就会一并删除。试想，如果我们启动了博客应用的容器并运行，一段时间后，容器中的数据库就会产生数据。后来我们更新了代码或者修改了容器的镜像，这个时候就要删除旧容器，然后重新构建新的容器并运行，那么旧容器中的数据库就会连同容器一并删除，我们辛苦写的博客文章付之一炬。&lt;/p&gt;
&lt;p&gt;所以我们使用 docker 的数据卷来管理需要持久存储的数据，只要数据被 docker 的数据卷管理起来了，那么新的容器启动时，就可以从数据卷取数据，从而恢复被删除容器里的数据。&lt;/p&gt;
&lt;p&gt;我们有 2 个数据需要被数据卷管理，一个是数据库文件，一个是应用的静态文件。数据库文件容易理解，那么为什么静态文件也要数据卷管理呢？启动新的容器后使用 python manage.py collectstatic 命令重新收集不就好了？&lt;/p&gt;
&lt;p&gt;答案是不行，数据卷不仅有持久保存数据的功能，还有跨容器共享文件的功能。要知道，容器不仅和宿主机隔离，而且容器之间也是互相隔离的。Nginx 运行于独立容器，那么它处理的静态文件从哪里来呢？应用的静态文件存放于应用容器，Nginx 容器是访问不到的，所以这些文件也通过数据卷管理，nginx 容器从数据卷中取静态文件映射到自己的容器内部。&lt;/p&gt;
&lt;p&gt;接下来定义了 2 个 services，一个是应用服务 hellodjango_blog_tutorial，一个是 nginx 服务。&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;build:
      context: .
      dockerfile: compose/production/django/Dockerfile&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;告诉 docker-compose，构建容器是基于当前目录（yml 文件所在的目录），且使用的镜像是 dockerfile 指定路径下的镜像文件。&lt;/p&gt;
&lt;p&gt;image 和 container_name 分别给构建的镜像和容器取个名字。&lt;/p&gt;
&lt;p&gt;working_dir 指定工作目录。&lt;/p&gt;
&lt;ul readability=&quot;11&quot;&gt;&lt;li readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;code&gt;volumes:
  - database:/app/database
  - static:/app/static&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时这里要注意，数据卷只能映射文件夹而不能映射单一的文件，所以对我们应用的数据库来说，db.sqlite3 文件我们把它挪到了 database 目录下。因此我们要改一下 django 的配置文件中数据库的配置，让它正确地将数据库文件生成在项目根目录下的 database 文件夹下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
      'NAME': os.path.join(BASE_DIR, 'database', 'db.sqlite3'),
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;env_file:
    - .envs/.production&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;容器启动时读取 .envs/.production文件中的内容，将其注入环境变量。&lt;/p&gt;
&lt;p&gt;我们创建一下这个文件，把 secret_key 写进去。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DJANGO_SECRET_KEY=2pe8eih8oah2_2z1=7f84bzme7^bwuto7y&amp;amp;f(#@rgd9ux9mp-3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意将这些包含敏感信息的文件加入版本控制工具的忽略列表里，防止一不小心推送到公开仓库供大众观光。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;ports:
  - &quot;8000:8000&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;暴露容器内的 8000 端口并且和宿主机的 8000 端口绑定，于是我们就可以通过宿主机的 8000 端口访问容器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;command: /start.sh 容器启动时将执行 start.sh，从而启动 django应用。&lt;/p&gt;
&lt;p&gt;nginx 服务容器也类似，只是注意它从数据卷 static 中取静态文件并映射到 nginx 容器内的 /apps/hellodjango_blog_tutorial/static，所以我们在 nginx 的配置中：&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;location /static {
    alias /apps/hellodjango_blog_tutorial/static;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样可以正确代理静态文件。&lt;/p&gt;
&lt;p&gt;万事具备，在&lt;strong&gt;本地&lt;/strong&gt;执行一下下面的两条命令来构建容器和启动容器。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;docker-compose -f production.yml build
docker-compose -f production.yml up&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时我们可以通过域名来访问容器内的应用，当然，由于 Nginx 在本地环境的容器内运行，需要修改一下 本地 hosts 文件，让域名解析为本地 ip 即可。&lt;/p&gt;
&lt;p&gt;如果本地访问没有问题了，那么就可以直接在服务器上执行上面两条命令以同样的方式启动容器，django 应用就顺利地在服务上部署了。&lt;/p&gt;
&lt;h2 id=&quot;开发环境&quot;&gt;开发环境&lt;/h2&gt;
&lt;p&gt;既然线上环境都使用 Docker 了，不妨开发环境也一并使用 Docker 进行开发。开发环境的镜像和 docker-compose 文件比线上环境简单一点，因为不用使用 nginx。&lt;/p&gt;
&lt;p&gt;开发环境的镜像文件，放到 compose\local 下：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;FROM python:3.6-alpine

ENV PYTHONUNBUFFERED 1

RUN apk update \
  # Pillow dependencies
  &amp;amp;&amp;amp; apk add jpeg-dev zlib-dev freetype-dev lcms2-dev openjpeg-dev tiff-dev tk-dev tcl-dev

WORKDIR /app

RUN pip install pipenv -i https://pypi.douban.com/simple

COPY Pipfile /app/Pipfile
COPY Pipfile.lock /app/Pipfile.lock
RUN pipenv install --system --deploy --ignore-pipfile

COPY ./compose/local/start.sh /start.sh
RUN sed -i 's/\r//' /start.sh
RUN chmod +x /start.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要注意和线上环境不同的是，我们没有把整个代码 copy 到容器里。线上环境代码一般比较稳定，而对于开发环境，由于需要频繁修改和调试代码，如果我们把代码 copy 到容器，那么容器外做的代码修改，容器内部是无法感知的，这样容器内运行的应用就没法同步我们的修改了。所以我们会把代码通过 Docker 的数据卷来管理。&lt;/p&gt;
&lt;p&gt;start.sh 不再启动 gunicorn，而是使用 runserver 启动开发服务器。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;#!/bin/sh

python manage.py migrate
python manage.py runserver 0.0.0.0:8000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后创建一个 docker-compose 文件 local.yml（和 production.yml 同级），用于管理开发容器。&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;version: '3'

services:
  djang_blog_tutorial_v2_local:
    build:
      context: .
      dockerfile: ./compose/local/Dockerfile
    image: django_blog_tutorial_v2_local
    container_name: django_blog_tutorial_v2_local
    working_dir: /app
    volumes:
      - .:/app
    ports:
      - &quot;8000:8000&quot;
    command: /start.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意我们将整个项目根目录下的文件挂载到了 /app 目录下，这样就能容器内就能实时反映代码的修改了。&lt;/p&gt;
&lt;h2 id=&quot;线上部署&quot;&gt;线上部署&lt;/h2&gt;
&lt;p&gt;如果容器在本地运行没有问题了，线上环境的容器运行也没有问题，因为理论上，我们在线上服务器也会构建和本地测试用的容器一模一样的环境，所以几乎可以肯定，只要我们服务器有 Docker，那么我们的应用就可以成功运行。&lt;/p&gt;
&lt;p&gt;首先在服务安装 Docker，安装方式因系统而异，方式非常简单，我们以 CentOS 7 为例，其它系统请参考 &lt;a href=&quot;https://docs.docker.com/install/&quot;&gt;Docker 的官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;首先安装必要依赖：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ sudo yum install -y yum-utils \
  device-mapper-persistent-data \
  lvm2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后添加仓库源：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ sudo yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后安装 Docker：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ sudo yum install docker-ce docker-ce-cli containerd.io&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动 Docker：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ sudo systemctl start docker&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（境外服务器忽略）设置 Docker 源加速（使用 daocloud 提供的镜像源），否则拉取镜像时会非常慢&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 docker 中运行一个 hello world，确认 docker 安装成功：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ sudo docker run hello-world&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;docker 安装成功了，还要安装一下 docker-compose。其实是一个 python 包，我们直接通过 pip 安装就可以了：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ pip install docker-compose&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了避免运行一些 docker 命令时可能产生的权限问题，我们把系统当前用户加入到 docker 组里：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ sudo usermod -aG docker ${USER}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加组后要重启一下 shell（ssh 连接的话就断开重连）。&lt;/p&gt;
&lt;p&gt;万事俱备，只欠东风了！&lt;/p&gt;
&lt;p&gt;开始准备让我们的应用在 docker 容器里运行。由于之前我们把应用部署在宿主机上，首先来把相关的服务停掉：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 停掉 nginx，因为我们将在容器中运行 nginx
$ sudo systemctl stop nginx

# 停掉博客应用
$ supervisorctl stop hellodjango-blog-tutorial -c ~/etc/supervisord.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来拉取最新的代码到服务器，进入项目根目录下，创建线上环境需要的环境变量文件：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ mkdir .envs
$ cd .envs
$ vi .production&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将线上环境的 secret key 写入 .production 环境变量文件，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DJANGO_SECRET_KEY=2pe8eih8oah2_2z1=7f84bzme7^bwuto7y&amp;amp;f(#@rgd9ux9mp-3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;保存并退出。&lt;/p&gt;
&lt;p&gt;回到项目根目录，运行 build 命令构建镜像：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ docker-compose -f prodcution.yml build&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们可以开始启动根据构建好的镜像启动 docker 容器，不过为了方便，我们的 docker 进程仍然由 supervisor 来管理，我们修改一下博客应用的配置，让它启动时启动 docker 容器。&lt;/p&gt;
&lt;p&gt;打开 ~/etc/supervisor/conf.d/hellodjango-blog-tutorial.ini，修改为如下内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[program:hellodjango-blog-tutorial]
command=docker-compose -f production.yml up --build
directory=/home/yangxg/apps/HelloDjango-blog-tutorial
autostart=true
autorestart=unexpected
user=yangxg
stdout_logfile=/home/yangxg/etc/supervisor/var/log/hellodjango-blog-tutorial-stdout.log
stderr_logfile=/home/yangxg/etc/supervisor/var/log/hellodjango-blog-tutorial-stderr.log&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主要就是把之前的使用 Gunicorn 来启动服务换成了启动 docker。&lt;/p&gt;
&lt;p&gt;修改 ini 配置 要记得 reread 使配置生效：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ supervisorctl -c ~/etc/supervisord.conf
&amp;gt; reread
&amp;gt; start &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;docker 容器顺利启动，访问我们的博客网站。抛掉镜像编排的准备工作，相当于我们只执行了一条构建容器并启动容器的命令就部署了我们的博客应用。如果换台服务器，也只要再执行一下镜像构建和启动容器的命令，服务就又可以起来！这就是 docker 的好处。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;由于开发 django 用的最多的 IDE Pycharm 也能很好地集成 Docker，我现在开发工作已经全面拥抱 Docker 了，前所未有的体验，前所未有的方便和稳定，一定要学着用起来！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;https&quot;&gt;HTTPS&lt;/h2&gt;
&lt;p&gt;最后，由于 Nginx 在新的容器里运行，所以需要重新申请和配置 https 证书，这和之前是一样，只是此前 Nginx 在宿主机上，这次我们在容器里运行 certbot 命令。编排 nginx 镜像时已经安装了 certbot，直接执行命令即可，在 docker 容器内执行命令如下：&lt;/p&gt;
&lt;p&gt;我们首先通过 docker ps 命令查看正在运行的容器，记住 nginx 容器的名字，然后使用 docker exec -it 容器名 命令的格式在指定容器内执行命令，所以我们执行：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ docker exec -it nginx certbot --nginx&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据提示输入信息即可，过程和上一节在宿主机上部署一模一样，这里不再重复。&lt;/p&gt;
&lt;h2 id=&quot;自动化部署&quot;&gt;自动化部署&lt;/h2&gt;
&lt;p&gt;fabric 无需修改，来尝试本地执行一下：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;pipenv run fab -H server_ip --prompt-for-login-password -p deploy&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完美！至此，我们的博客已经稳定运行于线上，陆陆续续会有更多的人来访问我们的博客，让我们来继续完善它的功能吧！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;『讲解开源项目系列』&lt;/strong&gt;——让对开源项目感兴趣的人不再畏惧、让开源项目的发起者不再孤单。跟着我们的文章，你会发现编程的乐趣、使用和发现参与开源项目如此简单。欢迎留言联系我们、加入我们，让更多人爱上开源、贡献开源～&lt;/p&gt;
</description>
<pubDate>Fri, 11 Oct 2019 00:38:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>作者：HelloGitHub 追梦人物 文中涉及的示例代码，已同步更新到 'HelloGitHub Team 仓库' 之前一系列繁琐的部署步骤让我们感到痛苦。这些痛苦包括： 要去服务器上执行 n 条命</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/11649630.html</dc:identifier>
</item>
<item>
<title>品Spring：关于@Scheduled定时任务的思考与探索，结果尴尬了 - 编程新说(李新杰)</title>
<link>http://www.cnblogs.com/lixinjie/p/taste-spring-017.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lixinjie/p/taste-spring-017.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br class=&quot;Apple-interchange-newline&quot;/&gt;
非Spring风格的代码与Spring的结合&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在的开发都是基于Spring的，所有的依赖都有Spring管理，这没有问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是要突然写一些非Spring风格的代码时，可能会很不习惯，如果还要和Spring风格的代码结合起来的话，就会稍显麻烦。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为非Spring风格的代码不由Spring管理，所以Spring不会给我们注入依赖，相反，我们要自己去Spring中拿取依赖。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以首先目标就是要获取Spring容器，即ApplicationContext，方法通常如下图01：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925214239223-1053664440.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义一个类实现ApplicationContextAware，类中定义一个静态的ApplicationContext字段，Spring会把容器注入到这个静态字段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于类的静态字段在JVM中一直存在，这样ApplicationContextUtils这个类就可以在非Spring风格的代码里使用Spring管理的bean了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;若用于定时任务是否有潜在的问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Spring自带的定时任务，非常好用，而且我很早就用过，具体时间已经记不清了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我依稀记得以前好像觉得容器还&lt;/span&gt;&lt;span&gt;没有&lt;/span&gt;&lt;span&gt;启动完成时，定时任务就有可能被触发。就姑且认为是这样吧，当然也可能不是。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果我的定时任务运行的代码是非Spring风格的，我自然需要自己去new实例，如下图02：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925214303062-1497707835.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果这个非Spring风格的代码恰好又要使用Spring管理的bean，那就是刚刚上面提到的方式，如下图03：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925214316574-607415806.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;可以看到&lt;/span&gt;&lt;span&gt;SimpleService&lt;/span&gt;&lt;span&gt;是Spring管理的bean，&lt;/span&gt;&lt;span&gt;SimpleTask&lt;/span&gt;&lt;span&gt;却不是，所以只能在构造方法里使用容器的&lt;/span&gt;&lt;span&gt;getBean&lt;/span&gt;&lt;span&gt;方式获取。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种方式通常是没有问题的，我们也都是这样用的。但是要把它放到定时任务里呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;会不会出现定时任务触发的较早，此时ApplicationContextUtils类里的静态字段ApplicationContext还没有被注入呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果真这样的话，那可就空指针了。那到底会不会这样呢，一起来探索发现下吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;探索与发现，没有频道&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我比较认同这个观点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当一个人什么都不知道的时候，他觉得自己什么都懂，老想出来指点江山。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当一个人随着学习知道的越多，他发现自己懂的越少，反而不敢随便乱说。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实就是，&lt;/span&gt;&lt;span&gt;知道的越多，问题就越多，随之而来的困惑也就越多。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我写完16篇《品Spring》文章，知道了bean定义注册的顺序、bean实例化的顺序、bean后处理器应用的顺序都和本文描述的问题有关。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以我也不敢冒然乱说，只能逐步测试逼近答案，这就是典型的知道的“太多了”的烦恼，哈哈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实本文的问题就是一个先后顺序的问题，如果定时任务先触发就会产生空指针，如果静态字段先注入，就不会有空指针。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而我选择了相信有空指针，完全是吃瓜群众幸灾乐祸的心理，嘻嘻。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以我就想办法安排空指针的出现。甚至“处心积虑”，直至使出浑身解数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一、&lt;/span&gt;&lt;span&gt;让定时任务的bean定义注册早于ApplicationContextUtils&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;抛开依赖不说，实例化的顺序就是bean定义注册的顺序。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;bean定义注册的顺序怎么确定呢？单就扫描jar包而言，就是包名和类名的字母顺序。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，我的安排如下图04：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925214331612-2032355454.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;最终bean定义的顺序符合预期，如下图05：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925214339944-461642350.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这说明bean实例化的顺序是，先实例化定时任务，再实例化ApplicationContextUtils。保证了定时任务在前。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;遗憾的是，我安排的空指针没有出现，一切是正常的，定时任务中可以获取到静态字段的值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;二、&lt;/span&gt;&lt;span&gt;让定时任务以最快的速度触发&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为这两个bean定义是挨着的，所以实例化也是挨着的。会不会是实例化执行的太快了？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于实例化的速度无法控制，所以就加快定时任务的触发速度，试试看。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;改成1秒就触发，如下图06：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925214352539-1363758359.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;哎，遗憾的是还是一切正常，我太想看到报错了，哈哈，继续使“阴招”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;三、&lt;/span&gt;&lt;span&gt;让ApplicationContextUtils的实例化过程卡住&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;定时任务肯定先实例化好，然后才会去实例化ApplicationContextUtils。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这次想办法让后者卡住，这样定时任务该先执行了吧。小样，我还治不了你啦。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为定时任务是在单独的线程池中执行，所以让主线程睡一会即可，如下图07：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925214404879-1442788550.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;主线程确实卡住了，遗憾的是还是一切正常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;深入虎穴，不为虎子&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ApplicationContext的注入和定时任务的处理都是由bean后处理器完成的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以把容器中的后处理器都输出来看看，如下图08：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925214420820-412258354.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;可以看到共有12个，显示的顺序就是它们被应用的顺序。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也就是说对于每一个bean实例的创建，都会应用这12个，且按如图顺序应用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;只不过每个bean后处理器只处理自己关注的bean，对于不关注的不起作用而已。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而且这12个的顺序只对单个bean有意义，对于不同的bean，没有意义。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为在测试时，我发现每次必须等容器启动好后，定时任务才开始执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以只能去看处理定时任务的bean后处理器源码了，即&lt;/span&gt;&lt;span&gt;ScheduledAnnotation&lt;/span&gt;&lt;span&gt;BeanPostProcessor这个类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是就从上往下看源码，当看到这个方法后，我似乎明白了，如下图09：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925214432015-872775177.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这是一个事件的回调方法，参数是&lt;/span&gt;&lt;span&gt;ContextRefreshed&lt;/span&gt;&lt;span&gt;事件对象，说明在容器启动完成后会调用这个方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再看看方法体，就一句代码，finishRegistration，完成注册，说明在容器没有启动好之前，这个注册是不会完成的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实已经表达的很清楚了，只有在容器启动完成后，定时任务才会完成注册，才会开始被调度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后再看看完成注册方法，它的最后一句代码如下图10：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925214440289-2049106127.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这个方法名很亲切吧，就是和初始化相关的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后再进到这个方法里看看，如下图11：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925214447854-1746059356.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;也只有一句代码，就是调度任务。哦，现在才开始调度。之前的只是注册任务，并没有调度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;惨遭打脸？&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;其实并没有&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我仔细看了几遍源码，发现写的很有特点，既支持容器启动好后触发定时任务，也支持容器启动过程中的及时触发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;只不过现在默认是前者而已。所以我怀疑以前可能就是及时触发，后来可能觉得不太合适，就进行了改造，成了现在这样子。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这既是探索与发现精神，也是好奇精神，就是它促使了我们向前发展，去了解更多的未知领域。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; 品Spring系列文章 &amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484224&amp;amp;idx=1&amp;amp;sn=78a994d8311dd0abf3f9419108ff363a&amp;amp;chksm=fc3338b0cb44b1a6803dbeb8540c17ce753f1878e3b7cc86cf6508e81dc32736f84d7224f166&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：帝国的基石&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484229&amp;amp;idx=1&amp;amp;sn=b552914c42963d06306d35f1d8332284&amp;amp;chksm=fc3338b5cb44b1a39d0762b2fd94d8870fcbc520b0713964d9a453d8466d781897707de8cd8f&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：bean定义上梁山&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484244&amp;amp;idx=1&amp;amp;sn=d500b3ed748331687028b78d567222a8&amp;amp;chksm=fc3338a4cb44b1b23f5dd9bef1cc66950a1ded23151a05b38716f4ec46ff960cdda5d8022e8f&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：实现bean定义时采用的“先进生产力”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484249&amp;amp;idx=1&amp;amp;sn=dfbdca65a2b64b0ac951f90b301e73a0&amp;amp;chksm=fc3338a9cb44b1bfafee072597430dae91d4dd8b4787e4af0896f9ce45b258fd5d3634169a5d&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：注解终于“成功上位”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484259&amp;amp;idx=1&amp;amp;sn=791a5726b9b7bf41e4e64053cfbc7ffa&amp;amp;chksm=fc333893cb44b1851d2052423392551ca9188c4fc0a33f412ddda13af9e0dc6655966a668964&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：能工巧匠们对注解的“加持”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484301&amp;amp;idx=1&amp;amp;sn=a5557c4c285cb07a052238d3de2a2585&amp;amp;chksm=fc33387dcb44b16b487edee0ab4c755de394d19dd4a0acd2532af0e49e95eb7988628e93157b&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：SpringBoot和Spring到底有没有本质的不同？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484319&amp;amp;idx=1&amp;amp;sn=89d925e6128109444c2ec40111a9f217&amp;amp;chksm=fc33386fcb44b179dcee6ef522e2252420658c0342759a9d6d9795bf90b144f6284c72fe808d&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：负责bean定义注册的两个“排头兵”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484337&amp;amp;idx=1&amp;amp;sn=398a1f718cc8b5a711ba9f45a6d9074b&amp;amp;chksm=fc333841cb44b157da33d685daedda001cb59abb64aa6152c3d4096d43c8d92bff8ae5d084ed&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：SpringBoot轻松取胜bean定义注册的“第一阶段”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484358&amp;amp;idx=1&amp;amp;sn=21fc717c7815ae41103e3e2e4f5520df&amp;amp;chksm=fc333836cb44b120fd9073b6075580109d5665afbd0f50abe43e8a5aea42e066c759dcdb8157&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：SpringBoot发起bean定义注册的“二次攻坚战”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484369&amp;amp;idx=1&amp;amp;sn=ac9d591014074f49a96bc9f3ed7cca4a&amp;amp;chksm=fc333821cb44b137f3c0c7c24b88fc5b3edfa0dc530366b884a3813759ae6fb32c1974e506de&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：注解之王@Configuration和它的一众“小弟们”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484403&amp;amp;idx=1&amp;amp;sn=f10760d51119f91b5c18d3267ebbd1eb&amp;amp;chksm=fc333803cb44b115a6fcab3e264233514f90fd8874f038361aaa174e8c73bb7f2a31d96f9099&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：bean工厂后处理器的调用规则&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484414&amp;amp;idx=1&amp;amp;sn=16391934efdc318c65251d311a6cc61c&amp;amp;chksm=fc33380ecb44b1183af1d82647996fb5ec24a3cc977b028671cb62f91edcc421542e92ecbe92&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：详细解说bean后处理器&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484431&amp;amp;idx=1&amp;amp;sn=29a6cc3aa9959c04512864ee59365f6b&amp;amp;chksm=fc333fffcb44b6e9cce30ca85ee1c8a32fd5e5597cd27d45a1c1a6bc3bd59b004df3cc66ea22&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：对@PostConstruct和@PreDestroy注解的处理方法&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484448&amp;amp;idx=1&amp;amp;sn=dc0e6d9b0ddd8168d749b90069999c03&amp;amp;chksm=fc333fd0cb44b6c68127c6a1e8b9c91891ef4ee37df40e7c85d2b67bd058d3c59e5e51d06101&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：对@Resource注解的处理方法&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484462&amp;amp;idx=1&amp;amp;sn=d492ff48764329f37abd452b0b4e1287&amp;amp;chksm=fc333fdecb44b6c8b6634ac340a63c9271d22a08e53d3adaeef5e487658a425122b45f84fd20&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：对@Autowired和@Value注解的处理方法&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484505&amp;amp;idx=1&amp;amp;sn=98e154a00e7782ec8fb9ca2d6295dfcd&amp;amp;chksm=fc333fa9cb44b6bf0283da8353aba4cca8267315c91e18765dfebc4aa70da96394b9b374e078&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：真没想到，三十步才能完成一个bean实例的创建&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; 热门文章集锦 &amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484219&amp;amp;idx=1&amp;amp;sn=e6c39138e44ce8f0c91aba4873fb42cd&amp;amp;chksm=fc3338cbcb44b1dde7ae372ed66b40bdf4f755d711008810eb837a8f78d884f00956ae7ce7a7&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;毕业10年，我有话说&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247483949&amp;amp;idx=1&amp;amp;sn=200c9ac4f8e4e877b0b253d45205712a&amp;amp;chksm=fc3339ddcb44b0cb5ac2957dbed41b2f9e11fbba14967d00f97012806a9d6af364b0f8135eee&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】我是如何面试别人List相关知识的，深度有点长文&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247483989&amp;amp;idx=1&amp;amp;sn=cf9ce5c3f7981c16b71047b868b1c1ab&amp;amp;chksm=fc3339a5cb44b0b3df524ce684e8cd76ab6d15a2ccf26ec2425ecbcdd26bc777b95a06994189&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;我是如何在毕业不久只用1年就升为开发组长的&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247483994&amp;amp;idx=1&amp;amp;sn=fb09e943331e89abcb99d8304ea6b677&amp;amp;chksm=fc3339aacb44b0bc2a120c79efebb46a43ce5b4d3148992d86b2841a89bb46bf5d8863e065ea&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;爸爸又给Spring MVC生了个弟弟叫Spring WebFlux&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484017&amp;amp;idx=1&amp;amp;sn=a2055640b142fc4cfa5a9901d22ec57f&amp;amp;chksm=fc333981cb44b09782c196da25dc613b38a9ede52de073bfaaaef6214a9deb294b6527091892&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】我是如何在面试别人Spring事务时“套路”对方的&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484029&amp;amp;idx=1&amp;amp;sn=44b05473af37fe008bb9659a35d1a9de&amp;amp;chksm=fc33398dcb44b09bbd25a7e14e7100419988479fbeb4bda7787f1b93dd932ec699dfd793df04&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】Spring事务面试考点吐血整理（建议珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484158&amp;amp;idx=1&amp;amp;sn=1ca952ba9166c5ccf0e3f40622335fc5&amp;amp;chksm=fc33390ecb44b01898bb2500ba61a15e38487a23f5c0405d738cc4c272cd705d2dbbf1a3f8e7&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】我是如何在面试别人Redis相关知识时“软怼”他的&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484164&amp;amp;idx=1&amp;amp;sn=390d911b19812d22aebd3f0f6522004c&amp;amp;chksm=fc3338f4cb44b1e20bc2344474586934a2b148f92eefdaecf134d57af10f64310579e196904a&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】吃透了这些Redis知识点，面试官一定觉得你很NB（干货 | 建议珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484184&amp;amp;idx=1&amp;amp;sn=37007efde0cc93e48c55a133dc9cc8d4&amp;amp;chksm=fc3338e8cb44b1fea0ed4af7f01de658e8a1bc7f573cb5bde2701d9b09ba14747139d2bcea39&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】如果你这样回答“什么是线程安全”，面试官都会对你刮目相看（建议珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484195&amp;amp;idx=1&amp;amp;sn=95c3acdaeb0f6a1d61f152550c3d2669&amp;amp;chksm=fc3338d3cb44b1c55f6046f6280da863d3514cca3ce50ef29e2d53b0eafe2b7efef062c51c27&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】迄今为止把同步/异步/阻塞/非阻塞/BIO/NIO/AIO讲的这么清楚的好文章（快快珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484201&amp;amp;idx=1&amp;amp;sn=7cf45aff64eecdff58d2acea8fb7c9fa&amp;amp;chksm=fc3338d9cb44b1cfc6b5c797a005c91ed19b0dd06587fdfb2e7b553e2b03104a145380a7a990&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】一篇文章帮你彻底搞清楚“I/O多路复用”和“异步I/O”的前世今生（深度好文，建议珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484206&amp;amp;idx=1&amp;amp;sn=9547fdad111ac1a8ac9311cb9e76b9dc&amp;amp;chksm=fc3338decb44b1c89aee789e80e32989ea43232321397cc265c99b1d0ce4057e6563bc00a3d3&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】如果把线程当作一个人来对待，所有问题都瞬间明白了&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484214&amp;amp;idx=1&amp;amp;sn=0f677e8b0d61b5a5317a274cc8b33cbc&amp;amp;chksm=fc3338c6cb44b1d06aa20533aafb0b7b709b3bd88dbf6af6b8f3cb91288e4afc585ecb77489a&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Java多线程通关———基础知识挑战&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484224&amp;amp;idx=1&amp;amp;sn=78a994d8311dd0abf3f9419108ff363a&amp;amp;chksm=fc3338b0cb44b1a6803dbeb8540c17ce753f1878e3b7cc86cf6508e81dc32736f84d7224f166&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：帝国的基石&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;作者&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是工作超过&lt;/span&gt;&lt;span&gt;&lt;strong&gt;10年&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;的码农，现在任架构师。喜欢研究技术，崇尚简单快乐。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;追求以通俗易懂的语言解说技术，希望所有的读者都能看懂并记住。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;下面是公众号和知识星球的二维码，欢迎关注！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201904/76066-20190419093441100-1622885471.jpg&quot; alt=&quot;&quot;/&gt;      &lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://img2018.cnblogs.com/blog/76066/201904/76066-20190419132131137-250931220.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 11 Oct 2019 00:37:00 +0000</pubDate>
<dc:creator>编程新说(李新杰)</dc:creator>
<og:description>非Spring风格的代码与Spring的结合现在的开发都是基于Spring的，所有的依赖都有Spring管理，这没有问题。但是要突然写一些非Spring风格的代码时，可能会很不习惯，如果还要和Spri</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lixinjie/p/taste-spring-017.html</dc:identifier>
</item>
<item>
<title>前后端分离开发中动态菜单的两种实现方案 - 江南一点雨</title>
<link>http://www.cnblogs.com/lenve/p/11651861.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lenve/p/11651861.html</guid>
<description>&lt;p&gt;关于前后端分离开发中的权限处理问题，松哥之前写过一篇文章和大家聊这个问题：&lt;/p&gt;
&lt;p&gt;但是最近有小伙伴在学习微人事项目时，对动态菜单这一块还是有疑问（即不同用户登录成功后会看到不同的菜单项），因此松哥打算再来写一篇文章和大家聊一聊前后端分离开发中的动态菜单问题。&lt;/p&gt;
&lt;h2 id=&quot;一个原则&quot;&gt;1. 一个原则&lt;/h2&gt;
&lt;p&gt;做权限管理，一个核心思想就是后端做权限控制，前端做的所有工作都只是为了提高用户体验，我们不能依靠前端展示或者隐藏一个按钮来实现权限控制，这样肯定是不安全的。&lt;/p&gt;
&lt;p&gt;就像用户注册时需要输入邮箱地址，前端校验之后，后端还是要校验，两个校验目的不同，前端校验是为了提高响应速度，优化用户体验，后端校验则是为了确保数据完整性。权限管理也是如此，前端按钮的&lt;code&gt;展示/隐藏&lt;/code&gt;都只是为了提高用户体验，真正的权限管理需要后端来实现。&lt;/p&gt;
&lt;p&gt;这是非常重要的一点，做前后端分离开发中的权限管理，我们首先要建立上面这样的思考框架，然后在这样的框架下，去考虑其他问题。&lt;/p&gt;
&lt;p&gt;因此，下文我会和大家分享两种方式实现动态菜单，这两种方式仅仅只是探讨如何更好的给用户展示菜单，而不是探讨权限管理，因为权限管理是在后端完成的，也必须在后端完成。&lt;/p&gt;
&lt;h2 id=&quot;具体实现&quot;&gt;2. 具体实现&lt;/h2&gt;
&lt;p&gt;一旦建立起这样的思考框架，你会发现动态菜单的实现办法太多了。&lt;/p&gt;
&lt;p&gt;动态菜单就是用户登录之后看到的菜单，不用角色的用户登录成功之后，会看到不用的菜单项，这个动态菜单要怎么实现呢？整体来说，有两种不同的方案，松哥曾经做过的项目中，两种方案也都有用过，这里分别来和大家分享一下。&lt;/p&gt;
&lt;h3 id=&quot;后端动态返回&quot;&gt;2.1 后端动态返回&lt;/h3&gt;
&lt;p&gt;后端动态返回，这是我在微人事中采用的方案。微人事中，权限管理相关的表一共有五张表，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747810/201910/747810-20191011083507388-1943542607.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;hr&lt;/code&gt; 表就是用户表，用户登录成功之后，可以查询到用户的角色，再根据用户角色去查询出来用户可以操作的菜单（资源），然后把这些可以操作的资源，组织成一个 JSON 数据，返回给前端，前端再根据这个 JSON 渲染出相应的菜单。以微人事为例，我们返回的 JSON 数据格式如下：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;[
    {
        &quot;id&quot;:2,
        &quot;path&quot;:&quot;/home&quot;,
        &quot;component&quot;:&quot;Home&quot;,
        &quot;name&quot;:&quot;员工资料&quot;,
        &quot;iconCls&quot;:&quot;fa fa-user-circle-o&quot;,
        &quot;children&quot;:[
            {
                &quot;id&quot;:null,
                &quot;path&quot;:&quot;/emp/basic&quot;,
                &quot;component&quot;:&quot;EmpBasic&quot;,
                &quot;name&quot;:&quot;基本资料&quot;,
                &quot;iconCls&quot;:null,
                &quot;children&quot;:[

                ],
                &quot;meta&quot;:{
                    &quot;keepAlive&quot;:false,
                    &quot;requireAuth&quot;:true
                }
            }
        ],
        &quot;meta&quot;:{
            &quot;keepAlive&quot;:false,
            &quot;requireAuth&quot;:true
        }
    }
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样的 JSON 在前端中再进行二次处理之后，就可以使用了，前端的二次处理主要是把 component 属性的字符串值转为对象。这一块具体操作大家可以参考微人事项目（具体在：&lt;code&gt;https://github.com/lenve/vhr/blob/master/vuehr/src/utils/utils.js&lt;/code&gt;），我就不再赘述了。&lt;/p&gt;
&lt;p&gt;这种方式的一个好处是前端的判断逻辑少一些，后端也不算复杂，就是一个 SQL 操作，前端拿到后端的返回的菜单数据，稍微处理一下就可以直接使用了。另外这种方式还有一个优势就是可以动态配置&lt;strong&gt;资源-角色&lt;/strong&gt;以及&lt;strong&gt;用户-角色&lt;/strong&gt;之间的关系，进而调整用户可以操作的资源(菜单)。&lt;/p&gt;
&lt;h3 id=&quot;前端动态渲染&quot;&gt;2.2 前端动态渲染&lt;/h3&gt;
&lt;p&gt;另一种方式就是前端动态渲染，这种方式后端的工作要轻松一些，前端处理起来麻烦一些，松哥去年年末帮一个律所做的一个管理系统，因为权限上比较容易，我就采用了这种方案。&lt;/p&gt;
&lt;p&gt;这种方式就是我直接在前端把所有页面都在路由表里边定义好，然后在 meta 属性中定义每一个页面需要哪些角色才能访问，例如下面这样：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;[
    {
        &quot;id&quot;:2,
        &quot;path&quot;:&quot;/home&quot;,
        &quot;component&quot;:Home,
        &quot;name&quot;:&quot;员工资料&quot;,
        &quot;iconCls&quot;:&quot;fa fa-user-circle-o&quot;,
        &quot;children&quot;:[
            {
                &quot;id&quot;:null,
                &quot;path&quot;:&quot;/emp/basic&quot;,
                &quot;component&quot;:EmpBasic,
                &quot;name&quot;:&quot;基本资料&quot;,
                &quot;iconCls&quot;:null,
                &quot;children&quot;:[

                ],
                &quot;meta&quot;:{
                    &quot;keepAlive&quot;:false,
                    &quot;requireAuth&quot;:true,
                    &quot;roles&quot;:['admin','user']
                }
            }
        ],
        &quot;meta&quot;:{
            &quot;keepAlive&quot;:false,
            &quot;requireAuth&quot;:true
        }
    }
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样定义表示当前登录用户需要具备 admin 或者 user 角色，才可以访问 EmpBasic 组件，当然这里不是说我这样定义了就行，这个定义只是一个标记，在项目首页中，我会遍历这个数组做菜单动态渲染，然后根据当前登录用户的角色，再结合当前组件需要的角色，来决定是否把当前组件所对应的菜单项渲染出来。&lt;/p&gt;
&lt;p&gt;这样的话，后端只需要在登录成功后返回当前用户的角色就可以了，剩下的事情则交给前端来做。不过这种方式有一个弊端就是菜单和角色的关系在前端代码中写死了，以后如果想要动态调整会有一些不方便，可能需要改代码。特别是大项目，权限比较复杂的时候，调整就更麻烦了，所以这种方式我一般建议在一些简单的项目中使用。&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;3. 结语&lt;/h2&gt;
&lt;p&gt;虽然我在微人事中使用了第一种方式，不过如果小伙伴是一个新项目，并且权限问题不是很复杂的话，我还是建议尝试一下第二种方式，感觉要方便一些。&lt;/p&gt;
&lt;p&gt;不过在公司中，动态菜单到底在前端做还是后端做，可能会有一个前后端团队沟（si）通（bi）的过程，赢了的一方就可以少写几行代码了。&lt;/p&gt;
&lt;p&gt;关注公众号【江南一点雨】，专注于 Spring Boot+微服务以及前后端分离等全栈技术，定期视频教程分享，关注后回复 Java ，领取松哥为你精心准备的 Java 干货！&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747810/201910/747810-20191011083607703-1353080945.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 11 Oct 2019 00:36:00 +0000</pubDate>
<dc:creator>江南一点雨</dc:creator>
<og:description>关于前后端分离开发中的权限处理问题，松哥之前写过一篇文章和大家聊这个问题： 'Spring Boot + Vue 前后端分离开发，权限管理的一点思路' 但是最近有小伙伴在学习微人事项目时，对动态菜单这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lenve/p/11651861.html</dc:identifier>
</item>
<item>
<title>『开发技术』Ubuntu与Windows如何查看CPU&amp;GPU&amp;内存占用量 - 小宋是呢</title>
<link>http://www.cnblogs.com/xiaosongshine/p/11651856.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaosongshine/p/11651856.html</guid>
<description>&lt;h2&gt;0 序·简介&lt;/h2&gt;

&lt;p&gt;在使用Ubuntu或者Windows执行一些复杂数据运算时，需要关注下CPU、GPU以及内存占用量，如果数据运算超出了负荷，会产生难以预测的错误。本文将演示如何用简单地方式，实时监控Ubuntu或者Windows的CPU、GPU以及内存占用量，教会大家如何实时监控电脑状态。&lt;/p&gt;
&lt;p&gt;水平有限，笔者在这里仅仅使用最简便的方式来实现，抛砖引玉，以便于小白用户也能掌握。大佬们看不上莫要喷，欢迎在评论处补充。觉得有用的话，记得点赞收藏。&lt;/p&gt;
&lt;p&gt;废话不多说，操作教程正式开始。。&lt;/p&gt;

&lt;hr/&gt;&lt;h2&gt;1 Ubuntu系统操作&lt;/h2&gt;
&lt;p&gt;在Linux系操作系统中，Shell指令具备功能强大，使用高效便捷等特点。隶属于Linux的Ubuntu系统也继承了这些优点。只需要简单一句指令就可以查看相关信息（真的很高效）。&lt;/p&gt;

&lt;h3&gt;1.0 查看CPU与内存使用&lt;/h3&gt;
&lt;p&gt;在Ubuntu中内置了 &lt;strong&gt;top&lt;/strong&gt; 指令，可以查看CPU与内存信息，我们在Shell 输入 top：&lt;/p&gt;

&lt;p&gt;输出结果如下：（数据实时刷新）Ctrl + C 退出&lt;/p&gt;

&lt;p&gt;虽然可以看到相关信息，但是界面很不友好，有用信息难以辨识。&lt;/p&gt;
&lt;p&gt;后面笔者又找到一个新的工具（指令）&lt;strong&gt;htop&lt;/strong&gt; 使用起来就直观多了，如果当前Ubuntu系统没有这个指令的话，可以使用 apt 安装：&lt;/p&gt;

&lt;p&gt;如果Bash输出信息如下的话：就表示系统已经有过这个指令了，无需再安装&lt;/p&gt;

&lt;p&gt;下面我们使用 &lt;strong&gt;htop&lt;/strong&gt; 指令来查看：&lt;/p&gt;

&lt;p&gt;结果如下：（数据实时刷新）Ctrl + C 退出&lt;/p&gt;

&lt;p&gt;可以发现直观多了，1-8分别代表每个CPU占用量，Mem 代表内存占用。&lt;/p&gt;
&lt;p&gt;综上，推荐大家使用 &lt;strong&gt;htop&lt;/strong&gt; 指令查看CPU与内存使用。&lt;/p&gt;

&lt;h3&gt;1.1 查看GPU使用情况&lt;/h3&gt;
&lt;p&gt;类似 &lt;strong&gt;top&lt;/strong&gt; 指令，Ubuntu中也内置了用于查看GPU的指令：&lt;strong&gt;nvidia-smi&lt;/strong&gt; 使用这个指令的前提是在Ubuntu中安装好了GPU驱动&lt;/p&gt;

&lt;p&gt;输出结果如下：（只显示当前信息，不能实时显示）&lt;/p&gt;

&lt;p&gt;可以发现，的确输出了相关信息，但是只是我们运行指令时的信息，无法实时更新。如何让GPU信息也实时更新呢，我们就要借助 &lt;strong&gt;watch -n&lt;/strong&gt; 指令，&lt;strong&gt;watch -n 1&lt;/strong&gt; 就表示 1秒刷新一下信息。下面我们更改一下指令：每0.1 秒刷新显示一下。Ctrl + C 退出&lt;/p&gt;

&lt;hr/&gt;&lt;h2&gt;2 Windows系统操作&lt;/h2&gt;
&lt;p&gt;Windows系统虽然没有Ubuntu系统那么高效的指令，但是查看相关信息还是很方便的。&lt;/p&gt;
&lt;p&gt;使用快捷按键 &lt;strong&gt;Ctrl + Alt + Delele&lt;/strong&gt; 调出 任务管理器：&lt;/p&gt;
&lt;p&gt;如果你的界面是这样的：&lt;/p&gt;

&lt;p&gt;只需点击 &lt;strong&gt;详细信息&lt;/strong&gt; 按钮展开如下：&lt;/p&gt;

&lt;p&gt;然后点击 &lt;strong&gt;性能&lt;/strong&gt; 按钮：&lt;/p&gt;

&lt;p&gt;我们就可以看出相关占用信息了，选中某一个右边就是详细信息的展示，上图是CPU的显示，第二个就是内存。&lt;/p&gt;


&lt;p&gt;左边往下拉，我们可以发现有两个GPU，要注意一下，GPU 0是Intel的集成显卡。而我们常用来计算的是下面的GPU Nvidia的显卡。&lt;/p&gt;

&lt;p&gt;笔者在这里仅仅使用最简便的方式来实现了实时监控Ubuntu或者Windows的CPU、GPU以及内存占用量，以便于大家更高效利用硬件。大佬们看不上莫要喷，欢迎在评论处补充。觉得有用的话，记得点赞收藏。&lt;/p&gt;
</description>
<pubDate>Fri, 11 Oct 2019 00:35:00 +0000</pubDate>
<dc:creator>小宋是呢</dc:creator>
<og:description>0 序&amp;#183;简介 在使用Ubuntu或者Windows执行一些复杂数据运算时，需要关注下CPU、GPU以及内存占用量，如果数据运算超出了负荷，会产生难以预测的错误。本文将演示如何用简单地方式，实</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaosongshine/p/11651856.html</dc:identifier>
</item>
<item>
<title>[ASP.NET Core 3框架揭秘] 跨平台开发体验: Windows [下篇] - Artech</title>
<link>http://www.cnblogs.com/artech/p/inside-asp-net-core-01-03.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/inside-asp-net-core-01-03.html</guid>
<description>&lt;p&gt;由于ASP.NET Core框架在本质上就是由服务器和中间件构建的消息处理管道，所以在它上面构建的应用开发框架都是建立在某种类型的中间件上，整个ASP.NET Core MVC开发框架就是建立在用来实现路由的&lt;strong&gt;EndpointRoutingMiddleware&lt;/strong&gt;和&lt;strong&gt;EndpointMiddleware&lt;/strong&gt;中间件上。ASP.NET Core MVC利用路由系统为它分发请求，并在此基础上实现针对目标Controller的激活、Action方法的选择和执行，以及最终对于执行结果的响应。在介绍的实例演示中，我们将对上面创建的ASP.NET Core作进一步改造，使之转变成一个MVC应用。&lt;/p&gt;

&lt;p&gt;ASP.NET Core框架内置了一个原生的依赖注入框架，该框架利用一个依赖注入容器提供管道在构建以及请求处理过程中所需的服务，而这些服务需要在应用启动的时候被预先注册。对于ASP.NET Core MVC框架来说，它在处理HTTP请求的过程中所需的一系列服务同样需要预先注册。对这个概念有了基本的了解之后，相信读者朋友们对如下所示的代码就容易理解了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Builder;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Hosting;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.DependencyInjection;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Hosting;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; helloworld
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
        {
            Host.CreateDefaultBuilder()
                .ConfigureWebHostDefaults(webHostBuilder &lt;/span&gt;=&amp;gt;&lt;span&gt; webHostBuilder
                    .ConfigureServices(servicecs &lt;/span&gt;=&amp;gt;&lt;span&gt; servicecs
                        .AddRouting()
                        .AddControllersWithViews())
                    .Configure(app &lt;/span&gt;=&amp;gt;&lt;span&gt; app
                        .UseRouting()
                        .UseEndpoints(endpoints &lt;/span&gt;=&amp;gt;&lt;span&gt; endpoints.MapControllers())))
                .Build()
                .Run();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整个ASP.NET MVC框架建立在&lt;strong&gt;EndpointRoutingMiddleware&lt;/strong&gt;和&lt;strong&gt;EndpointMiddleware&lt;/strong&gt;中间件构建的路由系统上，这两个中间件采用“终结点（Endpoint）映射”的方式实现针对HTTP请求的路由。这里所谓的终结点可以视为应用程序提供的针对HTTP请求的处理器，这两个终结点通过预先设置的规则将具有某些特征的请求（比如路径、HTTP方法等）映射到对应的终结点，进而实现路由的功能。对于一个MVC应用程序来说，我们可以将定义在Controller类型中的Action方法视为一个终结点，那么路由映射最终体现在HTTP请求与目标Action方法的映射上。&lt;/p&gt;
&lt;p&gt;如上面的代码片段所示，我们先后调用了IApplicationBuilder接口的&lt;strong&gt;UseRouting&lt;/strong&gt;和&lt;strong&gt;UseEndpoints&lt;/strong&gt;扩展方法注册了EndpointRoutingMiddleware和EndpointMiddleware中间件。在调用UseEndpoints方法的时候，我们利用指定的Action&amp;lt;IEndpointRouteBuilder&amp;gt;委托对象调用了IEndpointRouteBuilder接口的&lt;strong&gt;MapControllers&lt;/strong&gt;扩展方法完成了针对定义在Controller类型中所有Action方法的映射。&lt;/p&gt;
&lt;p&gt;由于注册的中间件具有对其他服务的依赖，我们需要预先将这些服务注册到依赖注入框架中。依赖服务的注册通过调用IWebHostBuilder的&lt;strong&gt;ConfigureServices&lt;/strong&gt;方法来完成，该方法的参数类型为Action&amp;lt;IServiceCollection&amp;gt;，添加的服务注册就保存在IServiceCollection接口表示的集合中。在上面的演示程序中，两个中间件依赖的服务是通过调用IServiceCollection接口的&lt;strong&gt;AddRouting&lt;/strong&gt;和&lt;strong&gt;AddControllersWithViews&lt;/strong&gt;方法进行注册的。&lt;/p&gt;
&lt;p&gt;如下所示的HelloController是我们定义的Controller类型。按照约定，所有的Controller类型名称都应该以“&lt;strong&gt;Controller&lt;/strong&gt;”字符作为后缀。与之前版本的ASP.NET MVC不同，ASP.NET Core MVC下的Controller类型并不要求强制继承某个基类。我们在HelloController中定义了一个唯一的Action方法SayHello，该方法直接返回一个内容为“Hello World”的字符串。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloController
{
    [HttpGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; SayHello() =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们在Action方法SayHello上通过标注的HttpGetAttribute特性注册了一个模板为“/hello”的路由，意味着请求地址为“/hello”的GET请求最终会被路由到这个Action方法上，而该方法执行的结果将作为请求的响应内容。所以启动该程序后使用浏览器访问地址“http://localhost:5000/hello”,我们依然会得到如下图所示的输出结果。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191011081741214-1370480681.png&quot;&gt;&lt;img width=&quot;534&quot; height=&quot;316&quot; title=&quot;1-7&quot; alt=&quot;1-7&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191011081741556-991669238.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;上面这个程序并没有涉及视图，所以算不上一个典型的MVC应用，接下来我们对它做进一步改造。为了让HelloController具有视图呈现的能力，我们让它派生于基类&lt;strong&gt;Controller&lt;/strong&gt;。Action方法SayHello的返回类型被修改为&lt;strong&gt;IActionResult&lt;/strong&gt;接口，它表示Action方法执行的结果。我们为该方法定义了一个表示姓名的参数name，通过HttpGetAttribute特性注册的路由模板（“/hello/{name}”）中具有与之对应的路由参数。换句话说，满足该路径模式的请求URL携带的姓名将自动绑定到该Action方法的name参数上。在SayHello方法中，我们利用ViewBag将代表姓名的name参数值传递给呈现的视图，该方法最终调用&lt;strong&gt;View&lt;/strong&gt;方法返回当前Action方法对应的&lt;strong&gt;ViewResult&lt;/strong&gt;对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloController : Controller
{
    [HttpGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/hello/{name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IActionResult SayHello(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
    {
        ViewBag.Name &lt;/span&gt;=&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于我们调用View方法时没有显式指定视图的名称，所以视图引擎会将当前Action的名称（“SayHello”）作为视图的名称。如果该视图还没有经过编译（部署时针对View的预编译，或者在这之前针对该View的动态编译），视图引擎将从若干候选的路径中读取对应的.cshtml 文件进行编译，其中首选的路径为“{ContentRoot}\Views\{ControllerName}\{ViewName}.cshtml”。为了迎合视图引擎定位视图文件的规则，我们需要将SayHello对应的视图文件（SayHello.cshtml）定义在目录“\Views\Hello\”下。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191011081741787-1091108643.png&quot;&gt;&lt;img width=&quot;290&quot; height=&quot;299&quot; title=&quot;1-12&quot; alt=&quot;1-12&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191011081742036-527092462.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如下所示的就是SayHello.cshtml这个文件的内容，这是一个针对Razor引擎的视图文件。从文件的扩展名（.cshtml）我们看出可以这样的文件可以同时包含HTML标签和C#代码。总的来说，视图文件会在服务端生成最终在浏览器呈现出来的HTML，我们可以在这个文件中直接提供原样输出的HTML标签，也可以内嵌一段动态执行的C#代码。虽然Razor引擎对View文件的编写制定了严格的语法，但是我个人觉得没有必要在Razor语法上花太多的精力，因为Razor语法的目的就是让我们很“自然”地将动态C#代码和静态HTML标签结合起来，并最终生成一份完整的HTML文档，因此它的语法和普通的思维基本是一致。比如下面这个View最终会生成一个完整的HTML文档，其主体部分只有一个&amp;lt;p&amp;gt;标签。该标签的内容是动态的，因为包含利用&lt;strong&gt;ViewBag&lt;/strong&gt;从Controller传进来的姓名。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Hello World&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Hello, @ViewBag.Name&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;再次运行该程序后，我们利用浏览器访问地址“http://localhost:5000/hello/foobar”。由于请求地址与Action方法SayHello上的路由规则相匹配，所以路径携带的姓名（foobar）会绑定到该方法的name参数上，所以我们最终将在浏览器上得到如下图所示的输出结果。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191011081742295-326912376.png&quot;&gt;&lt;img width=&quot;417&quot; height=&quot;160&quot; title=&quot;1-13&quot; alt=&quot;1-13&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191011081742519-946388551.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;任何一个ASP.NET Core应用在初始化的时候都会根据请求处理的需求注册对应的中间件。在前面演示的实例中，我们都是直接调用IWebHostBuilder的&lt;strong&gt;Configure&lt;/strong&gt;扩展方法来注册所需的中间件，但是在大部分真实的开发场景中我们一般会将中间件以及依赖服务的注册定义在一个单独的类型中。按照约定，我们通常会将这个类型命名为&lt;strong&gt;Startup&lt;/strong&gt;，比如我们演示实例中针对服务和中间件的注册就可以放在如下定义的这个Startup类中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ConfigureServices(IServiceCollection services) =&amp;gt;&lt;span&gt; services
        .AddRouting()
        .AddControllersWithViews();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Configure(IApplicationBuilder app) =&amp;gt;&lt;span&gt; app
        .UseRouting()
        .UseEndpoints(endpoints &lt;/span&gt;=&amp;gt;&lt;span&gt; endpoints.MapControllers());
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上面的代码片段所示，我们不需要让Startup类实现某个预定义的接口或者继承某个预定义基类，所采用的完全是一种基于“约定”的定义方式。随着对ASP.NET Core框架认识的加深，我们会发现这种“&lt;strong&gt;约定优于配置&lt;/strong&gt;”的设计广泛地应用在整个框架之中。按照约定，服务注册和中间件注册分别实现在&lt;strong&gt;ConfigureServices&lt;/strong&gt;和&lt;strong&gt;Configure&lt;/strong&gt;方法中，它们的第一个参数类型分别为&lt;strong&gt;IServiceCollection&lt;/strong&gt;和&lt;strong&gt;IApplicationBuilder&lt;/strong&gt;接口。由于已经将两种核心的操作转移到了Startup类型中，所以我们需要注册该类型。Startup类型可以调用IWebHostBuilder接口的&lt;strong&gt;UseStartup&amp;lt;TStartup&amp;gt;&lt;/strong&gt;扩展方法进行注册。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        Host.CreateDefaultBuilder()
            .ConfigureWebHostDefaults(webHostBuilder &lt;/span&gt;=&amp;gt; webHostBuilder.UseStartup&amp;lt;Startup&amp;gt;&lt;span&gt;())
            .Build()
            .Run();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们在前面的内容中对.NET Core、ASP.NET Core以及ASP.NET Core MVC应用的编程作了初步的体验，但是这仅仅限于我们熟悉的Windows平台。作为一个号称跨平台的开发框架，我们有必要在其他操作系统平台上体验一下.NET Core开发的乐趣。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-01.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Windows [上篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-02.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Windows [中篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-03.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Windows [下篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-04.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Mac OS&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-05.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Linux&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-01.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Docker&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 11 Oct 2019 00:18:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>由于ASP.NET Core框架在本质上就是由服务器和中间件构建的消息处理管道，所以在它上面构建的应用开发框架都是建立在某种类型的中间件上，整个ASP.NET Core MVC开发框架就是建立在用来实</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/inside-asp-net-core-01-03.html</dc:identifier>
</item>
<item>
<title>设计模式-行为型-解释器模式 - 酷学大叔</title>
<link>http://www.cnblogs.com/az4215/p/11648518.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/az4215/p/11648518.html</guid>
<description>&lt;p&gt;&lt;span&gt;解释器模式（Interpreter）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　从名称上来看看这个模式，个人的最初理解“解释器”和Google的中英翻译功能类似。如果有一天你去国外旅游去了，比如去美国吧，美国人是讲英语的，我们是讲汉语的，如果英语听不懂，讲不好，估计沟通就完蛋了，不能沟通，估计玩的就很难尽兴了，因为有很多景点的解说你可能不明白（没有中文翻译的情况下，一般情况会有的）。所以我们需要一个软件，可以把中英文互译，那彼此就可以更好的理解对方的意思，我感觉翻译软件也可以称得上是解释器，把你不懂的解释成你能理解的。我们写代码，需要编译器把我们写的代码编译成机器可以理解的机器语言，从这方面来讲，C#的编译器也是一种解释器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解释器模式的角色：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1445321/201910/1445321-20191010154535261-1023903020.png&quot; alt=&quot;&quot; width=&quot;339&quot; height=&quot;178&quot;/&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1）抽象解释器（AbstractExpression）：定义解释器的接口，约定解释器的解释操作。其中的Interpret接口，正如其名字那样，它是专门用来解释该解释器所要实现的功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2）终结符表达式（TermialExpression）：实现了抽象表达式角色所要求的接口，主要是一个interpret()方法；文法中的每一个终结符都有一个具体终结表达式与之相对应。比如有一个简单的公式R=R1+R2，在里面R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3）非终结符表达式（NonterminalExpression）：文法中的每一条规则都需要一个具体的非终结符表达式，非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R=R1+R2中，“+”就是非终结符，解析“+”的解释器就是一个非终结符表达式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4）环境角色（Context）：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如R=R1+R2，我们给R1赋值100，给R2赋值200。这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们演示一个判断且或的例子。&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AbstractExpression
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Interpret(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; context);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TerminalExpression : AbstractExpression
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; data;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; TerminalExpression(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; data)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.data =&lt;span&gt; data;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Interpret(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; context)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; data.Contains(context);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrExpression : AbstractExpression
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; AbstractExpression expr1 = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; AbstractExpression expr2 = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; OrExpression(AbstractExpression expr1, AbstractExpression expr2)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.expr1 =&lt;span&gt; expr1;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.expr2 =&lt;span&gt; expr2;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Interpret(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; context)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; expr1.Interpret(context) ||&lt;span&gt; expr2.Interpret(context);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AndExpression : AbstractExpression
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; AbstractExpression expr1 = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; AbstractExpression expr2 = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; AndExpression(AbstractExpression expr1, AbstractExpression expr2)
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.expr1 =&lt;span&gt; expr1;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.expr2 =&lt;span&gt; expr2;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Interpret(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; context)
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; expr1.Interpret(context) ||&lt;span&gt; expr2.Interpret(context);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;规则：Robert 和 John 是男性&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; AbstractExpression GetMaleExpression()
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;         AbstractExpression robert = &lt;span&gt;new&lt;/span&gt; TerminalExpression(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Robert&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         AbstractExpression john = &lt;span&gt;new&lt;/span&gt; TerminalExpression(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;John&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OrExpression(robert, john);
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; 
&lt;span&gt;65&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;规则：Julie 是一个已婚的女性&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; AbstractExpression GetMarriedWomanExpression()
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;         AbstractExpression julie = &lt;span&gt;new&lt;/span&gt; TerminalExpression(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Julie&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;         AbstractExpression married = &lt;span&gt;new&lt;/span&gt; TerminalExpression(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Married&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AndExpression(julie, married);
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; 
&lt;span&gt;73&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;         AbstractExpression isMale =&lt;span&gt; GetMaleExpression();
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;         AbstractExpression isMarriedWoman =&lt;span&gt; GetMarriedWomanExpression();
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; 
&lt;span&gt;78&lt;/span&gt;         Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;John is male? {isMale.Interpret(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;John&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;         Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Julie is a married women? {isMarriedWoman.Interpret(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;Married Julie&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　这里我们可以得出：解释器模式有很好的扩展模式，或此时我们希望能够找到一位男士已婚，我们只需要再写一个非终结符表达式即可，易于扩展。我们再来看下面这个例子。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 抽象表达式&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Expression
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt; table = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;9&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; 
&lt;span&gt;  6&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Expression()
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;         table.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;一&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;         table.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;二&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;         table.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;三&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;         table.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;四&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;         table.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;五&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;         table.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;六&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;         table.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;七&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;         table.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;八&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;         table.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;九&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; 
&lt;span&gt; 19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Interpreter(Context context)
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (context.Statement.Length == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; 
&lt;span&gt; 26&lt;/span&gt;         &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; table.Keys)
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; value =&lt;span&gt; table[key];
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; 
&lt;span&gt; 30&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (context.Statement.EndsWith(key +&lt;span&gt; GetPostFix()))
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;                 context.Data += value * &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Multiplier();
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;                 context.Statement = context.Statement.Substring(&lt;span&gt;0&lt;/span&gt;, context.Statement.Length - &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.GetLength());
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (context.Statement.EndsWith(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;零&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;                 context.Statement = context.Statement.Substring(&lt;span&gt;0&lt;/span&gt;, context.Statement.Length - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; 
&lt;span&gt; 42&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetPostFix();
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; 
&lt;span&gt; 44&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Multiplier();
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; 
&lt;span&gt; 46&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个可以通用，但是对于个位数字例外，所以用虚方法&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; GetLength()
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.GetPostFix().Length + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; 
&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;个位表达式&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GeExpression : Expression
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetPostFix()
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; 
&lt;span&gt; 61&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Multiplier()
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; 
&lt;span&gt; 66&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; GetLength()
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; 
&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;十位表达式&lt;/span&gt;
&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ShiExpression : Expression
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetPostFix()
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;十&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; 
&lt;span&gt; 80&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Multiplier()
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; 
&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;百位表达式&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaiExpression : Expression
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetPostFix()
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;百&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; 
&lt;span&gt; 94&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Multiplier()
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; 
&lt;span&gt;100&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;千位表达式&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; QianExpression : Expression
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetPostFix()
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;千&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; 
&lt;span&gt;108&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Multiplier()
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; 
&lt;span&gt;114&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;万位表达式&lt;/span&gt;
&lt;span&gt;115&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WanExpression : Expression
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetPostFix()
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;万&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; 
&lt;span&gt;122&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Multiplier()
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;10000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; 
&lt;span&gt;127&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Interpreter(Context context)
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (context.Statement.Length == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; 
&lt;span&gt;134&lt;/span&gt;         ArrayList tree = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayList();
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; 
&lt;span&gt;136&lt;/span&gt;         tree.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; GeExpression());
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;         tree.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ShiExpression());
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;         tree.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BaiExpression());
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;         tree.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; QianExpression());
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; 
&lt;span&gt;141&lt;/span&gt;         &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; table.Keys)
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (context.Statement.EndsWith(GetPostFix()))
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; temp =&lt;span&gt; context.Data;
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;                 context.Data = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt; 
&lt;span&gt;148&lt;/span&gt;                 context.Statement = context.Statement.Substring(&lt;span&gt;0&lt;/span&gt;, context.Statement.Length - &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.GetLength());
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; 
&lt;span&gt;150&lt;/span&gt;                 &lt;span&gt;foreach&lt;/span&gt; (Expression exp &lt;span&gt;in&lt;/span&gt;&lt;span&gt; tree)
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt; &lt;span&gt;                    exp.Interpreter(context);
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;                 context.Data = temp + context.Data * &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Multiplier();
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt; 
&lt;span&gt;160&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;亿位表达式&lt;/span&gt;
&lt;span&gt;161&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; YiExpression : Expression
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetPostFix()
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;亿&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt; 
&lt;span&gt;168&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Multiplier()
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;100000000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt; 
&lt;span&gt;173&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Interpreter(Context context)
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt;         ArrayList tree = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayList();
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt; 
&lt;span&gt;177&lt;/span&gt;         tree.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; GeExpression());
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt;         tree.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ShiExpression());
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt;         tree.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BaiExpression());
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt;         tree.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; QianExpression());
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt; 
&lt;span&gt;182&lt;/span&gt;         &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; table.Keys)
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (context.Statement.EndsWith(GetPostFix()))
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; temp =&lt;span&gt; context.Data;
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt;                 context.Data = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt;                 context.Statement = context.Statement.Substring(&lt;span&gt;0&lt;/span&gt;, context.Statement.Length - &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.GetLength());
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt; 
&lt;span&gt;190&lt;/span&gt;                 &lt;span&gt;foreach&lt;/span&gt; (Expression exp &lt;span&gt;in&lt;/span&gt;&lt;span&gt; tree)
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt; &lt;span&gt;                    exp.Interpreter(context);
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt;                 context.Data = temp + context.Data * &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Multiplier();
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;199&lt;/span&gt; 
&lt;span&gt;200&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;环境上下文&lt;/span&gt;
&lt;span&gt;201&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Context
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _statement;
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; _data;
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt; 
&lt;span&gt;206&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Context(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; statement)
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;._statement =&lt;span&gt; statement;
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt; 
&lt;span&gt;211&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Statement
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;213&lt;/span&gt;         &lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._statement; }
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt;         &lt;span&gt;set&lt;/span&gt; { &lt;span&gt;this&lt;/span&gt;._statement =&lt;span&gt; value; }
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt; 
&lt;span&gt;217&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Data
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;219&lt;/span&gt;         &lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._data; }
&lt;/span&gt;&lt;span&gt;220&lt;/span&gt;         &lt;span&gt;set&lt;/span&gt; { &lt;span&gt;this&lt;/span&gt;._data =&lt;span&gt; value; }
&lt;/span&gt;&lt;span&gt;221&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;222&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt; 
&lt;span&gt;224&lt;/span&gt; &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt;225&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt;         &lt;span&gt;string&lt;/span&gt; roman = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;五亿七千三百零二万六千四百五十二&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;229&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;分解：((五)亿)((七千)(三百)(零)(二)万)
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;((六千)(四百)(五十)(二))&lt;/span&gt;
&lt;span&gt;231&lt;/span&gt; 
&lt;span&gt;232&lt;/span&gt;         Context context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Context(roman);
&lt;/span&gt;&lt;span&gt;233&lt;/span&gt;         List&amp;lt;Expression&amp;gt; tree = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Expression&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;234&lt;/span&gt;         tree.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; GeExpression());
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt;         tree.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ShiExpression());
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt;         tree.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BaiExpression());
&lt;/span&gt;&lt;span&gt;237&lt;/span&gt;         tree.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; QianExpression());
&lt;/span&gt;&lt;span&gt;238&lt;/span&gt;         tree.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; WanExpression());
&lt;/span&gt;&lt;span&gt;239&lt;/span&gt;         tree.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; YiExpression());
&lt;/span&gt;&lt;span&gt;240&lt;/span&gt; 
&lt;span&gt;241&lt;/span&gt;         &lt;span&gt;foreach&lt;/span&gt; (Expression exp &lt;span&gt;in&lt;/span&gt;&lt;span&gt; tree)
&lt;/span&gt;&lt;span&gt;242&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;243&lt;/span&gt; &lt;span&gt;            exp.Interpreter(context);
&lt;/span&gt;&lt;span&gt;244&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;245&lt;/span&gt; 
&lt;span&gt;246&lt;/span&gt; &lt;span&gt;        Console.Write(context.Data);
&lt;/span&gt;&lt;span&gt;247&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;248&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　看完之后是不是想骂一句fuck，我只是想要简单的转换一下，却需要写这么一大坨，显然不符合我们的心意。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解释器模式的优缺点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　优点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　1）易于改变和扩展文法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　2）每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　3）实现文法较为容易。在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　4）增加新的解释表达式较为方便。如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合“&lt;a href=&quot;https://www.cnblogs.com/az4215/p/11489712.html&quot; target=&quot;_blank&quot;&gt;开闭原则&lt;/a&gt;”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　缺点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　1）对于复杂文法难以维护。在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护，此时可以考虑使用语法分析程序等方式来取代解释器模式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　2）执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解释器模式的应用场景：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1）当一个语言需要解释执行，并可以将该语言中的句子表示为一个抽象语法树的时候，可以考虑使用解释器模式（如XML文档解释、正则表达式等领域）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2）一些重复出现的问题可以用一种简单的语言来进行表达。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3）一个语言的文法较为简单.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4）当执行效率不是关键和主要关心的问题时可考虑解释器模式（注：高效的解释器通常不是通过直接解释抽象语法树来实现的，而是需要将它们转换成其他形式，使用解释器模式的执行效率并不高。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考：&lt;a href=&quot;https://www.cnblogs.com/PatrickLiu/p/8242238.html&quot;&gt;https://www.cnblogs.com/PatrickLiu/p/8242238.html&lt;/a&gt;&lt;/span&gt; &lt;/p&gt;
</description>
<pubDate>Fri, 11 Oct 2019 00:16:00 +0000</pubDate>
<dc:creator>酷学大叔</dc:creator>
<og:description>解释器模式（Interpreter）： 从名称上来看看这个模式，个人的最初理解“解释器”和Google的中英翻译功能类似。如果有一天你去国外旅游去了，比如去美国吧，美国人是讲英语的，我们是讲汉语的，如</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/az4215/p/11648518.html</dc:identifier>
</item>
<item>
<title>如何优雅的生成接口文档？ - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/11637984.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/11637984.html</guid>
<description>&lt;p&gt;　　我们知道在项目开发阶段，接口文档基本上是必备产物了，一般由后端开发人员提供，作为和前端人员进行前后端接口联调的桥梁，或者与别的项目模块进行交互提供指导等等，接口文档的准确性，实时性，详细与否等，都会极大的影响前面的操作。那么如何才能优雅的生成接口文档呢？&lt;/p&gt;
&lt;p&gt;　　这里，我首先给出如何生成接口文档的小demo地址，在下面介绍中，有不懂的，可以参考项目注释来看。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/YSOcean/swagger-bootstrap-ui-demo.git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1、接口文档的痛点&lt;/h3&gt;
&lt;h4&gt;①、准确性&lt;/h4&gt;
&lt;p&gt;　　传统的接口文档产出，基本上是由后端人员进行手工编写，在编写文档过程中，很可能会由于人为的粗心大意，造成接口文档某个字段，或者某个接口名写错，那么这些粗心导致的错误就会影响后续的联调等操作。&lt;/p&gt;
&lt;p&gt;　　所以接口文档和实际代码的一致性是比较重要的。&lt;/p&gt;
&lt;h4&gt;②、实时性&lt;/h4&gt;
&lt;p&gt;　　在项目开发过程中，当后端人员提供了一份接口文档，并且与前端人员联调也通过了，但是由于需求变更，导致后端接口发生了变化，而后端人员有可能懒，又没有实时的去更新接口文档，那么前端人员就无法根据最新的接口文档进行修改，从而无法有效的完成整个项目的需求变更。&lt;/p&gt;
&lt;p&gt;　　所以接口文档的实时性也是很重要的。&lt;/p&gt;
&lt;h4&gt;③、详细性&lt;/h4&gt;
&lt;p&gt;　　在进行接口文档编写时，基本上都会有一个标准，包括接口名、方法类型、入参、入参类型，返回值，返回值的各种情况说明等等。一般公司都会通过接口文档规范来强制大家按照要求编写，但是理想很美好，现实很残酷。随着时间推移，项目迭代次数过多，或者项目周期赶等等因素，大家很难能够完全按照规范来编写接口文档。&lt;/p&gt;
&lt;p&gt;　　由于接口文档的不够规范，描述不够详细，对于接口文档的需求方会造成困扰。&lt;/p&gt;
&lt;p&gt;　　以上便是关于接口文档的一些痛点，可能你就会开始想，优雅的接口文档，应该满足如下特性：&lt;/p&gt;
&lt;p&gt;　　一、自动生成满足接口规范的文档&lt;/p&gt;
&lt;p&gt;　　二、能够跟随代码实时更新&lt;/p&gt;
&lt;p&gt;　　那么应该怎么办呢？&lt;/p&gt;
&lt;h3&gt;2、Swagger&lt;/h3&gt;
&lt;p&gt;　　程序员是万能的，基本上有痛点，就会有解决方案。于是 Swagger 产生了。&lt;/p&gt;
&lt;p&gt;　　简单来说，Swagger 是一套规范，只需要按照它的规范去定义接口以及接口相关信息，在通过Swagger衍生出来的一系列项目和工具，就可以做到生成各种格式的接口文档，生成多种语言的客户端和服务端的代码，以及在线接口调试页面等等。这样，如果按照新的开发模式，在开发新版本或者迭代版本的时候，只需要更新Swagger描述文件，就可以自动生成接口文档和客户端服务端代码，做到调用端代码、服务端代码以及接口文档的一致性。&lt;/p&gt;
&lt;p&gt;　　这里，我们不对 Swagger 进行过多的描述，需要了解更多的，可以参考下面的官方文档。&lt;/p&gt;
&lt;p&gt;　　Swagger 官方网站：&lt;a href=&quot;https://swagger.io/&quot; target=&quot;_blank&quot;&gt;https://swagger.io/&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;3、普通版工具-springfox-swagger-ui&lt;/h3&gt;
&lt;p&gt;　　多的不说，我们直接进入正题，如何在项目中引入swagger呢？&lt;/p&gt;
&lt;h4&gt;①、引入jar包&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&amp;lt;!-- swagger2 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${swagger.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!--swagger2-UI--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;springfox-swagger-ui&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${swagger.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　PS：这里的版本号可以参考源码pom.xml文件。或者到下面的Maven仓库中选取最新的版本。　　&lt;/p&gt;
&lt;p&gt;　　一、swagger2仓库地址：&lt;a href=&quot;https://mvnrepository.com/artifact/io.springfox/springfox-swagger2&quot; rel=&quot;nofollow&quot;&gt;https://mvnrepository.com/artifact/io.springfox/springfox-swagger2&lt;/a&gt;&lt;br/&gt;　　二、springfox-swagger-ui仓库地址：&lt;a href=&quot;https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui&quot; target=&quot;_blank&quot;&gt;https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;②、编写配置文件&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('7b3d958b-fb19-4b7e-b9ab-18b73653b5ed')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_7b3d958b-fb19-4b7e-b9ab-18b73653b5ed&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7b3d958b-fb19-4b7e-b9ab-18b73653b5ed&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('7b3d958b-fb19-4b7e-b9ab-18b73653b5ed',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7b3d958b-fb19-4b7e-b9ab-18b73653b5ed&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ys.swaggerbootstrapuidemo.common;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Value;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; springfox.documentation.builders.ApiInfoBuilder;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; springfox.documentation.builders.PathSelectors;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; springfox.documentation.builders.RequestHandlerSelectors;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; springfox.documentation.service.ApiInfo;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; springfox.documentation.service.Contact;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; springfox.documentation.spi.DocumentationType;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; springfox.documentation.spring.web.plugins.Docket;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; springfox.documentation.swagger2.annotations.EnableSwagger2;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt; * @Author: yuShuai
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt; * @Description: Swagger2的接口配置
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt; * @Date: 2019/10/8 13:41
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt; * @params:
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;@EnableSwagger2
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SwaggerConfig {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     @Value(&quot;${config.swaggerConfig.isShow}&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Boolean isShow;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Docket createUserRestApi() {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Docket(DocumentationType.SWAGGER_2)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                .enable(isShow)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用来创建该API的基本信息，展示在文档的页面中（自定义展示的信息）&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                .apiInfo(apiInfo())
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 .groupName(&quot;用户管理API&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过select()函数返回一个ApiSelectorBuilder实例,用来控制哪些接口暴露给Swagger来展现&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                .select()
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 .apis(RequestHandlerSelectors.basePackage(&quot;com.ys.swaggerbootstrapuidemo.controller.user&quot;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 扫描所有有注解的api
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;.apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 扫描指定包中的swagger注解
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;.apis(RequestHandlerSelectors.basePackage(&quot;com.kxjl.belleps.api&quot;))
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 扫描所有 .apis(RequestHandlerSelectors.any())
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对所有路径进行监控&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt; &lt;span&gt;                .paths(PathSelectors.any())
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;                .build();
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Docket createRoleRestApi() {
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Docket(DocumentationType.SWAGGER_2)
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;                .enable(isShow)
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用来创建该API的基本信息，展示在文档的页面中（自定义展示的信息）&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt; &lt;span&gt;                .apiInfo(apiInfo())
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                 .groupName(&quot;角色管理API&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过select()函数返回一个ApiSelectorBuilder实例,用来控制哪些接口暴露给Swagger来展现&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt; &lt;span&gt;                .select()
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;                 .apis(RequestHandlerSelectors.basePackage(&quot;com.ys.swaggerbootstrapuidemo.controller.role&quot;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 扫描所有有注解的api
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;.apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 扫描指定包中的swagger注解
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;.apis(RequestHandlerSelectors.basePackage(&quot;com.kxjl.belleps.api&quot;))
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 扫描所有 .apis(RequestHandlerSelectors.any())
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对所有路径进行监控&lt;/span&gt;
&lt;span&gt;67&lt;/span&gt; &lt;span&gt;                .paths(PathSelectors.any())
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;                .build();
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; 
&lt;span&gt;71&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;72&lt;/span&gt; &lt;span&gt;     * 添加摘要信息
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;74&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ApiInfo apiInfo() {
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用ApiInfoBuilder进行定制&lt;/span&gt;
&lt;span&gt;76&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ApiInfoBuilder()
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置标题&lt;/span&gt;
&lt;span&gt;78&lt;/span&gt;                 .title(&quot;标题：Swagger测试_接口文档&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 描述&lt;/span&gt;
&lt;span&gt;80&lt;/span&gt;                 .description(&quot;描述：Swagger测试相关接口信息&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 作者信息&lt;/span&gt;
&lt;span&gt;82&lt;/span&gt;                 .contact(&lt;span&gt;new&lt;/span&gt; Contact(&quot;ShuaiYu&quot;, &quot;https://www.cnblogs.com/ysocean/&quot;, &quot;1827165732@163.com&quot;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 版本&lt;/span&gt;
&lt;span&gt;84&lt;/span&gt;                 .version(&quot;版本号:&quot; + &quot;1.0&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt; &lt;span&gt;                .build();
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　PS:相关配置的意思在代码中都有标注，这里需要注意以下两点：&lt;/p&gt;
&lt;p&gt;　　一、由于swagger是用于生成API文档，那么在生成环境中是不能让别人能够访问的，需要需要配置 new Docket(DocumentationType.SWAGGER_2).enable(isShow)。&lt;/p&gt;
&lt;p&gt;　　对于isShow属性，我们可以在application.yml配置文件进行相关设定，true表示显示，false不是不展示。&lt;/p&gt;
&lt;p&gt;　　applicaion.yml 文件配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;config:
  swaggerConfig:
    #是否展示swagger,true表示展示。生产环境中需要置为false,避免暴露接口
    isShow: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　二、配置文件中，我配置了groupName()属性，这是为了在微服务模式下，模块太多，便于分类展示（具体可以看下面的截图展示）。只保留一个Docket也是可以的。 &lt;/p&gt;
&lt;h4&gt;③、访问地址&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;${host}:${port}/项目访问地址名称/swagger-ui.html&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　PS:这里的“项目访问地址名称”是你在配置文件配置了就写，没有配置，这里则没有。比如，本项目的配置文件为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server:
  port: &lt;/span&gt;8070&lt;span&gt;
  servlet:
    context&lt;/span&gt;-path: /swaggerTest
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　那么访问接口文档的路径为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8070/swaggerTest/swagger-ui.html&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;④、截图展示&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;一、初始界面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201910/1120165-20191010211822434-187064182.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;二、 配置了多个groupName()属性，展示如下&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201910/1120165-20191010211718677-254607708.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 三、接口详情&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201910/1120165-20191010211858039-1584393232.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;具体可以直接运行最前文的 github 项目，查看即可。&lt;/p&gt;
&lt;h3&gt;4、增强版工具-swagger-bootstrap-ui&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;swagger-bootstrap-ui&lt;/strong&gt; 是 &lt;strong&gt;springfox-swagger&lt;/strong&gt;&lt;code&gt; &lt;/code&gt;的增强UI实现，为Java开发者在使用Swagger的时候，能拥有一份简洁、强大的接口文档体验&lt;/p&gt;
&lt;p&gt;　　这个项目的地址：&lt;a href=&quot;https://github.com/xiaoymin/swagger-bootstrap-ui&quot; target=&quot;_blank&quot;&gt;https://github.com/xiaoymin/swagger-bootstrap-ui&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　作者对于这个项目的描述已经很清楚了。&lt;/p&gt;
&lt;h4&gt;①、用法&lt;/h4&gt;
&lt;p&gt;　　在用法上，和前面普通版工具一样，只需要将jar包 springfox-swagger-ui 替换成 swagger-bootstrap-ui 即可。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;②、访问路径&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;${host}:${port}/项目访问地址名称/doc.html&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;strong&gt;③、截图展示&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201910/1120165-20191010212830644-599648068.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;④、生成接口文档 md &lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201910/1120165-20191010212914357-1175191133.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 5、总结&lt;/h3&gt;
&lt;p&gt;　　大家在使用过程中，直接用增强版工具 &lt;strong&gt;swagger-bootstrap-ui&lt;/strong&gt;  就可以了。再次列一下我写的一个 demo 路径：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/YSOcean/swagger-bootstrap-ui-demo.git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这是一个 Springboot 项目，大家可以下载，直接运行，有不懂的欢迎留言评论。&lt;/p&gt;
</description>
<pubDate>Fri, 11 Oct 2019 00:06:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<og:description>如何优雅的生成接口文档？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ysocean/p/11637984.html</dc:identifier>
</item>
<item>
<title>1. SOFAJRaft源码分析— SOFAJRaft启动时做了什么？ - luozhiyun</title>
<link>http://www.cnblogs.com/luozhiyun/p/11651414.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luozhiyun/p/11651414.html</guid>
<description>&lt;p&gt;我们这次依然用上次的例子CounterServer来进行讲解：&lt;/p&gt;
&lt;p&gt;我这里就不贴整个代码了&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(final String[] args) throws IOException {
    if (args.length != 4) {
        System.out
            .println(&quot;Useage : java com.alipay.sofa.jraft.example.counter.CounterServer {dataPath} {groupId} {serverId} {initConf}&quot;);
        System.out
            .println(&quot;Example: java com.alipay.sofa.jraft.example.counter.CounterServer &quot; +
                    &quot;/tmp/server1 &quot; +
                    &quot;counter &quot; +
                    &quot;127.0.0.1:8081 127.0.0.1:8081,127.0.0.1:8082,127.0.0.1:8083&quot;);
        System.exit(1);
    }
    //日志存储的路径
    final String dataPath = args[0];
    //SOFAJRaft集群的名字
    final String groupId = args[1];
    //当前节点的ip和端口
    final String serverIdStr = args[2];
    //集群节点的ip和端口
    final String initConfStr = args[3];

    final NodeOptions nodeOptions = new NodeOptions();
    // 为了测试,调整 snapshot 间隔等参数
    // 设置选举超时时间为 1 秒
    nodeOptions.setElectionTimeoutMs(1000);
    // 关闭 CLI 服务。
    nodeOptions.setDisableCli(false);
    // 每隔30秒做一次 snapshot
    nodeOptions.setSnapshotIntervalSecs(30);
    // 解析参数
    final PeerId serverId = new PeerId();
    if (!serverId.parse(serverIdStr)) {
        throw new IllegalArgumentException(&quot;Fail to parse serverId:&quot; + serverIdStr);
    }
    final Configuration initConf = new Configuration();
    //将raft分组加入到Configuration的peers数组中
    if (!initConf.parse(initConfStr)) {
        throw new IllegalArgumentException(&quot;Fail to parse initConf:&quot; + initConfStr);
    }
    // 设置初始集群配置
    nodeOptions.setInitialConf(initConf);

    // 启动
    final CounterServer counterServer = new CounterServer(dataPath, groupId, serverId, nodeOptions);
    System.out.println(&quot;Started counter server at port:&quot;
                       + counterServer.getNode().getNodeId().getPeerId().getPort());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在启动server的main方法的时候会传入日志存储的路径、SOFAJRaft集群的名字、当前节点的ip和端口、集群节点的ip和端口并设值到NodeOptions中，作为当前节点启动的参数。&lt;/p&gt;
&lt;p&gt;这里会将当前节点初始化为一个PeerId对象&lt;br/&gt;&lt;strong&gt;PeerId&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//存放当前节点的ip和端口号
private Endpoint            endpoint         = new Endpoint(Utils.IP_ANY, 0);

//默认是0
private int                 idx; 
//是一个ip：端口的字符串
private String              str;
public PeerId() {
    super();
}

public boolean parse(final String s) {
    final String[] tmps = StringUtils.split(s, ':');
    if (tmps.length != 3 &amp;amp;&amp;amp; tmps.length != 2) {
        return false;
    }
    try {
        final int port = Integer.parseInt(tmps[1]);
        this.endpoint = new Endpoint(tmps[0], port);
        if (tmps.length == 3) {
            this.idx = Integer.parseInt(tmps[2]);
        } else {
            this.idx = 0;
        }
        this.str = null;
        return true;
    } catch (final Exception e) {
        LOG.error(&quot;Parse peer from string failed: {}&quot;, s, e);
        return false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PeerId的parse方法会将传入的ip：端口解析之后对变量进行一些赋值的操作。&lt;/p&gt;
&lt;p&gt;然后会调用到CounterServer的构造器中：&lt;br/&gt;&lt;strong&gt;CounterServer&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public CounterServer(final String dataPath, final String groupId, final PeerId serverId,
                     final NodeOptions nodeOptions) throws IOException {
    // 初始化路径
    FileUtils.forceMkdir(new File(dataPath));

    // 这里让 raft RPC 和业务 RPC 使用同一个 RPC server, 通常也可以分开
    final RpcServer rpcServer = new RpcServer(serverId.getPort());
    RaftRpcServerFactory.addRaftRequestProcessors(rpcServer);
    // 注册业务处理器
    rpcServer.registerUserProcessor(new GetValueRequestProcessor(this));
    rpcServer.registerUserProcessor(new IncrementAndGetRequestProcessor(this));
    // 初始化状态机
    this.fsm = new CounterStateMachine();
    // 设置状态机到启动参数
    nodeOptions.setFsm(this.fsm);
    // 设置存储路径
    // 日志, 必须
    nodeOptions.setLogUri(dataPath + File.separator + &quot;log&quot;);
    // 元信息, 必须
    nodeOptions.setRaftMetaUri(dataPath + File.separator + &quot;raft_meta&quot;);
    // snapshot, 可选, 一般都推荐
    nodeOptions.setSnapshotUri(dataPath + File.separator + &quot;snapshot&quot;);
    // 初始化 raft group 服务框架
    this.raftGroupService = new RaftGroupService(groupId, serverId, nodeOptions, rpcServer);
    // 启动
    this.node = this.raftGroupService.start();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法主要是调用NodeOptions的各种方法进行设置，然后调用raftGroupService的start方法启动raft节点。&lt;/p&gt;
&lt;h3 id=&quot;raftgroupservice&quot;&gt;RaftGroupService&lt;/h3&gt;
&lt;p&gt;我们来到RaftGroupService的start方法：&lt;br/&gt;&lt;strong&gt;RaftGroupService#start&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public synchronized Node start(final boolean startRpcServer) {
    //如果已经启动了，那么就返回
    if (this.started) {
        return this.node;
    }
    //校验serverId和groupId
    if (this.serverId == null || this.serverId.getEndpoint() == null
            || this.serverId.getEndpoint().equals(new Endpoint(Utils.IP_ANY, 0))) {
        throw new IllegalArgumentException(&quot;Blank serverId:&quot; + this.serverId);
    }
    if (StringUtils.isBlank(this.groupId)) {
        throw new IllegalArgumentException(&quot;Blank group id&quot; + this.groupId);
    }
    //Adds RPC server to Server.
    //设置当前node的ip和端口
    NodeManager.getInstance().addAddress(this.serverId.getEndpoint());

    //创建node
    this.node = RaftServiceFactory.createAndInitRaftNode(this.groupId, this.serverId, this.nodeOptions);
    if (startRpcServer) {
        //启动远程服务
        this.rpcServer.start();
    } else {
        LOG.warn(&quot;RPC server is not started in RaftGroupService.&quot;);
    }
    this.started = true;
    LOG.info(&quot;Start the RaftGroupService successfully.&quot;);
    return this.node;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法会在一开始的时候对RaftGroupService在构造器实例化的参数进行校验，然后把当前节点的Endpoint添加到NodeManager的addrSet变量中，接着调用RaftServiceFactory#createAndInitRaftNode实例化Node节点。&lt;/p&gt;
&lt;p&gt;每个节点都会启动一个rpc的服务，因为每个节点既可以被选举也可以投票给其他节点，节点之间需要互相通信，所以需要启动一个rpc服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RaftServiceFactory#createAndInitRaftNode&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static Node createAndInitRaftNode(final String groupId, final PeerId serverId, final NodeOptions opts) {
    //实例化一个node节点
    final Node ret = createRaftNode(groupId, serverId);
    //为node节点初始化
    if (!ret.init(opts)) {
        throw new IllegalStateException(&quot;Fail to init node, please see the logs to find the reason.&quot;);
    }
    return ret;
}

public static Node createRaftNode(final String groupId, final PeerId serverId) {
    return new NodeImpl(groupId, serverId);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;createAndInitRaftNode方法首先调用createRaftNode实例化一个Node的实例NodeImpl，然后调用其init方法进行初始化，主要的配置都是在init方法中完成的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NodeImpl&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public NodeImpl(final String groupId, final PeerId serverId) {
    super();
    if (groupId != null) {
        //检验groupId是否符合格式规范
        Utils.verifyGroupId(groupId);
    }
    this.groupId = groupId;
    this.serverId = serverId != null ? serverId.copy() : null;
    //一开始的设置为未初始化
    this.state = State.STATE_UNINITIALIZED;
    //设置新的任期为0
    this.currTerm = 0;
    //设置最新的时间戳
    updateLastLeaderTimestamp(Utils.monotonicMs());
    this.confCtx = new ConfigurationCtx(this);
    this.wakingCandidate = null; 
    final int num = GLOBAL_NUM_NODES.incrementAndGet();
    LOG.info(&quot;The number of active nodes increment to {}.&quot;, num);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;NodeImpl会在构造器中初始化一些参数。&lt;/p&gt;
&lt;h3 id=&quot;node的初始化&quot;&gt;Node的初始化&lt;/h3&gt;
&lt;p&gt;Node节点的所有的重要的配置都是在init方法中完成的，NodeImpl的init方法比较长所以分成代码块来进行讲解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NodeImpl#init&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//非空校验
Requires.requireNonNull(opts, &quot;Null node options&quot;);
Requires.requireNonNull(opts.getRaftOptions(), &quot;Null raft options&quot;);
Requires.requireNonNull(opts.getServiceFactory(), &quot;Null jraft service factory&quot;);
//目前就一个实现：DefaultJRaftServiceFactory
this.serviceFactory = opts.getServiceFactory();
this.options = opts;
this.raftOptions = opts.getRaftOptions();
//基于 Metrics 类库的性能指标统计，具有丰富的性能统计指标，默认不开启度量工具
this.metrics = new NodeMetrics(opts.isEnableMetrics());

if (this.serverId.getIp().equals(Utils.IP_ANY)) {
    LOG.error(&quot;Node can't started from IP_ANY.&quot;);
    return false;
}

if (!NodeManager.getInstance().serverExists(this.serverId.getEndpoint())) {
    LOG.error(&quot;No RPC server attached to, did you forget to call addService?&quot;);
    return false;
}
//定时任务管理器
this.timerManager = new TimerManager();
//初始化定时任务管理器的内置线程池
if (!this.timerManager.init(this.options.getTimerPoolSize())) {
    LOG.error(&quot;Fail to init timer manager.&quot;);
    return false;
}

//定时任务管理器
this.timerManager = new TimerManager();
//初始化定时任务管理器的内置线程池
if (!this.timerManager.init(this.options.getTimerPoolSize())) {
    LOG.error(&quot;Fail to init timer manager.&quot;);
    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码主要是给各个变量赋值，然后进行校验判断一下serverId不能为0.0.0.0，当前的Endpoint必须要在NodeManager里面设置过等等（NodeManager的设置是在RaftGroupService的start方法里）。&lt;/p&gt;
&lt;p&gt;然后会初始化一个全局的的定时调度管理器TimerManager：&lt;br/&gt;&lt;strong&gt;TimerManager&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private ScheduledExecutorService executor;

@Override
public boolean init(Integer coreSize) {
    this.executor = Executors.newScheduledThreadPool(coreSize, new NamedThreadFactory(
        &quot;JRaft-Node-ScheduleThreadPool-&quot;, true));
    return true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;TimerManager的init方法就是初始化一个线程池，如果当前的服务器的cpu线程数&lt;em&gt;3 大于20 ，那么这个线程池的coreSize就是20，否则就是cpu线程数&lt;/em&gt;3。&lt;/p&gt;
&lt;p&gt;往下走是计时器的初始化：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// Init timers
//设置投票计时器
this.voteTimer = new RepeatedTimer(&quot;JRaft-VoteTimer&quot;, this.options.getElectionTimeoutMs()) {

    @Override
    protected void onTrigger() {
        //处理投票超时
        handleVoteTimeout();
    }

    @Override
    protected int adjustTimeout(final int timeoutMs) {
        //在一定范围内返回一个随机的时间戳
        return randomTimeout(timeoutMs);
    }
};
//设置预投票计时器
//当leader在规定的一段时间内没有与 Follower 舰船进行通信时，
// Follower 就可以认为leader已经不能正常担任旗舰的职责，则 Follower 可以去尝试接替leader的角色。
// 这段通信超时被称为 Election Timeout
//候选者在发起投票之前，先发起预投票
this.electionTimer = new RepeatedTimer(&quot;JRaft-ElectionTimer&quot;, this.options.getElectionTimeoutMs()) {

    @Override
    protected void onTrigger() {
        handleElectionTimeout();
    }

    @Override
    protected int adjustTimeout(final int timeoutMs) {
        //在一定范围内返回一个随机的时间戳
        //为了避免同时发起选举而导致失败
        return randomTimeout(timeoutMs);
    }
};
//leader下台的计时器
//定时检查是否需要重新选举leader
this.stepDownTimer = new RepeatedTimer(&quot;JRaft-StepDownTimer&quot;, this.options.getElectionTimeoutMs() &amp;gt;&amp;gt; 1) {

    @Override
    protected void onTrigger() {
        handleStepDownTimeout();
    }
};
//快照计时器
this.snapshotTimer = new RepeatedTimer(&quot;JRaft-SnapshotTimer&quot;, this.options.getSnapshotIntervalSecs() * 1000) {

    @Override
    protected void onTrigger() {
        handleSnapshotTimeout();
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;voteTimer是用来控制选举的，如果选举超时，当前的节点又是候选者角色，那么就会发起选举。&lt;br/&gt;electionTimer是预投票计时器。候选者在发起投票之前，先发起预投票，如果没有得到半数以上节点的反馈，则候选者就会识趣的放弃参选。&lt;br/&gt;stepDownTimer定时检查是否需要重新选举leader。当前的leader可能出现它的Follower可能并没有整个集群的1/2却还没有下台的情况，那么这个时候会定期的检查看leader的Follower是否有那么多，没有那么多的话会强制让leader下台。&lt;br/&gt;snapshotTimer快照计时器。这个计时器会每隔1小时触发一次生成一个快照。&lt;/p&gt;
&lt;p&gt;这些计时器的具体实现现在暂时不表，等到要讲具体功能的时候再进行梳理。&lt;/p&gt;
&lt;p&gt;这些计时器有一个共同的特点就是会根据不同的计时器返回一个在一定范围内随机的时间。返回一个随机的时间可以防止多个节点在同一时间内同时发起投票选举从而降低选举失败的概率。&lt;/p&gt;
&lt;p&gt;继续往下看：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;this.configManager = new ConfigurationManager();
//初始化一个disruptor，采用多生产者模式
this.applyDisruptor = DisruptorBuilder.&amp;lt;LogEntryAndClosure&amp;gt;newInstance() //
        //设置disruptor大小，默认16384
        .setRingBufferSize(this.raftOptions.getDisruptorBufferSize()) //
        .setEventFactory(new LogEntryAndClosureFactory()) //
        .setThreadFactory(new NamedThreadFactory(&quot;JRaft-NodeImpl-Disruptor-&quot;, true)) //
        .setProducerType(ProducerType.MULTI) //
        .setWaitStrategy(new BlockingWaitStrategy()) //
        .build();
//设置事件处理器
this.applyDisruptor.handleEventsWith(new LogEntryAndClosureHandler());
//设置异常处理器
this.applyDisruptor.setDefaultExceptionHandler(new LogExceptionHandler&amp;lt;Object&amp;gt;(getClass().getSimpleName()));
// 启动disruptor的线程
this.applyQueue = this.applyDisruptor.start();
//如果开启了metrics统计
if (this.metrics.getMetricRegistry() != null) {
    this.metrics.getMetricRegistry().register(&quot;jraft-node-impl-disruptor&quot;,
            new DisruptorMetricSet(this.applyQueue));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里初始化了一个Disruptor作为消费队列，不清楚Disruptor的朋友可以去看我上一篇文章：&lt;a href=&quot;https://www.cnblogs.com/luozhiyun/p/11631305.html&quot;&gt;Disruptor—核心概念及体验&lt;/a&gt;。然后还校验了metrics是否开启，默认是不开启的。&lt;/p&gt;
&lt;p&gt;继续往下看：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//fsmCaller封装对业务 StateMachine 的状态转换的调用以及日志的写入等
this.fsmCaller = new FSMCallerImpl();
//初始化日志存储功能
if (!initLogStorage()) {
    LOG.error(&quot;Node {} initLogStorage failed.&quot;, getNodeId());
    return false;
}
//初始化元数据存储功能
if (!initMetaStorage()) {
    LOG.error(&quot;Node {} initMetaStorage failed.&quot;, getNodeId());
    return false;
}
//对FSMCaller初始化
if (!initFSMCaller(new LogId(0, 0))) {
    LOG.error(&quot;Node {} initFSMCaller failed.&quot;, getNodeId());
    return false;
}
//实例化投票箱
this.ballotBox = new BallotBox();
final BallotBoxOptions ballotBoxOpts = new BallotBoxOptions();
ballotBoxOpts.setWaiter(this.fsmCaller);
ballotBoxOpts.setClosureQueue(this.closureQueue);
//初始化ballotBox的属性
if (!this.ballotBox.init(ballotBoxOpts)) {
    LOG.error(&quot;Node {} init ballotBox failed.&quot;, getNodeId());
    return false;
}
//初始化快照存储功能
if (!initSnapshotStorage()) {
    LOG.error(&quot;Node {} initSnapshotStorage failed.&quot;, getNodeId());
    return false;
}
//校验日志文件索引的一致性
final Status st = this.logManager.checkConsistency();
if (!st.isOk()) {
    LOG.error(&quot;Node {} is initialized with inconsistent log, status={}.&quot;, getNodeId(), st);
    return false;
}
//配置管理raft group中的信息
this.conf = new ConfigurationEntry();
this.conf.setId(new LogId());
// if have log using conf in log, else using conf in options
if (this.logManager.getLastLogIndex() &amp;gt; 0) {
    this.conf = this.logManager.checkAndSetConfiguration(this.conf);
} else {
    this.conf.setConf(this.options.getInitialConf());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码主要是对快照、日志、元数据等功能初始化。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;this.replicatorGroup = new ReplicatorGroupImpl();
//收其他节点或者客户端发过来的请求，转交给对应服务处理
this.rpcService = new BoltRaftClientService(this.replicatorGroup);
final ReplicatorGroupOptions rgOpts = new ReplicatorGroupOptions();
rgOpts.setHeartbeatTimeoutMs(heartbeatTimeout(this.options.getElectionTimeoutMs()));
rgOpts.setElectionTimeoutMs(this.options.getElectionTimeoutMs());
rgOpts.setLogManager(this.logManager);
rgOpts.setBallotBox(this.ballotBox);
rgOpts.setNode(this);
rgOpts.setRaftRpcClientService(this.rpcService);
rgOpts.setSnapshotStorage(this.snapshotExecutor != null ? this.snapshotExecutor.getSnapshotStorage() : null);
rgOpts.setRaftOptions(this.raftOptions);
rgOpts.setTimerManager(this.timerManager);

// Adds metric registry to RPC service.
this.options.setMetricRegistry(this.metrics.getMetricRegistry());
//初始化rpc服务
if (!this.rpcService.init(this.options)) {
    LOG.error(&quot;Fail to init rpc service.&quot;);
    return false;
}
this.replicatorGroup.init(new NodeId(this.groupId, this.serverId), rgOpts);

this.readOnlyService = new ReadOnlyServiceImpl();
final ReadOnlyServiceOptions rosOpts = new ReadOnlyServiceOptions();
rosOpts.setFsmCaller(this.fsmCaller);
rosOpts.setNode(this);
rosOpts.setRaftOptions(this.raftOptions);
//只读服务初始化
if (!this.readOnlyService.init(rosOpts)) {
    LOG.error(&quot;Fail to init readOnlyService.&quot;);
    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码主要是初始化replicatorGroup、rpcService以及readOnlyService。&lt;/p&gt;
&lt;p&gt;接下来是最后一段的代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// set state to follower
this.state = State.STATE_FOLLOWER;

if (LOG.isInfoEnabled()) {
    LOG.info(&quot;Node {} init, term={}, lastLogId={}, conf={}, oldConf={}.&quot;, getNodeId(), this.currTerm,
            this.logManager.getLastLogId(false), this.conf.getConf(), this.conf.getOldConf());
}

//如果快照执行器不为空，并且生成快照的时间间隔大于0，那么就定时生成快照
if (this.snapshotExecutor != null &amp;amp;&amp;amp; this.options.getSnapshotIntervalSecs() &amp;gt; 0) {
    LOG.debug(&quot;Node {} start snapshot timer, term={}.&quot;, getNodeId(), this.currTerm);
    this.snapshotTimer.start();
}

if (!this.conf.isEmpty()) {
    //新启动的node需要重新选举
    stepDown(this.currTerm, false, new Status());
}

if (!NodeManager.getInstance().add(this)) {
    LOG.error(&quot;NodeManager add {} failed.&quot;, getNodeId());
    return false;
}

// Now the raft node is started , have to acquire the writeLock to avoid race
// conditions
this.writeLock.lock();
//这个分支表示当前的jraft集群里只有一个节点，那么个节点必定是leader直接进行选举就好了
if (this.conf.isStable() &amp;amp;&amp;amp; this.conf.getConf().size() == 1 &amp;amp;&amp;amp; this.conf.getConf().contains(this.serverId)) {
    // The group contains only this server which must be the LEADER, trigger
    // the timer immediately.
    electSelf();
} else {
    this.writeLock.unlock();
}

return true;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码里会将当前的状态设置为Follower，然后启动快照定时器定时生成快照。&lt;br/&gt;如果当前的集群不是单节点集群需要做一下stepDown，表示新生成的Node节点需要重新进行选举。&lt;br/&gt;最下面有一个if分支，如果当前的jraft集群里只有一个节点，那么个节点必定是leader直接进行选举就好了，所以会直接调用electSelf进行选举。&lt;br/&gt;选举的代码我们就暂时略过，要不然后面就没得讲了。&lt;/p&gt;
&lt;p&gt;到这里整个NodeImpl实例的init方法就分析完了，这个方法很长，但是还是做了很多事情的。&lt;/p&gt;
&lt;p&gt;好了，今天也不早了，各位晚安~&lt;/p&gt;
</description>
<pubDate>Thu, 10 Oct 2019 15:45:00 +0000</pubDate>
<dc:creator>luozhiyun</dc:creator>
<og:description>我们这次依然用上次的例子CounterServer来进行讲解： 我这里就不贴整个代码了 我们在启动server的main方法的时候会传入日志存储的路径、SOFAJRaft集群的名字、当前节点的ip和端</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/luozhiyun/p/11651414.html</dc:identifier>
</item>
<item>
<title>死磕 java线程系列之自己动手写一个线程池（续） - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/11651370.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/11651370.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201910/1648938-20191010233255759-1031137370.png&quot; alt=&quot;mythreadpool&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（手机横屏看源码更方便）&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;（1）自己动手写的线程池如何支持带返回值的任务呢？&lt;/p&gt;
&lt;p&gt;（2）如果任务执行的过程中抛出异常了该怎么处理呢？&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;上一章我们自己动手写了一个线程池，但是它是不支持带返回值的任务的，那么，我们自己能否实现呢？必须可以，今天我们就一起来实现带返回值任务的线程池。&lt;/p&gt;
&lt;h2 id=&quot;前情回顾&quot;&gt;前情回顾&lt;/h2&gt;
&lt;p&gt;首先，让我们先回顾一下上一章写的线程池：&lt;/p&gt;
&lt;p&gt;（1）它包含四个要素：核心线程数、最大线程数、任务队列、拒绝策略；&lt;/p&gt;
&lt;p&gt;（2）它具有执行无返回值任务的能力；&lt;/p&gt;
&lt;p&gt;（3）它无法处理有返回值的任务；&lt;/p&gt;
&lt;p&gt;（4）它无法处理任务执行的异常（线程中的异常不会抛出到线程外）；&lt;/p&gt;
&lt;p&gt;那么，我们能不能在现有的基础上实现其下面两项能力呢？让我们一起来试一试吧！&lt;/p&gt;
&lt;h2 id=&quot;有返回值和无返回值的任务到底有何不同&quot;&gt;有返回值和无返回值的任务到底有何不同？&lt;/h2&gt;
&lt;p&gt;答案很明显，就是一个有返回值，一个无返回值，用伪代码来表示就是下面这样：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    // 无返回值
    threadPool.execute(()-&amp;gt;{
        System.out.println(1);
    });
    // 有返回值，分两步走
    // 1. 提交任务到线程池中
    SomeClass result = threadPool.execute(()-&amp;gt;{
        System.out.println(1);
        return 1;
    });
    // 2. 等待任务的结果返回
    Object value = result.get();
    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;无返回值的任务提交了就完事，主线程并不Care它到底有没有执行完，并不关心它是不是抛出异常，主线程Just提交线程到线程池中，其余什么都不管。&lt;/p&gt;
&lt;p&gt;有返回值的任务就不一样了，主线程首先要提交任务到线程池中，它需要使用到任务执行的结果，所以它必须等待任务执行完毕才能拿到任务执行的结果。&lt;/p&gt;
&lt;p&gt;那么，为什么不直接在execute的时候就等待任务执行完毕呢？这样的话那不就跟串行没啥区别了，还不如直接在主线程执行任务呢，还少了线程切换的资源消耗。&lt;/p&gt;
&lt;p&gt;之所以要分成两步，是因为主线程并不一定需要立即获取返回值，在需要用到返回值的时候才去get，这样就可以在提交任务和获取返回值之间干些其它的事情，提高效率。&lt;/p&gt;
&lt;p&gt;所以，提交任务的时候不需要阻塞，get返回值的时候才可能需要阻塞，如果get的时候任务已经执行完毕了，这时候也不需要阻塞，如果get的时候任务还未执行完毕，那就要阻塞等待任务执行完毕才能获取到返回值。&lt;/p&gt;
&lt;h2 id=&quot;实现分析&quot;&gt;实现分析&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;首先&lt;/strong&gt;，无返回值的任务我们直接使用的Runnable函数式接口，有返回值的任务有没有现成的接口呢？还真有，那就是Callable接口，它有个返回值。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@FunctionalInterface
public interface Callable&amp;lt;V&amp;gt; {
    V call() throws Exception;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;其次&lt;/strong&gt;，提交任务的时候需要有个返回值，它是在将来用来获取任务执行结果的，实际上它也是新任务的一种能力，可以使用它对任务进行包装，使其具有返回值的能力。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Future&amp;lt;T&amp;gt; {
    T get();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;再次&lt;/strong&gt;，我们需要给现有的线程池增加一种新的能力，根据单一职责原则，我们定义一个新的接口来承载这种能力。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface FutureExecutor extends Executor {
    &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; command);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;然后&lt;/strong&gt;，我们需要一种新的任务，它既具有旧任务的执行能力（run()方法），又具有新任务的返回值能力（get()方法），所以我们造一个“将来的任务”对提交的任务进行包装，使其具有返回值的能力。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class FutureTask&amp;lt;T&amp;gt; implements Runnable, Future&amp;lt;T&amp;gt; {

    /**
     * 真正的任务
     */
    private Callable&amp;lt;T&amp;gt; task;
    
    public FutureTask(Callable&amp;lt;T&amp;gt; task) {
        this.task = task;
    }

    @Override
    public void run() {
        // 具体实现...
    }

    @Override
    public T get() {
        // 具体实现...
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;最后&lt;/strong&gt;，我们只要对原有的线程池进行扩展，将提交的任务包装成“将来获取返回值的任务”，还是使用原来的方法去执行，然后返回这个将来的任务即可。&lt;/p&gt;
&lt;p&gt;根据开闭原则，【本篇文章由公众号“彤哥读源码”原创】原来的代码我们不做任何修改，扩展新的子类来实现新的能力。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyThreadPoolFutureExecutor extends MyThreadPoolExecutor implements FutureExecutor, Executor {

    public MyThreadPoolFutureExecutor(String name, int coreSize, int maxSize, BlockingQueue&amp;lt;Runnable&amp;gt; taskQueue, RejectPolicy rejectPolicy) {
        super(name, coreSize, maxSize, taskQueue, rejectPolicy);
    }

    @Override
    public &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task) {
        // 包装成将来获取返回值的任务
        FutureTask&amp;lt;T&amp;gt; futureTask = new FutureTask&amp;lt;&amp;gt;(task);
        // 还是使用原来的执行能力
        execute(futureTask);
        // 返回将来的任务，只需要返回其get返回值的能力即可
        // 所以这里返回的是Future而不是FutureTask类型
        return futureTask;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，到这里整体的逻辑我们就已经比较清晰地实现完了，还剩下最关键的部分，这个“将来的任务”的两个能力要如何实现。&lt;/p&gt;
&lt;h2 id=&quot;将来的任务&quot;&gt;将来的任务&lt;/h2&gt;
&lt;p&gt;将来的任务，具有两个能力：一是执行真正任务的能力，二是将来获取返回值的能力。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class FutureTask&amp;lt;T&amp;gt; implements Runnable, Future&amp;lt;T&amp;gt; {
    @Override
    public void run() {
        // 具体实现...
    }

    @Override
    public T get() {
        // 具体实现...
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;首先&lt;/strong&gt;，我们要明确一件事，任务的执行是线程池中，获取返回值是在主线程中，它们是在两个线程中执行的，而且谁先谁后我们无法确定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其次&lt;/strong&gt;，如果run()在get()之前执行，我们需要告诉get()任务已经执行完毕了，所以需要一个状态来通知这个事，还需要一个变量来承载任务执行的返回值。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * 任务执行的状态，0未开始，1正常完成，2异常完成
     * 也可以使用volatile+Unsafe实现CAS操作
     */
    private AtomicInteger state = new AtomicInteger(NEW);
    private static final int NEW = 0;
    private static final int FINISHED = 1;
    private static final int EXCEPTION = 2;
    /**
     * 任务执行的结果【本篇文章由公众号“彤哥读源码”原创】
     * 如果执行正常，返回结果为T
     * 如果执行异常，返回结果为Exception
     */
    private Object result;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;再次&lt;/strong&gt;，如果get()在run()之前执行，那就需要阻塞等待run()执行完毕才能拿到返回值，所以需要保存调用者（主线程），get()的时候park阻塞住，run()完成了unpark唤醒它来拿返回值。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * 调用者线程
     * 也可以使用volatile+Unsafe实现CAS操作
     */
    private AtomicReference&amp;lt;Thread&amp;gt; caller = new AtomicReference&amp;lt;&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;然后&lt;/strong&gt;，我们先来看看run()方法的逻辑，它其实就是先执行真正的任务，然后修改状态为完成，并保存任务的返回值，如果保存了主线程，还要唤醒它。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    public void run() {
        // 如果状态不是NEW，说明执行过了，直接返回
        if (state.get() != NEW) {
            return;
        }
        try {
            // 执行任务【本篇文章由公众号“彤哥读源码”原创】
            T r = task.call();
            // CAS更新state的值为FINISHED
            // 如果更新成功，就把r赋值给result
            // 如果更新失败，说明state的值不为NEW了，也就是任务已经执行过了
            if (state.compareAndSet(NEW, FINISHED)) {
                this.result = r;
                // finish()必须放在修改state里面，见下面的分析
                finish();
            }
        } catch (Exception e) {
            // 如果CAS更新state的值为EXCEPTION成功，就把e赋值给result
            // 如果CAS更新失败，说明state的值不为NEW了，也就是任务已经执行过了
            if (state.compareAndSet(NEW, EXCEPTION)) {
                this.result = e;
                // finish()必须放在修改state里面，见下面的分析
                finish();
            }
        }
    }

    private void finish() {
        // 检查调用者是否为空，如果不为空，唤醒它
        // 调用者在调用get()方法的进入阻塞状态
        for (Thread c; (c = caller.get()) != null;) {
            if (caller.compareAndSet(c, null)) {
                LockSupport.unpark(c);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;最后&lt;/strong&gt;，我们再看看get()方法，如果任务还未执行，就阻塞等待任务的执行；如果任务已经执行完毕了，直接拿返回值即可；但是，还有一种情况，get()方法执行的过程中run()方法也在执行，所以get()方法中的每一步都要检查状态的值有没有变化。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
    public T get() {
        int s = state.get();
        // 如果任务还未执行完成，判断当前线程是否要进入阻塞状态
        if (s == NEW) {
            // 标识调用者线程是否被标记过
            boolean marked = false;
            for (;;) {
                // 重新获取state的值
                s = state.get();
                // 如果state大于NEW说明完成了，跳出循环
                if (s &amp;gt; NEW) {
                    break;
                    // 此处必须把caller的CAS更新和park()方法分成两步处理，不能把park()放在CAS里面
                } else if (!marked) {
                    // 尝试更新调用者线程
                    // 试想断点停在此处【本篇文章由公众号“彤哥读源码”原创】
                    // 此时state为NEW，让run()方法执行到底，它不会执行finish()中的unpark()方法
                    // 这时打开断点，这里会更新caller成功，但是循环从头再执行一遍发现state已经变了，
                    // 直接在上面的if(s&amp;gt;NEW)处跳出循环了，因为finish()在修改state内部
                    marked = caller.compareAndSet(null, Thread.currentThread());
                } else {
                    // 调用者线程更新之后park当前线程
                    // 试想断点停在此处
                    // 此时state为NEW，让run()方法执行到底，因为上面的caller已经设置值了，
                    // 所以会执行finish()方法中的unpark()方法，
                    // 这时再打开断点，这里不会park信
                    // 见unpark()方法的注释，上面写得很清楚：
                    // 如果线程执行了park()方法，那么执行unpark()方法会唤醒那个线程
                    // 如果先执行了unpark()方法，那么线程下一次执行park()方法将不会阻塞
                    LockSupport.park();
                }
            }
        }

        if (s == FINISHED) {
            return (T) result;
        }
        throw new RuntimeException((Throwable) result);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;在我们的实现中&lt;/strong&gt;，如果任务执行的过程抛出异常了，也是通过result返回给主线程，这样主线程就拿到了这个异常，它就可以做相应的处理了。&lt;/p&gt;
&lt;p&gt;好了，完整的实现到此结束，不知道你领悟了没有。&lt;/p&gt;
&lt;h2 id=&quot;测试用例&quot;&gt;测试用例&lt;/h2&gt;
&lt;p&gt;最后奉上测试代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyThreadPoolFutureExecutorTest {
    public static void main(String[] args) {
        FutureExecutor threadPool = new MyThreadPoolFutureExecutor(&quot;test&quot;, 2, 4, new ArrayBlockingQueue&amp;lt;&amp;gt;(6), new DiscardRejectPolicy());
        List&amp;lt;Future&amp;lt;Integer&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; 100; i++) {
            int num = i;
            Future&amp;lt;Integer&amp;gt; future = threadPool.submit(() -&amp;gt; {
                Thread.sleep(1000);
                System.out.println(&quot;running: &quot; + num);
                return num;
            });
            list.add(future);
        }

        for (Future&amp;lt;Integer&amp;gt; future : list) {
            System.out.println(&quot;runned: &quot; + future.get());
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;thread name: core_test2
thread name: test4
thread name: test3
discard one task
thread name: core_test1
discard one task
...省略被拒绝的任务
【本篇文章由公众号“彤哥读源码”原创】
discard one task
running: 0
running: 1
running: 8
running: 9
runned: 0
runned: 1
running: 4
running: 2
running: 3
running: 5
runned: 2
runned: 3
runned: 4
runned: 5
running: 6
running: 7
runned: 6
runned: 7
runned: 8
runned: 9
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;（1）有返回值的任务是通过包装成将来的任务来实现的，这个任务既具有基本的执行能力，又具有将来获取返回值的能力；&lt;/p&gt;
&lt;p&gt;（2）任务执行的异常跟任务正常的返回值是通过同一个返回值返回到主线程的，主线程根据状态判断是异常还是正常值；&lt;/p&gt;
&lt;p&gt;（3）我们的实现中运用了单一职责原则、开闭原则等设计原则，对原有代码没有造成任何的入侵；&lt;/p&gt;
&lt;h2 id=&quot;彩蛋&quot;&gt;彩蛋&lt;/h2&gt;
&lt;p&gt;手写线程池目前只打算写这两章，后面开始进入jdk原生线程池的源码分析，敬请期待。&lt;/p&gt;
&lt;p&gt;另外，需要手写线程池&lt;strong&gt;完整源码&lt;/strong&gt;的同学请关注我的公众号“彤哥读源码”，在后台回复“&lt;strong&gt;MyThreadPool&lt;/strong&gt;”（不带引号）即可领取手写线程池完整源码，注意大小写不要弄错哦，否则彤哥是不会给你的哈。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;欢迎关注我的公众号“彤哥读源码”，查看更多源码系列文章, 与彤哥一起畅游源码的海洋。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201910/1648938-20191010233255960-671622575.jpg&quot; alt=&quot;qrcode&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 10 Oct 2019 15:33:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>（手机横屏看源码更方便） 问题 （1）自己动手写的线程池如何支持带返回值的任务呢？ （2）如果任务执行的过程中抛出异常了该怎么处理呢？ 简介 上一章我们自己动手写了一个线程池，但是它是不支持带返回值的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tong-yuan/p/11651370.html</dc:identifier>
</item>
<item>
<title>线程的来龙去脉，你了解吗？ - tobe的呓语</title>
<link>http://www.cnblogs.com/tobe98/p/11651237.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tobe98/p/11651237.html</guid>
<description>&lt;p&gt;进程最近有些烦恼，整日愁眉苦脸的，拜访内存的时候也有点心不在焉。&lt;/p&gt;
&lt;p&gt;内存是个明眼人，开门见山的问道：“进程啊，最近遇到啥问题了？我看你最近情绪有点低落，有啥问题你就直接说出来嘛，我让大家伙儿来一起帮你想想办法。”&lt;/p&gt;
&lt;p&gt;进程叹了口气，说道：“唉，最近不是说 CPU 单核频率到瓶颈了吗？人类就用多核芯来弥补单核处理器性能的不足，咱们的 CPU 不也升级到四核了嘛。”&lt;/p&gt;
&lt;p&gt;“是啊，这是好事啊，现在最多能&lt;strong&gt;并行&lt;/strong&gt;处理 4 个进程，效率比以前高多了，这还不好吗？”内存疑惑的问。&lt;/p&gt;
&lt;p&gt;“好是好，可我每次上 CPU 运行的时候，都忍不住去想，要是单核频率不增加，我总的运行的时间不还是没有什么变化吗？以后的应用程序越来越大，越来越吃 CPU 资源，比如那些大型游戏进程，在&lt;strong&gt;短时间内需要进行大量计算&lt;/strong&gt;，靠单核撑不住怎么办。不谈以后，就说说我自己，我也想能够早点运行完，早点休息啊。”&lt;/p&gt;
&lt;p&gt;&lt;em&gt;tobe 注：很明显单进程的运行时间是变小了的，不过这里主要强调的是进程占用 CPU 的时间。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;内存点点头，赞同道：“这个问题我倒是没想到，多核处理器对单个进程确实不大友好。那咱得想办法让你能够同时使用几个核心。不过我一时间也想不到什么好办法，还是和大家一起讨论下吧。”&lt;/p&gt;
&lt;p&gt;在讨论会上，内存向大家说明了进程现在遇到的问题。&lt;/p&gt;
&lt;p&gt;“一个进程怎么&lt;strong&gt;并行&lt;/strong&gt;？”进程调度器第一个发出疑问：“我总不能把一个进程放在四个核上吧，这样不仅毫无意义，还阻碍了其他进程的执行。”&lt;/p&gt;
&lt;p&gt;操作系统见多识广，说：“把进程一次放在几个核上运行肯定是不可能的，我在想，咱们的目标，其实就是让多个核心&lt;strong&gt;不冲突&lt;/strong&gt;地帮助一个进程运行嘛。那我们就得把进程「拆开」，然后放在几个核上。”&lt;/p&gt;
&lt;p&gt;操作系统一边说，一边画了张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1780031/201910/1780031-20191010230228749-973898050.jpg&quot; alt=&quot;进程拆分&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“你们看，假如说 fun1 和 fun2 这两个函数互不关联，我们就可以让两个核同时执行他们，这不就做到并行了吗？”&lt;/p&gt;
&lt;p&gt;“你的意思是说把一个进程拆成好几个进程？”&lt;/p&gt;
&lt;p&gt;操作系统摇摇头：“不是拆成多个进程，进程切换的代价太大了，再说了，这些拆出来的函数，他们是&lt;strong&gt;共用一个地址空间&lt;/strong&gt;的，天生就能够&lt;strong&gt;数据共享&lt;/strong&gt;，如果拆成进程，我们还得再考虑进程之间的&lt;strong&gt;通信&lt;/strong&gt;问题，那多麻烦。不过为了跟进程区分，就叫他们「&lt;strong&gt;线程&lt;/strong&gt;（Thread）」吧”&lt;/p&gt;
&lt;p&gt;进程一惊，要把自己拆成线程？那自己不就没了？赶忙问道：“那我岂不是没有存在的余地了？”&lt;/p&gt;
&lt;p&gt;进程调度器也慌了：“要是没了进程，我是不是也要被退休了？”&lt;/p&gt;
&lt;p&gt;操作系统赶忙解释道：你们误会了，我要拆开的，是进程的&lt;strong&gt;执行流&lt;/strong&gt;，进程不是包含了&lt;strong&gt;资源所有权&lt;/strong&gt;和&lt;strong&gt;执行流&lt;/strong&gt;吗，资源所有权还是由进程来把控，执行流就分给几个线程，就像这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1780031/201910/1780031-20191010230230288-782176273.jpg&quot; alt=&quot;执行流&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;tobe 注：在进程模型里，进程拥有对内存、I/O 通道、I/O 设备和文件等资源的控制权，称之为「资源所有权」。「执行流」可以看做进程在 CPU 上的执行过程（直观一点就是高级语言里的语句）。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;进程恍然大悟：“也就是说我仍然是资源的掌控者，那些线程就相当于帮我干活的小弟？”&lt;/p&gt;
&lt;p&gt;“没错，而且从这种角度看，你本身还是一个&lt;strong&gt;单线程进程&lt;/strong&gt;。”&lt;/p&gt;
&lt;p&gt;听了这么久，内存发问了：“创建进程的时候，我要保存进程 PCB ，那为了创建线程，我是不是还得创建一个 &lt;strong&gt;TCB&lt;/strong&gt;（Thread Control Block）？”&lt;/p&gt;
&lt;p&gt;“当然了，线程切换需要的信息就得存在 TCB 里面。不过你放心，TCB 要比 PCB 小得多，所以线程切换会比进程切换快很多。”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1780031/201910/1780031-20191010230231236-667162836.jpg&quot; alt=&quot;多线程进程模型&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大家听完，纷纷觉得「线程」这个模型完美的解决了当前的问题，说道：“要不我们现在就在操作系统里添上线程模型吧，早点解决进程的问题。”&lt;/p&gt;
&lt;p&gt;但是操作系统面露难色，说：“线程模型只是我们的一个假想，贸然加进来的话，可能会出问题，系统崩溃可就不好了，还是要以稳定为主。。。但这个模型还是得试的，要不我们先创建一个&lt;strong&gt;线程库&lt;/strong&gt;，靠一个&lt;strong&gt;用户级别&lt;/strong&gt;的应用程序——&lt;strong&gt;线程调度器&lt;/strong&gt;来管理这些线程吧。”&lt;/p&gt;
&lt;p&gt;进程不解的问：“可是这样的话，我还是被分配在一个单独的核心上啊，即使是多线程，也只能在单核上运行。再说了，如果这些线程里有一个被阻塞，在你看来，是&lt;strong&gt;整个进程阻塞&lt;/strong&gt;了，那其他线程，即使是就绪态，也得不到 CPU 资源。”&lt;/p&gt;
&lt;p&gt;操作系统仔细想了下，说：“没办法，&lt;strong&gt;用户级线程&lt;/strong&gt;确实有这两个缺点，但相比起让&lt;strong&gt;内核&lt;/strong&gt;来实现线程，用户级线程也有他的好处——线程切换&lt;strong&gt;不需要我进行状态转换&lt;/strong&gt;（从用户态到内核态），开销小，除此之外，线程库可以有多个调度算法，能够为应用程序量身定做调度算法。”&lt;/p&gt;
&lt;p&gt;&lt;em&gt;tobe 注：有一种解决线程阻塞的方案叫 &lt;strong&gt;jacketing&lt;/strong&gt;，他可以把一个产生阻塞的系统调用转化成一个非阻塞的系统调用，比如说，不直接调用&lt;strong&gt;系统级&lt;/strong&gt;的 I/O 例程，而是让线程调用&lt;strong&gt;应用级&lt;/strong&gt;的 I/O jacket 例程，这个 jacket 例程会检查 I/O 设备是否忙，如果忙的话，就不执行 I/O 操作，转而调度其他线程，避免了因等待 I/O 设备而造成的进程阻塞。&lt;/em&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;用户级线程很快投入使用，Linux系统中的 pthread（POSIX thread）库可以说是大获成功，操作系统做出了一项重大决定——支持内核级线程。&lt;/p&gt;
&lt;p&gt;内核级线程解决了进程并行的问题，除此之外，由于内核看得到线程的存在，一个线程阻塞了，位于同一个进程中的其它线程仍然能够运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1780031/201910/1780031-20191010230231764-346847048.jpg&quot; alt=&quot;用户级线程和内核级线程&quot;/&gt;&lt;/p&gt;
&lt;p&gt;并行的问题解决了，进程表示自己十分开心。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;希望你在看完我的文章之后有所收获。&lt;/p&gt;
&lt;p&gt;感谢你的阅读，我们后会有期！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;声明：原创文章，未经授权，禁止转载&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 10 Oct 2019 15:03:00 +0000</pubDate>
<dc:creator>tobe的呓语</dc:creator>
<og:description>进程最近有些烦恼，整日愁眉苦脸的，拜访内存的时候也有点心不在焉。 内存是个明眼人，开门见山的问道：“进程啊，最近遇到啥问题了？我看你最近情绪有点低落，有啥问题你就直接说出来嘛，我让大家伙儿来一起帮你想</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tobe98/p/11651237.html</dc:identifier>
</item>
</channel>
</rss>