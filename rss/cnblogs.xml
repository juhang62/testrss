<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>EF6学习笔记十二：Update操作、批量数据操作 - 张四海</title>
<link>http://www.cnblogs.com/jinshan-go/p/10280066.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jinshan-go/p/10280066.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;要专业系统地学习EF前往《你必须掌握的Entity Framework 6.x与Core 2.0》这本书的作者（汪鹏，Jeffcky）的博客：https://www.cnblogs.com/CreateMyself/&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据操作CRUD，我们只说Update,因为在EF中Update有点复杂  后面我们说批量数据更新&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;Update操作&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;上下文没有提供Update方法，所以我们要更新操作一般都是讲数据查询出来，修改实体属性的值，然后SaveChanges()就OK了&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;眼熟一下平时的Update&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_141b674d-20a0-4b0d-96c3-b793a4b4c59b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_141b674d-20a0-4b0d-96c3-b793a4b4c59b&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_141b674d-20a0-4b0d-96c3-b793a4b4c59b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  一般的修改&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; pro =&lt;span&gt; ctx.Products.FirstOrDefault();
Console.WriteLine(JsonConvert.SerializeObject(pro));
Console.WriteLine(ctx.Entry(pro).State);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Unchanged
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{&quot;Order&quot;:null,&quot;Name&quot;:&quot;牙刷&quot;,&quot;Price&quot;:14.00,&quot;Unit&quot;:&quot;只&quot;,&quot;FK_Order_Id&quot;:&quot;82903023-a7a6-4839-9caa-153ee9d00e65&quot;,&quot;Id&quot;:&quot;1b25351c-3008-4d27-a9de-6749ec1d0845&quot;,&quot;AddTime&quot;:&quot;2019-01-15T10:35:03.947&quot;}&lt;/span&gt;
pro.Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;牙刷2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
Console.WriteLine(ctx.Entry(pro).State);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Modified&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; res =&lt;span&gt; ctx.SaveChanges();
Console.WriteLine(res);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  result:1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;查询出来没做修改的实体，状态为Unchange,修改了属性值，状态变为Modified&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;现在要是我凭空new一个Product对象，id设置为数据库中某一个产品的Id,然后让上下文对这个新对象追踪，最后再修改实体状态为Modified,看看能不能修改&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_c69209d0-a2a4-47ca-91b1-e418997bfb31&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c69209d0-a2a4-47ca-91b1-e418997bfb31&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c69209d0-a2a4-47ca-91b1-e418997bfb31&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  数据库中存在的某一条数据的Id&lt;/span&gt;
&lt;span&gt;string&lt;/span&gt; id = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b0465c73-a7ab-4135-9bf8-4ec85ac6b1e2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
Product p &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Product
{
    Id &lt;/span&gt;=&lt;span&gt; id,
    Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;娃哈哈&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    AddTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
    Price &lt;/span&gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
    Unit &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;瓶&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
};
Console.WriteLine(ctx.Entry(p).State);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Detached&lt;/span&gt;
ctx.Products.Attach(p);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  这里报错&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;失败，在我对它进行追踪时就报错了。因为不能跟踪多个相同键的实体，就和数据库中主键重复冲突一样&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;System.InvalidOperationException: Attaching an entity of type '_2019011402.Entity.Product' failed because another entity of the same type already has the same primary key value. This can happen when using the 'Attach' method or setting the state of an entity to 'Unchanged' or 'Modified' if any entities in the graph have conflicting key values. This may be because some entities are new and have not yet received database-generated key values. In this case use the 'Add' method or the 'Added' entity state to track the graph and then set the state of non-new entities to 'Unchanged' or 'Modified' as appropriate.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;解决办法就是，去掉一个追踪，那么我们把该条数据查询出来，对它取消追踪，这个再跟踪这个新对象就可以了&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_6cca0bda-9e4e-4db1-98b6-e1e2467283df&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6cca0bda-9e4e-4db1-98b6-e1e2467283df&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6cca0bda-9e4e-4db1-98b6-e1e2467283df&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  全部属性更新  &lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; pro = ctx.Products.AsNoTracking().FirstOrDefault(x =&amp;gt;&lt;span&gt; x.Id.Contains(id));
Console.WriteLine(ctx.Entry(pro).State);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Detached&lt;/span&gt;
Product p = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Product
{
    Id &lt;/span&gt;=&lt;span&gt; id,
    Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;娃哈哈&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    AddTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
    Price &lt;/span&gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
    Unit &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;瓶&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    FK_Order_Id &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;469b82be-8139-4e67-b566-5b2b5f6d838d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
};
ctx.Products.Attach(p);
ctx.Entry(p).State &lt;/span&gt;=&lt;span&gt; System.Data.Entity.EntityState.Modified;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; res =&lt;span&gt; ctx.SaveChanges();
Console.WriteLine(res);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; result:1  ok&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;然后我贴一段代码，和主题没什么关系&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_a52f47d2-ecb3-4d91-afa6-00dfd00fa230&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a52f47d2-ecb3-4d91-afa6-00dfd00fa230&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a52f47d2-ecb3-4d91-afa6-00dfd00fa230&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;我来声明两个变量查询数据库中的同一条记录，引用相等&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; pro2 = ctx.Products.FirstOrDefault(x =&amp;gt;&lt;span&gt; x.Id.Contains(id)); 
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pro3 = ctx.Products.FirstOrDefault(x =&amp;gt;&lt;span&gt; x.Id.Contains(id));
Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pro2_state:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ctx.Entry(pro2).State);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Unchanged&lt;/span&gt;
Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pro3_state:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ctx.Entry(pro3).State);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Unchanged&lt;/span&gt;
&lt;span&gt;
Console.WriteLine(ReferenceEquals(pro2, pro3));  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  True&lt;/span&gt;
Test t1 = &lt;span&gt;new&lt;/span&gt; Test { Id = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
Test t2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Test { Id = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
Console.WriteLine(ReferenceEquals(t1, t2));  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;接着看Update操作，如果我们只更新一个实体的部分属性呢?&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_13d712c8-f886-4f08-8d43-ae11635f667c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_13d712c8-f886-4f08-8d43-ae11635f667c&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_13d712c8-f886-4f08-8d43-ae11635f667c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  部分属性更新,少了name,unit&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; pro = ctx.Products.AsNoTracking().FirstOrDefault(x =&amp;gt;&lt;span&gt; x.Id.Contains(id));
Console.WriteLine(ctx.Entry(pro).State);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Detached&lt;/span&gt;
Product p = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Product
{
    Id &lt;/span&gt;=&lt;span&gt; id,
    AddTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
    Price &lt;/span&gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
    FK_Order_Id &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;469b82be-8139-4e67-b566-5b2b5f6d838d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
};
ctx.Products.Attach(p);
ctx.Entry(p).State &lt;/span&gt;=&lt;span&gt; System.Data.Entity.EntityState.Modified;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; res =&lt;span&gt; ctx.SaveChanges();
Console.WriteLine(res);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; result:1  ok&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;看看数据库中的情况&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190116224626991-1358639965.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的情况说明Modified是全部更新，不能部分更新&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;部分更新&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;那么怎么部分更新？书中给了两种办法&lt;/p&gt;
&lt;p&gt;1.手动指定更新属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_ce5938b0-5a1e-4059-906c-6e264424d02d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ce5938b0-5a1e-4059-906c-6e264424d02d&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ce5938b0-5a1e-4059-906c-6e264424d02d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
ctx.Entry(p).Property(x =&amp;gt; x.Name).IsModified = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
ctx.Entry(p).Property(x &lt;/span&gt;=&amp;gt; x.Unit).IsModified = &lt;span&gt;true&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;2.用Entry().CurrentValues.SetValues() 方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_52022cb0-62aa-495c-b603-0a1d24284c98&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_52022cb0-62aa-495c-b603-0a1d24284c98&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_52022cb0-62aa-495c-b603-0a1d24284c98&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  使用 Entry()..CurrentValues.SetValues()  方式&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; pro = ctx.Products.FirstOrDefault(x =&amp;gt;&lt;span&gt; x.Id.Contains(id));
Product p &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Product
{
    Id &lt;/span&gt;=&lt;span&gt; id,
    Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;盆子2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;AddTime = new DateTime(1999, 2, 2),
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Price = 3,&lt;/span&gt;
    Unit = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    FK_Order_Id &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;469b82be-8139-4e67-b566-5b2b5f6d838d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
};
ctx.Entry(pro).CurrentValues.SetValues(p);
ctx.SaveChanges();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;但是我使用了之后，觉得不太好，也不知道是不是用错了，我遇到的问题是这样的，无法部分更新&lt;/p&gt;
&lt;p&gt;比如数据库中存在这么一条数据{&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:25,&quot;FK_AddressId&quot;:&quot;234&quot;}，那么我现在只想更新Name,我就传递这个对象{&quot;name&quot;:&quot;赵四&quot;}，但是它还是全部更新&lt;/p&gt;
&lt;p&gt;比如我没有指定age属性，那么修改为默认值“0”，外键在数据库中不能为空，报错&lt;/p&gt;
&lt;p&gt;各位可以去弄一下&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;批量更新操作&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;平时做批量更新，那就是遍历修改呗&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_080e1523-e74b-41c7-99a2-6c96ae168889&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_080e1523-e74b-41c7-99a2-6c96ae168889&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_080e1523-e74b-41c7-99a2-6c96ae168889&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; products =&lt;span&gt; ctx.Products.ToList();
&lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; products)
{
    item.Name &lt;/span&gt;= item.Name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;999&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}
ctx.SaveChanges();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;看看EF生成并执行的SQL语句&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190116231049592-2113789165.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;他会先把要更新的数据查询出来，然后逐条更新，如果你创建了存储过程，那么他会自动调用存储过程进行更新，这个性能会好一点&lt;/p&gt;
&lt;p&gt;我这里有一个存储过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190116231318476-1484952878.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后真正的SQL执行是这样的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190116231422865-767982373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;他首先会将要更新的数据查询出来，然后调用多次存储过程&lt;/p&gt;
&lt;p&gt;还是觉得不太理想？那么作者告诉了我们一个更好的方案，使用第三方库：EntityFrameWork.Extended&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190116231633407-439051367.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;引入命名空间：using EntityFramework.Extensions; 然后调用该Update方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_42045fa3-a038-4cd9-a5cc-e209ffb431df&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_42045fa3-a038-4cd9-a5cc-e209ffb431df&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_42045fa3-a038-4cd9-a5cc-e209ffb431df&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; products = ctx.Products.Update(x =&amp;gt; &lt;span&gt;new&lt;/span&gt; Product { Name = x.Name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;777&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
ctx.SaveChanges();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;捕获到SQL语句是这样的，很奇怪用ctx.Database.Log = Console.WriteLine;捕获不到，我用的SQL Profiler,这应该是这个Extended库是第三方的原因，不是EF团队弄的&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_0dda3db0-704a-446b-93c8-d01702311852&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0dda3db0-704a-446b-93c8-d01702311852&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0dda3db0-704a-446b-93c8-d01702311852&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;UPDATE&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;tb_Products&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; 
&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;CASE&lt;/span&gt; &lt;span&gt;WHEN&lt;/span&gt; (&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;IS&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;) &lt;span&gt;THEN&lt;/span&gt; N&lt;span&gt;''&lt;/span&gt; &lt;span&gt;ELSE&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;END&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;777&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  
&lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;tb_Products&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; j0 &lt;span&gt;INNER&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt;&lt;span&gt; (
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; 
    &lt;span&gt;1&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;C1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;, 
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Extent1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
    &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;tb_Products&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;Extent1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;
) &lt;/span&gt;&lt;span&gt;AS&lt;/span&gt; j1 &lt;span&gt;ON&lt;/span&gt; (j0.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; j1.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;看看数据库里面&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190116232343591-2146469794.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;唉，也难怪别人都说EF性能不好，还有很多东西要学啊。&lt;/p&gt;

</description>
<pubDate>Wed, 16 Jan 2019 15:28:00 +0000</pubDate>
<dc:creator>张四海</dc:creator>
<og:description>要专业系统地学习EF前往《你必须掌握的Entity Framework 6.x与Core 2.0》这本书的作者（汪鹏，Jeffcky）的博客：https://www.cnblogs.com/Creat</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jinshan-go/p/10280066.html</dc:identifier>
</item>
<item>
<title>redis - Sentinel 和 cluster - 温而新</title>
<link>http://www.cnblogs.com/peng104/p/10280009.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/peng104/p/10280009.html</guid>
<description>

&lt;h2&gt;引入&lt;/h2&gt;
&lt;p&gt;上回说到redis主从同步时，master（主库）如果宕机了怎么解决...&lt;/p&gt;
&lt;p&gt;我给出了一个手动解决的办法！&lt;/p&gt;
&lt;p&gt;但实际上，如果你配置了Sentinel，它能自动发现master宕机并且进行自动切换slave（从库）变master 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sentinel（哨兵）主要功能如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不时的监控redis是否良好运行，如果节点不可达就会对节点进行下线标识&lt;/li&gt;
&lt;li&gt;如果被标识的是主节点，sentinel就会和其他的sentinel节点“协商”，如果其他节点也人为主节点不可达，就会选举一个sentinel节点来完成自动故障转义&lt;/li&gt;
&lt;li&gt;在master-slave进行切换后，master_redis.conf、slave_redis.conf和sentinel.conf的内容都会发生改变，即master_redis.conf中会多一行slaveof的配置，sentinel.conf的监控目标会随之调换&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;安装配置&lt;/h2&gt;
&lt;p&gt;实验环境：CentOS7虚拟机一台&lt;/p&gt;
&lt;p&gt;配置：&lt;/p&gt;
&lt;p&gt;　　一主（6379）两从（6380，6381）&lt;/p&gt;
&lt;p&gt;　　三个 sentinel 检测主节点（26379，26380，26381）&lt;/p&gt;
&lt;p&gt;存放位置自定义，运行程序时切换到改文件即可。&lt;/p&gt;
&lt;p&gt;在正式环境中，需按照公司需求，安装配置在不同的linux上。&lt;/p&gt;
&lt;p&gt;具体步骤请参考&lt;a href=&quot;https://www.cnblogs.com/peng104/p/10274857.html&quot; target=&quot;_blank&quot;&gt;上一篇博客&lt;/a&gt; 本篇博客不做详细讲解~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，先准备三个redis实例，&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c8a2fbdb-2e12-4c1b-8415-225a601c789c')&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_c8a2fbdb-2e12-4c1b-8415-225a601c789c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c8a2fbdb-2e12-4c1b-8415-225a601c789c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c8a2fbdb-2e12-4c1b-8415-225a601c789c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c8a2fbdb-2e12-4c1b-8415-225a601c789c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
port 6379&lt;span&gt;
daemonize yes
logfile &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;6379.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
dbfilename &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dump-6379.rdb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
dir &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/var/redis/data/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;redis-6379.conf&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('1d29c9de-de0d-46b8-913e-2c22f7578ed4')&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_1d29c9de-de0d-46b8-913e-2c22f7578ed4&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1d29c9de-de0d-46b8-913e-2c22f7578ed4&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('1d29c9de-de0d-46b8-913e-2c22f7578ed4',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1d29c9de-de0d-46b8-913e-2c22f7578ed4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
port 6380&lt;span&gt;
daemonize yes
logfile &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;6380.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
dbfilename &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dump-6380.rdb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
dir &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/var/redis/data/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
slaveof &lt;/span&gt;127.0.0.1 6379
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;redis-6380.conf&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('06477485-6432-4665-825b-7277c9b879a0')&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_06477485-6432-4665-825b-7277c9b879a0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_06477485-6432-4665-825b-7277c9b879a0&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('06477485-6432-4665-825b-7277c9b879a0',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_06477485-6432-4665-825b-7277c9b879a0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
port 6381&lt;span&gt;
daemonize yes
logfile &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;6381.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
dbfilename &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dump-6381.rdb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
dir &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/var/redis/data/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
slaveof &lt;/span&gt;127.0.0.1 6379
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;redis-6381.conf&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('999794df-05d4-4c5e-9a8a-db335c07f69b')&quot; readability=&quot;47&quot;&gt;&lt;img id=&quot;code_img_closed_999794df-05d4-4c5e-9a8a-db335c07f69b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_999794df-05d4-4c5e-9a8a-db335c07f69b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('999794df-05d4-4c5e-9a8a-db335c07f69b',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_999794df-05d4-4c5e-9a8a-db335c07f69b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;89&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Redis 配置文件&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当配置中需要配置内存大小时，可以使用 1k, 5GB, 4M 等类似的格式，其转换方式如下(不区分大小写)&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 1k =&amp;gt; 1000 bytes&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 1kb =&amp;gt; 1024 bytes&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 1m =&amp;gt; 1000000 bytes&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 1mb =&amp;gt; 1024*1024 bytes&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 1g =&amp;gt; 1000000000 bytes&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 1gb =&amp;gt; 1024*1024*1024 bytes&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 内存配置大小写是一样的.比如 1gb 1Gb 1GB 1gB&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; daemonize no 默认情况下，redis不是在后台运行的，如果需要在后台运行，把该项的值更改为yes&lt;/span&gt;
&lt;span&gt;daemonize yes

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当redis在后台运行的时候，Redis默认会把pid文件放在/var/run/redis.pid，你可以配置到其他地址。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 当运行多个redis服务时，需要指定不同的pid文件和端口&lt;/span&gt;
pidfile /var/run/&lt;span&gt;redis.pid

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 指定redis运行的端口，默认是6379&lt;/span&gt;
port 6379

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 指定redis只接收来自于该IP地址的请求，如果不进行设置，那么将处理所有请求，&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 在生产环境中最好设置该项&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; bind 127.0.0.1&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Specify the path for the unix socket that will be used to listen for&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; incoming connections. There is no default, so Redis will not listen&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; on a unix socket when not specified.&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; unixsocket /tmp/redis.sock&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; unixsocketperm 755&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置客户端连接时的超时时间，单位为秒。当客户端在这段时间内没有发出任何指令，那么关闭该连接&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 0是关闭此设置&lt;/span&gt;
&lt;span&gt;timeout 0

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 指定日志记录级别&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; debug    记录很多信息，用于开发和测试&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; varbose    有用的信息，不像debug会记录那么多&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; notice    普通的verbose，常用于生产环境&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; warning    只有非常重要或者严重的信息会记录到日志&lt;/span&gt;
&lt;span&gt;loglevel debug

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 配置log文件地址&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 默认值为stdout，标准输出，若后台模式会输出到/dev/null&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;logfile stdout&lt;/span&gt;
logfile /var/log/redis/&lt;span&gt;redis.log

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; To enable logging to the system logger, just set 'syslog-enabled' to yes,&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; and optionally update the other syslog parameters to suit your needs.&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; syslog-enabled no&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Specify the syslog identity.&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; syslog-ident redis&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; syslog-facility local0&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 可用数据库数&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 默认值为16，默认数据库为0，数据库范围在0-（database-1）之间&lt;/span&gt;
databases 16

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################### 快照 #################################&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 保存数据到磁盘，格式如下:&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; save &amp;lt;seconds&amp;gt; &amp;lt;changes&amp;gt;&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 指出在多长时间内，有多少次更新操作，就将数据同步到数据文件rdb。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 相当于条件触发抓取快照，这个可以多个条件配合&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt; &lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 比如默认配置文件中的设置，就设置了三个条件&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; save 900 1 900秒内至少有1个key被改变&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; save 300 10 300秒内至少有300个key被改变&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; save 60 10000 60秒内至少有10000个key被改变&lt;/span&gt;
&lt;span&gt;
save &lt;/span&gt;900 1&lt;span&gt;
save &lt;/span&gt;300 10&lt;span&gt;
save &lt;/span&gt;60 10000

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 存储至本地数据库时（持久化到rdb文件）是否压缩数据，默认为yes&lt;/span&gt;
&lt;span&gt;rdbcompression yes

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 本地持久化数据库文件名，默认值为dump.rdb&lt;/span&gt;
&lt;span&gt;dbfilename dump.rdb

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 工作目录&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 数据库镜像备份的文件放置的路径。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 这里的路径跟文件名要分开配置是因为redis在进行备份时，先会将当前数据库的状态写入到一个临时文件中，等备份完成时，&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 再把该该临时文件替换为上面所指定的文件，而这里的临时文件和上面所配置的备份文件都会放在这个指定的路径当中。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt; &lt;span&gt;
#&lt;/span&gt;&lt;span&gt; AOF文件也会存放在这个目录下面&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt; &lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 注意这里必须制定一个目录而不是文件&lt;/span&gt;
dir ./

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;################################ 复制 #################################&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 主从复制. 设置该数据库为其他数据库的从数据库. &lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; slaveof &amp;lt;masterip&amp;gt; &amp;lt;masterport&amp;gt;&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当master服务设置了密码保护时(用requirepass制定的密码)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; slav服务连接master的密码&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt; &lt;span&gt;
#&lt;/span&gt;&lt;span&gt; masterauth &amp;lt;master-password&amp;gt;&lt;/span&gt;


&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当从库同主机失去连接或者复制正在进行，从机库有两种运行方式：&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 1) 如果slave-serve-stale-data设置为yes(默认设置)，从库会继续相应客户端的请求&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt; &lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 2) 如果slave-serve-stale-data是指为no，出去INFO和SLAVOF命令之外的任何请求都会返回一个&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 错误&quot;SYNC with master in progress&quot;&lt;/span&gt;&lt;span&gt;
#
&lt;/span&gt;slave-serve-stale-&lt;span&gt;data yes

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从库会按照一个时间间隔向主库发送PINGs.可以通过repl-ping-slave-period设置这个时间间隔，默认是10秒&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; repl-ping-slave-period 10&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; repl-timeout 设置主库批量数据传输时间或者ping回复时间间隔，默认值是60秒&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 一定要确保repl-timeout大于repl-ping-slave-period&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; repl-timeout 60&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;################################# 安全 ###################################&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置客户端连接后进行任何其他指定前需要使用的密码。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 警告：因为redis速度相当快，所以在一台比较好的服务器下，一个外部的用户可以在一秒钟进行150K次的密码尝试，这意味着你需要指定非常非常强大的密码来防止暴力破解&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; requirepass foobared&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 命令重命名.&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 在一个共享环境下可以重命名相对危险的命令。比如把CONFIG重名为一个不容易猜测的字符。&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 举例:&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 如果想删除一个命令，直接把它重命名为一个空字符&quot;&quot;即可，如下：&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; rename-command CONFIG &quot;&quot;&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;################################## 约束 ####################################&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 如果设置 maxclients 0，表示不作限制。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; maxclients 128&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Redis同时也会移除空的list对象&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt; &lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 注意：Redis新的vm机制，会把Key存放内存，Value会存放在swap区&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; maxmemory的设置比较适合于把redis当作于类似memcached的缓存来使用，而不适合当做一个真实的DB。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 当把Redis当做一个真实的数据库使用的时候，内存使用将是一个很大的开销&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; maxmemory &amp;lt;bytes&amp;gt;&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当内存达到最大值的时候Redis会选择删除哪些数据？有五种方式可供选择&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt; &lt;span&gt;
#&lt;/span&gt;&lt;span&gt; volatile-lru -&amp;gt; 利用LRU算法移除设置过过期时间的key (LRU:最近使用 Least Recently Used )&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; allkeys-lru -&amp;gt; 利用LRU算法移除任何key&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; volatile-random -&amp;gt; 移除设置过过期时间的随机key&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; allkeys-&amp;gt;random -&amp;gt; remove a random key, any key &lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; volatile-ttl -&amp;gt; 移除即将过期的key(minor TTL)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; noeviction -&amp;gt; 不移除任何可以，只是返回一个写错误&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt; &lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 注意：对于上面的策略，如果没有合适的key可以移除，当写的时候Redis会返回一个错误&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 写命令包括: set setnx setex append&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; getset mset msetnx exec sort&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 默认是:&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; maxmemory-policy volatile-lru&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; LRU 和 minimal TTL 算法都不是精准的算法，但是相对精确的算法(为了节省内存)，随意你可以选择样本大小进行检测。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Redis默认的灰选择3个样本进行检测，你可以通过maxmemory-samples进行设置&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; maxmemory-samples 3&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################# AOF ###############################&lt;/span&gt;


&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 默认情况下，redis会在后台异步的把数据库镜像备份到磁盘，但是该备份是非常耗时的，而且备份也不能很频繁，如果发生诸如拉闸限电、拔插头等状况，那么将造成比较大范围的数据丢失。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 所以redis提供了另外一种更加高效的数据库备份及灾难恢复方式。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 开启append only模式之后，redis会把所接收到的每一次写操作请求都追加到appendonly.aof文件中，当redis重新启动时，会从该文件恢复出之前的状态。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 但是这样会造成appendonly.aof文件过大，所以redis还支持了BGREWRITEAOF指令，对appendonly.aof 进行重新整理。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 你可以同时开启asynchronous dumps 和 AOF&lt;/span&gt;
&lt;span&gt;
appendonly no

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; AOF文件名称 (默认: &quot;appendonly.aof&quot;)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; appendfilename appendonly.aof&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Redis支持三种同步AOF文件的策略:&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; no: 不进行同步，系统去操作 . Faster.&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; always: always表示每次有写操作都进行同步. Slow, Safest.&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; everysec: 表示对写操作进行累积，每秒同步一次. Compromise.&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 默认是&quot;everysec&quot;，按照速度和安全折中这是最好的。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 如果想让Redis能更高效的运行，你也可以设置为&quot;no&quot;，让操作系统决定什么时候去执行&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 或者相反想让数据更安全你也可以设置为&quot;always&quot;&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 如果不确定就用 &quot;everysec&quot;.&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; appendfsync always&lt;/span&gt;
&lt;span&gt;appendfsync everysec
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; appendfsync no&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; AOF策略设置为always或者everysec时，后台处理进程(后台保存或者AOF日志重写)会执行大量的I/O操作&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 在某些Linux配置中会阻止过长的fsync()请求。注意现在没有任何修复，即使fsync在另外一个线程进行处理&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 为了减缓这个问题，可以设置下面这个参数no-appendfsync-on-rewrite&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; This means that while another child is saving the durability of Redis is&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; the same as &quot;appendfsync none&quot;, that in pratical terms means that it is&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; possible to lost up to 30 seconds of log in the worst scenario (with the&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; default Linux settings).&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt; &lt;span&gt;
#&lt;/span&gt;&lt;span&gt; If you have latency problems turn this to &quot;yes&quot;. Otherwise leave it as&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; &quot;no&quot; that is the safest pick from the point of view of durability.&lt;/span&gt;
no-appendfsync-on-&lt;span&gt;rewrite no

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Automatic rewrite of the append only file.&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; AOF 自动重写&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 当AOF文件增长到一定大小的时候Redis能够调用 BGREWRITEAOF 对日志文件进行重写 &lt;/span&gt;&lt;span&gt;
#&lt;/span&gt; &lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 它是这样工作的：Redis会记住上次进行些日志后文件的大小(如果从开机以来还没进行过重写，那日子大小在开机的时候确定)&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 基础大小会同现在的大小进行比较。如果现在的大小比基础大小大制定的百分比，重写功能将启动&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 同时需要指定一个最小大小用于AOF重写，这个用于阻止即使文件很小但是增长幅度很大也去重写AOF文件的情况&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 设置 percentage 为0就关闭这个特性&lt;/span&gt;
&lt;span&gt;
auto&lt;/span&gt;-aof-rewrite-percentage 100&lt;span&gt;
auto&lt;/span&gt;-aof-rewrite-min-&lt;span&gt;size 64mb

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;################################# SLOW LOG ###################################&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Redis Slow Log 记录超过特定执行时间的命令。执行时间不包括I/O计算比如连接客户端，返回结果等，只是命令执行时间&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt; &lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 可以通过两个参数设置slow log：一个是告诉Redis执行超过多少时间被记录的参数slowlog-log-slower-than(微妙)，&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 另一个是slow log 的长度。当一个新命令被记录的时候最早的命令将被从队列中移除&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 下面的时间以微妙微单位，因此1000000代表一分钟。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 注意制定一个负数将关闭慢日志，而设置为0将强制每个命令都会记录&lt;/span&gt;
slowlog-log-slower-than 10000

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对日志长度没有限制，只是要注意它会消耗内存&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 可以通过 SLOWLOG RESET 回收被慢日志消耗的内存&lt;/span&gt;
slowlog-max-len 1024

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################### VM ###############################&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;## WARNING! Virtual Memory is deprecated in Redis 2.4&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;## The use of Virtual Memory is strongly discouraged.&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Virtual Memory allows Redis to work with datasets bigger than the actual&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; amount of RAM needed to hold the whole dataset in memory.&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; In order to do so very used keys are taken in memory while the other keys&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; are swapped into a swap file, similarly to what operating systems do&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; with memory pages.&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; To enable VM just set 'vm-enabled' to yes, and set the following three&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; VM parameters accordingly to your needs.&lt;/span&gt;
&lt;span&gt;
vm&lt;/span&gt;-&lt;span&gt;enabled no
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; vm-enabled yes&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; This is the path of the Redis swap file. As you can guess, swap files&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; can't be shared by different Redis instances, so make sure to use a swap&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; file for every redis process you are running. Redis will complain if the&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; swap file is already in use.&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; The best kind of storage for the Redis swap file (that's accessed at random) &lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; is a Solid State Disk (SSD).&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; *** WARNING *** if you are using a shared hosting the default of putting&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; the swap file under /tmp is not secure. Create a dir with access granted&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; only to Redis user and configure Redis to create the swap file there.&lt;/span&gt;
vm-swap-file /tmp/&lt;span&gt;redis.swap

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; vm-max-memory configures the VM to use at max the specified amount of&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; RAM. Everything that deos not fit will be swapped on disk *if* possible, that&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; is, if there is still enough contiguous space in the swap file.&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; With vm-max-memory 0 the system will swap everything it can. Not a good&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; default, just specify the max amount of RAM you can in bytes, but it's&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; better to leave some margin. For instance specify an amount of RAM&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; that's more or less between 60 and 80% of your free RAM.&lt;/span&gt;
vm-max-&lt;span&gt;memory 0

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Redis swap files is split into pages. An object can be saved using multiple&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; contiguous pages, but pages can't be shared between different objects.&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; So if your page is too big, small objects swapped out on disk will waste&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; a lot of space. If you page is too small, there is less space in the swap&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; file (assuming you configured the same number of total swap file pages).&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; If you use a lot of small objects, use a page size of 64 or 32 bytes.&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; If you use a lot of big objects, use a bigger page size.&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; If unsure, use the default :)&lt;/span&gt;
vm-page-size 32

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Number of total memory pages in the swap file.&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Given that the page table (a bitmap of free/used pages) is taken in memory,&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; every 8 pages on disk will consume 1 byte of RAM.&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; The total swap size is vm-page-size * vm-pages&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; With the default of 32-bytes memory pages and 134217728 pages Redis will&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; use a 4 GB swap file, that will use 16 MB of RAM for the page table.&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; It's better to use the smallest acceptable value for your application,&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; but the default is large in order to work in most conditions.&lt;/span&gt;
vm-pages 134217728

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Max number of VM I/O threads running at the same time.&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; This threads are used to read/write data from/to swap file, since they&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; also encode and decode objects from disk to memory or the reverse, a bigger&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; number of threads can help with big objects even if they can't help with&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; I/O itself as the physical device may not be able to couple with many&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; reads/writes operations at the same time.&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; The special value of 0 turn off threaded I/O and enables the blocking&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Virtual Memory implementation.&lt;/span&gt;
vm-max-threads 4

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################## ADVANCED CONFIG ###############################&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当hash中包含超过指定元素个数并且最大的元素没有超过临界时，&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; hash将以一种特殊的编码方式（大大减少内存使用）来存储，这里可以设置这两个临界值&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Redis Hash对应Value内部实际就是一个HashMap，实际这里会有2种不同实现，&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 这个Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，对应的value redisObject的encoding为zipmap,&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 当成员数量增大时会自动转成真正的HashMap,此时encoding为ht。&lt;/span&gt;
hash-max-zipmap-entries 512&lt;span&gt;
hash&lt;/span&gt;-max-zipmap-value 64

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; list数据类型多少节点以下会采用去指针的紧凑存储格式。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; list数据类型节点值大小小于多少字节会采用紧凑存储格式。&lt;/span&gt;
list-max-ziplist-entries 512&lt;span&gt;
list&lt;/span&gt;-max-ziplist-value 64

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; set数据类型内部数据如果全部是数值型，且包含多少节点以下会采用紧凑格式存储。&lt;/span&gt;
set-max-intset-entries 512

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; zsort数据类型多少节点以下会采用去指针的紧凑存储格式。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; zsort数据类型节点值大小小于多少字节会采用紧凑存储格式。&lt;/span&gt;
zset-max-ziplist-entries 128&lt;span&gt;
zset&lt;/span&gt;-max-ziplist-value 64

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Redis将在每100毫秒时使用1毫秒的CPU时间来对redis的hash表进行重新hash，可以降低内存的使用&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt; &lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 当你的使用场景中，有非常严格的实时性需要，不能够接受Redis时不时的对请求有2毫秒的延迟的话，把这项配置为no。&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 如果没有这么严格的实时性要求，可以设置为yes，以便能够尽可能快的释放内存&lt;/span&gt;
&lt;span&gt;activerehashing yes

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;################################# INCLUDES ###################################&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; include /path/to/local.conf&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; include /path/to/other.conf&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;附：redis.conf详解&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2，启动三个数据库实例&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; redis-server  redis-6379.conf&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; redis-server  redis-6380.conf&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; redis-server  redis-6381.conf&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3，准备三个哨兵文件，监控主从架构&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('46dae53b-5078-4945-85a0-7e93cf446dfd')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_46dae53b-5078-4945-85a0-7e93cf446dfd&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_46dae53b-5078-4945-85a0-7e93cf446dfd&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('46dae53b-5078-4945-85a0-7e93cf446dfd',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_46dae53b-5078-4945-85a0-7e93cf446dfd&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
//&lt;span&gt; Sentinel节点的端口
port &lt;/span&gt;26379&lt;span&gt;  
dir &lt;/span&gt;/var/redis/data/&lt;span&gt;
logfile &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;26379.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

// 当前Sentinel节点监控 127.0.0.1:6379&lt;span&gt; 这个主节点
&lt;/span&gt;//&lt;span&gt; 2代表判断主节点失败至少需要2个Sentinel节点节点同意
&lt;/span&gt;//&lt;span&gt; mymaster是主节点的别名
sentinel monitor qsmaster  &lt;/span&gt;127.0.0.1 6379 2

//&lt;span&gt;每个Sentinel节点都要定期PING命令来判断Redis数据节点和其余Sentinel节点是否可达，如果超过30000毫秒30s且没有回复，则判定不可达
sentinel down&lt;/span&gt;-after-milliseconds qsmaster 30000

//&lt;span&gt;当Sentinel节点集合对主节点故障判定达成一致时，Sentinel领导者节点会做故障转移操作，选出新的主节点，
原来的从节点会向新的主节点发起复制操作，限制每次向新的主节点发起复制操作的从节点个数为1
sentinel parallel&lt;/span&gt;-syncs qsmaster 1

//&lt;span&gt;故障转移超时时间为180000毫秒
sentinel failover&lt;/span&gt;-timeout qsmaster 180000

//&lt;span&gt;后台运行服务端
daemonize yes &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;redis-26379.conf&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;注意：避免冲突，复制前删除注释&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('3c282f37-2668-4057-83d8-82e81dee81b2')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_3c282f37-2668-4057-83d8-82e81dee81b2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3c282f37-2668-4057-83d8-82e81dee81b2&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('3c282f37-2668-4057-83d8-82e81dee81b2',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3c282f37-2668-4057-83d8-82e81dee81b2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
port 26380&lt;span&gt;  
dir &lt;/span&gt;/var/redis/data/&lt;span&gt;
logfile &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;26380.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
sentinel monitor qsmaster  &lt;/span&gt;127.0.0.1 6379 2&lt;span&gt;
sentinel down&lt;/span&gt;-after-milliseconds qsmaster 30000&lt;span&gt;
sentinel parallel&lt;/span&gt;-syncs qsmaster 1&lt;span&gt;
sentinel failover&lt;/span&gt;-timeout qsmaster 180000&lt;span&gt;
daemonize yes &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;redis-26380.conf&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('93062297-d2d2-47f6-aa03-dadd9dfbf7bf')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_93062297-d2d2-47f6-aa03-dadd9dfbf7bf&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_93062297-d2d2-47f6-aa03-dadd9dfbf7bf&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('93062297-d2d2-47f6-aa03-dadd9dfbf7bf',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_93062297-d2d2-47f6-aa03-dadd9dfbf7bf&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
port 26381&lt;span&gt;  
dir &lt;/span&gt;/var/redis/data/&lt;span&gt;
logfile &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;26381.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
sentinel monitor qsmaster  &lt;/span&gt;127.0.0.1 6379 2&lt;span&gt;
sentinel down&lt;/span&gt;-after-milliseconds qsmaster 30000&lt;span&gt;
sentinel parallel&lt;/span&gt;-syncs qsmaster 1&lt;span&gt;
sentinel failover&lt;/span&gt;-timeout qsmaster 180000&lt;span&gt;
daemonize yes &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;redis-26381.conf&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4，分别启动三个哨兵实例&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; redis-sentinel redis-26379.conf &lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; redis-sentinel redis-26380.conf &lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; redis-sentinel redis-26381.conf&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意: 如果发现不成功，需要删掉所有的哨兵配置文件，从新来过&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5，检查哨兵状态是否正常，&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; redis-cli -p 26379 info sentinel  # 查看配置&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 配置如下表示正常&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Sentinel&lt;/span&gt;
sentinel_masters:1&lt;span&gt;
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
sentinel_simulate_failure_flags:0
master0:name&lt;/span&gt;=qsmaster,status=ok,address=127.0.0.1:6380,slaves=2,sentinels=3
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 哨兵主节点名字叫做mymaster，状态ok，监控地址是127.0.0.1:6379，有两个从节点，3个哨兵&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;故障实验&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;大致思路&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;杀掉主节点的redis进程6379端口，观察从节点是否会进行新的master选举，进行切换&lt;/li&gt;
&lt;li&gt;重新恢复旧的“master”节点，查看此时的redis身份&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;1，首先查看三个redis的进程状态&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
ps -ef|grep redis
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2，干掉master ， 然后等待其他俩个节点是否自动被哨兵切换主从身份&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
kill 进程pid  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;干掉master进程&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1392643/201901/1392643-20190116222632999-1652781929.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3，再查看另外两个slave的状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　发现其中一个节点变为主节点（随机的）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4，然后再开启主节点6379，检查三个节点的复制身份状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　此时，6379状态已经变成 slave 了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;&lt;img id=&quot;code_img_closed_d831fd75-340e-41e1-9ef4-ccc794561907&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;第一个&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;&lt;img id=&quot;code_img_closed_e174f213-672a-49f2-b7e5-e587ee731933&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;第二个&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;&lt;img id=&quot;code_img_closed_7d0eac2b-17e7-461d-822a-1b4dc2e69fa7&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;第三个&lt;/span&gt;&lt;/div&gt;


&lt;h2&gt;引入&lt;/h2&gt;
&lt;p&gt;　　1，redis官方生成可以达到 10万/每秒,每秒执行10万条命令。&lt;/p&gt;
&lt;p&gt;　　　　假如业务需要每秒100万的命令执行呢？&lt;/p&gt;
&lt;p&gt;　　1，一台服务器内存正常是16~256G。&lt;/p&gt;
&lt;p&gt;　　　　假如你的业务需要500G内存，那怎么办？&lt;/p&gt;
&lt;p&gt;正确的应该是考虑分布式，加机器，把数据分到不同的位置，分摊集中式的压力，&lt;strong&gt;一堆机器做一件事&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;cluster实例及配置&lt;/h2&gt;
&lt;p&gt;使用方式： 官方提供通过ruby语言的脚本一键安装&lt;/p&gt;
&lt;h3&gt;1，环境配置&lt;/h3&gt;
&lt;p&gt;redis支持多实例的功能，我们在单机演示集群搭建，需要6个实例，三个是主节点，三个是从节点，数量为6个节点才能保证高可用的集群。&lt;/p&gt;
&lt;p&gt;通过配置，开启redis-cluster&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
port 7000&lt;span&gt;
daemonize yes
dir &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/opt/redis/data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
logfile &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;7000.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
dbfilename &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dump-7000.rdb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
cluster&lt;/span&gt;-enabled yes   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 开启集群模式&lt;/span&gt;
cluster-config-file nodes-7000.conf　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 集群内部的配置文件&lt;/span&gt;
cluster-require-full-coverage no　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt; redis cluster需要16384个slot都正常的时候才能对外提供服务，换句话说，只要任何一个slot异常那么整个cluster不对外提供服务。 因此生产环境一般为no&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;每个节点仅仅是端口运行的不同！&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@localhost /opt/redis/config 17:12:30]&lt;span&gt;#&lt;/span&gt;&lt;span&gt;ls&lt;/span&gt;
redis-7000.conf  redis-7002.conf  redis-7004&lt;span&gt;.conf
redis&lt;/span&gt;-7001.conf  redis-7003.conf  redis-7005&lt;span&gt;.conf

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;确保每个配置文件中的端口修改！！&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2，分别运行redis实例&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; redis-server redis-7000.conf&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; redis-server redis-7001.conf&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; redis-server redis-7002.conf&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; redis-server redis-7003.conf&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; redis-server redis-7004.conf&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; redis-server redis-7005.conf&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：此时集群还不可用&lt;/p&gt;
&lt;h3&gt;3，准备ruby的编程环境&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.下载ruby的源码包&lt;/span&gt;
wget https://cache.ruby-lang.org/pub/ruby/2.3/ruby-2.3.1&lt;span&gt;.tar.gz

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.解压缩ruby源码&lt;/span&gt;
tar -xvf ruby-2.3.1&lt;span&gt;.tar.gz

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3.进入ruby源码包，配置安装位置&lt;/span&gt;
./configure --prefix=/opt/ruby/

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4.开始编译且编译安装&lt;/span&gt;
make &amp;amp;&amp;amp;&lt;span&gt; make install

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 5.配置ruby的环境变量&lt;/span&gt;
vim /etc/&lt;span&gt;profile 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 写入如下配置&lt;/span&gt;
PATH=$PATH:/opt/ruby/&lt;span&gt;bin 
      &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4，安装ruby操作redis的模块&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.下载ruby操作redis的模块&lt;/span&gt;
wget http://rubygems.org/downloads/redis-3.3&lt;span&gt;.0.gem

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.安装&lt;/span&gt;
gem install -l redis-3.3&lt;span&gt;.0.gem

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3.搜索创建redis集群的命令&lt;/span&gt;
find /opt  -name  redis-&lt;span&gt;trib.rb
&lt;/span&gt;/opt/redis-4.0.10/src/redis-trib.rb  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 搜索结果&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5，一键创建redis集群&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; replicas 1 --代表每个主节点，有一个从节点&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 集群自动分配主从关系，默认：&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 7000，7001，7001 为主库&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;  7003，7004，7005 为从库&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;6，查看集群状态&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
redis-cli -p 7000&lt;span&gt; cluster info  

redis&lt;/span&gt;-cli -p 7000 cluster nodes  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;等同于查看nodes-7000.conf文件节点信息&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 集群主节点状态&lt;/span&gt;
redis-cli -p 7000 cluster nodes |&lt;span&gt; grep master
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 集群从节点状态&lt;/span&gt;
redis-cli -p 7000 cluster nodes | grep slave
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;6，开启集群&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
redis-cli -p 7000  -&lt;span&gt;c  
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -p  指定数据库端口&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -c  指定开启集群模式&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;7，测试写入集群数据&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
127.0.0.1:7000&amp;gt;&lt;span&gt; set name peng     
&lt;/span&gt;-&amp;gt; Redirected to slot [5798] located at 127.0.0.1:7001&lt;span&gt;       
OK
&lt;/span&gt;127.0.0.1:7001&amp;gt;&lt;span&gt; exit
[root@yugo &lt;/span&gt;/opt/redis/src 18:46:07]&lt;span&gt;#&lt;/span&gt;&lt;span&gt;redis-cli -c -p 7000&lt;/span&gt;
127.0.0.1:7000&amp;gt;&lt;span&gt; ping
PONG
&lt;/span&gt;127.0.0.1:7000&amp;gt; keys *&lt;span&gt;
(empty list &lt;/span&gt;&lt;span&gt;or&lt;/span&gt;&lt;span&gt; set)
&lt;/span&gt;127.0.0.1:7000&amp;gt;&lt;span&gt; get name
&lt;/span&gt;-&amp;gt; Redirected to slot [5798] located at 127.0.0.1:7001
&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;peng&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;集群已经搭建完毕啦！！！&lt;/p&gt;
</description>
<pubDate>Wed, 16 Jan 2019 15:14:00 +0000</pubDate>
<dc:creator>温而新</dc:creator>
<og:description>redis哨兵集群 引入 上回说到redis主从同步时，master（主库）如果宕机了怎么解决... 我给出了一个手动解决的办法！ 但实际上，如果你配置了Sentinel，它能自动发现master宕机</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/peng104/p/10280009.html</dc:identifier>
</item>
<item>
<title>03 Java 虚拟机是如何加载 Java 类的 - 黑_子</title>
<link>http://www.cnblogs.com/yuepenglei/p/10279996.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuepenglei/p/10279996.html</guid>
<description>&lt;h4 id=&quot;java-引用类型&quot;&gt;Java 引用类型&lt;/h4&gt;
&lt;p&gt;Java 中的引用类型细分为四种：类，接口，数组类和泛型参数。&lt;/p&gt;
&lt;p&gt;因为泛型参数会在编译过程中被擦除，所以 Java 虚拟机实际上只有前三种。数组类是由 Java 虚拟机直接生成的，其他两种则有对应的字节流。&lt;/p&gt;
&lt;p&gt;无论是数组类还是其他两种类型，Java 虚拟机都需要对其进行链接和初始化。&lt;/p&gt;
&lt;h4 id=&quot;加载&quot;&gt;加载&lt;/h4&gt;
&lt;p&gt;加载就是查找字节流，然后据此创建类的过程。数组类由 Java 虚拟机直接生成，其他类则需要 Java 虚拟机借助类加载器来完成查找字节流的过程。&lt;/p&gt;
&lt;p&gt;类加载器有很多种，除了启动类加载器以外，其他的类加载器都是 java.lang.ClassLoader 的子类，因此有对应的 Java 对象。这些类加载器都需要先由其他类加载器比如说启动类加载器加载到 Java 虚拟机中，方能执行类加载。&lt;/p&gt;
&lt;p&gt;双亲委派机制：每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。如果父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。&lt;/p&gt;
&lt;p&gt;在 Java 9 之前，启动类加载器负责加载最基础最重要的类。除了启动类加载器之外，还有扩展类加载器和应用类加载器，均由 Java 核心类库提供。&lt;/p&gt;
&lt;p&gt;扩展类加载器的父类加载器是启动类加载器。它负责加载相对次要但通用的类。&lt;/p&gt;
&lt;p&gt;应用类加载器的父类加载器是扩展类加载器。它负责加载应用程序路径下的类。&lt;/p&gt;
&lt;p&gt;Java 9 中扩展类加载器被改名为平台类加载器。Java SE 中除了少数几个关键模块是由启动类加载器加载之外，其他模块均由平台类加载器所加载。&lt;/p&gt;
&lt;p&gt;在 Java 虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的。&lt;/p&gt;
&lt;h4 id=&quot;链接&quot;&gt;链接&lt;/h4&gt;
&lt;p&gt;链接是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。它可以分为：验证，准备和解析三个阶段。&lt;/p&gt;
&lt;p&gt;验证阶段：确保加载类能够满足 Java 虚拟机的约束条件。通常情况下，Java 编译器生成的类文件必然满足 Java 虚拟机的约束条件。（除了字节码注入）&lt;/p&gt;
&lt;p&gt;准备阶段：为被加载类的静态字段分配内存，初始化则会在初始化阶段进行。部分 Java 虚拟机还会在此阶段构造其他跟类层次相关的数据结构，比如说用来实现虚方法的动态绑定的方法表。&lt;/p&gt;
&lt;p&gt;在 class 文件被加载至 Java 虚拟机之前，这个类无法知道其他类以及其方法和字段所对应的具体地址，甚至不知道自己方法和字段的地址。当需要引用这些成员时，Java 编译器会生成一个符号引用，在运行阶段这些符号引用会定位到具体目标上。&lt;/p&gt;
&lt;p&gt;解析阶段就是将这些符号引用解析成为实际引用。&lt;/p&gt;
&lt;p&gt;Java 虚拟机规定：如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析。也就是说，在链接过程中不要求一定解析完成。&lt;/p&gt;
&lt;h4 id=&quot;初始化&quot;&gt;初始化&lt;/h4&gt;
&lt;p&gt;在 Java 代码中，初始化一个静态字段，可以声明时赋值，也可以在静态代码块中赋值。&lt;/p&gt;
&lt;p&gt;如果被赋值的静态字段被 final 修饰，并且它是基本类型或者字符串时，那么该字段便会被 Java 编译器标记成常量值，其初始化直接由 Java 虚拟机完成。除此之外的直接复制操作每一集静态代码块中的代码，都会被 Java 编译器置于同一方法中，命名为&lt;/p&gt;
&lt;p&gt;类的初始化，就是为标记常量的字段赋值，以及执行&lt;/p&gt;
&lt;p&gt;举例一下情况会触发类的初始化：&lt;br/&gt;1：虚拟机启动时，初始化用户指定的主类。&lt;br/&gt;2：遇到 new 指令时，初始化 new 指令的目标类。&lt;br/&gt;3：当遇到调用静态方法的指令时，初始化该静态方法所在的类。&lt;br/&gt;4：当遇到访问静态字段的指令时，初始化该静态方法所在的类。&lt;br/&gt;5：子类的初始化会触发父类的初始化。&lt;br/&gt;6：如果一个接口定义了 default 方法，那么实现该接口的类初始化时，会触发接口的初始化。&lt;br/&gt;7：使用反射 API 对某个类进行反射调用时，初始化该类。&lt;/p&gt;
&lt;h4 id=&quot;问答&quot;&gt;问答&lt;/h4&gt;
&lt;h6 id=&quot;q新建类和新建类的数组初始化过程&quot;&gt;Q：新建类，和新建类的数组，初始化过程&lt;/h6&gt;
&lt;p&gt;新建类的时候，需要加载，链接和初始化。新建类的数组的时候，由于并没有使用类，所以只需要加载该类。如果需要使用该类了，在执行类的链接和初始化。&lt;/p&gt;
&lt;h6 id=&quot;q类的初始化和实例的初始化区别初始化后的类存储在什么地方&quot;&gt;Q：类的初始化和实例的初始化区别，初始化后的类存储在什么地方&lt;/h6&gt;
&lt;p&gt;类的初始化只有一次，通过类的加载链接生成对应的数据结构，存储在元空间。实例的初始化可以有多次。&lt;/p&gt;
&lt;h6 id=&quot;q类中的静态字段如果没有被-jvm-标记为常量那么如何分配内存&quot;&gt;Q：类中的静态字段，如果没有被 JVM 标记为常量，那么如何分配内存&lt;/h6&gt;
&lt;p&gt;加载类的过程，都会分配内存，只是初始化的时候不一样：一个是在 JVM 中直接复制，一个是在 clinit 方法中复制。&lt;/p&gt;
&lt;h6 id=&quot;q-clinit-执行时的锁是什么锁跟-synchronized-一样吗&quot;&gt;Q clinit 执行时的锁，是什么锁，跟 synchronized 一样吗&lt;/h6&gt;
&lt;p&gt;clinit 执行时的锁是虚拟机内部锁，和 synchronized 不一样。&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;本文创作灵感来源于 极客时间 郑雨迪老师的《深入拆解 Java 虚拟机》课程，通过课后反思以及借鉴各位学友的发言总结，现整理出自己的知识架构，以便日后温故知新，查漏补缺。&lt;/p&gt;
&lt;h4 id=&quot;关注本人公众号第一时间获取最新文章发布每日更新一篇技术文章&quot;&gt;关注本人公众号，第一时间获取最新文章发布，每日更新一篇技术文章。&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1562380/201901/1562380-20190113225450069-1906096752.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 16 Jan 2019 15:12:00 +0000</pubDate>
<dc:creator>黑_子</dc:creator>
<og:description>Java 引用类型 Java 中的引用类型细分为四种：类，接口，数组类和泛型参数。 因为泛型参数会在编译过程中被擦除，所以 Java 虚拟机实际上只有前三种。数组类是由 Java 虚拟机直接生成的，其</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuepenglei/p/10279996.html</dc:identifier>
</item>
<item>
<title>浅谈c#垃圾回收机制（GC） - micDavid</title>
<link>http://www.cnblogs.com/wangqiang3311/p/10280000.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangqiang3311/p/10280000.html</guid>
<description>&lt;p&gt;写了一个window服务，循环更新sqlite记录，内存一点点稳步增长。三天后，内存溢出。于是，我从自己的代码入手，查找到底哪儿占用内存释放不掉，最终明确是调用servicestack.ormlite更新sqlite数据库造成的。至于是不是框架问题，可能性不大，因为本地模拟执行的代码没有任何问题。我觉得应该是orm在执行数据库更新后，对象还在被引用造成的。这里，我贴出一个伪代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放对象的一个列表&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; List&amp;lt;Record&amp;gt; data=&lt;span&gt;new&lt;/span&gt; List&amp;lt;Record&amp;gt;(&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
    
   &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; models =  ReadDB(&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;);
   data.AddRange(models);
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新model对象的字段&lt;/span&gt;&lt;span&gt;
   Dbhelp.UpdateAll(models);&lt;br/&gt;data.Clear();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我的猜测到底对不对呢？现在还不知道。不过在探寻答案的时候，对GC的相关机制详细地了解了一遍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/110779/201901/110779-20190116215435177-1156444218.png&quot; alt=&quot;&quot; width=&quot;1024&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、什么是GC？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;官网中有这么一句话：&lt;/p&gt;
&lt;p&gt;The garbage collector is a common language runtime component that controls the allocation and release of managed memory。&lt;/p&gt;
&lt;p&gt;原来GC是CLR的一个组件，它控制内存的分配与释放。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、托管堆和CLR堆管理器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们知道c#中的引用类型，分配在堆上。所谓的堆，就是一大块连续的内存地址。CLR堆管理器负责内存的分配、释放。堆又分为小对象堆和大对象堆。它的内存分配流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/110779/201901/110779-20190116221303847-920638576.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                  图片来源《.NET高级调试》pdf&lt;/p&gt;
&lt;p&gt;CLR加载时，就会分配堆。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 三、GC的工作机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;GC有三个假设：&lt;/p&gt;
&lt;p&gt;1、如果没有特别声明，所有的对象都是垃圾（通过引用追踪对象是否为垃圾）&lt;/p&gt;
&lt;p&gt;2、假设托管堆上所有的对象的活跃时间都是短暂的（相对于长久活跃的对象来说，GC将更频繁地收集短暂活跃的对象）&lt;/p&gt;
&lt;p&gt;3、通过代跟踪对象的持续时间&lt;/p&gt;
&lt;p&gt;以下是官方文档给出的和这三个假设一致&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;The garbage collector in the common language runtime supports object aging using generations&lt;/p&gt;
&lt;p&gt;Objects created more recently are part of newer generations, and have lower generation numbers than objects created earlier in the application life cycle. &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;Objects in the most recent generation are in generation 0. This implementation of the garbage collector supports three generations of objects, generations 0, 1, and 2&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;每代都有自己的堆，假如0代的堆满了，就会触发GC，然后把依然有引用的对象升级，放到1代对象。最后压缩堆，把剩余的堆空间合并到一块。1代对象也是如此操作。但到了2代，就处理不同了。2代的堆可能是大对象堆，它的压缩代价过于高昂，所以只是合并相邻的空间。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/110779/201901/110779-20190116223741347-863532123.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                                                    图片来源博客园&lt;strong&gt;c#技术漫谈之垃圾回收（GC）&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Garbage collection happens automatically when a request for memory cannot be satisfied using available free memory&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; GC发生的时机，就是相应的堆达到了阈值，因为堆也有大小限制，并不是无限的。尽管2代堆或者大对象堆满的时候，通过增加新的内存段来满足内存分配，如果没有可用的内存，这时就会报内存溢出。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、GC不能释放非托管资源&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有两种情况，第一种：托管代码引用了非托管资源，比如文件操作、数据库连接、网络连接等。这时候必须手动释放，或实现&lt;strong&gt; &lt;/strong&gt;dispose模式，或实现对象终结&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;When a type uses unmanaged resources that must be released before instances of the type are reclaimed, the type can implement a finalizer.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;In most cases, finalizers are implemented by overriding the &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.object.finalize?view=netframework-4.7.2&quot;&gt;Object.Finalize&lt;/a&gt; method; however, types written in C# or C++ implement &lt;strong&gt;destructors&lt;/strong&gt;, which compilers turn into an override of &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.object.finalize?view=netframework-4.7.2&quot;&gt;Object.Finalize&lt;/a&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;必须注意的一点是，实现对象终结器，GC会在释放对象之前自动调用。其实这是一个代价非常高昂的备用机制。所以能自己释放非托管资源的，就自己释放。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;如果一个对象中包含有终结器，那么在new的时候放入到终结者队列。当GC会把这个对象标为垃圾时，放入到另一个队列F-Reachable中。这个队列包含了所有带有终结器并且将被作为垃圾收集的对象，这些对象的终结器都将被执行。在垃圾收集的过程总并不会执行终结器代码。而是由.NET 进程的终结线程调用。因此，此时的垃圾回收滞后一段时间，目的在于等待终结器代码执行的完成。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;五、dispose模式&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseClass : IDisposable
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Flag: Has Dispose already been called?&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;    &lt;span&gt;bool&lt;/span&gt; disposed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;    
&lt;span&gt; 8&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Public implementation of Dispose pattern callable by consumers.&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Dispose()
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;   {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;       Dispose(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;       GC.SuppressFinalize(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);           
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;    
&lt;span&gt;15&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Protected implementation of Dispose pattern.&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Dispose(&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; disposing)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;   {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (disposed)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;          &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;       
&lt;span&gt;21&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (disposing) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Free any other managed objects here.
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;          &lt;span&gt;//
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;       
&lt;span&gt;26&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Free any unmanaged objects here.
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;       &lt;span&gt;//
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;       disposed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;    ~&lt;span&gt;BaseClass()
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;   {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;       Dispose(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Win32.SafeHandles;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Runtime.InteropServices;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DerivedClass : BaseClass
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Flag: Has Dispose already been called?&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;    &lt;span&gt;bool&lt;/span&gt; disposed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Instantiate a SafeHandle instance.&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;    SafeHandle handle = &lt;span&gt;new&lt;/span&gt; SafeFileHandle(IntPtr.Zero, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Protected implementation of Dispose pattern.&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Dispose(&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; disposing)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;   {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (disposed)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;          &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;       
&lt;span&gt;18&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (disposing) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;         handle.Dispose();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Free any other managed objects here.
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;          &lt;span&gt;//
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;       
&lt;span&gt;24&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Free any unmanaged objects here.
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;       &lt;span&gt;//
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;       disposed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Call base class implementation.&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;       &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.Dispose(disposing);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是基类和子类的dispose模式，来源于官网。&lt;/p&gt;
</description>
<pubDate>Wed, 16 Jan 2019 15:12:00 +0000</pubDate>
<dc:creator>micDavid</dc:creator>
<og:description>写了一个window服务，循环更新sqlite记录，内存一点点稳步增长。三天后，内存溢出。于是，我从自己的代码入手，查找到底哪儿占用内存释放不掉，最终明确是调用servicestack.ormlite</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangqiang3311/p/10280000.html</dc:identifier>
</item>
<item>
<title>我的2018前端踩坑集锦 - ChessZhang</title>
<link>http://www.cnblogs.com/yugege/p/10279990.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yugege/p/10279990.html</guid>
<description>&lt;p&gt;某著名小白说过 ：世上本来到处都是坑，只要走的人多了，也就把坑都给埋了。该小白还说过：坑本身并不可怕，可怕的是踩了一次之后，还第二、第三次踩到了相同的坑。&lt;/p&gt;
&lt;p&gt;所谓&quot;坑&quot;，主要是由于我们对某些知识点理解不够透彻，导致在应用的时出现了一些奇怪的问题。因为我们每个人，对于某个知识点的理解程度不一样，所以，有些坑我觉得真的很坑，但是你可能觉得一点都不坑，因为你早就对它了如指掌了。&lt;/p&gt;
&lt;p&gt;这里列举的一些坑，都是我过去一年在项目中所遇到过的，并当时在笔记中记录下来的，现在稍加整理就形成了这篇博客，以供日后查阅。&lt;/p&gt;
&lt;p&gt;不知不觉，开头又bb了这么多，还是赶紧进入正题哈。&lt;/p&gt;
&lt;h3 id=&quot;设置透明度opacity引起的惨案&quot;&gt;1. 设置透明度（opacity）引起的惨案&lt;/h3&gt;
&lt;p&gt;之前做炉石盒子的天梯环境页面，地址是 &lt;a href=&quot;https://hs.gameyw.netease.com/box_statistics.html&quot;&gt;炉石天梯环境&lt;/a&gt; ，就在项目做得差不多的时候，准备上线了， QA 突然发现了如下的一个 bug:&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/16/1685713e774598ee?w=107&amp;amp;h=190&amp;amp;f=png&amp;amp;s=29846&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有一个选择排序方式的下拉菜单，它的定位是 &lt;code&gt;position: absolute&lt;/code&gt;，正常来说，它应该会覆盖在其他元素之上的，可是为什么 &lt;code&gt;0.14%&lt;/code&gt; 反而会覆盖在它上面呢？ 在代码中找了好久，那个 &lt;code&gt;0.14%&lt;/code&gt; 并没有设置 &lt;code&gt;z-index&lt;/code&gt;属性，也没有 &lt;code&gt;position： absolute&lt;/code&gt; 这样的东西，真是好郁闷哦。后来到 mdn 查文档才发现，原来是 &lt;code&gt;opacity&lt;/code&gt;属性引起 的： &lt;code&gt;opacity 属性值小于 1 的元素会创建新的层叠上下文&lt;/code&gt; 。因为当时我有个偷懒的做法，字体继承的颜色是 &lt;code&gt;#666&lt;/code&gt;, 我想让 &lt;code&gt;0.14%&lt;/code&gt; （天梯比率）颜色变浅一些，直接加了个 &lt;code&gt;opacity: 0.6&lt;/code&gt; ，导致了创建了新的层叠上下文，层级比下拉菜单高了，所以就覆盖在了上面。具体什么是层叠上下文，以及哪些属性会创建新的层叠上下文，这里也不介绍了有需要的可以参考一下 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context&quot;&gt;层叠上下文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;虽然上面描述得已经很详细了，但是可能由于我的表达能力不太好，有些朋友还不是很明白我的意思，可以看一下这里的 demo 代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div class=&quot;menu&quot;&amp;gt;
  &amp;lt;div class=&quot;title&quot;&amp;gt;下拉菜单&amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;menu-list&quot;&amp;gt;
    &amp;lt;div class=&quot;item&quot;&amp;gt;菜单1&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;item&quot;&amp;gt;菜单2&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;item&quot;&amp;gt;菜单3&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;content&quot;&amp;gt;
  我是半透明的文字，可以覆盖在下拉菜单之上哦~
&amp;lt;/div&amp;gt;
&amp;lt;style&amp;gt;
  .menu {
    position: relative;
  }
  .menu-list {
    display: none;
    position: absolute;
    background: #ccc;
  }
  .menu:hover .menu-list {
    display: block;
  }
  .content {
    opacity: 0.6;
  }
&amp;lt;/style&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将鼠标移动到下拉菜单上，就会发现文字会发生重叠了：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/16/1685715a85978e8a?w=385&amp;amp;h=121&amp;amp;f=png&amp;amp;s=8914&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那这个坑有什么解决办法呢？最简单的就是下拉菜单添加个属性 &lt;code&gt;z-index： 1&lt;/code&gt; 。另外，这里再啰嗦一下，就是&lt;code&gt;z-index&lt;/code&gt;的值不要乱设置。以前刚刚接触前端时，会经常看一些视频教程，看到里面讲师动不动就设置个 &lt;code&gt;z-index: 999&lt;/code&gt; 之类的特别大的数值。这是一个不好的习惯。张鑫旭老师在《CSS世界》一书中，提到了 &lt;code&gt;不三原则&lt;/code&gt;，就是说一般情况下，&lt;code&gt;z-index&lt;/code&gt;的值不要超过3，基本能满足大多数的需求了。&lt;/p&gt;
&lt;h3 id=&quot;flex布局子项溢出后无法查看全部内容&quot;&gt;2. flex布局：子项溢出后无法查看全部内容&lt;/h3&gt;
&lt;p&gt;之前做漫画阅读器，因为漫画可能有长图片，也可能有短图片。长图片可以滚动查看，短图片就居中显示。所以，很自然会想到用 &lt;code&gt;flex&lt;/code&gt; 布局来实现。简单的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div class=&quot;app&quot;&amp;gt;
  &amp;lt;img src=&quot;https://m.tuniucdn.com/fb2/t1/G1/M00/F1/51/Cii9EFkAaZ-IRgGNAATB18ldk0UAAJzuQN-p1cABMHv15.jpeg&quot; alt=&quot;&quot;&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;style&amp;gt;

  html,
  body {
    height: 100%;
  }

  .app {
    display: flex;
    height: 100%;
    justify-content: center;
    align-items: center;
  }

  img {
    width: 100%;
  }
&amp;lt;/style&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，我们的&lt;code&gt;.app&lt;/code&gt; 容器里面这里有一张很长的图片。当我们运行上面的代码，如果你仔细观察原图和页面显示的图片，就会发现图片的顶部和底部的一些内容看不到了，滚动条到了一定位置就无法滚动了。正常来说，我们应该可以通过滚动条的上下滑动看到图片的全部内容才对的。当时我想了很久也没有想出来原因，最后到 stackoverflow 找到了答案 &lt;a href=&quot;https://stackoverflow.com/questions/33454533/cant-scroll-to-top-of-flex-item-that-is-overflowing-container&quot;&gt;Can't scroll to top of flex item that is overflowing container&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;答案中有提到，可以设置子项的 &lt;code&gt;margin: auto&lt;/code&gt; 来实现内容溢出时也自动居中（包括水平和垂直的）：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/16/168571653642b293?w=700&amp;amp;h=369&amp;amp;f=png&amp;amp;s=30848&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改后的 CSS 代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  .app {
    display: flex;
    height: 100%;
  }

  img {
    width: 100%;
    margin: auto;
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，以后如果在使用 &lt;code&gt;flex&lt;/code&gt; 布局实现居中，如果子项的内容会溢出 &lt;code&gt;flex容器&lt;/code&gt; ，可以将子项设置为 &lt;code&gt;margin: auto&lt;/code&gt;试试。&lt;/p&gt;
&lt;h3 id=&quot;transfrom-和-fixed-不能在一起&quot;&gt;3. transfrom 和 fixed 不能在一起！&lt;/h3&gt;
&lt;p&gt;CSS3 的 &lt;code&gt;transform&lt;/code&gt; 属性也算是比较常用的，特别是做一些动画效果的时候，用它来移动元素的位置，性能会比设置 &lt;code&gt;top&lt;/code&gt; 或 &lt;code&gt;left&lt;/code&gt; 要高一些。但是，如果一个元素设置了 &lt;code&gt;transform&lt;/code&gt; 属性，而它的子元素又设置 &lt;code&gt;fixed&lt;/code&gt; 定位，那么这个 &lt;code&gt;fixed&lt;/code&gt; 定位的子元素表现会有些奇怪，如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div class=&quot;app&quot;&amp;gt;
  &amp;lt;button onclick=&quot;layer.style.display='block'&quot;&amp;gt;弹出蒙层&amp;lt;/button&amp;gt;
  &amp;lt;div class=&quot;layer&quot; id=&quot;layer&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;style&amp;gt;
  .app {
    position: relative;
    width: 100px;
    height: 100px;
    background: #ccc;
    /* 使用transform让元素向下偏移20px */
    transform: translate(0, 20px);
  }

  .layer {
    display: none;
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    background: rgba(0, 0, 0, 0.7);
  }
&amp;lt;/style&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打开页面，效果是这样的：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/16/168571f923e087bd?w=398&amp;amp;h=212&amp;amp;f=png&amp;amp;s=7923&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们希望点击“弹出蒙层”按钮后，就显示个覆盖整个窗口的蒙层。但是结果却出乎意料。如下：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/16/168571fe8aee2212?w=396&amp;amp;h=264&amp;amp;f=png&amp;amp;s=8408&quot;/&gt;&lt;/p&gt;
&lt;p&gt;蒙层只是遮住了小正方形，这不是我们想要的结果，因为我们知道，&lt;code&gt;fixed&lt;/code&gt; 定位是相对于屏幕视口（&lt;code&gt;viewport&lt;/code&gt;）定位的, 但是,本例却相对于它的父亲元素。这是为什么呢？如果认真查阅 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/CSS/position&quot;&gt;mdn文档&lt;/a&gt; ，就会找到答案：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/16/16857204a74f0e8c?w=732&amp;amp;h=144&amp;amp;f=png&amp;amp;s=27038&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可见，问题的原因在于，我们只是记住了fixed是相对于 &lt;code&gt;viewport&lt;/code&gt; 定位，但是也有特殊情况: &lt;code&gt;当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先&lt;/code&gt; 。所以，这并不是bug，是因为我基础不扎实导致的。事实上， 除了 &lt;code&gt;transform&lt;/code&gt; 会改变 &lt;code&gt;fixed&lt;/code&gt; 的定位元素之外，还有其他属性也会改变，ChokCoco大佬有一篇文章做了详细的讲解，想要了解更多的请点击 &lt;a href=&quot;https://www.cnblogs.com/coco1s/p/7358830.html&quot;&gt;不受控制的 position:fixed&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;那遇到这种情况怎么办呢？比较好的办法就是把 &lt;code&gt;fixed&lt;/code&gt; 元素移到外面去，不要放到有 &lt;code&gt;transform&lt;/code&gt; 属性的元素里面。但是，有时候我们没有办法移到外面怎么办呢？比如，这是它是一个子组件，它的某个父亲组件就是用了 &lt;code&gt;transform&lt;/code&gt;，那怎么办呢？我也不知道怎么办，欢迎大家探讨一下哈哈哈~&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fixed&lt;/code&gt; 定位还具有其他的坑，这里也不展开了，有兴趣的可看看github上有大佬整理好的这篇文章 &lt;a href=&quot;https://github.com/maxzhang/maxzhang.github.com/issues/2&quot;&gt;移动端web页面使用position:fixed问题总结&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;安卓微信视频播放器的层级问题&quot;&gt;4. 安卓微信视频播放器的层级问题&lt;/h3&gt;
&lt;p&gt;我们都知道， &lt;code&gt;video&lt;/code&gt; 标签设置了 &lt;code&gt;playsinline&lt;/code&gt; 就可以内联播放视频，而不是全屏播放。（注意：前提是客户端的 &lt;code&gt;Webview&lt;/code&gt; 配置了允许内联播放，所以有时候虽然设置了 &lt;code&gt;playsinline&lt;/code&gt;，但在某些app里面打开依然是全屏播放，这不是前端的锅哦）。最近有一个需求，类似下面这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/16/1685710261db834a?w=485&amp;amp;h=239&amp;amp;f=png&amp;amp;s=80794&quot;/&gt;&lt;/p&gt;
&lt;p&gt;页面上有一个视频，视频播下面有一个按钮，点击按钮就弹出一个图片，该图片要覆盖整个屏幕，比如是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/16/1685710a4826b327?w=376&amp;amp;h=439&amp;amp;f=png&amp;amp;s=309640&quot;/&gt;&lt;/p&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;video id=&quot;video&quot; controls=&quot;&quot; playsinline=&quot;&quot; src=&quot;https://vod.cc.163.com/file/5bcbe1ae9efdc0608bb6d06b.mp4&quot;&amp;gt;&amp;lt;/video&amp;gt;
&amp;lt;img id=&quot;image&quot; src=&quot;https://ds.163.com/2018/mrzh/appointment/static/img/bg-body.cdef1ec.jpg&quot; alt=&quot;&quot;&amp;gt;
&amp;lt;button id=&quot;button&quot;&amp;gt;弹出图片&amp;lt;/button&amp;gt;
&amp;lt;style&amp;gt;
  video,
  img {
    width: 100%;
  }

  img {
    display: none;
    position: absolute;
    top: 0;
  }
&amp;lt;/style&amp;gt;

&amp;lt;script&amp;gt;
  var video = document.getElementById('video');
  var image = document.getElementById('image');
  var button = document.getElementById('button');
  button.onclick = function() {
    image.style.display='block';
  }
  image.onclick = function() {
    this.style.display='none';
  }
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，在安卓上却发现一个问题，开始播放视频后（注意，只有播放视频后才可以复现），点击“弹出图片”按钮，显示如下所示：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/16/16857122e41d2edc?w=503&amp;amp;h=538&amp;amp;f=png&amp;amp;s=404373&quot;/&gt;&lt;br/&gt;图片无法覆盖在视频播放器上面。然后，我设置了 &lt;code&gt;z-index&lt;/code&gt; 或者 &lt;code&gt;transform&lt;/code&gt; ，都没有任何效果。最后， 剩下的可能原因就是: 安卓微信视频播放器实际上用的是原生组件。为了验证这一猜想，我们可以启用开发者选项的绘图模式（开发者选项 --&amp;gt; 绘图 --&amp;gt; 显示布局边界，不同机型不一样，找不到的请百度找一下哈），结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/16/1685713414f1835e?w=679&amp;amp;h=539&amp;amp;f=png&amp;amp;s=427662&quot;/&gt;&lt;br/&gt;看到没有，视频是一个完整的有边框的东西，证明他是一个独立于 &lt;code&gt;Webview&lt;/code&gt; 的原生组件。&lt;/p&gt;
&lt;p&gt;那怎么办呢？只能上网找答案呀！我们都知道，微信 &lt;code&gt;webview&lt;/code&gt; 使用的是 &lt;code&gt;X5&lt;/code&gt; 内核，所以我也希望能从它的开发者文档上找到一些有用的信息，好不容易找到了一篇叫做 &lt;a href=&quot;https://x5.tencent.com/tbs/guide/video.html&quot;&gt;H5同层播放器接入规范&lt;/a&gt; 。它说可以可以在 &lt;code&gt;video&lt;/code&gt; 标签添加一个属性 &lt;code&gt;x5-video-player-type&lt;/code&gt; ，并且给出的例子是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;video src=&quot;http://xxx.mp4&quot; x5-video-player-type=&quot;h5&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我当时很高兴，以为问题就这样解决了，然并卵，添加了 &lt;code&gt;x5-video-layer-type&lt;/code&gt; 属性之后，&lt;code&gt;playsinlie&lt;/code&gt; 属性就失效了，无法内联播放了，只能全屏播放，所以，不能添加这个属性。&lt;/p&gt;
&lt;p&gt;然后我就想，既然无法覆盖这个视频，那在弹出图片的时候能不能把视频给隐藏掉？然后关闭图片的时候再把视频显示回来呢？于是就把 JS 代码改成下面这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  button.onclick = function() {
    image.style.display='block';
    video.style.display = 'none';
  }
  image.onclick = function() {
    this.style.display='none';
    video.style.display = 'block';
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，这样就可以了。因为我在网上找不到更好的办法，如果大家遇到这个问题可以参考这种做法。当然，如果你们找到了有更好的办法，欢迎评论分享出来哈~&lt;/p&gt;
&lt;p&gt;关于安卓微信视频播放器的坑就先讲到这里啦。&lt;/p&gt;
&lt;p&gt;等等，一讲到原生组件，这里还得再补充一下微信小程序相关的东西，当然，我自己还没有过小程序的开发的经验, 这是之前的一次内部交流会，一位同事的分享：小程序在渲染的时候，大多数组件都是渲染成 &lt;code&gt;HTML&lt;/code&gt; 组件，但是有少部分比如 &lt;code&gt;canvas&lt;/code&gt;、 &lt;code&gt;video&lt;/code&gt;、 &lt;code&gt;input&lt;/code&gt;、 &lt;code&gt;map&lt;/code&gt; 等会渲染成原生组件的。所以，如果你在写小程序时，想用一段文字覆盖在一个 &lt;code&gt;canvas&lt;/code&gt; 上，发现怎么设置都无法实现，那是因为 &lt;code&gt;canvas&lt;/code&gt; 渲染后是原生组件，而文字是 &lt;code&gt;html&lt;/code&gt; 组件，所以无法覆盖上去的 。那有什么办法呢？可以考虑把文字放到　&lt;code&gt;cover-view&lt;/code&gt; 上，　它也是一种原生组件，可以覆盖在　&lt;code&gt;canvas&lt;/code&gt; 上的。具体的可以参考小程序官方文档 &lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/component/native-component.html&quot;&gt;原生组件说明&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于2018踩的坑就写到这里了，当然还有一些其他的，暂时没有时间整理，下次如果整理后，再写一篇补充一下。&lt;/p&gt;
&lt;p&gt;如果大家有什么问题，或者过去踩到过了哪些坑，欢迎在评论区讨论哈。&lt;/p&gt;
</description>
<pubDate>Wed, 16 Jan 2019 15:10:00 +0000</pubDate>
<dc:creator>ChessZhang</dc:creator>
<og:description>某著名小白说过 ：世上本来到处都是坑，只要走的人多了，也就把坑都给埋了。该小白还说过：坑本身并不可怕，可怕的是踩了一次之后，还第二、第三次踩到了相同的坑。 所谓'坑'，主要是由于我们对某些知识点理解不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yugege/p/10279990.html</dc:identifier>
</item>
<item>
<title>万物互联之~RPC专栏 - 毒逆天</title>
<link>http://www.cnblogs.com/dunitian/p/10279946.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dunitian/p/10279946.html</guid>
<description>&lt;p&gt;其他专栏最新篇：&lt;a href=&quot;https://mp.weixin.qq.com/s/Alv0Ds9LDvWbWSNgOgG43A&quot;&gt;协程加强之~兼容答疑篇&lt;/a&gt; | &lt;a href=&quot;https://www.cnblogs.com/dotnetcrazy/p/9887708.html&quot;&gt;聊聊数据库~SQL环境篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上篇回顾：&lt;a href=&quot;https://mp.weixin.qq.com/s/KbiAz3Z3yyyKRHws1WW6vg&quot;&gt;万物互联之~深入篇&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;rpc引入&quot;&gt;3.RPC引入&lt;/h2&gt;
&lt;p&gt;Code：&lt;a href=&quot;https://github.com/lotapp/BaseCode/tree/master/python/6.net/6.rpc/&quot; class=&quot;uri&quot;&gt;https://github.com/lotapp/BaseCode/tree/master/python/6.net/6.rpc/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;概念&quot;&gt;3.1.概念&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;RPC&lt;/code&gt;(&lt;code&gt;Remote Procedure Call&lt;/code&gt;)：分布式系统常见的一种通信方法（&lt;strong&gt;远程过程调用&lt;/strong&gt;），通俗讲：&lt;strong&gt;可以一台计算机的程序调用另一台计算机的子程序&lt;/strong&gt;（可以把它看成之前我们说的进程间通信，只不过这一次的进程不在同一台PC上了）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PS：&lt;code&gt;RPC&lt;/code&gt;的设计思想是力图使远程调用中的通讯细节对于使用者透明，调用双方无需关心网络通讯的具体实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;引用一张网上的图:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201901/1127869-20190116092121587-579261271.png&quot; alt=&quot;1.rpc.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;和&lt;code&gt;HTTP&lt;/code&gt;有点相似，你可以这样理解：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;老版本的&lt;code&gt;HTTP/1.0&lt;/code&gt;是短链接，而&lt;code&gt;RPC&lt;/code&gt;是长连接进行通信
&lt;ul&gt;&lt;li&gt;HTTP协议（header、body），RPC可以采取HTTP协议，也可以自定义二进制格式&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;后来&lt;code&gt;HTTP/1.1&lt;/code&gt;支持了长连接(&lt;code&gt;Connection:keep-alive&lt;/code&gt;)，基本上和&lt;code&gt;RPC&lt;/code&gt;差不多了
&lt;ul&gt;&lt;li&gt;但&lt;strong&gt;&lt;code&gt;keep-alive&lt;/code&gt;一般都限制有最长时间，或者最多处理的请求数，而&lt;code&gt;RPC&lt;/code&gt;是基于长连接的，基本上没有这个限制&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;后来谷歌直接基于&lt;code&gt;HTTP/2.0&lt;/code&gt;建立了&lt;code&gt;gRPC&lt;/code&gt;，它们之间的基本上也就差不多了
&lt;ul&gt;&lt;li&gt;如果硬是要区分就是：&lt;strong&gt;&lt;code&gt;HTTP-普通话&lt;/code&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;code&gt;RPC-方言&lt;/code&gt;&lt;/strong&gt;的区别了&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RPC高效而小众，HTTP效率没RPC高，但更通用&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;PS：&lt;strong&gt;&lt;code&gt;RPC&lt;/code&gt;和&lt;code&gt;HTTP&lt;/code&gt;调用不用经过中间件，而是端到端的直接数据交互&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;网络交互可以理解为基于&lt;code&gt;Socket&lt;/code&gt;实现的（&lt;code&gt;RPC&lt;/code&gt;、&lt;code&gt;HTTP&lt;/code&gt;都是&lt;code&gt;Socket&lt;/code&gt;的读写操作）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;简单概括一下&lt;code&gt;RPC&lt;/code&gt;的优缺点就是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;优点：
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;效率更高&lt;/strong&gt;（可以自定义二进制格式）&lt;/li&gt;
&lt;li&gt;发起RPC调用的一方，在编写代码时可忽略RPC的具体实现（&lt;strong&gt;跟编写本地函数调用一般&lt;/strong&gt;）&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;通用性不如HTTP&lt;/strong&gt;（方言普及程度肯定不如普通话），如果传输协议不是HTTP协议格式，调用双方就需要专门实现通信库&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;PS：HTTP更多是&lt;code&gt;Client&lt;/code&gt;与&lt;code&gt;Server&lt;/code&gt;的通讯;&lt;code&gt;RPC&lt;/code&gt;更多是内部服务器间的通讯&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;引入&quot;&gt;3.2.引入&lt;/h3&gt;
&lt;p&gt;上面说这么多，可能还没有来个案例实在，我们看个案例：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本地调用&lt;code&gt;sum()&lt;/code&gt;&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;def sum(a, b):
    &quot;&quot;&quot;return a+b&quot;&quot;&quot;
    return a + b

def main():
    result = sum(1, 2)
    print(f&quot;1+2={result}&quot;)

if __name__ == &quot;__main__&quot;:
    main()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：（这个大家都知道）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1+2=3&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;xmlrpc案例&quot;&gt;1.xmlrpc案例&lt;/h4&gt;
&lt;p&gt;官方文档：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://docs.python.org/3/library/xmlrpc.client.html
https://docs.python.org/3/library/xmlrpc.server.html&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;都说&lt;code&gt;RPC&lt;/code&gt;用起来就像本地调用一样，那么用起来啥样呢？看个案例：&lt;/p&gt;
&lt;p&gt;服务端：(&lt;strong&gt;CentOS7：&lt;code&gt;192.168.36.123:50051&lt;/code&gt;&lt;/strong&gt;)&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;from xmlrpc.server import SimpleXMLRPCServer

def sum(a, b):
    &quot;&quot;&quot;return a+b&quot;&quot;&quot;
    return a + b

# PS：50051是gRPC默认端口
server = SimpleXMLRPCServer(('', 50051))
# 把函数注册到RPC服务器中
server.register_function(sum)
print(&quot;Server启动ing，Port：50051&quot;)
server.serve_forever()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端：（&lt;strong&gt;Win10：&lt;code&gt;192.168.36.144&lt;/code&gt;&lt;/strong&gt;）&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;from xmlrpc.client import ServerProxy

stub = ServerProxy(&quot;http://192.168.36.123:50051&quot;)
result = stub.sum(1, 2)
print(f&quot;1+2={result}&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：（&lt;code&gt;Client&lt;/code&gt;用起来是不是和本地差不多？就是通过代理访问了下&lt;code&gt;RPCServer&lt;/code&gt;而已）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1+2=3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201901/1127869-20190116103749140-1803787161.png&quot; alt=&quot;2.server.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS：&lt;code&gt;CentOS&lt;/code&gt;服务器不是你绑定个端口就一定能访问的，如果不能记让&lt;strong&gt;防火墙开放对应的端口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个之前在说&lt;code&gt;MariaDB&lt;/code&gt;环境的时候有详细说：&lt;a href=&quot;https://www.cnblogs.com/dotnetcrazy/p/9887708.html#_map4&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/dotnetcrazy/p/9887708.html#_map4&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 添加 --permanent永久生效(没有此参数重启后失效)
firewall-cmd --zone=public --add-port=80/tcp --permanent&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;zerorpc案例&quot;&gt;2.ZeroRPC案例：&lt;/h4&gt;
&lt;p&gt;zeroRPC用起来和这个差不多，也简单举个例子吧：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;把服务的某个方法注册到&lt;code&gt;RPCServer&lt;/code&gt;中，供外部服务调用&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;import zerorpc

class Test(object):
    def say_hi(self, name):
        return f&quot;Hi，My Name is{name}&quot;


# 注册一个Test的实例
server = zerorpc.Server(Test())
server.bind(&quot;tcp://0.0.0.0:50051&quot;)
server.run()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;调用服务端代码&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;import zerorpc

client = zerorpc.Client(&quot;tcp://192.168.36.123:50051&quot;)
result = client.say_hi(&quot;RPC&quot;)
print(result)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;简单版自定义rpc&quot;&gt;3.3.简单版自定义RPC&lt;/h3&gt;
&lt;p&gt;看了上面的引入案例，是不是感觉&lt;code&gt;RPC&lt;/code&gt;不过如此？NoNoNo，要是真这么简单也就谈不上&lt;code&gt;RPC架构&lt;/code&gt;了，上面两个是最简单的RPC服务了，可以这么说：生产环境基本上用不到，只能当案例练习罢了，对Python来说，最常用的RPC就两个&lt;strong&gt;&lt;code&gt;gRPC&lt;/code&gt; and &lt;code&gt;Thrift&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PS：国产最出名的是&lt;strong&gt;&lt;code&gt;Dubbo&lt;/code&gt; and &lt;code&gt;Tars&lt;/code&gt;&lt;/strong&gt;，Net最常用的是&lt;code&gt;gRPC&lt;/code&gt;、&lt;code&gt;Thrift&lt;/code&gt;、&lt;code&gt;Surging&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;rpc服务的流程&quot;&gt;1.RPC服务的流程&lt;/h4&gt;
&lt;p&gt;要自己实现一个&lt;code&gt;RPC Server&lt;/code&gt;那么就得了解整个流程了：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;Client&lt;/code&gt;（调用者）以本地调用的方式发起调用&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;RPC&lt;/code&gt;服务进行&lt;strong&gt;远程过程调用&lt;/strong&gt;（RPC的目标就是要把这些步骤都封装起来，让使用者感觉不到这个过程）
&lt;ol&gt;&lt;li&gt;客户端的&lt;code&gt;RPC Proxy&lt;/code&gt;组件收到调用后，负责&lt;strong&gt;将被调用的&lt;code&gt;方法名、参数&lt;/code&gt;等打包编码成自定义的协议&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;客户端的&lt;code&gt;RPC Proxy&lt;/code&gt;组件在打包完成后通过网络把数据包发送给&lt;code&gt;RPC Server&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;服务端的&lt;code&gt;RPC Proxy&lt;/code&gt;组件把通过网络接收到的数据包按照相应格式进行&lt;strong&gt;&lt;code&gt;拆包解码&lt;/code&gt;，获取方法名和参数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;服务端的&lt;code&gt;RPC Proxy&lt;/code&gt;组件&lt;strong&gt;根据方法名和参数进行本地调用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;RPC Server&lt;/code&gt;&lt;/strong&gt;（被调用者）本地执行后将结果返回给服务端的&lt;code&gt;RPC Proxy&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;服务端的&lt;code&gt;RPC Proxy&lt;/code&gt;组件将返回值打包编码成自定义的协议数据包，并通过网络发送给客户端的&lt;code&gt;RPC Proxy&lt;/code&gt;组件&lt;/li&gt;
&lt;li&gt;客户端的&lt;code&gt;RPC Proxy&lt;/code&gt;组件收到数据包后，进行拆包解码，把数据返回给&lt;code&gt;Client&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Client&lt;/code&gt;（调用者）得到本次&lt;code&gt;RPC&lt;/code&gt;调用的返回结果&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;用一张时序图来描述下整个过程：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201901/1127869-20190116224934398-1277123948.png&quot; alt=&quot;4.时序图.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS：&lt;code&gt;RPC Proxy&lt;/code&gt;有时候也叫&lt;code&gt;Stub&lt;/code&gt;（存根）：(Client Stub，Server Stub)&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;为屏蔽客户调用远程主机上的对象，必须提供某种方式来模拟本地对象,这种本地对象称为存根(stub),存根负责接收本地方法调用,并将它们委派给各自的具体实现对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;PRC服务实现的过程中其实就两核心点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;消息协议：客户端调用的参数和服务端的返回值这些在网络上传输的数据以何种方式打包编码和拆包解码
&lt;ul&gt;&lt;li&gt;经典代表：&lt;strong&gt;&lt;code&gt;Protocol Buffers&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;传输控制：在网络中数据的收发传输控制具体如何实现（&lt;code&gt;TCP/UDP/HTTP&lt;/code&gt;）&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;手写rpc&quot;&gt;2.手写RPC&lt;/h4&gt;
&lt;p&gt;下面我们就根据上面的流程来手写一个简单的RPC：&lt;/p&gt;
&lt;p&gt;1.Client调用：&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;# client.py
from client_stub import ClientStub

def main():
    stub = ClientStub((&quot;192.168.36.144&quot;, 50051))

    result = stub.get(&quot;sum&quot;, (1, 2))
    print(f&quot;1+2={result}&quot;)

    result = stub.get(&quot;sum&quot;, (1.1, 2))
    print(f&quot;1.1+2={result}&quot;)

    time_str = stub.get(&quot;get_time&quot;)
    print(time_str)

if __name__ == &quot;__main__&quot;:
    main()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1+2=3
1.1+2.2=3.1
Wed Jan 16 22&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.Client Stub，客户端存根：(主要有&lt;code&gt;打包&lt;/code&gt;、&lt;code&gt;解包&lt;/code&gt;、和&lt;code&gt;RPC服务器通信&lt;/code&gt;的方法)&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;# client_stub.py
import socket

class ClientStub(object):
    def __init__(self, address):
        &quot;&quot;&quot;address ==&amp;gt; (ip,port)&quot;&quot;&quot;
        self.socket = socket.socket()
        self.socket.connect(address)

    def convert(self, obj):
        &quot;&quot;&quot;根据类型转换成对应的类型编号&quot;&quot;&quot;
        if isinstance(obj, int):
            return 1
        if isinstance(obj, float):
            return 2
        if isinstance(obj, str):
            return 3

    def pack(self, func, args):
        &quot;&quot;&quot;打包：把方法和参数拼接成自定义的协议
        格式：func:函数名@params:类型-参数,类型2-参数2...
        &quot;&quot;&quot;
        result = f&quot;func:{func}&quot;
        if args:
            params = &quot;&quot;
            # params:类型-参数,类型2-参数2...
            for item in args:
                params += f&quot;{self.convert(item)}-{item},&quot;
            # 去除最后一个,
            result += f&quot;@params:{params[:-1]}&quot;
        # print(result)  # log 输出
        return result.encode(&quot;utf-8&quot;)

    def unpack(self, data):
        &quot;&quot;&quot;解包：获取返回结果&quot;&quot;&quot;
        msg = data.decode(&quot;utf-8&quot;)
        # 格式应该是&quot;data:xxxx&quot;
        params = msg.split(&quot;:&quot;)
        if len(params) &amp;gt; 1:
            return params[1]
        return None

    def get(self, func, args=None):
        &quot;&quot;&quot;1.客户端的RPC Proxy组件收到调用后，负责将被调用的方法名、参数等打包编码成自定义的协议&quot;&quot;&quot;
        data = self.pack(func, args)
        # 2.客户端的RPC Proxy组件在打包完成后通过网络把数据包发送给RPC Server
        self.socket.send(data)
        # 等待服务端返回结果
        data = self.socket.recv(2048)
        if data:
            return self.unpack(data)
        return None&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简要说明下：（我根据流程在Code里面标注了，看起来应该很轻松）&lt;/p&gt;
&lt;p&gt;之前有说到核心其实就是&lt;code&gt;消息协议&lt;/code&gt;and&lt;code&gt;传输控制&lt;/code&gt;，我&lt;code&gt;客户端存根&lt;/code&gt;的消息协议是自定义的格式（后面会说简化方案）：&lt;strong&gt;&lt;code&gt;func:函数名@params:类型-参数,类型2-参数2...&lt;/code&gt;&lt;/strong&gt;，传输我是基于TCP进行了简单的封装&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;3.Server端：（实现很简单）&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;# server.py
import socket
from server_stub import ServerStub

class RPCServer(object):
    def __init__(self, address, mycode):
        self.mycode = mycode
        # 服务端存根（RPC Proxy）
        self.server_stub = ServerStub(mycode)
        # TCP Socket
        self.socket = socket.socket()
        # 端口复用
        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        # 绑定端口
        self.socket.bind(address)

    def run(self):
        self.socket.listen()
        while True:
            # 等待客户端连接
            client_socket, client_addr = self.socket.accept()
            print(f&quot;来自{client_addr}的请求：\n&quot;)
            # 交给服务端存根（Server Proxy）处理
            self.server_stub.handle(client_socket, client_addr)

if __name__ == &quot;__main__&quot;:
    from server_code import MyCode
    server = RPCServer(('', 50051), MyCode())
    print(&quot;Server启动ing，Port：50051&quot;)
    server.run()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了简洁，服务端代码我单独放在了&lt;code&gt;server_code.py&lt;/code&gt;中：&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;# 5.RPC Server（被调用者）本地执行后将结果返回给服务端的RPC Proxy
class MyCode(object):
    def sum(self, a, b):
        return a + b

    def get_time(self):
        import time
        return time.ctime()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.然后再看看重头戏&lt;code&gt;Server Stub&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;# server_stub.py
import socket

class ServerStub(object):
    def __init__(self, mycode):
        self.mycode = mycode

    def convert(self, num, obj):
        &quot;&quot;&quot;根据类型编号转换类型&quot;&quot;&quot;
        if num == &quot;1&quot;:
            obj = int(obj)
        if num == &quot;2&quot;:
            obj = float(obj)
        if num == &quot;3&quot;:
            obj = str(obj)
        return obj

    def unpack(self, data):
        &quot;&quot;&quot;3.服务端的RPC Proxy组件把通过网络接收到的数据包按照相应格式进行拆包解码，获取方法名和参数&quot;&quot;&quot;
        msg = data.decode(&quot;utf-8&quot;)
        # 格式应该是&quot;格式：func:函数名@params:类型编号-参数,类型编号2-参数2...&quot;
        array = msg.split(&quot;@&quot;)
        func = array[0].split(&quot;:&quot;)[1]
        if len(array) &amp;gt; 1:
            args = list()
            for item in array[1].split(&quot;:&quot;)[1].split(&quot;,&quot;):
                temps = item.split(&quot;-&quot;)
                # 类型转换
                args.append(self.convert(temps[0], temps[1]))
            return (func, tuple(args))  # (func,args)
        return (func, )

    def pack(self, result):
        &quot;&quot;&quot;打包：把方法和参数拼接成自定义的协议&quot;&quot;&quot;
        # 格式：&quot;data:返回值&quot;
        return f&quot;data:{result}&quot;.encode(&quot;utf-8&quot;)

    def exec(self, func, args=None):
        &quot;&quot;&quot;4.服务端的RPC Proxy组件根据方法名和参数进行本地调用&quot;&quot;&quot;
        # 如果没有这个方法则返回None
        func = getattr(self.mycode, func, None)
        if args:
            return func(*args)  # 解包
        else:
            return func()  # 无参函数

    def handle(self, client_socket, client_addr):
        while True:
            # 获取客户端发送的数据包
            data = client_socket.recv(2048)
            if data:
                try:
                    data = self.unpack(data)  # 解包
                    if len(data) == 1:
                        data = self.exec(data[0])  # 执行无参函数
                    elif len(data) &amp;gt; 1:
                        data = self.exec(data[0], data[1])  # 执行带参函数
                    else:
                        data = &quot;RPC Server Error Code:500&quot;
                except Exception as ex:
                    data = &quot;RPC Server Function Error&quot;
                    print(ex)
                # 6.服务端的RPC Proxy组件将返回值打包编码成自定义的协议数据包，并通过网络发送给客户端的RPC Proxy组件
                data = self.pack(data)  # 把函数执行结果按指定协议打包
                # 把处理过的数据发送给客户端
                client_socket.send(data)
            else:
                print(f&quot;客户端：{client_addr}已断开\n&quot;)
                break&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再简要说明一下：&lt;strong&gt;里面方法其实主要就是&lt;code&gt;解包&lt;/code&gt;、&lt;code&gt;执行函数&lt;/code&gt;、&lt;code&gt;返回值打包&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出图示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201901/1127869-20190116223931438-2073811968.png&quot; alt=&quot;3.div.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再贴一下上面的时序图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201901/1127869-20190116224934398-1277123948.png&quot; alt=&quot;4.时序图.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;课外拓展：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;HTTP1.0、HTTP1.1 和 HTTP2.0 的区别
https://www.cnblogs.com/heluan/p/8620312.html

简述分布式RPC框架
https://blog.csdn.net/jamebing/article/details/79610994

分布式基础—RPC
http://www.dataguru.cn/article-14244-1.html&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下节预估：&lt;strong&gt;RPC服务进一步简化与演变&lt;/strong&gt;、&lt;strong&gt;手写一个简单的REST接口&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 16 Jan 2019 15:00:00 +0000</pubDate>
<dc:creator>毒逆天</dc:creator>
<og:description>其他专栏最新篇：协程加强之~兼容答疑篇 | 聊聊数据库~SQL环境篇 上篇回顾：万物互联之~深入篇 3.RPC引入 Code： 3.1.概念 (`Remote Procedure Call`)：分布式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dunitian/p/10279946.html</dc:identifier>
</item>
<item>
<title>探索.NET Core中的IStartupFilter - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/10279874.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/10279874.html</guid>
<description>&lt;blockquote readability=&quot;2.1348314606742&quot;&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://andrewlock.net/exploring-istartupfilter-in-asp-net-core/&quot;&gt;Exploring IStartupFilter in ASP.NET Core&lt;/a&gt;&lt;br/&gt;作者：&lt;a href=&quot;https://andrewlock.net/&quot;&gt;Andrew Lock&lt;/a&gt;&lt;br/&gt;译者：Lamond Lu&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在本篇博客中，我将介绍一下&lt;code&gt;IStartupFilter&lt;/code&gt;, 以及如何在ASP.NET Core中使用它。在下一篇博客中，我将介绍一下如何在外部中间件中使用&lt;code&gt;IStartupFilter&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;IStartupFilter&lt;/code&gt;接口存在于&lt;em&gt;Microsoft.AspNetCore.Hosting.Abstractions&lt;/em&gt;程序集中，它非常简单，仅定义了一个接口方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;namespace Microsoft.AspNetCore.Hosting
{
    public interface IStartupFilter
    {
        Action&amp;lt;IApplicationBuilder&amp;gt; Configure(Action&amp;lt;IApplicationBuilder&amp;gt; next);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;Configure&lt;/code&gt;方法返回了一个变量&lt;code&gt;Action&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当创建一个ASP.NET Core应用程序的时候，&lt;code&gt;IApplicationBuilder&lt;/code&gt;负责配置ASP.NET Core的中间件管道。例如你可以在&lt;code&gt;Startup.cs&lt;/code&gt;文件的&lt;code&gt;Configure&lt;/code&gt;方法中，看到以下类似的代码。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public void Configure(IApplicationBuilder app)
{
    app.UseStaticFiles();

    app.UseMvc(routes =&amp;gt;
    {
        routes.MapRoute(
            name: &quot;default&quot;,
            template: &quot;{controller=Home}/{action=Index}/{id?}&quot;);
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个方法中，你可以直接使用方法提供的&lt;code&gt;IApplicationBuilder&lt;/code&gt;参数，并且可以向其中添加各种中间件。使用&lt;code&gt;IStartupFilter&lt;/code&gt;, 你可以指定并返回一个&lt;code&gt;Action&lt;/code&gt;类型的泛型委托，这意味你除了可以使用方法提供的泛型委托配置&lt;code&gt;IApplicationBuilder&lt;/code&gt;对象， 还需要返回一个泛型委托。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IStartupFilter&lt;/code&gt;方法可以接受一个配置&lt;code&gt;IApplicationBuilder&lt;/code&gt;的方法，换而言之&lt;code&gt;IStartupFilter.Configure&lt;/code&gt;方法可以使用&lt;code&gt;Startup.Configure&lt;/code&gt;方法作为参数。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Startup _startup = new Startup();
Action&amp;lt;IApplicationBuilder&amp;gt; startupConfigure = _startup.Configure;

//后续会补充StartupFilter1类的代码
IStartupFilter filter1 = new StartupFilter1(); 

Action&amp;lt;IApplicationBuilder&amp;gt; filter1Configure = filter1.Configure(startupConfigure)

//后续会补充StartupFilter2类的代码
IStartupFilter filter2 = new StartupFilter2(); 

Action&amp;lt;IApplicationBuilder&amp;gt; filter2Configure = filter2.Configure(filter1Configure)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果之前你学习过ASP.NET Core的中间件管道，对于这个代码，你可能会感觉很熟悉。这里我们正在建立另一条管道， 它是一个Configure方法的管道，而不是中间件管道。 这就是&lt;code&gt;IStartupFilter&lt;/code&gt;的目的，允许在应用程序中创建&lt;code&gt;Configure&lt;/code&gt;方法的管道。&lt;/p&gt;

&lt;p&gt;现在我们对&lt;code&gt;IStartupFilter&lt;/code&gt;的签名有了更进一步的理解，接下来我们可以看看它在ASP.NET Core框架中的用法。&lt;/p&gt;
&lt;p&gt;要查看&lt;code&gt;IStartupFilter&lt;/code&gt;是如果被调用的，你可以在查看&lt;em&gt;Microsoft.AspNetCore.Hosting&lt;/em&gt;程序集中的&lt;code&gt;WebHost&lt;/code&gt;类。 当你在&lt;code&gt;WebHostBuilder&lt;/code&gt;对象上调用&lt;code&gt;Build&lt;/code&gt;方法时，实现&lt;code&gt;IStartupFilter&lt;/code&gt;接口对象会被调用。 这个代码通常出现在&lt;code&gt;Program.cs&lt;/code&gt;文件中，例如：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Program
{
    public static void Main(string[] args)
    {
        var host = new WebHostBuilder()
            .UseKestrel()    
            .UseContentRoot(Directory.GetCurrentDirectory())
            .UseStartup&amp;lt;Startup&amp;gt;()
            .Build();  // 这个会调用BuildApplication方法

        host.Run(); 
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是&lt;code&gt;BuildApplication&lt;/code&gt;方法的部分代码，你可以看到这个方法负责初始化中间件管道。方法的返回值&lt;code&gt;RequestDelegate&lt;/code&gt;表示了一个完整的管道，当请求到达的时候，Kestral服务器可以调用它。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private RequestDelegate BuildApplication()
{
    ..
    IApplicationBuilder builder = builderFactory.CreateBuilder(Server.Features);
    builder.ApplicationServices = _applicationServices;

    var startupFilters = _applicationServices.GetService&amp;lt;IEnumerable&amp;lt;IStartupFilter&amp;gt;&amp;gt;();
    Action&amp;lt;IApplicationBuilder&amp;gt; configure = _startup.Configure;
    foreach (var filter in startupFilters.Reverse())
    {
        configure = filter.Configure(configure);
    }

    configure(builder);

    return builder.Build();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先，此方法创建&lt;code&gt;IApplicationBuilder&lt;/code&gt;的实例，该实例将用于构建中间件管道，并将&lt;code&gt;ApplicationServices&lt;/code&gt;设置为已配置的DI容器。&lt;/p&gt;
&lt;p&gt;接下来的代码块很意思。首先，从DI容器中获取了一个集合&lt;code&gt;IEnumerable&amp;lt;IStartupFilter&lt;/code&gt;。正如我前面说的那样，我们可以配置多个&lt;code&gt;IStartupFilter&lt;/code&gt;来形成一个管道，所以这个方法只是从容器中取出它们。此外，&lt;code&gt;Startup.Configure&lt;/code&gt;方法被保存到局部变量&lt;code&gt;configure&lt;/code&gt;中, 这就是通常在&lt;code&gt;Startup&lt;/code&gt;类中编写的&lt;code&gt;Configure&lt;/code&gt;方法，用于配置中间件管道。&lt;/p&gt;
&lt;p&gt;现在我们通过循环遍历每个&lt;code&gt;IStartupFilter&lt;/code&gt;（以相反的顺序），传入&lt;code&gt;Startup.Configure&lt;/code&gt;方法，然后更新局部变量&lt;code&gt;configure&lt;/code&gt;来创建Configure方法的管道。这种方式实现了一种嵌套管道的效果。例如，如果我们有三个&lt;code&gt;IStartupFilter&lt;/code&gt;实例，你最终会得到类似这样的东西，其中内部&lt;code&gt;Configure&lt;/code&gt;方法在参数中传递给外部方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190116224044765-1894606762.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;局部变量&lt;code&gt;configure&lt;/code&gt;的最终值会被&lt;code&gt;IApplicationBuilder&lt;/code&gt;调用来执行实际的中间件管道配置。 调用&lt;code&gt;builder.Build&lt;/code&gt;方法之后会生成处理HTTP请求所需的&lt;code&gt;RequestDelegate&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;前面我虽然描述了&lt;code&gt;IStartupFilter&lt;/code&gt;的用途，但是可能查看一些现成的实现会更容易理解一些。 默认情况下，&lt;code&gt;WebHostBuilder&lt;/code&gt;在初始化时会注册一个&lt;code&gt;IStartupFilter&lt;/code&gt; - &lt;code&gt;AutoRequestServicesStartupFilter&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class AutoRequestServicesStartupFilter : IStartupFilter
{
    public Action&amp;lt;IApplicationBuilder&amp;gt; Configure(Action&amp;lt;IApplicationBuilder&amp;gt; next)
    {
        return builder =&amp;gt;
        {
            builder.UseMiddleware&amp;lt;RequestServicesContainerMiddleware&amp;gt;();
            next(builder);
        };
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本质上，它在中间件管道的开头添加了一个额外的中间件，即&lt;code&gt;RequestServicesContainerMiddleware&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这是唯一一个默认注册的&lt;code&gt;IStartupFilter&lt;/code&gt;，因此在这种情况下，参数&lt;code&gt;next&lt;/code&gt;将是&lt;code&gt;Startup&lt;/code&gt;类的&lt;code&gt;Configure&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;这基本上就是&lt;code&gt;IStartupFilter&lt;/code&gt;的全部内容 - 它是一种在配置的管道的开头或结尾添加额外中间件（或其他配置）的方法。&lt;/p&gt;

&lt;p&gt;注册&lt;code&gt;IStartupFilter&lt;/code&gt;很简单，只需像往常一样在你的ConfigureServices方法中注册它。 默认情况下，在&lt;code&gt;WebHostBuilder&lt;/code&gt;中已经注册了&lt;code&gt;AutoRequestServicesStartupFilter&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private IServiceCollection BuildHostingServices()
{
    ...
    services.AddTransient&amp;lt;IStartupFilter, AutoRequestServicesStartupFilter&amp;gt;();
    ...
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;以下是&lt;code&gt;RequestServicesContainerMiddleware&lt;/code&gt;的部分代码&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class RequestServicesContainerMiddleware
{
    private readonly RequestDelegate _next;
    private IServiceScopeFactory _scopeFactory;

    public RequestServicesContainerMiddleware(RequestDelegate next, IServiceScopeFactory scopeFactory)
    {
        _scopeFactory = scopeFactory;
        _next = next;
    }

    public async Task Invoke(HttpContext httpContext)
    {
        var existingFeature = httpContext.Features.Get&amp;lt;IServiceProvidersFeature&amp;gt;();

        if (existingFeature?.RequestServices != null)
        {
            await _next.Invoke(httpContext);
            return;
        }

        using (var feature = new RequestServicesFeature(_scopeFactory))
        {
            try
            {
                httpContext.Features.Set&amp;lt;IServiceProvidersFeature&amp;gt;(feature);
                await _next.Invoke(httpContext);
            }
            finally
            {
                httpContext.Features.Set(existingFeature);
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该中间件负责设置&lt;code&gt;IServiceProvidersFeature&lt;/code&gt;。 创建时，&lt;code&gt;RequestServicesFeature&lt;/code&gt;为请求创建新的&lt;code&gt;IServiceScope&lt;/code&gt;和&lt;code&gt;IServiceProvider&lt;/code&gt;。 它将负责使用Scoped生命周期添加到DI容器的依赖项的创建和处理。&lt;/p&gt;

&lt;p&gt;一般来说，我不认为在用户的应用程序中需要使用&lt;code&gt;IStartupFilter&lt;/code&gt;。 就其本质而言，用户可以在&lt;code&gt;Configure&lt;/code&gt;方法中定义中间件管道，因此&lt;code&gt;IStartupFilter&lt;/code&gt;是不必要的。&lt;/p&gt;
&lt;p&gt;我能想到以下几种需要使用&lt;code&gt;IStartupFilter&lt;/code&gt;的场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;你自己创建了一个库，你需要确保你的中间件在中间件管道的开头（或结尾）运行。&lt;/li&gt;
&lt;li&gt;你正在使用一个使用&lt;code&gt;IStartupFilter&lt;/code&gt;的库，您需要确保您的中间件在它之前运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本篇博文中，我讲解了&lt;code&gt;IStartupFilter&lt;/code&gt;以及&lt;code&gt;WebHost&lt;/code&gt;如何使用它在构建中间件管道。 在下一篇文章中，我将探讨&lt;code&gt;IStartupFilter&lt;/code&gt;的具体用法。&lt;/p&gt;

&lt;p&gt;本篇是作者早期的一篇博文，个人觉着对&lt;code&gt;IStartupFilter&lt;/code&gt;讲解的比较清楚，就翻译了一下。在作者的后期博文中，作者提供了许多&lt;code&gt;IStartupFilter&lt;/code&gt;的使用场景，例如&lt;/p&gt;
&lt;p&gt;有兴趣的同学可以自己阅读一下，后续我会选择一些有意思的文章翻译一下。&lt;/p&gt;
</description>
<pubDate>Wed, 16 Jan 2019 14:41:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>在本篇博客中，我将介绍一下IStartupFilter, 以及如何在ASP.NET Core中使用它。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/10279874.html</dc:identifier>
</item>
<item>
<title>🤖️ ANNT：卷积神经网络 - I.am.Conmajia</title>
<link>http://www.cnblogs.com/conmajia/p/annt-convolutional-neural-networks.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/conmajia/p/annt-convolutional-neural-networks.html</guid>
<description>&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;Andrew Kirillov 著&lt;br/&gt;Conmajia 译&lt;br/&gt;2019 年 1 月 15 日&lt;/p&gt;
&lt;p&gt;原文发表于 CodeProject（2018 年 10 月 28 日）. 中文版有小幅修改，已获 Kirillov 本人许可.&lt;/p&gt;
&lt;p&gt;本文介绍了&lt;strong&gt;如何使用 ANNT 神经网络库生成卷积神经网络进行图像分类&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;info important&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;全文约 11,000 字，建议阅读时间 30 分钟. 本文数学内容较多，如果感到不适，可以放弃.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;info&quot; readability=&quot;10&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190112134441408-1460324434.png&quot; width=&quot;48&quot;/&gt;&lt;/div&gt;
&lt;strong&gt;ANNT&lt;/strong&gt;（Artificial Neural Networks Technology），是 AForge.NET 科学计算库 &lt;code&gt;AForge.Neuro&lt;/code&gt; 的组成部分. AForge.NET 是 Andrew Kirillov 的杰作之一，主要用于计算机视觉、人工智能、机器学习、图像处理、机器人等领域.&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190112011856517-760355778.png&quot;/&gt;&lt;a href=&quot;https://www.codeproject.com/KB/AI/1264962/ANNT.zip&quot;&gt;源码 491 KB&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文继续上一篇《&lt;a href=&quot;https://www.cnblogs.com/conmajia/p/annt-feed-forward-fully-connected-neural-networks.html&quot;&gt;前馈全连接神经网络&lt;/a&gt;》，讨论使用 ANNT 生成&lt;strong&gt;卷积神经网络&lt;/strong&gt;，并应用到图像分类处理任务中. 在《前馈》中，我介绍了&lt;strong&gt;随机梯度下降&lt;/strong&gt;（SGD）、&lt;strong&gt;误差反向传播&lt;/strong&gt;（EBP）等算法，还引入了一个 MNIST 手写文字识别的简单例子. 例子虽然简单，但还是达到了 96.5% 的准确率. 这篇文章里，我打算介绍一个不同的人工神经网络架构：&lt;strong&gt;卷积神经网络&lt;/strong&gt;（convolutional neural networks，CNN）. 这是专为计算机视觉领域设计的架构，适宜处理诸如图像分类、图像识别之类的任务. 文中附带的例子里，我把手写文字分类识别准确率提高到了 99%.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://towardsdatascience.com/convolutional-neural-networks-from-the-ground-up-c67bb41454e1&quot;&gt;卷积神经网络&lt;/a&gt;由 &lt;u&gt;Yann LeCun&lt;/u&gt;&lt;a href=&quot;http://www.cnblogs.com/conmajia/p/annt-convolutional-neural-networks.html#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; 在 1998 年提出. 然而那时候公众和业界对人工智能相关领域的关注度很低，他的研究在当时无人问津. 直到 14 年后，在 &lt;a href=&quot;http://image-net.org/&quot;&gt;ImageNet&lt;/a&gt; 比赛中获胜团队使用了这一架构拔得头筹，这才引起了广泛的关注. 随后 CNN 一飞冲天，迅速流行起来，并应用到了大量计算机视觉领域研究中. 如今，最先进的卷积神经网络算法在进行图像识别时，甚至可以超过人类肉眼识别的准确率.&lt;/p&gt;

&lt;p&gt;前馈全连接人工神经网络的思路来源于对生物细胞的生理连接规律的研究. 类似的，卷积网络则是从动物大脑的学习方式获得灵感. 1950 年代至 1960 年代，&lt;u&gt;Hubel&lt;/u&gt; 和 &lt;u&gt;Wiesel&lt;/u&gt; 的研究揭示了猫与猴子的大脑皮层中负责视觉的部分包含了能响应极小视野的神经元. 如果眼睛不动，视觉刺激影响单个神经元放电的视觉空间区域称为&lt;strong&gt;感受野&lt;/strong&gt;（receptive field）. 相邻的细胞有相似和重叠的接收区. 感受野的大小和位置在整个大脑皮层上有系统的变化，从而形成完整的视觉空间图.&lt;/p&gt;
&lt;div class=&quot;info&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;虽然汉语里&lt;u&gt;野&lt;/u&gt;字有 &lt;em lang=&quot;cmn-latn&quot;&gt;field&lt;/em&gt; 的意思，但是 &lt;em lang=&quot;cmn-latn&quot;&gt;receptive field&lt;/em&gt; 翻译成&lt;u&gt;感受&lt;/u&gt;&lt;u&gt;野&lt;/u&gt;还真是他妈的朗朗上口呢！&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;在 Hubel 等的论文中，他们描述了大脑中两种基本类型的视觉神经细胞，简单细胞和复杂细胞，每种的行为方式都不同. 例如，当识别到某个固定区域里呈某一角度的线条时，简单细胞就会激活. 复杂细胞的感受野更大，其输出对其中的特定位置不敏感. 这些细胞即便在视网膜的位置发生了变化也会继续对某种刺激作出反应.&lt;/p&gt;
&lt;p&gt;1980 年，日本的&lt;u&gt;福岛邦彦&lt;/u&gt;提出了种层次化的神经网络模型，命名为&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Neocognitron&quot;&gt;新认知机&lt;/a&gt;&lt;/strong&gt;（neocongnitron）. 这个模型受简单和复杂细胞的概念的启发，新认知者能够通过学习物体的形状来识别模式.&lt;/p&gt;
&lt;div class=&quot;info note&quot; readability=&quot;6.5205479452055&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://personalpage.flsi.or.jp/fukushima/index-e.html&quot;&gt;福岛邦彦&lt;/a&gt;这老大爷奔 90 去的人了，对于技术发展还是很关注的. 感兴趣的读者可以通过 [&lt;a href=&quot;mailto:fukushima@m.ieice.org&quot;&gt;〒电子邮件&lt;/a&gt;] 向他请教.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;再后来，1998 年，Yann LeCun 等人引入了卷积神经网络. 第一版的 CNN 叫做 Lenet-5，能够分类手写数字.&lt;/p&gt;
&lt;h2 id=&quot;卷积网络的架构&quot;&gt;卷积网络的架构&lt;/h2&gt;
&lt;p&gt;在开始构建卷积神经网络的细节之前，先来看神经网络的组成基础. 正如&lt;a href=&quot;https://www.cnblogs.com/conmajia/p/annt-feed-forward-fully-connected-neural-networks.html&quot;&gt;前一篇文章&lt;/a&gt;提到的，人工神经网络的许多概念&lt;em&gt;可以作为单独的实体来实现&lt;/em&gt;，用于执行推理和训练阶段的计算. 由于核心结构已经在前面的文章中列出，这里我将直接在顶层添加模块，然后把它们粘在一起.&lt;/p&gt;
&lt;h3 id=&quot;卷积层&quot;&gt;卷积层&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;卷积层&lt;/strong&gt;是卷积神经网络的核心部分. 它假定输入是具有一定宽度、高度和深度的三维形状. 对于第一个卷积层，它&lt;em&gt;通常是一个图像&lt;/em&gt;，最常见的深度是 1（灰度图像）或 3（带 RGB 通道的彩色图像）. 前一层生成一组特征映射（这里的深度是输入特征映射的数量）输入到后一层. 这里假设需要处理深度为 1 的输入，然后转换为二维结构.&lt;/p&gt;
&lt;p&gt;所以，卷积层所做的，本质上是一个具有&lt;a href=&quot;https://en.wikipedia.org/wiki/Kernel_(image_processing)&quot;&gt;&lt;strong&gt;核&lt;/strong&gt;&lt;/a&gt;的&lt;a href=&quot;http://machinelearninguru.com/computer_vision/basics/convolution/image_convolution_1.html&quot;&gt;&lt;strong&gt;图像卷积&lt;/strong&gt;&lt;/a&gt;，一种非常常见的图像处理操作. 例如，可以用来模糊化或者锐化图像. 但讨论卷积网络时并不关心这些. 根据使用的核，图像卷积可以用来寻找图像中的某些特征，如垂直、水平边缘，角或圆等更复杂的特征. 想想我前面介绍的视觉皮层中简单细胞的概念？&lt;/p&gt;
&lt;p&gt;数字图像处理里，两个矩阵相乘，如果其中一个保持不变，那么相当于用它代表的&lt;em&gt;操作&lt;/em&gt;对另一个进行某种运算. 所以有时&lt;u&gt;核&lt;/u&gt;也被称作&lt;u&gt;算子&lt;/u&gt;（operator）.&lt;/p&gt;
&lt;p&gt;现在来计算一下卷积. 假设有 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;×&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;（高度×宽度）、矩阵 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{K}\)&lt;/span&gt;（核）和 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{I}\)&lt;/span&gt;（图像），那么卷积可以写成这些矩阵的&lt;strong&gt;点积&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \tag{1} \mathbf{K}*\mathbf{I}=\sum_{i=1}^{n}\sum_{j=1}^{m}K_{n-i+1,m-j+1}*I_{i,j} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;举个例子，对于 3×3 的矩阵，可以这么计算它们的卷积：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{bmatrix} a &amp;amp; b &amp;amp; c \\ d &amp;amp; e &amp;amp; f \\ g &amp;amp; h &amp;amp; i \end{bmatrix} * \begin{bmatrix} 1 &amp;amp; 2 &amp;amp; 3 \\ 4 &amp;amp; 5 &amp;amp; 6 \\ 7 &amp;amp; 8 &amp;amp; 9 \end{bmatrix} \\ = i*1+h*2+g*3+f*4+e*5+d*6+c*7+b*8+a*9 \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;式 &lt;span class=&quot;math inline&quot;&gt;\((1)\)&lt;/span&gt; 的卷积定义是从信号处理领域借鉴过来的，核经过了垂直和水平翻转. 更直接的计算方法是 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{K}\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{I}\)&lt;/span&gt; 不进行翻转，直接进行正常点积. 这种操作称为&lt;strong&gt;互相关&lt;/strong&gt;，定义如下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \mathbf{K}*\mathbf{I}=\sum_{i=1}^{n}\sum_{j=1}^{m}K_{i,j}*I_{i,j} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在信号处理里，卷积和互相关具有不同的性质，并且用于不同的目的. 但是在图像处理和神经网络里，这些差异变得很细微，通常使用互相关来计算. &lt;em&gt;对于神经网络来说，这点差异并不重要&lt;/em&gt;. 稍后可以看到，这些“卷积”核实际上是神经网络需要学习的&lt;em&gt;权重&lt;/em&gt;. 所以，&lt;em&gt;由网络决定哪个核需要学习，翻转还是不翻转&lt;/em&gt;.&lt;/p&gt;
&lt;div class=&quot;info&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;本文提到的&lt;u&gt;卷积&lt;/u&gt;，是两个矩阵的点积，即&lt;u&gt;互相关&lt;/u&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;好了，现在知道了如何计算两个相同大小的矩阵的卷积. 但是实际图像处理中这种福利局很少有，一般通常是一个 3×3、5×5、7×7 等大小的正方形矩阵作为核，而图像可以是&lt;em&gt;任意大小&lt;/em&gt;的. 那么怎么计算图像卷积呢？为了计算图像卷积，在整个图像上移动核，并在每个可能位置计算加权和. 图像处理中，这个概念被称为&lt;strong&gt;滑动窗口&lt;/strong&gt;，从图像的左上角开始，计算这一小区域（大小和核相同）的卷积. 然后将核右移一个&lt;em&gt;像素&lt;/em&gt;，计算出另一个卷积. 不断重复，完成第一&lt;em&gt;行&lt;/em&gt;每个位置的计算，然后从第二行开始，继续重复前面的计算. 这样，当整个图像处理后，就能得到一个特征图，其中包含了原图每个位置的卷积值.&lt;/p&gt;
&lt;p&gt;图 1 说明了图像卷积的计算过程. 对于 8×8 的输入图像（input image）和 3×3 的核（kernel），计算得到 6×6 的特征图（feature map）.&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190115233148828-493611213.png&quot;/&gt; 图 1 图像卷积演示
&lt;div class=&quot;info important&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;注意卷积只在核&lt;em&gt;完全匹配&lt;/em&gt;图像的位置计算，图形边缘无法计算卷积. 于是计算得到的特征图总是&lt;em&gt;小于&lt;/em&gt;原图.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;图 1 的 3×3 卷积核是设计来查找对象的左边缘的（从滑动窗口的中心看，右侧有一条垂直直线）. 特征图中的高正值表示存在要查找的特征，零表示没有特征. 对于这个例子，负值表示存在“反转”特征，也就是对象的右边缘.&lt;/p&gt;
&lt;p&gt;当计算卷积时，输出特征映射的大小比原图小. 使用的核越大，得到的特征图就越小. 对于 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;×&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 大小的核，输入图像的大小将丢失 &lt;span class=&quot;math inline&quot;&gt;\((n-1)\)&lt;/span&gt;×&lt;span class=&quot;math inline&quot;&gt;\((m-1)\)&lt;/span&gt;. 因此，上面的例子如果用 5×5 的核，那特征图将只有 4×4. 多数情况下，需要特征图和原图等大，这时就要&lt;em&gt;填充&lt;/em&gt;特征图，一般用 0 填充. 假设原图大小为 8×8，而核为 5×5，那么需要先把原图填充到 12×12，添加 4 个额外的行和列，每侧各 2 行/列.&lt;/p&gt;
&lt;p&gt;现在，读者应该已经可以计算卷积了. 接下来要研究这些内容怎样运用到前面定义的卷积层中. 为了保持简单，继续使用图 1 的例子. 在这种情况下，输入层有 64 个节点，卷积层有 36 个神经元. 和全连接层不同的是，卷积层的神经元只与前一层的一小部分神经元相连. 卷积层中的&lt;em&gt;每个神经元的连接数与它所实现的卷积核中的权重数相同&lt;/em&gt;，在上面的例子中是 9 个连接（核大小 3×3）. 因为假定卷积层的输入具有二维形状（一般是三维的，我这里简化一下，便于研究），所以这些连接是对先前神经元的矩形组进行的，该组神经元的形状与使用中的内核相同. 以前连接的神经元组对于卷积层的每个神经元是不同的，但是它确实与相邻的神经元重叠. 使用滑动窗口法计算图像卷积时，这些连接的方式与选择原图像素的方式相同.&lt;/p&gt;
&lt;p&gt;忽略全连接层和卷积层的神经元与前一层的连接数不同，并且这些连接具有一定的结构这样的事实后，这两个层可以看作基本相同的：计算输入的加权和以产生输出. 不过还有一个区别，就是卷积层的神经元&lt;em&gt;共享权重&lt;/em&gt;. 因此，如果一个层做一个 3×3 的卷积，它只有一组权重，即 9. 每个神经元都共享这个权重，用于计算加权和. 而且，尽管没有提到，卷积层也为加权和&lt;em&gt;增加了偏差值，这也是共享的&lt;/em&gt;. 表 1 总结了全连接层和卷积层之间的区别：&lt;/p&gt;
表 1 全连接层和卷积层对比
&lt;table readability=&quot;5.5&quot;&gt;&lt;tr&gt;&lt;th&gt;全连接层&lt;/th&gt;
&lt;th&gt;卷积层&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;不假设输入结构&lt;/td&gt;
&lt;td&gt;假设输入为 2D 形状（通常是 3D）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;每个神经元都连接到前一层所有神经元&lt;br/&gt;每神经元 64 个连接&lt;/td&gt;
&lt;td&gt;每个神经元连接到前一层的矩形组，连接数等于卷积核的权重数&lt;br/&gt;每神经元 9 个连接&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;每个神经元有自身的权重和偏差值&lt;br/&gt;共 2304 权重，36 偏差值&lt;/td&gt;
&lt;td&gt;共享权重和偏差值&lt;br/&gt;共 9 权重，1 偏差值&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;前面的思考都基于卷积层的&lt;em&gt;输入和输出都是二维&lt;/em&gt;这个假设. 但是实际上通常&lt;em&gt;输入和输出都具有三维形状&lt;/em&gt;. 首先，从输出开始，每个卷积层计算不止一个卷积. 设计人工神经网络时，可以对它所能做的卷积数量进行配置，每个卷积使用自己的一组权重（核）和偏差值，从而生成不同的特征图. 前面提到过，不同的核可以用来寻找不同的特征直线、曲线、角等. 因此，通常会求得一些特征图，以突出不同特征. 这些图的计算方法很简单，只要在卷积层中添加额外的神经元群，这些神经元以单核的方式连接到输入端，就可以完成卷积的计算. 尽管这些神经元具有相同的连接模式，但它们共享不同的权重和偏差值. 还是用上面的例子，假设将卷积层配置为执行 5 个卷积，每个执行 3×3，这种情况下，输出数量（神经元数量）是 36×5=180. 5 组神经元组织成二维形状并重复相同的连接模式，每组都有自己的权重/偏差集，于是可得 45 个权重和 5 个偏差值.&lt;/p&gt;
&lt;p&gt;来讨论一下输入的&lt;strong&gt;三维性质&lt;/strong&gt;. 对于第一层卷积层，多半都是些图像，要么是灰度图（2D），要么是 RGB 彩图（3D）. 对于后续的卷积层，输入的深度等于前一层计算的特征图的数量（卷积的数量）. 输入深度越大，与前一层连接的数量越多，卷积层中的神经元数量就越少. 此时使用的实际上是 3D 的卷积核，大小为 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;×&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;×&lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt; 是输入&lt;strong&gt;深度&lt;/strong&gt;. 可以认为每个神经元都从各自的输入特征图增加了额外的连接. 2D 输入的情况下，每个神经元连接到输入特征图的 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;×&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 矩形区域. 3D 输入的情况下，每个神经元连接的是这些区域同样的位置，只是它们具有来自不同输入特征图的数字 &lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;现在已经将卷积层推广到了三维上，也提到了偏差值，针对卷积核每个 &lt;span class=&quot;math inline&quot;&gt;\((x,y)\)&lt;/span&gt;，式 &lt;span class=&quot;math inline&quot;&gt;\((1)\)&lt;/span&gt; 可以表示为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \tag{2} K^{(f)}*I_{y,x}=\sum_{l=1}^{d}\sum_{i=1}^{n}\sum_{j=1}^{m}\left[K_{l,i,j}^{(f)}*I_{l,y+i-1,x+j-1}+b^{(f)}\right],f=1,2,\cdots,z \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;总结一下卷积层的参数. 在生成全连接层时，只用到输入神经元数量和输出神经元数量两个参数. 生成卷积层时，不需要指定输出的数量，只用指定输入的形状，&lt;span class=&quot;math inline&quot;&gt;\(h\)&lt;/span&gt;×&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;×&lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt;，以及核的形状 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;×&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 和数量 &lt;span class=&quot;math inline&quot;&gt;\(z\)&lt;/span&gt;. 因此，有 6 个数字：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;：输入特征图的宽度&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(h\)&lt;/span&gt;：输入特征图的高度&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt;：输入深度（特征图的数量）&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;：卷积核宽度&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;：卷积核高度&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(z\)&lt;/span&gt;：卷积核数量（输出特征图的数量）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;卷积核的实际大小取决于指定的输入，因此可以得到 &lt;span class=&quot;math inline&quot;&gt;\(z\)&lt;/span&gt; 个 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;×&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;×&lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt; 大小的卷积核，假设&lt;em&gt;没有填充&lt;/em&gt;输入，这时输出的大小应为 &lt;span class=&quot;math inline&quot;&gt;\((h-n+1)\)&lt;/span&gt;×&lt;span class=&quot;math inline&quot;&gt;\((w-m+1)\)&lt;/span&gt;×&lt;span class=&quot;math inline&quot;&gt;\(z\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;上面是计算输出的概念性内容，接下来训练卷积层时，还会再次提到.&lt;/p&gt;
&lt;h3 id=&quot;relu-激活函数&quot;&gt;ReLU 激活函数&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Rectifier_(neural_networks)&quot;&gt;ReLU 激活函数&lt;/a&gt;也就是 rectifier 激活函数，对卷积神经网络来说，它不是什么新东西. 随着更深层次的神经网络的兴起，它得到了广泛的推广.&lt;/p&gt;
&lt;p&gt;深度神经网络遇到的问题之一就是&lt;a href=&quot;https://en.wikipedia.org/wiki/Vanishing_gradient_problem&quot;&gt;消失梯度问题&lt;/a&gt;. 当使用基于梯度的学习算法和反向传播算法训练人工神经网络时，每个神经网络的权重都与当前权重相关的误差函数偏导数成比例变化. 问题是在某些情况下，&lt;em&gt;梯度值可能小到权重值不会改变&lt;/em&gt;. 这一问题的原因之一是使用传统的激活函数，如 sigmoid 和 &lt;span class=&quot;math inline&quot;&gt;\(\tanh\)&lt;/span&gt;. 这些函数的梯度在 &lt;span class=&quot;math inline&quot;&gt;\((0,1)\)&lt;/span&gt; 范围内，大部分的值接近于 0. 由于误差的偏导数是用链式法则计算出来的，对于一个 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 层网络，这些&lt;em&gt;小数字&lt;/em&gt;会乘上 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 次，&lt;em&gt;梯度将呈指数递减&lt;/em&gt;. 结果就是，深度神经网络在训练“前面的”层时非常缓慢.&lt;/p&gt;
&lt;p&gt;ReLU 函数的定义为 &lt;span class=&quot;math inline&quot;&gt;\(f(x)=x^+=max(0,x)\)&lt;/span&gt;. 它最大的优点是，对于 &lt;span class=&quot;math inline&quot;&gt;\(x&amp;gt;0\)&lt;/span&gt; 的值，它的导数总是 1，所以它允许更好的梯度传播，从而加快深度人工神经网络的训练速度. 和 sigmoid 和 &lt;span class=&quot;math inline&quot;&gt;\(\tanh\)&lt;/span&gt; 相比，它的计算效率更高，速度更快.&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190116163602815-296699171.png&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190112173944179-589710150.png&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;center&gt;(a) ReLU 函数&lt;/center&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;center&gt;(b) sigmoid 函数&lt;/center&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/center&gt;
图 2 ReLU 函数和 sigmoid 函数
&lt;p&gt;虽然 ReLU 函数存在一些&lt;a href=&quot;https://en.wikipedia.org/wiki/Rectifier_(neural_networks)#Potential_problems&quot;&gt;潜在的问题&lt;/a&gt;，但到目前为止，它依然是深度神经网络中最成功最广泛的激活函数之一.&lt;/p&gt;
&lt;h3 id=&quot;池化层&quot;&gt;池化层&lt;/h3&gt;
&lt;p&gt;实践中经常会为卷积层生成一个&lt;strong&gt;池化层&lt;/strong&gt;（pooling layer）. &lt;a href=&quot;http://deeplearning.stanford.edu/wiki/index.php/%E6%B1%A0%E5%8C%96&quot;&gt;池化&lt;/a&gt;的目的是减少输入的空间尺寸，减少神经网络中的参数和计算量. 这也有助于控制&lt;strong&gt;过拟合&lt;/strong&gt;（over-fitting）.&lt;/p&gt;
&lt;p&gt;最常见的池化技术是&lt;strong&gt;平均池化&lt;/strong&gt;和&lt;strong&gt;最大池化&lt;/strong&gt;. 以最大池化为例，使用 2×2 大小过滤器，跨距为 2 的 &lt;code&gt;MAX&lt;/code&gt; 池化. 对于 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;×&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 的输入，通过将输入中的每个 2×2 区域替换为单个值（该区域中 4 个值的&lt;em&gt;最大值&lt;/em&gt;），得到 &lt;span class=&quot;math inline&quot;&gt;\(\dfrac{n}{2}\times\dfrac{m}{2}\)&lt;/span&gt; 的结果. 通过设置与池化区域大小相等的跨距，可以保证这些区域相邻而不重叠. 图 3 演示了用于 6×6 输入图的过程.&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190116163900926-976921434.png&quot;/&gt; 图 3 池化
&lt;p&gt;池化层的过滤器和跨距值. 例如一些应用程序使用具有 2 跨距的 3×3 大小过滤器这样存在部分重叠的池化. 一般来说跨距不会大于过滤器大小，图像里很多内容会完全丢失.&lt;/p&gt;
&lt;p&gt;池化层使用二维特征图，但并且不影响输入深度. 如果输入包含由前一个卷积层生成的 10 个特征图，那么池化将分别应用于每个图. 所以通过池化，能生成相同数量的特征图，但尺寸更小.&lt;/p&gt;
&lt;h3 id=&quot;建立卷积神经网络&quot;&gt;建立卷积神经网络&lt;/h3&gt;
&lt;p&gt;多数情况下，卷积网络从卷积层开始，卷积层执行初始特征的提取，然后是全连接层，后者执行最终的分类.&lt;/p&gt;
&lt;p&gt;以 &lt;a href=&quot;http://yann.lecun.com/exdb/lenet/index.html&quot;&gt;LeNet-5&lt;/a&gt; 为例. 这是 Yann LeCun 提出的卷积神经网络结构，并应用于手写数字分类. 它输入 32×32 的灰度图像，产生 10 个值的向量，这些值代表数字属于某一类（数字 0 到 9）的概率. 表 2 总结了网络的结构、输出的尺寸和可训练参数（权重+偏差）的数量.&lt;/p&gt;
表 2 LeNet-5 结构
&lt;table&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;层类型&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;可训练参数&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;输出大小&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;输入图像&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;32×32×1&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;卷积层 1，核大小 5×5，核数量 6&lt;br/&gt;ReLU 激活&lt;/td&gt;
&lt;td&gt;156&lt;/td&gt;
&lt;td&gt;28×28×6&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;最大池化 1&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;14×14×6&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;卷积层 2，核大小 5×5，核数量 16&lt;br/&gt;ReLU 激活函数&lt;/td&gt;
&lt;td&gt;416&lt;/td&gt;
&lt;td&gt;10×10×16&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;最大池化 2&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;5×5×16&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;卷积层 3，核大小 5×5，核数量 120&lt;/td&gt;
&lt;td&gt;3120&lt;/td&gt;
&lt;td&gt;1×1×120&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;全连接层 1，输入 120，输出 84&lt;br/&gt;Sigmoid 激活函数&lt;/td&gt;
&lt;td&gt;10164&lt;/td&gt;
&lt;td&gt;84&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;全连接层 2，输入 84，输出 10&lt;br/&gt;SoftMax 激活函数&lt;/td&gt;
&lt;td&gt;850&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这里只有 14706 个可训练参数，算是非常简单的卷积神经网络结构了. 业界实用的更复杂的深度神经网络，包含了超过几百万个训练参数.&lt;/p&gt;
&lt;h2 id=&quot;训练卷积网络&quot;&gt;训练卷积网络&lt;/h2&gt;
&lt;p&gt;到目前为止，本文还只局限于推导卷积神经网络，即计算给定输入的输出. 但是要从中得到有意义的东西，需要先对网络进行训练. 对于&lt;em&gt;图像处理中&lt;/em&gt;的卷积算子，卷积核通常是人工设计的，具有特定的用途，比如查找物体边缘，锐化图像或是模糊图像等. 设计正确的卷积核来执行所需的任务是一个耗时的过程. 但是&lt;em&gt;对于卷积神经网络&lt;/em&gt;，情况却完全不同. 在设计这种网络时，只用考虑层数、完成的卷积的数量和大小等，而不会设置这些卷积核. 相反，网络将在训练阶段学习这些内容. 从本质上说，这些核只不过是权重.&lt;/p&gt;
&lt;p&gt;卷积人工网络的训练使用与全连接网络训练完全相同的算法——随机梯度下降和反向传播. 正如《前馈》中写到的，为了计算神经网络误差的偏导数，可以使用链式法则. 这样可以为任何可训练层的权重变化定义完整的方程. 我将针对神经网络每个构建块（building block），比如全连接和卷积层、激活函数、成本函数等，写一些小点的方程，而不是那种一个式子占半页纸的大玩意儿.&lt;/p&gt;
&lt;p&gt;通过链式法则，可以发现神经网络的每个构建块都将其误差梯度计算为输出相对于输入的偏导数，并与后面块的误差梯度相乘. 要记住，信息流是向后移动的，所以计算要从最后一个块开始，然后流到前一个块，即第一个块. 训练阶段的最后一个块&lt;em&gt;始终是一个成本函数&lt;/em&gt;，它将误差梯度作为成本（其输出）相对于神经网络输出（成本函数的输入）的导数进行计算. 这可以通过以下方式定义：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \delta_i^{(\mathrm{net})}=\frac{\partial\mathrm{Cost}}{\partial\mathrm{net}_i} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;所有其他构建块都从下一个块中获取误差梯度，并乘以其输出相对于输入的偏导数.&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \delta_i^{(k)}=\frac{\partial\mathrm{out}^{(k)}}{\partial\mathrm{in}^{(k)}_i}\delta^{(k+1)} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;回忆一下全连接网络的导数. 首先，从 MSE 成本函数相对于网络输出的误差梯度开始（&lt;span class=&quot;math inline&quot;&gt;\(y_i\)&lt;/span&gt; 为网络产生的输出，&lt;span class=&quot;math inline&quot;&gt;\(t_i\)&lt;/span&gt; 为目标输出）：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \delta_i^{(\mathrm{net})}=y_i-t_i \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当误差梯度通过 sigmoid 激活函数后移时，它会以这种方式重新计算（这里的 &lt;span class=&quot;math inline&quot;&gt;\(o_i\)&lt;/span&gt; 是 sigmoid 的输出），这是从下一块（无所谓是什么，也可以是成本函数或多层网络中的另一层）得到的梯度乘以 sigmoid 的导数：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \delta_i^{(k)}=o_i(1-o_i)\delta_i^{(k+1)} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;或者，如果使用 &lt;span class=&quot;math inline&quot;&gt;\(\tanh\)&lt;/span&gt; 作为激活函数，则：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \delta_i^{(k)}=o_i(1-o_i^2)\delta_i^{(k+1)} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当需要通过一个全连接层向后传播误差梯度时，鉴于每个输入输出都各自相连，可以得到一个偏导数的和：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \delta_i^{(k)}=\sum_{j=1}^{m}\omega_{i,j}*\delta_j^{(k+1)} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 是全连接层中的神经元数，&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt; 分别表示第 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 个输出和第 &lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt; 个输入.&lt;/p&gt;
&lt;p&gt;由于全连接层是一个可训练的层，它不仅需要将误差梯度向后传递给前一个层，还需要计算权重. 使用上述定义的命名约定，权重和偏差的计算规则可以写成（经典SGD）：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align*} \omega_{i,j}(t+1) &amp;amp;= \omega_{i,j}(t)-\lambda\left(\delta_i^{(k+1)}x_j\right) \\ b_i(t+1) &amp;amp;=b_i(t)-\lambda\delta_i^{(k+1)} \end{align*} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上面的方程实际上都是《前馈》中反向传播的内容. 为什么我要再写一遍？首先是要提醒一下基础知识，其次，我用了不同的方式重写，其中每个构建块定义自己的误差梯度反向传播方程. 《前馈》里给出的权重方程有助于理解基本知识以及链规则的工作原理，但是作为一个单一的方程，它没法通用. 如果成本函数不是 MSE 呢？如果需要 &lt;span class=&quot;math inline&quot;&gt;\(\tanh\)&lt;/span&gt; 或者 ReLU 激活函数而不是 sigmoid 呢？本文介绍的方法更加灵活，允许以各种方式混合人工神经网络的构建块，并在不假设哪一层之后进行激活，使用哪一个成本函数的情况下进行培训. 此外，这样的写法和我实际的 C++ 代码实现类似，我把不同的构建块实现为单独的类，在训练过程中让它们各自计算前向传递和后向传递.&lt;/p&gt;

&lt;h3 id=&quot;交叉熵成本函数&quot;&gt;交叉熵成本函数&lt;/h3&gt;
&lt;p&gt;卷积神经网络最常用的用途之一是图像分类. 给定一个图像，网络需要把它分类到相互排斥的类里去. 比如手写数字分类，有 10 个可能的类对应于从 0 到 9 的数字. 或者可以训练一个网络来识别汽车、卡车、轮船、飞机等交通工具. 这种分类的要点是，&lt;em&gt;每个输入图像必须只属于一个类别&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;在处理多类分类问题时，人工神经网络输出的类数应当与要区分的类数相同. 在训练阶段，目标输出是&lt;a href=&quot;https://hackernoon.com/what-is-one-hot-encoding-why-and-when-do-you-have-to-use-it-e3c6186d008f&quot;&gt;独热编码&lt;/a&gt;的，也就是用零向量表示，在与类对应的索引处，只有一个元素设置为值“1”。例如，对于 4 类分类的任务，目标输出可能是：第 2 类 &lt;span class=&quot;math inline&quot;&gt;\(\{0、1、0、0\}\)&lt;/span&gt;、第 4 类 &lt;span class=&quot;math inline&quot;&gt;\(\{0、0、0、1\}\)&lt;/span&gt; 等. 任何目标输出都&lt;em&gt;不允许将多个元素设置为“1”或其他非零值&lt;/em&gt;. 这可以看作是目标概率，即 &lt;span class=&quot;math inline&quot;&gt;\(\{0、1、0、0\}\)&lt;/span&gt; 输出意味着输入属于第 2 类的概率为 100%，以及属于其他类的概率为 0%.&lt;/p&gt;
&lt;p&gt;上面说的是理想情况，实际训练中的神经网络输出不会是非黑即白这么极端，比如它可以输出 0.3、0.35、0.25、0.1 之类的小数. 这些输出对应着不同的实际含义. 这表示神经网络没法十分清楚判断目标应该分到哪一类，它只能根据计算得到的概率分析，第 2 类的概率有0.35，也就是 35% 的可能性，而且这是 4 个输出中最高的，那么它将猜测这&lt;em&gt;很可能&lt;/em&gt;应该属于第 2 类.&lt;/p&gt;
&lt;p&gt;所以说，需要一个成本函数来量化目标和实际输出之间的差异，并指导神经网络计算其参数. 在处理互斥类的概率模型时，通常需要处理预测概率和真实值（ground-truth）概率. 这种情况下，最常见的选择是&lt;strong&gt;交叉熵成本函数&lt;/strong&gt;（cross-entropy）. &lt;a href=&quot;https://rdipietro.github.io/friendly-intro-to-cross-entropy-loss/&quot;&gt;交叉熵&lt;/a&gt;是&lt;strong&gt;信息论&lt;/strong&gt;当中的概念. 通过最小化交叉熵，通过最小化额外的数据比特量，用&lt;em&gt;估计的&lt;/em&gt;概率 &lt;span class=&quot;math inline&quot;&gt;\(y_i\)&lt;/span&gt; 对出现概率分布 &lt;span class=&quot;math inline&quot;&gt;\(t_i\)&lt;/span&gt;（目标或实际分布）的某些事件进行编码. 为了最小化交叉熵，需要使估计概率与实际概率相同.&lt;/p&gt;
&lt;p&gt;交叉熵成本函数定义如下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \mathrm{Cost}=-\sum_{i=1}^{n}t_i\log(y_i) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(t_i\)&lt;/span&gt; 是目标输出，&lt;span class=&quot;math inline&quot;&gt;\(y_i\)&lt;/span&gt; 是神经网络输出.&lt;/p&gt;
&lt;p&gt;对上式求导，成本函数对神经网络输出的偏导数为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \delta_i^{(\mathrm{net})}=-\frac{t_i}{y_i} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这就得到了可以代替 MSE 的交叉熵成本函数. 接下来可以开始处理其他构建块并观察误差梯度是如何反向传播的.&lt;/p&gt;
&lt;h3 id=&quot;softmax-激活函数&quot;&gt;SoftMax 激活函数&lt;/h3&gt;
&lt;p&gt;《前馈》中已经介绍过在分类问题中用到的神经网络最后一层使用 sigmoid 作为激活函数. 它的输出值域为 &lt;span class=&quot;math inline&quot;&gt;\((0,1)\)&lt;/span&gt;，可以理解为从 0% 到 100% 表示的概率. 如果神经网络输出层采用 sigmoid，它的确可能得到接近于真实值的概率. 但是现在要处理的是互斥类，很多情况下 sigmoid 的输出是无意义的. 比如上面的 4 类分类例子：一个输出向量是 ${0.6,0.55,0.1,0.1}，这是用 sigmoid 可能得到的结果. 问题在哪？乍一看，这表明应该是第 1 类（60% 概率），但是第 2 类的可能性也很大（55%）. 而且这个输出结果有一个很大的问题，它的各概率和达到了 1.35，也就是目标属于这 4 类之一的可能性是 135%. 这在物理上是&lt;em&gt;毫无意义&lt;/em&gt;的！&lt;/p&gt;
&lt;p&gt;这里要指出两个问题：第一，各分类概率和应为 100%，不能多，也不能少. 第二，对于难以识别的分类目标，如果目标既像第 1 类，又像第 2 类，那么怎么能确定 60% 这么高的概率一定是可信的？&lt;/p&gt;
&lt;p&gt;为了解决这两个问题，需要用到另一个激活函数：&lt;strong&gt;SoftMax&lt;/strong&gt;. &lt;a href=&quot;https://en.wikipedia.org/wiki/Softmax_function&quot;&gt;SoftMax&lt;/a&gt; 类似 sigmoid，值域也是 &lt;span class=&quot;math inline&quot;&gt;\((0,1)\)&lt;/span&gt;. 不同的是，它处理整个输入向量而不是其中的单个值，这就保证了输出向量（概率）的和恒为 1. SoftMax 定义为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ f(x_i)=\frac{e^{x_i}}{\sum_{j=1}^{m}e^{x_j}} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;将上面的例子改用 SoftMax 进行处理后，输出向量变得更合理了：&lt;span class=&quot;math inline&quot;&gt;\(\{0.316,0.3,0.192,0.192\}\)&lt;/span&gt;. 可以看到，向量中各概率的和等于 1，也就是 100%. 最可能的第 1 类，它的概率也不再高得离谱，只有 31.6%.&lt;/p&gt;
&lt;p&gt;和其他激活函数一样，SoftMax 也需要定义它的梯度反向传播方程：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \delta_i^{(k)}=\sum_{j=1}^{m}\left(\delta_j^{(k+1)}*\left\{ \begin{align*}j &amp;amp;=i,o_i(1-o_j) \\ j &amp;amp;\neq i,-o_io_j \end{align*} \right\}\right) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;表 2 里可以看到 LeNet-5 神经网络架构中包含了全连接层和 sigmoid 激活函数. 这两者的方程也定义完毕，现在就可以继续讨论其他构建块了.&lt;/p&gt;
&lt;h3 id=&quot;relu-激活函数-1&quot;&gt;ReLU 激活函数&lt;/h3&gt;
&lt;p&gt;前面提到过，ReLU 激活函数在深度神经网络经常用到，它对于大于 0 的输入向量梯度恒为 1，所以能保证误差梯度在网络中更好地传播. 现在来定义它的梯度反向传播方程：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \delta_i^{(k)}=\delta_j^{(k+1)}*\left\{ \begin{align*} 1 &amp;amp;, o_i&amp;gt;0 \\ 0 &amp;amp;, o_i\leqslant0 \end{align*} \right\} \]&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;池化层-1&quot;&gt;池化层&lt;/h3&gt;
&lt;p&gt;为了尽量简洁地说明误差梯度如何通过池化层反向传播，假设使用的池化层卷积核大小 2×2，跨度 2，不填充输入（只池化有效位置）. 这个假设意味着每个输出特征图的值都是基于 4 个值计算得到的.&lt;/p&gt;
&lt;p&gt;尽管池化层假设输入向量是二维数据，但是下面的数学定义也可以处理输入输出是一维向量的情况. 首先定义 &lt;span class=&quot;math inline&quot;&gt;\(\mathrm{i2j}(i)\)&lt;/span&gt; 函数，这个函数接受输入向量第 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 个值（作为索引），并返回输出向量对应的第 &lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt; 个值（作为索引）. 由于每个输出都是用 4 个输入值计算出来的，所以这意味着有 4 个 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 会让 &lt;span class=&quot;math inline&quot;&gt;\(\mathrm{i2j}(i)\)&lt;/span&gt; 函数输出同一个 &lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;先从&lt;strong&gt;最大池化&lt;/strong&gt;开始，定义误差梯度反向传播方程之前，还有一件事要做. 在&lt;em&gt;正向传递&lt;/em&gt;时，计算神经网络的输出也会用与输出向量长度相同的&lt;strong&gt;最大索引值&lt;/strong&gt;（max indices）向量填充池化层. 如果输出向量包含对应输入值的最大值，则最大索引值向量包含最大值的索引. 综上所述，可以定义最大池化层的梯度反向传播方程：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \delta_i^{(k)}=\delta_{\mathrm{i2j}(i)}^{(k+1)}*\left\{ \begin{align*}1 &amp;amp;,i =p_{\mathrm{i2j}(i)} \\ 0 &amp;amp;, i\neq p_{\mathrm{i2j}(i)} \end{align*} \right\} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt; 是最大索引值向量.&lt;/p&gt;
&lt;p&gt;对&lt;strong&gt;平均池化&lt;/strong&gt;来说，就更简单了：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \delta_i^{(k)}=\frac{\delta_{\mathrm{i2j}(i)}^{(k+1)}}{q} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt; 是卷积核大小，在这个例子里，&lt;span class=&quot;math inline&quot;&gt;\(q=4\)&lt;/span&gt;.&lt;/p&gt;
&lt;h3 id=&quot;卷积层-1&quot;&gt;卷积层&lt;/h3&gt;
&lt;p&gt;最后来定义卷积层的反向传播过程. 牢记一点，它和全连接层的区别就在于共享权重和偏差值.&lt;/p&gt;
&lt;p&gt;从卷积层的权重计算开始. 对于全连接层，误差对权重 &lt;span class=&quot;math inline&quot;&gt;\(\omega_{i,j}\)&lt;/span&gt; 的偏导数等于下一个块的误差梯度乘以相应的输入值 &lt;span class=&quot;math inline&quot;&gt;\(\delta_i^{(k+1)}x_j\)&lt;/span&gt;. 这是因为每个输入／输出连接都在全连接层中分配了自己的权重，而全连接层是不共享的. 但是卷积层和这不一样，图 4 显示了卷积核的每个权重都用于多个输入／输出连接. 图中的例子，突出显示的卷积核权重每个使用了 9 次，对应输入图像中的 9 个不同位置. 因此，与权重有关的误差的偏导数也需要有 9 个.&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190116212209895-1169388814.png&quot;/&gt; 图 4 卷积层计算
&lt;p&gt;和处理池化层时类似，这里忽略了卷积层处理的是二维／三维数据这一事实，而假设它们是普通的向量／数组（就像 C++ 编程时用到的那样）. 对于上面的示例，第一个权重（红线框出）应用于输入 &lt;span class=&quot;math inline&quot;&gt;\(\{1,2,3,5,6,7,9,10,11,13,14,15\}\)&lt;/span&gt;，而第四个权重应用于输入 &lt;span class=&quot;math inline&quot;&gt;\(\{6,7,8,10,11,12,14,15,16\}\)&lt;/span&gt;. 用 &lt;span class=&quot;math inline&quot;&gt;\(r_i\)&lt;/span&gt; 表示每个权重使用的&lt;strong&gt;输入索引向量&lt;/strong&gt;. 另外定义 &lt;span class=&quot;math inline&quot;&gt;\(\mathrm{i2o}(i,j)\)&lt;/span&gt; 函数，它为第 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 个权重和第 &lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt; 个输入提供输出值索引. 上图中有几个例子，&lt;span class=&quot;math inline&quot;&gt;\(\mathrm{i2o}(1,1)=1\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(\mathrm{i2o}(4,6)=1\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(\mathrm{i2o}(1,11)=9\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(\mathrm{i2o}(4,16)=9\)&lt;/span&gt;. 根据这些约定，可以定义卷积网络的权重：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \tag{3} \omega_i(t+1)=\omega_i(t)-\lambda\sum_{j}^{j\in r_i}\delta_{\mathrm{i2o}(i,j)}^{(k+1)}x_j \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上面的玩意儿有什么意义？嗯，它的意义很丰富. 你想得越多，意义就越多. 这里的目标是为所有输出取误差梯度（因为每个核的权重用于计算所有的输出），然后将它们乘以相应的输入. 尽管有多个核，但是它们都以相同的模式应用，所以即使需要计算不同核的权重，权重输入向量也&lt;em&gt;保持不变&lt;/em&gt;. 然而，&lt;span class=&quot;math inline&quot;&gt;\(\mathrm{i2o}(i,j)\)&lt;/span&gt; 是每个核特定的，它可以使用核的索引作为额外的参数进行扩展.&lt;/p&gt;
&lt;p&gt;更新偏差值要简单得多. 由于每个核／偏差都用于计算输出值，所以只需为当前核生成的特性图的误差梯度求和即可：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \tag{4} b(t+1)=b(t)-\lambda\sum_{j}^{s}\delta_j^{(k+1)} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 是特性图.&lt;/p&gt;
&lt;div class=&quot;info important&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;式 $(3)$、式 $(4)$ 都是依据特征图／卷积核来完成的，权重和偏差值没有用核索引参数化.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;现在来求卷积层误差梯度反向传播的最终方程. 这意味要计算与层输入相关的误差偏导数. 每个输入元素可以多次用于生成要素图的输出值，它的使用次数可以与卷积核中的元素数（权重数）相同. 但是，有些输入&lt;em&gt;只能用于一个输出&lt;/em&gt;，比如二维特征图的四角. 还要记住，每个输入特征图都可以用不同的核进行多次处理，从而生成更多的输出图. 假设另一组名为 &lt;span class=&quot;math inline&quot;&gt;\(\gamma_i\)&lt;/span&gt; 的辅助向量，用于保存第 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 个输入所贡献的输出索引. 再定义 &lt;span class=&quot;math inline&quot;&gt;\(\mathrm{i2w}(i,j)\)&lt;/span&gt; 函数，它返回连接第 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 个输入到第 &lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt; 个输出的权重. 还是以图 4 为例，有：&lt;span class=&quot;math inline&quot;&gt;\(\mathrm{i2w}(1,1)=1\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(\mathrm{i2w}(6,1)=4\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(\mathrm{i2w}(16,9)=4\)&lt;/span&gt;. 利用这些定义，误差梯度通过卷积层后向传播的方程可以写为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \delta_i^{(k)}=\sum_{j}^{j\in\gamma_i}\omega_{\mathrm{i2w}(i,j)}*\delta_j^{(k+1)} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;数学分析到此结束，所有需要计算的内容都已经完成了.&lt;/p&gt;

&lt;p&gt;卷积人工神经网络很大程度上是基于《前馈》所述的全连接网络实现的设计集. 所有核心类都保持原样，只实现了新的构建块，允许将它们构建成卷积神经网络. 新的类关系图如下所示，跟原来的没有什么区别.&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190116215828894-1027441510.png&quot;/&gt; 图 5 类关系图
&lt;p&gt;与以前的设置方式类似，新的构建块负责计算正向传递上的输出和反向传递上传播误差梯度（以及在可训练层的情况下计算初始权重）. 因此，所有的神经网络训练代码都可以原样照搬. 和其他代码一样，新的构建块尽可能使用了 SIMD 指令向量化计算，以及 OpenMP 并行计算.&lt;/p&gt;
&lt;h2 id=&quot;编译源码&quot;&gt;编译源码&lt;/h2&gt;
&lt;p&gt;源码里附带 MSVC（2015版）文件和 GCC make 文件. 用 MSVC 非常简单，每个例子的解决方案文件都包括例子本身和库的项目，编译也只需点击一下按钮. 如果使用 GCC，则需要运行 make 来编译程序.&lt;/p&gt;

&lt;p&gt;分析了那么久的原理和数学推导，是时候开始实践并实际生成一些用于图像分类任务的网络了，例如分类识别手写数字和汽车、卡车、轮船、飞机之类不同的对象.&lt;/p&gt;
&lt;p&gt;这些例子唯一的目的是用来演示 ANNT 库的使用方法，并不代表用到的神经网络结构就是最适于它们的. 这些代码片段只是范例的一小部分，要查看示例的完整代码，你需要参阅本文提供的源码.&lt;/p&gt;
&lt;h2 id=&quot;mnist-手写数字分类&quot;&gt;MNIST 手写数字分类&lt;/h2&gt;
&lt;p&gt;第一个例子是对 &lt;a href=&quot;http://yann.lecun.com/exdb/mnist/&quot;&gt;MNIST 数据库&lt;/a&gt;里的手写数字进行分类. 这个数据库包含了 60000 个神经网络训练样本和 10000 个测试样本. 图 6 展示了其中的一部分.&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190116220721381-717850077.png&quot;/&gt; 图 6 MNIST 数据库（部分）
&lt;p&gt;例子使用的卷积神经网络的结构与 LeNet-5 网络非常相似，只是规模小得多. 它只有一个全连接网络：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Conv(32x32x1, 5x5x6  ) -&amp;gt; ReLU -&amp;gt; AvgPool(2x2)
Conv(14x14x6, 5x5x16 ) -&amp;gt; ReLU -&amp;gt; AvgPool(2x2)
Conv(5x5x16,  5x5x120) -&amp;gt; ReLU
FC(120, 10) -&amp;gt; SoftMax&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面设置了每个卷积层的输入大小以及它们执行的卷积的大小和数量，全连接层的输入／输出数量. 接下来生成卷积神经网络.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 连接表用于指定第一卷积层要使用的由第二层生成的特征图
vector&amp;lt;bool&amp;gt; connectionTable( {
    true,  true,  true,  false, false, false,
    false, true,  true,  true,  false, false,
    false, false, true,  true,  true,  false,
    false, false, false, true,  true,  true,
    true,  false, false, false, true,  true,
    true,  true,  false, false, false, true,
    true,  true,  true,  true,  false, false,
    false, true,  true,  true,  true,  false,
    false, false, true,  true,  true,  true,
    true,  false, false, true,  true,  true,
    true,  true,  false, false, true,  true,
    true,  true,  true,  false, false, true,
    true,  true,  false, true,  true,  false,
    false, true,  true,  false, true,  true,
    true,  false, true,  true,  false, true,
    true,  true,  true,  true,  true,  true
} );

// 准备卷积神经网络
shared_ptr&amp;lt;XNeuralNetwork&amp;gt; net = make_shared&amp;lt;XNeuralNetwork&amp;gt;( );

net-&amp;gt;AddLayer( make_shared&amp;lt;XConvolutionLayer&amp;gt;( 32, 32, 1, 5, 5, 6 ) );
net-&amp;gt;AddLayer( make_shared&amp;lt;XReLuActivation&amp;gt;( ) );
net-&amp;gt;AddLayer( make_shared&amp;lt;XAveragePooling&amp;gt;( 28, 28, 6, 2 ) );

net-&amp;gt;AddLayer( make_shared&amp;lt;XConvolutionLayer&amp;gt;( 14, 14, 6, 5, 5, 16, connectionTable ) );
net-&amp;gt;AddLayer( make_shared&amp;lt;XReLuActivation&amp;gt;( ) );
net-&amp;gt;AddLayer( make_shared&amp;lt;XAveragePooling&amp;gt;( 10, 10, 16, 2 ) );

net-&amp;gt;AddLayer( make_shared&amp;lt;XConvolutionLayer&amp;gt;( 5, 5, 16, 5, 5, 120 ) );
net-&amp;gt;AddLayer( make_shared&amp;lt;XReLuActivation&amp;gt;( ) );

net-&amp;gt;AddLayer( make_shared&amp;lt;XFullyConnectedLayer&amp;gt;( 120, 10 ) );
net-&amp;gt;AddLayer( make_shared&amp;lt;XLogSoftMaxActivation&amp;gt;( ) );&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从源码可以清楚看到上面的神经网络配置是如何转换成代码的，只是这个连接表是首次出现的. 这很容易理解，从网络结构和代码可以看出，第一层做 6 个卷积，因此生成 6 个特征图；第二层做 16 个卷积. 在某些情况下，需要配置层的卷积只在输入特征映射的子集上操作. 如代码所示，第二层的前 6 个卷积使用第一层生成的 3 个特征图的不同模式，接下来的 9 个卷积使用 4 个特征图的不同模式. 最后一个卷积使用第一层的所有 6 个特征映射. 这样做是为了&lt;em&gt;减少要训练的参数数量&lt;/em&gt;，并确保第二层的不同特征图不会基于相同的输入特征图.&lt;/p&gt;
&lt;p&gt;当创建卷积网络时，可以像处理全连接网络一样进行操作：创建一个训练内容，指定成本函数和权重的优化器，然后全部传递给一个助手类，由它运行训练／验证循环并测试.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 生成训练内容，用到了 Adam 优化器和负对数似然函数（SoftMax）
shared_ptr&amp;lt;XNetworkTraining&amp;gt; netTraining = make_shared&amp;lt;XNetworkTraining&amp;gt;( net,
                                           make_shared&amp;lt;XAdamOptimizer&amp;gt;( 0.002f ),
                                           make_shared&amp;lt;XNegativeLogLikelihoodCost&amp;gt;( ) );

// 使用助手类训练神经网络分类
XClassificationTrainingHelper trainingHelper( netTraining, argc, argv );
trainingHelper.SetValidationSamples( validationImages, encodedValidationLabels, validationLabels );
trainingHelper.SetTestSamples( testImages, encodedTestLabels, testLabels );

// 20 世代, 每批 50 样本
trainingHelper.RunTraining( 20, 50, trainImages, encodedTrainLabels, trainLabels );&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是输出，显示了训练进度和测试数据集的最终结果分类精度. 可以看到精度达到了 99.01%，比起《前馈》中 96.55% 的精度更准确了.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MNIST handwritten digits classification example with Convolution ANN

Loaded 60000 training data samples
Loaded 10000 test data samples

Samples usage: training = 50000, validation = 10000, test = 10000

Learning rate: 0.0020, Epochs: 20, Batch Size: 50

Before training: accuracy = 5.00% (2500/50000), cost = 2.3175, 34.324s

Epoch   1 : [==================================================] 123.060s
Training accuracy = 97.07% (48536/50000), cost = 0.0878, 32.930s
Validation accuracy = 97.49% (9749/10000), cost = 0.0799, 6.825s
Epoch   2 : [==================================================] 145.140s
Training accuracy = 97.87% (48935/50000), cost = 0.0657, 36.821s
Validation accuracy = 97.94% (9794/10000), cost = 0.0669, 5.939s
...
Epoch  19 : [==================================================] 101.305s
Training accuracy = 99.75% (49877/50000), cost = 0.0077, 26.094s
Validation accuracy = 98.96% (9896/10000), cost = 0.0684, 6.345s
Epoch  20 : [==================================================] 104.519s
Training accuracy = 99.73% (49865/50000), cost = 0.0107, 28.545s
Validation accuracy = 99.02% (9902/10000), cost = 0.0718, 7.885s

Test accuracy = 99.01% (9901/10000), cost = 0.0542, 5.910s

Total time taken : 3187s (53.12min)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;cifar10-图片分类&quot;&gt;CIFAR10 图片分类&lt;/h2&gt;
&lt;p&gt;第二个示例对来自 &lt;a href=&quot;https://www.cs.toronto.edu/~kriz/cifar.html&quot;&gt;CIFAR-10 数据集&lt;/a&gt;的 32×32 彩色图像进行分类. 这个数据集包含 60000 个图像，其中 50000 个用于训练，另外 10000 个用于测试. 图像分为 10 类：飞机、汽车、鸟、猫、鹿、狗、青蛙、马、船和卡车. 图 7 展示了部分内容.&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190116222355370-1819170028.jpg&quot;/&gt; 图 7 CIFAR10 数据集（部分）
&lt;p&gt;可以看到，CIFAR-10 数据集比 MNIST 手写数字复杂得多. 首先，图像是彩色的. 其次，它们不那么明显. 有些图如果不经提醒，我都认不出来. 网络的结构变得更大了，但并不是说它变得更深了，而是执行卷积和训练权重的&lt;em&gt;数量在增加&lt;/em&gt;. 它的网络结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Conv(32x32x3,  5x5x32, BorderMode::Same) -&amp;gt; ReLU -&amp;gt; MaxPool -&amp;gt; BatchNorm
Conv(16x16x32, 5x5x32, BorderMode::Same) -&amp;gt; ReLU -&amp;gt; MaxPool -&amp;gt; BatchNorm
Conv(8x8x32,   5x5x64, BorderMode::Same) -&amp;gt; ReLU -&amp;gt; MaxPool -&amp;gt; BatchNorm
FC(1024, 64) -&amp;gt; ReLU -&amp;gt; BatchNorm
FC(64, 10) -&amp;gt; SoftMax&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将上述神经网络结构转化为代码，得到以下结果：&lt;/p&gt;
&lt;div class=&quot;info note&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;用 &lt;code&gt;ReLU(MaxPool)&lt;/code&gt; 和 &lt;code&gt;MaxPool(ReLU)&lt;/code&gt; 计算结果相同，但计算量减少 75%，所以这里选用前者.&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 准备卷积神经网络
shared_ptr&amp;lt;XNeuralNetwork&amp;gt; net = make_shared&amp;lt;XNeuralNetwork&amp;gt;( );

net-&amp;gt;AddLayer( make_shared&amp;lt;XConvolutionLayer&amp;gt;( 32, 32, 3, 5, 5, 32, BorderMode::Same ) );
net-&amp;gt;AddLayer( make_shared&amp;lt;XMaxPooling&amp;gt;( 32, 32, 32, 2 ) );
net-&amp;gt;AddLayer( make_shared&amp;lt;XReLuActivation&amp;gt;( ) );
net-&amp;gt;AddLayer( make_shared&amp;lt;XBatchNormalization&amp;gt;( 16, 16, 32 ) );

net-&amp;gt;AddLayer( make_shared&amp;lt;XConvolutionLayer&amp;gt;( 16, 16, 32, 5, 5, 32, BorderMode::Same ) );
net-&amp;gt;AddLayer( make_shared&amp;lt;XMaxPooling&amp;gt;( 16, 16, 32, 2 ) );
net-&amp;gt;AddLayer( make_shared&amp;lt;XReLuActivation&amp;gt;( ) );
net-&amp;gt;AddLayer( make_shared&amp;lt;XBatchNormalization&amp;gt;( 8, 8, 32 ) );

net-&amp;gt;AddLayer( make_shared&amp;lt;XConvolutionLayer&amp;gt;( 8, 8, 32, 5, 5, 64, BorderMode::Same ) );
net-&amp;gt;AddLayer( make_shared&amp;lt;XMaxPooling&amp;gt;( 8, 8, 64, 2 ) );
net-&amp;gt;AddLayer( make_shared&amp;lt;XReLuActivation&amp;gt;( ) );
net-&amp;gt;AddLayer( make_shared&amp;lt;XBatchNormalization&amp;gt;( 4, 4, 64 ) );

net-&amp;gt;AddLayer( make_shared&amp;lt;XFullyConnectedLayer&amp;gt;( 4 * 4 * 64, 64 ) );
net-&amp;gt;AddLayer( make_shared&amp;lt;XReLuActivation&amp;gt;( ) );
net-&amp;gt;AddLayer( make_shared&amp;lt;XBatchNormalization&amp;gt;( 64, 1, 1 ) );

net-&amp;gt;AddLayer( make_shared&amp;lt;XFullyConnectedLayer&amp;gt;( 64, 10 ) );
net-&amp;gt;AddLayer( make_shared&amp;lt;XLogSoftMaxActivation&amp;gt;( ) );&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;剩下部分代码和前面的例子类似，也是生成训练内容，传递给助手类执行. 下面是这个例子的输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CIFAR-10 dataset classification example with Convolutional ANN

Loaded 50000 training data samples
Loaded 10000 test data samples

Samples usage: training = 43750, validation = 6250, test = 10000

Learning rate: 0.0010, Epochs: 20, Batch Size: 50

Before training: accuracy = 9.91% (4336/43750), cost = 2.3293, 844.825s

Epoch   1 : [==================================================] 1725.516s
Training accuracy = 48.25% (21110/43750), cost = 1.9622, 543.087s
Validation accuracy = 47.46% (2966/6250), cost = 2.0036, 77.284s
Epoch   2 : [==================================================] 1742.268s
Training accuracy = 54.38% (23793/43750), cost = 1.3972, 568.358s
Validation accuracy = 52.93% (3308/6250), cost = 1.4675, 76.287s
...
Epoch  19 : [==================================================] 1642.750s
Training accuracy = 90.34% (39522/43750), cost = 0.2750, 599.431s
Validation accuracy = 69.07% (4317/6250), cost = 1.2472, 81.053s
Epoch  20 : [==================================================] 1708.940s
Training accuracy = 91.27% (39931/43750), cost = 0.2484, 578.551s
Validation accuracy = 69.15% (4322/6250), cost = 1.2735, 81.037s

Test accuracy = 68.34% (6834/10000), cost = 1.3218, 122.455s

Total time taken : 48304s (805.07min)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面提到了，CIFAR-10 数据集来得更复杂！计算的结果远远达不到 MNIST 那样 99% 的准确度：训练集的准确度约 91%，测试／验证的准确度约 68-69%. 就是这样的精度，&lt;em&gt;区区 20 个世代的计算就花了我 13 个小时&lt;/em&gt;！这也说明了，对于卷积网络来说，（如果不用分布式集群或者超级计算机）普通 PC 仅仅使用 CPU 来计算显然不够看.&lt;/p&gt;

&lt;p&gt;本文中讨论了用 ANNT 库生成卷积神经网络. 在这一点上，它只能生成相对简单的网络，到目前为止，还不支持生产更高级、更流行的架构. 但是正如 CIFAR-10 一例中看到的，一旦神经网络变大，就需要更多的计算能力来进行训练，所以仅仅使用 CPU 是不够的（目前我只实现了用 CPU 计算网络）. 随着学习深入，这个弱点还会不断放大. 所以接下来我会优先研究如何实现 GPU 计算. 至于更复杂的神经网络架构，先往后放一放.&lt;/p&gt;
&lt;p&gt;现在已经讨论了全连接和卷积的神经网络，在接下来的文章里，我将介绍&lt;strong&gt;递归神经网络&lt;/strong&gt;（recurrent neural networks）架构.&lt;/p&gt;
&lt;p&gt;如果想关注 ANNT 库的进展，或者挖掘更多的代码，可以在 &lt;a href=&quot;https://github.com/cvsandbox/ANNT&quot;&gt;Github&lt;/a&gt; 上找到这个项目.&lt;/p&gt;

&lt;p&gt;本文以及任何相关的源代码和文件都是根据 &lt;a href=&quot;http://www.opensource.org/licenses/gpl-3.0.html&quot;&gt;GNU通用公共许可证（GPLv3）&lt;/a&gt;授权.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190112131615958-1292771686.jpg&quot;/&gt;&lt;br/&gt;Andrew Kirillov，来自英国🇬🇧，目前就职于 IBM.&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;&lt;hr/&gt;&lt;ol readability=&quot;-0.98507462686567&quot;&gt;&lt;li id=&quot;fn1&quot; readability=&quot;0.98507462686567&quot;&gt;
&lt;p&gt;Yann LeCun，中文名&lt;strong&gt;杨立昆&lt;/strong&gt;，Facebook 首席人工智能专家，人工智能研究院院长，被称为“深度学习三大巨头”之一，另外两位是 Geoffrey Hinton 和 Yoshua Bengio.&lt;a href=&quot;http://www.cnblogs.com/conmajia/p/annt-convolutional-neural-networks.html#fnref1&quot; class=&quot;footnote-back&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/section&gt;</description>
<pubDate>Wed, 16 Jan 2019 14:41:00 +0000</pubDate>
<dc:creator>I.am.Conmajia</dc:creator>
<og:description>使用 ANNT 库生成卷积神经网络实现图像分类. 全文约 11,000 字，建议阅读时间 30 分钟.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/conmajia/p/annt-convolutional-neural-networks.html</dc:identifier>
</item>
<item>
<title>设计模式——适配器模式 - NeilZhang</title>
<link>http://www.cnblogs.com/NeilZhang/p/10279549.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NeilZhang/p/10279549.html</guid>
<description>&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;适配器模式将某个类的接口转换成客户端期望的另一个接口表示，主的目的是&lt;strong&gt;兼容性&lt;/strong&gt;，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)。&lt;/p&gt;
&lt;p&gt;简单地说，就是需要的东西就在面前，但却不能使用，而短时间又无法改造它，于是我们就想办法适配它。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;适配器分类：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;类适配器模式&lt;/li&gt;
&lt;li&gt;对象的适配器模式&lt;/li&gt;
&lt;li&gt;接口的适配器模式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注： 如果对类图中的箭头有疑惑参考： &lt;a href=&quot;https://www.cnblogs.com/NeilZhang/p/10278995.html&quot;&gt;UML类图中的六种关系(物理设计阶段)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1. 类适配器模式&lt;/em&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;在Adapter中实现目标接口同时继承待适配类来完成适配：&lt;/p&gt;
&lt;p&gt;Target 为目标接口类&lt;/p&gt;
&lt;p&gt;Adaptee 为待适配类&lt;/p&gt;
&lt;p&gt;Adapter 适配器类: 将Adaptee适配为Target接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20170504162754080?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU0VVX0NhbHZpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;// 已存在的、具有特殊功能，但不符合我们既有的标准接口的类&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; Adaptee {
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; specificRequest() {
        System.out.println(&quot;&lt;span&gt;被适配的类，该类具有特殊功能&lt;/span&gt;&quot;);
    }
}

&lt;span&gt;// 目标接口&lt;/span&gt;
&lt;span&gt;interface&lt;/span&gt; Target {
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; request();
}

&lt;span&gt;// 具体目标类，只提供普通功能&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; ConcreteTarget &lt;span&gt;implements&lt;/span&gt; Target {
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; request() {
        System.out.println(&quot;&lt;span&gt;普通类，该类具有普通功能&lt;/span&gt;&quot;);
    }
}

&lt;span&gt;// 适配器类，继承了被适配类，同时实现标准接口&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; Adapter &lt;span&gt;extends&lt;/span&gt; Adaptee &lt;span&gt;implements&lt;/span&gt; Target{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; request() {
        &lt;span&gt;super&lt;/span&gt;.specificRequest();
    }
}

&lt;span&gt;//测试类&lt;/span&gt;
&lt;span&gt;// 使用普通功能类&lt;/span&gt;
Target concreteTarget = &lt;span&gt;new&lt;/span&gt; ConcreteTarget();
concreteTarget.request();   &lt;span&gt;//输出“普通类，该类具有普通功能”&lt;/span&gt;

&lt;span&gt;// 使用特殊功能类，即适配类&lt;/span&gt;
Target adapter = &lt;span&gt;new&lt;/span&gt; Adapter();
adapter.request();     &lt;span&gt;//输出“被适配的类，该类具有特殊功能”&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;2. 对象的适配器模式&lt;/em&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;与类适配器不同的是，对象适配器持有Adaptee对象而不需要继承它。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20170504162819956?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU0VVX0NhbHZpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//只需要修改适配器类即可&lt;/span&gt;
&lt;span&gt;//适配器类，只实现标准接口&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; Adapter &lt;span&gt;implements&lt;/span&gt; Target{
    &lt;span&gt;private&lt;/span&gt; Adaptee adaptee;
    &lt;span&gt;public&lt;/span&gt; Adapter (Adaptee adaptee) {
        &lt;span&gt;this&lt;/span&gt;.adaptee = adaptee;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; request() {
        &lt;span&gt;this&lt;/span&gt;.adaptee.specificRequest();
    }
}

&lt;span&gt;//测试类&lt;/span&gt;
Target concreteTarget = &lt;span&gt;new&lt;/span&gt; ConcreteTarget();
concreteTarget.request();  &lt;span&gt;//输出“普通类，该类具有普通功能”&lt;/span&gt;


&lt;span&gt;//Adapter需要先创建一个被适配类的对象作为参数&lt;/span&gt;
Target adapter = &lt;span&gt;new&lt;/span&gt; Adapter(&lt;span&gt;new&lt;/span&gt; Adaptee());
adapter.request();  &lt;span&gt;//输出“被适配的类，该类具有特殊功能”&lt;/span&gt;
---------------------
作者：SEU_Calvin
来源：CSDN
原文：https:&lt;span&gt;//blog.csdn.net/SEU_Calvin/article/details/71126649 &lt;/span&gt;
版权声明：本文为博主原创文章，转载请附上博文链接！
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;3. 接口的适配器模式&lt;/em&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;大话设计模式中没有 接口适配模式，但是很多网上文章中还是提到了接口适配，所以这里也讲解一下：&lt;/p&gt;
&lt;p&gt;目的：减少接口实现，Adaptee类只需要实现接口中的一部分&lt;/p&gt;
&lt;p&gt;Wrapper：相当于适配器（这里的作用和抽象类功能相同）&lt;/p&gt;
&lt;p&gt;Adaptee： 待适配的类，只实现了request接口而不需要实现cancel接口。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/918077/201901/918077-20190116213238481-1088281750.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/918077/201901/918077-20190116213238850-1125815396.png&quot; alt=&quot;image&quot; width=&quot;370&quot; height=&quot;379&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;Adapter继承自Adaptee和Target的类来完成适配。&lt;/p&gt;
&lt;p&gt;Adapter持有Adaptee对象并实现Target接口来完成适配（java类是单继承，最多只能继承一个类，对象适配器可以继承其它类）。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;使用实例&lt;/em&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;1. Android中ListView通过ListAdapter加载每一条View，而不需要考虑各个view的不同&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/918077/201901/918077-20190116213239777-1025489539.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/918077/201901/918077-20190116213240593-884428158.png&quot; alt=&quot;image&quot; width=&quot;640&quot; height=&quot;386&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ListView   是client&lt;/p&gt;
&lt;p&gt;ListAdapter 是 Target&lt;/p&gt;
&lt;p&gt;BaseAdapter/ArrayAdapter/CursorAdapter 是 适配类&lt;/p&gt;
&lt;p&gt;List&amp;lt;T&amp;gt;/Cursor 中保存了列表数据，需要适配成多个view展示到ListView上，它相当于 Adaptee&lt;/p&gt;
&lt;p&gt;所以这里使用了: &lt;span&gt;类适配模式 + 接口适配模式&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.jdk中InputStreamReader/OutputStreamWriter&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://hi.csdn.net/attachment/201101/3/0_1294058999cvJS.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Reader/Writer ： 相当于 Target&lt;/p&gt;
&lt;p&gt;InputStreamReader 是 Adapter&lt;/p&gt;
&lt;p&gt;InputStrea 是 Adaptee&lt;/p&gt;
&lt;p&gt;所以这里使用了: &lt;span&gt;对象适配&lt;/span&gt;&lt;span&gt;&lt;span&gt;模式&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. jdk中Arrays.asList(T …a)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将 数组适配成List对象，这里好像和上面讲的三种模式都不像，&lt;span&gt;它通过一个接口将一种对象类型数据转换为另一种类型数据：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;输出类型List 作为 Target&lt;/p&gt;
&lt;p&gt;asList接口  作为 Adapter&lt;/p&gt;
&lt;p&gt;输入数组 a 是 Adaptee&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;《大话设计模式》&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://blog.csdn.net/SEU_Calvin/article/details/71126649&quot; href=&quot;https://blog.csdn.net/SEU_Calvin/article/details/71126649&quot;&gt;https://blog.csdn.net/SEU_Calvin/article/details/71126649&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://www.jianshu.com/p/78f6083ef869&quot; href=&quot;https://www.jianshu.com/p/78f6083ef869&quot;&gt;https://www.jianshu.com/p/78f6083ef869&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 16 Jan 2019 13:34:00 +0000</pubDate>
<dc:creator>NeilZhang</dc:creator>
<og:description>适配器模式将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)。 简单地说，就是需要的东西就在面前，但</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/NeilZhang/p/10279549.html</dc:identifier>
</item>
<item>
<title>Salesforce Sales Cloud 零基础学习(三) Lead &amp; Opportunity &amp; Quote - zero.zhang</title>
<link>http://www.cnblogs.com/zero-zyq/p/10274345.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zero-zyq/p/10274345.html</guid>
<description>&lt;p&gt;上一篇讲的是Account 和 Contact，本篇主要描述 Lead &amp;amp; Opportunity &amp;amp; Quote.他们的主要的作用如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Lead 用来存储潜在客户。&lt;/li&gt;
&lt;li&gt;Opportunity 用来track潜在的订单。&lt;/li&gt;
&lt;li&gt;Quote 用来记录不断和客户进行报价的信息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;一.Lead&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们通过做市场活动，或者用户点击了公司网站，电销，广告等方式，使用户对公司的产品感兴趣，我们可以将这些针对公司产品感兴趣的用户作为潜在用户存储到Lead中，针对优质的Lead，后期可以转换成 Account和 Contact并且争取有Opportunity来建立起潜在的订单。Lead在salesforce中API Name为Lead.&lt;/p&gt;
&lt;p&gt;Lead 常用功能&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. Lead Conversion&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们认为优质的Lead，可以将其转换成相对应的 Account / Contact / Opportunity.&lt;/p&gt;
&lt;p&gt;我们在Lead上可能有自定义的字段，比如想要标记Lead的星级，我们可以在Lead上增加自定义字段 Lead Score，&lt;/p&gt;
&lt;p&gt;如果我们想要在Account或者Contact上也要这个字段，我们只要在Account以及Contact上创建同样的名字的字段，然后再Lead的Field中点击‘Map Lead Fields’即可设置Mapping关系，当 Lead convert时，便可以不需要自己写代码，自动将这个字段转换过去。&lt;/p&gt;
&lt;p&gt;Lead Conversion 可以查看此视频： &lt;a href=&quot;http://salesforce.vidyard.com/watch/gKjoNI_n5O9WfYpqE_p3Xg&quot; target=&quot;_blank&quot;&gt;http://salesforce.vidyard.com/watch/gKjoNI_n5O9WfYpqE_p3Xg&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;需要注意两点的是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当Lead Conversion 以后，你将在search框中查询不到该lead，除非你拥有 ‘View and Edit Converted Leads’权限&lt;/li&gt;
&lt;li&gt;当Lead上有Notes &amp;amp; Attachment, 转换后在转换的 Account / Contact / Opportunity 将均拥有这个Notes &amp;amp; Attachment&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Lead Convert 步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;进入一个想要Convert的lead，点击Convert按钮;&lt;/li&gt;
&lt;li&gt;如果系统已经有Account，则选择已有的Account，如果没有则新建&lt;/li&gt;
&lt;li&gt;如果系统已经有Contact，则选择已有的Contact，如果没有则新建&lt;/li&gt;
&lt;li&gt;如果系统已经有Opportunity，则选择已有的Opportunity，如果没有可以输入Opportunity的名字&lt;/li&gt;
&lt;li&gt;创建需要后期追踪的task（可选项）&lt;/li&gt;
&lt;li&gt;点击Convert按钮，实现Lead的Convert.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/910966/201901/910966-20190115211451038-517595687.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. Merge Duplicate Lead&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在系统中难免有重复的数据，针对重复的数据，我们需要对重复的数据进行merge操作以避免后期无用的转换。&lt;/p&gt;
&lt;p&gt;当我们点击进入一个Lead,点击 Find Duplicates,如果有重复的Lead,会在Matching Leads处有记录，点击Merge Leads,根据你想要的Lead的信息选择即可。&lt;/p&gt;
&lt;p&gt;除了使用标准的 Duplicate Lead Merge功能，还可以使用第三方的功能， Lightning Data 或者 Data.com。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二. Opportunity&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Opportunity 可以理解成正在进行中的交易，通过Opportunity可以追踪当前潜在的交易的阶段，金额，客户想要的产品，每一次的报价信息，竞争对手信息等。&lt;/p&gt;
&lt;p&gt;Sales Cloud 借助销售漏斗模型进行管理和预测销售的业绩，准确的Opportunity关系到 Forcast的准确性，所以Opportunity的真实性以及重要性不言而喻。Opportunity在salesforce标准的API名称为 Opportunity。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. 管理 Opportunity Product&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们新建了一个Opportunity，选择了要交易的Account或者 Contact 新建以后，我们便针对这个客户或者联系人(可能person account直接维护在Contact中)创建好了Opportunity，使用它来追踪这次交易的状态。客户需要买的是我们的公司的产品或者服务，所以我们需要在Opportunity中关联客户想要的Product信息，包括选择的产品/服务，销售价，数量,折扣等信息，Opportunity Product在Salesforce的API 名字为 OpportunityLineItem.&lt;/p&gt;
&lt;p&gt;我们在Opportunity上有 Amount字段，这个Amount字段自动汇总了所有你添加的Opportunity Product的sales price * quantity.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 跟踪竞争对手信息&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;你的企业客户可能找了多家公司报价，你也可以在Opportunity中维护你的竞争对手的信息。竞争对手在Salesforce 中对应的API名字为OpportunityCompetitor。&lt;/p&gt;
&lt;p&gt;在SetUp -&amp;gt; 搜索 Competitor 即可找到，点击进入维护一下需要维护的竞争对手名称即可。&lt;/p&gt;
&lt;p&gt;OpportunityCompetitor 常用字段：CompetitorName,OpportunityId,Strengths,Weaknesses ; 可以通过Opportunity.xxxField获取Opportunity的字段&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. 维护你的Partner信息&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在Opportunity中也可以维护你的Partner信息，Partner在Salesforce中对应的API 名字为OpportunityPartner，当新建了一个Opportunity 的partner以后，同时也会在这个Opportunity对应的Account上创建相同信息的Partner,在Account上面的Partner的API 名称为AccountPartner&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4. 维护你的 Opportunity Team Member&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Account中我们有介绍过Account Team Member的概念，在Opportunity中，我们也可以维护一组Opportunity team member去争取更大几率的赢单。Opportunity Team Member在salesforce中的API名称为：OpportunityTeamMember&lt;/p&gt;
&lt;p&gt;Account Team Member是针对这个Account而言，一个Account可能有多个Opportunity， Opportunity team member针对 当前的Opportunity而言，所以两者还是有本质的区别的。&lt;/p&gt;
&lt;p&gt;针对 Opportunity Team 可能有两个场景会经常用到：&lt;/p&gt;
&lt;p&gt;1) 针对系统中的Opportunity，经常会有一组人员会协助跟进，这个时候我们可以设置并且添加 default opportunity team;&lt;/p&gt;
&lt;p&gt;2) 如果系统中设置了Opportunity访问权限为私有的，我们需要某个专家去协助跟进这个Opportunity,我们可以将这个 专家添加到Opportunity Team 中并且分配他的访问权限。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5. 管理你的 Sales Process&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;公司可能有不同类型的产品，针对不同类型的产品可能销售阶段也不同，这里就要针对不同的销售阶段引出来Sales Process概念。&lt;/p&gt;
&lt;p&gt;Sales Process通常需要和 Record Type 以及 Opportunity Layout共同使用，以确保不同的record type进来，可以有不同的Sales Process.&lt;/p&gt;
&lt;p&gt;Why you need Sales Process链接：&lt;a href=&quot;https://www.salesforce.com/blog/2013/06/sales-process.html&quot; target=&quot;_blank&quot;&gt;https://www.salesforce.com/blog/2013/06/sales-process.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Trailhead：&lt;a href=&quot;https://trailhead.salesforce.com/content/learn/modules/admin_intro_opptys_leads/admin_intro_opptys_leads_opportunities&quot; target=&quot;_blank&quot;&gt;https://trailhead.salesforce.com/content/learn/modules/admin_intro_opptys_leads/admin_intro_opptys_leads_opportunities&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三.Quote&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;报价代表着贵公司产品和服务的建议销售价格，针对一个Opportunity，我们可能需要做多次报价操作，报价也是一个议价的过程，我们可以针对客户选择的产品和服务进行折扣以争取最大可能的赢单。Quote在salesforce的标准的API名称为Quote。&lt;/p&gt;
&lt;p&gt;使用 Quote时我们需要先在 Quote Setting中 enable quote，操作为 Setup -&amp;gt; 搜索 Quotes Settings 然后选择在哪个 opportunity page layout显示quote related list后 enable即可&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1 Quote Template&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当我们针对客户进行报价时，我们可以定义好生成的模板，这样当我们生成PDF，选择指定模板以后就可以生成基于当前报价单的PDF信息供给客户查看。&lt;/p&gt;
&lt;p&gt;在 SetUp -&amp;gt; 搜索 Template后在Quotes下面有Template，点击New 即可新建 Template。 Template通常包括以下几部分信息：&lt;/p&gt;
&lt;p&gt;Header / Body / Footer。 可以添加的类型为： Image / Rich Test / List / Total Section。当然一定要注意创建的 Template默认都是 inactive的，如果使用的话需要将其active&lt;/p&gt;
&lt;p&gt;配置好PDF以后，在 Quote详情页，点击 Create PDF即可生成我们要求的指定 Template的报价单。&lt;/p&gt;
&lt;p&gt;Quote Template 可以参看这个视频：&lt;a href=&quot;http://salesforce.vidyard.com/watch/_U4ePtDJHuot9OMHSZTLEA&quot; target=&quot;_blank&quot;&gt;http://salesforce.vidyard.com/watch/_U4ePtDJHuot9OMHSZTLEA&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. Quote Sync&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当我们 New Quote时，我们会生成一个新的 Quote 及其对应的 Quote Line Item, Quote Line Item 会将 Opportunity Line Item的内容同步过来，当然对应的表不同， Quote Line Item 在salesforce 的API名字为：QuoteLineItem,主要字段有：LineNumber、ListPrice、PricebookEntryId、Product2Id、Quantity、QuoteId、UnitPrice、Subtotal、TotalPrice。&lt;/p&gt;
&lt;p&gt;我们在做报价时，一个Opportunity会有多个 Quote，当客户对某个Quote很满意时，我们可以将 Quote信息同步到 Opportunity,同步以后，会将Quote的字段同步到Opportunity的相关字段， Quote Line Item的价格折扣等信息同步到 Opportunity Line Item。 需要注意的是：在一个时间，只允许有一个Quote可以Sync到Opportunity，如果后面的Quote sync到了 Opportunity，则前面的会自动解除 Sync。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/910966/201901/910966-20190116114124738-177558086.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 总结：&lt;/strong&gt;篇中只是简单的描述一下这三个标准的对象的业务含义以及简单的功能介绍，如果要详细了解sales cloud知识，自行查看sales cloud文档。篇中有问题地方欢迎指出，有不懂的欢迎留言。&lt;/p&gt;
</description>
<pubDate>Wed, 16 Jan 2019 12:34:00 +0000</pubDate>
<dc:creator>zero.zhang</dc:creator>
<og:description>上一篇讲的是Account 和 Contact，本篇主要描述 Lead &amp; Opportunity &amp; Quote.他们的主要的作用如下： Lead 用来存储潜在客户。 Opportu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zero-zyq/p/10274345.html</dc:identifier>
</item>
</channel>
</rss>