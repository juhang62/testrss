<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Mac从拆箱到入门 - dawa大娃bigbaby</title>
<link>http://www.cnblogs.com/bigbaby/p/12004579.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bigbaby/p/12004579.html</guid>
<description>&lt;p&gt;&lt;strong&gt;Mac从拆箱到入门&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;记录首次使用Mac的我的历程，不是专业的Mac使用教程，只是简单的记录。还有我在使用过程中一些用到的功能都一些小提示吧。 &lt;/p&gt;

&lt;p&gt;1.&lt;strong&gt;首次开机配置&lt;/strong&gt;，对于一个完全的新手来说（也就是我）是完全懵逼的一个状态，幸亏啊，幸亏这个语音提示挺给力，光开机配置我就慢慢研究了接近20分钟吧，使用这个语音助手一个字一个字的将所有的文字都理解了一遍，也发生了一些比较尴尬的事情，比如啊键盘上有一个Esc键，然后指示里面提示的escape，我竟然不知道这个键在哪，过了一会之后才恍然大悟过来，这原来不就是esc键嘛，我也通过这一个简单的小插曲认识到：我的英语原来是这么的差，因为我反应过来知道是esc键之后，我就翻译了一下这个escape单词的意思，这个意思有‘逃避，避开，避免’的意思，这也就是这个键盘表示的实际功能。总的来说，就是下一步，下一步，下一步，按照正确的选项，进入系统就行了。没有任何的技巧。&lt;/p&gt;

&lt;p&gt;2.&lt;strong&gt;关于输入法中英文的切换&lt;/strong&gt;，在window里面使用shift键就可以直接切换中英文的输入状态，在Mac里面呢，我按了几下shift没有反应之后就去百度了，因为当时是让我输入邮箱的账号，里面的符号是中文符号的,所以当时也着急找到解决方法，我问二娃呢，二娃也在摸索。突然间，看到了键盘上（以前的大小写切换键盘）上面写着这样‘中/英’的字样，点了一下，成了。&lt;/p&gt;

&lt;p&gt;3.&lt;strong&gt;关于下载软件&lt;/strong&gt;，我听说可以使用，我也就用这个去下载了一个微信，第一次下载的时候，需要登陆你的Apple ID，如果没有的话可以在这个时候注册，第一次登陆的时候还需要绑定一个支付方式，用于你购买软件的时候能够支付。一些特殊的软件，还是可以到软件的官网下载的，他们一般都支持的有Mac版本，比如我开发要用的IDEA，Google，有道云笔记，FortiClient,等等，这个最好直接配置下允许系统安装从非Apple Store下载的软件。&lt;/p&gt;

&lt;p&gt;4.&lt;strong&gt;Mac里面提供的这个toughbar&lt;/strong&gt;，简直是太好用了，智能人性化，功能变换无穷，不同的软件那个地方会显示他们的基本操作，比如打开浏览器的时候，能够直接在toughbar上面选择切换tab选项卡，打开新的窗口等等，在打字的时候能够智能提示，并且直接在这里输入表情等等，还有系统的基本控制操作，如音量，显示亮度，Siri的快捷调用等等，我觉得我要培养一下我的这个习惯，就是说每打开一个软件的时候看看那里都有什么快捷的方式，好好的把这个功能给利用起来。&lt;/p&gt;

&lt;p&gt;5.&lt;strong&gt;关于Mac的Logo会不会亮的问题&lt;/strong&gt;，因为之前和二娃都见过别人的Mac的logo会亮，我们呢就想着这个怎么弄呢，哈哈，先是在设置里面寻找了一番，没有找到相应的设置，后来Google搜索了一下，原来只有老版本的Mac可以亮，新版的去除了这个功能。好的吧。&lt;/p&gt;

&lt;p&gt;6.&lt;strong&gt;关于Mac的鼠标触碰版&lt;/strong&gt;，我之前以为苹果电脑触控板或者苹果手机的按钮是能够按下去的按键呢，今天二娃突然就给我说，我发现，咱们这个触控板的震动强度能够调，是不是能够通过设置调节这个按钮的深度呢？（这个时候还是以为他是按键呢），二娃说，我知道了，咱们这个是触控板，和苹果手机的那个按钮一样，在触摸的时候他给你震动反馈，我刚才关机的时候，按了触控板，他不是按键。emm. 被普及到了。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;基本操作到此，接下来介绍一些：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;程序员需要搭建的开发环境（Java路线）&lt;/p&gt;
&lt;p&gt;1.基本软件的安装 . homebrew 安装&lt;/p&gt;

&lt;p&gt;简介：Homebrew是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。又提示缺少套件啦？别担心，Homebrew 随时守候。Homebrew —— OS X 不可或缺的套件管理器。&lt;/p&gt;
&lt;p&gt;安装步骤：&lt;/p&gt;
&lt;p&gt;打开Terminal，输入下面的指令&lt;/p&gt;
&lt;div id=&quot;7850-1575724174728&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/usr/bin/ruby -e &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;他会先让你点Enter键，然后会让你输入密码（这个密码是你电脑的锁屏密码）&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;接来下就会自动下载安装成功。&lt;/p&gt;
&lt;p&gt;然后在命令行中输入 。 brew，有提示面板就代表成功了&lt;/p&gt;

&lt;p&gt;2.关于电脑主机名的修改&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/37E0F67CD04540D79084A43B677E0E3C&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;我这里默认的是我的名字加上后缀，我现在需要修改一下它（我要换成dawa,哈哈）&lt;/p&gt;
&lt;p&gt;修改Hostname&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sudo scutil --&lt;span&gt;set&lt;/span&gt; HostName dawa
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;4396-1575723683451&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1464573/201912/1464573-20191208084520755-2144307669.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;3.安装JDK，使用homebrew （我这里选择的是jdk8，如果）&lt;em id=&quot;__mceDel&quot;&gt; &lt;/em&gt;&lt;/p&gt;
&lt;p&gt;首先呢，可以先用br&lt;/p&gt;
&lt;div id=&quot;5083-1575725019913&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;:brew tap AdoptOpenJDK/&lt;span&gt;openjdk
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;:brew cask install adoptopenjdk8
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;就这两条简单的指令啊，我不知道输错了多少次，一定要拼写正确哦。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1464573/201912/1464573-20191208084829320-797374961.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/597E1F369F044CD5B5CFE5BC487DA1DD&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;自动会下载，在安装之前会让你再输入一个密码（这个密码也是锁屏密码）&lt;/p&gt;
&lt;p&gt;安装完成之后再terminal里面输入Java -version，输出版本号即可，本来我还想Mac里面怎么配环境变量。&lt;/p&gt;
&lt;p&gt;下次需要的时候再单独拿出来处理吧。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/6F85BEAE9DA44A9595782DA93E9B060A&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1464573/201912/1464573-20191208084845625-1473113385.png&quot; alt=&quot;&quot;/&gt; &lt;/div&gt;

&lt;p&gt;4.安装Git，还是使用homebrew&lt;/p&gt;
&lt;p&gt;先查看本地是否安装Git，&lt;/p&gt;
&lt;div id=&quot;3090-1575729069680&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
git --version
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;我这里会默认显示一个apple的git版本&lt;/p&gt;
&lt;p&gt;如果想要下载的话，还是使用homebrew来进行下载，指令很简单，还是之前的流程，&lt;/p&gt;
&lt;p&gt;可以先查看，使用search指令，然后再下载安装使用install指令&lt;/p&gt;
&lt;div id=&quot;5614-1575764956303&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
brew install git
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1464573/201912/1464573-20191208084931385-1457111573.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div readability=&quot;7&quot;&gt;&lt;img src=&quot;https://note.youdao.com/src/FD16C602747742B38A5902F53C3397F3&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;另外列出几个常用的命令&lt;/div&gt;
&lt;div id=&quot;9329-1575729653487&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ls ： 列举当前目录的文件夹
cd 目录名称： 进入文件夹
cd ..&lt;/span&gt;/：返回上一级目录&lt;/pre&gt;
&lt;p&gt;&lt;br class=&quot;Apple-interchange-newline&quot;/&gt;
快速打开访达的搜索：co+s&lt;/p&gt;
&lt;p&gt;快速打开全局搜索：c+s&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Mac丢失追踪的功能挺好用的，绑定Apple ID的电脑，在登陆iCloud的时候可以查找你的设备&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/087EA4A653994BA78C375849100E06CC&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;点击有上角的AppleID，然后选择左边菜单栏里面的最后一项，在里面开启定位&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/EB3752DE04D34E219E3E49492627240B&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div&gt; &lt;img src=&quot;https://img2018.cnblogs.com/common/1464573/201912/1464573-20191208085107601-513473283.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1464573/201912/1464573-20191208085117456-1576439801.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt; 
&lt;hr/&gt;&lt;/p&gt;
&lt;p&gt;总的来说呢，没有任何技巧。想必每个人拿到电脑的时候，都会慢慢的熟悉一天&lt;/p&gt;
&lt;p&gt;一天之后，你对Mac的使用，肯定有所掌握。&lt;/p&gt;

</description>
<pubDate>Sun, 08 Dec 2019 00:52:00 +0000</pubDate>
<dc:creator>dawa大娃bigbaby</dc:creator>
<og:description>Mac从拆箱到入门 记录首次使用Mac的我的历程，不是专业的Mac使用教程，只是简单的记录。还有我在使用过程中一些用到的功能都一些小提示吧。 1.首次开机配置，对于一个完全的新手来说（也就是我）是完全</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bigbaby/p/12004579.html</dc:identifier>
</item>
<item>
<title>WebGPU学习（四）:Alpha To Coverage - Wonder-YYC</title>
<link>http://www.cnblogs.com/chaogex/p/12004546.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chaogex/p/12004546.html</guid>
<description>&lt;p&gt;大家好，本文学习与MSAA相关的Alpha To Coverage以及在WebGPU中的实现。&lt;/p&gt;
&lt;p&gt;上一篇博文&lt;br/&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/95930763&quot;&gt;WebGPU学习（三）:MSAA&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;前置知识&quot;&gt;前置知识&lt;/h2&gt;
&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;开启了MSAA和Alpha To Coverage后，fragment的alpha值（fragment shader输出的颜色的alpha值）会影响该fragment对应像素的采样点是否被覆盖。&lt;/p&gt;
&lt;h2 id=&quot;动机&quot;&gt;动机&lt;/h2&gt;
&lt;p&gt;参考&lt;a href=&quot;http://www.zwqxin.com/archives/opengl/talk-about-alpha-to-coverage.html&quot;&gt;乱弹纪录II:Alpha To Coverage&lt;/a&gt;：&lt;br/&gt;&lt;img src=&quot;http://static.zybuluo.com/yangyc/lmv12ihkuodtb2i78xl3wd9y/%E6%88%AA%E5%B1%8F2019-12-07%E4%B8%8B%E5%8D%883.48.09.png&quot; alt=&quot;截屏2019-12-07下午3.48.09.png-220.6kB&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://static.zybuluo.com/yangyc/mkusa81g92wg3tqpxtmc042h/%E6%88%AA%E5%B1%8F2019-12-07%E4%B8%8B%E5%8D%883.48.17.png&quot; alt=&quot;截屏2019-12-07下午3.48.17.png-844.8kB&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://static.zybuluo.com/yangyc/mdnlj97g7wofgjojbndboko7/%E6%88%AA%E5%B1%8F2019-12-07%E4%B8%8B%E5%8D%883.48.23.png&quot; alt=&quot;截屏2019-12-07下午3.48.23.png-203.1kB&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://static.zybuluo.com/yangyc/wp14rb2jpm7ijbfqhzkf5vpm/%E6%88%AA%E5%B1%8F2019-12-07%E4%B8%8B%E5%8D%883.48.29.png&quot; alt=&quot;截屏2019-12-07下午3.48.29.png-774.9kB&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://static.zybuluo.com/yangyc/io5jm4efldzjo9mlkrnv6ftc/%E6%88%AA%E5%B1%8F2019-12-07%E4%B8%8B%E5%8D%889.25.41.png&quot; alt=&quot;截屏2019-12-07下午9.25.41.png-380.3kB&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;
&lt;h3 id=&quot;覆盖检测&quot;&gt;覆盖检测&lt;/h3&gt;
&lt;p&gt;通过&lt;a href=&quot;https://zhuanlan.zhihu.com/p/95930763&quot;&gt;WebGPU学习（三）:MSAA&lt;/a&gt;对MSAA原理的介绍，我们知道gpu要经过覆盖检测的步骤，来决定哪些采样点被覆盖。没有被覆盖的采样点不会进入“解析”步骤。&lt;/p&gt;
&lt;p&gt;覆盖检测的结果是计算出每个fragment的coverage（覆盖率）。&lt;/p&gt;
&lt;p&gt;根据&lt;a href=&quot;http://www.zwqxin.com/archives/opengl/talk-about-alpha-to-coverage.html&quot;&gt;乱弹纪录II:Alpha To Coverage&lt;/a&gt; 的说法，开启MSAA后，每个fragment带了一个新属性coverage（覆盖率），它是一个二进制的bit掩码mask。&lt;/p&gt;
&lt;p&gt;以4X MSAA为例，每个fragment的coverage为xxxx，其中x为0或1。它的每一位对应像素的一个采样点sample，0表示该sample没被覆盖，1表示被覆盖。&lt;/p&gt;
&lt;p&gt;所以coverage这个掩码对应了采样点的覆盖情况。&lt;/p&gt;
&lt;h3 id=&quot;如何计算coverage&quot;&gt;如何计算coverage&lt;/h3&gt;
&lt;p&gt;1.用户可以设置一个固定的coverage掩码，这里命名为FixedSampleMask&lt;/p&gt;
&lt;p&gt;2.gpu检测每个像素有哪些采样点被primitive覆盖，得到该采样点的coverage掩码，这里命名为RasterizerCoverageMask&lt;/p&gt;
&lt;p&gt;3.如果开启了Alpha To Coverage，则会将fragment的alpha值转换为coverage掩码，这里命名为AlphaCoverageMask&lt;/p&gt;
&lt;p&gt;转换的算法可以参考&lt;a href=&quot;http://www.zwqxin.com/archives/opengl/talk-about-alpha-to-coverage.html&quot;&gt;乱弹纪录II:Alpha To Coverage&lt;/a&gt; ：&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;一个fragment的Alpha值在0~1间，它对应着一个dither mask。还是以4XMSAA为例，这个dither mask也是xxxx的形式，Alpha为0对应了0000，alpha为1对应了1111，至于中间的值的对应关系，OpenGL是交由显卡制造商决定的——其实一般就是类似[0~0.249 -&amp;gt; 0000, 0.25~0.499 -&amp;gt; 0001, 0.5~0.749 -&amp;gt; 0011, 0.75~0.99-&amp;gt; 0111]这样。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;4.fragment shader可以输出该fragment的coverage掩码，这里称为FragShaderSampleMaskOutput&lt;/p&gt;
&lt;p&gt;像素最终的coverage = FixedSampleMask &amp;amp; RasterizerCoverageMask &amp;amp; AlphaCoverageMask &amp;amp; FragShaderSampleMaskOutput&lt;br/&gt;（“&amp;amp;”是逻辑与运算，如0011 &amp;amp; 0010 = 0010）&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.zwqxin.com/archives/opengl/talk-about-alpha-to-coverage.html&quot;&gt;乱弹纪录II:Alpha To Coverage&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;暂时没有实现的sample，我们根据WebGPU规范和相关资料，分析下WebGPU如何实现Alpha To Coverage。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在render pipeline descriptor中设置固定的coverage掩码FixedSampleMask和是否开启Alpha To Coverage：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;dictionary GPURenderPipelineDescriptor : GPUPipelineDescriptorBase {
...
    unsigned long sampleMask = 0xFFFFFFFF;
    boolean alphaToCoverageEnabled = false;
...    
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们注意到sampleMask是unsigned long类型，它是32位的，而coverage应该是二进制的（如4X MSAA的coverage是4位的二进制），所以这里是进行了进制转换。&lt;/p&gt;
&lt;p&gt;举例来说：&lt;br/&gt;对于4X MSAA，如果设置sampleMask为0x1（十六进制），则它转换为二进制是0001；&lt;br/&gt;如果设置sampleMask为0x3，则它转换为二进制是0010&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以在fragment shader中设置输出的coverage掩码FragShaderSampleMaskOutput&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;根据&lt;a href=&quot;https://github.com/gpuweb/gpuweb/issues/267&quot;&gt;Investigation: Multisample Coverage&lt;/a&gt;，我们知道Vulkan-&amp;gt;SPIR-V的fragment shader支持内置的SampleMask变量。&lt;/p&gt;
&lt;p&gt;因为Chrome实现的WebGPU也使用SPIR-V作为shader编译后的字节码，所以WebGPU在这点上应该与Vulkan类似。&lt;/p&gt;
&lt;p&gt;我没有搜索到SPIR-V中关于SampleMask的详细资料，但是考虑到Chrome实现的WebGPU使用GLSL 4.5，所以我们可以看下它关于gl_SampleMask的&lt;a href=&quot;https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/gl_SampleMask.xhtml&quot;&gt;说明&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Name&lt;br/&gt;gl_SampleMask — specifies the sample coverage mask for the current fragment&lt;br/&gt;Declaration&lt;br/&gt;out int gl_SampleMask[] ;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们看到gl_SampleMask的每个元素的类型是32位的，所以也进行了进制转换。&lt;/p&gt;
&lt;p&gt;又因为它是数组，所以它支持coverage为超过32位的二进制（如支持64X MSAA）&lt;/p&gt;
&lt;p&gt;用代码来说明：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//in fragment shader

gl_SampleMask[0] = 1;   //对于4X MSAA来说，相当于设置该fragment的coverage为0001
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//in fragment shader

gl_SampleMask[0] = 2;

gl_SampleMask[1] = 1;   //对于64X MSAA来说，可能相当于设置该fragment的coverage为000...1000...10 （前面的000...1有32位，后面的000...10有32位） (我不能确定这是否正确！)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果开启了Alpha To Coverage，则不能在fragment shader中输出coverage掩码&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果开启了Alpha To Coverage，将alpha转换为掩码的算法在不同的浏览器中不一样&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;参考资料-1&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/gpuweb/gpuweb/issues/267&quot;&gt;Investigation: Multisample Coverage&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://docs.google.com/document/d/1RxZx6K2eytCCNI593YtEDgyxP84iuG0xvcS-Fr2EZsk/edit#heading=h.o7nziwf8wb1n&quot;&gt;Minutes for GPU Web meeting 2019-04-29&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/gl_SampleMask.xhtml&quot;&gt;OpenGL-&amp;gt;gl_SampleMask&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 08 Dec 2019 00:11:00 +0000</pubDate>
<dc:creator>Wonder-YYC</dc:creator>
<og:description>大家好，本文学习与MSAA相关的Alpha To Coverage以及在WebGPU中的实现。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chaogex/p/12004546.html</dc:identifier>
</item>
<item>
<title>python-14-文件操作 - 广深-小龙</title>
<link>http://www.cnblogs.com/gsxl/p/11966383.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gsxl/p/11966383.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;python中对文件的读写也是非常方便的，本章节将讲解读、写、读写等常用操作。下面讲师必要的参数：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、文件路径&lt;/strong&gt;：必须得知道文件的路径，不然怎样进行读写？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、编码方式&lt;/strong&gt;：utf-8，gbk，gb2312....（python3的str是unicode编码存储的，我们一般常用utf-8存在，编码不了解的话容易出现乱码）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、操作模式&lt;/strong&gt;：只读，只写，追加，写读，读写。&lt;/p&gt;
&lt;p&gt;　　“r”打开读取（默认）&lt;/p&gt;
&lt;p&gt;　　“w”打开进行写入，首先截断文件&lt;/p&gt;
&lt;p&gt;　　“x”创建一个新文件并打开它进行写入&lt;/p&gt;
&lt;p&gt;　　“a”打开写入，如果文件存在，则追加到文件的末尾&lt;/p&gt;
&lt;p&gt;　　“b”二进制模式&lt;/p&gt;
&lt;p&gt;　　“t”文本模式（默认）&lt;/p&gt;
&lt;p&gt;　　“+”打开磁盘文件进行更新（读写）&lt;/p&gt;
&lt;p&gt;　　“U”通用换行模式（已弃用）&lt;/p&gt;
&lt;h3&gt;一、只读&lt;/h3&gt;
&lt;p&gt;1、r：str方式读，编码：UTF-8，bytes --》 str（将我们的文件转为python3中的str）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1、r：str方式读，编码：UTF-8&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; bytes --》 str&lt;/span&gt;
f = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
c &lt;/span&gt;=&lt;span&gt; f.read()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(c)
f.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1815594/201912/1815594-20191201154905729-1675242227.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2、rb：bytes方式读，非文字的文件。可以看到【我是一个文件哈】是7个文字，一个文字3个字节，所以我们转换为bytes有21个，每个 \ 隔开。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2、rb：bytes方式读，非文字的文件&lt;/span&gt;
f = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
c &lt;/span&gt;=&lt;span&gt; f.read()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(c)
f.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1815594/201912/1815594-20191201155039267-1318688376.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 二、只写&lt;/h3&gt;
&lt;p&gt;1、w：写入，没有此文件则是新创建，有此文件会清空源文件再写。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1、w：写入，没有此文件是创建，有此文件会清空源文件再写&lt;/span&gt;
f = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
f.write(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;abc小龙abc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
f.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1815594/201912/1815594-20191201155545657-1262856871.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2、wb：二进制写入，凡是有wb都需要加.encode(&quot;utf-8&quot;)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2、wb：写入，没有此文件是创建，有此文件会清空源文件再写&lt;/span&gt;
f = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;log1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
f.write(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;abc小龙abc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.encode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 以utf-8编码格式，写入东西&lt;/span&gt;
f.close()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1815594/201912/1815594-20191201155807381-1013984038.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3、a：追加写入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3、a：追加写入&lt;/span&gt;
f = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;log1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
f.write(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;abc小龙abc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
f.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1815594/201912/1815594-20191201160630258-924515929.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 三、读写&lt;/h3&gt;
&lt;p&gt;1、r+ 先读再写，推荐该 r+ 方式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1、先读再写，写了不能再读&lt;/span&gt;
f = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
f.seek(0)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(f.read())
f.write(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;小哥哥谈恋爱吗？我偷老公的钱养你&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
f.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1815594/201912/1815594-20191201160814110-1392909471.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2、先写再读，推荐该 r+ 方式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2、先写再读，不推荐&lt;/span&gt;
f = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
f.write(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;小哥哥谈恋爱吗？我偷老公的钱养你&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(f.read())
f.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1815594/201912/1815594-20191201160920880-1439010333.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然模式可以组合，如r+b，a+b等。&lt;/p&gt;
&lt;h3&gt;四、常用操作&lt;/h3&gt;
&lt;p&gt;1、seek 指定光标&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
f = open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
a &lt;/span&gt;= f.read()        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 默认读全部&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
f.seek(&lt;/span&gt;6)           &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 按照字节指定光标开始读位置&lt;/span&gt;
c = f.read(6)       &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 指定读 N 个字符&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(c)
f.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1815594/201912/1815594-20191201161611169-538178416.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2、追加 小龙女，调节光标获取后面的9个字节&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 追加 小龙女，调节光标获取后面的9个字节&lt;/span&gt;
f = open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
f.write(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;小龙女&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
count &lt;/span&gt;= f.tell()     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看光标的位置&lt;/span&gt;
f.seek(count-9)      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 按照字节指定光标开始读位置&lt;/span&gt;
c =&lt;span&gt; f.read()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(c)
f.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1815594/201912/1815594-20191201161956440-2037186041.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3、readline、readlines的使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
f = open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
f.seek(0)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; c = f.readline()     # 一行一行读&lt;/span&gt;
d = f.readlines()   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 每行当成一个列表，添加到list中&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; print(c)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(d)
f.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1815594/201912/1815594-20191201162145755-642219193.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 4、推荐：with， 不用 close 关闭,也可读多个&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 推荐：with 不用 close 关闭,可读多个&lt;/span&gt;
a = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
b &lt;/span&gt;= open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
with a as f, b as f1:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(f.read())
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(f1.read())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1815594/201912/1815594-20191201162306807-2120920077.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;欢迎来QQ交流群：482713805&lt;/p&gt;
</description>
<pubDate>Sun, 08 Dec 2019 00:10:00 +0000</pubDate>
<dc:creator>广深-小龙</dc:creator>
<og:description>前言 python中对文件的读写也是非常方便的，本章节将讲解读、写、读写等常用操作。下面讲师必要的参数： 1、文件路径：必须得知道文件的路径，不然怎样进行读写？ 2、编码方式：utf-8，gbk，gb</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/gsxl/p/11966383.html</dc:identifier>
</item>
<item>
<title>VisualVM分析与HelloWorld、springBoot项目 - metabolism</title>
<link>http://www.cnblogs.com/metabolism/p/12004190.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/metabolism/p/12004190.html</guid>
<description>&lt;h2 id=&quot;visualvm分析与helloworldspringboot项目&quot;&gt;VisualVM分析与HelloWorld、springBoot项目&lt;/h2&gt;
&lt;p&gt;自从1995年第一个JDK版本JDKBeta发布，至今已经快25年，这些年来Java的框架日新月异，从最开始的Servlet阶段，到SSH，SSI，SSM，springboot等，还有一些其他方向的框架微服务SpringCloud、响应式编程Spring Reactor。零零总总 的框架，我们都需要去熟悉，那么怎么去快速熟悉呢，我觉得可以看源码，可以看博客，也可以根据内存分配去完善理解。&lt;/p&gt;
&lt;p&gt;那么问题来了，一个Java项目在咱们平时启动项目的时候，究竟发生了什么，创建几个简单的项目，用VisualVM来分析一下~&lt;/p&gt;
&lt;h4 id=&quot;main&quot;&gt;Main&lt;/h4&gt;
&lt;p&gt;简单的项目，应该没有比HelloWorld更简单的了吧，按照老规矩，咱们就从HelloWorld开始分析！那么简单的项目大家都能闭着眼睛敲出来，是不是没分析的必要啊，别着急，写好HelloWorld咱们开始分析：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;System.out.println(&quot;HelloWorld start&quot;);
// 这里让线程睡一会，方便分析
Thread.sleep(100000);
System.out.println(&quot;HelloWorld end&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行main方法，打开VisualVM，发现事情并不简单哦，这个简单的项目有十六个线程维护，其中守护线程有十五个。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1180221/201912/1180221-20191208015015572-36880394.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中几大线程的内存分配情况如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1180221/201912/1180221-20191208015017494-42197167.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这些线程都是干什么用的？写了那么多年HelloWorld没想到还有这种知识盲区：&lt;/p&gt;
&lt;ol readability=&quot;10.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;RMI TCP Connection(2)-10.128.227.33&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;10.128.227.33是我本地的ip地址。正确而愚蠢的原因是因为开了VisualVM(JMX客户端)，JVM需要把他的数据传递给这个客户端，就是使用的TCP传递，相同作用的线程还有&lt;strong&gt;JMX server connection timeout&lt;/strong&gt;：MAIN方法跑完了，JMX连接的心跳断开。&lt;strong&gt;RMI TCP Connection(idle)&lt;/strong&gt;：用来在RMI连接池中创建线程。&lt;strong&gt;*** Profiler Agent Communication Thread&lt;/strong&gt;：Profiler代理通信线程。&lt;strong&gt;RMI TCP Accept-0&lt;/strong&gt;：进行JMX进行JMX监测。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;Attach Listener&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Attach Listener线程是负责接收到外部的命令，对该命令进行执行并把结果返回给发送者。通常我们会用一些命令去要求jvm给我们一些反馈信息，如：java -version、jmap、jstack等等。如果该线程在jvm启动的时候没有初始化，那么，则会在用户第一次执行jvm命令时，得到启动。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;main&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;main线程，就是我们代码所写得代码对应线程&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;Monitor Ctr-Break&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这应该是 IDEA 通过反射的方式，伴随你的程序一起启动的对你程序的监控线程。这也是一个默认全局线程&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Signal Dispatcher&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面提到的Attach Listener线程职责是接收外部jvm命令，当命令接收成功后，就会交给signal dispather线程分发到各个不同的模块处理，并且返回处理结果。signal dispather线程是在第一次接收外部jvm命令时，才进行初始化工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;Finalizer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个线程是在main线程之后创建的，其优先级为10，主要用于在垃圾收集前，调用对象的finalize()方法；关于Finalizer线程的几点：&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;只有当开始一轮垃圾收集时，才会开始调用finalize()方法；因此并不是所有对象的finalize()方法都会被执行；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;该线程是守护线程，因此如果虚拟机中没有其他非守护线程的线程，不管该线程有没有执行完finalize()方法，JVM也会退出；&lt;/li&gt;
&lt;li&gt;JVM在垃圾收集时会将失去引用的对象包装成Finalizer对象（Reference的实现），并放入ReferenceQueue，由Finalizer线程来处理；最后将该Finalizer对象的引用置为null，由垃圾收集器来回收；&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;JVM为什么要单独用一个线程来执行finalize()方法呢？如果JVM的垃圾收集线程自己来做，很有可能由于在finalize()方法中误操作导致GC线程停止或不可控，这对GC线程来说是一种灾难，所以单独创建了一个守护线程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;Reference Handler&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;VM在创建main线程后就创建Reference Handler线程，其优先级最高，为10，它主要用于处理引用对象本身（软引用、弱引用、虚引用）的垃圾回收问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;经过上面的分析可以看出来main本身程序的线程有：main线程，Reference Handler线程，Finalizer线程，Attach Listener线程，Signal Dispatcher线程。&lt;/p&gt;
&lt;p&gt;java代码想要实现也很简单，如下即可：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 获取java线程管理器MXBean，dumpAllThreads参数：
//                                  lockedMonitors参数表示是否获取同步的monitor信息
//                                  lockedSynchronizers表示是否获取同步的synchronizer
ThreadInfo[] threadInfos = ManagementFactory.getThreadMXBean().dumpAllThreads(true, false);
for (ThreadInfo threadInfo : threadInfos) {
    System.out.println(threadInfo.getThreadId() + &quot; : &quot; + threadInfo.getThreadName());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到的打印结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1180221/201912/1180221-20191208015018091-1093569257.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也就是说，写了那么多年的HelloWorld居然有五个线程来支撑，而我却一直被蒙在鼓里？？谁能随时去关注项目有多少个线程啊，VIsualVM可以= =，虽然我觉得他一直起线程进行通信很蠢，但是项目结构大了就有必要了。&lt;/p&gt;
&lt;h4 id=&quot;spring-boot&quot;&gt;Spring-Boot&lt;/h4&gt;
&lt;p&gt;那么一个啥都没有的springBoot项目启动了之后，会有哪些线程呢？先看看他的pom文件：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.2.1.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;groupId&amp;gt;com.visual.vm.performance&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mock&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;mock&amp;lt;/name&amp;gt;
  
    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只引入了spring-boot-starter-web的依赖，其他的什么都没有，启动着试一下。共有27个线程，守护线程有23个。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1180221/201912/1180221-20191208015020883-330963243.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不同的颜色对应着不同的状态，详情看右下角。这些线程很多都是熟悉的，Main方法分析过的，通过VisualVM工具进行JMX监视(RMI TCP...)开了些线程；IDEA(Monitor Ctrl-Break)开了些线程；垃圾回收(Finalizer，Reference Handler)开了些线程。着重讲一下没见过的线程。&lt;/p&gt;
&lt;ol readability=&quot;14.992331288344&quot;&gt;&lt;li readability=&quot;10.949886104784&quot;&gt;
&lt;p&gt;&lt;strong&gt;DestroyJavaVM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有&lt;a href=&quot;https://en.wikipedia.org/wiki/Plain_Old_Java_Object&quot;&gt;POJO&lt;/a&gt;应用程序都通过调用该&lt;code&gt;main&lt;/code&gt;方法开始。正常情况下，main&lt;code&gt;完成后，将告知JVM的&lt;/code&gt;DestroyJavaVM`线程来关闭JVM，该线程等待所有非守护进程线程完成后再进行工作。这是为了确保创建的所有非守护程序线程都可以在JVM拆除之前运行完毕。&lt;/p&gt;
&lt;p&gt;但是，带有GUI的应用程序通常以多个线程运行。用于监视系统事件，例如键盘或鼠标事件。JVM仍然会创建&lt;code&gt;DestroyJavaVM&lt;/code&gt;线程，且需要等待所有创建的线程完成，然后再拆除VM，然而应用并不会停止，所以DestoryJavaVM线程就会一直处于等待，直到应用运行完成。&lt;/p&gt;
&lt;p&gt;任何创建线程并仅依赖其功能的应用程序都会有一个&lt;code&gt;DestroyJavaVM&lt;/code&gt;线程，等待应用程序完成并关闭JVM。由于它等待所有其他线程执行完毕(&lt;code&gt;join&lt;/code&gt;)，因此它不会消耗任何资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;19&quot;&gt;
&lt;p&gt;&lt;strong&gt;Http-nio-8080-Acceptor&lt;/strong&gt;、&lt;strong&gt;Http-nio-8080-ClientPoller&lt;/strong&gt;、&lt;strong&gt;Http-nio-8080-BlockPoller&lt;/strong&gt;、&lt;strong&gt;http-nio-8080-exec-1...10&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这些线程都有个特点，http-nio-8080开头。8080就是这个应用的端口，显然这是给容器使用的。项目引入的是spring-boot-starter-web依赖，也就是默认使用springBoot的内置tomcat容器启动，我们的maven下面也会有这样的几个包：&lt;code&gt;tomcat-embed-core&lt;/code&gt;、&lt;code&gt;tomcat-embed-el&lt;/code&gt;、&lt;code&gt;tomcat-embed-websocket&lt;/code&gt;，我们所看到的线程都是由这几个包产生的。那么这些线程是干什么用的？&lt;/p&gt;
&lt;p&gt;解决这个问题之前，先看一下tomcat的总体架构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1180221/201912/1180221-20191208015021636-105726488.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Tomcat由Connector和Container两个核心组件构成，Connector组件负责网络请求接入，目前支持BIO、NIO、APR三种模式，Tomcat5之后就支持了NIO，看我们的线程名也就是用的NIO；Container组件负责管理servlet容器。service服务将Container和Connector又包装了一层，使得外部可以直接获取。多个service服务运行在tomcat的Server服务器上，Server上有所有的service实例，并实现了LifeCycle接口来控制所有service的生命周期。&lt;/p&gt;
&lt;p&gt;而NIO对应线程主要是实现在Connector组件中，他负责接受浏览器发过来的tcp请求，创建一个Reuqest和Response对象用来请求和响应，然后产生一个线程，将Request和Response分发给他们对应处理的线程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1180221/201912/1180221-20191208015022530-997248731.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;终于看到了线程名中包含的Acceptor、Poller。他们都在Connector组件下的Http11NioProtocol下。着重介绍一下Http11NioProtocol下面的几个组件&lt;/p&gt;
&lt;p&gt;​ &lt;img src=&quot;https://img2018.cnblogs.com/blog/1180221/201912/1180221-20191208015023046-1153185834.jpg&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;20.5&quot;&gt;&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;Acceptor&lt;/strong&gt;：接受socket线程，接受的方法比较传统：serverSocket.accept()，得到SocketChannel对象并封装到NioChannel对象中。然后NioChannel对象封装在PollerEvent对象中，并放到events queue中。使用队列(生产者-消费者)和Poller组件交互，Acceptor是生产者，Poller是消费者，通过events queue通信。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package org.apache.tomcat.util.net;

public class Acceptor&amp;lt;U&amp;gt; implements Runnable {
      ...
    public void run() {
        byte errorDelay = 0;
        while(this.endpoint.isRunning()) {
                      ....
            try {
                this.endpoint.countUpOrAwaitConnection();
                if (!this.endpoint.isPaused()) {
                    Object socket = null;
                    try {
                      // 这句会调用NioEndPoint类，底层是serverSock.accept()
                        socket = this.endpoint.serverSocketAccept();
                    } catch (Exception var6) {
                        ...
                    }
                                      ...
                }
            } catch (Throwable var7) {
                ...
            }
        }

        this.state = Acceptor.AcceptorState.ENDED;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;strong&gt;Poller&lt;/strong&gt;：NIO选择器Selector用于检查一个或多个NIO Channel(通道)的状态是否可读、可写。如此可以实现单线程管理多个channels也就是可以管理多个网络线程。Poller是NIO实现的主要线程，首先从events queue队列中消费得到PollerEvent对象，再将此对象中的Channel以OP_READ事件注册到主Selector中，Selector执行select操作，遍历出可以读数据的socket，并从Worker线程池中拿到可用的Workrer线程，将可用的socket传递给Worker线程。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package org.apache.tomcat.util.net;
public class Poller implements Runnable {
     ...
     public void run() {
         while(true) {
             boolean hasEvents = false;
                label59: {
                    try {
                        if (!this.close) {
                            hasEvents = this.events();
                            if (this.wakeupCounter.getAndSet(-1L) &amp;gt; 0L) {
                                this.keyCount = this.selector.selectNow();
                            } else {
                              // selector.select方法，接受acceptor的socket
                                this.keyCount = this.selector.select(NioEndpoint.this.selectorTimeout);
                            }

                            this.wakeupCounter.set(0L);
                        }

                        if (!this.close) {
                            break label59;
                        }

                        this.events();
                        this.timeout(0, false);

                        try {
                            this.selector.close();
                        } catch (IOException var5) {
                            NioEndpoint.log.error(AbstractEndpoint.sm.getString(&quot;endpoint.nio.selectorCloseFail&quot;), var5);
                        }
                    } catch (Throwable var6) {
                        ExceptionUtils.handleThrowable(var6);
                        NioEndpoint.log.error(AbstractEndpoint.sm.getString(&quot;endpoint.nio.selectorLoopError&quot;), var6);
                        continue;
                    }

                    NioEndpoint.this.getStopLatch().countDown();
                    return;
                }

                if (this.keyCount == 0) {
                    hasEvents |= this.events();
                }

                Iterator iterator = this.keyCount &amp;gt; 0 ? this.selector.selectedKeys().iterator() : null;

                while(iterator != null &amp;amp;&amp;amp; iterator.hasNext()) {
                    SelectionKey sk = (SelectionKey)iterator.next();
                    NioEndpoint.NioSocketWrapper socketWrapper = (NioEndpoint.NioSocketWrapper)sk.attachment();
                    if (socketWrapper == null) {
                        iterator.remove();
                    } else {
                        iterator.remove();
                      // 然后调用processKey方法，将socket传给worker线程进行处理
                        this.processKey(sk, socketWrapper);
                    }
                }

                this.timeout(this.keyCount, hasEvents);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;strong&gt;Worker&lt;/strong&gt;：Worker线程从Poller传过来的socket后，将socket封装在SocketProcessor对象中，然后从Http11ConnectionHandler获取Http11NioProcessor对象，从Http11NioProcessor中调用CoyoteAdapter的逻辑(这就出了Http11NioProtocol组件，可以看上上图)。在Worker线程中，会完成从socket中读取http request，解析成HttpervletRequest对象，分派到相应的servlet并完成逻辑，然而将response通过socket发回client。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package org.apache.tomcat.util.net;
protected class SocketProcessor extends SocketProcessorBase&amp;lt;NioChannel&amp;gt; {
        public SocketProcessor(SocketWrapperBase&amp;lt;NioChannel&amp;gt; socketWrapper, SocketEvent event) {
            super(socketWrapper, event);
        }

        protected void doRun() {
          // 这一句从Poller拿到socket，然后进行tomcat主线程处理流程
            NioChannel socket = (NioChannel)this.socketWrapper.getSocket();
            SelectionKey key = socket.getIOChannel().keyFor(socket.getSocketWrapper().getPoller().getSelector());
            NioEndpoint.Poller poller = NioEndpoint.this.poller;
            if (poller == null) {
                this.socketWrapper.close();
            } else {
                try {
                    int handshake = -1;

                    try {
                        if (key != null) {
                            if (socket.isHandshakeComplete()) {
                                handshake = 0;
                            } else if (this.event != SocketEvent.STOP &amp;amp;&amp;amp; this.event != SocketEvent.DISCONNECT &amp;amp;&amp;amp; this.event != SocketEvent.ERROR) {
                                handshake = socket.handshake(key.isReadable(), key.isWritable());
                                this.event = SocketEvent.OPEN_READ;
                            } else {
                                handshake = -1;
                            }
                        }
                    } catch (IOException var13) {
                        handshake = -1;
                        if (NioEndpoint.log.isDebugEnabled()) {
                            NioEndpoint.log.debug(&quot;Error during SSL handshake&quot;, var13);
                        }
                    } catch (CancelledKeyException var14) {
                        handshake = -1;
                    }

                    if (handshake == 0) {
                        SocketState state = SocketState.OPEN;
                        if (this.event == null) {
                            state = NioEndpoint.this.getHandler().process(this.socketWrapper, SocketEvent.OPEN_READ);
                        } else {
                            state = NioEndpoint.this.getHandler().process(this.socketWrapper, this.event);
                        }

                        if (state == SocketState.CLOSED) {
                            poller.cancelledKey(key, this.socketWrapper);
                        }
                    } else if (handshake == -1) {
                        NioEndpoint.this.getHandler().process(this.socketWrapper, SocketEvent.CONNECT_FAIL);
                        poller.cancelledKey(key, this.socketWrapper);
                    } else if (handshake == 1) {
                        this.socketWrapper.registerReadInterest();
                    } else if (handshake == 4) {
                        this.socketWrapper.registerWriteInterest();
                    }
                } catch (CancelledKeyException var15) {
                    ...
                } finally {
                    ...

                }

            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;NioSelectorPool&lt;/strong&gt;：NioEndPoint对象维护了一个NioSelectorPool对象，这个NioSelectorPool中又维护了一个BlockPoller线程(基于Selector进行NIO逻辑)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;h2 id=&quot;平时看起来很熟悉的代码helloworld和springboot初始化的项目没想到背地里有那么多线程来支撑装了visualvm插件并不是让你蹭的就变强但是可以给你提供一些进步的思路引导你去思考去进步下面还会继续带着分析更复杂的项目不知道会不会有更多常见又未知的知识点等待我们去发现&quot;&gt;平时看起来很熟悉的代码，HelloWorld和SpringBoot初始化的项目。没想到背地里有那么多线程来支撑。装了VisualVM插件并不是让你蹭的就变强，但是可以给你提供一些进步的思路，引导你去思考去进步。下面还会继续带着分析更复杂的项目，不知道会不会有更多常见又未知的知识点等待我们去发现~&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.mossesblog.com&quot;&gt;欢迎访问我的个人博客&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 07 Dec 2019 17:50:00 +0000</pubDate>
<dc:creator>metabolism</dc:creator>
<og:description>VisualVM分析与HelloWorld、springBoot项目 自从1995年第一个JDK版本JDKBeta发布，至今已经快25年，这些年来Java的框架日新月异，从最开始的Servlet阶段，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/metabolism/p/12004190.html</dc:identifier>
</item>
<item>
<title>js对象可扩展性和属性的四个特性（上） - 买辣椒也用券</title>
<link>http://www.cnblogs.com/Juaoie/p/12004176.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Juaoie/p/12004176.html</guid>
<description>&lt;h2 id=&quot;js对象可扩展性和属性的四个特性上&quot;&gt;# js对象可扩展性和属性的四个特性（上）&lt;/h2&gt;
&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;ul readability=&quot;-0.98387096774194&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;再次花时间回顾一下基础，毕竟要想楼建的好，地基就要牢固，嘻嘻！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;在开始之前需要具备对prototype、__proto__、constructor有一定得了解，可以看看我之前写的一篇文章=&amp;gt;&lt;a href=&quot;https://www.cnblogs.com/Juaoie/p/9217466.html&quot;&gt;通道&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;之前的用户管理系统已经差不多了，顺便加了个socket聊天的，但是由于做java后台的哪个朋友节奏跟不上来，所以即时聊天的后台就是node+socket-io写的，由于用户列表也涉及比较多的用户隐私问题，所以我设置了页面权限和接口权限，然后下面开放的几个账号就只能看到几个页面而已，哈哈。=&amp;gt;&lt;a href=&quot;http://uaoie.top/cv&quot;&gt;通道&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;体验账号1：账号：“123456”。密码：“123456”&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;体验账号2：账号：“123123”。密码：“123123”&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;二目录&quot;&gt;二、目录&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;对象属性的四个特性&lt;/li&gt;
&lt;li&gt;对象的可扩展性&lt;/li&gt;
&lt;li&gt;删除属性&lt;/li&gt;
&lt;li&gt;检测属性&lt;/li&gt;
&lt;li&gt;枚举属性&lt;/li&gt;
&lt;li&gt;属性的getter和setter&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h2 id=&quot;三对象属性的四个特性&quot;&gt;三、对象属性的四个特性&lt;/h2&gt;
&lt;h3 id=&quot;定义&quot;&gt;1、定义&lt;/h3&gt;
&lt;h4 id=&quot;什么是数据属性&quot;&gt;1.1、什么是数据属性？&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;数据属性就是我们平常看到的对象普通属性。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数据属性的特性为以下四种：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;值（value）
可写性（writable）
可枚举性（enumerable）
可配置性（configurable）&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;什么是存储器属性&quot;&gt;1.2、什么是存储器属性？&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;存储器属性是由getter和setter定义的属性&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;存储器属性特性为以下四种：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;读取（get）
写入（set）
可枚举性（enumerable）
可配置性（configurable）&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;方法&quot;&gt;2、方法&lt;/h3&gt;
&lt;h4 id=&quot;获取某个对象特定属性的属性描述&quot;&gt;2.1、获取某个对象特定属性的属性描述&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;Object.getOwnPropertyDescriptor()&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;        const log = console.log;
        //返回数据数据的描述
        let aa = {
            x: 1
        };
        log(Object.getOwnPropertyDescriptor(aa, 'x'))
            //返回存储器属性的描述
        let bb = {
            get y() {
                return 2;
            },
        }
        log(Object.getOwnPropertyDescriptor(bb, 'y'))
            //对于一个不存在的属性或者继承属性返回undefined
        log(Object.getOwnPropertyDescriptor({}, 'x'))
        log(Object.getOwnPropertyDescriptor({}, 'toString'))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1370048/201912/1370048-20191208011941191-219980528.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;让新建属性具有某种特性&quot;&gt;2.2、让新建属性具有某种特性&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;Object.defineProperty()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;defineProperty不能修改继承属性&lt;/li&gt;
&lt;li&gt;defineProperty不必包含所有四个属性，对于已有的属性来说，未指定的特性不做修改，只对指定特性进行修改。&lt;/li&gt;
&lt;li&gt;对于新创建的属性来说默认是false或者undefined。&lt;/li&gt;
&lt;li&gt;当configurable设置为false，就不能再设置为true了，因为不可配置也不能配置自己&lt;/li&gt;
&lt;li&gt;当configurable设置为true，writable设置为false时，是可以通过配置特性更改value值的&lt;/li&gt;
&lt;li&gt;当configurable设置为false时，writable可以从true设置为false，当时不能从false设置为true&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;        const log = console.log;
        var aa = {
            y: 22
        };
        //添加一个x属性为不可写、不可枚举、可配置
        Object.defineProperty(aa, 'x', {
            value: 1,
            writable: false,
            enumerable: false,
            configurable: true
        })
        log(aa.x);
        aa.x = 2; //尝试修改这个属性会失败，但是不会报错，在严格模式下会报错
        log(aa.x)
        for (let i in aa) {
            //不可枚举数据属性x，但是y可以枚举
            console.log(i)
        }
        //因为这个x属性依然是可以配置的，所以可以通过配置的方式对值进行修改
        Object.defineProperty(aa, 'x', {
            value: 3,
        })
        log(aa.x);
        //将数据属性设置为存储器属性
        Object.defineProperty(aa, 'x', {
            get: function() {
                return 4;
            },
        })
        log(aa.x)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1370048/201912/1370048-20191208011954924-1868673107.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;同时修改多个属性的特性&quot;&gt;2.3、同时修改多个属性的特性&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;Object.defineProperties()&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;        const log = console.log;
        var aa = {};
        Object.defineProperties(aa, {
            x: {value: 1,writable: false,enumerable: true,configurable: false},
            y: {value: 2,writable: false,enumerable: true,configurable: false},
            z: {
                get:function(){
                    return 3
                },
                enumerable: false,
                configurable: false
            }
        })
        for(let i in aa){
            log(i,'---',aa[i])
        }
        log('z','---',aa.z)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1370048/201912/1370048-20191208012003070-1863794302.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;四对象的可扩展性&quot;&gt;四、对象的可扩展性&lt;/h2&gt;
&lt;h3 id=&quot;定义-1&quot;&gt;1、定义&lt;/h3&gt;
&lt;h4 id=&quot;什么是可扩展性&quot;&gt;1.1、什么是可扩展性？&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;对象可扩展性是指是否可以给该对象添加新的属性&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;方法-1&quot;&gt;2、方法&lt;/h3&gt;
&lt;h4 id=&quot;将对象设置为不可扩展&quot;&gt;2.1、将对象设置为不可扩展&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;Object.preventExtensions()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对象一旦设置不为不可扩展就不能转换为可扩展了&lt;/li&gt;
&lt;li&gt;Object.preventExtensions只会影响对象本身的可扩展性，所以依然还是可以给对象原型添加属性。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;        const log = console.log;
        var aa = {};
        Object.preventExtensions(aa);
        aa.x = 1;
        log(aa.x)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1370048/201912/1370048-20191208012012957-782477321.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;检测对象是否是可扩展的&quot;&gt;2.2、检测对象是否是可扩展的&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;Object.isExtensible()&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;        //在《javascript权威指南》第六版中6.8.3节介绍可扩展性的时候，将isExtensible写为esExtensible了。
        const log = console.log;
        var aa = {};
        var bb = {};
        Object.preventExtensions(aa);
        log(Object.isExtensible(aa))
        log(Object.isExtensible(bb))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1370048/201912/1370048-20191208012024554-68324413.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;将对象封闭sealed&quot;&gt;2.3、将对象封闭（sealed）&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;Object.seal()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Object.seal不仅可以设置对象的可扩展性，还可以设置对象的所有自有属性的可配置性&lt;/li&gt;
&lt;li&gt;将对象设置为不可扩展并且不可配置，也就是说不能给这个对象添加新属性，而且已有的属性不能删除或者配置。&lt;/li&gt;
&lt;li&gt;不过这些属性可写特性依然是可以配置的&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;        const log = console.log;
        var aa = {
            y: 2
        };
        Object.seal(aa);
        aa.x = 1;
        log(aa.x);
        log(Object.getOwnPropertyDescriptor(aa, 'y'))
        Object.defineProperty(aa, 'y', {
            writable: false,
        })
        log(Object.getOwnPropertyDescriptor(aa, 'y'))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1370048/201912/1370048-20191208012033867-18597559.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;检测对象是否被封闭&quot;&gt;2.4、检测对象是否被封闭&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;Object.isSealed()&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;        const log = console.log;
        var aa = {};
        var bb = {};
        Object.seal(aa);
        log(Object.isSealed(aa));
        log(Object.isSealed(bb))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1370048/201912/1370048-20191208012042331-275526158.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;将对象冻结freeze&quot;&gt;2.5、将对象冻结（freeze）&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;Object.freeze()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;freeze不仅仅可以将对象设置为不可扩展和所有属性为不可配置，并且会将所有对象属性设置为只读。&lt;/li&gt;
&lt;li&gt;如果存取器属性具有setter方法，则不会受到影响，仍然可以通过此方法给属性赋值。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;        const log = console.log;
        var aa = {
            x: 1
        };
        Object.freeze(aa);
        log(Object.getOwnPropertyDescriptor(aa, 'x'))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1370048/201912/1370048-20191208012056974-2058773083.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;检测对象是否配冻结&quot;&gt;2.6、检测对象是否配冻结&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;Object.isFreeze()&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;        const log = console.log;
        var aa = {};
        var bb = {};
        Object.freeze(aa);
        log(Object.isFrozen(aa));
        log(Object.isFrozen(bb));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1370048/201912/1370048-20191208012109315-639405013.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 07 Dec 2019 17:21:00 +0000</pubDate>
<dc:creator>买辣椒也用券</dc:creator>
<og:description>js对象可扩展性和属性的四个特性（上） 一、前言 再次花时间回顾一下基础，毕竟要想楼建的好，地基就要牢固，嘻嘻！ 在开始之前需要具备对prototype、\_\_proto\_\_、construct</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Juaoie/p/12004176.html</dc:identifier>
</item>
<item>
<title>目标分析与制定算法 - bee0060</title>
<link>http://www.cnblogs.com/bee0060/p/12004165.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bee0060/p/12004165.html</guid>
<description>&lt;p&gt;原创内容，转载请注明出处： &lt;a href=&quot;https://www.cnblogs.com/bee0060/p/12004165.html&quot;&gt;https://www.cnblogs.com/bee0060/p/12004165.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;目录：&lt;/strong&gt;&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;前言&lt;/li&gt;
&lt;li&gt;S.M.A.R.T&lt;/li&gt;
&lt;li&gt;过程目标和结果目标&lt;/li&gt;
&lt;li&gt;目标制定算法&lt;/li&gt;
&lt;li&gt;小结&lt;/li&gt;
&lt;li&gt;参考资料&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;制定目标并努力达到，是一个主要的成长手段。 但是工作生活中，目标以及如何达到目标有时并不那么清晰，本文主要列出最近关于这些问题的思考和收获。本文中提到的算法，可以理解成一种为了实现目标，进行分析和制定具体可执行步骤的一种方法。本文将用编程的思维和表达方式来阐述这个方法。下面的代码都是用JavaScript语法。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;S.M.A.R.T&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;这里说的SMART是说咱们只要足够聪明，聪明了自然就知道吗？ 当然不是。 SMART是一个使用广泛的方法，或也可以叫原则。 &lt;/p&gt;
&lt;p&gt;SMART可用于目标制定，有些公司将SMART用于绩效考核指标的制定。&lt;/p&gt;
&lt;p&gt;很多朋友可能已经知道，SMART是五个单词的首字母拼起来的，即：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;S=Specific （具体的）&lt;/li&gt;
&lt;li&gt;M=Measurable （可以衡量的）&lt;/li&gt;
&lt;li&gt;A=Attainable （可以达到的）&lt;/li&gt;
&lt;li&gt;R=Relevant （相关性，一般指与自己的工作内容相关）&lt;/li&gt;
&lt;li&gt;T=Time-bound （有时间限制的）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为什么突然说SMART？ 要成长，必须要用行动，而行动不能盲目，所以我们的行动应该是向着我们目标前进的。而只有可执行的目标，我们才知道该怎么前进。所以我们要用到SMART，用SMART来制定可执行的目标。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;过程目标和结果目标&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;最近看了一本书（《哈佛分享课》）， 才知道原来目标之间也有区别。他们就是过程目标和结果目标。那么它们分别是什么意思？ 虽然我有自己的理解，但还是搜了下百度：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
过程目标： 为了达成结果目标的阶段性目标，称为过程目标。
结果目标： 没有百度到。 -。-
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;百度再次让我失望，好吧，还是用我自己的理解来解释吧。&lt;/p&gt;
&lt;p&gt;结果目标： 我认为是某一个现实结果的表述，如我要上大学，我要当科学家，我要发达，我要当前端架构师。一个&lt;strong&gt;&lt;em&gt;结果目标&lt;/em&gt;&lt;/strong&gt;可以拆分为若干个&lt;strong&gt;&lt;em&gt;过程目标&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;过程目标： 补充百度的解释，除了拆分自&lt;em&gt;&lt;strong&gt;结果目标&lt;/strong&gt;&lt;/em&gt;， 我们一般还期望&lt;em&gt;&lt;strong&gt;过程目标&lt;/strong&gt;&lt;/em&gt;具有可量化甚至可执行的特点，且&lt;em&gt;&lt;strong&gt;过程目标&lt;/strong&gt;&lt;/em&gt;也能拆分为更多更小的&lt;em&gt;&lt;strong&gt;过程目标&lt;/strong&gt;&lt;/em&gt;。拆分目标时我们会期望&lt;em&gt;&lt;strong&gt;过程目标&lt;/strong&gt;&lt;/em&gt;全部或部分实现后，就能达到&lt;em&gt;&lt;strong&gt;结果目标&lt;/strong&gt;&lt;/em&gt;。但请谨记，这个仅仅是目标拆分人的期望，未必与事实相符。但随着我们知识、能力的增长，这种期望实现的概率会逐步提高。以下是几个拆分例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
结果目标： 我要上大学
过程目标： 
1. 我每天要花3小时课余时间学习
2. 我周末要上2个培训班
3. 每个月额外完成一本习题册
等等
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
结果目标：我要发达（发财）
过程目标：
1. 我要月入超过5W
2. 我每月要存4W5来投资
3. N年后买房投资
等等
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就像前面说的， 拆分出来的&lt;em&gt;&lt;strong&gt;过程目标&lt;/strong&gt;&lt;/em&gt;未必能带帮你实现结果目标，而&lt;em&gt;&lt;strong&gt;过程目标&lt;/strong&gt;&lt;/em&gt;本身可能也依然是个过大或不可执行的目标，接下来就轮到我想说的目标拆分与制定算法了。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;目标制定算法&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;好了，这一节就可以用程序员喜欢的表达方式了。首先，我们的最初目标是成长，在我们有了目标（&lt;em&gt;&lt;strong&gt;结果目标&lt;/strong&gt;&lt;/em&gt;）后，我们需要将其变成可执行的步骤（&lt;em&gt;&lt;strong&gt;过程目标&lt;/strong&gt;&lt;/em&gt;）。 怎样的步骤算是可执行的呢？&lt;/p&gt;
&lt;p&gt;我们这里需要用到SMART方法。 在本文中，我们只认为符合SMART原则的过程目标，才是可执行的。&lt;/p&gt;
&lt;p&gt;下面，我们会用到判断和递归的方法，来实现我们的算法。&lt;/p&gt;
&lt;p&gt;首先我们列下这个算法的输入和输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
输入： 结果目标
输出： 一个或多个可执行的过程目标
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而因为我们仅将符合SMART的过程目标认为是可执行的，所以我们需要定义一个函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; isSmart(target) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; do your checking  &lt;br/&gt;// return true or false&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上文中我们已经列过SMART的定义， 要判断一个过程目标是否可执行，应该并不困难。&lt;/p&gt;
&lt;p&gt;然后，我们还需要定义一个拆分目标的函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; breakDownTarget(target) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将目标拆分成若干个子目标，我们需要用尽我们的智慧和经验，来让子目标尽量覆盖到父目标的方方面面，因为我们的期望是子目标都完成后，就代表父目标的完成&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回子目标数组&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个函数的具体执行、正确性和可靠性只能依靠咱们自己的经验和知识。&lt;/p&gt;
&lt;p&gt;上面说过，这里会用到判断和递归，因为一个大的结果目标未必一下就能拆分成符合SMART的过程目标，下面让我们来完善一下这个算法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
   @parameter target: 可以是结果目标或过程目标
   @return 最终的可执行过程目标集合
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; definePlan(target) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isSmart(ftarget)) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; target
  }

  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; subTargets =&lt;span&gt; breakDownTarget(target)
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; subTargets.map(definePlan);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好了， 当我们有一个结果目标，将这个结果目标传入这个算法，就应该能得到一系列的可执行的过程目标了。当然了，执行这个算法的不是电脑、CPU、内存， 而是我们的大脑，可能借助纸笔和朋友的辅助。 下面列举2个使用这个算法的小例子：&lt;/p&gt;
&lt;p&gt;1. 结果目标： 我要减肥&lt;/p&gt;
&lt;p&gt;这是个常见的目标。 但是这个目标不符合SMART，所以我们需要拆分。 而在拆分前，我们可能会想要量化目标。 例如，一个月，减5斤。&lt;/p&gt;
&lt;p&gt;那么怎样才能一个月减5斤？ 如果我们只是希望和喊口号，固然是得不到我们想要的结果的。 为了提高我们的结果目标实现概率，我们可能需要学习一些热量、运动、肥胖原因等知识。所以我们第一版的过程目标出来了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[
  &lt;/span&gt;&quot;花一周时间上网查找肥胖原因、减肥方法等知识&quot;&lt;span&gt;，
  &lt;/span&gt;&quot;每天少吃一点&quot;， &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 但因为缺乏知识，我们不知道少吃多少，也不确定这么做是否能达到减肥目的，不符合SMART&lt;/span&gt;
  &quot;每天做运动&quot;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 原因同上， 我们不知道当前身体状态适合做什么运动，应该做多大的量，不符合SMART&lt;/span&gt;
]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在进行一定学习后，我们可能知道了一些饮食的方法和适合自己的运动，然后可以将上述目标拆分为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[
    &lt;/span&gt;&quot;学习减肥知识&quot;&lt;span&gt;,
    [&lt;/span&gt;&quot;一天三餐&quot;&lt;span&gt;， “晚餐不吃米饭、面等碳水化合物”， “中午多吃牛肉、鸡蛋等补充优质蛋白”， 等等]，
    [&lt;/span&gt;&quot;每天走1万步左右&quot;， &quot;每周至少跑3次步，每次4-5公里&quot;&lt;span&gt;]
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;经过一些学习， 这个过程目标列表看起来靠谱多了。不过， 体重是个很复杂的东西。这么做下来到底会减5斤还是10斤还是1斤，未必能保证。虽然最后体重应该会减少，身体会更健康。但若以结果目标是否实现为判断标准的话。 这些可执行的过程目标未必能实现结果目标。如果无法实现，那么可以认为这个计划是失败了的。就和上文提到的一样，结果目标是否成功，受我们的知识、能力、社会环境等诸多因素影响，真的是谋事在人，成事在天。但是，我们还有另一个解决方案，也就是适当的调整我们的&lt;em&gt;&lt;strong&gt;结果目标&lt;/strong&gt;&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;例如， 把”一个月减肥5斤“， 改成： ”逐步解决肥胖问题，并让自己越来越健康“， 或者改回”我要减肥”这个目标，那上述的&lt;em&gt;&lt;strong&gt;过程目标&lt;/strong&gt;&lt;/em&gt;应该是可以很好实现&lt;em&gt;&lt;strong&gt;结果目标&lt;/strong&gt;&lt;/em&gt;的。&lt;/p&gt;

&lt;p&gt;2. 结果目标： 我要成为前端架构师&lt;/p&gt;
&lt;p&gt;我第一反应能想到的是以下这些过程目标：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[
  &lt;/span&gt;&quot;上网了解前端架构师、定义、职能、所需技能等&quot;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 你可能已经了解一些&lt;/span&gt;
  &quot;精通JS&quot;,              &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Not smart&lt;/span&gt;
  &quot;了解各端各浏览器差异&quot;,   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Not smart&lt;/span&gt;
  &quot;深入了解几个主流框架&quot;,   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Not smart&lt;/span&gt;
  &quot;项目初始化架构&quot;,        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Not smart&lt;/span&gt;
  &quot;制定工作流程能力&quot;,     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Not smart&lt;/span&gt;
  &quot;团队建设&quot;，            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Not smart&lt;/span&gt;
&lt;span&gt;  等等
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体内容大家不必较真，只是举个例子。 好了，一堆not smart。那么咱么继续拆分, 因为是个递归的过程，这里我就每个都拆了，拆一两个举个例子。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
“精通JS” =&amp;gt;&lt;span&gt;
[
  &lt;/span&gt;&quot;阅读某某（一或多本）JS权威书籍&quot;&lt;span&gt;，
  &lt;/span&gt;&quot;订阅某某（一或多个）前端大牛的博客&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;每天花2小时阅读权威文档，如MDN，或做JS相关练习&quot;&lt;span&gt;，
],

...

“深入了解主流框架”  &lt;/span&gt;=&amp;gt;&lt;span&gt;
[
  &lt;/span&gt;&quot;阅读react源码和文档&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;订阅react社区较权威的开发者的博客&quot;&lt;span&gt;，
  &lt;/span&gt;&quot;加入使用react的开发大中型项目&quot;&lt;span&gt;
],

...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里需要提一下的是， 结果目标和时间长短、规模大小无关，短期、中期、长期目标均可作为结果目标。&lt;/p&gt;
&lt;p&gt;而很明显的，越大的结果目标，需要拆分的过程目标层级越多，实现所需时间越长， 拆分不合理和失败的可能性越大。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;我把这个方法叫做目标分析与制定算法，因为涉及一些分析和拆分目标的建议和例子，而将目标变为符合SMART的可执行步骤也相当于制定可执行的计划了。&lt;/p&gt;
&lt;p&gt;本文将这个方法作一个记录，以便自己可以长期使用。&lt;/p&gt;
&lt;p&gt;很多人都有一些目标、憧憬、渴望，但是对如何实现目标常有困惑，特别是一些长期的，复杂的，不具体或不可量化的目标。 &lt;/p&gt;
&lt;p&gt;经过本文，希望可以在大家面对这种目标时，帮助大家经过一步步的分析和拆分，制定出一个感觉比较靠谱的可执行计划。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;《哈佛 分享课》&lt;/li&gt;
&lt;li&gt;SMART （百度百科） &lt;a href=&quot;https://baike.baidu.com/item/SMART%E5%8E%9F%E5%88%99/8575850?fr=aladdin&quot;&gt;https://baike.baidu.com/item/SMART%E5%8E%9F%E5%88%99/8575850?fr=aladdin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;过程目标（百度百科） &lt;a href=&quot;https://baike.baidu.com/item/%E8%BF%87%E7%A8%8B%E7%9B%AE%E6%A0%87/19677749?fr=aladdin&quot;&gt;https://baike.baidu.com/item/%E8%BF%87%E7%A8%8B%E7%9B%AE%E6%A0%87/19677749?fr=aladdin&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;谢谢观看。&lt;/p&gt;
&lt;p&gt;2019.12.08&lt;/p&gt;
</description>
<pubDate>Sat, 07 Dec 2019 17:03:00 +0000</pubDate>
<dc:creator>bee0060</dc:creator>
<og:description>原创内容，转载请注明出处：&amp;#160;https://www.cnblogs.com/bee0060/p/12004165.html 目录： 前言 制定目标并努力达到，是一个主要的成长手段。 但是工作</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bee0060/p/12004165.html</dc:identifier>
</item>
<item>
<title>动态规划--0,1背包问题（再也不怕类似背包问题了） - 西西嘛呦</title>
<link>http://www.cnblogs.com/xiximayou/p/12004082.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiximayou/p/12004082.html</guid>
<description>&lt;p&gt;&lt;span&gt;这种类型问题&lt;strong&gt;&lt;span&gt;三大要素：总重量、每件物品重量、每件物品价值，&lt;/span&gt;&lt;/strong&gt;问最终能够塞进背包中的价值最大是多少？应该怎么选择物品？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然也不一定是这些，例如上节所说的矿工挖矿：总人数、挖每座矿的人数、每座矿的金子数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是说，只要出现了这三大要素，都可以视为0，1背包问题（物品不可拆分）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;动态规划三要素：边界、最优子结构、状态转移方程。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们一步步进行解析：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;初始化：物品总重量：&lt;strong&gt;c=8&lt;/strong&gt;，物品类别：&lt;strong&gt;n=['a','b','c','d']&lt;/strong&gt;，物品重量：&lt;strong&gt;w=[2,4,5,3]&lt;/strong&gt;，物品价值：&lt;strong&gt;v=[5,4,6,2]&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设我们目前只有一个物品a，&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;背包的总重量为0，那么我们获得总价值为0&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;背包的总重量为1，那么我们获得总价值为1&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;背包的总重量为2，此时，正好可以放下物品a，因为它的重量正好是2，那么我们获得总价值为5&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在这之后，我们可以获得的总价值均为5，因为总重量&amp;gt;2，且只有a一个物品&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;假设我们现在多了一个物品b,&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;背包总重量0，那么我们获得总价值为0&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;背包总重量1，那么我们获得总价值为0&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;背包总重量2，此时可以放进a，那么我们获得总价值为5&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;背包总重量3，仍只能放进a，那么我们获得总价值为5&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;背包总重量4，此时我们既可以放进a，也可以放进b，选价值最大的，也就是放进a，那么我们获得总价值为5&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;背包总重量5，那么我们获得总价值为5&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;背包总重量6，此时就可以放进a，b了，那么我们获得总价值为5+4=9&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在这之后，我们可以获得的总价值均为9&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;假设我们现在多了一个物品c&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;背包总重量0，那么我们获得总价值为0&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;背包总重量1，那么我们获得总价值为0&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;背包总重量2，此时可以放进a，那么我们获得总价值为5&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;背包总重量3，仍只能放进a，那么我们获得总价值为5&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;背包总重量4，此时我们既可以放进a，也可以放进b，选价值最大的，也就是放进a，那么我们获得总价值为5&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;背包总重量5，此时我们可以放a，也可以放c，选最大的，也就是放进c，此时我们获得总价值为6&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;背包总重量6，此时可以放进a，b了，也可以只放进c，选最大的，那么我们获得总价值为5+4=9&amp;gt;6&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在这之后，我们可以获得的总价值均为9&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503039/201912/1503039-20191208000627791-1246423642.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;依此类推下去，看起来挺复杂，其实是有套路的，那我们应该如何实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对付这种问题，一般就直接初始化一个数组：dp[len(n)+1][c+1]，即5行9列的二维数组（行代表物品种类，列代表总重量，多加一列和一行是为了更容易理解）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来，我们就从代码中一步步剖析：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
n=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
c&lt;/span&gt;=8&lt;span&gt;
w&lt;/span&gt;=[2,4,5,3&lt;span&gt;]
v&lt;/span&gt;=[5,4,6,2&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; bag(c,w,v):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;初始化数组，dp[i][j]表示总重量为j，物品种类为i，可以获得的最大价值&lt;/span&gt;
    dp = [[0 &lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt; range(c+1)] &lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt; range(len(w)+1&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义边界，也就是当我们只有物品a，总重量依次由0-8&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;也就是第一步我们所解释的&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1,c+1&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; i&amp;gt;=&lt;span&gt;w[0]:
            dp[&lt;/span&gt;1][i] =&lt;span&gt; v[0]
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;遍历从第二行第一列开始&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(2,len(w)+1&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(1,c+1&lt;span&gt;):
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果对于第i个物品，当前总重量放不下它，那么获得的最大值就是放下之前的i-1个&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; j&amp;lt;w[i-1&lt;span&gt;]:
                dp[i][j] &lt;/span&gt;= dp[i-1&lt;span&gt;][j]
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果放得下，那么获得的最大值就是max(放下之前的i-1个，第i个物品的价值+&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; （总重量-第i个物品的重量)在前i-1个物品的值)&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt;注意下标，第i个物品的重量是w[i-1]，价值是v[i-1]&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                dp[i][j]&lt;/span&gt;=max(dp[i-1][j],dp[i-1][j-w[i-1]]+v[i-1&lt;span&gt;])
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dp
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; show(c,w,dp):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;最大价值为：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,dp[len(w)][c])
    x &lt;/span&gt;= [False &lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt; range(len(w)+1&lt;span&gt;)]
    j &lt;/span&gt;= c &lt;span&gt;#&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;
    i = len(w) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; i&amp;gt;=&lt;span&gt;0:
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; dp[i][j]&amp;gt;dp[i-1&lt;span&gt;][j]:
            x[i]&lt;/span&gt;=&lt;span&gt;True
            j&lt;/span&gt;=j-w[i-1&lt;span&gt;]
        i&lt;/span&gt;-=1
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;选择的物品是：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(len(w)+1&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; x[i]:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;第&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,i,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,end=&lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
dp &lt;/span&gt;=&lt;span&gt; bag(c,w,v)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(len(w)+1&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(dp[i])
show(c,w,dp)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503039/201912/1503039-20191208000411628-1167640154.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;最后在输出第几个物品的时候采用由下往上，如果下面的值大于上面的值，说明这个物品被放置了，然后总重量减去该物品重量，继续判断，如蓝色所标记的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结：背包问题三步走：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（1）初始化dp数组，行为物品个数+1，列为总重量+1&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（2）初始化边界，只放一个物品，在不同总重量下得到的价值&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（3）遍历数组，依赖dp[i-1]更新dp[i]&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 07 Dec 2019 16:11:00 +0000</pubDate>
<dc:creator>西西嘛呦</dc:creator>
<og:description>这种类型问题三大要素：总重量、每件物品重量、每件物品价值，问最终能够塞进背包中的价值最大是多少？应该怎么选择物品？ 当然也不一定是这些，例如上节所说的矿工挖矿：总人数、挖每座矿的人数、每座矿的金子数。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiximayou/p/12004082.html</dc:identifier>
</item>
<item>
<title>PAT甲级满分攻略|记一次考试经历 - fishers</title>
<link>http://www.cnblogs.com/fisherss/p/12004044.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fisherss/p/12004044.html</guid>
<description>&lt;p&gt;今天是“大雪”，很冷。&lt;br/&gt;来到隔壁的学校考试，记得上一次来河中医是两年前大一刚开学吧，那天晚上印象比较深刻，6个室友骑车到处闲逛。当时还不会Hello world。&lt;/p&gt;
&lt;p&gt;很巧，遇到了一年前在网络上一起准备蓝桥杯的小伙伴，考前，相约明年再来考一次。。然而，下次可能不会再来了。&lt;/p&gt;&lt;p&gt;A题：字符串处理&lt;br/&gt;B题：模拟链表&lt;br/&gt;C题：图论，简单的邻接矩阵判断顶点相连&lt;br/&gt;D题：小根堆，给出中序序列建树，输出层序遍历的序列。&lt;/p&gt;
&lt;p&gt;除了第一题以外，其他三题都和往年的题型一样的。&lt;br/&gt;第一题字符串看起来就比较难处理，所以先做了后三道。&lt;/p&gt;
&lt;p&gt;怎么说，现场做题还是有一定压力，需要保持一个良好的心态。第一题字符串花了一个多小时，提交了十几次吧，几乎要放弃的时候奇迹出现了。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1454456/201912/1454456-20191207233130123-1217376155.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;考了满分可以提前出考场，还有半小时可以闲逛。拍下了阳光下，河中医的湖，两年前来这里的时候是晚上什么也看不见。。&lt;br/&gt;好像每个学校的湖里都藏着几只不怕冷的鸭子。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1454456/201912/1454456-20191207232255777-605962706.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;晚上起雾了，10米以外都看不清；不过，慢慢走就好了，我们都在路上。好吧是霾，那等天晴肯定就没了。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1454456/201912/1454456-20191207233241302-622027371.png&quot;/&gt;&lt;/p&gt;&lt;p&gt;加油。&lt;/p&gt;

&lt;p&gt;1.浙大举办的一场考试，可以抵浙大复试的机试。考浙大就不想了。。&lt;br/&gt;2.BAT和其它部分互联网企业校招免笔试，节省校招时间。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1454456/201912/1454456-20191207233713100-786560509.png&quot;/&gt;&lt;/p&gt;&lt;p&gt;计划是明年在考研的时候，先用PAT证书拿个校招offer保底，这样考研时的心态比较稳一点。&lt;br/&gt;所以准备了PAT考试。&lt;br/&gt;听说考到企业要求的分数能收到企业面试电话，然而好像还没有。。应该要校招的时候，拿着成绩单自己主动申请免笔试吧。&lt;/p&gt;

&lt;h2 id=&quot;先刷专题&quot;&gt;先刷专题&lt;/h2&gt;
&lt;p&gt;第一题一般是：素数筛、模拟题、字符串题。&lt;br/&gt;第二题一般是：结构体排序、模拟链表、哈希表和其它简单数据结构&lt;br/&gt;第三题一般是：简单图论&lt;br/&gt;第四题一般是：二叉树、堆、图论，离不开这几个考点。&lt;br/&gt;柳神的博客有专题目录：&lt;a href=&quot;https://www.liuchuo.net/archives/2502#&quot; class=&quot;uri&quot;&gt;https://www.liuchuo.net/archives/2502#&lt;/a&gt;&lt;br/&gt;我自己也写过一些专题小结可以参考：&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/fisherss/p/11516227.html&quot;&gt;PAT甲级专题|模拟链表&lt;br/&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/fisherss/p/11470942.html&quot;&gt;PAT甲级专题|树的遍历&lt;br/&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/fisherss/p/11577726.html&quot;&gt;PAT甲级专题|最短路&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/fisherss/p/11516227.html&quot;&gt;PTA教育超市可以进行模拟考试，可以给自己规定一定的时间去做一次真题，及时反馈。&lt;br/&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/fisherss/p/11615671.html&quot;&gt;PAT（甲级）2019年秋季考试&lt;br/&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/fisherss/p/11579935.html&quot;&gt;PAT（甲级）2019年春季考试&lt;br/&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/fisherss/p/11631271.html&quot;&gt;PAT（甲级）2018年冬季考试&lt;br/&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/fisherss/p/11988440.html&quot;&gt;PAT（甲级）2017年秋季考试&lt;br/&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/fisherss/p/11994468.html&quot;&gt;PAT（甲级）2017年春季考试&lt;br/&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/fisherss/p/11651317.html&quot;&gt;不知道是哪一年了，PTA 1140 1141 1142 1143&lt;br/&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/fisherss/p/11954605.html&quot;&gt;不知道是哪一年了，PTA 1139 1138 1137 1136&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 07 Dec 2019 15:55:00 +0000</pubDate>
<dc:creator>fishers</dc:creator>
<og:description>一次考试经历 今天是“大雪”，很冷。 来到隔壁的学校考试，记得上一次来河中医是两年前大一刚开学吧，那天晚上印象比较深刻，6个室友骑车到处闲逛。当时还不会Hello world。 很巧，遇到了一年前在网</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fisherss/p/12004044.html</dc:identifier>
</item>
<item>
<title>全链路压测资料汇总——业内大厂解决方案 - 老_张</title>
<link>http://www.cnblogs.com/imyalost/p/12004026.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imyalost/p/12004026.html</guid>
<description>&lt;p&gt;&lt;span&gt;最近忙于公司的全链路压测平台调研和技术规划文档输出工作，参考了全网能搜到的业内大厂的全链路压测方案，这里做个汇总，以及将个人认为可以落地的方案做一个关键点整理。&lt;/span&gt;&lt;/p&gt;

&lt;p id=&quot;Rsw9P&quot;&gt;&lt;strong&gt;&lt;span&gt;技术链接&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/g6u8w7p06dco99fq3/article/details/79119269&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;滴滴全链路压测解决之道&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://my.oschina.net/cctester/blog/994727&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;阿里巴巴的全链路压测&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/eAbFi3hL4DpZLNM4OMjv2g&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;阿里怎么做双11全链路压测？&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/uv2AfwnKzkSAMDjj9fs-UA&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;美团全链路压测自动化实践&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651748852&amp;amp;idx=1&amp;amp;sn=71d24d5f4fe1575589d56d2bed040d7a&amp;amp;chksm=bd12a0b98a6529aff13987a8189205b21c832398add2b8443e953ba88be88a856c2ced2e4607&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;全链路压测平台在美团中的实践&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30306892&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;饿了么全链路压测的探索与实践&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.testwo.com/article/1104&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;饿了么全链路压测平台的实现与原理&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/0a-Sd_fCkE2mDFzNpKxf7A&quot; target=&quot;_blank&quot;&gt;有赞全链路压测方案设计与实施详解&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://sdk.cn/news/6349&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;京东全链路压测系统(ForceBot)架构解密&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.toutiao.com/i6660639134580736526/?tt_from=weixin_moments&amp;amp;utm_campaign=client_share&amp;amp;wxshare_count=3&amp;amp;from=timeline&amp;amp;timestamp=1550847944&amp;amp;app=news_article&amp;amp;utm_source=weixin_moments&amp;amp;isappinstalled=0&amp;amp;iid=59695444050&amp;amp;utm_medium=toutiao_ios&amp;amp;group_id=6660639134580736526&amp;amp;pbid=6660859823690794499&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;罗辑思维在全链路压测方面的实践和工作笔记&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;大厂方案point整理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p id=&quot;2iQ3y&quot;&gt;&lt;strong&gt;&lt;span&gt;1、逻辑思维&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;定位：保障业务稳定性的核心基础设施；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;重要性：业务知名度高&amp;amp;技术团队承受压力大；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;核心目标：服务可用性、稳定性、扩展性；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;h1rlF&quot;&gt;&lt;strong&gt;&lt;span&gt;2、阿里巴巴&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;流程管理：有效的方案+充足的准备+靠谱稳定的平台；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;流量识别：压测流量标记透传落影子库，同一API多次压测，防止被拦截，同一IP，白名单机制；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;系统改造：①.业务改造：流量识别、单一性问题、限流拦截、报表剔除、动态校验；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;数据准备：活动方案确定→业务模型评审→技术架构&amp;amp;压测范围&amp;amp;数据量级&amp;amp;数据形式；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;①.业务模型数据：API&amp;amp;流量量级&amp;amp;配比&amp;amp;转化漏斗→业务抽象模型（漏斗比例不变）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;②.基础数据构造：数据量级&amp;amp;真实性（买家&amp;amp;卖家、商户&amp;amp;商品、价格）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;系统预热：缓存准备、系统load准备；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;登录准备：模拟登录场景长链接（用户逐步登录），保护user服务；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;压测方式：0点脉冲、系统摸高、限流降级、破坏性验证（容灾恢复演练）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;3CpU6&quot;&gt;&lt;strong&gt;&lt;span&gt;3、京东&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;场景：买家、卖家；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;数据：历史双十一峰值流量作为基础流量，动态增加并发压力；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;流量：日常流量、大促流量（主库写压力大）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;压测引擎：jmeter/Ngrinder；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;测试脚本/数据：git/本地？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;启动模式：梯度递增、脉冲、稳定水位验证；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;执行方式：立刻执行、定时执行；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;测试场景：压力源、虚拟用户数、测试脚本、执行方式、启动模式；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;压力源：docker集群、多组、无状态（状态检查）、共享资源；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;压测数据：统一存储（ES），合并计算（jmeter），grafana展示（需优化）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;流量识别、风控放行；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;JDAnq&quot;&gt;&lt;strong&gt;&lt;span&gt;4、有赞&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;流量模型：流量来自于买家侧，正常水位-突刺-回落；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;机器成本：核心链路按量扩容，卖家侧服务按需扩容，错峰；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;核心链路：人多&amp;amp;链路复杂&amp;amp;梳理核心链路→汇总筛选→剔除→确认；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;压测策略：单机单链路基准→单机混合链路容量→全链路压测（水位）→专项预案演练；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;流量预估：监控统计-QPS、连接数、IOPS、RT、缓存命中率、consumer group、topic；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;datapool：基础数据脱敏、脚本/测试数据，统一提供存储/下发/分割功能；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;影子存储：DB路由：①.同instance不同schema（风险大）；②.不同instance同schema（安全性高，成本高）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;Redis路由：①.key值加统一前缀；②.Redis-client做路由；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;ES路由：①.index统一加前缀，提供统一ES client做数据访问，由client做路由；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;应用变更：微服务，统一隔离，流量标透传存储；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;流量下发：数据文件：按照场景区分（考虑漏斗模型-转化）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;压测脚本：①.不同场景的流量配比；②.每个场景按URL从上至下做转化（gatling）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;水位检测：压测过程中，①.实时采集各应用服务的资源使用情况+RT+TPS+成功率；&lt;/span&gt;&lt;span&gt;②.流量干预，保护生产服务不受影响；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;压测实施：①.基础中间件开发，路由策略，框架升级，压测引擎选型开发调试-基础架构；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;②.业务改造升级+线下验证（功能验证，手动点击，数据落影子库）-功能测试；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;③.业务改造升级+生产验证（功能验证，手动点击，数据落影子库）-功能测试；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;④.datapool准备：数据生成，脚本文件切割下发-业务开发&amp;amp;测试；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;⑤.小流量下发验证-测试域同学；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;⑥.模拟真实场景压测验证-团队协同；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;压测方式：流量递增/爬坡（梯度增加，优化扩容）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;链路梳理：非核心链路-去依赖解耦；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;长期规划：轮询化：线时链路测试机器人，实时检测；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;常规化：减少人力成本投入；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;日常化：尽可能少熬夜，白天完成；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;图形化：链路压测规划图形化展示，与业务结合，一键完成数据准备工作；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;rgxQk&quot;&gt;&lt;strong&gt;&lt;span&gt;5、美团&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;&lt;strong&gt;全链路压测思路&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-selected&quot; data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F403166%2F1574388936876-3ed268a1-88c1-4115-af89-5e7ef728d106.png%22%2C%22originWidth%22%3A669%2C%22originHeight%22%3A365%2C%22name%22%3A%22image.png%22%2C%22size%22%3A186600%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22%22%2C%22width%22%3A633%2C%22height%22%3A345%7D&quot;&gt;&lt;img class=&quot;image lake-drag-image&quot; title=&quot;image.png&quot; src=&quot;https://cdn.nlark.com/yuque/0/2019/png/403166/1574388936876-3ed268a1-88c1-4115-af89-5e7ef728d106.png&quot; alt=&quot;image.png&quot; data-role=&quot;image&quot; data-raw-src=&quot;https://cdn.nlark.com/yuque/0/2019/png/403166/1574388936876-3ed268a1-88c1-4115-af89-5e7ef728d106.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;&lt;strong&gt;系统总体设计&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;&lt;strong&gt;&lt;img class=&quot;image lake-drag-image&quot; title=&quot;image.png&quot; src=&quot;https://cdn.nlark.com/yuque/0/2019/png/403166/1574390140853-7450b504-ef8d-4be4-9513-9cf01411fbf7.png&quot; alt=&quot;image.png&quot; data-role=&quot;image&quot; data-raw-src=&quot;https://cdn.nlark.com/yuque/0/2019/png/403166/1574390140853-7450b504-ef8d-4be4-9513-9cf01411fbf7.png&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;重要程度：系统稳定性建设中的核心重要位置，也是最有效的方案；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;技术背景：验证峰值流量下系统服务的伸缩性和稳定性；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;验证新上线功能的可用性、稳定性；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;限流、降级、熔断、告警灯故障演练；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;线上服务容量评估&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;技术方案：获取线上真实流量-流量录制&amp;amp;流量回放；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;快速创建压测环境-环境/服务隔离、流量标透传、灵活伸缩容；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;支持多协议类型-http、tcp、webscoket、rpc、dubbo......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;实时监控&amp;amp;过载保护；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;必备功能：数据构造、压测隔离、场景管理、动态调整、实时监控、压测报告、分布式......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;整体架构：web管理端：数据构造、环境准备、任务管理、场景管理、压测动态调整、报表展示；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;调度中心：压测资源调度、任务分发、机器资源管理；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;压测引擎：流量构造、模拟；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;监控组件：实施监控、压测数据统计、聚合分析、展示；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;链路梳理：工具化，提供自动构建压测入口链路完整的依赖信息，辅助提效手段；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;挡板服务：配置化手段，完成外部依赖等相关接口的Mock配置，无需在业务代码中嵌入压测判断逻辑；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;数据构造：流量复制、存储、清洗、解析、组合展示、偏移脱敏处理；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;链路追踪：链路匹配分析定位&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;服务隔离：大促（业务低谷）&amp;amp;常规（机器隔离）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;数据隔离：同库不同表（影子表）-成本低，风险较高&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;机器管理：动态扩容、灰度升级、异常摘除&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;压测引擎：jmeter&amp;amp;nGrinder&amp;amp;gatling&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;内存优化：内存管理&amp;amp;JVM参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;监控：秒级监控、实时展示、告警、服务保护&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;日志：压测日志采样、展示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;服务治理：限流熔断降级保护&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;注意事项：小步快跑，及时响应、项目推广、开放生态、基础资源&amp;amp;赋能；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;XyLqB&quot;&gt;&lt;strong&gt;&lt;span&gt;6、饿了么&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;用例管理：建立用例、文件上传、分类管理；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;压测执行：一键启动，可指定线程数&amp;amp;预热时间&amp;amp;测试周期和负载机，文件切割分发，分布式执行；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;监控数据：TPS、ART、Error%实时展示；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;实时数据持久化-influxdb，设置过期时间；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;冷数据持久化至MongoDB；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img alt=&quot;&quot;/&gt;&lt;img alt=&quot;&quot;/&gt;&lt;span class=&quot;lake-selected&quot; data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F403166%2F1574407464048-b74fe551-5613-49e6-a954-8c39adc34d0e.png%22%2C%22originWidth%22%3A666%2C%22originHeight%22%3A462%2C%22name%22%3A%22image.png%22%2C%22size%22%3A94265%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22%22%2C%22width%22%3A666%2C%22height%22%3A462%7D&quot;&gt;&lt;img class=&quot;image lake-drag-image&quot; title=&quot;image.png&quot; src=&quot;https://cdn.nlark.com/yuque/0/2019/png/403166/1574407464048-b74fe551-5613-49e6-a954-8c39adc34d0e.png&quot; alt=&quot;image.png&quot; data-role=&quot;image&quot; data-raw-src=&quot;https://cdn.nlark.com/yuque/0/2019/png/403166/1574407464048-b74fe551-5613-49e6-a954-8c39adc34d0e.png&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;测试报告：用例执行完毕，自动生成测试报告；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;集群监控：压测机使用状态监控，作为共享资源，提示用户可用的测试机；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;安全保障：权限管理&amp;amp;异常操作限制；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;分布式压测实现：二次开发；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img alt=&quot;&quot;/&gt;&lt;span class=&quot;lake-selected&quot; data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F403166%2F1574407482397-6aeadb12-dd82-46e0-bf78-8ad3a261045b.png%22%2C%22originWidth%22%3A726%2C%22originHeight%22%3A172%2C%22name%22%3A%22image.png%22%2C%22size%22%3A69474%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22%22%2C%22width%22%3A667%2C%22height%22%3A158%7D&quot;&gt;&lt;img class=&quot;image lake-drag-image&quot; title=&quot;image.png&quot; src=&quot;https://cdn.nlark.com/yuque/0/2019/png/403166/1574407482397-6aeadb12-dd82-46e0-bf78-8ad3a261045b.png&quot; alt=&quot;image.png&quot; data-role=&quot;image&quot; data-raw-src=&quot;https://cdn.nlark.com/yuque/0/2019/png/403166/1574407482397-6aeadb12-dd82-46e0-bf78-8ad3a261045b.png&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;异常干预：水位超限&amp;amp;服务保护&amp;amp;阈值告警&amp;amp;压测触发失败（形成闭环）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img alt=&quot;&quot;/&gt;&lt;span class=&quot;lake-selected&quot; data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F403166%2F1574407509907-0a28bbbe-008c-48fb-b403-974b7f7f5fae.png%22%2C%22originWidth%22%3A700%2C%22originHeight%22%3A330%2C%22name%22%3A%22image.png%22%2C%22size%22%3A107789%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22%22%2C%22width%22%3A661%2C%22height%22%3A312%7D&quot;&gt;&lt;img class=&quot;image lake-drag-image&quot; title=&quot;image.png&quot; src=&quot;https://cdn.nlark.com/yuque/0/2019/png/403166/1574407509907-0a28bbbe-008c-48fb-b403-974b7f7f5fae.png&quot; alt=&quot;image.png&quot; data-role=&quot;image&quot; data-raw-src=&quot;https://cdn.nlark.com/yuque/0/2019/png/403166/1574407509907-0a28bbbe-008c-48fb-b403-974b7f7f5fae.png&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;influxdb轮询：http请求轮询频次较高，需优化；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;预配置：提前配置，时段保留，节省时间，提高效率；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img alt=&quot;&quot;/&gt;&lt;span class=&quot;lake-selected&quot; data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F403166%2F1574407536632-c14234ab-9cbb-4ab5-9fa1-1a9870f58444.png%22%2C%22originWidth%22%3A693%2C%22originHeight%22%3A359%2C%22name%22%3A%22image.png%22%2C%22size%22%3A79394%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22%22%2C%22width%22%3A655%2C%22height%22%3A339%7D&quot;&gt;&lt;img class=&quot;image lake-drag-image&quot; title=&quot;image.png&quot; src=&quot;https://cdn.nlark.com/yuque/0/2019/png/403166/1574407536632-c14234ab-9cbb-4ab5-9fa1-1a9870f58444.png&quot; alt=&quot;image.png&quot; data-role=&quot;image&quot; data-raw-src=&quot;https://cdn.nlark.com/yuque/0/2019/png/403166/1574407536632-c14234ab-9cbb-4ab5-9fa1-1a9870f58444.png&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;服务保护&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;权限分级：高峰期禁止直行；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;压测干预，随时手动触发禁止动作，kill所有压测机上运行的压测进程；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;限流熔断：根据错误率和告警阈值判断，达到或超过自动熔断；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;兜底服务：系统不可用需要停止测试时，外部强制停止，过载保护；&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;lake-fontsize-10&quot;&gt;以上内容，来自各大厂方案的汇总整理，仅供参考。。。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 07 Dec 2019 15:49:00 +0000</pubDate>
<dc:creator>老_张</dc:creator>
<og:description>最近忙于公司的全链路压测平台调研和技术规划文档输出工作，参考了全网能搜到的业内大厂的全链路压测方案，这里做个汇总，以及将个人认为可以落地的方案做一个关键点整理。 技术链接 滴滴全链路压测解决之道 阿里</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/imyalost/p/12004026.html</dc:identifier>
</item>
<item>
<title>WSGI到底是什么？ - Yabea</title>
<link>http://www.cnblogs.com/ybjourney/p/12004002.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ybjourney/p/12004002.html</guid>
<description>&lt;p&gt;在用Python Web开发时经常会遇到WSGI，所以WSGI到底是什么呢？本文我们一起来揭开WSGI神秘的面纱！&lt;/p&gt;
&lt;p&gt;先来看一下&lt;strong&gt;WSGI的介绍&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;全称Python Web Server Gateway Interface，指定了web服务器和Python web应用或web框架之间的标准接口，以提高web应用在一系列web服务器间的移植性。 具体可查看 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0333/&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从以上介绍我们可以看出：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;WSGI是一套接口标准协议/规范；&lt;/li&gt;
&lt;li&gt;通信（作用）区间是Web服务器和Python Web应用程序之间；&lt;/li&gt;
&lt;li&gt;目的是制定标准，以保证不同Web服务器可以和不同的Python程序之间相互通信&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;你可能会问，&lt;strong&gt;为什么需要WSGI？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，我们明确一下web应用处理请求的具体流程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;用户操作操作浏览器发送请求；&lt;/li&gt;
&lt;li&gt;请求转发至对应的web服务器&lt;/li&gt;
&lt;li&gt;web服务器将请求转交给web应用程序，web应用程序处理请求&lt;/li&gt;
&lt;li&gt;web应用将请求结果返回给web服务器，由web服务器返回用户响应结果&lt;/li&gt;
&lt;li&gt;浏览器收到响应，向用户展示&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;可以看到，请求时Web服务器需要和web应用程序进行通信，但是web服务器有很多种啊，Python web应用开发框架也对应多种啊，所以WSGI应运而生，定义了一套通信标准。试想一下，如果不统一标准的话，就会存在Web框架和Web服务器数据无法匹配的情况，那么开发就会受到限制，这显然不合理的。&lt;/p&gt;
&lt;p&gt;既然定义了标准，那么&lt;strong&gt;WSGI的标准或规范是？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;web服务器在将请求转交给web应用程序之前，需要先将http报文转换为WSGI规定的格式。&lt;/p&gt;
&lt;p&gt;WSGI规定，Web程序必须有一个可调用对象，且该可调用对象接收两个参数，返回一个可迭代对象：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;environ：字典，包含请求的所有信息&lt;/li&gt;
&lt;li&gt;start_response：在可调用对象中调用的函数，用来发起响应，参数包括状态码，headers等&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;通过以上学习，一起&lt;strong&gt;实现一个简单WSGI服务吧&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，我们编写一个符合WSGI标准的一个http处理函数：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def hello(environ, start_response):
    status = &quot;200 OK&quot;
    response_headers = [('Content-Type', 'text/html')]
    start_response(status, response_headers)
    path = environ['PATH_INFO'][1:] or 'hello'
    return [b'&amp;lt;h1&amp;gt; %s &amp;lt;/h1&amp;gt;' % path.encode()]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法负责获取environ字典中的path_info，也就是获取请求路径，然后在前端展示。&lt;/p&gt;
&lt;p&gt;接下来，我们需要一个服务器启动WSGI服务器用来处理验证，使用Python内置的WSGI服务器模块wsgiref，编写server.py：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# coding:utf-8
&quot;&quot;&quot;
desc: WSGI服务器实现
&quot;&quot;&quot;
from wsgiref.simple_server import make_server
from learn_wsgi.client import hello


def main():
    server = make_server('localhost', 8001, hello)
    print('Serving HTTP on port 8001...')
    server.serve_forever()


if __name__ == '__main__':
    main()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行python server.py，浏览器打开&quot;&lt;a href=&quot;http://localhost:8001/a&quot; class=&quot;uri&quot;&gt;http://localhost:8001/a&lt;/a&gt;&quot;，即可验证。&lt;/p&gt;
&lt;p&gt;通过实现一个简单的WSGI服务，我们可以看到：通过environ可以获取http请求的所有信息，http响应的数据都可以通过start_response加上函数的返回值作为body。&lt;/p&gt;
&lt;p&gt;当然，以上只是一个简单的案例，那么在python的Web框架内部是如何遵循WSGI规范的呢？以Flask举例，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Flask与WSGI&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Flask中的程序实例app就是一个可调用对象，我们创建app实例时所调用的Flask类实现了__call__方法，__call__方法调用了wsgi_app()方法，该方法完成了请求和响应的处理，WSGI服务器通过调用该方法传入请求数据，获取返回数据：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def wsgi_app(self, environ, start_response):
    ctx = self.request_context(environ)
    error = None
    try:
        try:
            ctx.push()
            response = self.full_dispatch_request()
        except Exception as e:
            error = e
            response = self.handle_exception(e)
        except:  # noqa: B001
            error = sys.exc_info()[1]
            raise
        return response(environ, start_response)
    finally:
        if self.should_ignore_error(error):
            error = None
        ctx.auto_pop(error)

def __call__(self, environ, start_response):
    return self.wsgi_app(environ, start_response)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Flask的werkzeug库是一个非常优秀的WSGI工具库，具体的实现我们之后再详细学习。&lt;/p&gt;
&lt;p&gt;以上。&lt;/p&gt;
</description>
<pubDate>Sat, 07 Dec 2019 15:40:00 +0000</pubDate>
<dc:creator>Yabea</dc:creator>
<og:description>本文分享WSGI到底是什么。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ybjourney/p/12004002.html</dc:identifier>
</item>
</channel>
</rss>