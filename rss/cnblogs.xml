<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>CPU Cache 机制以及 Cache miss - JokerJason</title>
<link>http://www.cnblogs.com/jokerjason/p/10711022.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jokerjason/p/10711022.html</guid>
<description>&lt;p&gt;CPU体系结构之cache小结&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.What is cache?&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;Cache是用来对内存数据的缓存。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;CPU要访问的数据在Cache中有缓存，称为“命中” (Hit)，反之则称为“缺失” (Miss)。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;CPU访问它的速度介于寄存器与内存之间（数量级的差别）。实现Cache的花费介于寄存器与内存之间。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;现在 CPU 的 Cache 又被细分了几层，常见的有 L1 Cache, L2 Cache, L3 Cache，其读写延迟依次增加，实现的成本依次降低。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;现代系统采用从 Register ―&amp;gt; L1 Cache ―&amp;gt; L2 Cache ―&amp;gt; L3 Cache ―&amp;gt; Memory ―&amp;gt; Mass storage的层次结构，是为解决性能与价格矛盾所采用的折中设计。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;下图描述的就是CPU、Cache、内存、以及DMA之间的关系。程序的指令部分和数据部分一般分别存放在两片不同的cache中，对应指令缓存（I-Cache）和数据缓存（D-Cache）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/941117/201904/941117-20190415153854116-1717451517.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;引入 Cache 的理论基础是&lt;span&gt;&lt;strong&gt;程序局部性原理&lt;/strong&gt;&lt;/span&gt;，包括时间局部性和空间局部性。即最近被CPU访问的数据，短期内CPU 还要访问（时间）；被 CPU 访问的数据附近的数据，CPU 短期内还要访问（空间）。因此如果将刚刚访问过的数据缓存在Cache中，那下次访问时，可以直接从Cache中取，其速度可以得到数量级的提高。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;CPU缓存（Cache Memory）位于CPU与内存之间的临时存储器，它的容量比内存小但交换速度快。在缓存中的数据是内存中的一小部分，但这一小部分是短时间内CPU即将访问的，当CPU调用大量数据时，就可避开内存直接从缓存中调用，从而加快读取速度。&lt;/p&gt;&lt;p&gt;在CPU中加入缓存是一种高效的解决方案，这样整个内存储器（缓存+内存）就变成了既有缓存的高速度，又有内存的大容量的存储系统了。缓存对CPU的性能影响很大，主要是因为CPU的数据交换顺序和CPU与缓存间的带宽引起的。&lt;/p&gt;&lt;p&gt;下图是一个典型的存储器层次结构，我们可以看到一共使用了三级缓存&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/941117/201904/941117-20190415151355245-1616621096.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. Why should I care about cache?&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/941117/201904/941117-20190415151438010-85846939.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;从延迟上看，做一次乘法一般只要三个周期，而做一次CPU的内存访问需要167个cycle，如果需要提升程序性能，减少CPU的memory访问至关重要。因此，需要采用容量小但是更快的存储器（cache）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.为什么要有多级CPU Cache&lt;/span&gt;&lt;/p&gt;&lt;p&gt;随着科技发展，热点数据的体积越来越大，单纯的增加一级缓存大小的性价比已经很低了&lt;br/&gt;二级缓存就是一级缓存的缓冲器：一级缓存制造成本很高因此它的容量有限，二级缓存的作用就是存储那些CPU处理时需要用到、一级缓存又无法存储的数据。&lt;br/&gt;同样道理，三级缓存和内存可以看作是二级缓存的缓冲器，它们的容量递增，但单位制造成本却递减。&lt;br/&gt;另外需要注意的是，L3 Cache和L1，L2 Cache有着本质的区别。，L1和L2 Cache都是每个CPU core独立拥有一个，而L3 Cache是几个Cores共享的，可以认为是一个更小但是更快的内存。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/941117/201904/941117-20190415151555484-995491025.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;使用dmidecode命令查看cache size&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/941117/201904/941117-20190415151607267-286721434.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.cpu与cache 内存交互的过程&lt;/span&gt;&lt;/p&gt;&lt;p&gt;CPU接收到指令后，它会最先向CPU中的一级缓存（L1 Cache）去寻找相关的数据，然一级缓存是与CPU同频运行的，但是由于容量较小，所以不可能每次都命中。这时CPU会继续向下一级的二级缓存（L2 Cache）寻找，同样的道理，当所需要的数据在二级缓存中也没有的话，会继续转向L3 Cache、内存(主存)和硬盘.&lt;/p&gt;&lt;p&gt;程序运行时可以使用perf工具观察cache-miss的rate.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;5.什么是cache line&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Cache Line可以简单的理解为CPU Cache中的最小缓存单位。&lt;br/&gt;内存和高速缓存之间或高速缓存之间的数据移动不是以单个字节或甚至word完成的。&lt;br/&gt;相反，移动的最小数据单位称为缓存行，有时称为缓存块&lt;br/&gt;目前主流的CPU Cache的Cache Line大小都是64Bytes。假设我们有一个512字节的一级缓存，那么按照64B的缓存单位大小来算，这个一级缓存所能存放的缓存个数就是512/64 = 8个。&lt;br/&gt;查看cache line大小&lt;br/&gt;cat /sys/devices/system/cpu/cpu1/cache/index0/coherency_line_size&lt;br/&gt;cache line的影响：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; N; i+=&lt;span&gt;k)
    arr[i] &lt;/span&gt;*= &lt;span&gt;3&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/941117/201904/941117-20190415151723631-1714332519.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;注意当步长在1到16范围内，循环运行时间几乎不变。但从16开始，每次步长加倍，运行时间减半。&lt;br/&gt;由于16个整型数占用64字节（一个缓存行），for循环步长在1到16之间必定接触到相同数目的缓存行：即数组中所有的缓存行。当步长为32，我们只有大约每两个缓存行接触一次，当步长为64，只有每四个接触一次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;6. cache写机制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Cache写机制分为write through和write back两种。&lt;/p&gt;&lt;p&gt;Write-through- Write is done synchronously both to the cache and to the backing store.&lt;br/&gt;Write-back (or Write-behind) - Writing is done only to the cache. A modified cache block is written back to the store, just before it is replaced.&lt;/p&gt;&lt;p&gt;Write-through（直写模式）在数据更新时，同时写入缓存Cache和后端存储。此模式的优点是操作简单；缺点是因为数据修改需要同时写入存储，数据写入速度较慢。&lt;/p&gt;&lt;p&gt;Write-back（回写模式）在数据更新时只写入缓存Cache。只在数据被替换出缓存时，被修改的缓存数据才会被写到后端存储。此模式的优点是数据写入速度快，因为不需要写存储；缺点是一旦更新后的数据未被写入存储时出现系统掉电的情况，数据将无法找回。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;7.cache 一致性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;多个处理器对某个内存块同时读写，会引起冲突的问题，这也被称为Cache一致性问题。&lt;br/&gt;Cache一致性问题出现的原因是在一个多处理器系统中，多个处理器核心都能够独立地执行计算机指令，从而有可能同时对某个内存块进行读写操作，并且由于我们之前提到的回写和直写的Cache策略，导致一个内存块同时可能有多个备份，有的已经写回到内存中，有的在不同的处理器核心的一级、二级Cache中。由于Cache缓存的原因，我们不知道数据写入的时序性，因而也不知道哪个备份是最新的。还有另外一个一种可能，假设有两个线程A和B共享一个变量，当线程A处理完一个数据之后，通过这个变量通知线程B，然后线程B对这个数据接着进行处理，如果两个线程运行在不同的处理器核心上，那么运行线程B的处理器就会不停地检查这个变量，而这个变量存储在本地的Cache中，因此就会发现这个值总也不会发生变化。&lt;/p&gt;&lt;p&gt;为了正确性，一旦一个核心更新了内存中的内容，硬件就必须要保证其他的核心能够读到更新后的数据。目前大多数硬件采用的策略或协议是MESI或基于MESI的变种：&lt;br/&gt;M代表更改（modified），表示缓存中的数据已经更改，在未来的某个时刻将会写入内存；&lt;br/&gt;E代表排除（exclusive），表示缓存的数据只被当前的核心所缓存；&lt;br/&gt;S代表共享（shared），表示缓存的数据还被其他核心缓存；&lt;br/&gt;I代表无效（invalid），表示缓存中的数据已经失效，即其他核心更改了数据。&lt;br/&gt;8.cache的局部性&lt;/p&gt;&lt;p&gt;程序在一段时间内访问的数据通常具有局部性，比如对一维数组来说，访问了地址x上的元素，那么以后访问地址x+1、x+2上元素的可能性就比较高；现在访问的数据，在不久之后再次被访问的可能性也比较高。局部性分为“时间局部性”和“空间局部性”，时间局部性是指当前被访问的数据随后有可能访问到；空间局部性是指当前访问地址附近的地址可能随后被访问。处理器通过在内存和核心之间增加缓存以利用局部性增强程序性能，这样可以用远低于缓存的价格换取接近缓存的速度。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;时间局部性：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;代码1：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; (loop=&lt;span&gt;0&lt;/span&gt;; loop&amp;lt;&lt;span&gt;10&lt;/span&gt;; loop++&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;N; i++&lt;span&gt;) {
        ... &lt;/span&gt;=&lt;span&gt; ... x[i] ...
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;代码2：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; (i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;N; i++&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (loop=&lt;span&gt;0&lt;/span&gt;; loop&amp;lt;&lt;span&gt;10&lt;/span&gt;; loop++&lt;span&gt;) {
        ... &lt;/span&gt;=&lt;span&gt; ... x[i] ...
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;代码二的性能优于代码1，x的元素现在被重复使用，因此更有可能留在缓存中。 这个&lt;br/&gt;重新排列的代码在使用x[i]时显示更好的时间局部性。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;空间局部性：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;一个矩阵乘法的例子：&lt;br/&gt;代码1：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;..n
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; j=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;..n
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; k=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;..n
            c[i,j] &lt;/span&gt;+= a[i,k]*b[k,j]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;代码2：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;..n
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; k=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;..n
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; j=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;..n
            c[i,j] &lt;/span&gt;+= a[i,k]*b[k,j]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码2的性能优于代码一的性能。&lt;br/&gt;两者实现上的差异：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/941117/201904/941117-20190415151935721-708823313.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;代码2的b[k,j]是按行访问的，所以存在良好的空间局部性，cache line被充分利用。&lt;br/&gt;代码1中，b [k，j]由列访问。 由于行的存储矩阵，因此对于每个缓存行加载，只有一个元素用于遍历。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;9.cache替换策略&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Cache工作原理要求它尽量保存最新数据，当从主存向Cache传送一个新块，而Cache中可用位置已被占满时，就会产生Cache替换的问题。&lt;br/&gt;常用的替换算法有下面三种。&lt;br/&gt;（1） LFU&lt;br/&gt;LFU（Least Frequently Used，最不经常使用）算法将一段时间内被访问次数最少的那个块替换出去。每块设置一个计数器，从0开始计数，每访问一次，被访块的计数器就增1。当需要替换时，将计数值最小的块换出，同时将所有块的计数器都清零。&lt;br/&gt;这种算法将计数周期限定在对这些特定块两次替换之间的间隔时间内，不能严格反映近期访问情况，新调入的块很容易被替换出去。&lt;br/&gt;（2）LRU&lt;br/&gt;LRU（Least Recently Used，近期最少使用）算法是把CPU近期最少使用的块替换出去。这种替换方法需要随时记录Cache中各块的使用情况，以便确定哪个块是近期最少使用的块。每块也设置一个计数器，Cache每命中一次，命中块计数器清零，其他各块计数器增1。当需要替换时，将计数值最大的块换出。&lt;br/&gt;LRU算法相对合理，但实现起来比较复杂，系统开销较大。这种算法保护了刚调入Cache的新数据块，具有较高的命中率。LRU算法不能肯定调出去的块近期不会再被使用，所以这种替换算法不能算作最合理、最优秀的算法。但是研究表明，采用这种算法可使Cache的命中率达到90%左右。&lt;br/&gt;（3） 随机替换&lt;br/&gt;最简单的替换算法是随机替换。随机替换算法完全不管Cache的情况，简单地根据一个随机数选择一块替换出去。随机替换算法在硬件上容易实现，且速度也比前两种算法快。缺点则是降低了命中率和Cache工作效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;10.cache的映射&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;主存与cache的地址映射方式有全相联方式、直接方式和组相联方式三种。&lt;br/&gt;直接映射&lt;br/&gt;将一个主存块存储到唯一的一个Cache行。&lt;/p&gt;&lt;p&gt;1) 多对一的映射关系，但一个主存块只能拷贝到cache的一个特定行位置上去。&lt;br/&gt;cache的行号i和主存的块号j有如下函数关系：i=j mod m（m为cache中的总行数）&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/941117/201904/941117-20190415152015554-2116413964.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;优点：硬件简单，容易实现&lt;br/&gt;缺点：命中率低， Cache的存储空间利用率低&lt;/p&gt;&lt;p&gt;2) 全相联映射&lt;br/&gt;可以将一个主存块存储到任意一个Cache行。&lt;br/&gt;主存的一个块直接拷贝到cache中的任意一行上&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/941117/201904/941117-20190415152038861-573924176.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;优点：命中率较高，Cache的存储空间利用率高&lt;br/&gt;缺点：线路复杂，成本高，速度低&lt;/p&gt;&lt;p&gt;组相联映射&lt;br/&gt;可以将一个主存块存储到唯一的一个Cache组中任意一个行。&lt;br/&gt;将cache分成u组，每组v行，主存块存放到哪个组是固定的，至于存到该组哪一行是灵活的，即有如下函数关系：cache总行数m＝u×v 组号q＝j mod u&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/941117/201904/941117-20190415152136772-1526893524.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;组间采用直接映射，组内为全相联&lt;br/&gt;硬件较简单，速度较快，命中率较高&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Cache Miss&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.不要期望编译器对你做任何优化&lt;/p&gt;
&lt;p&gt;2.Cache(&lt;span&gt;广义内存&lt;/span&gt;)&lt;span&gt;系统代表性的包括三种级别：&lt;br/&gt;（&lt;span&gt;1&lt;span&gt;）第一级&lt;span&gt;cache (L1)&lt;span&gt;位于&lt;span&gt;CPU&lt;span&gt;芯片上并且运算于&lt;span&gt;CPU&lt;span&gt;工作频率；&lt;br/&gt;（&lt;span&gt;2&lt;span&gt;）第二级&lt;span&gt;cache(L2)&lt;span&gt;也位于芯片上比&lt;span&gt;L1&lt;span&gt;速度慢而体积大；&lt;br/&gt;（&lt;span&gt;3&lt;span&gt;）第三级&lt;span&gt;cache(L3)&lt;span&gt;位于&lt;span&gt;CPU&lt;span&gt;外部，是速度最慢、体积最大的存储器。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.当运算器需要从存储器中提取数据时，它首先在最高级的&lt;span&gt;cache&lt;span&gt;中寻找然后在次高级的&lt;span&gt;cache&lt;span&gt;中寻找。如果在&lt;span&gt;cache&lt;span&gt;中找到，则称为命中&lt;span&gt;hit&lt;span&gt;；反之，则称为不命中&lt;span&gt;miss&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.cache misses&lt;span&gt;的种类：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（1）cold misses&lt;span&gt;：不可避免。若&lt;span&gt;K&lt;span&gt;级&lt;span&gt;cache&lt;span&gt;空，则必发生&lt;span&gt;cache miss&lt;span&gt;，空的&lt;span&gt;cache&lt;span&gt;称为&lt;span&gt;cold cache&lt;span&gt;，这种&lt;span&gt;cache misses&lt;span&gt;称为&lt;span&gt;compulsory misses&lt;span&gt;或者&lt;span&gt;cold misses&lt;span&gt;。当&lt;span&gt;cache&lt;span&gt;已被&lt;span&gt;warmed up&lt;span&gt;则一般不会再发生&lt;span&gt;cold misses&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（2）conflict misses&lt;span&gt;：多个&lt;span&gt;K+1&lt;span&gt;级的&lt;span&gt;blocks&lt;span&gt;被映射到&lt;span&gt;K&lt;span&gt;级中同一个&lt;span&gt;block&lt;span&gt;。这一点关系到对于程序员而言能否写出&lt;span&gt;cache&lt;span&gt;友好代码。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（3）程序常会分阶段执行（例如循环：内层、外层），每个阶段会取&lt;span&gt;cache blocks&lt;span&gt;的固定几个块，这几个块所构成的集合称为&lt;span&gt;working set&lt;span&gt;。 当&lt;span&gt;working set&lt;span&gt;超过&lt;span&gt;cache&lt;span&gt;大小时所发生的&lt;span&gt;miss&lt;span&gt;称为&lt;span&gt;capacity misses&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5.从&lt;span&gt;cache&lt;span&gt;指令上做优化：简化调用关系，减少冗余代码（即不是必须存在的的代码），减小代码量，减少不必要的调用；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;6.从数据&lt;span&gt;cache&lt;span&gt;上做优化：即减少&lt;span&gt;cache miss&lt;span&gt;的次数，方法有不少，&lt;span&gt;http://blog.chinaunix.net/uid-7319742-id-2059720.html &lt;span&gt;这篇文章有介绍&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;推荐链接：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;http://bi.dataguru.cn/thread-163962-1-1.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;http://blog.chinaunix.net/uid-7319742-id-2059720.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;http://blog.csdn.net/wangjiaoyu250/article/details/9212863&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;http://coolshell.cn/articles/10249.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;https://blog.csdn.net/yhb1047818384/article/details/79604976&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 15 Apr 2019 07:41:00 +0000</pubDate>
<dc:creator>JokerJason</dc:creator>
<og:description>CPU体系结构之cache小结 1.What is cache? Cache是用来对内存数据的缓存。 CPU要访问的数据在Cache中有缓存，称为“命中” (Hit)，反之则称为“缺失” (Miss)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jokerjason/p/10711022.html</dc:identifier>
</item>
<item>
<title>spring事务传播行为之使用REQUIRES_NEW不回滚 - 酒鬼_blog</title>
<link>http://www.cnblogs.com/whwei-blog/p/10708926.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whwei-blog/p/10708926.html</guid>
<description>&lt;p&gt;最近写spring事务时用到REQUIRES_NEW遇到一些不回滚的问题,所以就记录一下。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;场景1:在一个服务层里面方法1和方法2都加上事务,其中方法二设置上&lt;/span&gt;&lt;span&gt;propagation=Propagation.REQUIRES_NEW&lt;/span&gt;&lt;span&gt;,方法1调用方法2并且在执行完方法2后抛出一个异常,如下代码&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BookServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BookService {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; JdbcTemplate jdbcTemplate;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     
&lt;span&gt; 7&lt;/span&gt;     @Transactional(timeout=4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;售卖  扣除库存数量&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         String sellSql = &quot;UPDATE book_stock SET stock = stock - ? WHERE isbn = (SELECT isbn FROM book WHERE NAME = ?)&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;入账的sql  将赚到的钱添加到account表中的balance&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         String addRmbSql = &quot;UPDATE account SET balance = balance + ? * (SELECT price FROM book WHERE NAME = ?)&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         Object []params = {1,&quot;Spring&quot;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        jdbcTemplate.update(sellSql, params);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        testUpdate();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        jdbcTemplate.update(addRmbSql, params);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;故意的一个异常&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     @Transactional(propagation=&lt;span&gt;Propagation.REQUIRES_NEW)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testUpdate() {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个业务没什么意义,只是用来测试REQUIRES_NEW的 当执行后SpringMVC这本书库存-1&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         String sql = &quot;UPDATE book_stock SET stock = stock - ? WHERE isbn = (SELECT isbn FROM book WHERE NAME = ?)&quot;&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         Object []params = {1,&quot;SpringMVC&quot;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        jdbcTemplate.update(sql, params);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         
&lt;span&gt;31&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517282/201904/1517282-20190415093348072-883208447.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517282/201904/1517282-20190415093354909-2105527042.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517282/201904/1517282-20190415093359254-1204944376.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三张表分别是对应account表,book表,book_stock表&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;  ClassPathXmlApplicationContext ac = &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;classpath:spring/*.xml&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testREQUIRES_NEW() {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         
&lt;span&gt;6&lt;/span&gt;         BookService bean = ac.getBean(BookService.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         
&lt;span&gt;8&lt;/span&gt; &lt;span&gt;        bean.update();
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;结果是无论是方法1还是方法2都回滚了,那么REQUIRES_NEW就不起作用了,为了探索原因我修改了一下代码&lt;/p&gt;
&lt;p&gt;在第5行的地方打印出对象的类型是什么&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testREQUIRES_NEW() {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         
&lt;span&gt;4&lt;/span&gt;         BookService bean = ac.getBean(BookService.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         System.out.println(&quot;update的调用者:&quot;+&lt;span&gt;bean.getClass());
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;        bean.update();
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在第11行的地方打印对象类型&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @Transactional(timeout=4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;售卖&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         String sellSql = &quot;UPDATE book_stock SET stock = stock - ? WHERE isbn = (SELECT isbn FROM book WHERE NAME = ?)&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;入账的sql&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         String addRmbSql = &quot;UPDATE account SET balance = balance + ? * (SELECT price FROM book WHERE NAME = ?)&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         Object []params = {1,&quot;Spring&quot;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        jdbcTemplate.update(sellSql, params);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         System.out.println(&quot;testUpdate的调用者:&quot;+&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getClass());
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        testUpdate();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        jdbcTemplate.update(addRmbSql, params);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;故意的一个异常&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果是&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517282/201904/1517282-20190415132759939-353281249.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显然调用update的对象是一个代理对象,调用testUpdate的对象不是一个代理对象,这就是为什么添加REQUIRES_NEW不起作用，想要让注解生效就要用代理对象的方法，不能用原生对象的.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决方法：在配置文件中添加标签&amp;lt;aop:aspectj-autoproxy   expose-proxy=&quot;true&quot;&amp;gt;&amp;lt;/aop:aspectj-autoproxy&amp;gt;将代理暴露出来，使AopContext.currentProxy()获取当前代理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将代码修改为&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
        &amp;lt;!-- 开启事务注解 --&amp;gt;
        &amp;lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&amp;gt;
        &amp;lt;!-- 将代理暴露出来 --&amp;gt;
        &amp;lt;aop:aspectj-autoproxy   expose-proxy=&quot;true&quot;&amp;gt;&amp;lt;/aop:aspectj-autoproxy&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　11 12行将this替换为((BookService)AopContext.currentProxy())&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     @Transactional(timeout=4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;售卖&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         String sellSql = &quot;UPDATE book_stock SET stock = stock - ? WHERE isbn = (SELECT isbn FROM book WHERE NAME = ?)&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;入账的sql&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         String addRmbSql = &quot;UPDATE account SET balance = balance + ? * (SELECT price FROM book WHERE NAME = ?)&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         Object []params = {1,&quot;Spring&quot;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        jdbcTemplate.update(sellSql, params);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         System.out.println(&quot;testUpdate的调用者:&quot;+&lt;span&gt;((BookService)AopContext.currentProxy()).getClass());
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        ((BookService)AopContext.currentProxy()).testUpdate();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        jdbcTemplate.update(addRmbSql, params);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;故意的一个异常&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;p&gt;调用的对象变成代理对象了  那么结果可想而知第一个事务被挂起,第二个事务执行完提交了 然后异常触发,事务一回滚  SpringMVC这本书库存-1,其他的不变&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517282/201904/1517282-20190415134919004-1232686346.png&quot; alt=&quot;&quot; width=&quot;324&quot; height=&quot;99&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517282/201904/1517282-20190415135427399-2064061103.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517282/201904/1517282-20190415135440514-539154623.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517282/201904/1517282-20190415135446183-671010702.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我还看到过另一种解决方法  &lt;/p&gt;
&lt;p&gt;在第7行加一个BookService类型的属性并且给个set方法,目的就是将代理对象传递过来...    看26 27行显然就是用代理对象去调用的方法   所以就解决问题了   不过还是用第一个方案好&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BookServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BookService {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; JdbcTemplate jdbcTemplate;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; BookService proxy;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setProxy(BookService proxy) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.proxy =&lt;span&gt; proxy;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     
&lt;span&gt;13&lt;/span&gt;     @Transactional(timeout=4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update() {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;售卖&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         String sellSql = &quot;UPDATE book_stock SET stock = stock - ? WHERE isbn = (SELECT isbn FROM book WHERE NAME = ?)&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;入账的sql&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         String addRmbSql = &quot;UPDATE account SET balance = balance + ? * (SELECT price FROM book WHERE NAME = ?)&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         Object []params = {1,&quot;Spring&quot;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        jdbcTemplate.update(sellSql, params);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;    System.out.println(&quot;testUpdate的调用者:&quot;+((BookService)AopContext.currentProxy()).getClass());
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        ((BookService)AopContext.currentProxy()).testUpdate();&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        System.out.println(proxy.getClass());
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        proxy.testUpdate();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        jdbcTemplate.update(addRmbSql, params);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;故意的一个异常&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;OK这个问题解决那就下一个&lt;/p&gt;
&lt;p&gt;&lt;span&gt;场景2:在一个服务层里面方法1和方法2都加上事务,其中方法二设置上propagation=Propagation.REQUIRES_NEW,方法1调用方法2并且在执行方法2时抛出一个异常     没注意看是不是觉得两个场景是一样的,因为我是拷贝下来改的...   差别就是在哪里抛出异常  这次是在方法2里面抛出异常, 我将代码还原至场景1的第一个解决方案，然后在方法2里面抛出异常 代码如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BookServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BookService {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; JdbcTemplate jdbcTemplate;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     
&lt;span&gt; 7&lt;/span&gt;     @Transactional(timeout=4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;售卖&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         String sellSql = &quot;UPDATE book_stock SET stock = stock - ? WHERE isbn = (SELECT isbn FROM book WHERE NAME = ?)&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;入账的sql&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         String addRmbSql = &quot;UPDATE account SET balance = balance + ? * (SELECT price FROM book WHERE NAME = ?)&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         Object []params = {1,&quot;Spring&quot;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        jdbcTemplate.update(sellSql, params);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         
&lt;span&gt;18&lt;/span&gt;         System.out.println(&quot;testUpdate的调用者:&quot;+&lt;span&gt;((BookService)AopContext.currentProxy()).getClass());
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        ((BookService)AopContext.currentProxy()).testUpdate();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        jdbcTemplate.update(addRmbSql, params);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     @Transactional(propagation=&lt;span&gt;Propagation.REQUIRES_NEW)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testUpdate() {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个业务没什么意义,只是用来测试REQUIRES_NEW的&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         String sql = &quot;UPDATE book_stock SET stock = stock - ? WHERE isbn = (SELECT isbn FROM book WHERE NAME = ?)&quot;&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         Object []params = {1,&quot;SpringMVC&quot;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        jdbcTemplate.update(sql, params);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;在方法二里面抛出一个异常&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;预期结果是testUpdate这个事务是要回滚的,update这个方法的事务正常执行,所以数据库的变化是balance字段的钱要+60  Spring这本书的库存-1,但是结果是数据库完全没有变化&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517282/201904/1517282-20190415142309176-1918521429.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517282/201904/1517282-20190415142314507-2120358464.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517282/201904/1517282-20190415142318916-1373417599.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分析:在testUpdate方法内抛异常被spring aop捕获,捕获后异常又被抛出,那么异常抛出后,是不是update方法没有手动捕获,而是让spring aop自动捕获,所以在update方法内也捕获到了异常,因此都回滚了&lt;/p&gt;
&lt;p&gt;这张图片的代码是我debug模式下  在testUpdate方法中执行到抛出异常的地方  再点step over 跳到的地方   显然spring aop捕获到了异常后,再次抛出,这就是为什么update方法会捕获到异常&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1517282/201904/1517282-20190415144440642-1289805084.png&quot; alt=&quot;&quot; width=&quot;658&quot; height=&quot;297&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OK问题很简单   解决方案也很简单   只需要手动捕获该异常,不让spring aop捕获就OK了&lt;/p&gt;
&lt;p&gt;将update方法改为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @Transactional(timeout=4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;售卖&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         String sellSql = &quot;UPDATE book_stock SET stock = stock - ? WHERE isbn = (SELECT isbn FROM book WHERE NAME = ?)&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;入账的sql&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         String addRmbSql = &quot;UPDATE account SET balance = balance + ? * (SELECT price FROM book WHERE NAME = ?)&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         Object []params = {1,&quot;Spring&quot;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        jdbcTemplate.update(sellSql, params);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             System.out.println(&quot;testUpdate的调用者:&quot;+&lt;span&gt;((BookService)AopContext.currentProxy()).getClass());
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            ((BookService)AopContext.currentProxy()).testUpdate();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (RuntimeException e) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            System.out.println(e.getMessage());
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        jdbcTemplate.update(addRmbSql, params);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         
&lt;span&gt;23&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果    update执行成功   testUpdate回滚&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517282/201904/1517282-20190415145655172-619078964.png&quot; alt=&quot;&quot; width=&quot;436&quot; height=&quot;111&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517282/201904/1517282-20190415145658522-2033614985.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517282/201904/1517282-20190415145701971-239992116.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517282/201904/1517282-20190415145705312-1570682782.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 总结:同一个Service不同事务的嵌套会出现调用的对象不是代理对象的问题,如果是多个不同Service的不同事务嵌套就没有这个问题。场景2的要记得手动捕获异常,不然全回滚了.至于为什么调用testUpdate方法的对象不是代理对象,可能还要看源码,懂的人可以在评论区分享一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果有错误,请评论区指正&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 15 Apr 2019 07:23:00 +0000</pubDate>
<dc:creator>酒鬼_blog</dc:creator>
<og:description>最近写spring事务时用到REQUIRES_NEW遇到一些不回滚的问题,所以就记录一下。 场景1:在一个服务层里面方法1和方法2都加上事务,其中方法二设置上propagation=Propagati</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/whwei-blog/p/10708926.html</dc:identifier>
</item>
<item>
<title>Envoy 源码分析－－network - mathli</title>
<link>http://www.cnblogs.com/mathli/p/10710856.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mathli/p/10710856.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;申明：本文的 Envoy 源码分析基于 Envoy1.10.0。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Envoy&lt;/code&gt; 的服务是通用服务，因此它需要支持 &lt;code&gt;TCP&lt;/code&gt; 和 &lt;code&gt;UDP&lt;/code&gt;，同时还需支持 &lt;code&gt;IPV4&lt;/code&gt; 和 &lt;code&gt;IPV6&lt;/code&gt; 两种网络协议，所以网络模块有点复杂。本次分析的网络模块是底层的模块，没有一整个服务的启动流程，有的地方可能还串不起来。现在先来看下UML类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531082/201904/1531082-20190415151955171-1051804162.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;类图看上去略显复杂，主要分为4块：&lt;code&gt;addres&lt;/code&gt;，&lt;code&gt;socket&lt;/code&gt;，&lt;code&gt;listen&lt;/code&gt; 和 &lt;code&gt;connection&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;address&lt;/code&gt; 是地址相关的，主要包括 &lt;code&gt;IPV4&lt;/code&gt;，&lt;code&gt;IPV6&lt;/code&gt;，&lt;code&gt;PIPE&lt;/code&gt;，&lt;code&gt;DNS&lt;/code&gt; 和 &lt;code&gt;cidr&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;socket&lt;/code&gt; 是 &lt;code&gt;socket&lt;/code&gt; 相关的操作，主要包括 &lt;code&gt;ListenSocket&lt;/code&gt;，&lt;code&gt;ConnectionSocket&lt;/code&gt;，&lt;code&gt;TransportSocket&lt;/code&gt; 以及 &lt;code&gt;option&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;listen&lt;/code&gt; 是网络监听操作，包括 &lt;code&gt;TCP&lt;/code&gt; 监听和 &lt;code&gt;UDP&lt;/code&gt; 监听。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;connection&lt;/code&gt; 是连接相关操作。关于 L3/4 过滤的这次暂时不分析，后续再讲。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;address&quot;&gt;address&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;InstanceBase&lt;/code&gt; 继承自 &lt;code&gt;Instance&lt;/code&gt; 是所有地址类型的基类。&lt;code&gt;Ipv4Instance&lt;/code&gt;，&lt;code&gt;Ipv6Instance&lt;/code&gt; 和 &lt;code&gt;PipeInstance&lt;/code&gt; 三个地址类都是继承 &lt;code&gt;InstanceBase&lt;/code&gt;。 &lt;code&gt;DNS&lt;/code&gt;解析类使用 &lt;code&gt;c-ares&lt;/code&gt; 库，&lt;code&gt;DnsResolverImpl&lt;/code&gt; 只是对 &lt;code&gt;c-ares&lt;/code&gt; 的进一步封装。 &lt;code&gt;CidrRange&lt;/code&gt; 是对 &lt;a href=&quot;https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing&quot;&gt;cidr&lt;/a&gt; 操作相关。&lt;/p&gt;
&lt;p&gt;系统操作返回的值和错误信息封装成一个公用的结构体。具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;template &amp;lt;typename T&amp;gt; struct SysCallResult {
  //系统返回值
  T rc_;
  //系统返回的错误信息
  int errno_;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;instance&quot;&gt;Instance&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Ipv4Instance&lt;/code&gt;，&lt;code&gt;Ipv6Instance&lt;/code&gt; 和 &lt;code&gt;PipeInstance&lt;/code&gt; 三个地址类都是继承 &lt;code&gt;InstanceBase&lt;/code&gt;。它们的实现基本都差不多，&lt;code&gt;socket()&lt;/code&gt;、&lt;code&gt;bind()&lt;/code&gt; 和 &lt;code&gt;connect()&lt;/code&gt; 这三个基础操作都属于它们的成员。现在我们主要来看下 &lt;code&gt;Ipv4Instance&lt;/code&gt; 几个主要的操作（其它两个类类似就不再分析）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ipv4Instance&lt;/code&gt; 的类里有个私有结构体 &lt;code&gt;IpHelper&lt;/code&gt; 。这结构体封装着 &lt;code&gt;IPV4&lt;/code&gt; 地址的具体内容，比如端口，版本等&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;struct IpHelper : public Ip {
  const std::string&amp;amp; addressAsString() const override { return friendly_address_; }
  bool isAnyAddress() const override { return ipv4_.address_.sin_addr.s_addr == INADDR_ANY; }
  bool isUnicastAddress() const override {
  return !isAnyAddress() &amp;amp;&amp;amp; (ipv4_.address_.sin_addr.s_addr != INADDR_BROADCAST) &amp;amp;&amp;amp;
             // inlined IN_MULTICAST() to avoid byte swapping
             !((ipv4_.address_.sin_addr.s_addr &amp;amp; htonl(0xf0000000)) == htonl(0xe0000000));
  }
  const Ipv4* ipv4() const override { return &amp;amp;ipv4_; }
  const Ipv6* ipv6() const override { return nullptr; }
  uint32_t port() const override { return ntohs(ipv4_.address_.sin_port); }
  IpVersion version() const override { return IpVersion::v4; }

  Ipv4Helper ipv4_;
  std::string friendly_address_;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;bind()&lt;/code&gt;，&lt;code&gt;socket()&lt;/code&gt; 和 &lt;code&gt;connect()&lt;/code&gt; 基本都是直接调的底层函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Api::SysCallIntResult Ipv6Instance::bind(int fd) const {
  const int rc = ::bind(fd, reinterpret_cast&amp;lt;const sockaddr*&amp;gt;(&amp;amp;ip_.ipv6_.address_),
                        sizeof(ip_.ipv6_.address_));
  return {rc, errno};
}

Api::SysCallIntResult Ipv6Instance::connect(int fd) const {
  const int rc = ::connect(fd, reinterpret_cast&amp;lt;const sockaddr*&amp;gt;(&amp;amp;ip_.ipv6_.address_),
                           sizeof(ip_.ipv6_.address_));
  return {rc, errno};
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;dns&quot;&gt;DNS&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;DNS&lt;/code&gt; 使用 &lt;a href=&quot;https://c-ares.haxx.se/&quot;&gt;c-ares&lt;/a&gt; 作为底层库。 &lt;code&gt;c-ares&lt;/code&gt; 是个 c 实现的异步 DNS 解析库，很多知名软件（curl，Nodejs，gevent 等）都使用了该库。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c-ares&lt;/code&gt; 在构造函数内初始化库，初始化上下文，然后设置 DNS 服务器。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DnsResolverImpl::DnsResolverImpl(
    Event::Dispatcher&amp;amp; dispatcher,
    const std::vector&amp;lt;Network::Address::InstanceConstSharedPtr&amp;gt;&amp;amp; resolvers)
        : dispatcher_(dispatcher),
      timer_(dispatcher.createTimer([this] { onEventCallback(ARES_SOCKET_BAD, 0); })) {
  //初始化库
  ares_library_init(ARES_LIB_INIT_ALL);
  ares_options options;
  //初始化上下文
  initializeChannel(&amp;amp;options, 0);
  ... ...
  const std::string resolvers_csv = StringUtil::join(resolver_addrs, &quot;,&quot;);
  //设置 DNS 服务器
  int result = ares_set_servers_ports_csv(channel_, resolvers_csv.c_str());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用时直接 &lt;code&gt;resolve()&lt;/code&gt; 结果返回在 callback 里。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ActiveDnsQuery* DnsResolverImpl::resolve(const std::string&amp;amp; dns_name,
                                         DnsLookupFamily dns_lookup_family, ResolveCb callback) {
  ... ...
  if (dns_lookup_family == DnsLookupFamily::V4Only) {
    pending_resolution-&amp;gt;getHostByName(AF_INET);
  } else {
    pending_resolution-&amp;gt;getHostByName(AF_INET6);
  }
  ... ...
}

void DnsResolverImpl::PendingResolution::getHostByName(int family) {
  ares_gethostbyname(channel_, dns_name_.c_str(), family,
                     [](void* arg, int status, int timeouts, hostent* hostent) {
                       static_cast&amp;lt;PendingResolution*&amp;gt;(arg)-&amp;gt;onAresHostCallback(status, timeouts, hostent);
                     },
                     this);
}

void DnsResolverImpl::PendingResolution::onAresHostCallback(int status, int timeouts, hostent* hostent) {

  ... ...
  //解析内容加入address_list
  std::list&amp;lt;Address::InstanceConstSharedPtr&amp;gt; address_list;
  if (status == ARES_SUCCESS) {
    if (hostent-&amp;gt;h_addrtype == AF_INET) {
      for (int i = 0; hostent-&amp;gt;h_addr_list[i] != nullptr; ++i) {
        ASSERT(hostent-&amp;gt;h_length == sizeof(in_addr));
        sockaddr_in address;
        memset(&amp;amp;address, 0, sizeof(address));
        address.sin_family = AF_INET;
        address.sin_port = 0;
        address.sin_addr = *reinterpret_cast&amp;lt;in_addr*&amp;gt;(hostent-&amp;gt;h_addr_list[i]);
        address_list.emplace_back(new Address::Ipv4Instance(&amp;amp;address));
      }
      ... ...
  }

  if (completed_) {
    if (!cancelled_) {
      try {
        //调用回调
        callback_(std::move(address_list));
      } catch (const EnvoyException&amp;amp; e) {
      ... ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;cidr&quot;&gt;cidr&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;cidr&lt;/code&gt; 的定义是形如 192.168.0.1/24 的 IP 段。想知道具体的定义和 IP 段 可看 &lt;a href=&quot;https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing&quot;&gt;cidr&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CidrRange&lt;/code&gt; 将 &lt;code&gt;cidr&lt;/code&gt; 拆分成两字段地址和长度。下面是判断地址是否属于这个 IP 段。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bool CidrRange::isInRange(const Instance&amp;amp; address) const {
  ... ...
  //长度为0，全匹配（length_初始值为-1）
  if (length_ == 0) {
    return true;
  }

  switch (address.ip()-&amp;gt;version()) {
  case IpVersion::v4:
    if (ntohl(address.ip()-&amp;gt;ipv4()-&amp;gt;address()) &amp;gt;&amp;gt; (32 - length_) ==
        ntohl(address_-&amp;gt;ip()-&amp;gt;ipv4()-&amp;gt;address()) &amp;gt;&amp;gt; (32 - length_)) {
      return true;
    }
    break;
  case IpVersion::v6:
    if ((Utility::Ip6ntohl(address_-&amp;gt;ip()-&amp;gt;ipv6()-&amp;gt;address()) &amp;gt;&amp;gt; (128 - length_)) ==
        (Utility::Ip6ntohl(address.ip()-&amp;gt;ipv6()-&amp;gt;address()) &amp;gt;&amp;gt; (128 - length_))) {
      return true;
    }
    break;
  }
  return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;socket&quot;&gt;socket&lt;/h2&gt;
&lt;p&gt;我们都知道，创建 TCP 服务时，监听的 fd 和连接的 fd 是不一样的，因此 &lt;code&gt;socket&lt;/code&gt; 分为 &lt;code&gt;ListenSocket&lt;/code&gt; 和 &lt;code&gt;ConnectionSocket&lt;/code&gt;。&lt;code&gt;socket&lt;/code&gt; 里有很多的配置（比如读超时，写超时等）都是调用&lt;code&gt;setsockopt&lt;/code&gt;，所有需要一个 &lt;code&gt;Option&lt;/code&gt; 来进行统一的封装。&lt;/p&gt;
&lt;h3 id=&quot;option&quot;&gt;Option&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Option&lt;/code&gt; 是对 &lt;code&gt;setsockopt&lt;/code&gt; 这个函数操作的封装。封装后再用智能指针的方式进行操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef std::shared_ptr&amp;lt;const Option&amp;gt; OptionConstSharedPtr;
typedef std::vector&amp;lt;OptionConstSharedPtr&amp;gt; Options;
typedef std::shared_ptr&amp;lt;Options&amp;gt; OptionsSharedPtr;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Option&lt;/code&gt; 在全部设置完后，在 &lt;code&gt;applyOptions&lt;/code&gt;后，最终还是调用 &lt;code&gt;setsockopt&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static bool applyOptions(const OptionsSharedPtr&amp;amp; options, Socket&amp;amp; socket,
                       envoy::api::v2::core::SocketOption::SocketState state) {
  if (options == nullptr) {
    return true;
  }
  for (const auto&amp;amp; option : *options) {
    //对所有的option 进行设置
    if (!option-&amp;gt;setOption(socket, state)) {
      return false;
    }
  }
  return true;
}

bool SocketOptionImpl::setOption(Socket&amp;amp; socket,
                                 envoy::api::v2::core::SocketOption::SocketState state) const {
  if (in_state_ == state) {
    //调用成员函数 setSocketOption
    const Api::SysCallIntResult result = SocketOptionImpl::setSocketOption(socket, optname_, value_);
  ... ...
  return true;
}

Api::SysCallIntResult SocketOptionImpl::setSocketOption(Socket&amp;amp; socket, Network::SocketOptionName optname, const absl::string_view value) {
  ... ...
  //最终调用系统函数setsockopt
  return os_syscalls.setsockopt(socket.ioHandle().fd(), optname.value().first,
                                optname.value().second, value.data(), value.size());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;socket-1&quot;&gt;Socket&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Socket&lt;/code&gt; 提供基本的 socket 操作。主要是 'Option' 操作（上面已分析过）和地址操作。代码比较简单。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//设置和获取本地地址
const Address::InstanceConstSharedPtr&amp;amp; localAddress() const override { return local_address_; }
void setLocalAddress(const Address::InstanceConstSharedPtr&amp;amp; local_address) override {
  local_address_ = local_address;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;listensocket&quot;&gt;ListenSocket&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ListenSocket&lt;/code&gt; 是对监听 fd 的封装，继承自 &lt;code&gt;Socket&lt;/code&gt;。主要操作自然就是 &lt;code&gt;bind()&lt;/code&gt;。bind 调用自地址类的 bind() 函数（看上面的 address）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void ListenSocketImpl::doBind() {
  // 地址和handle 继承自socket。调用地址类的 bind。
  const Api::SysCallIntResult result = local_address_-&amp;gt;bind(io_handle_-&amp;gt;fd());
  if (result.rc_ == -1) {
    close();
    throw SocketBindException(
        fmt::format(&quot;cannot bind '{}': {}&quot;, local_address_-&amp;gt;asString(), strerror(result.errno_)),
        result.errno_);
  }
  if (local_address_-&amp;gt;type() == Address::Type::Ip &amp;amp;&amp;amp; local_address_-&amp;gt;ip()-&amp;gt;port() == 0) {
    // If the port we bind is zero, then the OS will pick a free port for us (assuming there are
    // any), and we need to find out the port number that the OS picked.
    local_address_ = Address::addressFromFd(io_handle_-&amp;gt;fd());
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;connectionsocket&quot;&gt;ConnectionSocket&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ConnectionSocket&lt;/code&gt; 是对连接 fd 的封装，除了 &lt;code&gt;Socket&lt;/code&gt; 的基本操作外，还增加对远程地址和协议的设置。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//设置和获取远程地址
const Address::InstanceConstSharedPtr&amp;amp; remoteAddress() const override { return remote_address_; }
void setRemoteAddress(const Address::InstanceConstSharedPtr&amp;amp; remote_address) override {
  remote_address_ = remote_address;
}

//协议相关
void setDetectedTransportProtocol(absl::string_view protocol) override {
 transport_protocol_ = std::string(protocol);
}
absl::string_view detectedTransportProtocol() const override { return transport_protocol_; }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;transportsocket&quot;&gt;TransportSocket&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;TransportSocket&lt;/code&gt; 是一个实际读/写的传输套接字。它可以对数据进行一些转换（比如TLS，TCP代理等）。 &lt;code&gt;TransportSocket&lt;/code&gt; 提供了多个接口。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;failureReason()&lt;/code&gt; 返回最后的一个错误，没错误返回空值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;canFlushClose()&lt;/code&gt; socket 是否能刷新和关闭。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;closeSocket()&lt;/code&gt; 关闭 socket。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;doRead()&lt;/code&gt; 读取数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;doWrite()&lt;/code&gt; 写数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;onConnected()&lt;/code&gt; transport 连接时调用此函数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ssl::ConnectionInfo* ssl()&lt;/code&gt; Ssl连接数据。&lt;/p&gt;
&lt;h2 id=&quot;listen&quot;&gt;listen&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;listen&lt;/code&gt; 是对监听操作相关的类，分为 &lt;code&gt;TcpListen&lt;/code&gt; 和 &lt;code&gt;UdpListen&lt;/code&gt;。 Listen 抽象类只提供两个接口 &lt;code&gt;disable&lt;/code&gt; 和 &lt;code&gt;enable&lt;/code&gt;。 &lt;code&gt;disable&lt;/code&gt; 关闭接受新连接，&lt;code&gt;enable&lt;/code&gt;开启接受新连接。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ListenerImpl&lt;/code&gt; 实现那两接口的同时，由于它是 TCP 的监听必然就有 listen 和 accept 操作。在构造函数时，调用 setupServerSocket 创造 listen，启用回调&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void ListenerImpl::
setupServerSocket(Event::DispatcherImpl&amp;amp; dispatcher, Socket&amp;amp; socket) {
  //创建监听，完成后回调 listenCallback
  listener_.reset(
      evconnlistener_new(&amp;amp;dispatcher.base(), listenCallback, this, 0, -1, socket.ioHandle().fd()));
  ... ...
  //失败回调errorCallback
  evconnlistener_set_error_cb(listener_.get(), errorCallback);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;监听完成后，调用 listenCallback。listenCallback 用回调函数调用 onAccept 接收连接。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
void ListenerImpl::listenCallback(evconnlistener*, evutil_socket_t fd, sockaddr* remote_addr, int remote_addr_len, void* arg) {
  ListenerImpl* listener = static_cast&amp;lt;ListenerImpl*&amp;gt;(arg);

  IoHandlePtr io_handle = std::make_unique&amp;lt;IoSocketHandleImpl&amp;gt;(fd);

  // 获取本地地址
  const Address::InstanceConstSharedPtr&amp;amp; local_address =
      listener-&amp;gt;local_address_ ? listener-&amp;gt;local_address_
                               : listener-&amp;gt;getLocalAddress(io_handle-&amp;gt;fd());
  // 获取远程地址
  const Address::InstanceConstSharedPtr&amp;amp; remote_address =
      (remote_addr-&amp;gt;sa_family == AF_UNIX)
          ? Address::peerAddressFromFd(io_handle-&amp;gt;fd())
          : Address::addressFromSockAddr(*reinterpret_cast&amp;lt;const sockaddr_storage*&amp;gt;(remote_addr),
                                         remote_addr_len,
                                         local_address-&amp;gt;ip()-&amp;gt;version() == Address::IpVersion::v6);
  //调用 onAccept，
  listener-&amp;gt;cb_.onAccept(
      std::make_unique&amp;lt;AcceptedSocketImpl&amp;gt;(std::move(io_handle), local_address, remote_address),
      listener-&amp;gt;hand_off_restored_destination_connections_);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;connection&quot;&gt;connection&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;connection&lt;/code&gt; 是连接相关的操作，客户端和服务端的连接都属于这个类。 &lt;code&gt;Connection&lt;/code&gt; 是针对原始连接的一个抽象，继承自 &lt;code&gt;DeferredDeletable&lt;/code&gt; 和 &lt;code&gt;FilterManager&lt;/code&gt;。关于 &lt;code&gt;DeferredDeletable&lt;/code&gt; 延迟析构请看 &lt;a href=&quot;https://www.cnblogs.com/mathli/p/10674391.html&quot;&gt;Envoy 源码分析－－event&lt;/a&gt;，&lt;code&gt;FilterManager&lt;/code&gt; 以后讨论。&lt;/p&gt;
&lt;h3 id=&quot;connectionimpl&quot;&gt;ConnectionImpl&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ConnectionImpl&lt;/code&gt; 是 &lt;code&gt;Connection&lt;/code&gt;，&lt;code&gt;BufferSource&lt;/code&gt; 和 &lt;code&gt;TransportSocketCallbacks&lt;/code&gt; 三个抽象类的实现类。&lt;code&gt;Connection&lt;/code&gt; 是连接操作相关的类，&lt;code&gt;BufferSource&lt;/code&gt; 是获得 StreamBuffer 的抽象类（包括读和写），&lt;code&gt;TransportSocketCallbacks&lt;/code&gt; 是传输套接字实例与连接进行通信的回调。&lt;/p&gt;
&lt;p&gt;每个 &lt;code&gt;ConnectionImpl&lt;/code&gt; 实例都有一个唯一的全局ID。在构造时赋值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;std::atomic&amp;lt;uint64_t&amp;gt; ConnectionImpl::next_global_id_;

ConnectionImpl::ConnectionImpl(Event::Dispatcher&amp;amp; dispatcher, ConnectionSocketPtr&amp;amp;&amp;amp; socket, TransportSocketPtr&amp;amp;&amp;amp; transport_socket, bool connected) : id_(next_global_id_++) {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ConnectionImpl&lt;/code&gt; 事件由 &lt;code&gt;dispatcher_&lt;/code&gt; 创建。在构造函数时创建事件。&lt;br/&gt;Event 使用边缘触发，减少内核通知，提高效率（水平触发和边缘触发区别大家自己查阅相关文档）。同时写入读写事件。当有读写事件时，会触发回调 &lt;code&gt;onFileEvent&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ConnectionImpl::ConnectionImpl(Event::Dispatcher&amp;amp; dispatcher, ConnectionSocketPtr&amp;amp;&amp;amp; socket,TransportSocketPtr&amp;amp;&amp;amp; transport_socket, bool connected) {
  ... ...
  file_event_ = dispatcher_.createFileEvent(
      ioHandle().fd(), [this](uint32_t events) -&amp;gt; void { onFileEvent(events); },
      Event::FileTriggerType::Edge, Event::FileReadyType::Read | Event::FileReadyType::Write);
  ... ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;onFileEvent&lt;/code&gt; 在收到事件后，对不同的事件进行不同的处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void ConnectionImpl::onFileEvent(uint32_t events) {
  ... ...
  // 写事件
  if (events &amp;amp; Event::FileReadyType::Write) {
    onWriteReady();
  }

  // 读事件
  if (ioHandle().isOpen() &amp;amp;&amp;amp; (events &amp;amp; Event::FileReadyType::Read)) {
    onReadReady();
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于读事件，在连接调用 &lt;code&gt;readDisable&lt;/code&gt; 后，如果是 enable 会触发读事件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void ConnectionImpl::readDisable(bool disable) {
    ... ...
    read_enabled_ = true;
    file_event_-&amp;gt;setEnabled(Event::FileReadyType::Read | Event::FileReadyType::Write);
    if (read_buffer_.length() &amp;gt; 0) {
      file_event_-&amp;gt;activate(Event::FileReadyType::Read);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;读事件调用 &lt;code&gt;onReadReady&lt;/code&gt;，&lt;code&gt;onReadReady&lt;/code&gt; 先从 buffer中读取数据，同时更新统计数据。对返回的结果进行分析，已关闭直接关闭。正常读到数据，判断是否有数据，有数据会调用 &lt;code&gt;onRead&lt;/code&gt;, &lt;code&gt;onRead&lt;/code&gt; 内会调用 ReadFilter 进行下一步处理（L3/4过滤下次分析）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void ConnectionImpl::onReadReady() {
  ... ...
  IoResult result = transport_socket_-&amp;gt;doRead(read_buffer_);
  uint64_t new_buffer_size = read_buffer_.length();
  updateReadBufferStats(result.bytes_processed_, new_buffer_size);

  if ((!enable_half_close_ &amp;amp;&amp;amp; result.end_stream_read_)) {
    result.end_stream_read_ = false;
    result.action_ = PostIoAction::Close;
  }

  read_end_stream_ |= result.end_stream_read_;
  //有读到数据
  if (result.bytes_processed_ != 0 || result.end_stream_read_) 
    onRead(new_buffer_size);
  }

  // 关闭连接
  if (result.action_ == PostIoAction::Close || bothSidesHalfClosed()) {
    ENVOY_CONN_LOG(debug, &quot;remote close&quot;, *this);
    closeSocket(ConnectionEvent::RemoteClose);
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于写事件，在连接写入数据时，会将数据先进行过滤，然后写入写缓冲。之后调用写事件触发 &lt;code&gt;onFileEvent&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void ConnectionImpl::write(Buffer::Instance&amp;amp; data, bool end_stream) {
  ... ...
  // WriteFilter过滤
  current_write_buffer_ = &amp;amp;data;
  current_write_end_stream_ = end_stream;
  FilterStatus status = filter_manager_.onWrite();
  current_write_buffer_ = nullptr;

  if (FilterStatus::StopIteration == status) {
    return;
  }

  write_end_stream_ = end_stream;
  if (data.length() &amp;gt; 0 || end_stream) {
    // 写入缓冲
    write_buffer_-&amp;gt;move(data);
    if (!connecting_) {
      //触发写事件
      file_event_-&amp;gt;activate(Event::FileReadyType::Write);
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在写入事件后会调用 &lt;code&gt;onWriteReady&lt;/code&gt;。 &lt;code&gt;onWriteReady&lt;/code&gt; 先判断是否已连接，未连接会调用 &lt;code&gt;connect&lt;/code&gt; 连接事件。连接成功后发送数据并统计信息，连接失败关闭 socket。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void ConnectionImpl::onWriteReady() {
  ... ...
  if (connecting_) {
    ... ...
    if (error == 0) {
      connecting_ = false;
      //socket 未连接，调用connect。
      transport_socket_-&amp;gt;onConnected();
     ... ...

  // 发送数据
  IoResult result = transport_socket_-&amp;gt;doWrite(*write_buffer_, write_end_stream_);
  uint64_t new_buffer_size = write_buffer_-&amp;gt;length();
  //更新统计信息
  updateWriteBufferStats(result.bytes_processed_, new_buffer_size);
  ... ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;clientconnectionimpl&quot;&gt;ClientConnectionImpl&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ClientConnectionImpl&lt;/code&gt; 是客户端的连接，其继承自 &lt;code&gt;ConnectionImpl&lt;/code&gt; 和 &lt;code&gt;ClientConnection&lt;/code&gt;。&lt;code&gt;ClientConnectionImpl&lt;/code&gt; 只是在 &lt;code&gt;Connection&lt;/code&gt; 的基础上只增加了一个 connect 的接口。&lt;/p&gt;
&lt;p&gt;connect 函数内最主要做的就是调用 connect() 连接。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void ClientConnectionImpl::connect() {
  // 连接服务器
  const Api::SysCallIntResult result = socket_-&amp;gt;remoteAddress()-&amp;gt;connect(ioHandle().fd());
  if (result.rc_ == 0) {
    // write will become ready.
    ASSERT(connecting_);
  } else {
  ... ...
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 15 Apr 2019 07:21:00 +0000</pubDate>
<dc:creator>mathli</dc:creator>
<og:description>[toc] Envoy 源码分析－－network 申明：本文的 Envoy 源码分析基于 Envoy1.10.0。 的服务是通用服务，因此它需要支持 和 ，同时还需支持 和 两种网络协议，所以网络模</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mathli/p/10710856.html</dc:identifier>
</item>
<item>
<title>图解选择排序与插入排序 - 9龙</title>
<link>http://www.cnblogs.com/9dragon/p/10710735.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/9dragon/p/10710735.html</guid>
<description>&lt;div class=&quot;output_wrapper&quot; id=&quot;output_wrapper_id&quot; readability=&quot;26.86015729906&quot;&gt;
&lt;p&gt;上一篇详述了冒泡排序及其优化，有兴趣的可以看看：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/9dragon/p/10705097.html&quot;&gt;如何优化冒泡排序？&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;hselectionsort&quot;&gt;&lt;span&gt;一、选择排序（SelectionSort）&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;算法思想&lt;/strong&gt;：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;排序过程&lt;/strong&gt;：（默认升序）&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;span&gt;从原序列中找到最小值，与数组第一个元素交换；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;除第一个元素外，从剩下未排序的序列中找到最小值，与数组第二个元素交换；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;共N-1趟，每趟都找到未排序的最小值，放到已排序的序列后面。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1603499/201904/1603499-20190415152320602-1758861163.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;如图所示，每一趟找到未排序的最小值，并放到有序序列的后面（即当前趟对应于数组中的第几个元素）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;java实现选择排序&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &amp;lt;T extends Comparable&amp;lt;? &lt;span class=&quot;hljs-keyword&quot;&gt;super&lt;/span&gt; T&amp;gt;&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;selectionSort&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(T[] nums)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt; == nums || nums.length == &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;hljs-string&quot;&gt;&quot;数组为null或长度为0&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; length = nums.length;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; minValueIndex = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;br/&gt;T temp = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; length - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; i++) {&lt;br/&gt;minValueIndex = i;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; j = i + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; j &amp;lt; length; j++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (nums[j].compareTo(nums[minValueIndex]) &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) {&lt;br/&gt;minValueIndex = j;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (minValueIndex != i) {&lt;br/&gt;temp = nums[i];&lt;br/&gt;nums[i] = nums[minValueIndex];&lt;br/&gt;nums[minValueIndex] = temp;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;时间、空间复杂度及稳定性分析：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;最好时间复杂度：最好情况是输入序列已经升序排列，需要比较n*(n-1)/2次，但不需要交换元素，即交换次数为：0；所以&lt;strong&gt;最好时间复杂度&lt;/strong&gt;为&lt;strong&gt;O(n^2)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;最坏时间复杂度：最坏情况是输入序列是逆序的，则每一趟都需要交换。即需要比较n*(n-1)/2次，元素交换次数为：n-1次。所以&lt;strong&gt;最坏时间复杂度&lt;/strong&gt;还是&lt;strong&gt;O(n^2)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;平均时间复杂度：O(n^2)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;空间复杂度：只用到一个临时变量，所以&lt;strong&gt;空间复杂度&lt;/strong&gt;为&lt;strong&gt;O(1)&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;稳定性：&lt;strong&gt;不稳定&lt;/strong&gt;排序。如序列3，5，3，1。第一次交换结果为1，5，3，3，我们发现原序列的第一个3排在了第二个3的后面。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;hinsertsort&quot;&gt;&lt;span&gt;二、插入排序（InsertSort）&lt;/span&gt;&lt;/h3&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;算法思想&lt;/strong&gt;：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;strong&gt;排序过程：&lt;/strong&gt;（默认升序）&lt;/p&gt;
&lt;p&gt;InsertionSort 和打扑克牌时，从牌桌上逐一拿起扑克牌，在手上排序的进程相同。&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;p&gt;Input: {4, 3, 8, 5, 2, 6, 1, 7}。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ol readability=&quot;6&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;首先拿起第一张牌, 手上有 {4}。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;拿起第二张牌 3, 把 3insert 到手上的牌 {4}, 得到 {3 ，4}。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;拿起第三张牌 8, 把 8 insert 到手上的牌 {3，4 }, 得到 {3 ，4，8}。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;以此类推。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;插入排序由N-1趟排序组成&lt;/strong&gt;。对于p=1到N-1趟排序后，插入排序保证从位置0到位置p上的元素为已排序状态。即&lt;strong&gt;插入排序利用了从位置0到p-1位置上已经有序&lt;/strong&gt;的条件，&lt;strong&gt;将位置p上的元素向前查找适当的位置插入此元素。&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/1603499/201904/1603499-20190415152333984-518044804.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;如图所示：在第p趟，我们将位置p上的元素向左移动，直到它在前p+1个元素（包括当前位置的元素）中的正确位置被找到。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;java实现插入排序&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &amp;lt;T extends Comparable&amp;lt;? &lt;span class=&quot;hljs-keyword&quot;&gt;super&lt;/span&gt; T&amp;gt;&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;insertSort&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(T[] nums)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt; == nums || nums.length == &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;hljs-string&quot;&gt;&quot;数组为null或长度为0&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; length = nums.length;&lt;br/&gt;T temp = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; p = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; p &amp;lt; length; p++) {&lt;br/&gt;temp = nums[p];&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (i = p; i &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; (temp.compareTo(nums[i - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]) &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;); i--) {&lt;br/&gt;nums[i] = nums[i - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;];&lt;br/&gt;}&lt;br/&gt;nums[i] = temp;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;时间、空间复杂度及稳定性分析：&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;最好时间复杂度：最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需n-1次即可。即&lt;strong&gt;最好时间复杂度&lt;/strong&gt;为&lt;strong&gt;O(n)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;最坏时间复杂度：最坏情况就是，序列是降序排列，那么总共需要n(n-1)/2次比较；移动次数（赋值操作）是比较次数减去n-1次（因为每一次循环的比较都比赋值多一次，共n-1次循环），即n(n-1)/2 - (n-1)；所以&lt;strong&gt;最坏时间复杂度&lt;/strong&gt;为&lt;strong&gt;O(n^2)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;平均时间复杂度：O(n^2)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;空间复杂度：只用到一个临时变量，所以&lt;strong&gt;空间复杂度&lt;/strong&gt;为&lt;strong&gt;O(1)&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;稳定性：&lt;strong&gt;稳定。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;h&quot;&gt;&lt;span&gt;三、总结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;​ &lt;strong&gt;选择排序&lt;/strong&gt;的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。&lt;strong&gt;选择排序每次交换一对元素&lt;/strong&gt;，它们当中至少有一个将被移到其最终位置上，因此对n个元素的表进行排序总共进行n-1次交换。&lt;strong&gt;在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。选择排序最好、最坏时间复杂度都为O(n^2)，空间复杂度为O(1)，属于不稳定排序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;插入排序&lt;/strong&gt;不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千；或者若已知输入元素大致上按照顺序排列，那么插入排序还是一个不错的选择。&lt;strong&gt;插入排序最好时间复杂度为O(n)、最坏时间复杂度为O(n^2)，空间复杂度为O(1)，属于稳定排序。&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 15 Apr 2019 07:06:00 +0000</pubDate>
<dc:creator>9龙</dc:creator>
<og:description>上一篇详述了冒泡排序及其优化，有兴趣的可以看看： 如何优化冒泡排序？ 一、选择排序（SelectionSort） 算法思想：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/9dragon/p/10710735.html</dc:identifier>
</item>
<item>
<title>iOS面试题：反射是什么？可以举出几个应用场景么？ - G_猿员</title>
<link>http://www.cnblogs.com/zhuzi12345/p/10710714.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuzi12345/p/10710714.html</guid>
<description>&lt;p&gt;系统Foundation框架为我们提供了一些方法反射的API，我们可以通过这些API执行将字符串转为SEL等操作。由于OC语言的动态性，这些操作都是发生在运行时的。&lt;/p&gt;
&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;通过这些方法，我们可以在运行时选择创建那个实例，并动态选择调用哪个方法。这些操作甚至可以由服务器传回来的参数来控制，我们可以将服务器传回来的类名和方法名，实例为我们的对象。&lt;/p&gt;
&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;反射机制使用技巧&lt;/p&gt;
&lt;p&gt;假设有一天公司产品要实现一个需求：根据后台推送过来的数据，进行动态页面跳转，跳转到页面后根据返回到数据执行对应的操作。&lt;/p&gt;
&lt;p&gt;遇到这样奇葩的需求，我们当然可以问产品都有哪些情况执行哪些方法，然后写一大堆if else判断或switch判断。&lt;br/&gt;但是这种方法实现起来太low了，而且不够灵活，假设后续版本需求变了，还要往其他已有页面中跳转，这不就傻眼了吗....&lt;br/&gt;这种情况反射机制就派上用场了，我们可以用反射机制动态的创建类并执行方法。当然也可以通过runtime来实现这个功能，但是我们当前需求反射机制已经足够满足需求了，如果遇到更加复杂的需求可以考虑用runtime来实现。&lt;br/&gt;这时候就需要和后台配合了，我们首先需要和后台商量好返回的数据结构，以及数据格式、类型等，返回后我们按照和后台约定的格式，根据后台返回的信息，直接进行反射和调用即可。&lt;/p&gt;
&lt;p&gt;假设和后台约定格式如下：&lt;/p&gt;
&lt;pre class=&quot;hljs ruby&quot;&gt;
&lt;code class=&quot;ruby&quot;&gt;@{
     &lt;span class=&quot;hljs-regexp&quot;&gt;// 类名
     @&lt;span class=&quot;hljs-string&quot;&gt;&quot;className&quot; : @&lt;span class=&quot;hljs-string&quot;&gt;&quot;UserListViewController&quot;, 
     &lt;span class=&quot;hljs-regexp&quot;&gt;// 数据参数
     @&lt;span class=&quot;hljs-string&quot;&gt;&quot;propertys&quot; : @{ @&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;: @&lt;span class=&quot;hljs-string&quot;&gt;&quot;liuxiaozhuang&quot;, 
                       @&lt;span class=&quot;hljs-string&quot;&gt;&quot;age&quot;: @3 },
     &lt;span class=&quot;hljs-regexp&quot;&gt;// 调用方法名
     @&lt;span class=&quot;hljs-string&quot;&gt;&quot;method&quot; : @&lt;span class=&quot;hljs-string&quot;&gt;&quot;refreshUserInformation&quot;
 };

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义一个UserListViewController类，这个类用于测试，在实际使用中可能会有多个这样的控制器类。&lt;/p&gt;
&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#import &lt;span class=&quot;hljs-meta-string&quot;&gt;&amp;lt;UIKit/UIKit.h&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面通过反射机制简单实现了控制器跳转的方法，在实际使用中再根据业务需求进行修改即可。因为这篇文章主要是讲反射机制，所以没有使用runtime代码。&lt;/p&gt;
&lt;p&gt;简单封装的页面跳转方法，只是做演示，代码都是没问题的，使用时可以根据业务需求进行修改。&lt;/p&gt;
&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;&gt;- (&lt;span class=&quot;hljs-keyword&quot;&gt;void)remoteNotificationDictionary:(&lt;span class=&quot;hljs-built_in&quot;&gt;NSDictionary *)dict {
    &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code class=&quot;objectivec&quot;&gt; ***&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更多：&lt;a href=&quot;https://www.jianshu.com/p/c4ec36af8dad&quot; target=&quot;_blank&quot;&gt;iOS面试题大全&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 15 Apr 2019 07:04:00 +0000</pubDate>
<dc:creator>G_猿员</dc:creator>
<og:description>系统Foundation框架为我们提供了一些方法反射的API，我们可以通过这些API执行将字符串转为SEL等操作。由于OC语言的动态性，这些操作都是发生在运行时的。 通过这些方法，我们可以在运行时选择</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhuzi12345/p/10710714.html</dc:identifier>
</item>
<item>
<title>数据库连接池原理分析及模拟实现 - 梓&amp;艺</title>
<link>http://www.cnblogs.com/love-wzy/p/10710183.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/love-wzy/p/10710183.html</guid>
<description>&lt;p&gt;&lt;strong&gt;数据库访问&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ 访问数据库主要有以下几个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;加载数据库驱动&lt;/li&gt;
&lt;li&gt;创建数据库连接&lt;/li&gt;
&lt;li&gt;执行访问操作并处理执行结果&lt;/li&gt;
&lt;li&gt;关闭连接，释放资源&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;​ 在每一次请求数据库都要经历上述过程，创建连接和释放资源也都是些重复性的动作，当请求量比较大时，资源是个很大的浪费。如何优化呢，可以使用连接池。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;连接池&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原理分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ 数据库连接是访问数据库必须的，可以在系统初始化时提前创建一定数量的连接，保存起来，当有创建连接的请求过来时，就直接拿出来，标记为使用中(避免与其他请求拿到同一个)，使用完后，再放回连接池中。过程如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1570156/201904/1570156-20190415133839534-2046245566.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;系统在启动时初始化连接池；&lt;/li&gt;
&lt;li&gt;向连接池请求可用的数据库连接；&lt;/li&gt;
&lt;li&gt;如果没有获取到可用的数据库连接，并且连接池中连接的数量小于最大连接数，则按照规定的步长给连接池中添加连接，然后再获取，如果连接池中的数量已经到了最大连接数还没有获取到可用的连接，则等待其他请求释放了连接后再获取；&lt;/li&gt;
&lt;li&gt;使用获取到的数据库连接请求数据库；&lt;/li&gt;
&lt;li&gt;将数据库连接放回连接池，供其他连接使用；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;简单模拟实现&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 连接池对象
 */
public class Pool {

    private String driver = null;//数据库驱动
    private String url = null;//连接地址
    private String username = null;//用户
    private String password = null;//密码

    //初始化连接数
    private static int initSize = 2;
    //池中最大连接数
    private static int maxSize = 5;
    //每次创建的连接数
    private static int stepSize = 2;
    //超时时间
    private static int timeout = 2000;

    //用来保存创建的数据库连接
    private List&amp;lt;PooledConnection&amp;gt; connectionPool = new ArrayList&amp;lt;PooledConnection&amp;gt;();

    private Lock lock = new ReentrantLock();

    public Pool(String driver, String url, String username, String password) throws Exception {
        this.driver = driver;
        this.url = url;
        this.username = username;
        this.password = password;

        //创建连接池时初始化initSize个数据库连接放入池中
        resizePool(initSize);
    }

    /**
     * 初始化连接池
     * @param num 初始时按照initSize给池中添加连接，其他时候按照stepSize给池中加
     */
    private void resizePool(int num) throws Exception {
        //池中现有的连接数
        int currentNum = connectionPool.size();
        //池中的连接数不能超过设置的最大连接数
        if (maxSize &amp;lt; currentNum + num) {
            num = maxSize - currentNum;
        }
        //创建连接放入池中
        for(int i=0; i&amp;lt;num; i++){
            PooledConnection conn = newPooledConnection();
            connectionPool.add(conn);
        }
    }

    /**
     * 创建连接池中的连接对象，包含了状态（忙、闲）
     * @return
     */
    private PooledConnection newPooledConnection() throws Exception {
        Connection conn = createConnection();//数据库连接
        PooledConnection pconn = new PooledConnection(conn);//连接池中的连接
        return pconn;
    }

    /**
     * 创建数据库连接
     * @return
     * @throws SQLException
     */
    private Connection createConnection() throws Exception {
        //加载驱动
        this.getClass().getClassLoader().loadClass(driver);
        //创建连接
        Connection conn = null;
        conn = DriverManager.getConnection(url, username, password);
        return conn;
    }

    /**
     * 获取数据库连接
     * @return
     */
    public synchronized Connection getConnection() throws Exception {
        Connection conn = null;
        //从连接池中获取连接
        if(connectionPool.size() &amp;gt; 0){
            //获取一个空闲的数据库连接
            conn = getFreeConnFromPool();
            //没有获取到连接
            while(conn == null){
                //隔2秒 重新获取
                System.out.println(Thread.currentThread().getName() + &quot; 等待获取连接&quot;);
                Thread.sleep(2000);
                conn = getFreeConnFromPool();
            }
        }
        return conn;
    }

    /**
     * 从连接池中获取空闲的连接
     * @return
     */
    private Connection getFreeConnFromPool() throws Exception {
        Connection conn = null;
        //获取可用的连接
        conn = findAvailableConn();
        //没有获取到可用的连接
        if(conn == null){
            //重新添加数据库连接到连接池中
            resizePool(stepSize);
            //获取可用的连接
            conn = findAvailableConn();
        }
        return conn;
    }

    /**
     * 获取一个可用的连接
     * @return
     * @throws Exception
     */
    private Connection findAvailableConn() throws Exception {
        Connection conn = null;
        if(connectionPool.size() &amp;gt; 0){
            for(PooledConnection cip : connectionPool){
                if(!cip.isBusy()){
                    conn = cip.getConn();
                    cip.setBusy(true);//获取后将当前连接状态标记为 执行
                    //判断当前连接是否可用
                    if(!conn.isValid(timeout)){
                        //conn.isValid如果连接未关闭且有效，则返回true
                        //当前连接池连接的数据库连接有问题，创建一个新的数据库连接代替它
                        conn = createConnection();
                        cip.setConn(conn);
                    }
                    break;
                }
            }
        }
        return conn;
    }

    /**
     * 把连接返回连接池
     * 把连接返回给连接池就是把状态标记为‘闲’，可以让其他请求使用
     */
    public void returnConnToPool(Connection conn){
        for (PooledConnection cip : connectionPool) {
            if (cip.getConn() == conn) {
                cip.setBusy(false);//设置为空闲
                System.out.println(Thread.currentThread().getName() + &quot; 释放了连接&quot;);
                break;
            }
        }
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 连接池中的连接对象
 */
public class PooledConnection {
    //数据库连接
    private Connection conn;
    //用于标识当前数据库连接的状态 true:执行   false:空闲
    private boolean busy;

    public PooledConnection(Connection conn) {
        this.conn = conn;
    }

    // 此处省略get set方法
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class App {
    public static void main(String[] args) throws Exception {
        //创建一个连接池
        Pool pool = new Pool(&quot;com.mysql.jdbc.Driver&quot;, &quot;jdbc:mysql://localhost:3306/test&quot;,
                &quot;root&quot;, &quot;123456&quot;);
        //创建7个线程，模拟并发
        Thread[] threads = new Thread[7];
        for(int i=0;i&amp;lt;threads.length;i++){
            int t = i * 1000;
            threads[i] = new Thread(()-&amp;gt;{
                Connection conn = null;
                try {
                    conn = pool.getConnection();
                    if(conn != null){
                        System.out.println(Thread.currentThread().getName()+&quot;获取到连接 &quot;+conn);
                        Thread.sleep(3000 + t);//模拟每个连接使用时间不等
                        pool.returnConnToPool(conn);
                    }else{
                        System.out.println(Thread.currentThread().getName()+&quot; 没有获取到连接&quot;);
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }, &quot;Thread-&quot;+i);
        }

        for(Thread thread : threads){
            thread.start();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1570156/201904/1570156-20190415133922627-258597659.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 可以看出，请求数超过池中的最大数时，多余的请求会进入等待状态，等到其他的连接被释放后才会获取到连接，线程0和线程5用的同一个连接，线程1和6用的同一个连接，实现了资源的重复利用，没有在去重新创建和关闭连接，节省了完成这些工作需要的时间，提高了效率。&lt;/p&gt;
</description>
<pubDate>Mon, 15 Apr 2019 06:46:00 +0000</pubDate>
<dc:creator>梓&amp;amp;艺</dc:creator>
<og:description>数据库访问 ​ 访问数据库主要有以下几个步骤： 1. 加载数据库驱动 2. 创建数据库连接 3. 执行访问操作并处理执行结果 4. 关闭连接，释放资源 ​ 在每一次请求数据库都要经历上述过程，创建连接</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/love-wzy/p/10710183.html</dc:identifier>
</item>
<item>
<title>frp中的json模块 - MnCu</title>
<link>http://www.cnblogs.com/MnCu8261/p/10710546.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MnCu8261/p/10710546.html</guid>
<description>&lt;h3 id=&quot;预备知识&quot;&gt;预备知识&lt;/h3&gt;
&lt;p&gt;Go中的接口的数据结构可以分为两部分：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;其中一部分指向或者存储了原始数据的值&lt;/li&gt;
&lt;li&gt;另一部分指向或者存储了原始数据的类型描述符(其中包含类型，以及对应于接口中的方法)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所以大体上我们可以粗略的认为接口内部存储了原始数据的值和类型。&lt;br/&gt;更详细的可以看一下&lt;a href=&quot;https://www.cnblogs.com/MnCu8261/p/10561348.html&quot;&gt;Go数据结构-接口&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;正文&quot;&gt;正文&lt;/h3&gt;
&lt;p&gt;json模块一共三个文件，分别是 msg.go pack.go process.go，总共300行左右的代码量，虽然不多，但确实有许多较为深的点的。&lt;/p&gt;
&lt;p&gt;三个文件一起看，总共就一个接口一个结构体。&lt;/p&gt;
&lt;p&gt;接口是&lt;code&gt;Message&lt;/code&gt;，一个空接口没啥好看的。&lt;/p&gt;
&lt;p&gt;再来看结构体&lt;code&gt;MsgCtl&lt;/code&gt;以及其生成函数：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type MsgCtl struct {
    typeMap     map[byte]reflect.Type
    typeByteMap map[reflect.Type]byte

    maxMsgLength int64
}

func NewMsgCtl() *MsgCtl {
    return &amp;amp;MsgCtl{
        typeMap:      make(map[byte]reflect.Type),
        typeByteMap:  make(map[reflect.Type]byte),
        maxMsgLength: defaultMaxMsgLength,
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;感觉似乎也很简单，两个&lt;code&gt;map&lt;/code&gt;一个整型。&lt;code&gt;MsgCtl&lt;/code&gt;有很多方法，比较简单的像:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// 注册，注意这里看出typeMap和typeByteMap是相互对应的。而且容量只有256个
func (msgCtl *MsgCtl) RegisterMsg(typeByte byte, msg interface{}) {
    msgCtl.typeMap[typeByte] = reflect.TypeOf(msg)
    msgCtl.typeByteMap[reflect.TypeOf(msg)] = typeByte
}

func (msgCtl *MsgCtl) SetMaxMsgLength(length int64) {
    msgCtl.maxMsgLength = length
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分别是向map中填充数据以及设置唯一的整型字段的值。&lt;/p&gt;
&lt;p&gt;剩余的几个方法最重要的就是&lt;code&gt;Pack&lt;/code&gt;和&lt;code&gt;readMsg&lt;/code&gt;和&lt;code&gt;unpack&lt;/code&gt;这三个方法，其余的都是添头了。&lt;br/&gt;先来看一下&lt;code&gt;Pack&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (msgCtl *MsgCtl) Pack(msg Message) ([]byte, error) {
    // 1
    typeByte, ok := msgCtl.typeByteMap[reflect.TypeOf(msg).Elem()]
    if !ok {
        return nil, ErrMsgType
    }
    
    // 2
    content, err := json.Marshal(msg)
    if err != nil {
        return nil, err
    }

    // 3
    buffer := bytes.NewBuffer(nil)
    buffer.WriteByte(typeByte)
    binary.Write(buffer, binary.BigEndian, int64(len(content)))
    buffer.Write(content)
    return buffer.Bytes(), nil
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;获取msg的结构体类型以及其对应'标示字节(就是typeByteMap键值对中的值)'，首先一般来说：msg参数中的类型一般是一个结构体实例的指针类型，所以&lt;code&gt;reflect.TypeOf(msg).Elem()&lt;/code&gt;返回的是这个结构体类型&lt;/li&gt;
&lt;li&gt;解析为json&lt;/li&gt;
&lt;li&gt;先将标示字节写入，然后将json的长度按大端写入，最后将json写入&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;来看一下&lt;code&gt;readMsg&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (msgCtl *MsgCtl) readMsg(c io.Reader) (typeByte byte, buffer []byte, err error) {
    // 1
    buffer = make([]byte, 1)
    _, err = c.Read(buffer)
    if err != nil {
        return
    }
    typeByte = buffer[0]
    if _, ok := msgCtl.typeMap[typeByte]; !ok {
        err = ErrMsgType
        return
    }
    
    // 2
    var length int64
    err = binary.Read(c, binary.BigEndian, &amp;amp;length)
    if err != nil {
        return
    }
    if length &amp;gt; msgCtl.maxMsgLength {
        err = ErrMaxMsgLength
        return
    } else if length &amp;lt; 0 {
        err = ErrMsgLength
        return
    }

    // 3
    buffer = make([]byte, length)
    n, err := io.ReadFull(c, buffer)
    if err != nil {
        return
    }

    if int64(n) != length {
        err = ErrMsgFormat
    }
    return
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看完&lt;code&gt;Pack&lt;/code&gt;方法后，再看这个就不难理解了。这个方法基本上就是三步走：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;消息的第一个字节表示消息类型，读取后检测这个消息类型是否是合法的(是否被注册过)&lt;/li&gt;
&lt;li&gt;消息的第二个和第三个字节表示数据长度，读出来后检测该长度是否有效&lt;/li&gt;
&lt;li&gt;知道了长度后，就把对应长度的数据读出来放到buffer中&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所以&lt;code&gt;Pack&lt;/code&gt;后的数据一般需要&lt;code&gt;readMsg&lt;/code&gt;来读取。&lt;/p&gt;
&lt;p&gt;接下来再看&lt;code&gt;unpack&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (msgCtl *MsgCtl) unpack(typeByte byte, buffer []byte, msgIn Message) (msg Message, err error) {
    if msgIn == nil {
        t, ok := msgCtl.typeMap[typeByte]
        if !ok {
            err = ErrMsgType
            return
        }

        msg = reflect.New(t).Interface().(Message)
    } else {
        msg = msgIn
    }

    err = json.Unmarshal(buffer, &amp;amp;msg)
    return
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;unpack&lt;/code&gt;一般是将&lt;code&gt;readMsg&lt;/code&gt;读取的数据加以处理得到其对应的结构。这个方法有些东西，一开始看的我一脸懵逼，主要是对Go中的反射reflect不熟，后来看了看这个&lt;a href=&quot;https://segmentfault.com/a/1190000006190038&quot;&gt;Go 语言反射三定律&lt;/a&gt;，我才了解了这些东西。首先&lt;code&gt;msgIn&lt;/code&gt;肯定是一个&lt;code&gt;Message&lt;/code&gt;接口类型的对象，假如其是nil的话，那我们根据&lt;code&gt;typeByte&lt;/code&gt;找出对应的类型，然后就是复杂的这一句了:&lt;br/&gt;&lt;code&gt;msg = reflect.New(t).Interface().(Message)&lt;/code&gt;，&lt;code&gt;t&lt;/code&gt;是一个&lt;code&gt;reflect.Type&lt;/code&gt;类型的接口实例，&lt;code&gt;reflect.New(t)&lt;/code&gt;则会返回一个&lt;code&gt;reflect.Value&lt;/code&gt;类型的结构体实例，&lt;strong&gt;但注意：这个Value的类型是&lt;code&gt;t&lt;/code&gt;的原始类型的指针类型，值则是该类型的零值&lt;/strong&gt;，&lt;code&gt;reflect.New(t).Interface()&lt;/code&gt;会将&lt;code&gt;reflect.Value&lt;/code&gt;这个实例中真正对应的值以及其指针类型转换为空接口然后返回，紧接着后面又跟了&lt;code&gt;.(Message)&lt;/code&gt;将空接口转换为&lt;code&gt;Message&lt;/code&gt;空接口。绕了这么一大圈，我们知道：现在&lt;code&gt;msg&lt;/code&gt;接口中两部分中值是&lt;code&gt;t&lt;/code&gt;原始类型的零值，类型是&lt;code&gt;t&lt;/code&gt;原始类型的指针类型。&lt;/p&gt;
&lt;p&gt;最后，将buffer中的数据解析出来赋给msg，并返回。&lt;/p&gt;
&lt;p&gt;其余的方法基本上都是调用了这三个方法中的某个或者某几个&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (msgCtl *MsgCtl) UnPack(typeByte byte, buffer []byte) (msg Message, err error) {
    return msgCtl.unpack(typeByte, buffer, nil)
}

func (msgCtl *MsgCtl) ReadMsg(c io.Reader) (msg Message, err error) {
    typeByte, buffer, err := msgCtl.readMsg(c)
    if err != nil {
        return
    }
    return msgCtl.UnPack(typeByte, buffer)
}

func (msgCtl *MsgCtl) WriteMsg(c io.Writer, msg interface{}) (err error) {
    buffer, err := msgCtl.Pack(msg)
    if err != nil {
        return
    }

    if _, err = c.Write(buffer); err != nil {
        return
    }
    return nil
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在外层我们基本上只用&lt;code&gt;ReadMsg&lt;/code&gt;和&lt;code&gt;WriteMsg&lt;/code&gt;来读取数据就可以了。&lt;/p&gt;
&lt;h3 id=&quot;用法&quot;&gt;用法&lt;/h3&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    jsonMsg &quot;github.com/fatedier/golib/msg/json&quot;
)

const (
    TypeMsgOne = '1'
    TypeMsgTwo = '2'
)

var msgTypeMap = map[byte]interface{}{
    TypeMsgOne: MsgOne{},
    TypeMsgTwo: MsgTwo{},
}

var msgCtl *jsonMsg.MsgCtl


type MsgOne struct {}

type MsgTwo struct {}

type EchoWriter struct {}

func (EchoWriter)Write(p []byte) (n int, err error) {
    fmt.Println(p)
    fmt.Println(string(p))
    return len(p), nil
}

func init() {
    msgCtl = jsonMsg.NewMsgCtl()
    for typeByte, msg := range msgTypeMap {
        msgCtl.RegisterMsg(typeByte, msg)
    }
}

func main() {
    msgCtl.WriteMsg(EchoWriter{}, &amp;amp;MsgOne{})

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行后结果是&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;[49 0 0 0 0 0 0 0 2 123 125]
1{}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先是字节49：表示字符串1；然后是占了8个字节的0 0 0 0 0 0 0 2：表示长度2；最后是字节123和125：对应花括号{}。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;整体来看json模块就是对结构体编解码处理，本质上和go官方的json模块无区别。详细的说该json模块提供了对特定的(被注册的)结构体(一般是结构体，当然其他的也可以。)的存储或者传输(可以理解为读取写入buffer)的&lt;strong&gt;处理&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;接上一点：其写处理方式则是将该结构体类型对应的byte、该结构体json序列化后的长度、以及该结构体编码后的字节序列按照顺序写入&lt;/li&gt;
&lt;li&gt;接上一点：其读处理方式则是将读取到的字节序列，按照写入的顺序读取并解析出来，返回给上层调用的代码。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 15 Apr 2019 06:41:00 +0000</pubDate>
<dc:creator>MnCu</dc:creator>
<og:description>预备知识 Go中的接口的数据结构可以分为两部分： 1. 其中一部分指向或者存储了原始数据的值 2. 另一部分指向或者存储了原始数据的类型描述符(其中包含类型，以及对应于接口中的方法) 所以大体上我们可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MnCu8261/p/10710546.html</dc:identifier>
</item>
<item>
<title>python高级-模块(14) - Se7eN_HOU</title>
<link>http://www.cnblogs.com/Se7eN-HOU/p/10710272.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Se7eN-HOU/p/10710272.html</guid>
<description>&lt;h3&gt;&lt;span&gt;一、python中的模块&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;有过C语言编程经验的朋友都知道在C语言中如果要引用sqrt函数，必须用语句#include &amp;lt;math.h&amp;gt;引入math.h这个头文件，否则是无法正常进行调用的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么在Python中，如果要引用一些其他的函数，该怎么处理呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在Python中有一个概念叫做模块（module），这个和C语言中的头文件以及Java中的包很类似，比如在Python中要调用sqrt函数，必须用import关键字引入math这个模块，下面就来了解一下Python中的模块。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;说的通俗点：模块就好比是工具包，要想使用这个工具包中的工具(就好比函数)，就需要导入这个模块&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;模块的概念：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;每一个以&lt;strong&gt;扩展名py&lt;/strong&gt;结尾的&lt;strong&gt;python源代码&lt;/strong&gt;文件都是一个模块&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;模块名&lt;/strong&gt;同样也是一个标识符，需要符合标识符的命名规范&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在模块中定义的&lt;strong&gt;全局变量、函数、类&lt;/strong&gt;都是提供给外界直接使用的工具&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;模块就好比工具包，要想使用这个工具包中的工具，就需要先导入这个模块&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;span&gt;二、import&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在Python中用关键字import来引入某个模块，比如要引用模块math，就可以在文件最开始的地方用import math来引入。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;import导入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;import&lt;/span&gt; 模块名1，模块名2 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;不推荐&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;说明：在导入模块时，每个导入应该独占一行（推荐）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; 模块1
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; 模块2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;导入之后&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过模块名使用模块提供的工具---&lt;strong&gt;全局变量、函数、类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;只用as指定模块的别名&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果模块的名字太长，可以使用as指定模块的别名，以方便在代码中的使用&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;import&lt;/span&gt;&lt;strong&gt; 模块名1 as&lt;/strong&gt; &lt;strong&gt;模块别名&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意：模块别名应该符合托峰值命名规范&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;为什么要加上模块名呢？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为可能存在这样一种情况：在多个模块中含有相同名称的函数，此时如果只是通过函数名来调用，解释器无法知道到底要调用哪个函数。所以如果像上述这样引入模块的时候，调用函数必须加上模块名&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;三、from … import&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;from...import导入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;如果想从某一模块中导入部分工具，就可以使用&lt;strong&gt;from...import&lt;/strong&gt;的方式&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;import模块名是一次性把模块中所有的工具全部导入，并且通过模块名/别名访问&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;从模块中导入某一个工具&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; 模块名 &lt;span&gt;import&lt;/span&gt; 工具名&lt;span&gt;#&lt;/span&gt;&lt;span&gt;可以通过as为工具指定别名&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;导入之后&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;不需要通过&lt;strong&gt;模块名.&lt;/strong&gt; 的方式使用模块提供的工具&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;可以直接使用模块提供的工具  --- 全局变量、函数、类&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;如果两个模块，存在同名的函数，name后导入模块的函数会覆盖先导入的函数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;开发时import代码应该统一写在代码的顶部，更容易及时发现冲突&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;一定大仙冲突，可以使用as关键字，给其中一个工具起一个别名&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;from...import *&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;从模块中导入所有工具&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; 模块名 &lt;span&gt;import&lt;/span&gt; *&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;这种法师不推荐使用，因为函数重名并没有任何的提示，出现问题不好排查&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;案例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;demo.py(自定义的模块)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;全局变量&lt;/span&gt;
title = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;模块1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;函数&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; say_hello():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;title)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;类&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Dog(object):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;类&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Cat(object):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;test.py中使用demo.py模块&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入模块中的所有工具，同时为模块指定别名为myTest&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; demo as myTest
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入模块中所有工具，不推荐，工具同名不好排查&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;from...import * &lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;from...import导入模块中的部分工具（Dog类）&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; demo &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Dog
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;为导入工具Cat类指定别名Test_Cat，防止与其他模块中工具重名&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; demo &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Cat as Test_Cat

myTest.say_hello()
dog&lt;/span&gt;=&lt;span&gt;Dog()
cat&lt;/span&gt;=Test_Cat()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;四、python模块导入的搜索路径&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;程序的主目录&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;PTYHONPATH目录（如果已经进行了设置）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;标准连接库目录（一般在/usr/local/lib/python2.X/）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;任何的.pth文件的内容（如果存在的话）.新功能，允许用户把有效果的目录添加到模块搜索路径中去 .pth后缀的文本文件中一行一行的地列出目录。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;这四个组建组合起来就变成了sys.path了，&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当python import模块的时候，就通过sys.path里面的目录列表下面去查找。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;sys.path是python的搜索模块的路径集，是一个list。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;查看sys.path方法：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(sys.path)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\\Users\\Se7eN_HOU\\Desktop\\Tools\\sublimetext3\\Sublime Text Build 3176 x86&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\\Program Files\\Python37\\python37.zip&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\\Program Files\\Python37\\DLLs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\\Program Files\\Python37\\lib&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\\Program Files\\Python37&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\\Users\\Se7eN_HOU\\AppData\\Roaming\\Python\\Python37\\site-packages&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\\Program Files\\Python37\\lib\\site-packages&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;程序执行时导入模块路径&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;因为sys.path是一个列表，所以可以在后面追加一个自定的模块路径&lt;/span&gt;
sys.path.append(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/home/Se7eN_HOU&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;通过insert可以将路径插到前面&lt;/span&gt;
sys.path.insert(0,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Home/Se7eN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(sys.path)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Home/Se7eN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\\Users\\Se7eN_HOU\\Desktop\\Tools\\sublimetext3\\Sublime Text Build 3176 x86&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\\Program Files\\Python37\\python37.zip&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\\Program Files\\Python37\\DLLs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\\Program Files\\Python37\\lib&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\\Program Files\\Python37&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\\Users\\Se7eN_HOU\\AppData\\Roaming\\Python\\Python37\\site-packages&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\\Program Files\\Python37\\lib\\site-packages&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/home/Se7eN_HOU&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;五、模块制作&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、定义自己的模块&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在Python中，每个Python文件都可以作为一个模块，模块的名字就是文件的名字。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如有这样一个文件test.py，在test.py中定义了函数add&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt;  add(a,b):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a+b&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、调用自己的模块&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么在demo.py文件中就可以先import test，然后通过test.add(a,b)来调用了，当然也可以通过from test import add来引入&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; test
result &lt;/span&gt;= test.add(1,2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(result)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果为：3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、测试模块&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在实际开中，当一个开发人员编写完一个模块后，为了让模块能够在项目中达到想要的效果，这个开发人员会自行在py文件中添加一些测试信息，例如：test.py文件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; add(a,b):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a+&lt;span&gt;b

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用来测试&lt;/span&gt;
ret = add(11,22&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;in test.py 测试11+22 = %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%ret)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果此时，在demo.py文件中引入了此文件的话，想想看，测试的那段代码是否也会执行呢！&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; test
result &lt;/span&gt;= test.add(1,2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(result)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;in&lt;/span&gt; test.py 测试11+22 = 33
3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;至此，可发现test.py中的测试代码，应该是单独执行test.py文件时才应该执行的，不应该是其他的文件中引用而执行。为了解决这个问题，python在执行一个文件时有个变量__name__&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;test.py文件中：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; add(a,b):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a+&lt;span&gt;b

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用来测试&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;ret = add(11,22)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;print(&quot;in test.py 测试11+22 = %d&quot;%ret)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;in test.py,__name__ is %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;__name__&lt;/span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;in&lt;/span&gt; test.py,&lt;span&gt;__name__&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;__main__&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在demo.py文件中导入test.py模块运行为&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; test
result &lt;/span&gt;= test.add(1,2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(result)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;in&lt;/span&gt; test.py,&lt;span&gt;__name__&lt;/span&gt; &lt;span&gt;is&lt;/span&gt;&lt;span&gt; test
&lt;/span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以根据__name__变量的结果能够判断出，是直接执行的python脚本还是被引入执行的，从而能够有选择性的执行测试代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;test.py模块中代码改为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; add(a,b):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a+&lt;span&gt;b

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    ret &lt;/span&gt;= add(11,22&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;in test.py 测试11+22 = %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%ret)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在test.py中运行结果为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;in&lt;/span&gt; test.py 测试11+22 = 33&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在demo.py中导入test.py模块&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; test
result &lt;/span&gt;= test.add(1,2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(result)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果为：3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样我们在开中测试的代码，就不会在其他模块中出现了。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;六、模块中的_ _all_ _&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、没有_ _all_ _&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;test.py模块&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---Test类中的test方法---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test1():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---test1方法---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test2():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---test2方法---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在demo.py中导入test.py模块&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;from&lt;/span&gt; test &lt;span&gt;import&lt;/span&gt; *&lt;span&gt;
a &lt;/span&gt;=&lt;span&gt; Test()
a.test()
test1()
test2() &lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;---Test类中的test方法---
---test1方法---
---test2方法---&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、模块中有_ _all_ _&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;test.py模块&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;__all__&lt;/span&gt; = [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---Test类中的test方法---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test1():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---test1方法---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test2():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---test2方法---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;demo.py模块&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;from&lt;/span&gt; test &lt;span&gt;import&lt;/span&gt; *&lt;span&gt;
a &lt;/span&gt;=&lt;span&gt; Test()
a.test()
test1()
test2() &lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;---Test类中的test方法---&lt;span&gt;Traceback (most recent call last):

&lt;/span&gt;---test1方法---&lt;span&gt;
  File &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\Users\Se7eN_HOU\Desktop\Tools\sublimetext3\Sublime Text Build 3176 x86\demo.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, line 5, &lt;span&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;&lt;span&gt;
    test2() 
&lt;strong&gt;NameError: name &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; defined&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果一个文件中有__all__变量，那么也就意味着只有这个变量中的元素，才会被from xxx import *时导入&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 15 Apr 2019 05:56:00 +0000</pubDate>
<dc:creator>Se7eN_HOU</dc:creator>
<og:description>一、python中的模块 有过C语言编程经验的朋友都知道在C语言中如果要引用sqrt函数，必须用语句#include &lt;math.h&gt;引入math.h这个头文件，否则是无法正常进行调用的。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Se7eN-HOU/p/10710272.html</dc:identifier>
</item>
<item>
<title>不一样的go语言-athens私仓安装 - Laud</title>
<link>http://www.cnblogs.com/laud/p/athens.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laud/p/athens.html</guid>
<description>&lt;h4 id=&quot;前言&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;  本系列文章曾多次提及go的依赖管理，提到了私仓，构件系统等概念，也曾提及当前流行的go构件系统，如athens，jfrog artifactory。鉴于jfrog的收费特性，本文只选择athens着重介绍。包括安装、使用、踩坑、源码分析等。&lt;/p&gt;
&lt;h4 id=&quot;简要介绍&quot;&gt;简要介绍&lt;/h4&gt;
&lt;p&gt;  在依赖管理方面，go相较于其他语言，其提供了从开放的源码仓库(github、bitbucket等)动态获取源码的工具，最早是go get，go1.11后又新增了go mod。而像java，其本身并没有提供类似的命令，因而才诞生了maven、gradle这样的构建系统。它们的构件则来源于公共仓库或者自行搭建的私有仓库。go的创造者估计是想回避掉这些问题，而直接由官方来提供，这样更便利于开发人员。但其短板则在于私仓，因为私仓在网络、权限、安全等方面会有诸多的限制，并不能像github那样公开，在这样的情况下，go get或者go mod也只能是心有由而力不足。鉴于此，go提出了GOPROXY的概念，通过vgo download protocol协商软件包的获取。剩下的网络、权限等问题就交由proxy server来解决了。&lt;/p&gt;
&lt;h4 id=&quot;go软件包协议&quot;&gt;go软件包协议&lt;/h4&gt;
&lt;p&gt;Defining Go Modules，协议的开头，Russ Cox就指明了go modules的设计目标，只要包括以下六点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;希望约定以tag的方式发布软件包，同时又能支持获取指定commit的软件包；&lt;/li&gt;
&lt;li&gt;希望不借助其他版本管理工具为实现软件包的获取；&lt;/li&gt;
&lt;li&gt;希望支持软件包的多版本管理；&lt;/li&gt;
&lt;li&gt;希望在获取软件包时拥有前置个人或公司的代理仓库或私有仓库的能力；&lt;/li&gt;
&lt;li&gt;希望支持在未来扩展实现公有仓库，同时又能在没有公有仓库的情况下正常运作；&lt;/li&gt;
&lt;li&gt;希望废弃vendor文件夹。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;协议的主体内容主要包括：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;13.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;软件包版本&lt;/td&gt;
&lt;td&gt;遵循语义版本2.0(Semantic Versioning)&lt;/td&gt;
&lt;td&gt;同时支持tag与commit方式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;go mod&lt;/td&gt;
&lt;td&gt;go.mod&lt;/td&gt;
&lt;td&gt;定义go.mod文件的内容&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;软件包&lt;/td&gt;
&lt;td&gt;定义软件包在源码库的组织方式&lt;/td&gt;
&lt;td&gt;支持分支方式、子目录方&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;发布方式&lt;/td&gt;
&lt;td&gt;定义软件包的发布方式&lt;/td&gt;
&lt;td&gt;软件包仓库需支持go-get=1参数获取软件包meta&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;打包方式&lt;/td&gt;
&lt;td&gt;定义软件包的打包方式&lt;/td&gt;
&lt;td&gt;在构件系统中以zip格式保存&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;下载协议&lt;/td&gt;
&lt;td&gt;定义软件包如何从构件系统获取&lt;/td&gt;
&lt;td&gt;实现四个或六个http请求接口&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;代理服务&lt;/td&gt;
&lt;td&gt;定义GOPROXY服务系统的概念&lt;/td&gt;
&lt;td&gt;如goproxy.io, gocenter.io&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;download protocol约定以下四个http请求接口：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;GET baseURL/module/@v/list: 获取指定软件包的所有已知版本信息，每个版本一行。&lt;/li&gt;
&lt;li&gt;GET baseURL/module/@v/version.info: 获取指定软件包特定版本的json格式元数据。&lt;/li&gt;
&lt;li&gt;GET baseURL/module/@v/version.mod: 获取指定软件包特定版本的mod文件。&lt;/li&gt;
&lt;li&gt;GET baseURL/module/@v/version.zip: 获取指定软件包特定版本的zip源码包。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其中version.info响应定义如下：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;type RevInfo struct {
    Version string    // version string
    Name    string    // complete ID in underlying repository
    Short   string    // shortened ID, for use in pseudo-version
    Time    time.Time // commit time
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下两个请求为可选实现：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;GET baseURL/module/@t/yyyymmddhhmmss：获取与指定时间戳最近的一个版本，响应数据与version.json接口一致&lt;/li&gt;
&lt;li&gt;GET baseURL/module/@t/yyyymmddhhmmss/branch: 获取指定分支下，与指定时间戳最近的一个版本，响应数据与version.json接口一致。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;athens私仓搭建&quot;&gt;athens私仓搭建&lt;/h4&gt;
&lt;p&gt;  依前文所述，go的构件系统其实是由两部分组成的，一是实现了vgo download protocol的服务；二是软件包仓库。前者是纯代理模式，比如goproyx.io，gocenter.io，其本身并不存储软件包，而只是转发请求从指定仓库(github等)获取所需软件包。后者真的就只是一个软件包仓库(如github，github目前并不是GOPROXY，虽然它可以是)。而athens则既是代理又是软件包仓库(类似于nexus，属于本地缓存仓，原始软件包仍然在公共仓库或私有仓库)。接下来的篇幅，着重于介绍如何安装并使用athens。&lt;/p&gt;
&lt;p&gt;  athens本身使用go语言编写，除了通过常规运行方式之外，还支持docker、k8s的方式运行，本文介绍的方式为第一种。常规的运行方式遇到问题或者踩到深坑，可较快速找到问题所在，不需要再去考虑装载容器的因素。&lt;/p&gt;
&lt;p&gt;  系统与网络环境说明：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;操作系统&lt;/td&gt;
&lt;td&gt;linux, centos 7&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;gitlab&lt;/td&gt;
&lt;td&gt;内网ip, 192.168.197.26，http端口10080，ssh端口10022，域名git.example.com&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;athens宿主机&lt;/td&gt;
&lt;td&gt;内网ip, 192.168.197.205&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;go&lt;/td&gt;
&lt;td&gt;go 1.12&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;git client&lt;/td&gt;
&lt;td&gt;git-bash&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;  前方高能预警，为避免不必要的踩坑行为，特提醒如下。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;务必为gitlab配置域名&lt;/li&gt;
&lt;li&gt;务必使用https&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上两点，已经可以避免ip、域名、端口诸多烦人的问题。比如go get指令是不支持这样的指令的：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[eventer@localhost]# go get github.com:8080/gomods/athens
go get github.com:8080/gomods/athens: malformed module path &quot;github.com:8080/gomods/athens&quot;: invalid char ':'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  当然如果gitlab满足以上两点， 同时http与ssh端口又是默认80与443端口，那么athens体验过程应更为轻松。&lt;/p&gt;
&lt;p&gt;安装步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;下载&amp;amp;编译athens&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[eventer@localhost]# pwd
[eventer@localhost]# /home/eventer
[eventer@localhost]# git clone https://github.com/gomods/athens.git
[eventer@localhost]# cd athens
[eventer@localhost]# make build-ver VERSION=&quot;0.2.0&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;运行athens&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[eventer@localhost]# pwd
[eventer@localhost]# /home/eventer/athens
[eventer@localhost]# ./athens -config_file=./config.dev.toml&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  到这一步，默认配置的情况下，go的构件系统已经搭建好了，只需要将自己开发环境的go环境变量GOPROXY指向这里即可。IP地址：192.168.197.205:3000。其中192.168.197.205是athens安装机器ip。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;修改默认配置&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;打开config.dev.toml，可能要修改的配置项说明如下。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;9.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Port&lt;/td&gt;
&lt;td&gt;端口号，默认3000&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;7&quot;&gt;&lt;td&gt;StorageType&lt;/td&gt;
&lt;td&gt;memory, disk, mongo, gcp, minio, s3。本安装过程选择disk&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;FilterFile&lt;/td&gt;
&lt;td&gt;过滤策略，与GlobalEndpoint配合使用。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;GlobalEndpoint&lt;/td&gt;
&lt;td&gt;全局代理，即athens的GOPROXY，可设置为https://goproxy.io&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;NETRCPath&lt;/td&gt;
&lt;td&gt;自动登录脚本，放在当前用户home目录下，文件名.netrc此处可用于访问git&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;GithubToken&lt;/td&gt;
&lt;td&gt;github访问令牌，用于访问github&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;HGRCPath&lt;/td&gt;
&lt;td&gt;Mercurial自动登录脚本，放在当前用户home目录下，文件名.hgrc&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Stogage-&amp;gt;Storage.Disk&lt;/td&gt;
&lt;td&gt;当StorageType为disk时，需要修改此处&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;FileterFile&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  athens约定的软件包过滤策略，当前可用策略包括D、-、+三种。D必须存在且放在第一行；-表示禁止下载此软件包，若请求，报403；+表示不从指定的GlobalEndpoint下载，而直接从域名指定的仓库获取软件包。-与+对软件包的策略可指定至版本，多个版本用,号分隔，甚至可使用版本修饰符(~, ^, &amp;gt;)。此外#开头的行表示注释，会被忽略。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;D
# 内网的gitlab不需要通过GlobalEndpoint下载
+ git.example.com
+ github.com/gomods/athens v0.1,v0.2,v0.4.1&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;~&lt;/td&gt;
&lt;td&gt;~1.2.3表示激活所有大于等于3的patch版本，在语义化版本方案中，最后一位的3表示补丁版本。如1.2.3, 1.2.4, 1.2.5&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;^1.2.3表示激活所有大于等于2的minor与大于等于3的patch版本。如1.2.3, 1.3.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;lt;1.2.3表示激活所有小于1.2.3的版本。如1.2.2, 1.0.0, 0.1.1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;  这个过滤策略主要用于API兼容或者软件包license改变时使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NETRCPath&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  自动登录脚本，即遇到指定machine需要输入用户名密码时，则从登录脚本中寻找是否有匹配的配置项。示例如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# filename: .netrc

machine 192.168.197.26
login eventer
password 123456  &lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;gitlab访问配置&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;  前文已经讲述vgo download protocol，因此当athens接收到go get或go mod的指令时，需要做出正确的回应。这四个接口是依次执行下去的，后一个接口依赖于前一个接口的响应。而这其中的关键在于两个地方，其中一个是软件包仓库支持的获取元数据的接口(GET baseURL/module?go-get=1)，第二个是获取软件包(GET baseURL/module/@v/version.zip)。当athens收到GET baseURL/module/@v/version.info指令时，如果本地没有，会直接调用go mod命令去指定的软件包仓库下载。而这个命令的第一步就是获取软件包元数据，即向软件包仓库发起请求GET baseURL/module?go-get=1，按照协议，软件包仓库应该返回如下类似响应：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;meta content='git.example.net/module git https://git.example.net/module.git' name='go-import'&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  之后go会使用git clone命令下载zip软件包至本地，至此go mod的使命完成。然后athens将软件包加上版本号，改名后放至本地仓库中，等待GET baseURL/module/@v/version.zip。&lt;/p&gt;
&lt;p&gt;  可以看到关键的两步，第一步要返回准确的git地址，第二步要能访问git并clone下来。&lt;/p&gt;
&lt;p&gt;  对于第一步，低版本的gitlab可能会返回不正确的meta，这里提供的方案是使用nginx来处理。方案如下(不同gitlab环境可能nginx的配置会有所不同，比如路径匹配)：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;if ($args ~* &quot;^go-get=1&quot;) {
        set $condition goget;
}
if ($uri ~ ^/([a-zA-Z0-9_-]+)/([a-zA-Z0-9_-]+)) {
    set $condition &quot;${condition}path&quot;;
}
if ($condition = gogetpath) {
    return 200 &quot;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;meta content='git.example.net/$1 git http://git.example.net/$1.git' name='go-import'&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;/html&amp;gt;&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  对于第二步，其实有两个方案可用，一是使用前文所说的.netrc文件，二是使用ssh。本文选择的是ssh。&lt;/p&gt;
&lt;p&gt;  ssh方案要处理两件事情，一是go调用git clone命令，使用的是https协议，需要替换为ssh协议，这可以通过gitconfig文件完成，示例如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[eventer@localhost]# pwd
[eventer@localhost]# /home/eventer
[eventer@localhost]# touch .gitconfig&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;.gitconfing内容如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# filename: .gitconfig

[url &quot;ssh://git@192.168.197.26:10022&quot;]
    insteadOf = https://git.example.com

[url &quot;ssh://git@192.168.197.26:10022&quot;]
    insteadOf = https://192.168.197.26:10080&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  二是https协议替换成ssh后，需要生成及指定ssh所用的私钥。这个通过.ssh目录做文章。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[eventer@localhost]# pwd
[eventer@localhost]# /home/eventer
[eventer@localhost]# cd .ssh
[eventer@localhost]# ssh-keygen -t rsa -C &quot;your.email@example.com&quot; -b 4096
Generating public/private rsa key pair.
Enter file in which to save the key (/data/rfchina/.ssh/id_rsa): git_id_rsa
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in aaaa.
Your public key has been saved in aaaa.pub.
The key fingerprint is:
SHA256:0/jCNSuQ5vuOl/URiFH466dm+B+dgVSaVi3T5eSKs1Q your.email@example.com
The key's randomart image is:
+---[RSA 4096]----+
|         o.   oo+|
|        o    =o+o|
|         + .= Eoo|
|       ..ooo.+ . |
|      + S +.=.o  |
|     o o +o+.+ o |
|      . +=o.o.o  |
|       o+o+ o.   |
|      o+o+o+.    |
+----[SHA256]-----+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;RSA秘钥对生成之后，将公钥放置到gitlab的ssh keys中，私钥放在home目录下的.ssh目录中。&lt;br/&gt;然后配置config文件，指定哪个host使用哪个私钥。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[eventer@localhost]# pwd
[eventer@localhost]# /home/eventer
[eventer@localhost]# cd .ssh
[eventer@localhost]# touch config&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;config内容如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# filename: config

Host 192.168.197.26
HostName 192.168.197.26
Port 10022
StrictHostKeyChecking no
IdentityFile /home/eventer/.ssh/git_id_rsa&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  配置完成之后，可在athens宿主机上尝试运行git clone命令，如果 能顺序获取到源码，则配置正确。否则需要根据athens的log并在宿主机上尝试运行go mod或go get指令来检查问题。&lt;/p&gt;
&lt;p&gt;  至此，athens可以访问私有的gitlab源码库了。go私仓安装教程毕。&lt;/p&gt;
&lt;p&gt;  如果采用docker方式安装，athens的环境变量已在config.dev.toml中的注释中给出。简略安装步骤如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[eventer@localhost]# pwd
[eventer@localhost]# /home/eventer
[eventer@localhost]# mkdir -p athens/storage
[eventer@localhost]# cd athens/storage
[eventer@localhost]# mkdir gitconfig
[eventer@localhost]# mkdir ssh-keys
[eventer@localhost]# export $ATHENS_STORAGE=/home/eventer/athens/storage
[eventer@localhost]# docker run -d -v $ATHENS_STORAGE:/var/lib/athens \
&amp;gt;    -v $ATHENS_STORAGE/gitconfig/.gitconfig:/root/.gitconfig \
&amp;gt;    -v $ATHENS_STORAGE/ssh-keys:/root/.ssh \
&amp;gt;    -e ATHENS_DISK_STORAGE_ROOT=/var/lib/athens \
&amp;gt;    -e ATHENS_FILTER_FILE=/var/lib/athens/FilterFile \
&amp;gt;    -e ATHENS_GLOBAL_ENDPOINT=https://goproxy.io \
&amp;gt;    -e ATHENS_STORAGE_TYPE=disk \
&amp;gt;    --name athens-proxy \
&amp;gt;    --restart always \
&amp;gt;    -p 3000:3000 \
&amp;gt;    gomods/athens:latest&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  在执行docker run命令之前，将前文所述的.gitconfig拷贝至/home/eventer/athens/storage/gitconfig目录下，同时将config与git_id_rsa文件拷贝至/home/eventer/athens/storage/ssh-keys目录下。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;#查看docker日志
[eventer@localhost]# docker logs -f athens-proxy
#进入docker
[eventer@localhost]# docker exec -it athens-proxy /bin/sh
#重启docker
[eventer@localhost]# docker restart athens-proxy
#停止docker
[eventer@localhost]# docker stop athens-proxy
#删除docker
[eventer@localhost]# docker rm athens-proxy&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;欢迎关注个人公众号&quot;&gt;欢迎关注个人公众号&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/78533/201903/78533-20190320094228818-1808949793.jpg&quot; alt=&quot;不一样的go语言&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 15 Apr 2019 05:44:00 +0000</pubDate>
<dc:creator>Laud</dc:creator>
<og:description>go proxy与vgo download protocol介绍，go私仓当前最详细搭建教程，没有之一。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/laud/p/athens.html</dc:identifier>
</item>
<item>
<title>spring  JdbcTemplate  在itest 开源测试管理项目中的浅层（5个使用场景）封装 - 我是刘阿牛</title>
<link>http://www.cnblogs.com/mypm/p/10709689.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mypm/p/10709689.html</guid>
<description>&lt;p&gt;       导读：&lt;/p&gt;
&lt;p&gt;       主要从4个方面来阐述，1：背景；2：思路；3：代码实现；4：使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一：封装背景，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在做项目的时候，用的JPA ，有些复杂查询，比如报表用原生的JdbcTemplate ，很不方便；需要增加分页功能，以及结果集自动转对像等5个常用功能，见第4节。&lt;/p&gt;
&lt;p&gt;下面两个图是开源测试管理软件 itest 的统计功能，因为SQL复杂，有些有200行，所以才有后面的 JdbcTemplateWrapper；可以在这体验这些报表（点测试，然后选择一个项目，然后点度量分析），速度还不错，&lt;a href=&quot;https://itest.work/demo/login.htm&quot; target=&quot;_blank&quot;&gt;https://itest.work/demo/login.htm  &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/261867/201904/261867-20190415113131722-733414015.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/261867/201904/261867-20190415113207882-728804661.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上面这图，SQL 就有200行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二：封装实现思路&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    （1）实现spring RowMapper 接口，直接把jdbc 结果集转 JAVA 对像&lt;span&gt;(用的反射，访问量大的业务不推荐用这方式)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    （2）不通过 RowMapper 接口, 把JdbcTemplate 返回的List&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt;  原生JDBC结果集中，字段名，也就是MAP中的KEY，转换为驼峰规则的JAVA对属性名,方便前端组件使用，不再中间转为VO 或 实体类对像后，再返前端;比传统查询&lt;span&gt;（多了一个LIST的遍历 ，基本对性能影响不大）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     （3）封装分页&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三：代码实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  &lt;/strong&gt; 两个类，ObjectRowMapper   和  JdbcTemplateWrapper&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ObjectRowMapper&lt;/strong&gt;    代码如下：&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;78&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.com.mypm.framework.jdbc;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Field;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.ResultSet;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.ResultSetMetaData;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.SQLException;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ConcurrentHashMap;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; 
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.logging.Log;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.logging.LogFactory;
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.jdbc.core.RowMapper;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.util.StringUtils;
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; 
&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.com.mypm.common.util.CalendaUtilities;
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.com.mypm.framework.common.config.PropertiesBean;
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; 
&lt;span&gt; 19&lt;/span&gt; 
&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;* &amp;lt;p&amp;gt;标题: RowMapper 接口实现&amp;lt;/p&amp;gt;
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;* &amp;lt;p&amp;gt;业务描述:完成原生结果集到JAVA对像的转换&amp;lt;/p&amp;gt;
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;* &amp;lt;p&amp;gt;公司:itest.work&amp;lt;/p&amp;gt;
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;* &amp;lt;p&amp;gt;版权:itest 2018&amp;lt;/p&amp;gt;
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; itest andy
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;* @date 2018年6月8日
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;* &lt;/span&gt;&lt;span&gt;@version&lt;/span&gt;&lt;span&gt; V1.0
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt; @SuppressWarnings(&quot;rawtypes&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ObjectRowMapper &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; RowMapper {
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; 
&lt;span&gt; 34&lt;/span&gt;     
&lt;span&gt; 35&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Class&amp;lt;?&amp;gt;&lt;span&gt; objectClass;
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; String[] columnNames = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Field[] fields ;
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;/缓存 当前结果集字对段和当前class的 Field的对应关系，&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String ,Field&amp;gt;&lt;span&gt; currQueryFieldMap ;
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存当前结果集，字段和 JAVA属性名的对应关系 ，按脱峰规则做的转换&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String ,String&amp;gt;&lt;span&gt; fieldClassMap ;
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Boolean isConvertSwitch  = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; MYSQL 是否区分大小写的标记，要是区转，要把结果集中，字段名，大写转为小写&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; String mysqlLowerCaseTableNames = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Log logger = LogFactory.getLog(ObjectRowMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存某个class 已处理过的字段映射到属性名的关系，避免同一个类每次重新处理，第一个KEY 为类名&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;String, Map&amp;lt;String, String&amp;gt;&amp;gt; dbColumnClassFieldMap = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;String, Map&amp;lt;String, String&amp;gt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;     
&lt;span&gt; 49&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ObjectRowMapper(Class&amp;lt;?&amp;gt;&lt;span&gt; objectClass) {
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.objectClass =&lt;span&gt; objectClass;
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;         fields =&lt;span&gt; objectClass.getDeclaredFields();
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; 
&lt;span&gt; 54&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clean(){
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(currQueryFieldMap!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;            currQueryFieldMap.clear();
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;             currQueryFieldMap = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(fieldClassMap!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;            fieldClassMap.clear();
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;             fieldClassMap = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(fields!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;             fields = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(columnNames!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;             columnNames = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;     
&lt;span&gt; 71&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;     * 该方法自动将数据库字段对应到Object中相应字段 要求：
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;     * 字段名严格为驼峰形式 == 数据库字段名去掉下划线转为驼峰形式
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;     * 如user_name 转为userName ，如数据库字段名，无下划线
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;     * 就只能把首字母变为大小写后的 set ,get
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object mapRow(ResultSet rs, &lt;span&gt;int&lt;/span&gt; rowNum) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; 
&lt;span&gt; 80&lt;/span&gt;         Object targetObject = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;             targetObject =&lt;span&gt; objectClass.newInstance();
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt; (InstantiationException |&lt;span&gt; IllegalAccessException e) {
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;            logger.error(e.getMessage(), e);
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (columnNames == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;             ResultSetMetaData rsmd =&lt;span&gt; rs.getMetaData();
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; columnCount =&lt;span&gt; rsmd.getColumnCount();
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;             columnNames = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String[columnCount];
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; columnCount; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;                 columnNames[i] = rsmd.getColumnLabel(i + 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;         isConvertSwitch = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; 
&lt;span&gt; 96&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(mysqlLowerCaseTableNames == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;             String lowerCaseNames = PropertiesBean.getInstance().getProperty(&quot;conf.mysql.lowerCaseNames&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(lowerCaseNames==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;                 mysqlLowerCaseTableNames = &quot;yes&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;                 mysqlLowerCaseTableNames = &quot;no&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(currQueryFieldMap==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;             currQueryFieldMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String,Field&amp;gt;&lt;span&gt;(columnNames.length);
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String columnName : columnNames) {
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Field field : fields) {
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;(isConvertSwitch==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (field.getName().equals(
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; &lt;span&gt;                                convertColumnNameToFieldName(columnName))) {
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; &lt;span&gt;                            currQueryFieldMap.put(columnName, field);
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;                             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;                     }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(isConvertSwitch){
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt;(targetObject &lt;span&gt;instanceof&lt;/span&gt;  CustomRowMapper&amp;amp;&amp;amp;(!&lt;span&gt;((CustomRowMapper)targetObject).isConvert())){
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;                                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (field.getName().equals(columnName)) {
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;                                    currQueryFieldMap.put(columnName, field);
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;                                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; &lt;span&gt;                                }
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;                             }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;                                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (field.getName().equals(
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; &lt;span&gt;                                        convertColumnNameToFieldName(columnName))) {
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; &lt;span&gt;                                    currQueryFieldMap.put(columnName, field);
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;                                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; &lt;span&gt;                                }
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; 
&lt;span&gt;130&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; 
&lt;span&gt;132&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String columnName : columnNames) {
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;             Field field =&lt;span&gt; currQueryFieldMap.get(columnName);
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(field==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(logger.isDebugEnabled()){
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;                     logger.debug(objectClass.getName() +&quot;is  not property match  db columnName:&quot;+&lt;span&gt;columnName );
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;                 &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;             Object value =&lt;span&gt; rs.getObject(columnName);
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (value == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;                 &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;             &lt;span&gt;boolean&lt;/span&gt; accessFlag =&lt;span&gt; field.isAccessible();
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;accessFlag) {
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;                 field.setAccessible(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(fieldClassMap==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;                 fieldClassMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String,String&amp;gt;&lt;span&gt;(columnNames.length);
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(fieldClassMap.get(columnName)==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt; &lt;span&gt;                fieldClassMap.put(columnName, getFieldClaszName(field));
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt; &lt;span&gt;            setFieldValue(targetObject, field, rs, columnName,fieldClassMap.get(columnName));
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 恢复相应field的权限&lt;/span&gt;
&lt;span&gt;159&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;accessFlag) {
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt; &lt;span&gt;                field.setAccessible(accessFlag);
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; targetObject;
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt; 
&lt;span&gt;166&lt;/span&gt; 
&lt;span&gt;167&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String convertColumnNameToFieldName(String columnName) {
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt; 
&lt;span&gt;169&lt;/span&gt;         Map&amp;lt;String, String&amp;gt; fieldMap =&lt;span&gt; dbColumnClassFieldMap.get(objectClass
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt; &lt;span&gt;                .getName());
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; emptyFlg = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (fieldMap == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt;             fieldMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, String&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt;             emptyFlg = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt; 
&lt;span&gt;177&lt;/span&gt;         String classFieldName =&lt;span&gt; fieldMap.get(columnName);
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (classFieldName != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; classFieldName;
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt;         String columnNameKey =&lt;span&gt; columnName;
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt; 
&lt;span&gt;183&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;if (&quot;oracle&quot;.equals(dbType)||(&quot;mysql&quot;.equals(dbType)&amp;amp;&amp;amp;&quot;no&quot;.equals(mysqlLowerCaseTableNames))) {&lt;/span&gt;
&lt;span&gt;184&lt;/span&gt;             columnName =&lt;span&gt; columnName.toLowerCase();
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;186&lt;/span&gt; 
&lt;span&gt;187&lt;/span&gt;         StringBuffer buf = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuffer();
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; ((i = columnName.indexOf('_')) &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt;             buf.append(columnName.substring(0&lt;span&gt;, i));
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt;             columnName = StringUtils.capitalize(columnName.substring(i + 1&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt; &lt;span&gt;        buf.append(columnName);
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt; &lt;span&gt;        fieldMap.put(columnNameKey, buf.toString());
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (emptyFlg) {
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt; &lt;span&gt;            dbColumnClassFieldMap.put(objectClass.getName(), fieldMap);
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; fieldMap.get(columnNameKey);
&lt;/span&gt;&lt;span&gt;199&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt; 
&lt;span&gt;201&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;202&lt;/span&gt; &lt;span&gt;     * 根据类型对具体对象属性赋值
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;204&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setFieldValue(Object targetObj, Field field,
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt; &lt;span&gt;            ResultSet rs, String columnLabel,String fieldClass) {
&lt;/span&gt;&lt;span&gt;206&lt;/span&gt; 
&lt;span&gt;207&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&quot;String&quot;&lt;span&gt;.equals(fieldClass)) {
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt; &lt;span&gt;                field.set(targetObj, rs.getString(columnLabel));
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&quot;Double&quot;&lt;span&gt;.equals(fieldClass)) {
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt; &lt;span&gt;                field.set(targetObj, rs.getDouble(columnLabel));
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&quot;Float&quot;&lt;span&gt;.equals(fieldClass)) {
&lt;/span&gt;&lt;span&gt;213&lt;/span&gt; &lt;span&gt;                field.set(targetObj, rs.getFloat(columnLabel));
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&quot;Integer&quot;&lt;span&gt;.equals(fieldClass)) {
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt; &lt;span&gt;                field.set(targetObj, rs.getInt(columnLabel));
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&quot;Long&quot;&lt;span&gt;.equals(fieldClass)) {
&lt;/span&gt;&lt;span&gt;217&lt;/span&gt; &lt;span&gt;                field.set(targetObj, rs.getLong(columnLabel));
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&quot;BigDecimal&quot;&lt;span&gt;.equals(fieldClass)) {
&lt;/span&gt;&lt;span&gt;219&lt;/span&gt; &lt;span&gt;                field.set(targetObj, rs.getBigDecimal(columnLabel));
&lt;/span&gt;&lt;span&gt;220&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&quot;Date&quot;&lt;span&gt;.equals(fieldClass)) {
&lt;/span&gt;&lt;span&gt;221&lt;/span&gt; &lt;span&gt;                field.set(targetObj, rs.getDate(columnLabel));
&lt;/span&gt;&lt;span&gt;222&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&quot;Short&quot;&lt;span&gt;.equals(fieldClass)) {
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt; &lt;span&gt;                field.set(targetObj, rs.getShort(columnLabel));
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&quot;Boolean&quot;&lt;span&gt;.equals(fieldClass)) {
&lt;/span&gt;&lt;span&gt;225&lt;/span&gt; &lt;span&gt;                field.set(targetObj, rs.getBoolean(columnLabel));
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&quot;Byte&quot;&lt;span&gt;.equals(fieldClass)) {
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt; &lt;span&gt;                field.set(targetObj, rs.getByte(columnLabel));
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&quot;Timestamp&quot;&lt;span&gt;.equals(fieldClass)) {
&lt;/span&gt;&lt;span&gt;229&lt;/span&gt; &lt;span&gt;                field.set(targetObj, rs.getTimestamp(columnLabel));
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(&quot;BigDecimal&quot;&lt;span&gt;.equals(fieldClass)) {
&lt;/span&gt;&lt;span&gt;231&lt;/span&gt; &lt;span&gt;                field.set(targetObj, rs.getBigDecimal(columnLabel));
&lt;/span&gt;&lt;span&gt;232&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;233&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里没有实现，如有特殊需要处理的在这里实现&lt;/span&gt;
&lt;span&gt;234&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt;             
&lt;span&gt;236&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IllegalArgumentException e) {
&lt;/span&gt;&lt;span&gt;237&lt;/span&gt; &lt;span&gt;            logger.error(e.getMessage(), e);
&lt;/span&gt;&lt;span&gt;238&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IllegalAccessException e) {
&lt;/span&gt;&lt;span&gt;239&lt;/span&gt; &lt;span&gt;            logger.error(e.getMessage(), e);
&lt;/span&gt;&lt;span&gt;240&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SQLException e) {
&lt;/span&gt;&lt;span&gt;241&lt;/span&gt; &lt;span&gt;            logger.error(e.getMessage(), e);
&lt;/span&gt;&lt;span&gt;242&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;243&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;244&lt;/span&gt; 
&lt;span&gt;245&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String getFieldClaszName(Field field) {
&lt;/span&gt;&lt;span&gt;246&lt;/span&gt; 
&lt;span&gt;247&lt;/span&gt;         String elemType =&lt;span&gt; field.getType().toString();
&lt;/span&gt;&lt;span&gt;248&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&quot;class java.lang.String&quot;&lt;span&gt;.equals(elemType)
&lt;/span&gt;&lt;span&gt;249&lt;/span&gt;                 || elemType.indexOf(&quot;char&quot;) != -1
&lt;span&gt;250&lt;/span&gt;                 || elemType.indexOf(&quot;Character&quot;) != -1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;251&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &quot;String&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;252&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (elemType.indexOf(&quot;double&quot;) != -1
&lt;span&gt;253&lt;/span&gt;                 || elemType.indexOf(&quot;Double&quot;) != -1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;254&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &quot;Double&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;255&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (elemType.indexOf(&quot;float&quot;) != -1
&lt;span&gt;256&lt;/span&gt;                 || elemType.indexOf(&quot;Float&quot;) != -1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;257&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &quot;Float&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;258&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (elemType.indexOf(&quot;int&quot;) != -1
&lt;span&gt;259&lt;/span&gt;                 || elemType.indexOf(&quot;Integer&quot;) != -1||elemType.indexOf(&quot;BigInteger&quot;) != -1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;260&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &quot;Integer&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;261&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (elemType.indexOf(&quot;long&quot;) != -1
&lt;span&gt;262&lt;/span&gt;                 || elemType.indexOf(&quot;Long&quot;) != -1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;263&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &quot;Long&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;264&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (elemType.indexOf(&quot;BigDecimal&quot;) != -1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;265&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &quot;BigDecimal&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;266&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (elemType.indexOf(&quot;Date&quot;) != -1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;267&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &quot;Date&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;268&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (elemType.indexOf(&quot;short&quot;) != -1
&lt;span&gt;269&lt;/span&gt;                 || elemType.indexOf(&quot;Short&quot;) != -1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;270&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &quot;Short&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;271&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (elemType.indexOf(&quot;boolean&quot;) != -1
&lt;span&gt;272&lt;/span&gt;                 || elemType.indexOf(&quot;Boolean&quot;) != -1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;273&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &quot;Boolean&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;274&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (elemType.indexOf(&quot;byte&quot;) != -1
&lt;span&gt;275&lt;/span&gt;                 || elemType.indexOf(&quot;Byte&quot;) != -1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;276&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &quot;Byte&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;277&lt;/span&gt;         }  &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (elemType.indexOf(&quot;Timestamp&quot;) != -1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;278&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &quot;Timestamp&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;279&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;280&lt;/span&gt;         
&lt;span&gt;281&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;String&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;282&lt;/span&gt; 
&lt;span&gt;283&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;JdbcTemplateWrapper&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;160&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.com.mypm.framework.jdbc;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Iterator;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map.Entry;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Set;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.regex.Matcher;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.regex.Pattern;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.lang3.StringUtils;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.logging.Log;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.logging.LogFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.jdbc.core.JdbcTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.jdbc.core.RowMapper;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.util.Assert;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.com.mypm.common.dto.PageModel;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.com.mypm.framework.exception.DataBaseException;



&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 
* &amp;lt;p&amp;gt;标题:  JdbcTemplate 包装器&amp;lt;/p&amp;gt;
* &amp;lt;p&amp;gt;业务描述:实现分页，原生结果集转对像，原生结果集字段名转脱峰java 属性名&amp;lt;/p&amp;gt;
* &amp;lt;p&amp;gt;公司:itest.work&amp;lt;/p&amp;gt;
* &amp;lt;p&amp;gt;版权:itest 2018&amp;lt;/p&amp;gt;
* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; itest andy 
* @date 2018年6月8日
* &lt;/span&gt;&lt;span&gt;@version&lt;/span&gt;&lt;span&gt; V1.0
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JdbcTemplateWrapper  {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Log logger = LogFactory.getLog(JdbcTemplateWrapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; JdbcTemplate jdbcTemplate;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String dbType = &quot;mysql&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String showSql = &quot;false&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; NamedParameterJdbcTemplate namedParameterJdbcTemplate;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String mysqlLowerCaseTableNames = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; JdbcTemplateWrapper() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; JdbcTemplateWrapper(JdbcTemplate jdbcTemplate) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.jdbcTemplate =&lt;span&gt; jdbcTemplate;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.namedParameterJdbcTemplate = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NamedParameterJdbcTemplate(jdbcTemplate);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; JdbcTemplateWrapper(JdbcTemplate jdbcTemplate, String dbType, String showSql) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.jdbcTemplate =&lt;span&gt; jdbcTemplate;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dbType =&lt;span&gt; dbType;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.namedParameterJdbcTemplate = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NamedParameterJdbcTemplate(jdbcTemplate);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.showSql =&lt;span&gt; showSql;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; JdbcTemplate getJdbcTemplate() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; jdbcTemplate;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 查询所有匹配的列表
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; sql
     *            查询sql
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; className
     *            对象类型
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; args
     *            查询参数
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; itest andy 
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @SuppressWarnings({ &lt;/span&gt;&quot;rawtypes&quot;, &quot;unchecked&quot;&lt;span&gt; })
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; List queryAllMatchList(String sql, Class clasz, Object[] args) {
        Assert.notNull(clasz, &lt;/span&gt;&quot;clasz must not be null&quot;&lt;span&gt;);
        List dataList &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        RowMapper rowMapper &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectRowMapper(clasz);
        dataList &lt;/span&gt;=&lt;span&gt; getJdbcTemplate().query(sql, args, rowMapper);
        ((ObjectRowMapper) rowMapper).clean();
        rowMapper &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dataList;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 查询所有匹配的列表
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; sql
     *            查询sql
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; className
     *            对象类型
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; args
     *            查询参数
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; itest andy 
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @SuppressWarnings({ &lt;/span&gt;&quot;rawtypes&quot;, &quot;unchecked&quot;&lt;span&gt; })
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; List queryAllMatchListWithFreePra(String sql, Class clasz, Object... args) {
        Assert.notNull(clasz, &lt;/span&gt;&quot;clasz must not be null&quot;&lt;span&gt;);
        List dataList &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        RowMapper rowMapper &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectRowMapper(clasz);
        dataList &lt;/span&gt;=&lt;span&gt; getJdbcTemplate().query(sql, args, rowMapper);
        ((ObjectRowMapper) rowMapper).clean();
        rowMapper &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dataList;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 把list map 原生JDBC结果集中，字段名，也就是MAP中的KEY，转换为驼峰规则的JAVA对属性名
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; resultList ：JDBC 结果集
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;    把MAP中的KEY转换为转换为驼峰规则的JAVA对属性名的LIST&amp;lt;map&amp;lt;驼峰规则的JAVA对属性名形式的KEY,Object&amp;gt;&amp;gt;
     * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; itest andy 
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; converDbColumnName2ObjectPropName(List&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt;&lt;span&gt; resultList) {
        
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(resultList!=&lt;span&gt;null&lt;/span&gt;&amp;amp;&amp;amp;!&lt;span&gt;resultList.isEmpty()) {
            List&lt;/span&gt;&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt; convertList=  &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt;&lt;span&gt;(resultList.size());
             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于缓存字段名到属性名的映射，第二条记录时就不再处理字段名到属性名的转换，提升性能&lt;/span&gt;
            Map&amp;lt;String,String&amp;gt; ColumnNamePropNameMap = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(resultList.size()&amp;gt;1&lt;span&gt;) {
                ColumnNamePropNameMap &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String,String&amp;gt;&lt;span&gt;();
            }
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(Map&amp;lt;String,Object&amp;gt;&lt;span&gt; currMap :resultList) {
                 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(currMap!=&lt;span&gt;null&lt;/span&gt;&amp;amp;&amp;amp;!&lt;span&gt;currMap.isEmpty()) {
                     Iterator&lt;/span&gt;&amp;lt;Entry&amp;lt;String, Object&amp;gt;&amp;gt;   currentIt =&lt;span&gt;  currMap.entrySet().iterator();
                     Map tempMap &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String,Object&amp;gt;&lt;span&gt;();
                     convertList.add(tempMap);
                     &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(currentIt.hasNext()) {
                         Map.Entry&lt;/span&gt;&amp;lt;String,Object&amp;gt;  me=&lt;span&gt;  currentIt.next();
                         String dbColumnName &lt;/span&gt;=&lt;span&gt; me.getKey();
                         Object value &lt;/span&gt;=&lt;span&gt; me.getValue();
                         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(resultList.size()&amp;gt;1&lt;span&gt;) {
                             &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ColumnNamePropNameMap.get(dbColumnName)==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                                 String currProName &lt;/span&gt;=&lt;span&gt; convertColumnName2OFieldName(dbColumnName);
                                 tempMap.put(currProName, value);
                                 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存起来，第二条记录时就不再处理字段名到属性名的转换，提升性能&lt;/span&gt;
&lt;span&gt;                                 ColumnNamePropNameMap.put(dbColumnName, currProName);
                             }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                                 tempMap.put(ColumnNamePropNameMap.get(dbColumnName), value);
                             }
                        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                             tempMap.put(convertColumnName2OFieldName(dbColumnName), value);
                        }

                         
                     }
                 }
            }
            resultList.clear();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(Map&amp;lt;String,Object&amp;gt;&lt;span&gt; currMap:convertList) {
                resultList.add(currMap);
            }
            convertList.clear();
            convertList &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        }
    }
    
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String convertColumnName2OFieldName(String columnName ) {
         
         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(mysqlLowerCaseTableNames == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            String lowerCaseNames &lt;/span&gt;= PropertiesBean.getInstance().getProperty(&quot;conf.mysql.lowerCaseNames&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(lowerCaseNames==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                mysqlLowerCaseTableNames &lt;/span&gt;= &quot;yes&quot;&lt;span&gt;;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                mysqlLowerCaseTableNames &lt;/span&gt;= &quot;no&quot;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&quot;oracle&quot;.equals(dbType)||(&quot;mysql&quot;.equals(dbType)&amp;amp;&amp;amp;&quot;no&quot;&lt;span&gt;.equals(mysqlLowerCaseTableNames))) {
            columnName &lt;/span&gt;=&lt;span&gt; columnName.toLowerCase();
        }
         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&quot;true&quot;&lt;span&gt;.equals(mysqlLowerCaseTableNames)) {
             columnName &lt;/span&gt;=&lt;span&gt; columnName.toLowerCase();
         }
        
        StringBuffer buf &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuffer();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((i = columnName.indexOf('_')) &amp;gt; 0&lt;span&gt;) {
            buf.append(columnName.substring(&lt;/span&gt;0&lt;span&gt;, i));
            columnName &lt;/span&gt;= StringUtils.capitalize(columnName.substring(i + 1&lt;span&gt;));
        }
        buf.append(columnName);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;  buf.toString();
     }
     
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 查询所有匹配的列表
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; sql
     *            查询sql
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; className
     *            对象类型
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; paramMap
     *            查询参数
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; itest andy 
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @SuppressWarnings({ &lt;/span&gt;&quot;rawtypes&quot;, &quot;unchecked&quot;&lt;span&gt; })
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; List queryAllMatchListWithParaMap(String sql, Class clasz, Map paramMap) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (paramMap != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; paramMap.isEmpty()) {
            paramMap &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&quot;true&quot;&lt;span&gt;.equals(showSql)) {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                logger.info(getSqlFromQueryData(sql, paramMap));
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                logger.error(e.getMessage(), e);
            }
        }
        List resultList &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (clasz == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            resultList &lt;/span&gt;=&lt;span&gt; namedParameterJdbcTemplate.queryForList(sql, paramMap);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            RowMapper rowMapper &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectRowMapper(clasz);
            resultList &lt;/span&gt;=&lt;span&gt; namedParameterJdbcTemplate.query(sql, paramMap, rowMapper);
            ((ObjectRowMapper) rowMapper).clean();
            rowMapper &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resultList;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; pageModel:
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; className
     *            : 从查询结果集中构建出的类，如为null则pageModel的PageData为List&amp;lt;Map&amp;gt;，
     *            不为null则pageModel的PageData为List&amp;lt;className&amp;gt;
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; columnNameForCount:查询记录数时的字段名，一般用主键
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @SuppressWarnings({ &lt;/span&gt;&quot;rawtypes&quot;, &quot;unchecked&quot;&lt;span&gt; })
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; fillPageModelData(PageModel pageModel, Class className, String columnNameForCount) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pageModel.getHqlParamMap() != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; pageModel.getHqlParamMap().isEmpty()) {
            pageModel.setHqlParamMap(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pageModel.getTotal() == 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; totalRows = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getResultCountWithValuesMap(pageModel.getQueryHql(), columnNameForCount,
                    pageModel.getHqlParamMap());
            pageModel.setTotal(totalRows);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pageModel.getTotal() == 0&lt;span&gt;) {
            pageModel.setRows(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayList());
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pageModel.getPageNo() &amp;gt; 1&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; pageCount = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getValidPage(pageModel.getPageNo(), pageModel.getTotal(), pageModel.getPageSize());
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pageCount &amp;lt;&lt;span&gt; pageModel.getPageNo()) {
                pageModel.setPageNo(pageCount);
            }
        }

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; startRow =&lt;span&gt; getStartOfPage(pageModel.getPageNo(), pageModel.getPageSize());

        String sql &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.buildPageSql(pageModel.getQueryHql(), startRow, pageModel.getPageSize());
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&quot;true&quot;&lt;span&gt;.equals(showSql)) {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                logger.info(getSqlFromQueryData(sql, pageModel.getHqlParamMap()));
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                logger.error(e.getMessage(), e);
            }
        }
        List dataList &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (className == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            dataList &lt;/span&gt;=&lt;span&gt; namedParameterJdbcTemplate.queryForList(sql, pageModel.getHqlParamMap());
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            RowMapper rowMapper &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectRowMapper(className);
            dataList &lt;/span&gt;=&lt;span&gt; namedParameterJdbcTemplate.query(sql, pageModel.getHqlParamMap(), rowMapper);
            ((ObjectRowMapper) rowMapper).clean();
            rowMapper &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        pageModel.setRows(dataList);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 多表sql 分页查询,多表连查时，才用这个方法，其他请用commonDao的 SQL分页查询
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; sql
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; className
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; paramMap
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; pageNo
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; PageSize
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; columnNameForCount
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @SuppressWarnings({ &lt;/span&gt;&quot;rawtypes&quot;, &quot;unchecked&quot;&lt;span&gt; })
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List queryAllMatchListWithParaMap(String sql, Class clasz, Map paramMap, &lt;span&gt;int&lt;/span&gt; pageNo, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; pageSize,
            String columnNameForCount) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (paramMap != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; paramMap.isEmpty()) {
            paramMap &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&quot;true&quot;&lt;span&gt;.equals(showSql)) {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                logger.info(getSqlFromQueryData(sql, paramMap));
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                logger.error(e.getMessage(), e);
            }
        }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;         int totalRows = this.getResultCountWithValuesMap(sql,
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;         columnNameForCount, paramMap);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;         if(pageNo&amp;gt;1){
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;             int pageCount = this.getValidPage(pageNo, totalRows, pageSize);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;         }&lt;/span&gt;
        List resultList = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; startRow =&lt;span&gt; getStartOfPage(pageNo, pageSize);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (clasz == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            resultList &lt;/span&gt;= namedParameterJdbcTemplate.queryForList(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.buildPageSql(sql, startRow, pageSize), paramMap);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            RowMapper rowMapper &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectRowMapper(clasz);
            resultList &lt;/span&gt;= namedParameterJdbcTemplate.query(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.buildPageSql(sql, startRow, pageSize), paramMap,
                    rowMapper);
            rowMapper &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resultList;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String buildPageSql(String sql, &lt;span&gt;int&lt;/span&gt; startRow, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; pageSize) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&quot;oracle&quot;.equals(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getDbType())) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.buildOraclePageSql(sql, startRow, pageSize);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&quot;mysql&quot;.equals(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getDbType())) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.buildMysqlPageSql(sql, startRow, pageSize);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&quot;informix&quot;.equals(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getDbType())) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.buildInformixPageSql(sql, startRow, pageSize);
        }
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; DataBaseException(&quot;don't support db type,please confirm db is oracle or mysql or informix&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String buildOraclePageSql(String sql, &lt;span&gt;int&lt;/span&gt; startRow, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; pageSize) {
        StringBuilder pageSql &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StringBuilder(&quot;SELECT * FROM  &quot;&lt;span&gt;);
        pageSql.append(&lt;/span&gt;&quot; ( &quot;&lt;span&gt;);
        pageSql.append(&lt;/span&gt;&quot; SELECT pageDataTable.*, ROWNUM RNV &quot;&lt;span&gt;);
        pageSql.append(&lt;/span&gt;&quot; FROM (&quot; + sql + &quot; ) pageDataTable &quot;&lt;span&gt;);
        pageSql.append(&lt;/span&gt;&quot; WHERE ROWNUM &amp;lt;= &quot; + (startRow +&lt;span&gt; pageSize));
        pageSql.append(&lt;/span&gt;&quot; )  WHERE RNV &amp;gt;= &quot; + (startRow + 1&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pageSql.toString();
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String buildMysqlPageSql(String sql, &lt;span&gt;int&lt;/span&gt; startRow, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; pageSize) {
        sql &lt;/span&gt;= sql + &quot; limit &quot; + startRow + &quot;, &quot; +&lt;span&gt; pageSize;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sql;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String buildInformixPageSql(String sql, &lt;span&gt;int&lt;/span&gt; startRow, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; pageSize) {
        sql &lt;/span&gt;=&lt;span&gt; sql.trim();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sql.startsWith(&quot;select&quot;&lt;span&gt;)) {
            sql &lt;/span&gt;= sql.replaceFirst(&quot;select&quot;, &quot; select skip &quot; + startRow + &quot; first &quot; + pageSize + &quot; &quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            sql &lt;/span&gt;= sql.replaceFirst(&quot;SELECT&quot;, &quot; select skip &quot; + startRow + &quot; first &quot; + pageSize + &quot; &quot;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sql;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Integer getValidPage(Integer pageNo, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; totalRows, Integer pageSize) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isValidPage(pageNo, totalRows, pageSize)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getValidPage(--&lt;span&gt;pageNo, totalRows, pageSize);
        }
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; pageCount = (totalRows + (pageSize - (totalRows % pageSize == 0 ? pageSize : totalRows %&lt;span&gt; pageSize)))
                &lt;/span&gt;/&lt;span&gt; pageSize;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pageCount;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getStartOfPage(&lt;span&gt;int&lt;/span&gt; pageNo, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; pageSize) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(pageNo==0&lt;span&gt;){
            pageNo&lt;/span&gt;=1&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (pageNo - 1) *&lt;span&gt; pageSize;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isValidPage(Integer pageNo, Integer totalRows, Integer pageSize) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pageNo == 1&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; rowStart = (pageNo - 1) *&lt;span&gt; pageSize;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; rowEnd = rowStart +&lt;span&gt; pageSize;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rowEnd &amp;gt;&lt;span&gt; totalRows) {
            rowEnd &lt;/span&gt;=&lt;span&gt; totalRows;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; rowEnd &amp;gt;&lt;span&gt; rowStart;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 查询记录数
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; sql
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; columnNameForCount
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; praValuesMap
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; @SuppressWarnings(&quot;deprecation&quot;)&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getResultCountWithValuesMap(String sql, String columnNameForCount, Map&amp;lt;String, Object&amp;gt;&lt;span&gt; praValuesMap) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (praValuesMap != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; praValuesMap.isEmpty()) {
            praValuesMap &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        String countQuerySql &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        countQuerySql &lt;/span&gt;= &quot; select count(*) from ( &quot; + sql + &quot; ) V_TABLE&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; namedParameterJdbcTemplate.queryForInt(countQuerySql, praValuesMap);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; queryForIntWithpraValuesMap(String countQuerySql, Map&amp;lt;String, Object&amp;gt;&lt;span&gt; praValuesMap) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (praValuesMap != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; praValuesMap.isEmpty()) {
            praValuesMap &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; namedParameterJdbcTemplate.queryForInt(countQuerySql, praValuesMap);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; queryForInt(String countQuerySql, Object... args) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; getJdbcTemplate().queryForInt(countQuerySql, args);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String getSqlFromQueryData(String sql, Map&amp;lt;String, Object&amp;gt;&lt;span&gt; paramMap) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.isEmpty(sql)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (paramMap == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sql;
        }
        StringBuffer sqlExp &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuffer(sql);
        Set&lt;/span&gt;&amp;lt;Entry&amp;lt;String, Object&amp;gt;&amp;gt; set =&lt;span&gt; paramMap.entrySet();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;String, Object&amp;gt;&lt;span&gt; entry : set) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; start = sqlExp.indexOf(&quot;:&quot; + entry.getKey() + &quot; &quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (start &amp;lt; 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; last = sqlExp.lastIndexOf(&quot;:&quot; + entry.getKey() + &quot; &quot;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (start &amp;gt;= 0 &amp;amp;&amp;amp; start ==&lt;span&gt; last) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (entry.getValue() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    sqlExp.replace(start, start &lt;/span&gt;+ entry.getKey().length(), &quot;'&quot; + entry.getValue().toString() + &quot;'&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; sqlExp.replace(start-1, start+entry.getKey().length(),
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;'&quot;+entry.getValue().toString()+&quot;'&quot;);&lt;/span&gt;
&lt;span&gt;                }
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理同一参数多处出现&lt;/span&gt;
                sqlExp.replace(start, start + entry.getKey().length(), &quot;'&quot; + entry.getValue().toString() + &quot;'&quot;&lt;span&gt;);
                start &lt;/span&gt;= sqlExp.indexOf(&quot;:&quot; +&lt;span&gt; entry.getKey());
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (start &amp;gt; 0&lt;span&gt;) {
                    sqlExp.replace(start, start &lt;/span&gt;+ entry.getKey().length(), &quot;'&quot; + entry.getValue().toString() + &quot;'&quot;&lt;span&gt;);
                    start &lt;/span&gt;= sqlExp.indexOf(&quot;:&quot; +&lt;span&gt; entry.getKey());
                }

            }

        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sqlExp.toString();
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String removeSelect(String sql) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; beginPos = sql.indexOf(&quot; from &quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (beginPos &amp;lt; 0&lt;span&gt;) {
            beginPos &lt;/span&gt;= sql.indexOf(&quot;from &quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (beginPos &amp;lt; 0&lt;span&gt;) {
            beginPos &lt;/span&gt;= sql.toLowerCase().indexOf(&quot; from &quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (beginPos &amp;lt; 0&lt;span&gt;) {
            beginPos &lt;/span&gt;= sql.toLowerCase().indexOf(&quot;from &quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sql.substring(beginPos);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 去除sql的orderby 用于页查果询
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; sql
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String removeOrders(String sql) {
        Pattern p &lt;/span&gt;= Pattern.compile(&quot;order\\s*by[\\w|\\W|\\s|\\S]*&quot;&lt;span&gt;, Pattern.CASE_INSENSITIVE);
        Matcher m &lt;/span&gt;=&lt;span&gt; p.matcher(sql);
        StringBuffer sb &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuffer();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (m.find()) {
            m.appendReplacement(sb, &lt;/span&gt;&quot;&quot;&lt;span&gt;);
        }
        m.appendTail(sb);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sb.toString();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDbType() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dbType;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; NamedParameterJdbcTemplate getNamedParameterJdbcTemplate() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; namedParameterJdbcTemplate;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setJdbcTemplate(JdbcTemplate jdbcTemplate) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.jdbcTemplate =&lt;span&gt; jdbcTemplate;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.namedParameterJdbcTemplate = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NamedParameterJdbcTemplate(jdbcTemplate);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getMysqlLowerCaseTableNames() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mysqlLowerCaseTableNames;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setMysqlLowerCaseTableNames(String mysqlLowerCaseTableNames) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mysqlLowerCaseTableNames =&lt;span&gt; mysqlLowerCaseTableNames;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String isShowSql() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; showSql;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setShowSql(String showSql) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.showSql =&lt;span&gt; showSql;
    }



}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;三：使用&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 数据源和JPA是同一数据源，在同一事务中，用的连接和JPA使用的是同一个连接，在CommonDao 额外注入一个  JdbcTemplateWrapper,当作处理复杂SQL的帮手。&lt;/p&gt;
&lt;p&gt;JdbcTemplateWrapper  常用的方法同如下几个：&lt;/p&gt;
&lt;p&gt;clasz 把查询结果要转为的类对像，内部再构造 ObjectRowMapper&lt;/p&gt;
&lt;p&gt;1：public List queryAllMatchListWithFreePra(String sql, Class clasz, Object... args)  // SQL 参数为问号占位符，使用参数小的情况&lt;/p&gt;
&lt;p&gt;2：public List queryAllMatchListWithParaMap(String sql, Class clasz, Map paramMap) // SQL 参数为 参数名占位符 ,如 name=:name, paramMap中 key 为参数名，value 为值数值; 如clasz 传为为空，实际返为 List&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt;,不为空侧为   List&amp;lt;Map&amp;lt;String,clasz&amp;gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;3：  以pageModel为载体实现分页&lt;/p&gt;
&lt;p&gt;   /**&lt;br/&gt;     *&lt;br/&gt;     * @param pageModel: 设置了查询SQL ，及查询参数 Map paramMap 的分页对像&lt;br/&gt;     * @param className&lt;br/&gt;     *            : 从查询结果集中构建出的类，如为null则pageModel的PageData为List&amp;lt;Map&amp;gt;，&lt;br/&gt;     *            不为null则pageModel的PageData为List&amp;lt;className&amp;gt;&lt;br/&gt;     * @param columnNameForCount:查询记录数时的字段名，一般用主键&lt;br/&gt;     */&lt;br/&gt;    @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })&lt;br/&gt;    public void fillPageModelData(PageModel pageModel, Class className)&lt;/p&gt;
&lt;p&gt;  4  ： 不用 pageModel 分页查询&lt;/p&gt;

&lt;p&gt;    /**&lt;br/&gt;     * 多表sql 分页查询,多表连查时，才用这个方法，其他请用commonDao的 SQL分页查询&lt;br/&gt;     *&lt;br/&gt;     * @param sql&lt;br/&gt;     * @param className&lt;br/&gt;     * @param paramMap&lt;br/&gt;     * @param pageNo&lt;br/&gt;     * @param PageSize&lt;br/&gt;     * @param columnNameForCount&lt;br/&gt;     * @return&lt;br/&gt;     */&lt;br/&gt;    @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })&lt;br/&gt;    public List queryAllMatchListWithParaMap(String sql, Class clasz, Map paramMap, int pageNo, int pageSize)&lt;/p&gt;

&lt;p&gt;5 ： 把list map 原生JDBC结果集中，字段名，也就是MAP中的KEY，转换为驼峰规则的JAVA对属性名&lt;/p&gt;

&lt;p&gt;    /**&lt;br/&gt;     * 把list map 原生JDBC结果集中，字段名，也就是MAP中的KEY，转换为驼峰规则的JAVA对属性名&lt;br/&gt;     * 方便前端组件使用，不再中间转为VO 或 实体类对像后，再返前端;比传统查询&lt;span&gt;（多了一个LIST的遍历 ，基本对性能影响不大）&lt;/span&gt;&lt;br/&gt;     * @param resultList ：JDBC 结果集&lt;br/&gt;     * @return    把MAP中的KEY转换为转换为驼峰规则的JAVA对属性名的LIST&amp;lt;map&amp;lt;驼峰规则的JAVA对属性名形式的KEY,Object&amp;gt;&amp;gt;&lt;br/&gt;     * @author itest andy&lt;br/&gt;     */&lt;br/&gt;    public void converDbColumnName2ObjectPropName(List&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt; resultList)&lt;/p&gt;

</description>
<pubDate>Mon, 15 Apr 2019 05:31:00 +0000</pubDate>
<dc:creator>我是刘阿牛</dc:creator>
<og:description>导读： 主要从4个方面来阐述，1：背景；2：思路；3：代码实现；4：使用 一：封装背景， 在做项目的时候，用的JPA ，有些复杂查询，比如报表用原生的JdbcTemplate ，很不方便；需要增加分页</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mypm/p/10709689.html</dc:identifier>
</item>
</channel>
</rss>