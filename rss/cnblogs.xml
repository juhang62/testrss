<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>用脚本应对业务不清析的情况 - CUBA-China</title>
<link>http://www.cnblogs.com/cubacn/p/scripting.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cubacn/p/scripting.html</guid>
<description>&lt;p&gt;原文：&lt;a href=&quot;https://www.cuba-platform.com/blog/in-any-incomprehensible-situation-go-scripting&quot;&gt;&lt;span&gt;In any incomprehensible situation go scripting&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;翻译&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;CUBA China&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;CUBA-Platform:&lt;a href=&quot;https://cuba-platform.com&quot;&gt;&lt;span&gt;https://cuba-platform.com&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CUBA-China:&lt;span&gt;&lt;a href=&quot;http://cuba-platform.cn&quot;&gt;http://cuba-platform.cn&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　让应用程序在运行时适应客户需求最常用的方法之一就是使用脚本。但是事物总有两面性，无一例外。脚本这种方法并非只有好的一面，我们需要在灵活性和可管理性之间权衡。本文不是在理论上讨论优缺点的文章，而是从实际出发，展示使用脚本的几种不同方式，并介绍了一个&lt;/span&gt;Spring库，这个库提供了方便的脚本基础设施和一些其他的有用功能。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　脚本（也称为插件架构）是使应用程序在运行时可自定义的最直接的方法。很多时候，脚本并不是设计到应用程序中的，只是偶尔会用到。比如说，在功能描述中有一部分描述地非常模糊，我们不能再耗费额外一天时间去分析这个描述模糊的业务。这时我们决定创建一个扩展点并调用一个脚本存根，然后在晚些时候再详细定义这个脚本的业务逻辑。&lt;/p&gt;
&lt;p&gt;　　使用这种方法有很多众所周知的优点和缺点：例如可以非常灵活地在运行时定义业务逻辑并且可以在重新部署方面节省大量时间，但是使用脚本也会导致不能对系统进行全面地测试，因此，会给系统在安全性、性能等方面带来不可预测的问题。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　后续对使用脚本的方式的讨论可能对已经决定在&lt;/span&gt;Java应用程序中坚持使用脚本插件的用户或正在考虑将其添加到代码中的用户都会有所帮助。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;直接编写脚本&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用&lt;/span&gt;Java JSR-233 API在Java中执行脚本是很简单的任务。有许多实现了此API的产品级脚本执行引擎，比如Nashorn、JRuby、Jython等。因此在java添加一些脚本的魔法很容易实现，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201901/1438872-20190108103353473-1383100356.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　显然，如果你的代码库中的脚本文件很多，那么将这些调用代码分散在整个应用程序并不好。因此，你可能会将此代码段提取到一个工具类的单独方法中。也可能会考虑地更远一些：创建一个专用的类（或一组类），根据业务领域对脚本化业务逻辑进行分组，比如：&lt;/span&gt;PricingScriptService类。这样我们就可以将对evaluateGroovy() 方法的调用封装到一个强类型的方法中，但这里仍然存在一些重复的代码：所有方法都包含构建参数Map、加载脚本文本以及调用脚本引擎的代码，类似于：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201901/1438872-20190108103512236-861416098.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这种方法在了解参数类型和返回值类型方面有更大的透明度。但是别忘了，需要在编码标准文档中添加一条：禁止调用&lt;/span&gt;“解包”了的脚本引擎！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;CUBA平台中增强版的脚本引擎&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　尽管使用脚本引擎非常简单，但如果代码库中有很多脚本，就可能会遇到一些性能问题。比如，在报表中使用&lt;/span&gt;groovy模板，并且同时运行大量报表。那么，你迟早会发现“简单”脚本成为性能瓶颈。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这就是为什么有些框架在现有&lt;/span&gt;API上构建自己的脚本引擎 ：添加一些功能来改善性能、监控脚本的执行、支持多种脚本语言，等等。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　例如，在&lt;/span&gt;CUBA框架中，有一个相当复杂的&lt;a href=&quot;https://doc.cuba-platform.com/manual-6.10/scripting.html?_ga=2.206061139.1358325695.1546313483-2145930198.1545295201&quot;&gt;&lt;span&gt;Scripting&lt;/span&gt;&lt;/a&gt;引擎，提供一些用于改善脚本实现和执行的功能，例如：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;对类进行缓存，&lt;/span&gt; &lt;span&gt;避免脚本的重复编译。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;使开发人员能够使用&lt;/span&gt;Groovy和Java语言编写脚本。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;提供用于脚本引擎管理的&lt;/span&gt;JMX bean。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;　　所有这些都改善了性能和可用性，但这些还只是用于创建参数&lt;/span&gt;Map、获取脚本文本等低级API，因此我们仍然需要将这些脚本分组到高阶模块，以便在应用程序中更高效地使用脚本。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在这里，有必要提一下&lt;/span&gt;GraalVM引擎，这是一个由Oracle开源实验性产品。GraalVM引擎及其多语言API允许开发人员使用其他语言扩展Java应用程序。所以，我们也许能看到Nashorn退役之时，我们也可以在同一个源文件中使用不同的编程语言。但是，这些还需要等待。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Spring 框架对脚本的支持&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Spring框架在JDK API之上内置了对脚本的支持，可以在org.springframework.scripting.* 包中找到很多有用的类。有执行器(evaluators)、工厂(factories)等所有用于构建脚本支持所需的工具。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　除了低级别&lt;/span&gt;API之外，Spring 框架还有一个可以在应用程序中简化脚本处理的实现 - 可以使用动态语言定义Bean，文档&lt;a href=&quot;https://docs.spring.io/spring/docs/current/spring-framework-reference/languages.html#dynamic-language-beans&quot;&gt;&lt;span&gt;&lt;span&gt;链接&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要做的就是使用像&lt;/span&gt;Groovy这样的动态语言实现一个类，并在配置XML中描述一个bean，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201901/1438872-20190108103555690-678782101.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　之后，就可以使用&lt;/span&gt;XML配置将Messenger bean注入到应用程序的类中。由于AOP的帮助，在Bean对应的脚本文件发生变化时，这个Bean可以自动“刷新”。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这种方法看起来不错，但是作为开发人员，如果想充分发挥动态语言的威力，应该为&lt;/span&gt;bean实现完整的类。在现实中，脚本可能是纯函数，因此需要在脚本中添加一些额外的代码使其与Spring兼容。此外，现在一些开发人员认为XML配置与注解相比，已经“过时”，并且尽量避免使用它，因为会觉得bean的定义和注入分散在Java代码和XML代码中。虽然这更像是审美问题而不是性能/兼容性/可读性等问题，但我们也许会把它考虑在内。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;脚本：挑战和想法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　任何事情都有代价，当为应用程序添加脚本支持功能时，可能会遇到一些挑战：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;可管理性&lt;/span&gt; - 通常脚本分散在应用程序中，因此管理大量的evaluateGroovy（或类似的）调用会很困难。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;可发现性&lt;/span&gt; - 如果在调用的脚本中出现问题，很难在源代码中找到实际的出错点。但是在IDE中能很轻松地找到所有脚本调用点。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;透明度&lt;/span&gt; - 编写脚本扩展并非是一件简单的事情，因为没有关于要传递给脚本的变量的信息，也没有关于脚本返回的结果的信息。最终，脚本只能由开发人员通过查看源代码完成。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;更新&lt;/span&gt; - 部署（更新）新脚本总是存在危险性，在用于生产环境之后很难进行回滚。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;　　将对脚本方法的调用隐藏在常规&lt;/span&gt;Java方法下似乎可以解决大部分这种问题。更好的方法是注入“脚本化”bean并使用有意义的名称调用其方法，而不是从通用类中调用另一个“eval”方法。这样，我们的代码将可以自描述，开发人员不需要查看文件“disc_10_cl.groovy”来确定参数名称、类型等。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　另一个优点&lt;/span&gt; - 如果所有脚本都有与之关联的唯一java方法，则可以使用IDE中的“Find Usages（查找用例）”功能轻松找到应用程序中的所有扩展点，同时也可以知道此脚本的参数和返回值是什么。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这种编写脚本的方式也使得测试变得更简单&lt;/span&gt; - 我们不仅可以“像往常一样”测试这些类，而且如果需要也可以使用Mocking框架。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　所有这些都再次提及本文开头提到的方法&lt;/span&gt; - 用于脚本化方法的“特殊”类。如果我们更进一步对开发人员隐藏对脚本引擎的调用、参数创建等操作用会怎么样？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;脚本仓库概念&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这个想法很简单，所有使用过&lt;/span&gt;Spring框架的开发人员都应该很熟悉。我们只是创建一个java接口，并以某种方式将其方法链接到脚本。举例来说，Spring Data JPA使用的就是类似的方法，其中接口方法基于其名称转换为SQL查询，然后由ORM引擎执行。&lt;/p&gt;
&lt;p&gt;　　实现这个概念可能需要什么？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可能需要一个类级别的注解来帮助我们检测脚本仓库接口并为它们构造一个特殊的&lt;/span&gt;Spring bean。&lt;/p&gt;
&lt;p&gt;　　还有一个方法级别的注解，可以帮助我们将方法链接到具体的脚本实现。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果给接口方法提供一个默认实现，这个实现不是简单的存根，而是一部分有效的业务逻辑，这样会更好。这样的话，在业务分析人员实现算法之前可以一直使用这个默认实现。或者我们可以让他&lt;/span&gt;/她（业务专家）自己来编写这个脚本 :-)。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　假设需要创建根据用户的个人资料计算折扣的服务。业务分析师表示，我们可以安全地假设默认情况下可以为所有注册客户提供&lt;/span&gt;10％的折扣。对于这种情况，我们可能会考虑以下概念代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201901/1438872-20190108103711194-2117291763.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当有了合适的折扣算法实现时，&lt;/span&gt;groovy脚本可以这样写：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201901/1438872-20190108103751040-1598249096.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这一切的最终目标是让开发人员只实现一个接口和折扣算法脚本，并且不需要笨拙地调用那些&lt;/span&gt; “getEngine” 和 “eval”方法。脚本解决方案应处理所有的逻辑：当方法被调用时拦截调用，查找并加载脚本文本，执行它并返回结果（如果没找到脚本文本，则执行默认方法）。理想的用法大概如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201901/1438872-20190108103823685-1322019145.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我想这种脚本调用具有可读性，并且这种调用方式对&lt;/span&gt;java开发人员来说不会陌生。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这些是想法，并且用这些想法来基于&lt;/span&gt; Spring Framework 创建脚本仓库的实现库。这个库包含从不同来源加载并执行脚本的基础设施，同时也提供了一些API, 开发人员可以使用这些API对这个库进行扩展。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;它如何工作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这个库创建了一些注解（以及&lt;/span&gt;XML配置，有的开发人员可能偏好于使用XML配置），在上下文初始化期间，为使用@ScriptRepository注解的所有Repository接口初始化动态代理。这些代理发布为实现Repository接口的单例bean，这意味着可以使用@Autowired或@Inject将这些代理注入到bean中，如上一节中的代码片段所示。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在其中一个应用程序的配置类上使用&lt;/span&gt;@EnableScriptRepositories注解来激活脚本Repositories。这种方法类似于开发人员熟知的其它Spring 注解（如 @EnableJpaRepositories 或 @EnableMongoRepositories）。对于此注解，需要指定应与 JPA repository相似的扫描包名数组。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201901/1438872-20190108103908461-845419528.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如前面所示，我们需要使用&lt;/span&gt; @ScriptMethod 注解来标记脚本Repository中的每个方法（库也提供 @GroovyScript 和 @JavaScript），为方法调用添加元数据并注明这些方法是脚本方法。当然，也支持脚本方法的默认实现。这个解决方案的所有组件都显示在下图中。蓝色图形与应用程序代码相关，白色图形与库相关。Spring bean 有 Spring Logo 。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201901/1438872-20190108103927360-361504567.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当调用接口的脚本方法时，它会被代理类拦截，代理类会查找两个&lt;/span&gt; bean  - 一个是用于获取实现脚本内容的provider，另一个是用于获取执行结果的evaluator。在脚本执行之后，结果将返回给脚本的调用方。可以用 @ScriptMethod 注解属性指定provider和evaluator以及执行超时（这个库也为这些属性提供了默认值）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201901/1438872-20190108103955620-631318784.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　你可能会注意到&lt;/span&gt; @ScriptParam 注解 - 我们使用它们为方法的参数提供名称，这些名称应该用在脚本中，因为 Java 编译器会在编译时删除实际的参数名称。也可以不用这个注解，此时，需要以 “arg0”、“arg1” 等来命名脚本参数，只是这会影响代码的可读性。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　默认情况下，这个库提供可以从文件系统读取&lt;/span&gt; groovy 和 javascript 文件的provider以及用于两种脚本语言的基于JSR-233 的 evaluator。可以为不同的脚本存储和执行引擎创建自定义的provider和evaluator。所有这些设施都基于 Spring 框架接口（org.springframework.scripting.ScriptSource 和 org.springframework.scripting.ScriptEvaluator），因此可以复用所有基于 Spring 的类。例如，使用StandardScriptEvaluator代替默认的类。&lt;/p&gt;
&lt;p&gt;　　Provider（以及evaluator）会作为 Spring bean 发布，为了提高灵活性，脚本repository代理会按名称解析 - 可以在不更改应用程序代码的情况下将默认执行程序替换为另外一个，只是在应用程序上下文中替换一个 bean。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;测试和版本控制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　由于脚本很容易更改，因此我们需要确保在改变脚本时不会破坏生产服务器。这个库与&lt;/span&gt; JUnit 测试框架兼容，这里没有特殊之处。由于在基于 Spring 的应用程序中使用这个库，因此在将脚本更新到生产环境之前，可以使用单元测试和集成测试将脚本作为应用程序的一部分来测试，测试中也支持模拟（mocking）框架。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　此外，可以创建一个脚本&lt;/span&gt;provider，从数据库甚至从 Git 或其它源代码控制系统读取不同版本的脚本文本。在这种情况下，如果生产环境中出现问题，可以很容易切换到新版本的脚本或回滚到之前版本的脚本。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　这个库有助于在代码中使用脚本，提供以下功能：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;通过引入&lt;/span&gt; java 接口，开发人员可以获取到脚本参数及其类型信息。&lt;/li&gt;
&lt;li&gt;Provider和evaluator可以避免分散在饮用程序各处的脚本引擎调用。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;我们可以使用&lt;/span&gt; “Find usages (references)” IDE 命令或只通过方法名称进行简单的文本搜索就能轻松找到应用程序代码中的所有脚本使用的地方。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;　　另外，这个库也支持&lt;/span&gt;Spring Boot自动配置，并且还可以使用熟悉的单元测试和模拟（mocking ）技术在脚本部署到生产环境之前对其进行测试。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这个库有一个用于在运行时获取脚本元数据（方法名称、参数等）的&lt;/span&gt; API，也可以获取封装后的执行结果，如果不想编写 try..catch 块来处理脚本抛出的异常的话，另外，如果更习惯用XML格式来存储配置的话，这个库也支持。&lt;/p&gt;
&lt;p&gt;　　此外，可以使用注解的超时时限参数对脚本执行时间进行限制。&lt;/p&gt;
&lt;p&gt;　　这个库的源码：&lt;a href=&quot;https://github.com/cuba-rnd/spring-script-repositories&quot;&gt;&lt;span&gt;https://github.com/cuba-rnd/spring-script-repositories&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201901/1438872-20190108104043510-1807512802.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Tue, 08 Jan 2019 22:54:00 +0000</pubDate>
<dc:creator>CUBA-China</dc:creator>
<og:description>原文：In any incomprehensible situation go scripting 翻译：CUBA China CUBA-Platform:https://cuba-platform.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cubacn/p/scripting.html</dc:identifier>
</item>
<item>
<title>C# Memory Cache 踩坑记录 - 码农阿宇</title>
<link>http://www.cnblogs.com/CoderAyu/p/10242230.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CoderAyu/p/10242230.html</guid>
<description>&lt;p&gt;前些天公司服务器数据库访问量偏高,运维人员收到告警推送,安排我团队小伙伴排查原因.&lt;/p&gt;
&lt;p&gt;我们发现原来系统定期会跑一个回归测试,该测运行的任务较多,每处理一条任务都会到数据库中取相关数据,高速地回归测试也带来了高频率的数据库读取.&lt;/p&gt;

&lt;p&gt;我们认为每个任务要取的数据大相径庭,因此我们考虑对这个过程进行修改,加入MemoryCache把数据库中读取到的数据进行缓存.&lt;/p&gt;
&lt;p&gt;整个修改非常简单,相信对常年混迹在博客园中的各位大佬来说小菜一碟,因此小弟不再叙述添加缓存的步骤细节.&lt;/p&gt;
&lt;p&gt;从缓存的添加,代码提交,Teamcity 编译通过,到测试环境,QA环境的安装无比流畅,一切显得如手到擒来.&lt;/p&gt;
&lt;p&gt;嗯,优秀是一种习惯, 没有一点办法.&lt;/p&gt;
&lt;p&gt;人生如戏,当我们还沉浸在&quot;我加的Cache不可能又BUG&quot;的自信中时,QA传来噩耗,回归测试大量未通过 ....&lt;/p&gt;

&lt;p&gt;之前习惯了使用Redis缓存,因此,常识告诉我们 ---  在数据库中数据没有改动的前提下,加了缓存后读取的数据的效果和从数据库中读取的效果是一模一样的.&lt;/p&gt;
&lt;p&gt;除非  ,,,   除非  这个常识是错误的....&lt;/p&gt;
&lt;p&gt;因此我们加了日志,对写入缓存前后读取出来的数据进行了对比,结果出人意料.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1293736/201901/1293736-20190109005329355-153902224.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1293736/201901/1293736-20190109005329675-756142097.png&quot; alt=&quot;image&quot; width=&quot;680&quot; height=&quot;139&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;该死 MemoryCache 毁我老脸,丢我精度,拿命来!!!!!&lt;/p&gt;
&lt;p&gt;从日志中看到,第一行是从数据库中读取的结果,第二行是从cache中读取的,前两条数据完全一致,到了第三条,第四条,第五条,仔细观察发现,在小数点后面,居然有些小数点后比较微小的变化,不管变化的大小但数据确实发生改变了,所以MemoryCache会影响数据精度??这样会改变数据精度的MemoryCache又有何用?? &lt;/p&gt;
&lt;p&gt;机智的我,似乎早已看穿了一切,这肯定不是MenoryCache的锅!!!&lt;/p&gt;

&lt;p&gt;我从&lt;a title=&quot;https://referencesource.microsoft.com&quot; href=&quot;https://referencesource.microsoft.com&quot;&gt;https://referencesource.microsoft.com&lt;/a&gt; 中扒出了MemoryCache的源码一探究竟.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1293736/201901/1293736-20190109005330144-1017692323.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1293736/201901/1293736-20190109005330364-1573619005.png&quot; alt=&quot;image&quot; width=&quot;687&quot; height=&quot;442&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;定位到MemoryCache中的AddOrGetExisting方法,我们看到,其实我们把数据存储到该缓存的过程本质是把该对象存到一个名为_entries的         Hashtable 中,同样,取数据也是通过Key到该Hashtable中取出来,整个过程并没有对该对象进行序列化反序列等,也没有对该对象进行clone操作.这就意味着我们之前存入的,和后面取出的(不管我们从MemoryCache中取数据取多少次),永远只取出同一个对象.&lt;/p&gt;
&lt;p&gt;这一点,和我之前使用的RedisCache是有很大区别的.我们在Redis中存入数据,是把对象序列化后存到Redis中,取数据是把Redis中的字节数据反序列成对象,意味着前一次存入的,和后一次取出的,已经不是同一个对象了,因此Redis中的数据是安全的.&lt;/p&gt;

&lt;p&gt;我做出了一个大胆的猜想,之前从MemoryCache中取出来的数据之所以变化了,可能是取出对象后,复杂的处理过程中对该对象进行了什么修改操作,所以后期,再次从数据库中读取数据,读出来的已经已经不是最初存入的数据,而是前一次修改之后的数据.带着这个猜想,我对代码进行了修改.&lt;/p&gt;

&lt;p&gt;从MenoryCache中取到数据后对结果进行clone(),这样即使程序对取出来的结果进行了修改也不会影响Cache中的数据了.&lt;/p&gt;
&lt;p&gt;又是一次提心掉到的提交,编译,安装后, 回归测试顺利通过.&lt;/p&gt;
&lt;p&gt;感觉人生到达了高潮   -_-&lt;/p&gt;
&lt;p&gt;把踩得坑分享出来,希望后面的小伙伴引以为鉴,&lt;/p&gt;
</description>
<pubDate>Tue, 08 Jan 2019 16:54:00 +0000</pubDate>
<dc:creator>码农阿宇</dc:creator>
<og:description>背景 前些天公司服务器数据库访问量偏高,运维人员收到告警推送,安排我团队小伙伴排查原因. 我们发现原来系统定期会跑一个回归测试,该测运行的任务较多,每处理一条任务都会到数据库中取相关数据,高速地回归测</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CoderAyu/p/10242230.html</dc:identifier>
</item>
<item>
<title>es6学习笔记-class之一概念 - 热爱前端的17号诶</title>
<link>http://www.cnblogs.com/sqh17/p/10236735.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sqh17/p/10236735.html</guid>
<description>&lt;p&gt;前段时间复习了面向对象这一部分，其中提到在es6之前，Javasript是没有类的概念的，只从es6之后出现了类的概念和继承。于是乎，花时间学习一下class。&lt;/p&gt;
&lt;h4 id=&quot;简介&quot;&gt;简介&lt;/h4&gt;
&lt;p&gt;JavaScript 语言中，生成实例对象的传统方法是通过构造函数来创建的。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function Person (name,age){
    this.name = name;
    this.age = age;
}
Person.prototype.say=function(){  // 不能使用箭头函数（我差点忘记）,因为 箭头函数没有prototype属性
    alert(this.name);
}
var peter = new Person('peter',25);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;es6提出了一个关键字class，把上述例子中简化成了传统的面向对象语言java，c++等创建类的形式。 ps：Javascript 的保留关键字不可以用作变量、标签或者函数名。有些保留关键字是作为 Javascript 以后扩展使用。&lt;/p&gt;
&lt;h5 id=&quot;class定义类简单方式&quot;&gt;class定义类简单方式：&lt;/h5&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class Person{
    constructor(name,age){
        this.name = name;
        this.age = age;
    }
    say(){
        alert(this.name)
    }
}
var peter = new Person('peter',25);&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;这几步骤中：
1. Person 这是类名，对应就是es5中构造函数名。
2. 里面创建的都是方法。
3. 其中有constructor方法，就叫构造方法，this关键字则代表实例对象，这个方法对应的就是es5的构造函数。
4. 还有个除了constructor方法的其他方法，say方法，对应的就是es5中挂载到其构造函数的prototype属性上的方法。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ps：1 定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去就行，否则报错。 2 方法之间不需要逗号分隔，加了会报错。 3 class定义类名，虽然是对象形式，但不是对象，而是函数。&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;typeof Person  // &quot;function&quot;
Person.prototype.constructor == Person   // true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这说明了类的数据类型就是函数，类本身就指向构造函数。&lt;br/&gt;  类和普通的构造函数的区别：&lt;br/&gt;    * 类的调用必须用new来实例化。&lt;br/&gt;    * 类的内部所有定义的方法是不可枚举的。&lt;br/&gt;    * 类的内部已经采用的是严格模式。&lt;br/&gt;    * 类的内部不存在变量提升。&lt;/p&gt;
&lt;h5 id=&quot;class表达式&quot;&gt;class表达式&lt;/h5&gt;
&lt;p&gt;与函数一样，类也可以使用表达式的形式定义。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;    const Person = class {
        constructor(){}
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以用这样的方式定义。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;    const MyClass = class Me {
        getClassName() {
            return Me.name;
        }
    };&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，这个类的名字是&lt;code&gt;MyClass&lt;/code&gt;而不是Me，Me只在 Class 的内部代码可用，指代当前类。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;    let inst = new MyClass();
    inst.getClassName() // 'Me'
    console.log(Me.name)  // Uncaught ReferenceError: Me is not defined&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;tip:
    name 属性
    由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性,name属性总是返回紧跟在class关键字后面的类名。
    class Point {}
    Point.name // &quot;Point&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;constuctor方法&quot;&gt;constuctor方法：&lt;/h5&gt;
&lt;p&gt;每个类中都有默认的construtor方法，通过new命令生成对象实例时，自动调用该方法。即使没有显式定义constructor方法，也会有默认的construtor方法。 constructor方法默认返回实例对象（即this）,也可以指定返回另外一个对象。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class Person{
    constructor(name,age){
        this.name = name;
        this.age = age
    }
}
var peter = new Person('peter',25);
peter instanceof Person   // true;
class Person{
    constructor(){
        var child = {
            name:'jerry',
            age:10
        }
        return child
    }
}
var peter = new Person();
peter instanceof Person   // false;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面两个例子说明了，在没有指定返回的对象情况下，默认返回实例对象，有指定返回的对象，则返回该对象，但返回的对象就不是类的实例了。&lt;br/&gt;另外：实例属性的新写法： // &lt;code&gt;error&lt;/code&gt;&lt;br/&gt;实例属性除了在constructor()方法里面定义，也可以直接写在类的最顶层。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class Person{
    name = 'peter';
    say(name){
        console.log(name)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;类的实例对象&quot;&gt;类的实例对象：&lt;/h5&gt;
&lt;p&gt;同es5的构造函数的实例一样：&lt;code&gt;实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）&lt;/code&gt;。 大白话就是：实例的属性如果没有显式定义到constructor上，那么就是定义在除了constructor以外的方法中。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class Person{
    constructor(name,age){
        this.name = name;
        this.age = age;
        this.skill = function(){
            alert('running')
        }
    }
    say(){
        alert(this.name)
    }
}
var peter = new Person('peter',25);
console.log(peter.hasOwnProperty('name'));   // true
console.log(peter.hasOwnProperty('age'));    // true
console.log(peter.hasOwnProperty('skill'));  // true
console.log(peter.hasOwnProperty('say'));    // false
console.log(peter.__proto__.hasOwnProperty('say'))  // true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上述可知：凡是在constructor方法里的属性都是实例对象中的都返回为true，不在constructor方法里的都是类的原型上的属性。&lt;br/&gt;tip：&lt;br/&gt;      object.hasOwnProperty(proName) 确定某个对象是否具有带指定名称的属性。&lt;br/&gt;        参数解释：&lt;br/&gt;        object&lt;br/&gt;          必需。对象的实例。&lt;br/&gt;        proName&lt;br/&gt;          必需。一个属性名称的字符串值。（是个字符串!）&lt;br/&gt;      说明：&lt;br/&gt;        如果 object 具有带指定名称的属性，则 hasOwnProperty 方法返回 true，否则返回 false。&lt;br/&gt;        此方法不会检查对象原型链中的属性；该属性必须是对象本身的一个成员。&lt;br/&gt;&lt;code&gt;同es5一样，类的所有实例共享一个原型对象&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var peter = new Person('peter',25);
var tom = new Person('tom',18);
console.log(tom.__proto__ == peter.__proto__)  // true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这说明了，peter，tom都是一个类的实例化对象，共享这一个类的所有属性和方法。&lt;br/&gt;根据原型共享，如果在一个实例对象上更改原型上的值，会直接影响到其他实例，所以一般不建议使用这种方式更改原型的值。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;tom.\__proto\__.skill = function(){
    alert('running');
}
tom.skill();  // running
peter.skill();  // running&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此&lt;code&gt;最好不要通过实例去更改类的值&lt;/code&gt;。&lt;/p&gt;
&lt;h5 id=&quot;this的指向-不懂&quot;&gt;this的指向 （不懂）&lt;/h5&gt;
&lt;p&gt;类的方法内部如果含有this，它默认指向类的实例，如果单独提取该方法调用this会报错&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class Print{
    printName(name){
        this.print(name);
    }
    print(text){
        alert(text);
    }
}
var hello = new Print();
var {printName} = hello;    //对象的解构,printName == hello.printName,为何找不到this的指向？
printName('peter');  // Cannot read property 'print' of undefined&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解决办法：&lt;br/&gt;1 在constructor方法中绑定this。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;  constructor(){
      this.printName = this.printName.bind(this);
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2 使用箭头函数。&lt;br/&gt;&lt;code&gt;printName(name)=&amp;gt;{this.print(name)};&lt;/code&gt;&lt;br/&gt;3 使用proxy（待学习）&lt;/p&gt;
&lt;h5 id=&quot;私有属性和私有方法&quot;&gt;私有属性和私有方法&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;所谓的私有方法和私有属性，只能在类中供其他方法使用&lt;/code&gt;。 有两种方式可以声明私有方法和私有属性&lt;br/&gt;1 将要调用的方法放到类的外部，在类的内部，通过call，apply进行调用。&lt;br/&gt;&lt;code&gt;javascript class Print{ printName(name){ print.call(this,name); } } function print(text){alert(text)} var hello = new Print(); hello.printName('peter'); // peter&lt;/code&gt;&lt;br/&gt;这种方式是把私有方法放到外部，不能被调用，这意思是说的在类的内部是访问不到print方法的。&lt;br/&gt;2 使用sybmol类型。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var print = Symbol('print');
class Print{
    printName(name){
        this[print](name);
    }
    [print] (text){
        alert(text);
    }
}
var hello = new Print();
hello.printName('peter');  // peter&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;symbol类型保证了是独一无二的，导致第三方获取不到,达到了私有的效果。&lt;/p&gt;
&lt;h5 id=&quot;class的取值函数和存值函数&quot;&gt;class的取值函数和存值函数&lt;/h5&gt;
&lt;p&gt;与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class Person{
    constructor(){

    }
    get height(){
        return this._height
    }
    set height(value){
        this._height = value
    }
}
var peter = new Person();
peter.height = 12344;  // 设置身高
console.log(perter.height)   // 12344&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当一个属性只有get没有set的时候，我们是无法进行赋值操作的,第一次初始化也不行。 如果把变量定义为私有的(定义在类的外面),就可以只使用get不使用set。&lt;/p&gt;
&lt;h5 id=&quot;class-的-generator&quot;&gt;Class 的 Generator&lt;/h5&gt;
&lt;p&gt;在类的某个方法的前面加上星号，可以代表这是个generator函数。可以用generator的方式去运用这个方法。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class Person{
    *sum(x,y,z){
        yield x + y;
        yield y + z;
        yield x + y +z;
    }
}
var a = new Person();
for(let i of a.sum(1,2,3)){
    console.log(i);
} // 3  5  6&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;class的静态方法&quot;&gt;class的静态方法&lt;/h5&gt;
&lt;p&gt;类相当于实例的原型，所有在类中定义的方法，都会被实例继承。 如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class Person{
    static print(text){
        alert(text);
    }
    printName(name){
        this.print(name);
    }
}
Person.print('peter')   // peter
var peter = new Person();
peter.print('peter');   //  peter.print is not a function&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码表示：可以直接在Person类上调用（Person.print('peter')），而不是在Person类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。&lt;br/&gt;  如果静态方法包含this关键字，这个this指的是类，而不是实例。&lt;br/&gt;  静态方法可以与非静态方法重名。(就是static的方法是一个，非static的方法是一个，两者无关联)。&lt;br/&gt;  父类的静态方法，可以被子类继承。&lt;/p&gt;
&lt;h5 id=&quot;new.target属性&quot;&gt;new.target属性&lt;/h5&gt;
&lt;p&gt;new是从构造函数生成实例对象的命令 ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function Person(name) {
  if (new.target === Person) {
    this.name = name;
  } else {
    throw new Error('必须使用 new 命令生成实例');
  }
}
var peter = new Person('peter');
var notAPerson = Person.call(peter, 'peter');  // 报错 必须使用 new 命令生成实例&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Class 内部调用new.target，返回当前 Class。&lt;br/&gt;子类继承父类时，new.target会返回子类。&lt;br/&gt;用处：可以写出不能独立使用、必须继承后才能使用的类。&lt;/p&gt;
&lt;h5 id=&quot;继承&quot;&gt;继承&lt;/h5&gt;
&lt;p&gt;因篇幅过长，放到下一篇文章&lt;a href=&quot;https://www.cnblogs.com/sqh17/p/10236753.html&quot;&gt;es6学习笔记-class之继承&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 08 Jan 2019 16:45:00 +0000</pubDate>
<dc:creator>热爱前端的17号诶</dc:creator>
<og:description>前段时间复习了面向对象这一部分，其中提到在es6之前，Javasript是没有类的概念的，只从es6之后出现了类的概念和继承。于是乎，花时间学习一下class。 简介 JavaScript 语言中，生</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sqh17/p/10236735.html</dc:identifier>
</item>
<item>
<title>MySQL的使用及优化 - 纪莫</title>
<link>http://www.cnblogs.com/jimoer/p/10226952.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jimoer/p/10226952.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;最近听了公司里的同事做的技术分享，然后觉得对自己还是挺有帮助的。都是一些日常需要注意的地方，我们目前在开发过程中，其实用不到MySQL太深的内容的。只是能适用我们日常开发的知识就可以了。所以我将自己的理解和学习总结也写出来，供大家一起分享。&lt;/p&gt;
&lt;p&gt;大体分四部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;数据库优化概述&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据库表设计&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;索引原理及优化&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可扩展性设计&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;strong&gt;数据库优化概述&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;优化金三角&lt;/h3&gt;
&lt;p&gt;做数据库优化一般是由以下几种方式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201901/772743-20190106001708945-1406546921.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;成本和效果成反比。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务器硬件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;增强服务器的硬件方式不同的方式：例如增加磁盘配置（SSD，PCRE），增大内存，增加CPU配置等。增强服务器硬件在一定的阶段内确实可以达到不错的效果，但是并不是长久之计，如果不注重下面的三种策略，一味的增加硬件配置，会适得其反。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系统及数据库配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;随着系统硬件的不断更新迭代，数据库的配置也是不断变化的。例如以前的机械硬盘性能并不很好，所以数据库的配置并没有设置太高。当服务器普遍的都是SSD后数据库的系统配配置也是可以随之变化的。另外随着业务的变化以及数据量的增长，数据库的配置也是随着变化的。但是这部分的配置带来的效果并不太明显，和增加服务器硬件类似。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据库表设计及规划&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据库的表在设计之初就应该考虑好了以后的规划。不然当发现数据库产生瓶颈了再去优化，成本会很高。所以也需要开发人员能通过对业务的深刻理解来对数据库做好长远的规划。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SQL及索引优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对SQL语句以及索引的优化可以说是成本最低的了，效果也是非常显著的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这四部分内容，总有人觉得SQL及索引优化是最重要的，但是本人觉得最重要的是数据库表设计以及规划，如果能根据业务将表设计好了，根本是不需要进行索引优化的。如果数据库没有规划好，再好的DBA给你做SQL优化，效果也是杯水车薪的。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;MySQL逻辑架构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201901/772743-20190106005013286-375362244.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面这幅图是MySQL的基本逻辑架构图，主要分为四层。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;连接层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过MySQL的连接地址去访问MySQL的数据库，以及对访问信息的校验。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对SQL语句的校验，以及对SQL的优化和优化策略选择，最后发送到执行器去执行SQL。还包括MySQL的查询缓存也在这一层。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引擎层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MySQL是插件式存储引擎，最终将数据存到硬盘时不同的引擎有不同的组织方式。上面列出了一些引擎，常见InnoDB，MyISAM等，只要符合MySQL的接口规范，MySQL是支持自定义的引擎。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;存储系统层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这部分主要是数据存储，将数据存到磁盘，磁盘的IO读写等过程。&lt;/p&gt;
&lt;h2&gt;数据库表设计&lt;/h2&gt;
&lt;h3&gt;引擎的选择&lt;/h3&gt;
&lt;p&gt;请使用InnoDB存储引擎，慎用MyISAM引擎。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201901/772743-20190106230322728-2052586890.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图是InnoDB引擎和MyISAM引擎的一些区别对比。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ACID事务支持&lt;/strong&gt;：由于我们介绍这次介绍MySQL的时候是以&lt;strong&gt;OLTP（on-line transaction processing：联机事务处理）&lt;/strong&gt;为主的，而非&lt;strong&gt;OLAP（On-Line Analytical Processing：联机分析处理）&lt;/strong&gt;，所以事务处理是很重要的，这也就是为什么强烈要求使用InnoDB引擎的一个原因。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;锁粒度&lt;/strong&gt;：MyISAM支持的锁粒度是表级锁，表级锁的意思是指当一张数据表被锁住后，其他的对这张表的操作（DML）都要等着前一个锁释放了才可以执行。所以当并发量高时用户体验是很不好的。而InnoDB引擎的行级锁，只是对表的一部分数据进行加锁，所以能很好的支持并发，降低了对同一张表的操作冲突。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;外检约束&lt;/strong&gt;：虽然InnoDB支持外键，MyISAM不支持外键。但是也不建议在日常的使用过程中用外键，因为每次操作外键时都要去检查一下外键关联的数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全文索引&lt;/strong&gt;：InnoDB引擎不支持全文索引，但是MyISAM支持。但是在数据库中建立全文索引其实并不是什么好的策略，还是建议如果需要建立全文索引的时候考虑使用搜索引擎工具如：ElasticSearch，Solr等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;崩溃安全&lt;/strong&gt;：InnoDB支持崩溃安全，MyISAM是不支持的崩溃安全的。&lt;/p&gt;
&lt;p&gt;什么是崩溃安全呢？&lt;/p&gt;
&lt;p&gt;举个例子🌰：当一台服务器的上的数据库突然挂了，或是服务器崩溃了，甚至是突然断电了。这个时候如果MySQL使用的是InnoDB引擎，那么在数据库恢复后或是重新通电后，会执行崩溃恢复，就是未执行完的事务会继续执行，该回滚的回滚，该执行完的执行完，能确保数据的一致性。但是如果MySQL是使用的InnoDB引擎，那么首先MyIAM不支持事务，所以会造成数据的不一致性，而且如果在对表进行操作时断电，导致没有正确的关闭表，还会导致存储文件的损坏，在恢复通电后对这张表的任何读写操作都不能执行了。而且就算手动恢复数据也是比较麻烦的。&lt;/p&gt;
&lt;h3&gt;表设计-规划&lt;/h3&gt;
&lt;p&gt;在设计表时要遵循几个基本原则：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;线上业务尽量避免使用外键、存储过程、分区表、触发器等。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不在数据库中存储图片、文件等大数据。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;尽量避免使用TEXT\BLOB等类型的大字段。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拆分大字段和访问频率低的字段，分离冷热数据。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;不同的业务使用不同的数据库，禁止混合使用&lt;/span&gt;。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第一条基本原则，是为了防止随着业务的发展以后如果数据量大到一定程度了需要分表时，拆分带有这些特性的表时成本是非常大的。&lt;/p&gt;
&lt;p&gt;第二条、第三条 、第四条都是说大字段或大文件是不建议存储到MySQL当中的，因为对这些数据的操作MySQL是有特殊的存储方式的，性能很差。如果存储了这些数据后，再有一些排序或者是聚合操作的话会直接在磁盘中建立临时文件表，普通的字段类型例如varchar类型的，在有聚合操作时是会在内存中进行临时存储的。&lt;/p&gt;
&lt;p&gt;第五条原则是要求对业务有长远的规划，不同的业务首先要分表，其次要分库。虽然MySQL的很强大，但是单节点的能力是有限的。所以企业级的数据库都是分布式的，要为以后业务的增长数据的访问量增长做好充分的规划。&lt;/p&gt;
&lt;h3&gt;字段类型选择&lt;/h3&gt;
&lt;h4&gt;VARCHAR(N)：只分配真正需要的空间&lt;/h4&gt;
&lt;p&gt;例如：使用VARCHAR(5)和VARCHAR(200)存储'hello'的空间开销是一样的，使用更短的列有什么优势吗？&lt;/p&gt;
&lt;p&gt;虽然存储开销是一样的，但是如果对这个字段进行聚合操作（order by、group by等），这个时候是需要先将临时数据存储到内存中的，但是申请内存空间时是按照字段的定义大小来申请的，也就是说VARCHAR(200)申请的内存空间是VARCHAR(5)的40倍。还有一种情况是，当一个表的数据量很大时，要做数据迁移或是大数据分析时，是需要抽取全表数据的，这个时候读全表数据是无法靠申请内存空间来实现的，MySQL是会在磁盘中建立临时文件表。并且是按照字段定义的大小来占用磁盘空间的，如果一个200G的硬盘，但是表中的数据是50G，在抽取全表数据时会有可能将磁盘占满的。&lt;/p&gt;
&lt;p&gt;所以，&lt;span&gt;&lt;strong&gt;更大的定义列会消耗更多的内存，在使用内存临时表进行排序或操作时会根据定义的长度进行内存分配。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;数值类型vs字符串类型vs时间类型vs枚举类型&lt;/h4&gt;
&lt;p&gt;在给字段选择类型时，尽量遵循【小而简单】的原则，但是可以根据可以读性等因素适当调整。&lt;/p&gt;
&lt;p&gt;例如：在存储时间字段时，有的人使用int类型（4个字节），有的人使用datetime(8个字节)，虽然说占用的空间小了，但是可读性也变差了。而且就即使是类型选择的稍微不太合理，这部分也是可以通过对SQL的优化等操作来减小影响的。&lt;/p&gt;
&lt;p&gt;还有就是例如存储性别的时候，咱们使用tinyint，而不使用枚举类型，因为如果以后又多了一种类型（😏），这种操作是需要进行改表的，成本比用tinyint类型大很多。&lt;/p&gt;
&lt;h4&gt;表字段个数vs表记录行数vs表物理文件大小&lt;/h4&gt;
&lt;p&gt;单个表的字段数到了一定程度是建议拆表的，但是具体的峰值是根据实际的业务来看的，还有就是一个表的记录行数也是不建议很多，当到达一定量时再进行聚合操作是性能很差的。当表的数据量很大时增加字段也是需要消耗成本的，需要copy表中数据然后重新建表，这样才能保证线上的数据在加字段时是热处理。表物理文件的大小也是根据实际需求来考虑是否拆分的，如果表中只是追加操作，而且查询操作很不频繁，呢么拆表就可以慢慢考虑。这部分内容不做过多的讨论。&lt;/p&gt;
&lt;h2&gt;索引工作原理及优化&lt;/h2&gt;
&lt;h3&gt;InnoDB表索引结构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201901/772743-20190107005222880-418571754.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的图介绍的是InnoDB的索引结构，分为两部分聚簇索引和辅助索引。&lt;/p&gt;
&lt;p&gt;聚簇索引也是主键索引，InnoDB表都是有主键的，就算是没有给表创建主键，MySQL也会默认的创建一个主键，聚簇索引每一个叶子节点代表的是主键的键值，最末端指向的是主键所在的那行数据记录。&lt;/p&gt;
&lt;p&gt;辅助索引也是非聚簇索引，辅助索引就是日常表中除了主键以外的其他索引，每个叶子节点都代表的是索引的字段值，最末端指向的是索引值的主键。&lt;/p&gt;
&lt;p&gt;在创建索引时需要注意，常用的有int类型，bigInt类型。首先这些类型是占用字节数少，并且是有序的。在建立辅助索引时能节省空间，因为每个辅助索引记录后面都带着一个主键索引，如果主键是uuid或是MD5值一类的，那么在建立辅助索引后会占用很大的磁盘空间，并且在按照主键去查询的时候主键值是要加载到内存中的，所以综合考虑还是int、bigInt更好一些。&lt;/p&gt;
&lt;p&gt;例如下图的例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201901/772743-20190107225434190-1068123598.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主键之外将name字段设置为索引。索引类型是varchar并且每个索引记录后面都跟着一个主键值，这个索引其实是很耗性能的。&lt;/p&gt;
&lt;h3&gt;MyISAM表索引结构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201901/772743-20190107225953299-548831362.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相对于InnoDB来说，MyISAM引擎的主键也是指向主键所在的记录的，但是辅助索引就不一样了，辅助索引最终也是指向数据记录的。MyISAM引擎的在数据存储的物理位置上有一个物理位置的编号。然后无论是主键还是辅助索引都是指向这个编号的。&lt;/p&gt;
&lt;p&gt;如下图的例子所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201901/772743-20190107231642940-1294208452.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;索引优化&lt;/h3&gt;
&lt;h4&gt;主键原则（InnoDB）&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;表必须有主键。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不使用更新频繁的列。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;忌用字符串列做主键。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不使用UUID/MD5等生成的随机数做主键。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推荐用独立于业务的AUTO_INCREMENT列或全局ID生成器做代理主键。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;表必须有主键，即使没有主键InnoDB也会自动生成一个，如果使用频繁更新的列做主键，那主键的B+树不是一个稳定的结构，很耗磁盘开销，以及主键性能大大降低，上面已经说了字符串类型做主键会占用大量磁盘空间。不适用随机数做主键，是为了防止有磁盘空洞，产生不连续的空间。&lt;/p&gt;
&lt;h4&gt;最左前缀&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201901/772743-20190107233727585-1531913053.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目前的MySQL确实是有最左前缀的规则，即a_b_c索引，查询b和c时不走联合索引，但是随着MySQL的不断发展，现在又出现了一种叫做“索引下推”的概念，虽然不是代表着b和c使用时就能走索引了，但是看趋势可能以后会出现这种优化。最左前缀内容就不做过多的介绍了。&lt;/p&gt;
&lt;h4&gt;覆盖索引&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201901/772743-20190107234900819-1164474749.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先介绍一下，回表的概念，InnoDB引擎的表是必须有主键的，但是当存在辅助索引时，辅助索引在索引记录中存储的是主键值。当通过二级索引去查询非辅助索引包含的字段时，是先根据辅助索引查询到相应的主键值，然后再根据主键值去查询到相应的记录。这个查询两次的过程就是回表。如果一个联合索引由a、b、c三个字段组成，那么“select b,c from test where a = 100”这个SQL就不需要产生回表的，因为只查询联合索引就能得到想要的结果了。&lt;/p&gt;
&lt;h3&gt;谨慎合理添加索引&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;改善查询效率&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;避免排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据率重&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;减慢插入和更新的效率。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;索引添加的目的就是为了改善查询效率，添加索引时要避免出现using filesort，出现using filesort是指，当查询操作中包含order by，无法利用索引完成排序操作时，MySQL优化器不得不选择相应的排序算法来实现，数据较少时从内存排序，否则从磁盘排序。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;p&gt;还是以上面的tb_user_test表为例，&quot;select b,c from tb_user_test where a=100 and b=200 order by c desc;&quot;这个SQL语句在执行的时候如果tb_user_test没有idx_a_b_c这个联合索引那么执行计划是这样的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201901/772743-20190108170826736-1555403315.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意Extra列的值，Using filesort 出现了，这说明MySQL将数据重新排序了。&lt;/p&gt;
&lt;p&gt;如果将字段a和b创建了联合索引后的执行计划是这样的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201901/772743-20190108171439341-1606842876.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还是会有Using filesort。&lt;/p&gt;
&lt;p&gt;将字段a和b还有c创建了联合索引后的执行计划是这样的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201901/772743-20190108171729453-1020993520.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这次没有Using filesort了，创建索引时注意避免出现重排序问题。&lt;/p&gt;
&lt;p&gt;数据虑重是指在使用distinct或者group by的时候也是可以使用索引进行优化查询的。distinct或group by的列创建索引能提示查询效率。&lt;/p&gt;
&lt;p&gt;索引虽然能改善查询效率，但是代价是牺牲了插入和更新的效率。&lt;/p&gt;
&lt;h4&gt;索引数据控制&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;单张表索引数量建议不超过5个。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单个索引中的字段建议不超过5个。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符串适度使用前缀索引。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;索引不是越多越好，能不添加的索引尽量不要添加。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;索引的控制只是一些建议，并不是强制要求。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;索引禁忌&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;不在低区分度的列上建立索引，例如：“性别”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;尽量避免%前导查询，如like &quot;%ab&quot;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;尽量避免负向查询，如not in /like。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;避免全表扫描以及频繁的回表操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;区分度低的列创建了索引后查询速度确实提升了，但是当数据量变大后会产生大量的随机IO和回表查询。&lt;strong&gt;like前缀是不走索引的&lt;/strong&gt;，索引对负向查询的支持也不好。 &lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其他几点需要注意的是，索引的建立要优先保证高频查询需求的效率，低频需求尽可能使用到最左前缀索引。索引也要随着业务的演进更变化，不是建完索引就完事了。&lt;/p&gt;
&lt;h2&gt;高效SQL开发&lt;/h2&gt;
&lt;h3&gt;SQL优化--设计基本原则&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;SQL尽可能简单，线上尽可能少使用大SQL，使用简单小SQL。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;尽可能少使用存储过程/触发器/函数，减少MySQL端的数学运算和逻辑判断。（不易于扩展）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用预编译语句，降低SQL注入概率。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;尽量少用select * ，只取需要的数据列。（可降低磁盘I/O，有机会只走复合索引，缓存使用降低。）&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;SQL优化--隐式转换&lt;/h3&gt;
&lt;p&gt;基本原则：&lt;strong&gt;where条件比较，字段类型和传入值必须保证：数字对数字，字符对字符。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过下面的例子就可以看出来。&lt;/p&gt;
&lt;p&gt;字段：`remark` varchar(50) NOT NULL COMMENT '备注，默认为空',&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
MySQL&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;  id, gift_ code &lt;span&gt;FROM&lt;/span&gt; gift &lt;span&gt;Where&lt;/span&gt; deal_ id &lt;span&gt;=&lt;/span&gt; &lt;span&gt;640&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; remark&lt;span&gt;=&lt;/span&gt;&lt;span&gt;115127&lt;/span&gt;; &lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.14&lt;/span&gt;&lt;span&gt; sec)

MySQL&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;  id, gift_ code &lt;span&gt;FROM&lt;/span&gt; pool gift &lt;span&gt;Where&lt;/span&gt; deal_ id &lt;span&gt;=&lt;/span&gt; &lt;span&gt;640&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; remark&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;115127&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; ;&lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.005&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当remark传入int类型的值后，查询时间0.14秒，传入字符类型后只需要0.005秒。&lt;/p&gt;
&lt;h3&gt;SQL优化--函数计算&lt;/h3&gt;
&lt;p&gt;基本原则：&lt;strong&gt;不在索引列进行数学运算和函数运算。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;索引字段进行数学运算时，不走索引。可以放到后面对值进行运算。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201901/772743-20190108223632863-1354344975.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过运行时间就可以看出效果。&lt;/p&gt;
&lt;p&gt;索引字段慎用函数运算，MySQL的优化器对函数运算识别不出来时会直接走全表扫描。&lt;/p&gt;
&lt;p&gt;例子如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201901/772743-20190108223837171-77676984.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;SQL优化--分页&lt;/h3&gt;
&lt;h4&gt;传统分页&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; limt &lt;span&gt;10000&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;LIMIT原理&lt;/h4&gt;
&lt;p&gt;limit 10000,10; 偏移量越大则越慢。查询的时候要一步一步遍历到第10010条记录，然后取后10条记录，前面的全部抛弃掉。&lt;/p&gt;
&lt;h4&gt;推荐分页SQL&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; id&lt;span&gt;&amp;gt;=&lt;/span&gt;&lt;span&gt;23424&lt;/span&gt; limit &lt;span&gt;11&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#10+1(每页10条)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; id&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;23434&lt;/span&gt; limit &lt;span&gt;11&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;分页方式二&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; id&lt;span&gt;&amp;gt;=&lt;/span&gt;(&lt;span&gt;select&lt;/span&gt; id &lt;span&gt;from&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; limit &lt;span&gt;10000&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;) limit &lt;span&gt;10&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;分页方式三&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;Inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; (&lt;span&gt;select&lt;/span&gt; id &lt;span&gt;from&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; limit &lt;span&gt;10000&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;) using (id);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;分页方式四&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
先取id：&lt;span&gt;select&lt;/span&gt; id &lt;span&gt;from&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; limit &lt;span&gt;10000&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; id &lt;span&gt;in&lt;/span&gt; (&lt;span&gt;123&lt;/span&gt;,&lt;span&gt;456&lt;/span&gt;,...);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
MySQL&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; sql_no_ cache &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; post limit &lt;span&gt;10&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;;&lt;span&gt;10&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.01&lt;/span&gt;&lt;span&gt; sec)

MySQL&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; sql_ no_cache &lt;span&gt;*&lt;/span&gt;  &lt;span&gt;from&lt;/span&gt; post limit &lt;span&gt;2000&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;;&lt;span&gt;10&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.13&lt;/span&gt;&lt;span&gt; sec)

MySQL&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; sql_no_cache  &lt;span&gt;*&lt;/span&gt;  &lt;span&gt;from&lt;/span&gt; post limit &lt;span&gt;80000&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;;&lt;span&gt;10&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.58&lt;/span&gt;&lt;span&gt; sec)

MySQL&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; sql_no_ cache id &lt;span&gt;from&lt;/span&gt; post limit &lt;span&gt;8000&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;;&lt;span&gt;10&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.02&lt;/span&gt;&lt;span&gt; sec)

MySQL&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; sql_no_ cache &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; post &lt;span&gt;WHERE&lt;/span&gt; id&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;323423&lt;/span&gt; limit &lt;span&gt;10&lt;/span&gt;;&lt;span&gt;10&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.01&lt;/span&gt;&lt;span&gt; sec)

MySQL&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; post &lt;span&gt;WHERE&lt;/span&gt; id &lt;span&gt;&amp;gt;=&lt;/span&gt; ( &lt;span&gt;select&lt;/span&gt; sql_ no_ cache id &lt;span&gt;from&lt;/span&gt; post limit8000,&lt;span&gt;1&lt;/span&gt; ) limit &lt;span&gt;10&lt;/span&gt;;&lt;span&gt;10&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.02&lt;/span&gt; sec)  
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;可扩展性设计&lt;/h2&gt;
&lt;h3&gt;业务隔离&lt;/h3&gt;
&lt;p&gt;不同的业务使用不同的数据库实例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201901/772743-20190108232100660-1535129140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;垂直拆分&lt;/h3&gt;
&lt;p&gt;不同的业务表拆分到不同的数据库中，可以根据不同的模块，不同的功能将表拆分到不同个数据库中。逻辑比较清晰，但是也要考虑到具体的情况，如果有关联查询时，两个表放在里不同的库中，这样就拆分的不合理了，所以拆分的时候要对业务做深入的了解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201901/772743-20190108232507461-881871882.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;水平拆分&lt;/h3&gt;
&lt;p&gt;一个表中的数据拆分到不同表中或不同的库中。但是拆分的时候要慎重的考虑好了，要以哪个键作为唯一标识进行拆分。一但确定下来最好不要随意更改。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201901/772743-20190108232922585-2038672297.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;终极--数据拆分&lt;/h3&gt;
&lt;p&gt;水平拆分+垂直拆分&lt;/p&gt;
&lt;p&gt;（如果对分布式事务要求不太高的可以使用WTable,底层也是做了拆分。聚合操作也比较麻烦，要对每个库进行请求，然后再进行聚合操作。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201901/772743-20190108233316906-1457931873.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;这次的知识总结的比较粗糙，以后会对每一块做深入研究。&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201809/772743-20180915224244625-861430438.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文章会同步到我的公众号上面，欢迎关注。&lt;/p&gt;
</description>
<pubDate>Tue, 08 Jan 2019 16:37:00 +0000</pubDate>
<dc:creator>纪莫</dc:creator>
<og:description>前言 最近听了公司里的同事做的技术分享，然后觉得对自己还是挺有帮助的。都是一些日常需要注意的地方，我们目前在开发过程中，其实用不到MySQL太深的内容的。只是能适用我们日常开发的知识就可以了。所以我将</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jimoer/p/10226952.html</dc:identifier>
</item>
<item>
<title>RabbitMQ与.net core(四) 消息的优先级 与 死信队列 - 老六代码</title>
<link>http://www.cnblogs.com/chenyishi/p/10242162.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenyishi/p/10242162.html</guid>
<description>&lt;h2&gt;1.消息的优先级&lt;/h2&gt;
&lt;p&gt;假如现在有个需求，我们需要让一些优先级最高的通知推送到客户端，我们可以使用redis的sortedset，也可以使用我们今天要说的rabbit的消息优先级属性&lt;/p&gt;
&lt;p&gt;Producer代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; RabbitMQ.Client;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; RabbitMQConsole
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            ConnectionFactory factory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
            factory.HostName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;39.**.**.**&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            factory.Port &lt;/span&gt;= &lt;span&gt;5672&lt;/span&gt;&lt;span&gt;;
            factory.VirtualHost &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            factory.UserName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            factory.Password &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; exchange = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;change4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; route = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;route2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; queue9 = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;queue9&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; connection =&lt;span&gt; factory.CreateConnection())
            {
                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; channel =&lt;span&gt; connection.CreateModel())
                {
                    channel.ExchangeDeclare(exchange, type: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fanout&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, durable: &lt;span&gt;true&lt;/span&gt;, autoDelete: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
　　　　　　　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x-max-priority属性必须设置，否则消息优先级不生效&lt;/span&gt;
                    channel.QueueDeclare(queue9, durable: &lt;span&gt;true&lt;/span&gt;, exclusive: &lt;span&gt;false&lt;/span&gt;, autoDelete: &lt;span&gt;false&lt;/span&gt;,arguments: &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; { { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x-max-priority&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;50&lt;/span&gt;&lt;span&gt; } });
                    channel.QueueBind(queue9, exchange, queue9);
                    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
                    {
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; messagestr =&lt;span&gt; Console.ReadLine();
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; messagepri =&lt;span&gt; Console.ReadLine();
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; props =&lt;span&gt; channel.CreateBasicProperties();
                        props.Persistent &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        props.Priority &lt;/span&gt;= (&lt;span&gt;byte&lt;/span&gt;)&lt;span&gt;int&lt;/span&gt;.Parse(messagepri);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置消息优先级&lt;/span&gt;
                        channel.BasicPublish(exchange, route, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, props, Encoding.UTF8.GetBytes(messagestr));
                    }
                }
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;consumer代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; RabbitMQ.Client;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; RabbitMQ.Client.Events;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; RabbitMQClient
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; ConnectionFactory rabbitMqFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory()
        {
            HostName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;39.**.**.**&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            Port &lt;/span&gt;= &lt;span&gt;5672&lt;/span&gt;&lt;span&gt;,
            UserName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            Password &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            VirtualHost &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        };
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; exchange = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;change4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; route = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;route2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; queue9 = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;queue9&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;


            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (IConnection conn =&lt;span&gt; rabbitMqFactory.CreateConnection())
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (IModel channel =&lt;span&gt; conn.CreateModel())
            {
                channel.ExchangeDeclare(exchange, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fanout&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, durable: &lt;span&gt;true&lt;/span&gt;, autoDelete: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                channel.QueueDeclare(queue9, durable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, exclusive: &lt;span&gt;false&lt;/span&gt;, autoDelete: &lt;span&gt;false&lt;/span&gt;, arguments: &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; { { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x-max-priority&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;50&lt;/span&gt;&lt;span&gt; } });
                channel.QueueBind(queue9, exchange, route);

                channel.BasicQos(prefetchSize: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, prefetchCount: &lt;span&gt;50&lt;/span&gt;, &lt;span&gt;global&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                EventingBasicConsumer consumer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EventingBasicConsumer(channel);
                consumer.Received &lt;/span&gt;+= (model, ea) =&amp;gt;&lt;span&gt;
                {
                    Byte[] body &lt;/span&gt;=&lt;span&gt; ea.Body;
                    String message &lt;/span&gt;=&lt;span&gt; Encoding.UTF8.GetString(body);
                    Console.WriteLine( message);
                    channel.BasicAck(deliveryTag: ea.DeliveryTag, multiple: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                };

                channel.BasicConsume(queue: queue9, autoAck: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, consumer: consumer);
                Console.ReadLine();
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行producer&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201901/1033233-20190107170401921-1759758031.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在运行consumer&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201901/1033233-20190107170509169-1034422863.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出消息是按优先级消费的&lt;/p&gt;
&lt;h2&gt;2.死信队列&lt;/h2&gt;
&lt;p&gt;死信队列可以用来做容错机制，当我们的消息处理异常时我们可以把消息放入到死信队列中，以便后期处理，死信的产生有三种&lt;/p&gt;
&lt;p&gt;1.消息被拒(basic.reject or basic.nack)并且没有重新入队(requeue=false)；&lt;/p&gt;
&lt;p&gt;2.当前队列中的消息数量已经超过最大长度。&lt;/p&gt;
&lt;p&gt;3.消息在队列中过期，即当前消息在队列中的存活时间已经超过了预先设置的TTL(Time To Live)时间；&lt;/p&gt;
&lt;p&gt;看代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; RabbitMQ.Client;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; RabbitMQConsole
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            ConnectionFactory factory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
            factory.HostName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;39.**.**.**&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            factory.Port &lt;/span&gt;= &lt;span&gt;5672&lt;/span&gt;&lt;span&gt;;
            factory.VirtualHost &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            factory.UserName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            factory.Password &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; exchangeA = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;changeA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; routeA = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;routeA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; queueA = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;queueA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; exchangeD = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;changeD&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; routeD = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;routeD&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; queueD = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;queueD&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; connection =&lt;span&gt; factory.CreateConnection())
            {
                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; channel =&lt;span&gt; connection.CreateModel())
                {
                    channel.ExchangeDeclare(exchangeD, type: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fanout&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, durable: &lt;span&gt;true&lt;/span&gt;, autoDelete: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                    channel.QueueDeclare(queueD, durable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, exclusive: &lt;span&gt;false&lt;/span&gt;, autoDelete: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                    channel.QueueBind(queueD, exchangeD, routeD);

                    channel.ExchangeDeclare(exchangeA, type: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fanout&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, durable: &lt;span&gt;true&lt;/span&gt;, autoDelete: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                    channel.QueueDeclare(queueA, durable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, exclusive: &lt;span&gt;false&lt;/span&gt;, autoDelete: &lt;span&gt;false&lt;/span&gt;, arguments: &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt; {
                                         { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x-dead-letter-exchange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,exchangeD}, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置当前队列的DLX&lt;/span&gt;
                                         { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x-dead-letter-routing-key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,routeD}, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置DLX的路由key，DLX会根据该值去找到死信消息存放的队列&lt;/span&gt;
                                         { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x-message-ttl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;10000&lt;/span&gt;} &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置消息的存活时间，即过期时间&lt;/span&gt;
&lt;span&gt;                                         });
                    channel.QueueBind(queueA, exchangeA, routeA);


                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; properties =&lt;span&gt; channel.CreateBasicProperties();
                    properties.Persistent &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发布消息&lt;/span&gt;
&lt;span&gt;                    channel.BasicPublish(exchange: exchangeA,
                                         routingKey: routeA,
                                         basicProperties: properties,
                                         body: Encoding.UTF8.GetBytes(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
                }
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样10秒后消息过期，我们可以看到queueD中有了消息&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201901/1033233-20190107171524693-1392694498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 08 Jan 2019 16:20:00 +0000</pubDate>
<dc:creator>老六代码</dc:creator>
<og:description>1.消息的优先级 假如现在有个需求，我们需要让一些优先级最高的通知推送到客户端，我们可以使用redis的sortedset，也可以使用我们今天要说的rabbit的消息优先级属性 Producer代码</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenyishi/p/10242162.html</dc:identifier>
</item>
<item>
<title>利用 Blob 处理 node 层返回的二进制文件流字符串并下载文件 - 筱月</title>
<link>http://www.cnblogs.com/ainyi/p/10242117.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ainyi/p/10242117.html</guid>
<description>&lt;p&gt;博客地址：&lt;a href=&quot;https://ainyi.com/#/65&quot; class=&quot;uri&quot;&gt;https://ainyi.com/#/65&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;解释-背景&quot;&gt;解释 | 背景&lt;/h2&gt;
&lt;p&gt;看到标题有点懵逼，哈哈，实际上是后端将文件处理成二进制流，返回到前端，前端处理这个二进制字符串，输出文件或下载&lt;/p&gt;
&lt;p&gt;最近公司有个需求是用户在点击下载文件（==pdf==）的时候，下载地址不能暴露在接口的返回值，前端不要通过这个地址下载，容易发生泄露，不安全。所以经过讨论，就在后端根据文件地址直接转成二进制流形式，返回给前端合并，再进行下载&lt;/p&gt;
&lt;h2 id=&quot;文件转换二进制流&quot;&gt;文件转换二进制流&lt;/h2&gt;
&lt;p&gt;在 nodejs 中将文件转换成二进制是比较简单的，先通过接口获取文件下载地址，由于是不同域的地址，也就是必须通过网络请求得到这个文件，不能使用 ==fs.readFile== 读取文件，可以使用 ==get== 请求获取读写，编码设置成二进制 ==binary==&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 后端 node 所写的接口(部分代码)

download() {
  let { ctx } = this
  // 根据传入的参数 contractNumber，查询得到文件地址 data.formalPdfUrl / data.draftPdfUrl
  // 查询...
  let url = data.formalPdfUrl || data.draftPdfUrl // 简便写法
  // 上面是简便写法，相当于
  // if (data.formalPdfUrl) {
  //   url = data.formalPdfUrl
  // } else if (data.draftPdfUrl) {
  //   url = data.draftPdfUrl
  // }
  let handle = this.handleFiles(url)
  let binaryFiles = await handle.then(data =&amp;gt; {
    return data
  })
  // 返回到前端
  ctx.body = binaryFiles
},
handleFiles(url) {
  return new Promise((resolve, reject) =&amp;gt; {
    http.get(url, res =&amp;gt; {
      res.setEncoding('binary') // 二进制
      let files = ''
      res.on('data', chunk =&amp;gt; { // 加载到内存
        files += chunk
      }).on('end', () =&amp;gt; { // 加载完
        resolve(binaryFiles)
      })
    })
  })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;提示&quot;&gt;提示&lt;/h3&gt;
&lt;p&gt;当然也可以在后端直接下载这个文件，然后使用 ==fs.readFile== 以 ==binary== 编码读取得到，但没必要下载，下载完还要删除，多此一举&lt;/p&gt;
&lt;h2 id=&quot;前端处理下载&quot;&gt;前端处理下载&lt;/h2&gt;
&lt;p&gt;问题来了，也是坑了我一个下午的问题，如何在前端 js 中处理这个二进制流，合并成文件，供下载&lt;/p&gt;
&lt;p&gt;找了找，发现 html5 有个 Blob 对象，此对象在数据库中也见过，保存庞大数据的字段，那么在 html5 中，Blob 允许我们可以通过 js 直接操作二进制数据&lt;/p&gt;
&lt;h3 id=&quot;javascript---blob-对象&quot;&gt;JavaScript - Blob 对象&lt;/h3&gt;
&lt;p&gt;一个 Blob 对象表示一个不可变的，原始数据的类似文件对象&lt;br/&gt;Blob 表示的数据不一定是一个 JavaScript 原生格式，本质上是 js 中的一个对象，里面可以储存大量的二进制编码格式的数据&lt;/p&gt;
&lt;p&gt;创建 blob 对象本质上和创建一个其他对象的方式是一样的，都是使用 Blob() 的构造函数来进行创建&lt;/p&gt;
&lt;p&gt;构造函数接受两个参数：&lt;br/&gt;第一个参数为一个数据序列，可以是任意格式的值&lt;br/&gt;第二个参数是一个包含两个属性的对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{ type: MIME 类型,
  endings: 决定第一个参数的数据格式，可以取值为 &quot;transparent&quot; 或者 &quot;native&quot;
 （transparent：不变，是默认值；native：按操作系统转换）
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于 MIME 类型的可看：&lt;a href=&quot;http://www.w3school.com.cn/media/media_mimeref.asp&quot; class=&quot;uri&quot;&gt;http://www.w3school.com.cn/media/media_mimeref.asp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于 Blob 对象在这篇博客不讲太多说明，主要讲解如何使用 Blob 对象解决二进制流转文件的问题&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 前端调用
download() {
  let params = {
    contractNumber: num
  }
  // 调用下载文件接口，实质转成二进制流
  let content = await downloadContract(params)
  // 拿到二进制字符串 content
  // 再利用 Buffer 转为对象
  const buf = Buffer.from(content, 'binary')
  // 再输入到 Blob 生成文件
  let blob = new Blob([buf], {type: 'application/pdf'});
  let a = document.createElement('a')
  // 指定生成的文件名
  a.download = num + '.pdf'
  a.href = URL.createObjectURL(blob)
  document.body.appendChild(a)
  a.click()
  document.body.removeChild(a)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到 Blob 对象创建的文件 url（格式类似：“&lt;a class=&quot;uri&quot;&gt;blob:http://&lt;/a&gt;.....”），赋值到动态创建的 a 标签的 href 属性，设置好 download 属性，点击下载后移除 a 标签&lt;/p&gt;
&lt;h2 id=&quot;注意&quot;&gt;注意&lt;/h2&gt;
&lt;p&gt;要注意的是&lt;br/&gt;在 node 层不必使用 Buffer 处理输出二进制对象，因为返回给前端的时候还是二进制字符串形式，所以 node 层可直接返回二进制流字符串&lt;br/&gt;在前端在调用 Blob 构造函数的时候，先利用 Buffer 将二进制字符串转为 Buffer 对象，再作为 Blob 的第一个参数，指定好第二个参数的类型 type 即可&lt;/p&gt;
&lt;p&gt;博客地址：&lt;a href=&quot;https://ainyi.com/#/65&quot; class=&quot;uri&quot;&gt;https://ainyi.com/#/65&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 08 Jan 2019 15:59:00 +0000</pubDate>
<dc:creator>筱月</dc:creator>
<og:description>博客地址：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ainyi/p/10242117.html</dc:identifier>
</item>
<item>
<title>从vue源码看props - 你假装没察觉</title>
<link>http://www.cnblogs.com/heavenYJJ/p/10242084.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/heavenYJJ/p/10242084.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;平时写vue的时候知道&lt;code&gt;props&lt;/code&gt;有很多种用法，今天我们来看看vue内部是怎么处理&lt;code&gt;props&lt;/code&gt;中那么多的用法的。&lt;/p&gt;
&lt;h2 id=&quot;vue提供的props的用法&quot;&gt;vue提供的props的用法&lt;/h2&gt;
&lt;h4 id=&quot;数组形式&quot;&gt;1. 数组形式&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;props: ['name', 'value']&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;对象形式&quot;&gt;2. 对象形式&lt;/h4&gt;
&lt;p&gt;对象形式内部也提供了三种写法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;props: {
    // 基础的类型检查
    name: String,
    // 多个可能的类型
    value: [String, Number],
    // 对象形式
    id: {
        type: Number,
        required: true
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;props实现的原理&quot;&gt;props实现的原理&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;function normalizeProps (options: Object, vm: ?Component) {
  const props = options.props
  if (!props) return
  const res = {}
  let i, val, name
  if (Array.isArray(props)) {
    ...
  } else if (isPlainObject(props)) {
    ...
  } else if (process.env.NODE_ENV !== 'production') {
    ...
  }
  options.props = res
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;normalizeProps&lt;/code&gt;函数就是vue实际处理&lt;code&gt;props&lt;/code&gt;的地方，从函数名的翻译我们可以看出该函数的功能就是标准化&lt;code&gt;props&lt;/code&gt;的值。该函数主要分成3部分：① 从&lt;code&gt;options&lt;/code&gt;对象中获取&lt;code&gt;props&lt;/code&gt;的值并且定义一个res空对象；②几个&lt;code&gt;if ... else&lt;/code&gt;，分别根据&lt;code&gt;props&lt;/code&gt;值的不同类型来处理&lt;code&gt;res&lt;/code&gt;对象；③ 用处理后的&lt;code&gt;res&lt;/code&gt;对象覆盖原来&lt;code&gt;options&lt;/code&gt;对象的&lt;code&gt;props&lt;/code&gt;属性的值。&lt;/p&gt;
&lt;p&gt;接下来看看那几个&lt;code&gt;if ... else&lt;/code&gt;的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (Array.isArray(props)) {
    i = props.length
    while (i--) {
      val = props[i]
      if (typeof val === 'string') {
        name = camelize(val)
        res[name] = { type: null }
      } else if (process.env.NODE_ENV !== 'production') {
        warn('props must be strings when using array syntax.')
      }
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个代码实际就是处理props的值为数组的情况，例如： &lt;code&gt;props: ['name', 'value']&lt;/code&gt;。使用while遍历该数组，如果数组内元素的类型不是字符串并且不是生产环境，那么就抛错：‘props的值类型为数组时，数组里面的元素的类型就必须是字符串’。如果是字符串的情况下，使用&lt;code&gt;camelize&lt;/code&gt;函数处理一下&lt;code&gt;val&lt;/code&gt;的值，并且赋值给&lt;code&gt;name&lt;/code&gt;变量。这里的&lt;code&gt;camelize&lt;/code&gt;函数的实际作用就是将&lt;code&gt;'-'&lt;/code&gt;转换为驼峰。&lt;code&gt;camelize&lt;/code&gt;函数具体的实现方式在后面分析。然后在&lt;code&gt;res&lt;/code&gt;对象上面添加一个为&lt;code&gt;name&lt;/code&gt;变量的属性，该属性的值为空对象 &lt;code&gt;{ type: null }&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;props: ['name', 'value']&lt;/code&gt;这种写法经过上面的处理后就会变成了下面这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;props: {
    name: {
        type: null
    },
    value: {
        type: null
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来看看下面这个&lt;code&gt;else if(isPlainObject(props))&lt;/code&gt;,这里的&lt;code&gt;isPlainObject&lt;/code&gt;函数实际就是返回&lt;code&gt;props&lt;/code&gt;的值是否为&lt;code&gt;object&lt;/code&gt;，&lt;code&gt;isPlainObject&lt;/code&gt;函数的具体实现我们也在后面分析。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;else if (isPlainObject(props)) {
   for (const key in props) {
     val = props[key]
     name = camelize(key)
     res[name] = isPlainObject(val)
       ? val
       : { type: val }
   }
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;for...in&lt;/code&gt;遍历props对象，和上面一样使用&lt;code&gt;camelize&lt;/code&gt;函数将&lt;code&gt;'-'&lt;/code&gt;转换为驼峰。这里有个三目运算：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;res[name] = isPlainObject(val) ? val : { type: val }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;判断了一下&lt;code&gt;val&lt;/code&gt;如果是&lt;code&gt;object&lt;/code&gt;，那么在res对象上面添加一个为name变量的属性，并且将该属性的值设置为val。这个其实就是处理下面这种props的写法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;props: {
   // 对象形式
   id: {
       type: Number,
       required: true
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果&lt;code&gt;val&lt;/code&gt;不是&lt;code&gt;object&lt;/code&gt;，那么也在res对象上面添加一个为name变量的属性，并且将该属性的值设置为{ type: val }。这个其实就是处理下面这种props的写法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;props: {
    // 基础的类型检查
    name: String,
    // 多个可能的类型
    value: [String, Number],
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;经过处理后props会变成了下面这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;props: {
    name: {
        type: String
    },
    value: {
        type: [String, Number]
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以不管我们使用vue提供的&lt;code&gt;props&lt;/code&gt;哪种写法，最终vue都会帮我们转换成下面这种类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;props: {
    name: {
        ...,
        type: '类型'
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来看看上面提到的util函数&lt;code&gt;isPlainObject&lt;/code&gt;，先把源码贴出来。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const _toString = Object.prototype.toString

export function isPlainObject (obj: any): boolean {
  return _toString.call(obj) === '[object Object]'
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实&lt;code&gt;Object.prototype.toString.call(obj)&lt;/code&gt;的值为obj对象的类型。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Object.prototype.toString.call({a: 1})      // [object Object]
Object.prototype.toString.call(new Date)    // [object Date]
Object.prototype.toString.call([1])         // [object Array]
Object.prototype.toString.call(null)        // [object Null]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来看看上面提到的util函数&lt;code&gt;camelize&lt;/code&gt;，还是先把源码贴出来。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export function cached&amp;lt;F: Function&amp;gt; (fn: F): F {
  const cache = Object.create(null)
  return (function cachedFn (str: string) {
    const hit = cache[str]
    return hit || (cache[str] = fn(str))
  }: any)
}

const camelizeRE = /-(\w)/g
export const camelize = cached((str: string): string =&amp;gt; {
  return str.replace(camelizeRE, (_, c) =&amp;gt; c ? c.toUpperCase() : '')
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里定义了两个函数，分别是&lt;code&gt;cached&lt;/code&gt;和&lt;code&gt;camelize&lt;/code&gt;，其中&lt;code&gt;camelize&lt;/code&gt;就是我们上面调用的，&lt;code&gt;cached&lt;/code&gt;是在&lt;code&gt;camelize&lt;/code&gt;函数内部调用的。&lt;/p&gt;
&lt;p&gt;我们先来看看&lt;code&gt;camelize&lt;/code&gt;函数，其实&lt;code&gt;camelize&lt;/code&gt;函数就是执行&lt;code&gt;cached&lt;/code&gt;后返回的一个函数。调用&lt;code&gt;cached&lt;/code&gt;时传入了一个箭头函数，箭头函数内部是调用了正则的&lt;code&gt;replace&lt;/code&gt;方法，将传入的&lt;code&gt;str&lt;/code&gt;变量中匹配&lt;code&gt;/-(\w)/g&lt;/code&gt;的变成大写字母，并且返回&lt;code&gt;replace&lt;/code&gt;后的值。（也就是将&lt;code&gt;-&lt;/code&gt;转换成驼峰）。&lt;/p&gt;
&lt;p&gt;再来看看&lt;code&gt;cached&lt;/code&gt;函数，该函数传入的变量其实就是&lt;code&gt;camelize&lt;/code&gt;那里的箭头函数，首先定义了一个&lt;code&gt;cache&lt;/code&gt;空对象，然后直接返回了&lt;code&gt;cachedFn&lt;/code&gt;函数。我们在外部调用&lt;code&gt;camelize(key)&lt;/code&gt;时，其实就是执行了这里的了&lt;code&gt;cachedFn&lt;/code&gt;函数，&lt;code&gt;str&lt;/code&gt;的值就是传入的&lt;code&gt;key&lt;/code&gt;的值。很明显这里是一个闭包，可以在外部调用&lt;code&gt;camelize&lt;/code&gt;函数的时候可以修改或者读取这里定义的&lt;code&gt;cache&lt;/code&gt;对象的值。获取&lt;code&gt;cache&lt;/code&gt;对象中&lt;code&gt;key&lt;/code&gt;为&lt;code&gt;str&lt;/code&gt;变量值的属性值赋值给&lt;code&gt;hit&lt;/code&gt;变量。如果有hit变量的值，那么就直接返回hit的值，如果没有就执行&lt;code&gt;camelize&lt;/code&gt;传入的箭头函数，并且将箭头函数的返回值赋值给&lt;code&gt;catche&lt;/code&gt;对象的&lt;code&gt;str&lt;/code&gt;属性。如果下次调用&lt;code&gt;camelize&lt;/code&gt;函数时传入了相同的&lt;code&gt;str&lt;/code&gt;，那么就不会执行箭头函数，直接返回闭包中的&lt;code&gt;cache&lt;/code&gt;对象的&lt;code&gt;str&lt;/code&gt;属性的值。这里是性能优化的一种手段。&lt;/p&gt;
&lt;p&gt;例如：第一次调用 &lt;code&gt;camelize('name')&lt;/code&gt;后，&lt;code&gt;cache&lt;/code&gt;对象的值就变成了{name: 'name'}。然后在其他地方再次调用 &lt;code&gt;camelize('name')&lt;/code&gt;时再次执行&lt;code&gt;cachedFn&lt;/code&gt;函数，此时&lt;code&gt;hit&lt;/code&gt;变量的值为'name'。直接返回&lt;code&gt;hit&lt;/code&gt;变量的值，不会执行传入的箭头函数。&lt;/p&gt;
</description>
<pubDate>Tue, 08 Jan 2019 15:55:00 +0000</pubDate>
<dc:creator>你假装没察觉</dc:creator>
<og:description>前言 平时写vue的时候知道 有很多种用法，今天我们来看看vue内部是怎么处理 中那么多的用法的。 vue提供的props的用法 1. 数组形式 2. 对象形式 对象形式内部也提供了三种写法： pro</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/heavenYJJ/p/10242084.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core入门（一） - lionxin</title>
<link>http://www.cnblogs.com/xinzhi/p/10242082.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xinzhi/p/10242082.html</guid>
<description>
&lt;p&gt;　　大家好，很荣幸您点了开此篇文章，和我一起来学习ASP.NET Core，此篇文字为《ASP.NET Core入门》系列中的第一篇，&lt;span&gt;本系列将以一个博客系统为例，从第一行代码，到系统发布上线（linux）。&lt;/span&gt;如有错误，请联系我，让我们共同成长，进步，谢谢。下面进入正题：&lt;/p&gt;
&lt;p&gt;　　首先，看到这篇文章可能是一位新手，下面由我先介绍下ASP.NET Core：&lt;/p&gt;
&lt;p&gt;　　ASP.NET Core 是一个新的&lt;span&gt;&lt;a href=&quot;https://github.com/aspnet/Home&quot;&gt;&lt;span&gt;开源&lt;/span&gt;&lt;/a&gt;和跨平台的框架&lt;/span&gt;，用于构建如 Web 应用、物联网（IoT）应用和移动后端应用等连接到互联网的基于云的现代应用程序。ASP.NET Core 应用可运行于 .NET Core 和完整的 .NET Framework 之上。它整合了原来ASP.NET中的MVC和WebApi框架，你可以在 Windows、Mac 和 Linux 上跨平台的开发和运行你的 ASP.NET Core 应用。&lt;span&gt;重点：跨平台的开发和运行是之前.NET Framework没有的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　对比之前的.NET Framework，它具有如下&lt;span&gt;优点&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　1.跨平台（Windows、Mac 和 Linux都可以开发，部署）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　2.内置了依赖注入（middewere）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　3.部署应用服务器有更多的选择（除去之前的IIS，还有了新的Kestrel等等）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　4.轻量级，高性能，模块化的HTTP管线。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　5..NET Core是开源的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　那么说到这么多的好处，我们&lt;span&gt;学习起来&lt;/span&gt;又是什么样子的呢？下面我也做了一个简单的对比：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　在配置方面：ASP.NET 使用的是web.config文件，而ASP.NET Core使用 appsettings.json 文件来进行配置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　依赖注入：ASP.NET不需要/很少关注就可以开发一个完整的程序，而ASP.NET Core使用了大量的依赖注入（包括本地文件读取都需要）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　管道：ASP.NET使用 httpmodule来配置使用，而ASP.NET Core则使用的是middware。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　说了这么多概念性的东西，大家也许很懵，那就先敲俩行，试试全新的ASP.NET Core。&lt;/p&gt;

&lt;p&gt;　　　　环境所需，大家可自行下载（注意：&lt;span&gt;sdk与Runtime版本需相同&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;　　　　　　.NET Core sdk&lt;/p&gt;
&lt;p&gt;　　　　　　.NET Core Runtime&lt;/p&gt;
&lt;p&gt;　　　　　　VS2017及以上或VS Code&lt;/p&gt;
&lt;p&gt;　　　　　　sdk和runntime下载地址：https://dotnet.microsoft.com/download，vs 2017/vs code下载地址：https://docs.microsoft.com/zh-cn/visualstudio/products/?view=vs-2017&lt;/p&gt;

&lt;p&gt;　　　　安装好以后，我们开始第一行代码，这里我们使用vs code来做示例：&lt;/p&gt;
&lt;p&gt;　　　　打开vs code后，我们看到的是这副画面　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/782902/201901/782902-20190108232520413-136649896.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　找到菜单栏：查看-&amp;gt;集成终端&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/782902/201901/782902-20190108232557058-1270928837.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　输入：dotnet --version，终端显示版本号为正确，否则请检测安装sdk，Runtime环境是否安装正确。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/782902/201901/782902-20190108232748984-1475905871.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　好，下面我们来新建一个项目，输入：dotnet new --help 来查看可创建程序的模板&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/782902/201901/782902-20190108233141410-638272921.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我们来新建一个最简单的 MVC项目，输入 dotnet new mvc即可创建一个mvc模板项目。创建成功后，会自动还原一次包（必须引用的包）。可以执行 dotnet restore 手动来还原包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/782902/201901/782902-20190108233550836-1824356415.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　最后，我们执行 dotnet run来运行这个程序。输入终端返回的地址，就可以访问我们创建好的项目。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/782902/201901/782902-20190108233858940-1580472904.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/782902/201901/782902-20190108233831897-813072755.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　最后，我们来总结下今天所学到的知识，第一篇内容很简单吧，下一篇开始我们会先将第一篇创建的程序放入linux环境中，然后与数据库进行交互。&lt;/p&gt;
&lt;p&gt;　　总结下今天所用到的命令：&lt;/p&gt;
&lt;p&gt;　　　　dotnet --version：查看runtime的版本号&lt;/p&gt;
&lt;p&gt;　　　　dotnet new --help：查看可创建的模块列表&lt;/p&gt;
&lt;p&gt;　　　　dotnet new mvc：创建一个mvc模板项目&lt;/p&gt;
&lt;p&gt;　　　　dotnet restore：还原包&lt;/p&gt;
&lt;p&gt;　　　　dotnet run：运行项目&lt;/p&gt;
&lt;p&gt;　　如文中有错误，还请您多多指出，共同学习进步。&lt;/p&gt;
</description>
<pubDate>Tue, 08 Jan 2019 15:46:00 +0000</pubDate>
<dc:creator>lionxin</dc:creator>
<og:description>大家好，很荣幸您点了开此篇文章，和我一起来学习ASP.NET Core，此篇文字为《ASP.NET Core入门》系列中的第一篇，本系列将以一个博客系统为例，从第一行代码，到系统发布上线（linux）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xinzhi/p/10242082.html</dc:identifier>
</item>
<item>
<title>通俗易懂--岭回归(L2)、lasso回归(L1)、ElasticNet讲解(算法+案例) - mantch</title>
<link>http://www.cnblogs.com/mantch/p/10242077.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mantch/p/10242077.html</guid>
<description>&lt;h2 id=&quot;l2正则化岭回归&quot;&gt;1.L2正则化(岭回归)&lt;/h2&gt;
&lt;h3 id=&quot;问题&quot;&gt;1.1问题&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/663864/201411/081949249876584.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;想要理解什么是正则化，首先我们先来了解上图的方程式。当训练的特征和数据很少时，往往会造成欠拟合的情况，对应的是左边的坐标；而我们想要达到的目的往往是中间的坐标，适当的特征和数据用来训练；但往往现实生活中影响结果的因素是很多的，也就是说会有很多个特征值，所以训练模型的时候往往会造成过拟合的情况，如右边的坐标所示。&lt;/p&gt;
&lt;h3 id=&quot;公式&quot;&gt;1.2公式&lt;/h3&gt;
&lt;p&gt;以图中的公式为例，往往我们得到的模型是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/01/08/5c34b8bda06d3.png&quot; alt=&quot;UTOOLS1546959038274.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了能够得到中间坐标的图形，肯定是&lt;strong&gt;希望θ3和θ4越小越好&lt;/strong&gt;，因为这两项越小就越接近于0，就可以得到中间的图形了。&lt;/p&gt;
&lt;p&gt;对应的损失函数也加上这个惩罚项(为了惩罚θ)：假设&lt;em&gt;λ&lt;/em&gt;=1000&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/01/08/5c34b941f2bf5.png&quot; alt=&quot;UTOOLS1546959169901.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了求得最小值，&lt;strong&gt;使θ值趋近于0&lt;/strong&gt;，这就达到了我们的目的，得到中间坐标的方程。&lt;/p&gt;
&lt;p&gt;把以上公式通用化得：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/01/08/5c34b975cf88d.png&quot; alt=&quot;UTOOLS1546959221738.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相当于在原始损失函数中加上了一个惩罚项(λ项)&lt;/p&gt;
&lt;p&gt;这就是&lt;strong&gt;防止过拟合&lt;/strong&gt;的一个方法，通常叫做&lt;strong&gt;L2正则化，也叫作岭回归。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;对应图形&quot;&gt;1.3对应图形&lt;/h3&gt;
&lt;p&gt;我们可以简化L2正则化的方程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/01/08/5c34b9a91663f.png&quot; alt=&quot;UTOOLS1546959273104.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;J0表示原始的损失函数，咱们假设正则化项为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/01/08/5c34ba6b35b6a.png&quot; alt=&quot;UTOOLS1546959466689.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们不妨回忆一下圆形的方程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/01/08/5c34ba88553fb.png&quot; alt=&quot;UTOOLS1546959496318.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中(a,b)为圆心坐标，r为半径。那么经过坐标原点的单位元可以写成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/01/08/5c34baf161c01.png&quot; alt=&quot;UTOOLS1546959601400.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;正和L2正则化项一样，同时，机器学习的任务就是要通过一些方法（比如梯度下降）求出损失函数的最小值。&lt;/p&gt;
&lt;p&gt;此时我们的任务变成在L约束下求出J0取最小值的解。&lt;/p&gt;
&lt;p&gt;求解J0的过程可以画出等值线。同时L2正则化的函数L也可以在w1w2的二维平面上画出来。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/01/08/5c34a2efa0b01.png&quot; alt=&quot;UTOOLS1546953455440.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;L表示为图中的黑色圆形，随着梯度下降法的不断逼近，与圆第一次产生交点，而这个交点很难出现在坐标轴上。&lt;/p&gt;
&lt;p&gt;这就说明了L2正则化不容易得到稀疏矩阵，同时为了求出损失函数的最小值，使得w1和w2无限接近于0，达到防止过拟合的问题。&lt;/p&gt;
&lt;h3 id=&quot;使用场景&quot;&gt;1.4使用场景&lt;/h3&gt;
&lt;p&gt;只要数据线性相关，用LinearRegression拟合的不是很好，&lt;strong&gt;需要正则化&lt;/strong&gt;，可以考虑使用岭回归(L2), 如何输入特征的维度很高,而且是稀疏线性关系的话， 岭回归就不太合适,考虑使用Lasso回归。&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;1.5代码实现&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mantchs/machine_learning_model/blob/master/Regularization/RidgeCV.ipynb&quot;&gt;GitHub代码--L2正则化&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;l1正则化lasso回归&quot;&gt;2.L1正则化(lasso回归)&lt;/h2&gt;
&lt;h3 id=&quot;公式-1&quot;&gt;2.1公式&lt;/h3&gt;
&lt;p&gt;L1正则化与L2正则化的区别在于惩罚项的不同：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/01/08/5c34bb9ac2621.png&quot; alt=&quot;UTOOLS1546959770276.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;L1正则化表现的是θ的绝对值，变化为上面提到的w1和w2可以表示为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/01/08/5c34bbc779e82.png&quot; alt=&quot;UTOOLS1546959815505.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;对应图形-1&quot;&gt;2.2对应图形&lt;/h3&gt;
&lt;p&gt;求解J0的过程可以画出等值线。同时L1正则化的函数也可以在w1w2的二维平面上画出来。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/01/08/5c34ab9a546f7.png&quot; alt=&quot;UTOOLS1546955675245.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;惩罚项表示为图中的黑色棱形，随着梯度下降法的不断逼近，与棱形第一次产生交点，而这个交点很容易出现在坐标轴上。&lt;strong&gt;这就说明了L1正则化容易得到稀疏矩阵。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用场景-1&quot;&gt;2.3使用场景&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;L1正则化(Lasso回归)可以使得一些特征的系数变小,甚至还使一些绝对值较小的系数直接变为0&lt;/strong&gt;，从而增强模型的泛化能力 。对于高纬的特征数据,尤其是线性关系是稀疏的，就采用L1正则化(Lasso回归),或者是要在一堆特征里面找出主要的特征，那么L1正则化(Lasso回归)更是首选了。&lt;/p&gt;
&lt;h3 id=&quot;代码实现-1&quot;&gt;2.4代码实现&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mantchs/machine_learning_model/blob/master/Regularization/LassoCV.ipynb&quot;&gt;GitHub代码--L1正则化&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;elasticnet回归&quot;&gt;3.ElasticNet回归&lt;/h2&gt;
&lt;h3 id=&quot;公式-2&quot;&gt;3.1公式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ElasticNet综合了L1正则化项和L2正则化项&lt;/strong&gt;，以下是它的公式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/01/08/5c34bc051086c.png&quot; alt=&quot;UTOOLS1546959876945.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用场景-2&quot;&gt;3.2使用场景&lt;/h3&gt;
&lt;p&gt;ElasticNet在我们发现用Lasso回归太过(太多特征被稀疏为0),而岭回归也正则化的不够(回归系数衰减太慢)的时候，可以考虑使用ElasticNet回归来综合，得到比较好的结果。&lt;/p&gt;
&lt;h3 id=&quot;代码实现-2&quot;&gt;3.3代码实现&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn import linear_model  
#得到拟合模型，其中x_train,y_train为训练集  
ENSTest = linear_model.ElasticNetCV(alphas=[0.0001, 0.0005, 0.001, 0.01, 0.1, 1, 10], l1_ratio=[.01, .1, .5, .9, .99],  max_iter=5000).fit(x_train, y_train)  
#利用模型预测，x_test为测试集特征变量  
y_prediction = ENSTest.predict(x_test)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;.&lt;/p&gt;
&lt;p&gt;.&lt;/p&gt;
&lt;p&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13876065-08b587647d14267c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;欢迎添加微信交流！请备注“机器学习”。&lt;/p&gt;
</description>
<pubDate>Tue, 08 Jan 2019 15:43:00 +0000</pubDate>
<dc:creator>mantch</dc:creator>
<og:description>1.L2正则化(岭回归) 1.1问题 想要理解什么是正则化，首先我们先来了解上图的方程式。当训练的特征和数据很少时，往往会造成欠拟合的情况，对应...</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mantch/p/10242077.html</dc:identifier>
</item>
<item>
<title>呵呵气象台 - 正版乔</title>
<link>http://www.cnblogs.com/qiaohaoforever/p/10242016.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiaohaoforever/p/10242016.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt; 每天叫醒你的除了梦想，还有呵呵气象台。&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;    2017-2-22 22:12，承载着对外经贸1238宿舍3号床的梦想和希望的“呵呵气象台”成功发出来了第一条微博播报。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;    树莓派DHT11温湿度传感器每日播报，至今已播报304条，还在继续～&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;简单来说就是，树莓派定时通过DHT11温湿度传感器查询当前室内温湿度，然后通过调用微博API将获取到的数据发送出来，每日七点准发送！&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;呵呵气象台&lt;/span&gt;每日7点准时为你播报～&lt;/p&gt;

&lt;div&gt;&lt;span&gt;对了，昨天有朋友对&lt;/span&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3NTM1NzM4MQ==&amp;amp;mid=2247483741&amp;amp;idx=1&amp;amp;sn=3bcf69d6ced8a2027c94fbd3b175a91e&amp;amp;chksm=eb074af7dc70c3e1d1783861f3006394db9c2b4a781621b062414aaf1d5aeef302d193910a4a&amp;amp;scene=21#wechat_redirect&quot;&gt;SQL行列乾坤大挪移&lt;/a&gt;&lt;span&gt;提出一种很好对方案，&lt;/span&gt;&lt;span&gt;SQL：使用&lt;/span&gt;&lt;span&gt;PIVOT&lt;/span&gt;&lt;span&gt; 行转列和&lt;/span&gt;&lt;span&gt;UNPIVOT &lt;/span&gt;&lt;span&gt;列转行。&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;推荐阅读：&lt;/span&gt;&lt;/p&gt;


&lt;hr/&gt;

&lt;p&gt;&lt;span&gt;一个学统计的程序员&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;喜欢Coding&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;喜欢硬件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;喜欢树莓派&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;喜欢深度学习&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;喜欢你&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;data:image/jpeg;base64,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&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;





</description>
<pubDate>Tue, 08 Jan 2019 15:18:00 +0000</pubDate>
<dc:creator>正版乔</dc:creator>
<og:description>“ 每天叫醒你的除了梦想，还有呵呵气象台。” 2017-2-22 22:12，承载着对外经贸1238宿舍3号床的梦想和希望的“呵呵气象台”成功发出来了第一条微博播报。 树莓派DHT11温湿度</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qiaohaoforever/p/10242016.html</dc:identifier>
</item>
</channel>
</rss>