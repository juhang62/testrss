<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>基于springboot实现http响应异常信息国际化 - 元气满满FLY</title>
<link>http://www.cnblogs.com/flylinran/p/10231186.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flylinran/p/10231186.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;国际化是指在设计软件，将软件与特定语言及地区脱钩的过程。当软件被移植到不同的语言及地区时，软件本身不用做内部工程上的改变或修正。&lt;/p&gt;
&lt;p&gt;本文提到的异常响应信息国际化是指：前端向后台发起请求，后台在处理逻辑中发生异常，把异常信息返回给前端，返回的异常信息应该支持国际化，能够对应特定的语言、地区等环境。例如，中文语言环境下返回的异常信息应该是中文的，英文语言环境下返回的则是对应的英文。&lt;/p&gt;
&lt;p&gt;javaweb项目中，不管是对底层的数据操作，还是业务层的处理过程，还是控制层的处理，都不可避免的会遇到各种可预知的(业务异常主动抛出)、不可预知的异常需要处理。一般dao层、service层的异常都会直接抛出，最后由controller统一进行处理，并对前端请求进行异常响应。针对此处的业务异常应该做到设计合理，统一格式，并且支持国际化。&lt;/p&gt;
&lt;p&gt;springboot是一个开源的Java／Java EE的应用程序框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。利用springboot提供的API库，我们能方便地做到全局异常统一拦截，并且Spring提供了完善的国际化支持，在此基础上，我们能方便地做到全局异常信息的国际化。&lt;/p&gt;
&lt;h2 id=&quot;原来存在的方案&quot;&gt;原来存在的方案：&lt;/h2&gt;
&lt;ol readability=&quot;8&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;局部的异常信息国际化：程序在抛出异常时手动设置好国际化之后的异常message。&lt;/p&gt;
&lt;p&gt;此种方案代码耦合性强，代码繁琐，处理逻辑过程中抛出异常时还得额外考虑对异常进行国际化操作，使得代码逻辑无法很好的集中在业务逻辑的处理。示意图如图1.1。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1500609/201901/1500609-20190107001756316-1666451947.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;半异常信息国际化：程序中未采用配置文件来记录国际化资源，而是直接在程序中写死了固定的异常值，每条异常值记录分别对应着不同的异常编号、某几种语言的异常信息。&lt;/p&gt;
&lt;p&gt;这是目前比较常见的方式，写起来方便，不需要在程序抛出异常时做国际化，只需在全局异常拦截中做统一的异常返回。但是，这种方式支持的异常信息比较单一，不能轻易添加多种语言的支持，只能改动现有程序的代码。示意图如图1.2。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1500609/201901/1500609-20190107001850764-457273153.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;使用编程语言自带的异常本地化接口。&lt;/p&gt;
&lt;p&gt;不少后台语言提供了异常信息本地化接口，比如java提供的java.lang.Throwable#getLocalizedMessage方法，但是这种方式只能获取到本地语言相关的对应的信息，并不能很好的支持多种语言，以及多种语言间的自由切换。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;现在的方案&quot;&gt;现在的方案&lt;/h2&gt;
&lt;p&gt;此方案结合异常码、字符串占位符和资源文件的特点及优势。异常码可理解为一个异常信息的ID，具有唯一性，必要性；异常信息资源文件中的值可包含占位符（格式为{n}），处理异常时可用实际值替换，达到异常信息的进一步具体化，但不是必须的。资源文件就是内容为“异常码=提心信息”的记录的文件。&lt;/p&gt;
&lt;p&gt;方案具体描述如下：&lt;/p&gt;
&lt;ol readability=&quot;7&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;首先，在springboot项目中定义系统的http请求统一返回的数据格式，此处我们的定义包含三个属性： code(业务异常状态码)、message(异常提示信息)、data(无异常时返回的数据体)。对异常信息国际化主要体现在message属性，也就是返回前端给用户展示的异常提示信息。code属性用于确定唯一的异常。其次定义需要抛出的业务异常，其中主要包括code（异常码）和params（用于替换异常信息字符串占位符{n}的实际值）属性。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;在项目路径下定义异常信息的资源文件，文件内容包含多条记录，每条记录为键值对的形式，即key=value。对需要实现的语言种类分别提供一份对应的文件，这些文件名除默认信息外，均包含语言（地区信息），文件中包含中key是一致的，value为相应语言的字符串组成。如果添加语言的支持，只需要添加一份对应的资源文件即可。以下包含默认、英文环境和简体中文环境下对应的异常提示信息国际化资源文件，如图2.1&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1500609/201901/1500609-20190107002113267-1685070145.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;利用springboot的提供的接口定义统一拦截器，并且注入http请求上下文和资源获取器，在拦截器中对应用抛出的异常进行捕获，针对上述特定的异常做国际化处理。&lt;br/&gt;其国际化处理逻辑如下：根据http请求传入的语言信息指定特定的语言（地区）环境，如没有传入语言信息，则采用应用默认的语言配置；据此读取上述编写好的对应的异常信息资源文件，并依据捕获的异常中的code（异常码）查到到对应的字符串，将params实际值替换掉字符串中的占位符，完成后即为返回给前端的异常提示信息。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1500609/201901/1500609-20190107002128704-1681813934.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在controller、service和dao层中根据程序逻辑抛出相应异常，其中异常码应该在资源文件中已定义。示例代码如下图2.3&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1500609/201901/1500609-20190107002146261-810007791.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;整体流程图如下图2.4&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1500609/201901/1500609-20190107002208995-253063122.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;demo&quot;&gt;demo&lt;/h2&gt;
&lt;p&gt;以下是一个demo，其中提供了必要的代码注释，以便于理解。&lt;/p&gt;
&lt;p&gt;请求1：&lt;code&gt;http://127.0.0.1:8080/demo?lang=en&amp;amp;msg=a&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;返回：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1500609/201901/1500609-20190107002440656-563086451.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请求2：&lt;code&gt;http://127.0.0.1:8080/demo?lang=zh_CN&amp;amp;msg=a&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;返回：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1500609/201901/1500609-20190107002515919-1385151849.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请求3：&lt;code&gt;http://127.0.0.1:8080/demo?lang=en&amp;amp;msg=c&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;返回：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1500609/201901/1500609-20190107002537062-948463214.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请求4：&lt;code&gt;http://127.0.0.1:8080/demo?lang=zh_CN&amp;amp;msg=c&lt;/code&gt;&lt;br/&gt;返回：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1500609/201901/1500609-20190107002555191-1940319590.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;此方案能较好地处理异常信息的国际化，能自如地添加资源文件，不需要改动此方案的现有代码，这也使得程序耦合性降低；&lt;/li&gt;
&lt;li&gt;统一的异常格式定义、全局异常拦截极大程度上减少了代码耦合性，大大简化了团队编码中对异常逻辑的处理，能减少重复性编码，有利于提高工作效率；&lt;/li&gt;
&lt;li&gt;现有方案未能较好地支持异常信息中特定值的支持，此方案利用设置占位符的方式，较好地做到了支持，灵活方便；&lt;/li&gt;
&lt;li&gt;springboot支持的国际化实现中默认提供了缓存支持，性能良好。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;（文中配图有空再改!!）&lt;/p&gt;
</description>
<pubDate>Sun, 06 Jan 2019 16:34:00 +0000</pubDate>
<dc:creator>元气满满FLY</dc:creator>
<og:description>背景 国际化是指在设计软件，将软件与特定语言及地区脱钩的过程。当软件被移植到不同的语言及地区时，软件本身不用做内部工程上的改变或修正。 本文提到的异常响应信息国际化是指：前端向后台发起请求，后台在处理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flylinran/p/10231186.html</dc:identifier>
</item>
<item>
<title>在.Net Core WebAPI下给Swagger增加导出离线文档功能 - 铁梧桐</title>
<link>http://www.cnblogs.com/hjjblog/p/10231180.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hjjblog/p/10231180.html</guid>
<description>&lt;h3&gt;一丶前言&lt;/h3&gt;
&lt;p&gt;  最近刚接触到Swagger，在github上下载了它的源码和demo学习了一遍，发现这个组件非常好用，不过不足的是它没有导出离线文档的功能，于是乎我就想给它加一个导出功能&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/domaindrivendev/Swashbuckle.AspNetCore&quot; target=&quot;_blank&quot;&gt; Swagger Github开源地址&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;二丶代码还原讲解&quot;&gt;二丶思路&lt;/h3&gt;
&lt;p&gt;其实说白了api文档就是一个html静态页面，html可以转word或者pdf，那问题就变简单了。&lt;/p&gt;
&lt;p&gt;1.想办法拿到swagger生成的api接口json数据。&lt;/p&gt;
&lt;p&gt;2.将json转化为html。&lt;/p&gt;
&lt;p&gt;3.将html转换成word或者pdf等文件。&lt;/p&gt;
&lt;h3 id=&quot;二丶代码还原讲解&quot;&gt;三丶实现&lt;/h3&gt;
&lt;p&gt;1.首先我们要解决第一个问题，要给Swagger的页面上加上导出按钮，Swagger提供了接口，我们可以用这个接口将js和css注入进去执行，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1106680/201901/1106680-20190106232742199-157715179.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1106680/201901/1106680-20190106232847669-1840119900.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1106680/201901/1106680-20190106233013414-1669286175.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.拿到swagger生成的文档数据，我查阅了swagger github上的的源码找到了他生成文档的代码，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1106680/201901/1106680-20190106231737728-1591310226.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.然后我们使用net core的ioc容器注入把这个对象注入到ioc容器中，以备后续使用它，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1106680/201901/1106680-20190106232112960-22128185.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.从ioc容器中取出对象使用，将json对象转换为html，在将html转换为需要导出的文件。&lt;/p&gt;
&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1106680/201901/1106680-20190106234359248-1242295307.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里用到了一个&lt;a href=&quot;https://blog.csdn.net/xue251248603/article/details/77085486&quot; target=&quot;_blank&quot;&gt;RazorEngine&lt;/a&gt; ，这是一个微软封装的模板引擎，最重要一点它可以脱离mvc使用，可以用它来定制自己的代码生成器，个人认为它比T4好用，吐槽一下，T4的语法看着是真的别扭。。再看RazorEngine语法看着舒服多了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1106680/201901/1106680-20190106234719490-878757668.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是不是很熟悉。&lt;/p&gt;
&lt;p&gt;最终效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1106680/201901/1106680-20190107000621750-840566449.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3 id=&quot;二丶代码还原讲解&quot;&gt;四丶结语&lt;/h3&gt;
&lt;p&gt;到这就结束了，其实也没有啥难度，就是要花时间累代码。IT最让人着迷的就是开源了，没有比学习别人的代码成长更快的了，我也支持一下开源。最后再感谢一下园友 &lt;a href=&quot;https://www.cnblogs.com/laozhang-is-phi/&quot; target=&quot;_blank&quot;&gt;@老张的哲学&lt;/a&gt; 的帮助。&lt;/p&gt;
&lt;h3 id=&quot;二丶代码还原讲解&quot;&gt;五丶Github Demo，演示地址&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/HanJunJun/Titan.Blog.WebAPP&quot; target=&quot;_blank&quot;&gt;Demo地址，顺便给个Star谢谢了。&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://gaobili.cn:8600/swagger/index.html&quot; target=&quot;_blank&quot;&gt;演示地址：http://gaobili.cn:8600/swagger/index.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img id=&quot;uploading_image_22795&quot; src=&quot;https://common.cnblogs.com/images/loading.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 06 Jan 2019 16:26:00 +0000</pubDate>
<dc:creator>铁梧桐</dc:creator>
<og:description>一丶前言 最近刚接触到Swagger，在github上下载了它的源码和demo学习了一遍，发现这个组件非常好用，不过不足的是它没有导出离线文档的功能，于是乎我就想给它加一个导出功能 Swagger G</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hjjblog/p/10231180.html</dc:identifier>
</item>
<item>
<title>HashMap 源码阅读 - 小眼儿</title>
<link>http://www.cnblogs.com/hujunzheng/p/10231097.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hujunzheng/p/10231097.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;　　之前读过一些类的源码，近来发现都忘了，再读一遍整理记录一下。这次读的是 JDK 11 的代码，贴上来的源码会去掉大部分的注释, 也会加上一些自己的理解。&lt;/p&gt;
&lt;h2 id=&quot;map-接口&quot;&gt;Map 接口&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;https://pics-1257963040.cos.ap-shanghai.myqcloud.com/20181231181859.png&quot; alt=&quot;&quot; width=&quot;689&quot; height=&quot;370&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　这里提一下 Map 接口与1.8相比 Map接口又新增了几个方法：&lt;br/&gt;　　&lt;img src=&quot;https://pics-1257963040.cos.ap-shanghai.myqcloud.com/20190101212411.png&quot; alt=&quot;&quot; width=&quot;686&quot; height=&quot;403&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这些方法都是包私有的static方法；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;of()&lt;/code&gt;方法分别返回包含 0 - 9 个键值对的不可修改的Map；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ofEntries()&lt;/code&gt;方法返回包含从给定的&lt;code&gt;entries&lt;/code&gt;总提取出来的键值对的不可修改的* Map（不会包含给定的&lt;code&gt;entries&lt;/code&gt;）；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;entry()&lt;/code&gt;方法返回包含键值对的不可修改的 Entry，不允许 null 作为 key 或 value；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;copyOf()&lt;/code&gt;返回一个不可修改的，包含给定 Map 的 entries 的 Map ，调用了&lt;code&gt;ofEntries()&lt;/code&gt;方法.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;数据结构&quot;&gt;数据结构&lt;/h2&gt;
&lt;p&gt;　　HashMap 是如何存储键值对的呢?　　&lt;/p&gt;
&lt;p&gt;　　HashMap 有一个属性 table:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;transient&lt;/span&gt; Node&amp;lt;K,V&amp;gt;[] table;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　table 是一个 Node 的数组, 在首次使用和需要 resize 时进行初始化; 这个数组的长度始终是2的幂, 初始化时是0, 因此能够使用位运算来代替模运算.&lt;/p&gt;
&lt;p&gt;　　HashMap的实现是装箱的(binned, bucketed), 一个 bucket 是 table 数组中的一个元素, 而 bucket 中的元素称为 bin .&lt;/p&gt;
&lt;p&gt;　　来看一下 Node , 很显然是一个单向链表:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Node&amp;lt;K,V&amp;gt; &lt;span&gt;implements&lt;/span&gt; Map.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash;
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; K key;
    V value;
    Node&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; next;
    
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当然, 我们都知道 bucket 的结构是会在链表和红黑树之间相互转换的:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 转换成红黑树&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; -1 for 1st&lt;/span&gt;
&lt;span&gt;    treeifyBin(tab, hash);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 转换成链表结构&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (lc &amp;lt;=&lt;span&gt; UNTREEIFY_THRESHOLD)
    tab[index] &lt;/span&gt;= loHead.untreeify(map);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意在 &lt;code&gt;treeifyBin()&lt;/code&gt; 方法中:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; table 为 null 或者 capacity 小于 MIN_TREEIFY_CAPACITY 会执行 resize() 而不是转换成树结构&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (tab == &lt;span&gt;null&lt;/span&gt; || (n = tab.length) &amp;lt;&lt;span&gt; MIN_TREEIFY_CAPACITY)
    resize();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　TreeNode 的结构和 TreeMap 相似, 并且实现了 tree 版本的一些方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TreeNode&amp;lt;K,V&amp;gt; &lt;span&gt;extends&lt;/span&gt; LinkedHashMap.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; {
    TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; parent;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; red-black tree links&lt;/span&gt;
    TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt; left;
    TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; right;
    TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; prev;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; needed to unlink next upon deletion&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; red;

    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;initialcapacity-和-loadfactor&quot;&gt;initialCapacity 和 loadFactor&lt;/h2&gt;
&lt;p&gt;　　先看一下 HashMap 的4个构造器，可以发现3个重要的 int ：threshold，initialCapacity 和 loadFactor ，其中 threshold 和 loadFactor 是 HashMap 的私有属性。&lt;/p&gt;
&lt;p&gt;　　HashMap 的 javadoc 中有相关的解释：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;capacity，HashMap 的哈希表中桶的数量；&lt;/li&gt;
&lt;li&gt;initial capacity ，哈希表创建时桶的数量；&lt;/li&gt;
&lt;li&gt;load factor ，在 capacity 自动增加(&lt;code&gt;resize()&lt;/code&gt;)之前，哈希表允许的填满程度；&lt;/li&gt;
&lt;li&gt;threshold，下一次执行&lt;code&gt;resize()&lt;/code&gt;时 size 的值 (capacity * load factor)，如果表没有初始化，存放的是表的长度，为0时表的长度将会是 &lt;code&gt;DEFAULT_INITIAL_CAPACITY&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　注意: 构造器中的 initialCapacity 参数并不是 table 的实际长度, 而是期望达到的值, 实际值一般会大于等于给定的值. initialCapacity 会经过&lt;code&gt;tableSizeFor()&lt;/code&gt; 方法, 得到一个不大于 MAXIMUM_CAPACITY 的足够大的2的幂, 来作为table的实际长度:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; tableSizeFor(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; cap) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = -1 &amp;gt;&amp;gt;&amp;gt; Integer.numberOfLeadingZeros(cap - 1&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (n &amp;lt; 0) ? 1 : (n &amp;gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　loadFactor 的默认值是 0.75f ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; DEFAULT_LOAD_FACTOR = 0.75f;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　initialCapacity 的默认值是16：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; aka 16&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　capacity 的最大值是1073741824：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在 new 一个 HasMap 时，应该根据 mapping 数量尽量给出 initialCapacity , 减少表容量自增的次数 . &lt;code&gt;putMapEntries()&lt;/code&gt; 方法给出了一种计算 initialCapacity 的方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;float&lt;/span&gt; ft = ((&lt;span&gt;float&lt;/span&gt;)s / loadFactor) + 1.0F&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; t = ((ft &amp;lt; (&lt;span&gt;float&lt;/span&gt;)MAXIMUM_CAPACITY) ?&lt;span&gt;
         (&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)ft : MAXIMUM_CAPACITY);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t &amp;gt;&lt;span&gt; threshold)
    threshold &lt;/span&gt;= tableSizeFor(t);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这段代码里的 t 就是 capacity .&lt;/p&gt;
&lt;h2 id=&quot;hash-方法&quot;&gt;hash() 方法&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;　　hash()&lt;/code&gt; 是 HashMap 用来计算 key 的 hash 值的方法, 这个方法并不是直接返回 key 的 &lt;code&gt;hashCode()&lt;/code&gt; 方法的返回值, 而是将 hashCode 的高位移到低位后 再与原值异或.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash(Object key) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; h;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　因为 HashMap 用 &lt;code&gt;hash &amp;amp; (table.length-1)&lt;/code&gt;代替了 模运算 , 如果直接使用 &lt;code&gt;hashCode()&lt;/code&gt; 的返回值的话, 只有hash code的低位(如果 table.length 是2的n次方, 只有最低的 n - 1 位)会参加运算, 高位即使发生变化也会产生碰撞. 而 &lt;code&gt;hash()&lt;/code&gt; 方法把 hashCode 的高位与低位异或, 相当于高位也参加了运算, 能够减少碰撞.&lt;/p&gt;
&lt;p&gt;　　举个例子:&lt;br/&gt;　　假设 table.length - 1 的 值为 0000 0111, 有两个hash code : 0001 0101 和 0000 0101. 这两个hash code 分别与 table.length - 1 做与运算之后的结果是一样的: 0000 0101; 将这两个hash code 的高位和低位异或之后分别得到: 0001 0100、 0000 0101, 此时再分别与 table.length - 1 做与运算的结果是 0000 0100 和 0000 0101, 不再碰撞了.&lt;/p&gt;
&lt;h2 id=&quot;resize&quot;&gt;resize()&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;　　resize()&lt;/code&gt; 方法负责初始化或扩容 table. 如果 table 为 null 初始化 table 为 一个长度为 threshold 或 DEFAULT_INITIAL_CAPACITY的表; 否则将 table 的长度加倍, 旧 table 中的元素要么呆在原来的 index 要么以2的幂为偏移量在新 table中移动:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt;&lt;span&gt;[] resize() {
   Node&lt;/span&gt;&amp;lt;K,V&amp;gt;[] oldTab =&lt;span&gt; table;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; oldCap = (oldTab == &lt;span&gt;null&lt;/span&gt;) ? 0&lt;span&gt; : oldTab.length;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; oldThr =&lt;span&gt; threshold;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; newCap, newThr = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (oldCap &amp;gt; 0&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (oldCap &amp;gt;=&lt;span&gt; MAXIMUM_CAPACITY) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 旧 table 的容量已经达到最大, 不扩容, 返回旧表&lt;/span&gt;
            threshold =&lt;span&gt; Integer.MAX_VALUE;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldTab;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((newCap = oldCap &amp;lt;&amp;lt; 1) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;&lt;span&gt;
                 oldCap &lt;/span&gt;&amp;gt;=&lt;span&gt; DEFAULT_INITIAL_CAPACITY)
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将旧容量加倍作为新表容量, 如果新表容量没达到容量最大值, 并且旧容量大于等于默认容量, threshold 加倍&lt;/span&gt;
            newThr = oldThr &amp;lt;&amp;lt; 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; double threshold&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (oldThr &amp;gt; 0) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; initial capacity was placed in threshold
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 旧的threshold 不为 0 , 旧 threshold 作为新表的容量&lt;/span&gt;
        newCap =&lt;span&gt; oldThr;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {               &lt;span&gt;//&lt;/span&gt;&lt;span&gt; zero initial threshold signifies using defaults
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 旧 threshold 为 0 , 用 DEFAULT_INITIAL_CAPACITY 作为新容量, 用默认值计算新 threshold&lt;/span&gt;
        newCap =&lt;span&gt; DEFAULT_INITIAL_CAPACITY;
        newThr &lt;/span&gt;= (&lt;span&gt;int&lt;/span&gt;)(DEFAULT_LOAD_FACTOR *&lt;span&gt; DEFAULT_INITIAL_CAPACITY);
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (newThr == 0&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 之前没有计算过新 threshold , 计算 threshold&lt;/span&gt;
        &lt;span&gt;float&lt;/span&gt; ft = (&lt;span&gt;float&lt;/span&gt;)newCap *&lt;span&gt; loadFactor;
        newThr &lt;/span&gt;= (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (&lt;span&gt;float&lt;/span&gt;)MAXIMUM_CAPACITY ?&lt;span&gt;
                  (&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)ft : Integer.MAX_VALUE);
    }
    threshold &lt;/span&gt;=&lt;span&gt; newThr;
    @SuppressWarnings({&lt;/span&gt;&quot;rawtypes&quot;,&quot;unchecked&quot;&lt;span&gt;})
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建新表数组, 更新表引用&lt;/span&gt;
    Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node[newCap];
    table &lt;/span&gt;=&lt;span&gt; newTab;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (oldTab != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将旧表中的元素移动到新表&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; oldCap; ++&lt;span&gt;j) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历旧表&lt;/span&gt;
            Node&amp;lt;K,V&amp;gt;&lt;span&gt; e;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((e = oldTab[j]) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 帮助 GC&lt;/span&gt;
                oldTab[j] = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.next == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个桶里只有一个元素, 此处用位运算代替了模运算&lt;/span&gt;
                    newTab[e.hash &amp;amp; (newCap - 1)] =&lt;span&gt; e;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; TreeNode)
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果这个 bucket 的结构是树, 将这个 bucket 中的元素分为高低两部分((e.hash &amp;amp; bit) == 0 就分在低的部分, bit 是 oldCap), 低的部分留在原位, 高的部分放到 newTab[j + oldCap]; 如果某一部分的元素个数小于 UNTREEIFY_THRESHOLD 将这一部分转换成链表形式, 否则就形成新的树结构&lt;/span&gt;
                    ((TreeNode&amp;lt;K,V&amp;gt;)e).split(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, newTab, j, oldCap);
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; preserve order
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将普通结构的 bucket 中的元素分为高低两部分, 低的部分留在原位, 高的部分放到 newTab[j + oldCap]&lt;/span&gt;
                    Node&amp;lt;K,V&amp;gt; loHead = &lt;span&gt;null&lt;/span&gt;, loTail = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    Node&lt;/span&gt;&amp;lt;K,V&amp;gt; hiHead = &lt;span&gt;null&lt;/span&gt;, hiTail = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    Node&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; next;
                    &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
                        next &lt;/span&gt;=&lt;span&gt; e.next;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((e.hash &amp;amp; oldCap) == 0&lt;span&gt;) {
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (loTail == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                                loHead &lt;/span&gt;=&lt;span&gt; e;
                            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                                loTail.next &lt;/span&gt;=&lt;span&gt; e;
                            loTail &lt;/span&gt;=&lt;span&gt; e;
                        }
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (hiTail == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                                hiHead &lt;/span&gt;=&lt;span&gt; e;
                            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                                hiTail.next &lt;/span&gt;=&lt;span&gt; e;
                            hiTail &lt;/span&gt;=&lt;span&gt; e;
                        }
                    } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((e = next) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (loTail != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        loTail.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                        newTab[j] &lt;/span&gt;=&lt;span&gt; loHead;
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (hiTail != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        hiTail.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                        newTab[j &lt;/span&gt;+ oldCap] =&lt;span&gt; hiHead;
                    }
                }
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; newTab;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　举个例子解释一下高低两部分的划分:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;扩容前 table.length 是 0000 1000 记为 oldCap , table.length - 1 是 0000 0111 记为 oldN;&lt;/li&gt;
&lt;li&gt;扩容后 table.length 是 0001 0000 记为 newCap, table.length - 1 为 0000 1111 记为 newN;&lt;/li&gt;
&lt;li&gt;有两个Node, hash ( &lt;code&gt;hash()&lt;/code&gt; 方法得到的值)分别为 0000 1101 和 0000 0101 记为 n1 和 n2;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　在扩容前, n1 和 n2 显然是在一个 bucket 里的, 但在扩容后 n1 &amp;amp; newN 和 n2 &amp;amp; newN 的值分别是 0000 1101 和 0000 0101, 这是需要划分成两部分, 并且把属于高部分的 bin 移动到新的 bucket 里的原因.&lt;/p&gt;
&lt;p&gt;　　扩容后, hash 中只会有最低的4位参加 index 的计算, 因此可以用第4位来判断属于高部分还是低部分, 也就可以用 &lt;code&gt;(hash &amp;amp; oldCap) == 0&lt;/code&gt; 来作为属于低部分的依据了.&lt;/p&gt;
&lt;h2 id=&quot;查找&quot;&gt;查找&lt;/h2&gt;
&lt;p&gt;　　查找方法只有 &lt;code&gt;get()&lt;/code&gt; 和 &lt;code&gt;getOrDefault()&lt;/code&gt; 两个, 都是调用了 &lt;code&gt;getNode()&lt;/code&gt;方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V get(Object key) {
    Node&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; e;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (e = getNode(hash(key), key)) == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : e.value;
}

@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V getOrDefault(Object key, V defaultValue) {
    Node&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; e;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (e = getNode(hash(key), key)) == &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt; defaultValue : e.value;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;getnode-方法&quot;&gt;getNode() 方法&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt; getNode(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash, Object key) {
    Node&lt;/span&gt;&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; first, e; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n; K k;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((tab = table) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (n = tab.length) &amp;gt; 0 &amp;amp;&amp;amp;&lt;span&gt;
        (first &lt;/span&gt;= tab[(n - 1) &amp;amp; hash]) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; table 已经被初始化且 table 的长度不为 0 且 对应的 bucket 里有 bin&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (first.hash == hash &amp;amp;&amp;amp; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; always check first node&lt;/span&gt;
            ((k = first.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一个节点的 key 和 给定的 key 相同&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; first;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((e = first.next) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; bucket 中还有下一个 bin&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (first &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; TreeNode)
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是树结构的 bucket, 调用树版本的 getNode 方法&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; ((TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt;)first).getTreeNode(hash, key);
            &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在普通的链表中查找 key&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp;&lt;span&gt;
                    ((k &lt;/span&gt;= e.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e;
            } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((e = e.next) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;遍历&quot;&gt;遍历&lt;/h2&gt;
&lt;p&gt;　　可以通过&lt;code&gt;entrySet()&lt;/code&gt;、&lt;code&gt;keySet()&lt;/code&gt;、&lt;code&gt;values()&lt;/code&gt;分别获得 &lt;code&gt;EntrySet&lt;/code&gt;、&lt;code&gt;KeySet()&lt;/code&gt;和&lt;code&gt;Values&lt;/code&gt;对象, 他们的迭代器都是&lt;code&gt;HashIterator&lt;/code&gt;的子类.&lt;/p&gt;
&lt;h3 id=&quot;fast-fail-和-modcount&quot;&gt;fast-fail 和 modCount&lt;/h3&gt;
&lt;p&gt;　　HashMap 不是线程安全的, 并且实现了 fast-fail 机制. 当一个迭代器被创建的时候(或者迭代器自身的 remove() 方法被调用), 会记录当前的 modCount 作为期待中的 modCount, 并在操作中先检查当前 modCount 是不是和旧的 modCount 相同, 不同则会抛出&lt;code&gt;ConcurrentModificationException&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;　　任何结构修改(新增或删除节点)都会改变 modCount 的值.&lt;/p&gt;
&lt;h2 id=&quot;新增和更新&quot;&gt;新增和更新&lt;/h2&gt;
&lt;p&gt;　　1.8 之前有4个方法和构造器能够往 HashMap 中添加键值对: 以一个Map为参数的构造器、&lt;code&gt;put()&lt;/code&gt;、&lt;code&gt;putAll()&lt;/code&gt;、&lt;code&gt;putIfAbsent()&lt;/code&gt;,&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; HashMap(Map&amp;lt;? &lt;span&gt;extends&lt;/span&gt; K, ? &lt;span&gt;extends&lt;/span&gt; V&amp;gt;&lt;span&gt; m) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.loadFactor =&lt;span&gt; DEFAULT_LOAD_FACTOR;
    putMapEntries(m, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V put(K key, V value) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; putVal(hash(key), key, value, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; putAll(Map&amp;lt;? &lt;span&gt;extends&lt;/span&gt; K, ? &lt;span&gt;extends&lt;/span&gt; V&amp;gt;&lt;span&gt; m) {
    putMapEntries(m, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
}

@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V putIfAbsent(K key, V value) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; putVal(hash(key), key, value, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　他们分别调用了&lt;code&gt;putMapEntries()&lt;/code&gt;和&lt;code&gt;putVal()&lt;/code&gt;. 这两个方法中有一个参数 evict , 仅当初始化时(构造器中)为 false.&lt;/p&gt;
&lt;h3 id=&quot;putval-方法&quot;&gt;putVal() 方法&lt;/h3&gt;
&lt;p&gt;　　来看一下&lt;code&gt;putVal()&lt;/code&gt; 方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; V putVal(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; onlyIfAbsent,
                   &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; evict) {
    Node&lt;/span&gt;&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n, i;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((tab = table) == &lt;span&gt;null&lt;/span&gt; || (n = tab.length) == 0&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; table 未被初始化或者长度为 0 时, 执行 resize()&lt;/span&gt;
        n = (tab =&lt;span&gt; resize()).length;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((p = tab[i = (n - 1) &amp;amp; hash]) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对应的 bucket 里没有元素, 新建一个普通 Node 放到这个位置&lt;/span&gt;
        tab[i] = newNode(hash, key, value, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        Node&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; e; K k;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p.hash == hash &amp;amp;&amp;amp;&lt;span&gt;
            ((k &lt;/span&gt;= p.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一个节点的 key 和 给定的 key 相同&lt;/span&gt;
            e =&lt;span&gt; p;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (p &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; TreeNode)
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 树结构, 调用树版本的 putVal, 如果树结构中存在 key, 将会返回相应的 TreeNode, 否则返回 null&lt;/span&gt;
            e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, tab, hash, key, value);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; binCount = 0; ; ++&lt;span&gt;binCount) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((e = p.next) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在链表中没有找到 key, 新建一个节点放到链表末尾&lt;/span&gt;
                    p.next = newNode(hash, key, value, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; -1 for 1st
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前桶转换成树结构&lt;/span&gt;
&lt;span&gt;                        treeifyBin(tab, hash);
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp;&lt;span&gt;
                    ((k &lt;/span&gt;= e.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; key 相同 break&lt;/span&gt;
                    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                p &lt;/span&gt;=&lt;span&gt; e;
            }
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; existing mapping for key
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; key 在 map 中存在&lt;/span&gt;
            V oldValue =&lt;span&gt; e.value;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!onlyIfAbsent || oldValue == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 覆盖旧值&lt;/span&gt;
                e.value =&lt;span&gt; value;
            afterNodeAccess(e);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; key 之前在 map 中不存在, 发生了结构变化, modCount 增加 1&lt;/span&gt;
    ++&lt;span&gt;modCount;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (++size &amp;gt;&lt;span&gt; threshold)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 扩容&lt;/span&gt;
&lt;span&gt;        resize();
    afterNodeInsertion(evict);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;HashMap 提供了三个回调方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; afterNodeAccess(Node&amp;lt;K,V&amp;gt;&lt;span&gt; p) { }
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; afterNodeInsertion(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; evict) { }
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; afterNodeRemoval(Node&amp;lt;K,V&amp;gt; p) { }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;putmapentries-方法&quot;&gt;putMapEntries() 方法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;　　putMapEntries()&lt;/code&gt;方法就简单多了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; putMapEntries(Map&amp;lt;? &lt;span&gt;extends&lt;/span&gt; K, ? &lt;span&gt;extends&lt;/span&gt; V&amp;gt; m, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; evict) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; s =&lt;span&gt; m.size();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s &amp;gt; 0&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (table == &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; pre-size
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; table 还没有初始化, 计算出 threshold&lt;/span&gt;
            &lt;span&gt;float&lt;/span&gt; ft = ((&lt;span&gt;float&lt;/span&gt;)s / loadFactor) + 1.0F&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; t = ((ft &amp;lt; (&lt;span&gt;float&lt;/span&gt;)MAXIMUM_CAPACITY) ?&lt;span&gt;
                     (&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)ft : MAXIMUM_CAPACITY);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t &amp;gt;&lt;span&gt; threshold)
                threshold &lt;/span&gt;=&lt;span&gt; tableSizeFor(t);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (s &amp;gt;&lt;span&gt; threshold)
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; s 超过了 threshold, 扩容&lt;/span&gt;
&lt;span&gt;            resize();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Map.Entry&amp;lt;? &lt;span&gt;extends&lt;/span&gt; K, ? &lt;span&gt;extends&lt;/span&gt; V&amp;gt;&lt;span&gt; e : m.entrySet()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用 putVal() 方法, 将键值对放进 map&lt;/span&gt;
            K key =&lt;span&gt; e.getKey();
            V value &lt;/span&gt;=&lt;span&gt; e.getValue();
            putVal(hash(key), key, value, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, evict);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;删除&quot;&gt;删除&lt;/h2&gt;
&lt;p&gt;　　删除元素有三个方法, 还有 EntrySet 和 KeySet 的 remove 和 clear 方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V remove(Object key) {
    Node&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; e;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (e = removeNode(hash(key), key, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;)) == &lt;span&gt;null&lt;/span&gt; ?
        &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : e.value;
}

@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; remove(Object key, Object value) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; removeNode(hash(key), key, value, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clear() {
    Node&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt;[] tab;
    modCount&lt;/span&gt;++&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((tab = table) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; size &amp;gt; 0&lt;span&gt;) {
        size &lt;/span&gt;= 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; tab.length; ++&lt;span&gt;i)
            tab[i] &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;removenode-方法&quot;&gt;removeNode() 方法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;　　removeNode()&lt;/code&gt; 方法有5个参数, 说明一下其中两个:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;matchValue 为 true 时, 只在 value 符合的情况下删除;&lt;/li&gt;
&lt;li&gt;movable 为 false 时, 删除时不移动其他节点, 只给树版本的删除使用.&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt; removeNode(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash, Object key, Object value,
                               &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; matchValue, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; movable) {
    Node&lt;/span&gt;&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n, index;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((tab = table) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (n = tab.length) &amp;gt; 0 &amp;amp;&amp;amp;&lt;span&gt;
        (p &lt;/span&gt;= tab[index = (n - 1) &amp;amp; hash]) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; table 已经被初始化且 table 的长度不为 0 且 对应的 bucket 里有 bin&lt;/span&gt;
        Node&amp;lt;K,V&amp;gt; node = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, e; K k; V v;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p.hash == hash &amp;amp;&amp;amp;&lt;span&gt;
            ((k &lt;/span&gt;= p.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一个的 key 和给定的 key 相同&lt;/span&gt;
            node =&lt;span&gt; p;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((e = p.next) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; bucket 中有不止一个 bin&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (p &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; TreeNode)
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 树结构, 调用树版本的 getNode&lt;/span&gt;
                node = ((TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt;)p).getTreeNode(hash, key);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在普通的 bucket 中查找 node&lt;/span&gt;
                &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp;&lt;span&gt;
                        ((k &lt;/span&gt;= e.key) == key ||&lt;span&gt;
                         (key &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k)))) {
                        node &lt;/span&gt;=&lt;span&gt; e;
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    }
                    p &lt;/span&gt;=&lt;span&gt; e;
                } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((e = e.next) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            }
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (!matchValue || (v = node.value) == value ||&lt;span&gt;
                             (value &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; value.equals(v)))) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 找到了 node , 并且符合删除条件&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (node &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; TreeNode)
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 树结构, 调用树版本的 removeNode , 如果节点过少, 会转换成链表结构&lt;/span&gt;
                ((TreeNode&amp;lt;K,V&amp;gt;)node).removeTreeNode(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, tab, movable);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (node ==&lt;span&gt; p)
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; node 是链表的第一个元素&lt;/span&gt;
                tab[index] =&lt;span&gt; node.next;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不是第一个元素&lt;/span&gt;
                p.next =&lt;span&gt; node.next;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 结构变化 modCount + 1&lt;/span&gt;
            ++&lt;span&gt;modCount;
            &lt;/span&gt;--&lt;span&gt;size;
            afterNodeRemoval(node);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;HashMap 是一个基于哈希表的装箱了的 Map 的实现; 它的数据结构是一个桶的数组, 桶的结构可能是单向链表或者红黑树, 大部分是链表.&lt;/li&gt;
&lt;li&gt;table 的容量是2的幂, 因此可以用更高效的位运算替代模运算.&lt;/li&gt;
&lt;li&gt;HashMap 使用的 hash 值, 并不是 key 的 &lt;code&gt;hashCode()&lt;/code&gt;方法所返回的值, 详细还是看上面吧.&lt;/li&gt;
&lt;li&gt;一个普通桶中的 bin 的数量超过 &lt;code&gt;TREEIFY_THRESHOLD&lt;/code&gt;, 并且 table 的容量大于 &lt;code&gt;MIN_TREEIFY_CAPACITY&lt;/code&gt;, 这个桶会被转换成树结构; 如果 bin 数量大于&lt;code&gt;TREEIFY_THRESHOLD&lt;/code&gt; , 但 table 容量小于 &lt;code&gt;MIN_TREEIFY_CAPACITY&lt;/code&gt;, 会进行扩容.&lt;/li&gt;
&lt;li&gt;每次扩容新 table 的容量是老 table 的 2 倍.&lt;/li&gt;
&lt;li&gt;扩容时, 会将原来下标为 index 的桶里的 bin 分为高低两个部分, 高的部分放到 &lt;code&gt;newTab[index + oldCap]&lt;/code&gt; 上, 低的部分放在原位; 如果某部分的 bin 的个数小于 &lt;code&gt;UNTREEIFY_THRESHOLD&lt;/code&gt; 树结构将会转换成链表结构.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;转自：&lt;a href=&quot;https://www.cnblogs.com/FJH1994/p/10227048.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/FJH1994/p/10227048.html&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 06 Jan 2019 15:56:00 +0000</pubDate>
<dc:creator>小眼儿</dc:creator>
<og:description>前言 之前读过一些类的源码，近来发现都忘了，再读一遍整理记录一下。这次读的是 JDK 11 的代码，贴上来的源码会去掉大部分的注释, 也会加上一些自己的理解。 Map 接口 这里提一下 Map 接口与</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hujunzheng/p/10231097.html</dc:identifier>
</item>
<item>
<title>mybatis-generator 详细配置及使用，爬坑记录 - 肖朋伟</title>
<link>http://www.cnblogs.com/xpwi/p/10231067.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xpwi/p/10231067.html</guid>
<description>&lt;h3 id=&quot;mybatis-generator-详细配置及使用爬坑记录&quot;&gt;mybatis-generator 详细配置及使用，爬坑记录&lt;/h3&gt;
&lt;p&gt;提示：如果不成功一定是项目路径和 数据库配置出问题，本篇基于 MySQL 8.0.13，调试没有问题。&lt;/p&gt;
&lt;p&gt;如果失败，建议使用相同的项目结构，包名，进行重试，博主也是多次调试，才成功。一些常见问题，看报错提示信息是可以看懂的，加油。&lt;/p&gt;
&lt;p&gt;整个项目的源代码，最后，也会给出下载链接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这是根据数据库，生成后的项目结构：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190106223652340.png&quot; width=&quot;80%&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;一简介&quot;&gt;一、简介：&lt;/h3&gt;
&lt;p&gt;mybatis-geneator 是一款 mybatis 自动代码生成工具，可以通过配置，快速生成 mapper 和 xml 文件。&lt;/p&gt;
&lt;h3 id=&quot;二配置方法&quot;&gt;二、配置方法：&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;（1）在项目的 pom.xml 文件中添加插件配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;详细的 pom.xml 配置：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;plugin&amp;gt;
    &amp;lt;groupId&amp;gt;org.mybatis.generator&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatis-generator-maven-plugin&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.3.7&amp;lt;/version&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;org.mybatis.generator&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;mybatis-generator-core&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;1.3.7&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;8.0.13&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
     &amp;lt;/dependencies&amp;gt;

     &amp;lt;executions&amp;gt;
        &amp;lt;execution&amp;gt;
          &amp;lt;id&amp;gt;mybatis generator&amp;lt;/id&amp;gt;
          &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;
          &amp;lt;goals&amp;gt;
            &amp;lt;goal&amp;gt;generate&amp;lt;/goal&amp;gt;
          &amp;lt;/goals&amp;gt;
          &amp;lt;configuration&amp;gt;
            &amp;lt;!--允许移动生成的文件--&amp;gt;
            &amp;lt;verbose&amp;gt;true&amp;lt;/verbose&amp;gt;
            &amp;lt;!--允许自动覆盖文件--&amp;gt;
            &amp;lt;overwrite&amp;gt;true&amp;lt;/overwrite&amp;gt;
            &amp;lt;configurationFile&amp;gt;
              src/main/resources/generatorConfig.xml
            &amp;lt;/configurationFile&amp;gt;
       &amp;lt;/configuration&amp;gt;
     &amp;lt;/execution&amp;gt;
     &amp;lt;/executions&amp;gt;


&amp;lt;/plugin&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;（2）根据自己配置的文件路径及名称，创建相应 generatorConfig.xml 文件，位置如下图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190106222723969.png&quot; width=&quot;90%&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）先手动创建一些目录，在配置的时候回有提示，大大降低出错概率，整体目录结构：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019010622282772.png&quot; width=&quot;40%&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;三创建-mysql-数据库创建-2-两个表&quot;&gt;三、创建 MySQL 数据库，创建 2 两个表：&lt;/h3&gt;
&lt;p&gt;之前介绍过多次命令行创建数据库表了，查看 &lt;a href=&quot;https://blog.csdn.net/qq_40147863/article/details/85703718&quot;&gt;MySQL - 最经典的 命令行操作数据库 + 表（增删改查实例）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这次使用 Navicat for MySQL，如果没有安装请参考：&lt;a href=&quot;https://blog.csdn.net/qq_40147863/article/details/84231811&quot;&gt;Navicat for MySQL 最新版安装与破解 + 报错解决办法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）建立连接，创建数据库：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190106123751615.png&quot; width=&quot;90%&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）数据库名，选择编码：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190106123445803.png&quot; width=&quot;60%&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）新建表：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190106123920249.png&quot; width=&quot;90%&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（4）填写表信息：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主键：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190106124216230.png&quot; width=&quot;90%&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其他：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190106124956143.png&quot; width=&quot;90%&quot;/&gt;&lt;/p&gt;
&lt;p&gt;表名为 user_info&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（5）插入一条信息：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190106125210662.png&quot; width=&quot;90%&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（6）细心的你可能发现了没有 upwd 存密码的字段，我们这里放在另外一张表上，新建表 user_pwd：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190106125541329.png&quot; width=&quot;90%&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;四编辑-mybatis-generator.xml-文件&quot;&gt;四、编辑 mybatis-generator.xml 文件：&lt;/h3&gt;
&lt;p&gt;（重要！）&lt;br/&gt;（请详细看注释！自行修改自己的配置信息）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修改目录请自行对应，可放大查看：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190106221833769.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;generatorConfig.xml 文件源代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE generatorConfiguration
        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&amp;gt;

&amp;lt;generatorConfiguration&amp;gt;

    &amp;lt;!-- context 是逆向工程的主要配置信息 --&amp;gt;
    &amp;lt;!-- id：起个名字 --&amp;gt;
    &amp;lt;!-- targetRuntime：设置生成的文件适用于那个 mybatis 版本 --&amp;gt;
    &amp;lt;context id=&quot;default&quot; targetRuntime=&quot;MyBatis3&quot;&amp;gt;


        &amp;lt;!--jdbc的数据库连接--&amp;gt;
        &amp;lt;!--这里是以变量的形式定义，具体的值在 application.properties 文件中--&amp;gt;
        &amp;lt;!--jdbc:mysql://localhost:3306/数据库名?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=UTC--&amp;gt;
        &amp;lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot;
                        connectionURL=&quot;jdbc:mysql://127.0.0.1:3306/miaosha?serverTimezone=UTC&quot;
                        userId=&quot;root&quot;
                        password=&quot;xiaopengwei&quot;&amp;gt;
        &amp;lt;/jdbcConnection&amp;gt;

        &amp;lt;!-- targetPackage：生成的实体类所在的包 --&amp;gt;
        &amp;lt;!-- targetProject：生成的实体类所在的硬盘位置 --&amp;gt;
        &amp;lt;!-- DataObject 类存放位置 --&amp;gt;
        &amp;lt;javaModelGenerator targetPackage=&quot;com.miaoshapro.dataobject&quot;
                            targetProject=&quot;.\src\main\java&quot;&amp;gt;
            &amp;lt;!-- 是否允许子包 --&amp;gt;
            &amp;lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&amp;gt;
            &amp;lt;!-- 是否对modal添加构造函数 --&amp;gt;
            &amp;lt;property name=&quot;constructorBased&quot; value=&quot;true&quot; /&amp;gt;
            &amp;lt;!-- 是否清理从数据库中查询出的字符串左右两边的空白字符 --&amp;gt;
            &amp;lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&amp;gt;
            &amp;lt;!-- 建立modal对象是否不可改变 即生成的modal对象不会有setter方法，只有构造方法 --&amp;gt;
            &amp;lt;property name=&quot;immutable&quot; value=&quot;false&quot; /&amp;gt;
        &amp;lt;/javaModelGenerator&amp;gt;

        &amp;lt;!-- targetPackage 和 targetProject：生成的 mapper 文件的包和位置 --&amp;gt;
        &amp;lt;sqlMapGenerator targetPackage=&quot;mapping&quot;
                         targetProject=&quot;.\src\main\resources&quot;&amp;gt;
            &amp;lt;!-- 针对数据库的一个配置，是否把 schema 作为字包名 --&amp;gt;
            &amp;lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&amp;gt;
        &amp;lt;/sqlMapGenerator&amp;gt;

        &amp;lt;!-- targetPackage 和 targetProject：生成的 interface 文件的包和位置 --&amp;gt;
        &amp;lt;javaClientGenerator type=&quot;XMLMAPPER&quot;
                             targetPackage=&quot;com.miaoshapro.dao&quot; targetProject=&quot;.\src\main\java&quot;&amp;gt;
            &amp;lt;!-- 针对 oracle 数据库的一个配置，是否把 schema 作为字包名 --&amp;gt;
            &amp;lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&amp;gt;
        &amp;lt;/javaClientGenerator&amp;gt;

        &amp;lt;!--生成对应表及类名--&amp;gt;
        &amp;lt;table tableName=&quot;user_info&quot; domainObjectName=&quot;UserDO&quot;&amp;gt;
        &amp;lt;/table&amp;gt;
        &amp;lt;table tableName=&quot;user_pwd&quot; domainObjectName=&quot;UserPwdDO&quot;&amp;gt;
        &amp;lt;/table&amp;gt;
    &amp;lt;/context&amp;gt;
&amp;lt;/generatorConfiguration&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;五执行-mybatis-generator-插件&quot;&gt;五、执行 mybatis-generator 插件&lt;/h3&gt;
&lt;p&gt;（1）打开配置：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190106130248264.png&quot; width=&quot;40%&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）点击 +，选择 Maven：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190106130415391.png&quot; width=&quot;40%&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）输入信息，命令：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190106130625717.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）选中刚才创建的名称，点击执行：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190106130746485.png&quot; width=&quot;50%&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;六运行结果&quot;&gt;六、运行结果：&lt;/h3&gt;
&lt;p&gt;（1）：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190106223652340.png&quot; width=&quot;80%&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190106224055655.png&quot; width=&quot;90%&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190106224123778.png&quot; width=&quot;90%&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190106224138239.png&quot; width=&quot;90%&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 06 Jan 2019 15:45:00 +0000</pubDate>
<dc:creator>肖朋伟</dc:creator>
<og:description>mybatis generator 详细配置及使用，爬坑记录 提示：如果不成功一定是项目路径和 数据库配置出问题，本篇基于 MySQL 8.0.13，调试没有问题。 如果失败，建议使用相同的项目结构，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xpwi/p/10231067.html</dc:identifier>
</item>
<item>
<title>分布式系统理论概述 - 开心的鱼a1</title>
<link>http://www.cnblogs.com/dw-haung/p/10211822.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dw-haung/p/10211822.html</guid>
<description>&lt;p&gt;分布式系统：一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统&lt;/p&gt;
&lt;p&gt;这是分布式系统，在不同的硬件，不同的软件，不同的网络，不同的计算机上，仅仅通过消息来进行通讯与协调&lt;/p&gt;
&lt;p&gt;这是他的特点，更细致的看这些特点又可以有：分布性、对等性、并发性、缺乏全局时钟、&lt;/p&gt;
&lt;p&gt;故障随时会发生。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;分布性&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;既然是分布式系统，最显著的特点肯定就是分布性，从简单来看，如果我们做的是个电商项目，整个项目会分成不同的功能，专业点就不同的微服务，比如用户微服务，产品微服务，订单微服务，这些服务部署在不同的&lt;/span&gt;tomcat&lt;span&gt;中，不同的服务器中，甚至不同的集群中，整个架构都是分布在不同的地方的，在空间上是随意的，而且随时会增加，删除服务器节点，这是第一个特性&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;对等性&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;对等性是分布式设计的一个目标，还是以电商网站为例，来说明下什么是对等性，要完成一个分布式的系统架构，肯定不是简单的把一个大的单一系统拆分成一个个微服务，然后部署在不同的服务器集群就够了，其中拆分完成的每一个微服务都有可能发现问题，而导致整个电商网站出现功能的丢失。&lt;/p&gt;
&lt;p&gt;比如订单服务，为了防止订单服务出现问题，一般情况需要有一个备份，在订单服务出现问题的时候能顶替原来的订单服务。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就要求这两个（或者&lt;/span&gt;2&lt;span&gt;个以上）订单服务完全是对等的，功能完全是一致的，其实这就是一种服务副本的冗余。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;还一种是数据副本的冗余，比如数据库，缓存等，都和上面说的订单服务一样，为了安全考虑需要有完全一样的备份存在，这就是对等性的意思。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;并发性&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;并发性其实对我们来说并不模式，在学习多线程的时候已经或多或少学习过，多线程是并发的基础。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但现在我们要接触的不是多线程的角度，而是更高一层，从多进程，多&lt;/span&gt;JVM&lt;span&gt;的角度，例如在一个分布式系统中的多个节点，可能会并发地操作一些共享资源，如何准确并高效的协调分布式并发操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;后面实战部分的分布式锁其实就是解决这问题的。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;缺乏全局时钟&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;在分布式系统中，节点是可能反正任意位置的，而每个位置，每个节点都有自己的时间系统，因此在分布式系统中，很难定义两个事务纠结谁先谁后，原因就是因为缺乏一个全局的时钟序列进行控制，当然，现在这已经不是什么大问题了，已经有大把的时间服务器给系统调用&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;故障随时会发生&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;任何一个节点都可能出现停电，死机等现象，服务器集群越多，出现故障的可能性就越大，随着集群数目的增加，出现故障甚至都会成为一种常态，怎么样保证在系统出现故障，而系统还是正常的访问者是作为系统架构师应该考虑的。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;分布式系统协调&lt;/span&gt;“方法论”&lt;/strong&gt;&lt;/h4&gt;
&lt;p class=&quot;17&quot;&gt; &lt;strong&gt;分布式系统带来的问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果把分布式系统和平时的交通系统进行对比，哪怕再稳健的交通系统也会有交通事故，分布式系统也有很多需要攻克的问题，比如：通讯异常，网络分区，三态，节点故障等。&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt; &lt;strong&gt;通信异常&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通讯异常其实就是网络异常，网络系统本身是不可靠的，由于分布式系统需要通过网络进行数据传输，网络光纤，路由器等硬件难免出现问题。只要网络出现问题，也就会影响消息的发送与接受过程，因此数据消息的丢失或者延长就会变得非常普遍。&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt; &lt;strong&gt;网络分区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网络分区，其实就是脑裂现象，本来有一个交通警察，来管理整个片区的交通情况，一切井然有序，突然出现了停电，或者出现地震等自然灾难，某些道路接受不到交通警察的指令，可能在这种情况下，会出现一个零时工，片警零时来指挥交通。&lt;/p&gt;
&lt;p&gt;但注意，原来的交通警察其实还在，只是通讯系统中断了，这时候就会出现问题了，在同一个片区的道路上有不同人在指挥，这样必然引擎交通的阻塞混乱。&lt;/p&gt;
&lt;p&gt;这种由于种种问题导致同一个区域（分布式集群）有两个相互冲突的负责人的时候就会出现这种精神分裂的情况，在这里称为脑裂，也叫网络分区。&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;. &lt;strong&gt;三态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;三态是什么？三态其实就是成功，与失败以外的第三种状态，当然，肯定不叫变态，而叫超时态。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在一个&lt;/span&gt;jvm&lt;span&gt;中，应用程序调用一个方法函数后会得到一个明确的相应，要么成功，要么失败，而在分布式系统中，虽然绝大多数情况下能够接受到成功或者失败的相应，但一旦网络出现异常，就非常有可能出现超时，当出现这样的超时现象，网络通讯的发起方，是无法确定请求是否成功处理的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;strong&gt;节点故障&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个其实前面已经说过了，节点故障在分布式系统下是比较常见的问题，指的是组成服务器集群的节点会出现的宕机或&lt;/span&gt;“僵死”的现象，这种现象经常会发生。&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;CAP&lt;span&gt;理论&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面花费了很大的篇幅来了解分布式的特点以及会碰到很多会让人头疼的问题，这些问题肯定会有一定的理论思想来解决问题的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来花点时间来谈谈这些理论，其中&lt;/span&gt;CAP&lt;span&gt;和&lt;/span&gt;&lt;span&gt;BASE&lt;/span&gt;&lt;span&gt;理论是基础，也是面试的时候经常会问到的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先看下&lt;/span&gt;CAP&lt;span&gt;，&lt;/span&gt;&lt;span&gt;CAP&lt;/span&gt;&lt;span&gt;其实就是一致性，可用性，分区容错性这三个词的缩写&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;一致性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一致性是事务&lt;/span&gt;ACID&lt;span&gt;的一个特性【&lt;/span&gt;&lt;span&gt;原子性（&lt;/span&gt;Atomicity&lt;span&gt;）、一致性（&lt;/span&gt;&lt;span&gt;Consistency&lt;/span&gt;&lt;span&gt;）、隔离性（&lt;/span&gt;&lt;span&gt;Isolation&lt;/span&gt;&lt;span&gt;）、持久性（&lt;/span&gt;&lt;span&gt;Durability&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span&gt;】，学习数据库优化的时候&lt;/span&gt;deer&lt;span&gt;老师讲过。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里讲的一致性其实大同小异，只是现在考虑的是分布式环境中，还是不单一的数据库。&lt;/p&gt;
&lt;p&gt; 在分布式系统中，一致性是数据在多个副本之间是否能够保证一致的特性，这里说的一致性和前面说的对等性其实差不多。如果能够在分布式系统中针对某一个数据项的变更成功执行后，所有用户都可以马上读取到最新的值，那么这样的系统就被认为具有【强一致性】。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;可用性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可用性指系统提供服务必须一直处于可用状态，对于用户的操作请求总是能够在有限的时间内访问结果。&lt;/p&gt;
&lt;p&gt;这里的重点是【有限的时间】和【返回结果】&lt;/p&gt;
&lt;p&gt;为了做到有限的时间需要用到缓存，需要用到负载，这个时候服务器增加的节点是为性能考虑；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了返回结果，需要考虑服务器主备，当主节点出现问题的时候需要备份的节点能最快的顶替上来，千万不能出现&lt;/span&gt;OutOfMemory&lt;span&gt;或者其他&lt;/span&gt;&lt;span&gt;500&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;404&lt;/span&gt;&lt;span&gt;错误，否则这样的系统我们会认为是不可用的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;strong&gt;分区容错性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分布式系统在遇到任何网络分区故障的时候，仍然需要能够对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。&lt;/p&gt;
&lt;p&gt;不能出现脑裂的情况&lt;/p&gt;
&lt;p&gt;  具体描述&lt;/p&gt;
&lt;p&gt;&lt;span&gt;来看下&lt;/span&gt;CAP&lt;span&gt;理论&lt;/span&gt;具体描述：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个分布式系统不可能同时满足一致性、可用性和分区容错性这三个基本需求，最多只能同时满足其中的两项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1403971/201901/1403971-20190102223747100-1984263996.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;TIPS&lt;span&gt;：不可能把所有应用全部放到一个节点上，因此架构师的精力往往就花在怎么样根据业务场景在&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;直接寻求平衡；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;BASE&lt;span&gt;理论&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据前面的&lt;/span&gt;CAP&lt;span&gt;理论，架构师应该从一致性和可用性之间找平衡，系统短时间完全不可用肯定是不允许的，那么根据&lt;/span&gt;&lt;span&gt;CAP&lt;/span&gt;&lt;span&gt;理论，在分布式环境下必然也无法做到强一致性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; BASE&lt;span&gt;理论：即使无法做到强一致性，但分布式系统可以根据自己的业务特点，采用适当的方式来使系统达到最终的一致性；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;Basically Avaliable  &lt;span&gt;基本可用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当分布式系统出现不可预见的故障时，允许损失部分可用性，保障系统的&lt;/span&gt;“基本可用”；体现在“时间上的损失”和“功能上的损失”；&lt;/p&gt;
&lt;p&gt;e.g&lt;span&gt;：部分用户双十一高峰期淘宝页面卡顿或降级处理；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;Soft state &lt;span&gt;软状态&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实就是前面讲到的三态&lt;/span&gt;,&lt;span&gt;既允许系统中的数据存在中间状态，既系统的不同节点的数据副本之间的数据同步过程存在延时，并认为这种延时不会影响系统可用性；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;e.g&lt;span&gt;：&lt;/span&gt;&lt;span&gt;12306&lt;/span&gt;&lt;span&gt;网站卖火车票，请求会进入排队队列；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt; &lt;strong&gt;Eventually consistent &lt;span&gt;最终一致性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有的数据在经过一段时间的数据同步后，最终能够达到一个一致的状态；&lt;/p&gt;
&lt;p&gt;e.g&lt;span&gt;：理财产品首页充值总金额短时不一致；&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;其实可能发现不管是&lt;/span&gt;CAP&lt;span&gt;理论，还是&lt;/span&gt;&lt;span&gt;BASE&lt;/span&gt;&lt;span&gt;理论，他们都是理论，这些理论是需要算法来实现的，今天讲的&lt;/span&gt;&lt;span&gt;2PC&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;3PC&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Paxos&lt;/span&gt;&lt;span&gt;算法，&lt;/span&gt;&lt;span&gt;ZAB&lt;/span&gt;&lt;span&gt;算法就是干这事情。&lt;/span&gt;&lt;/p&gt;



&lt;h3&gt;所以解决的问题全部都是在分布式环境下，怎么让系统尽可能的高可用，而且数据能最终能达到一致。&lt;/h3&gt;
&lt;h3&gt;1.1.1. &lt;strong&gt;&lt;span&gt;两阶段提交&lt;/span&gt; two-phase commit (2PC)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;首先来看下&lt;/span&gt;2PC&lt;span&gt;，翻译过来叫两阶段提交算法，它本身是一致强一致性算法，所以很适合用作数据库的分布式事务。其实数据库的经常用到的&lt;/span&gt;&lt;span&gt;TCC&lt;/span&gt;&lt;span&gt;本身就是一种&lt;/span&gt;&lt;span&gt;2PC.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1403971/201901/1403971-20190106230341862-2044102307.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;MySQL   &lt;span&gt;innodb&lt;/span&gt;&lt;span&gt;存储引擎，对数据库的修改都会写到&lt;/span&gt;&lt;span&gt;undo&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;redo&lt;/span&gt;&lt;span&gt;中，不只是数据库，很多需要事务支持的都会用到这个思路。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;对一条数据的修改操作首先写&lt;/span&gt;undo&lt;span&gt;日志，记录的数据原来的样子，接下来执行事务修改操作，把数据写到&lt;/span&gt;&lt;span&gt;redo&lt;/span&gt;&lt;span&gt;日志里面，万一捅娄子，事务失败了，可从&lt;/span&gt;&lt;span&gt;undo&lt;/span&gt;&lt;span&gt;里面回复数据。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;不只是数据库，在很多企业里面，比如华为等提交数据库修改都回要求这样，你要新增一个字段，首先要把修改数据库的字段&lt;/span&gt;SQL&lt;span&gt;提交给&lt;/span&gt;&lt;span&gt;DBA&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;redo&lt;/span&gt;&lt;span&gt;），这不够，还需要把删除你提交字段，把数据还原成你修改之前的语句也一并提交者叫（&lt;/span&gt;&lt;span&gt;undo&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;数据库通过&lt;/span&gt;undo&lt;span&gt;与&lt;/span&gt;&lt;span&gt;redo&lt;/span&gt;&lt;span&gt;能保证数据的强一致性，要解决分布式事务的前提就是当个节点是支持事务的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这在个前提下，&lt;/span&gt;2pc&lt;span&gt;借鉴这失效，首先把整个分布式事务分两节点，首先第一阶段叫准备节点，事务的请求都发送给一个个的资源，这里的资源可以是数据库，也可以是其他支持事务的框架，他们会分别执行自己的事务，写日志到&lt;/span&gt;&lt;span&gt;undo&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;redo&lt;/span&gt;&lt;span&gt;，但是不提交事务。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当事务管理器收到了所以资源的反馈，事务都执行没报错后，事务管理器再发送&lt;/span&gt;commit&lt;span&gt;指令让资源把事务提交，一旦发现任何一个资源在准备阶段没有执行成功，事务管理器会发送&lt;/span&gt;&lt;span&gt;rollback&lt;/span&gt;&lt;span&gt;，让所有的资源都回滚。这就是&lt;/span&gt;&lt;span&gt;2pc&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;优点：原理简单，实现方便&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;缺点：&lt;span&gt;同步阻塞，单点问题，数据不一致，容错性不好&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;同步阻塞&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在二阶段提交的过程中，所有的节点都在等待其他节点的响应，无法进行其他操作。这种同步阻塞极大的限制了分布式系统的性能。&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt; &lt;strong&gt;&lt;span&gt;单点问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;协调者在整个二阶段提交过程中很重要，如果协调者在提交阶段出现问题，那么整个流程将无法运转。更重要的是，其他参与者将会处于一直锁定事务资源的状态中，而无法继续完成事务操作。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;strong&gt;&lt;span&gt;数据不一致&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设当协调者向所有的参与者发送&lt;/span&gt;commit&lt;span&gt;请求之后，发生了局部网络异常，或者是协调者在尚未发送完所有&lt;/span&gt; &lt;span&gt;commit&lt;/span&gt;&lt;span&gt;请求之前自身发生了崩溃，导致最终只有部分参与者收到了&lt;/span&gt;&lt;span&gt;commit&lt;/span&gt;&lt;span&gt;请求。这将导致严重的数据不一致问题。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;.&lt;strong&gt;&lt;span&gt;容错性不好&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二阶段提交协议没有设计较为完善的容错机制，任意一个节点是失败都会导致整个事务的失败。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;三阶段提交&lt;/span&gt; three-phase commit (3PC)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;由于二阶段提交存在着诸如同步阻塞、单点问题，所以，研究者们在二阶段提交的基础上做了改进，提出了三阶段提交。&lt;/p&gt;


&lt;h4&gt;&lt;strong&gt;&lt;span&gt;第一阶段&lt;/span&gt;canCommit&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;确认所有的资源是否都是健康、在线的，以约女孩举例，你会打个电话问下她是不是在家，而且可以约个会。&lt;/p&gt;
&lt;p&gt;如果女孩有空，你在去约她。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就因为有了这一阶段，大大的减少了&lt;/span&gt;2&lt;span&gt;段提交的阻塞时间，在&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;段提交，如果有&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;个数据库&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;恰恰第三个数据库出现问题，其他两个都会执行耗费时间的事务操作，到第三个却发现连接不上。&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;段优化了这种情况&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt; &lt;strong&gt;第二阶段&lt;/strong&gt;PreCommit&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;如果所有服务都&lt;/span&gt;ok&lt;span&gt;，可以接收事务请求，这一阶段就可以执行事务了，这时候也是每个资源都回写&lt;/span&gt;&lt;span&gt;redo&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;undo&lt;/span&gt;&lt;span&gt;日志，事务执行成功，返回&lt;/span&gt;&lt;span&gt;ack&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;否则返回&lt;/span&gt;&lt;span&gt;no&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt; &lt;strong&gt;&lt;span&gt;第三阶段&lt;/span&gt;doCommit&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;这阶段和前面说的&lt;/span&gt;2&lt;span&gt;阶段提交大同小异，这个时候协调者发现所有提交者事务提交者事务都正常执行后，给所有资源发送&lt;/span&gt;&lt;span&gt;commit&lt;/span&gt;&lt;span&gt;指令。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;和二阶段提交有所不同的是，他要求所有事务在协调者出现问题，没给资源发送&lt;/span&gt;commit&lt;span&gt;指令的时候，三阶段提交算法要求资源在一段时间超时后回默认提交做&lt;/span&gt;&lt;span&gt;commit&lt;/span&gt;&lt;span&gt;操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这样的要求就减少了前面说的单点故障，万一事务管理器出现问题，事务也回提交。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但回顾整个过程，不管是&lt;/span&gt;2pc,&lt;span&gt;还是&lt;/span&gt;&lt;span&gt;3pc&lt;/span&gt;&lt;span&gt;，同步阻塞，单点故障，容错机制不完善这些问题都没本质上得到解决，尤其是前面说得数据一致性问题，反而更糟糕了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;所有数据库的分布式事务一般都是二阶段提交，而者三阶段的思想更多的被借鉴扩散成其他的算法。&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;&lt;strong&gt;Paxos&lt;span&gt;算法&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1403971/201901/1403971-20190106231708878-666885261.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;身这算法的提出者&lt;span&gt;莱斯利&lt;/span&gt;·&lt;span&gt;兰伯特&lt;/span&gt;在前面几篇论文中都不是以严谨的数学公式进行的。&lt;/p&gt;
&lt;p&gt;paxos&lt;span&gt;算法也分成两阶段。首先这个图有&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;个角色，提议者与接收者&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;第一阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;提议者对接收者吼了一嗓子，我有个事情要告诉你们，当然这里接受者不只一个，它也是个分布式集群&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相当于星期一开早会，可耻的领导吼了句：&lt;/span&gt;“要开会了啊，我要公布一个编号为&lt;span&gt;001&lt;/span&gt;&lt;span&gt;的提案，收到请回复”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个时候领导就会等着，等员工回复&lt;/span&gt;1&lt;span&gt;“好的”，如果回复的数目超过一半，就会进行下一步。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果由于某些原因（接收者死机，网络问题，本身业务问题），导通过的协议未超过一半，&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个时候的领导又会再吼一嗓子，当然气势没那凶残：&lt;/span&gt;“好了，怕了你们了，我要公布一个新的编号未&lt;span&gt;002&lt;/span&gt;&lt;span&gt;的提案，收到请回复&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;第二阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来到第二阶段，领导苦口婆心的把你们叫来开会了，今天编号&lt;/span&gt;002&lt;span&gt;提案的内容是：“由于项目紧张，今天加班到&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;点，同意的请举手”这个时候如果绝大多少的接收者都同意，那么好，议案就这么决定了，如果员工反对或者直接夺门而去，那么领导又只能从第一个阶段开始：“大哥，大姐们，我有个新的提案&lt;/span&gt;&lt;span&gt;003&lt;/span&gt;&lt;span&gt;，快回会议室吧。。”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面那个故事描绘的是个苦逼的领导和凶神恶煞的员工之间的斗争，通过这个故事你们起码要懂&lt;/span&gt;paxos&lt;span&gt;协议的流程是什么样的（&lt;/span&gt;&lt;span&gt;paxos&lt;/span&gt;&lt;span&gt;的核心就是少数服从多数）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上面的故事有两个问题：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;苦逼的领导（单点问题）&lt;/strong&gt;：有这一帮凶残的下属，这领导要不可能被气死，要不也会辞职，这是单点问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;凶神恶煞的下属（一致性问题）&lt;/strong&gt;：如果员工一种都拒绝，故意和领导抬杆，最终要产生一个一致性的解决方案是不可能的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;所以&lt;/span&gt;paxos&lt;span&gt;协议肯定不会只有一个提议者，作为下属的员工也不会那么强势&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;协议要求：如果接收者没有收到过提案编号，他必须接受第一个提案编号&lt;/p&gt;
&lt;p&gt;                  &lt;span&gt;如果接收者没有收到过其他协议，他必须接受第一个协议。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;举一个例子：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有&lt;/span&gt;2&lt;span&gt;个&lt;/span&gt;Proposer(&lt;span&gt;老板，老板之间是竞争关系&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;个&lt;/span&gt;&lt;span&gt;Acceptor(&lt;/span&gt;&lt;span&gt;政府官员&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;. &lt;strong&gt;阶段一&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.&lt;span&gt;现在需要对一项议题来进行&lt;/span&gt;&lt;span&gt;paxos&lt;/span&gt;&lt;span&gt;过程，议题是“&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;项目我要中标！”，这里的“我”指每个带着他的秘书&lt;/span&gt;&lt;span&gt;Proposer&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;Client&lt;/span&gt;&lt;span&gt;老板。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2.Proposer&lt;span&gt;当然听老板的话了，赶紧带着议题和现金去找&lt;/span&gt;&lt;span&gt;Acceptor&lt;/span&gt;&lt;span&gt;政府官员。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;span&gt;作为政府官员，当然想谁给的钱多就把项目给谁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4.Proposer-1&lt;span&gt;小姐带着现金同时找到了&lt;/span&gt;&lt;span&gt;Acceptor-1~Acceptor-3&lt;/span&gt;&lt;span&gt;官员，&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;号官员分别收取了&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;比特币，找到第&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;号官员时，没想到遭到了&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;号官员的鄙视，&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;号官员告诉她，&lt;/span&gt;&lt;span&gt;Proposer-2&lt;/span&gt;&lt;span&gt;给了&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;比特币。不过没关系，&lt;/span&gt;&lt;span&gt;Proposer-1&lt;/span&gt;&lt;span&gt;已经得到了&lt;/span&gt;&lt;span&gt;1,2&lt;/span&gt;&lt;span&gt;两个官员的认可，形成了多数派&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;如果没有形成多数派，&lt;/span&gt;&lt;span&gt;Proposer-1&lt;/span&gt;&lt;span&gt;会去银行提款在来找官员们给每人&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;比特币，这个过程一直重复每次&lt;/span&gt;&lt;span&gt;+10&lt;/span&gt;&lt;span&gt;比特币，直到多数派的形成&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;，满意的找老板复命去了，但是此时&lt;/span&gt;&lt;span&gt;Proposer-2&lt;/span&gt;&lt;span&gt;保镖找到了&lt;/span&gt;&lt;span&gt;1,2&lt;/span&gt;&lt;span&gt;号官员，分别给了他们&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;比特币，&lt;/span&gt;&lt;span&gt;1,2&lt;/span&gt;&lt;span&gt;号官员的态度立刻转变，都说&lt;/span&gt;&lt;span&gt;Proposer-2&lt;/span&gt;&lt;span&gt;的老板懂事，这下子&lt;/span&gt;&lt;span&gt;Proposer-2&lt;/span&gt;&lt;span&gt;放心了，搞定了&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;个官员，找老板复命去了，当然这个过程是第一阶段提交，只是官员们初步接受贿赂而已。故事中的比特币是编号，议题是&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个过程保证了在某一时刻，某一个&lt;/span&gt;proposer&lt;span&gt;的议题会形成一个多数派进行初步支持（初步达成共识）&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;15&quot;&gt;1.1.1.3.2. &lt;strong&gt;阶段二&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;5.&lt;span&gt;　现在进入第二阶段提交，现在&lt;/span&gt;&lt;span&gt;proposer-1&lt;/span&gt;&lt;span&gt;小姐使用分身术&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;多线程并发&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;分了&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;个自己分别去找&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;位官员，最先找到了&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;号官员签合同，遭到了&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;号官员的鄙视，&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;号官员告诉他&lt;/span&gt;&lt;span&gt;proposer-2&lt;/span&gt;&lt;span&gt;先生给了他&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;比特币，因为上一条规则的性质&lt;/span&gt;&lt;span&gt;proposer-1&lt;/span&gt;&lt;span&gt;小姐知道&lt;/span&gt;&lt;span&gt;proposer-2&lt;/span&gt;&lt;span&gt;第一阶段在她之后又形成了多数派&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;至少有&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;位官员的赃款被更新了&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;span&gt;此时她赶紧去提款准备重新贿赂这&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;个官员&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;重新进入第一阶段&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;，每人&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;比特币。刚给&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;号官员&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;比特币，&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;号官员很高兴初步接受了议题，还没来得及见到&lt;/span&gt;&lt;span&gt;2,3&lt;/span&gt;&lt;span&gt;号官员的时候&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这时&lt;/span&gt;proposer-2&lt;span&gt;先生也使用分身术分别找&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;位官员&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;注意这里是&lt;/span&gt;&lt;span&gt;proposer-2&lt;/span&gt;&lt;span&gt;的第二阶段&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;，被第&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;号官员拒绝了告诉他收到了&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;比特币，第&lt;/span&gt;&lt;span&gt;2,3&lt;/span&gt;&lt;span&gt;号官员顺利签了合同，这时&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;号官员记录&lt;/span&gt;&lt;span&gt;client-2&lt;/span&gt;&lt;span&gt;老板用了&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;比特币中标，因为形成了多数派，所以最终接受了&lt;/span&gt;&lt;span&gt;Client2&lt;/span&gt;&lt;span&gt;老板中标这个议题，对于&lt;/span&gt;&lt;span&gt;proposer-2&lt;/span&gt;&lt;span&gt;先生已经出色的完成了工作；&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这时&lt;/span&gt;proposer-1&lt;span&gt;小姐找到了&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;号官员，官员告诉她合同已经签了，将合同给她看，&lt;/span&gt;&lt;span&gt;proposer-1&lt;/span&gt;&lt;span&gt;小姐是一个没有什么职业操守的聪明人，觉得跟&lt;/span&gt;&lt;span&gt;Client1&lt;/span&gt;&lt;span&gt;老板混没什么前途，所以将自己的议题修改为“&lt;/span&gt;&lt;span&gt;Client2&lt;/span&gt;&lt;span&gt;老板中标”，并且给了&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;号官员&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;比特币，这样形成了一个多数派。顺利的再次进入第二阶段。由于此时没有人竞争了，顺利的找&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;位官员签合同，&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;位官员看到议题与上次一次的合同是一致的，所以最终接受了，形成了多数派，&lt;/span&gt;&lt;span&gt;proposer-1&lt;/span&gt;&lt;span&gt;小姐跳槽到&lt;/span&gt;&lt;span&gt;Client2&lt;/span&gt;&lt;span&gt;老板的公司去了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;总结：Paxos&lt;span&gt;过程结束了，这样，一致性得到了保证，算法运行到最后所有的&lt;/span&gt;&lt;span&gt;proposer&lt;/span&gt;&lt;span&gt;都投&lt;/span&gt;&lt;span&gt;“client2&lt;/span&gt;&lt;span&gt;中标&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;所有的&lt;/span&gt;&lt;span&gt;acceptor&lt;/span&gt;&lt;span&gt;都接受这个议题，也就是说在最初的第二阶段，议题是先入为主的，谁先占了先机，后面的&lt;/span&gt;&lt;span&gt;proposer&lt;/span&gt;&lt;span&gt;在第一阶段就会学习到这个议题而修改自己本身的议题，因为这样没职业操守，才能让一致性得到保证，这就是&lt;/span&gt;&lt;span&gt;paxos&lt;/span&gt;&lt;span&gt;算法的一个过程。原来&lt;/span&gt;&lt;span&gt;paxos&lt;/span&gt;&lt;span&gt;算法里的角色都是这样的不靠谱，不过没关系，结果靠谱就可以了。该算法就是为了追求结果的一致性。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;集群一致性协议&lt;/span&gt;ZAB&lt;span&gt;解析&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;懂了&lt;/span&gt;paxos&lt;span&gt;算法，其实&lt;/span&gt;&lt;span&gt;zab&lt;/span&gt;&lt;span&gt;就很好理解了。很多论文和资料都证明&lt;/span&gt;&lt;span&gt;zab&lt;/span&gt;&lt;span&gt;其实就是&lt;/span&gt;&lt;span&gt;paxos&lt;/span&gt;&lt;span&gt;的一种简化实现，但&lt;/span&gt;&lt;span&gt;Apache&lt;/span&gt; &lt;span&gt;自己的立场说&lt;/span&gt;&lt;span&gt;zab&lt;/span&gt;&lt;span&gt;不是&lt;/span&gt;&lt;span&gt;paxos&lt;/span&gt;&lt;span&gt;算法的实现，这个不需要去计较。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 06 Jan 2019 15:24:00 +0000</pubDate>
<dc:creator>开心的鱼a1</dc:creator>
<og:description>分布式系统是什么 分布式系统：一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统 这是分布式系统，在不同的硬件，不同的软件，不同的网络，不同的计算机上，仅仅通过消</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dw-haung/p/10211822.html</dc:identifier>
</item>
<item>
<title>别得意，你只是假装收藏了而已 - 云是风的梦</title>
<link>http://www.cnblogs.com/lijinfeng042/p/10230891.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lijinfeng042/p/10230891.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/66cf5bc0ly1fyx6d939faj20u00k0mxe.jpg&quot;/&gt;&lt;br/&gt;今天分享我在看罗振宇的《2018 时间的朋友》演讲视频记下的一些思考。&lt;/p&gt;
&lt;p&gt;跨年演讲中有过这样的一个来自印象笔记的片段，列举了几组对比来说明：&lt;br/&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/66cf5bc0ly1fyx6b12kvaj20hs02kaa1.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;『你在朋友圈里又佛又丧，你在收藏夹里偷偷地积极向上。』&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;扎心了，这不就是说我吗？读了很多书和文章，摘录了很多精彩片段，放进了收藏夹，也许还做了厚厚的笔记，回想起来，是否脑袋空空的，什么也想不起来吧？&lt;/p&gt;
&lt;h2 id=&quot;收藏是害怕错过&quot;&gt;01 收藏是害怕错过&lt;/h2&gt;
&lt;p&gt;和菜头曾写过一篇文章《我们都是花栗鼠》，下面摘选一段很有意思的表述。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;没有亲身实践过的知识不是知识，那只是一些文字，最多算上有含义的文字。没有经过辩证思考和行动验证，知识和经验都是别人的，放在硬盘、阅读器里，不等于你拥有了它。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;别人的思考结果无论看起来多么深刻，多么智慧，如果没有花时间去想一下，偶然在生活中验证一下，它只是你的阅读体验而已。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/66cf5bc0ly1fyx6hkd41rj20g509mgm4.jpg&quot;/&gt;&lt;br/&gt;花栗鼠收集过冬的食物，而我们则在收藏各种所谓的金句，前者在焦虑冬天饿死，后者则是害怕错过了。&lt;/p&gt;
&lt;h2 id=&quot;有必要收藏吗&quot;&gt;02 有必要收藏吗&lt;/h2&gt;
&lt;p&gt;如果仅仅是分门别类地收藏，想象着未来哪一天会用上，那我告诉你，别傻了，基本没有这个所谓的机会了，你更多的可能是把它们遗忘在收藏夹里。或者只在那App年终分享的时候从那串数字里面找到一点骄傲。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果仅仅是这样，也就不需要收藏了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;收藏这个行为，如果能提供一个打开率数据，可以想象，必然是大部分都是 0——不出意外的话，大部分人都是这样。&lt;/p&gt;
&lt;p&gt;我们先看一个例子，就说自媒体人粥左罗吧，他在他写的书和课程里说过，如何打造写作素材库：粥左罗的微信收藏夹超过 60 个标签，平时还会使用锤子便签记下灵感关键词。&lt;/p&gt;
&lt;p&gt;可能很多人都会忽略了他后面补充的一段话，『有时间的时候还会进行梳理』，定期整理，归纳，梳理收藏夹内容。&lt;/p&gt;
&lt;p&gt;这其实包含了收藏使用的两个方面：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;定期梳理，做减法。&lt;/li&gt;
&lt;li&gt;经常应用。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;收藏的时候，添加不是目的，吸收才是目的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/66cf5bc0ly1fxrq1joecwj20qo0hsjzk.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;收藏的底层逻辑&quot;&gt;03 收藏的底层逻辑&lt;/h2&gt;
&lt;p&gt;首先，我们来明确一下，什么是『收藏』。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;维基百科给出的定义『收藏是一种对于物品的搜集、储存、分类与维护的癖好。』是的，癖好，强调个性化行为。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;产品经理马洪洲写过一篇文章说：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;收藏的价值在于信息的快速重现和个性化整理，提高产品的使用效率，提高信息的利用率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如天猫 APP，收藏商品可以快速定位，提高转化率。我们熟悉的浏览器收藏夹就是为了快速定位网站。而微信，则提供了收藏的搜索和整理。&lt;/p&gt;
&lt;h2 id=&quot;需求对收藏做些什么&quot;&gt;04 需求对收藏做些什么？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;只有自己感兴趣的、关注的、需要的，你才会去收藏。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;怎么发挥收藏的价值呢？你要去做升维管理，转换为自己的知识。&lt;/p&gt;
&lt;p&gt;粥左罗说，没有输出的输入，就是无效的输入。同样的，收藏也是如此。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;你看书、听课、看文章，把好的观点、金句、方法摘出来在电脑里敲一遍，那不算真正的输出，那叫“练习打字”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你自己的思考出来的，才真的对你有用，否则你就是过过脑子，浅层记忆，明天就忘记了。&lt;/p&gt;
&lt;p&gt;只有给收藏内容加上行动，囤积起来的内容才会有价值。&lt;/p&gt;
&lt;p&gt;该精读的精读，提炼出内容，输出，然后删除。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;该打开编译器的就老实实现一下，不要停留在你知道了的表面印象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一切不被你利用的知识，都不属于你。&lt;/p&gt;
&lt;p&gt;你的收藏夹是否也需要整理一下吗？行动起来吧，不要被自己感动，收藏也仅仅是假装很重要。&lt;/p&gt;
&lt;p&gt;本文同步发表在公众号文章 &lt;a href=&quot;https://mp.weixin.qq.com/s/-Cx2plLsi-nmvyCultikPQ&quot;&gt;别得意，你只是假装收藏了而已&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;博客是我学习过程的输出，希望你有所收获。&lt;/li&gt;
&lt;li&gt;有想法请留言，共同探讨学习。&lt;/li&gt;
&lt;li&gt;由于博主能力有限，文中可能存在描述不正确，欢迎指正、补充！&lt;/li&gt;
&lt;li&gt;你也可以关注我的公众号：&lt;strong&gt;ProgramLife042&lt;/strong&gt;，名称：&lt;strong&gt;风之程序人生&lt;/strong&gt;，方便接收最新内容。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/mw690/66cf5bc0ly1fv6etki980j20760763yz.jpg&quot; alt=&quot;公众号&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 06 Jan 2019 15:04:00 +0000</pubDate>
<dc:creator>云是风的梦</dc:creator>
<og:description>今天分享我在看罗振宇的《2018 时间的朋友》演讲视频记下的一些思考。 跨年演讲中有过这样的一个来自印象笔记的片段，列举了几组对比来说明： 『你在朋友圈里又佛又丧，你在收藏夹里偷偷地积极向上。』 扎心</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lijinfeng042/p/10230891.html</dc:identifier>
</item>
<item>
<title>让Mongo在Spring中跑起来 - OKevin</title>
<link>http://www.cnblogs.com/yulinfeng/p/10230832.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yulinfeng/p/10230832.html</guid>
<description>&lt;p&gt;&lt;strong&gt;本文标题为《让Mongo在Spring中跑起来》，旨在Spring中如何成功连接MongoDB并对其进行增删改查等操作，由于笔者也是刚接触，对其中的一些原由也不甚了解，若有错误之处，敬请指正。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　习惯了MySQL在Spring中整合时填写各种各样的连接参数，本来只想做一件简单的数据库插入查询而已，翻遍整个互联网通篇都是复制粘贴抄袭的配置，连接数的多少，超时时间的多少等等。&lt;/p&gt;
&lt;p&gt;　　SprintBoot的出现，秉持**约定大于配置**的目标，可以使你免去许多配置的烦脑，“约定”即是大多数人都这么做，你这么做估计也没问题，反正就是能跑起来，你要用高级特性也可以也支持自定义配置。所以本文采用SpringBoot力求达到零XML配置。&lt;/p&gt;
&lt;p&gt;　　不得不说，Spring如今已经成为Java EE事实上的标准，可以说Spring出品必属精品，其中与数据库打交道的部分，Spring也替我们做好了封装，本文操作MongoDB的API不需要自己再在mongo-driver的基础上再封装一层，而是直接使用Spring提供的spring-data-mongo模块，这个模块加上SpringBoot的结合，淋漓尽致地展现了什么叫做“约定大于配置”。&lt;/p&gt;
&lt;p&gt;　　为了便于注入Bean，我们在maven中引入了以下两个包：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-data-mongodb&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　SprintBoot的版本号为2.0.2.RELEASE。&lt;/p&gt;
&lt;p&gt;　　为了验证是否能对MongoDB进行操作，我们还需要再引入Spring的单元测试包：&lt;/p&gt;
&lt;div readability=&quot;11.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　起初我想着，这应该需要配置MongoDB的地址、用户名、密码什么的吧，所以我起初写了一个配置类，企图使用@Configuration的方式来配置MongoDB连接，后来发现，引入了spring-data-mongo在我们启动SpringBoot时，已经为我们创建好了一个默认的MongoDB连接，不需要我们再去重复的配置（当然如果需要更高级的自定义配置也是可以自己配置的），只需要按照格式即可在启动完成SpringBoot时，自动创建MongoDB连接。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;　　在&lt;strong&gt;application.properties&lt;/strong&gt;中配置以下：&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
spring.data.mongodb.uri=mongodb://okevin:123456@localhost:27017/recommended
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　即可通过SpringBoot自动为我们创建MongoDB连接，在代码中直接引用&lt;strong&gt;MongoTemplate&lt;/strong&gt;类。&lt;/p&gt;
&lt;p&gt;　　我们先通过MongoDB可视化管理Robo 3T连入对应的数据库，并在数据库中新创建一个MongoDB集合“user”，在代码中需要我们创建一个与之对应的Java实体类User：&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.mongo.domain;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; lombok.Data;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; lombok.ToString;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.annotation.Id;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.mongodb.core.mapping.Document;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.mongodb.core.mapping.Field;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; OKevin
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt; * @description: MongoDB实体映射类
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt; * @date 2019-01-06 12:10
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;@Data
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;@ToString
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;以上两个注解使用的是lombok，可减少代码中getter/setter代码&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; @Document(collection = &quot;user&quot;&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; User &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 5094995541812833015L&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;     * 主键使用此注解
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    @Id
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String id;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;     * 字段使用此注解
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    @Field
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　User实体类对应MongoDB数据库中的collection集合。&lt;/p&gt;
&lt;p&gt;　　接下来就是操作MongoDB数据库中user集合的一些增删改查具体逻辑，很简单只需要在类中注入&lt;strong&gt;MongoTemplate&lt;/strong&gt;类即可。&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.mongo.dao;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.mongo.domain.User;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.mongodb.core.MongoTemplate;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.mongodb.core.query.Criteria;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.mongodb.core.query.Query;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.mongodb.core.query.Update;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; OKevin
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt; * @description: 数据层操作类
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt; * @date 2019-01-06 19:52
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserDao {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; MongoTemplate mongoTemplate;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;     * 保存用户
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; user 返回保存的用户
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; saveUser(User user) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        mongoTemplate.save(user);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;     * 根据名字查询用户
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; name 名字
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 用户
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;User&amp;gt;&lt;span&gt; findUserByName(String name) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         Query query = &lt;span&gt;new&lt;/span&gt; Query(Criteria.where(&quot;name&quot;&lt;span&gt;).is(name));
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         List&amp;lt;User&amp;gt; users = mongoTemplate.find(query, User.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; users;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;     * 更新用户
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; user 待更新的用户
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; updateUser(User user) {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         Query query = &lt;span&gt;new&lt;/span&gt; Query(Criteria.where(&quot;id&quot;&lt;span&gt;).is(user.getId()));
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         Update update = &lt;span&gt;new&lt;/span&gt; Update().set(&quot;name&quot;&lt;span&gt;, user.getName());
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         mongoTemplate.updateFirst(query, update, User.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt; &lt;span&gt;     * 根据MongoDB的_id删除用户
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; Id _id
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deleteUserById(String Id) {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;         Query query = &lt;span&gt;new&lt;/span&gt; Query(Criteria.where(&quot;id&quot;&lt;span&gt;).is(Id));
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;         mongoTemplate.remove(query, User.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　最后是单元测试的代码：&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.mongo;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.mongo.dao.UserDao;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.mongo.domain.User;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runner.RunWith;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.test.context.SpringBootTest;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.ComponentScan;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.ContextConfiguration;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.junit4.SpringRunner;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; @RunWith(SpringRunner.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;@SpringBootTest
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SpringDataMongoDemoApplicationTests {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserDao userDao;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; contextLoads() {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testSaveUser() {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         User user = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         user.setName(&quot;test&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        userDao.saveUser(user);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testFindUserByName() {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         String name = &quot;test&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         List&amp;lt;User&amp;gt; users =&lt;span&gt; userDao.findUserByName(name);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        System.out.println(users);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testUpdateUser() {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         String id = &quot;5c31f93f91ffb269a774b860&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         User user = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        user.setId(id);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         user.setName(&quot;test2&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        userDao.updateUser(user);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testDeleteUserById() {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         String id = &quot;5c31f93f91ffb269a774b860&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;        userDao.deleteUserById(id);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　执行单元测试运行正常，回到Robo 3T也发现执行成功。&lt;/p&gt;
&lt;p&gt;　　由此可见对于基本的一些操作，大可不必在Spring中配置一些MongoDB的连接，只需要一句配置提供地址、用户名、密码即可，软件开发在学习特别是在初学的过程，让一切先跑起来再说。&lt;/p&gt;
&lt;p&gt;　　本文涉及到的完整代码已上传至GitHub：&lt;a href=&quot;https://github.com/yu-linfeng/BlogRepositories/tree/master/repositories/%E8%AE%A9Mongo%E5%9C%A8Spring%E4%B8%AD%E8%B7%91%E8%B5%B7%E6%9D%A5/spring-data-mongo-demo&quot; target=&quot;_blank&quot;&gt;https://github.com/yu-linfeng/BlogRepositories/tree/master/repositories/%E8%AE%A9Mongo%E5%9C%A8Spring%E4%B8%AD%E8%B7%91%E8%B5%B7%E6%9D%A5/spring-data-mongo-demo&lt;/a&gt;。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;这是一个能给程序员加buff的公众号 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/630246/201901/630246-20190106013233246-1297584549.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 06 Jan 2019 14:46:00 +0000</pubDate>
<dc:creator>OKevin</dc:creator>
<og:description>本文标题为《让Mongo在Spring中跑起来》，旨在Spring中如何成功连接MongoDB并对其进行增删改查等操作，由于笔者也是刚接触，对其中的一些原由也不甚了解，若有错误之处，敬请指正。 习</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yulinfeng/p/10230832.html</dc:identifier>
</item>
<item>
<title>领域驱动设计，让程序员心中有码（五） - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/10230801.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/10230801.html</guid>
<description>&lt;p align=&quot;left&quot;&gt;1      从搬砖谈领域对象&lt;/p&gt;
&lt;p&gt;　　有一个古老的故事，大概是这样的。作者问三个建筑工地上的工人他们在干什么？有一个没精打采的说，我在挖洞！而另一一个人却说，我在盖一座房子。还有一个人说，我在建立一座巨大的城市。不同的思维模式决定了不同的发展，十年过后，第一个工人，还是在挖洞，而第二个则成为了工头。第三个最终却成为了大设计师。&lt;/p&gt;
&lt;p&gt;　　在软件开发领域，往往会使用搬砖这个词来形容我们所开发的每个功能模块，实际上也确实如此，如果把我们需要完成的每个项目，比作一座高楼大厦，那么在项目中所完成的各种模块，也确实是我们在计算机世界中利用砖块设计出来的精美建筑构建。而从领域驱动的角度来说，可以把关系，类比为建筑工程图纸中使用的各种辅助线，也可以把领域驱动中所涉及的各个对象，类比成砖块，这些砖块，大概有两种：一种是实体（Entity），一种是值对象(Value Object)，而使用这些对象的工具，则成为服务（Service)，完成的各个建筑构建，被成为包或者模块（Module).&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2      关联关系&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　在介绍领域驱动设计的第三篇文章《&lt;a href=&quot;https://www.cnblogs.com/xiyuanMore/p/10129529.html&quot; target=&quot;_blank&quot;&gt;领域驱动设计，让程序员心中有码（三）&lt;/a&gt;》中，笔者提到了UML中常用的几种关系，而关联关系是一种最为常见的关系。在软件设计过程中，无所不在的关联，有时候会让软件工程设计变得更加复杂。因此，在设计关联关系时，应该让关联更加易于控制，这意味着需要采取下列三种措施：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　1、规定一个遍历方向。对象与对象间，过于双向关联是一种低效的关系，而指定唯一的遍历方向，将有效的减少相互的依赖，实现设计的简化。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　2、添加一个限定符，以便有效地减少多重关联。过于复杂的多对多关系，最终形成一个纷繁复杂难以控制的图结构，而限定多对多关联的遍历方向，可以有效的简化多对多关系为一对多关联。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　3、消除不必要的关联。上述两个步骤的目的，也正是为了消除对于当前工作或模型对象的基本含义来说不重要的关联。实际上正是为了当前模型对象的简化。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;3      实体&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　在软件开发过程中，我们通常会定义模型和实体对象，这种实体对象同样也是领域驱动中的基本对象。按照大家的理解，通常而言，实体是指能够与数据库直接映射的对象。在领域驱动设计中，使用的则是更加妥当的说法：对象具有贯穿整个生命周期（甚至会经历多种形式）的抽象的连续性。 实体标识任何事物，只要满足两个条件即可：一个是它在整个生命周期中，具有联系性，二是他的区别并不是有哪些对用户来说非常重要的属性决定，而是通过标识来决定的。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　3.1   实体建模&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　由于实体对象的基本职责是为了确保连续性，其行为应该是非常清楚并且可以预测的。因此保持实体的简练是实现责任的关键。应该抓住实体的基本特征，而不要一味地过分求全求完美。对于实体而言，应该只添加对概念来说至关重要的行为和这些行为所必须的属性。其他行为，应当转移到与核心实体关联的其他对象中。实体则通过协调与之关联的其他对象来完成自己的基本职责。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;3.2   设计实体的标识&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　在面向对象开发中，会使用建立标识这种操作方式来实现与其他对象的区分。哪怕是在分布式系统中，同样需要使用标识来确保标识的唯一性。可以使用具有唯一性的属性来提供标识，也可以使用ID的方式来实现。这种ID如果使用系统自动生成，往往需要有一些手段确保生成的唯一性，尤其是在分布式系统中，更是一个非常困难的问题。经常使用的方式是使用redis或zookeeper这些中间件来生成唯一标识，还有一种常见的方案是使用twitter的Snowflake算法，这些算法就不再赘述了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;4      值对象&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　值对象则不具备Entity这种明确的连续性，如果在设计系统时，将所有的对象都定义为实体对象，实际上将会极大的增加系统的复杂度，所以需要定义一些用于描述领域的某个方面，本身没有概念标识的喜爱那个。例如，可以通过邮编对地址进行检索，邮编的变更，对地址也可能会发生变化，那么地址就是具有连续性的实体对象。而在电子商务系统中，只需根据地址即可完成投递，而无需确保地址的连续性，那么他就是值对象了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　值对象，往往使用与需要通过一个模型元素的属性来定义模型的场景，主要作为参数在对象间传递消息。通常是临时对象，在操作结束后，就可以被丢弃。值对象可以作为实体的属性，例如，一个人，是一个完整的实体，而他的名字，则是值对象。当然，也并非意味着值对象是一个单纯的属性，实际上值对象是指某一个特定概念下，具有完整意义的、通过属性进行理解的对象。例如，地址由省、市、区、街道、邮编等综合属性组成，这些组成对象，实际上也是实体，他们联系起来，就组成了值对象。      &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;5      服务&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　在软件设计中，并非所有的对象都需要通过标识或属性进行区分。领域驱动设计中，使用服务（Service)来定义具有活动或动作的对象。事实上也确实如此，并非所有的对象都适合使用实体或值对象来进行建模。服务强调与其他对象的操作，是通过定义能够为使用者做什么来实现的。也就是说，服务倾向于动词领域，而非名词领域。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　5.1   服务对象的基本特征&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　按照领域驱动设计的说法，一个好的服务应该具有以下特征：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　1）与领域概念相关的操作，不是Entity或ValueObject的一个自然组成部分。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　2）接口是根据领域模型的其他元素定义。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　3）操作是无状态的。操作的无状态是指任何调用者都能使用，而无需关注实例的历史状态。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;5.2   服务与领域层&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　在领域涉及中，服务无处不在，大体上包括以下几种不同层次。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　1、应用层：定义与应用相关的基础服务，例如在处理资金转账业务时，定义一系列服务，1、包括获取输入，2、发送消息给领域层服务，由其完成动作的执行；3、监听确认消息等。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　2、领域层：处理与相关的服务，例如，处理有上述转账业务发起的请求，例如进行结果的确认等。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　3、基础设施层：发送消息通知。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　5.3   服务的粒度&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       在概念建模中，通过控制领域层中接口的力度，可以有效的实现客户端与实体和值对象的耦合。通过合理的模式确保接口的简单性，将便于在大型或分布式系统中对组件进行打包的粒度控制，这实际上也是微服务架构中，服务粒度细分的理论基础。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;6      包或模块&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　模块，是软件工程学中自古有之的基本概念。在软件系统设计中，经常会按照各种各样的类别进行分解，有时候按照技术架构来分割，有时候则按照开发者的任务例如按照用例来进行细分，有的在软件重构过程中，甚至会沿用历史架构早期形成的模块划分。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　在软件工程学中，高内聚，低耦合是基本的概念，而在模块之间的关系，成为耦合，而模块内部的关系，成为内聚。因此，好的软件项目，模块之间应该低耦合，而模块内部则应该高内聚。但是模块的划分，跟软件分层划分一样，不应该仅仅只是代码层面的划分，而应该是概念模型角度的划分。不连贯的思想或者“一锅粥”式的模块划分，最终只会造成系统开发的严重不可控。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　领域驱动设计认为，模块，是一种非常重要的表达机制。模块的选择应该取决于被花费到模块中的对象的意义。当某些对象在模块中被创建时，实际上相当于告诉下一位开发者，这些对象间是通过模块来实现了某种关系。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　选择能够描述系统的模块，并使之饱含一个内聚的概念集合。应该基于模块来实现概念组合的方式，从而可以向相互独立地理解和分析这些概念。对模型进行精化，直到可以更具高层领域概念对模型进行划分，同时，相应的代码也不会产生耦合。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;7      结论&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　随着系统设计规模和复杂度的增加，模块化变得更加重要。领域模型中的每个概念都需要在实现元素中反映出来。实体、值对象、他们之间的关联关系、领域服务以及用于组织元素的模块都是实现领域模型相对应的地方。实现中的对象、指针和检索机制必须直接、清楚地映射到模型对象。&lt;/p&gt;

</description>
<pubDate>Sun, 06 Jan 2019 14:39:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>1 从搬砖谈领域对象 有一个古老的故事，大概是这样的。作者问三个建筑工地上的工人他们在干什么？有一个没精打采的说，我在挖洞！而另一一个人却说，我在盖一座房子。还有一个人说，我在建立一座巨大的城市。不同</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiyuanMore/p/10230801.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 2.2 基础知识(十二) 发送 HTTP 请求 - 热敷哥</title>
<link>http://www.cnblogs.com/refuge/p/10230795.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/refuge/p/10230795.html</guid>
<description>&lt;p&gt;&lt;span data-ttu-id=&quot;7d7bc-105&quot;&gt;可以注册 IHttpClientFactory 并将其用于配置和创建应用中的 HttpClient 实例。 &lt;span data-ttu-id=&quot;7d7bc-106&quot;&gt;这能带来以下好处：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span data-ttu-id=&quot;7d7bc-107&quot;&gt;提供一个中心位置，用于命名和配置逻辑 &lt;code&gt;HttpClient&lt;/code&gt; 实例。 &lt;span data-ttu-id=&quot;7d7bc-108&quot;&gt;例如，可以注册 github 客户端，并将它配置为访问 GitHub。 &lt;span data-ttu-id=&quot;7d7bc-109&quot;&gt;可以注册一个默认客户端用于其他用途。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span data-ttu-id=&quot;7d7bc-110&quot;&gt;通过委托 &lt;code&gt;HttpClient&lt;/code&gt; 中的处理程序整理出站中间件的概念，并提供适用于基于 Polly 的中间件的扩展来利用概念。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span data-ttu-id=&quot;7d7bc-111&quot;&gt;管理基础 &lt;code&gt;HttpClientMessageHandler&lt;/code&gt; 实例的池和生存期，避免在手动管理 &lt;code&gt;HttpClient&lt;/code&gt; 生存期时出现常见的 DNS 问题。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span data-ttu-id=&quot;7d7bc-112&quot;&gt;（通过 &lt;code&gt;ILogger&lt;/code&gt;）添加可配置的记录体验，以处理工厂创建的客户端发送的所有请求。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span data-ttu-id=&quot;7d7bc-112&quot;&gt;在应用中可以通过以下多种方式使用 IHttpClientFactory&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;基本用法&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
           &lt;span&gt; services.AddHttpClient();&lt;/span&gt;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    [ApiController]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValuesController : ControllerBase
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IHttpClientFactory _clientFactory;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ValuesController(IHttpClientFactory clientFactory)
        {
            _clientFactory &lt;/span&gt;=&lt;span&gt; clientFactory;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET api/values&lt;/span&gt;
&lt;span&gt;        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; Get()
        {
            HttpClient client &lt;/span&gt;=&lt;span&gt; _clientFactory.CreateClient();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法一:
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;HttpRequestMessage request = new HttpRequestMessage
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    Method = new HttpMethod(&quot;get&quot;),
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    RequestUri = new System.Uri(&quot;&lt;/span&gt;&lt;span&gt;http://localhost&lt;/span&gt;&lt;span&gt;:5000/api/values&quot;),
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;};
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;HttpResponseMessage response = await client.&lt;span&gt;SendAsync&lt;/span&gt;(request);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;string res = await response.Content.ReadAsStringAsync();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;return res;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法二:&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; res = &lt;span&gt;await&lt;/span&gt; client.&lt;span&gt;GetStringAsync&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5000/api/values&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
        }
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;命名客户端&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
&lt;span&gt;            services.AddHttpClient(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;test&quot;, c =&amp;gt;
            {
                c.BaseAddress = new Uri(&quot;http://localhost:5000&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;);
            });&lt;/span&gt;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; Get()
        {
            HttpClient client &lt;/span&gt;= _clientFactory.CreateClient(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册名叫 &quot;test&quot; 的客户端时,已经指定了该客户端的请求基地址,所以这里不需要指定主机名了&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; client.GetStringAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/values&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;类型化客户端&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestHttpClient
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; HttpClient Client { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TestHttpClient(HttpClient client)
        {
            client.BaseAddress &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; System.Uri(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Client &lt;/span&gt;=&lt;span&gt; client;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; Get()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; Client.GetStringAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/values&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
            services.AddHttpClient&lt;/span&gt;&amp;lt;TestHttpClient&amp;gt;(c =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以在这里设置,也可以在构造函数设置.
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;c.BaseAddress = new System.Uri(&quot;&lt;/span&gt;&lt;span&gt;http://localhost&lt;/span&gt;&lt;span&gt;:5000&quot;);&lt;/span&gt;
&lt;span&gt;            });
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    [ApiController]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValuesController : ControllerBase
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; TestHttpClient _client;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ValuesController(TestHttpClient client)
        {
            _client &lt;/span&gt;=&lt;span&gt; client;
        }
     &lt;/span&gt;
&lt;span&gt;        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; Get()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _client.Get();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;outgoing-request-middleware&quot; class=&quot;heading-with-anchor&quot;&gt;&lt;span data-ttu-id=&quot;7d7bc-169&quot;&gt;出站请求中间件&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;7d7bc-170&quot;&gt;&lt;code&gt;HttpClient&lt;/code&gt; 已经具有委托处理程序的概念，这些委托处理程序可以链接在一起，处理出站 HTTP 请求。 &lt;span data-ttu-id=&quot;7d7bc-171&quot;&gt;&lt;code&gt;IHttpClientFactory&lt;/code&gt; 可以轻松定义处理程序并应用于每个命名客户端。 &lt;span data-ttu-id=&quot;7d7bc-172&quot;&gt;它支持注册和链接多个处理程序，以生成出站请求中间件管道。 &lt;span data-ttu-id=&quot;7d7bc-173&quot;&gt;每个处理程序都可以在出站请求前后执行工作。 &lt;span data-ttu-id=&quot;7d7bc-174&quot;&gt;此模式类似于 ASP.NET Core 中的入站中间件管道。 它&lt;span data-ttu-id=&quot;7d7bc-175&quot;&gt;提供了一种用于管理围绕 HTTP 请求的横切关注点的机制，包括缓存、错误处理、序列化以及日志记录。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;7d7bc-176&quot;&gt;要创建处理程序，需要定义一个派生自 &lt;code&gt;DelegatingHandler&lt;/code&gt; 的类。 &lt;span data-ttu-id=&quot;7d7bc-177&quot;&gt;重写 &lt;code&gt;SendAsync&lt;/code&gt; 方法，在将请求传递至管道中的下一个处理程序之前执行代码：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValidateHeaderHandler : DelegatingHandler
    {
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;HttpResponseMessage&amp;gt;&lt;span&gt; SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!request.Headers.Contains(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;refuge&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpResponseMessage(HttpStatusCode.BadRequest)
                {
                    Content &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StringContent(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;not found refuge&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                };
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.SendAsync(request, cancellationToken);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
&lt;span&gt;            services.AddTransient&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;ValidateHeaderHandler&amp;gt;();//生存期必须是临时
            services.AddHttpClient(&quot;test&quot;, c =&amp;gt;
                {
                    c.BaseAddress = new Uri(&quot;http://localhost:5000&quot;);
                })
                .AddHttpMessageHandler&amp;lt;ValidateHeaderHandler&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;();&lt;/span&gt;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;httpclient-and-lifetime-management&quot; class=&quot;heading-with-anchor&quot;&gt;&lt;span data-ttu-id=&quot;7d7bc-226&quot;&gt;HttpClient 和生存期管理&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;7d7bc-226&quot;&gt;每次对 &lt;code&gt;IHttpClientFactory&lt;/code&gt; 调用 &lt;code&gt;CreateClient&lt;/code&gt; 都会返回一个新 &lt;code&gt;HttpClient&lt;/code&gt; 实例:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; Get()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试生存期&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;4&lt;/span&gt;; i++&lt;span&gt;)
            {
                HttpClient client &lt;/span&gt;= i % &lt;span&gt;2&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt;
                    ? _clientFactory.CreateClient(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    : _clientFactory.CreateClient();
                &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; &lt;span&gt;return&lt;/span&gt;&lt;span&gt; client.GetHashCode();
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201901/1189148-20190106221447497-903607223.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;CreateClient 方法内部会调用 CreateHandler 方法,后者创建 HttpMessageHandler,&lt;/p&gt;
&lt;p&gt;源码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; HttpClient &lt;span&gt;CreateClient&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
    {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (name == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof (name));
      HttpClient httpClient &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HttpClient(&lt;span&gt;this&lt;/span&gt;.&lt;span&gt;CreateHandler&lt;/span&gt;(name), &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
      HttpClientFactoryOptions clientFactoryOptions &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._optionsMonitor.Get(name);
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; index = &lt;span&gt;0&lt;/span&gt;; index &amp;lt; clientFactoryOptions.HttpClientActions.Count; ++&lt;span&gt;index)
        clientFactoryOptions.HttpClientActions[index](httpClient);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; httpClient;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; HttpMessageHandler &lt;span&gt;CreateHandler&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
    {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (name == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof (name));
      ActiveHandlerTrackingEntry entry &lt;/span&gt;= &lt;span&gt;this._activeHandlers.GetOrAdd(name, this._entryFactory).Value;
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.StartHandlerEntryTimer(entry);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (HttpMessageHandler) entry.Handler;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;而这个 _activeHandlers 的类型是 : &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201901/1189148-20190106222050716-719461479.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个线程安全的键值对集合.&lt;/p&gt;
&lt;p&gt;因此,实际上创建的 HttpMessageHandler 实例会汇集到池中.新建 &lt;code&gt;HttpClient&lt;/code&gt; 实例时,可能会重用池中的 &lt;code&gt;HttpMessageHandler&lt;/code&gt; 实例（如果生存期尚未到期的话）. &lt;/p&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;7d7bc-231&quot;&gt;由于每个处理程序通常管理自己的基础 HTTP 连接,因此需要池化处理程序.&lt;span data-ttu-id=&quot;7d7bc-232&quot;&gt;创建超出必要数量的处理程序可能会导致连接延迟. &lt;span data-ttu-id=&quot;7d7bc-233&quot;&gt;部分处理程序还保持连接无期限地打开,这样可以防止处理程序对 DNS 更改作出反应.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;7d7bc-234&quot;&gt;处理程序的默认生存期为两分钟,&lt;span data-ttu-id=&quot;7d7bc-235&quot;&gt;可在每个命名客户端上重写默认值:&lt;span data-ttu-id=&quot;7d7bc-236&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
services.AddHttpClient(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).SetHandlerLifetime(TimeSpan.FromMinutes(&lt;span&gt;5&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;configure-the-httpmessagehandler&quot; class=&quot;heading-with-anchor&quot;&gt;&lt;span data-ttu-id=&quot;7d7bc-259&quot;&gt;配置 HttpMessageHandler&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;7d7bc-260&quot;&gt;有时候,我们需要控制客户端使用的内部 &lt;code&gt;HttpMessageHandler&lt;/code&gt; .&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
            services.AddHttpClient(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .ConfigurePrimaryHttpMessageHandler(() &lt;/span&gt;=&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClientHandler()
                {
                    AllowAutoRedirect &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 06 Jan 2019 14:37:00 +0000</pubDate>
<dc:creator>热敷哥</dc:creator>
<og:description>可以注册 IHttpClientFactory 并将其用于配置和创建应用中的 HttpClient 实例。 这能带来以下好处： 提供一个中心位置，用于</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/refuge/p/10230795.html</dc:identifier>
</item>
<item>
<title>浅谈分词算法（5）基于字的分词方法（bi-LSTM） - 小月水寿</title>
<link>http://www.cnblogs.com/xlturing/p/10230728.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xlturing/p/10230728.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;p&gt;很早便规划的浅谈分词算法，总共分为了五个部分，想聊聊自己在各种场景中使用到的分词方法做个总结，种种事情一直拖到现在，今天抽空赶紧将最后一篇补上。前面几篇博文中我们已经阐述了不论分词、词性标注亦或NER，都可以抽象成一种序列标注模型，seq2seq，就是将一个序列映射到另一个序列，这在NLP领域是非常常见的，因为NLP中语序、上下文是非常重要的，那么判断当前字或词是什么，我们必须回头看看之前说了什么，甚至之后说了什么，这也符合人类在阅读理解时的习惯。由于抽象成了Seq2Seq的模型，那么我们便可以套用相关模型来求解，比如HMM、CRF以及深度中的RNN，本文我们就来聊聊LSTM在分词中的应用，以及使用中的一些trick，比如如何添加字典等。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xlturing/p/8465965.html&quot;&gt;浅谈分词算法（1）分词中的基本问题&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/xlturing/p/8467021.html&quot;&gt;浅谈分词算法（2）基于词典的分词方法&lt;/a&gt;&lt;br/&gt;[浅谈分词算法（3）基于字的分词方法（HMM）](https://www.cnblogs.com/xlturing/p/8467033.html&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/xlturing/p/10161840.html&quot;&gt;浅谈分词算法（4）基于字的分词方法（CRF）&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/xlturing/p/10230728.html&quot;&gt;浅谈分词算法（5）基于字的分词方法（LSTM）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在之前的博文&lt;a href=&quot;https://www.cnblogs.com/xlturing/p/5844555.html#%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C&quot;&gt;马里奥AI实现方式探索 ——神经网络+增强学习&lt;/a&gt;，我阐述了关于神经网络的历程，以及最近这波人工智能浪潮的起始CNN，即卷积神经网络的概念。卷积神经网络给图像领域带来了质的飞越，也将之前由李飞飞教授建立的ImageNet比赛提升到了新的高度，图像识别领域，计算机第一次超越了人类，从而引爆了最近两三年来对人工智能、深度学习的持续关注。&lt;br/&gt;当CNN在图像领域火爆之后，自然作为人工智能三大领域之一的NLP，也很快拿来使用，即著名的Text-CNN，大家感兴趣的可以去看看这篇论文&lt;a href=&quot;https://arxiv.org/pdf/1408.5882.pdf&quot;&gt;Convolutional Neural Networks for Sentence Classification&lt;/a&gt;，对NLP领域也具有重要的里程碑意义，现在引用量也达到了3436。&lt;br/&gt;但是CNN有个比较严重的问题是，其没有序列的概念在里面，如果我们将一个句子做好embedding丢到CNN中做分类模型，那么CNN更多的是将这个句子看做一个词袋（bag-of-words bag），这样在NLP领域重要的语序信息就丢失了，那么我们便引出了RNN，即循环神经网络或说递归神经网络（这里值得注意的是，如果是对语句做分类模型，那么用CNN进行不同kernel的卷积，然后拼接是可以提取到一些语序信息，这其中也涉及到各种变革的CNN，大家可以多查查资料）。&lt;br/&gt;对于循环神经网络，其实与CRF、HMM有很多共通之处，对于每一个输入&lt;span class=&quot;math inline&quot;&gt;\(x_t\)&lt;/span&gt;，我们通过网络变换都会得到一个状态&lt;span class=&quot;math inline&quot;&gt;\(h_t\)&lt;/span&gt;，对于一个序列来说，每一个token（可以是字也可以是词，在分词时是字）都会进入网络迭代，注意网络中的参数是共享的。这里不可免俗的放上经典图像吧：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/524764/201901/524764-20190106213411118-1615950664.png&quot;/&gt;&lt;br/&gt;这里将循环神经网络展开，就是后面那样。大家注意下图中的&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;，在RNN中就是一个比较简单的前馈神经网络，在RNN中会有一个严重的问题，就是当序列很长的时候，BP算法在反馈时，梯度会趋于零，即所谓的梯度消失（vanishing gradient）问题，这便引出了LSTM（Long Short Term Memory）。&lt;br/&gt;LSTM本质上还是循环神经网络，只不过呢它把上面我们提到的&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;换了换，加了三个门，其实就是关于向量的几个变换表达式，来规避这种梯度消失问题，使得LSTM的逻辑单元能够更好的保存序列信息，同样不可免俗上下面这张经典的图片：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/524764/201901/524764-20190106214132870-1357203278.png&quot;/&gt;&lt;br/&gt;图中对应了四个表达式如下：&lt;br/&gt;遗忘门：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[f_t=\sigma (W_f\cdot [h_{t-1},x_t]+b_f\]&lt;/span&gt;&lt;br/&gt;输入门：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[i_t=\sigma (W_i\cdot [h_{t-1},x_t]+b_i\]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\widetilde{C}=tanh(W_C\cdot [h_{t-1},x_t]+b_C\]&lt;/span&gt;&lt;br/&gt;状态更新：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[C_t=f_t*C_{t-1}+i_t*\widetilde{C}_t\]&lt;/span&gt;&lt;br/&gt;输出门：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[O_t=\sigma (W_o[h_{t-1},x_t]+b_o)\]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[h_t=O_t*tanh(C_t)\]&lt;/span&gt;&lt;br/&gt;一般呢LSTM都是一个方向将序列循环输入到网络之中，然而有时候我们需要两头关注序列的信息，这样便引出了Bi-LSTM，即双向LSTM，很简单，就是对于一个序列，我们有两个LSTM网络，一个正向输入序列，一个反向输入序列，然后将输出的state拼接在一起，供后续使用。&lt;br/&gt;到这里我们简单的说了下关于循环神经网络的事情，下面我们看下在分词中应用LSTM&lt;/p&gt;

&lt;p&gt;前文以及之前的系列博文，我们已经熟悉分词转换为Seq2Seq的思路，那么对于LSTM，我们需要做的是将一串句子映射成为Embedding，然后逐个输出到网络中，得到状态输出，进行序列标注。我们采用TensorFlow来开发。&lt;/p&gt;
&lt;h2 id=&quot;embedding&quot;&gt;Embedding&lt;/h2&gt;
&lt;p&gt;关于Embedding，我们可以直接下载网上公开的Wiki数据集训练好的Embedding，一般维度是100，也可以自己根据场景，利用Word2Vec、Fasttext等训练自己的Embedding。&lt;/p&gt;
&lt;h2 id=&quot;数据预处理&quot;&gt;数据预处理&lt;/h2&gt;
&lt;p&gt;其实深度的好多模型已经很成熟，最麻烦的是数据的预处理，在数据预处理阶段核心要做的是将序列映射到Embedding文件对应的id序列，并且按照Batch来切分，一般根据数据集的大小会设置64、128、256等不同的batch大小，在向网络输入数据，进行epoch迭代时，注意进行必要的shuffle操作，对于结果提高很有用，shuffle类似如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def shuffle(char_data, tag_data, dict_data, len_data):
    char_data = np.asarray(char_data)
    tag_data = np.asarray(tag_data)
    dict_data = np.asarray(dict_data)
    len_data = np.asarray(len_data)
    idx = np.arange(len(len_data))
    np.random.shuffle(idx)

    return (char_data[idx], tag_data[idx], dict_data[idx], len_data[idx])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数据预处理我这里不多讲了，读者可以直接看github上开源的代码，有问题随时留言，我有空会来解答~&lt;/p&gt;
&lt;h2 id=&quot;模型&quot;&gt;模型&lt;/h2&gt;
&lt;p&gt;我们的核心模型结构也很简单，将输入的id序列，通过Tensorflow 的查表操作，映射成对应的Embedding，然后输入到网络中，得到最终结果，进行Decode操作，得到每个字符的标记（BEMS），核心代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    def __init__(self, config, init_embedding = None):
        self.batch_size = batch_size = config.batch_size
        self.embedding_size = config.embedding_size # column
        self.hidden_size = config.hidden_size
        self.vocab_size = config.vocab_size # row

        # Define input and target tensors
        self._input_data = tf.placeholder(tf.int32, [batch_size, None], name=&quot;input_data&quot;)
        self._targets = tf.placeholder(tf.int32, [batch_size, None], name=&quot;targets_data&quot;)
        self._dicts = tf.placeholder(tf.float32, [batch_size, None], name=&quot;dict_data&quot;)
        self._seq_len = tf.placeholder(tf.int32, [batch_size], name=&quot;seq_len_data&quot;)

        with tf.device(&quot;/cpu:0&quot;):
            if init_embedding is None:
                self.embedding = tf.get_variable(&quot;embedding&quot;, [self.vocab_size, self.embedding_size], dtype=data_type())
            else:
                self.embedding = tf.Variable(init_embedding, name=&quot;embedding&quot;, dtype=data_type())
        inputs = tf.nn.embedding_lookup(self.embedding, self._input_data)
        inputs = tf.nn.dropout(inputs, config.keep_prob)
        inputs = tf.reshape(inputs, [batch_size, -1, 9 * self.embedding_size])
        d = tf.reshape(self._dicts, [batch_size, -1, 16])
        self._loss, self._logits, self._trans = _bilstm_model(inputs, self._targets, d, self._seq_len, config)
        # CRF decode
        self._viterbi_sequence, _ = crf_model.crf_decode(self._logits, self._trans, self._seq_len)
        with tf.variable_scope(&quot;train_ops&quot;) as scope:
            # Gradients and SGD update operation for training the model.
            self._lr = tf.Variable(0.0, trainable=False)
            tvars = tf.trainable_variables()  # all variables need to train
            # use clip to avoid gradient explosion or gradients vanishing
            grads, _ = tf.clip_by_global_norm(tf.gradients(self._loss, tvars), config.max_grad_norm)
            self.optimizer = tf.train.AdamOptimizer(self._lr)
            self._train_op = self.optimizer.apply_gradients(
                zip(grads, tvars),
                global_step=tf.contrib.framework.get_or_create_global_step())

            self._new_lr = tf.placeholder(data_type(), shape=[], name=&quot;new_learning_rate&quot;)
            self._lr_update = tf.assign(self._lr, self._new_lr)
        self.saver = tf.train.Saver(tf.global_variables())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码逻辑很清晰，将各种输入得到后，embedding查表结束后，放入Bi-LSTM模型，得到的结果进行Decode，这里注意我们用了一个CRF进行尾部Decode，经过试验效果更好，其实直接上一层Softmax也ok。对于bilstm如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def _bilstm_model(inputs, targets, dicts, seq_len, config):
    '''
    @Use BasicLSTMCell, MultiRNNCell method to build LSTM model
    @return logits, cost and others
    '''
    batch_size = config.batch_size
    hidden_size = config.hidden_size
    vocab_size = config.vocab_size
    target_num = config.target_num  # target output number
    seq_len = tf.cast(seq_len, tf.int32)

    fw_cell = lstm_cell(hidden_size)
    bw_cell = lstm_cell(hidden_size)

    with tf.variable_scope(&quot;seg_bilstm&quot;): # like namespace
        # we use only one layer
        (forward_output, backward_output), _ = tf.nn.bidirectional_dynamic_rnn(
            fw_cell,
            bw_cell,
            inputs,
            dtype=tf.float32,
            sequence_length=seq_len,
            scope='layer_1'
        )
        # [batch_size, max_time, cell_fw.output_size]/[batch_size, max_time, cell_bw.output_size]
        output = tf.concat(axis=2, values=[forward_output, backward_output])  # fw/bw dimension is 3
        if config.stack: # False
            (forward_output, backward_output), _ = tf.nn.bidirectional_dynamic_rnn(
                fw_cell,
                bw_cell,
                output,
                dtype=tf.float32,
                sequence_length=seq_len,
                scope='layer_2'
            )
            output = tf.concat(axis=2, values=[forward_output, backward_output])

        output = tf.concat(values=[output, dicts], axis=2)  # add dicts to the end
        # outputs is a length T list of output vectors, which is [batch_size*maxlen, 2 * hidden_size]
        output = tf.reshape(output, [-1, 2 * hidden_size + 16])
        softmax_w = tf.get_variable(&quot;softmax_w&quot;, [hidden_size * 2 + 16, target_num], dtype=data_type())
        softmax_b = tf.get_variable(&quot;softmax_b&quot;, [target_num], dtype=data_type())

        logits = tf.matmul(output, softmax_w) + softmax_b
        logits = tf.reshape(logits, [batch_size, -1, target_num])

    with tf.variable_scope(&quot;loss&quot;) as scope:
        # CRF log likelihood
        log_likelihood, transition_params = tf.contrib.crf.crf_log_likelihood(
            logits, targets, seq_len)
        loss = tf.reduce_mean(-log_likelihood)
    return loss, logits, transition_params&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意这里做了两次LSTM，并将结果拼接在一起，而我们的损失函数是关于crf_log_likelihood。&lt;/p&gt;
&lt;h2 id=&quot;如何添加用户词典&quot;&gt;如何添加用户词典&lt;/h2&gt;
&lt;p&gt;我们可以看到在整个模型训练好后，inference的过程是直接根据网络权重进行的，那么如何添加用户词典呢，这里我们采用的方式是将用户词典作为额外的特征拼接在Bi-LSTM结果的后面，就是在上面代码的output = tf.concat(values=[output, dicts], axis=2) # add dicts to the end这里，这个词典会分成四个部分，head、mid、single、tail，词头、词中、词尾以及单字词，这样对于用户词典是否出现用one-hot形式表达，不过实际使用过程中也还是存在切不出来的问题，读者可以考虑加强这部分特征。&lt;/p&gt;
&lt;p&gt;整个代码我放在github上了，感兴趣的读者直接看源代码，有问题欢迎留言~&lt;br/&gt;https://github.com/xlturing/machine-learning-journey/tree/master/seg_bilstm&lt;/p&gt;
&lt;p&gt;终于写好这个系列了，之后谢谢最近在弄的Attention、Transformer以及BERT这一套在文本分类中的应用哈，欢迎大家交流。&lt;/p&gt;
</description>
<pubDate>Sun, 06 Jan 2019 14:25:00 +0000</pubDate>
<dc:creator>小月水寿</dc:creator>
<og:description>[TOC] 前言 很早便规划的浅谈分词算法，总共分为了五个部分，想聊聊自己在各种场景中使用到的分词方法做个总结，种种事情一直拖到现在，今天抽空赶紧将最后一篇补上。前面几篇博文中我们已经阐述了不论分词、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xlturing/p/10230728.html</dc:identifier>
</item>
</channel>
</rss>