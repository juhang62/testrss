<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>你用的32位还是64位？有什么区别呢？ - 龙跃十二</title>
<link>http://www.cnblogs.com/zhonglongbo/p/14095539.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhonglongbo/p/14095539.html</guid>
<description>&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;5.2110091743119&quot;&gt;
&lt;p&gt;本文已经收录至我的GitHub,欢迎大家踊跃star 和 issues。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/midou-tech/articles&quot;&gt;https://github.com/midou-tech/articles&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过前面两篇文章的学习，外甥对电脑的产生了各种好奇，差点把自己电脑拆开来研究研究了&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我觉得这种学习精神挺好的，假使她真的把电脑拆坏了，也是赞同的，毕竟这种学习的经历是在的&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就在前几天外甥和我抱怨说只要应用打开的比较多或者网页打开比较多，电脑运行超级慢，卡顿半天&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我就反手问了一句，你知道为什么么？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;她故作无知冷冷的来了一句 &lt;strong&gt;不知道&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我细细的讲起卡顿有几方面的原因：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;打开的app或者网页需要计算的数据量太大，计算机&lt;strong&gt;算力不足&lt;/strong&gt;，此时计算机算力全部被征用了，无法在操作其他&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;打开的app&lt;strong&gt;内存需求量大&lt;/strong&gt;，打开app多或者单个app内存需求较大，会导致内存被占满，此时会发生&lt;strong&gt;磁盘&lt;/strong&gt;和&lt;strong&gt;内存&lt;/strong&gt;的交换，磁盘速度很慢&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;app需要读取大量磁盘数据，磁盘读写速度远远低于内存和CPU&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;网络卡顿，app有网路交互情况，网路非常慢，app会经历&lt;strong&gt;超时&lt;/strong&gt;和&lt;strong&gt;重试&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;巴拉巴拉说了一通，她估计实在忍不住了，打断说&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我看了任务管理器，卡顿时内存&lt;strong&gt;爆满&lt;/strong&gt; 100%状态，然后就加装了&lt;strong&gt;内存条&lt;/strong&gt;，诡异的是情况并没有好转，让我非常不解。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gl4o96flpmj305k05nq2s.jpg&quot; alt=&quot;问号？&quot;/&gt;问号？
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我听到这里，就已经知道病症在那里了，32bit和64bit的问题，今天就给大家讲讲这个病症&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gl4nwflpegj30yc0fuabg.jpg&quot; alt=&quot;文章大纲&quot;/&gt;文章大纲
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;32bit和64bit指的是什么？&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记得校招面试那会儿，经常被面试官问到，&lt;strong&gt;你知道32位和64位的区别是什么么？&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那时候我脱口而出 &lt;strong&gt;寻址能力不一样&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在看来，这个回答含糊不清、对也不对&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们应该问清楚 32位和64位指的是&lt;strong&gt;软件&lt;/strong&gt;呢？还是&lt;strong&gt;CPU&lt;/strong&gt;呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就像上面外甥的描述，她加装了一个4G内存条，她的本原生有4G内存 共计8G内存，为何原来的内存问题还是复现呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有两个可能的原因：&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;她的&lt;strong&gt;操作系统&lt;/strong&gt;软件是32位，但是CPU是64位的，这样一来的话，即使加装了内存也无法使用。&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然你有能力了，但是被限制了发挥空间，也就废物一个了，此时她装一个&lt;strong&gt;64位的操作系统&lt;/strong&gt;即可发挥8G内存的威力了。&lt;/p&gt;
&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;32位的CPU，这样一来的话，内存加装到8G了，也无济于事，寻址能力跟不上。&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面两种情况，第一种是有能力，但被限制了，只要放开我，就还你一片天地；第二种是无能为力&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以当在聊32位和64位的问题时，要优先搞清楚说的是什么？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的内容很容易看出来，所指&lt;strong&gt;对象不同&lt;/strong&gt;，结果完全&lt;strong&gt;不同&lt;/strong&gt;的，不可一概而论&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;32bit和64bit的区别&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;明白了32位和64位指代对象，现在来谈谈二者的区别，谈之前先温习下前面说的&lt;strong&gt;冯诺依曼&lt;/strong&gt;结构&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gl4pk672slj30mu0f2gn4.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结构五件套就不说了，前面有文章专门介绍了 &lt;a href=&quot;https://mp.weixin.qq.com/s/6wrp6864leNuZlLuRlzmlg&quot;&gt;计算机如何组成的？&lt;/a&gt;&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;&lt;p&gt;输入设备&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;p&gt;输出设备&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;p&gt;存储器&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;p&gt;中央处理器&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;p&gt;控制器&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说说五件套之间如何有效通信的&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU 和内存以及其他设备之间，需要通信，因此我们用一种特殊的设备进行控制，就是&lt;strong&gt;总线&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总线分成 3 种：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;&lt;strong&gt;地址总线&lt;/strong&gt;，专门用来指定 CPU 将要操作的内存地址&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;strong&gt;数据总线&lt;/strong&gt;，用来读写内存中的数据&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;strong&gt;控制总线&lt;/strong&gt;，用来发送和接收关键信号，比如中断信号，还有设备复位、就绪等信号，都是通过控制总线传输。CPU 需要对这些信号进行响应，这也需要控制总线。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，这和我们要说的32位和64位有什么关系呢？&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;32位和64位软件的区别&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;32位软件和64位软件的区别就是，&lt;strong&gt;指针的大小&lt;/strong&gt;不同，也就是&lt;strong&gt;地址范围&lt;/strong&gt;不同&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;估计一脸黑人问号，现在高级语言都不在使用指针这个概念了，龙叔还在说 指针 是不是不合时宜了&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是的，高级语言除了C++还在谈指针，其他的语言如java、Python、go都已经不谈指针了&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;语言设计者不谈是为了给开发者&lt;strong&gt;减负&lt;/strong&gt;，并不意味着就是没有了&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;指针非常核心，因为我们 &lt;strong&gt;访问内存数据必须依赖地址，指针就是地址&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拉回来了，继续说32位软件和64位软件问题&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软件设计者在设计软件时是32位的，意味着程序里面使用的指针都是4byte的，也就意味着最大能寻到的地址2^32次方，也就是4G。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以当我们操作系统是32位时，最大只能访问到4G内存，不管我们加多大的内存条 都是无意义的&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;声明一下 &lt;strong&gt;操作系统也是一种软件&lt;/strong&gt; ，不过是一种系统软件&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户软件是依赖操作系统的寻址操作的，如果操作系统是32位，该操作系统下无法运行64位的用户软件&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，数据传递是通过&lt;strong&gt;高低电压&lt;/strong&gt;控制的，高电平是1 低电平是0&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;龙叔在大学学习数字电路时经常搞这种操作，动不动就是用电路连接一个&lt;strong&gt;加法器&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gl4thosatuj30iq0indrz.jpg&quot; alt=&quot;四位全加器实验&quot;/&gt;四位全加器实验
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经常做实验就是搞几个芯片 通过电路去控制做一个加法器或者去在显示器上按照规则亮灭相应的二极管&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说实话，大一让我搞这些 还是比较头疼的，动不动几个小时还没搞个所以然，现在看来不过尔尔&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以现在每当遇到困难时，我都假设自己处在未来某个时间点 来看当下的问题 最终就是不过尔尔&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实本质就是使用电平的高低变化去传输数据，一个高电平表示 1 低电平表示 0&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我们只有一条地址线，一次传输只能是一个电平0或1，那你要传输一个数字10(二进制)就必须传输两次&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种只有一条地址总线进行数据传输的方式称为&lt;strong&gt;串行传输&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我们有两条地址总线，一次就能传输&lt;strong&gt;两个电平&lt;/strong&gt;，数字10就只需要传输一次就好&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种用多条地址总线，一次传输多个信号的方式就是&lt;strong&gt;并行传输&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 CPU 需要读写内存的时候，先要通过地址总线来指定内存地址，再通过数据总线来传输数据&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们地址总线的根数决定寻址的能力，当我们有32根地址总线时我们的寻址能力就是2^32=4G&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;32位CPU和64位CPU的区别&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子：用一个32位的CPU求和两个64位的数字&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常 32 位宽 CPU 最多操作 32 位宽的地址总线和数据总线&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;64 位宽 CPU 最多操作 64 位宽的地址总线和数据总线&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就存在一个问题，64位数字无法进行一次性传输到32位上让CPU进行计算&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由上面的传输原则可知 必须把64位数字拆分为两个32数字进行传输&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这个例子可以很明白的看到，&lt;strong&gt;32位的CPU和64位的CPU在控制总线上的能力不同&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;32位CPU和64位CPU的区别之一就是，&lt;strong&gt;CPU 的位宽决定能控制的总线根数&lt;/strong&gt;，而总线的根数决定寻址能力&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;32位最大控制的总线为32根，最大寻址能力是4G，一次能传输最大字节数是4byte&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;64位最大控制的总线为64根，最大寻址能力是256TB，一次能传输的最大字节数是8byte&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还可以看到的是，32位的CPU计算能力也是只能计算32位的数据，无法对64位的数据进行运算&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这点可能不是很好理解，32位CPU一次读入只能读取32bit的数据，同时32位的CPU只有32位的&lt;strong&gt;寄存器&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;64位具有&lt;strong&gt;向下兼容&lt;/strong&gt;特性，64位可以跑32位的软件，可以进行32位的计算&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到这里，再回想面试官问的问题，以及外甥女的不解 犹如明镜一般清澈无比&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gl4v1ou822g30460460uj.gif&quot; alt=&quot;&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;64的优势是什么？&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来说说64位的优势到底是个啥&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的CPU执行程序的步骤是：&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;CPU读取PC指针指向的指令，简称&lt;strong&gt;取指&lt;/strong&gt;（fetch）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;CPU 分析&lt;strong&gt;指令寄存器&lt;/strong&gt;中的指令，确定指令的类型和参数，简称 &lt;strong&gt;解码&lt;/strong&gt;（decode）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;如果是计算类型的指令，那么就交给逻辑运算单元计算；如果是存储类型的指令，那么由控制单元执行 ，简称&lt;strong&gt;执行&lt;/strong&gt;（execute）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;将执行结果进行返回给寄存器或者将寄存器数据存入内存，简称 &lt;strong&gt;存储&lt;/strong&gt;（store）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;PC 指针自增，并准备获取下一条指令&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面步骤是一个循环也称为&lt;strong&gt;CPU指令周期&lt;/strong&gt;，CPU 的工作就是一个周期接着一个周期，周而复始。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gl4wysiwmoj30f20b6jrv.jpg&quot; alt=&quot;指令周期&quot;/&gt;指令周期
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在CPU运行的周期中可以看到，有一个核心的部件 &lt;strong&gt;寄存器&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面用到了 &lt;strong&gt;程序寄存器&lt;/strong&gt; &lt;strong&gt;指令寄存器&lt;/strong&gt;，寄存器本质就是&lt;strong&gt;指针&lt;/strong&gt;，指针就是地址，地址就是一串数字编码&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而决定这串数字编码的就是地址的大小，地址的大小由&lt;strong&gt;寻址能力&lt;/strong&gt;决定，寻址能力就是&lt;strong&gt;总线&lt;/strong&gt;的根数&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总线的根数是由&lt;strong&gt;CPU的位数&lt;/strong&gt;决定的&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到这里其实大家应该已经明白64位CPU的优势了，龙叔还是给个总结&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;64 位 CPU 可以执行&lt;strong&gt;更大&lt;/strong&gt;数字的运算，具体多大呢？ 2^64这么大&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个优势在普通应用上不明显，但是对于数值计算较多的应用就非常明显&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;64 位 CPU 可以寻址更大的内存空间&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 32 位/64 位说的是程序，那么说的是指令是 64 位还是 32 位的&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;32 位指令在 64 位机器上执行，困难不大，可以兼容。 如果是 64 位指令，在 32 位机器上执行就困难了&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;32 位指令在 64 位机器执行的时候，需要的是一套兼容机制就OK了，但是 64 位指令在 32 位机器上执行，32 位的寄存器都存不下指令的参数。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;操作系统也是一种程序，如果是 64 位操作系统，也就是操作系统中程序的指令都是 64 位指令，因此不能安装在 32 位机器上。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;补充内容&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面提到了寄存器，很多人对寄存器非常陌生，这里详细讲解一下&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gl641diafcj30np0n60v0.jpg&quot; alt=&quot;CPU内部结构图&quot;/&gt;CPU内部结构图
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的图中可以很明显的看到，图中虚线以内，&lt;strong&gt;寄存器是CPU内部集成的&lt;/strong&gt;，&lt;strong&gt;内存是外部的&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们访问内存时需要通过&lt;strong&gt;寄存器&lt;/strong&gt;去找到对应的地址，再执行相应的指令&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时CPU会在数据总线上生成&lt;strong&gt;读取&lt;/strong&gt;或&lt;strong&gt;写入&lt;/strong&gt;内存的时钟信号，最后内存的内容会被CPU寄存器的内容更新或者读入&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;寄存器是啥，上面已经说了，&lt;strong&gt;寄存器就是一个指针，里面存放着地址&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是本期的所有内容了，我是龙叔，我们下期见&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后非常需要靓仔靓女们的分享、转发、点赞，这些都是我创作的动力，感谢大家&lt;/p&gt;
</description>
<pubDate>Mon, 07 Dec 2020 00:45:00 +0000</pubDate>
<dc:creator>龙跃十二</dc:creator>
<og:description>本文已经收录至我的GitHub,欢迎大家踊跃star 和 issues。 https://github.com/midou-tech/articles 通过前面两篇文章的学习，外甥对电脑的产生了各种好</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhonglongbo/p/14095539.html</dc:identifier>
</item>
<item>
<title>Spring框架之AOP源码完全解析 - tageerxing</title>
<link>http://www.cnblogs.com/xxkj/p/14094203.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xxkj/p/14094203.html</guid>
<description>&lt;p align=&quot;center&quot;&gt;&lt;span&gt;Spring框架之AOP源码完全解析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        Spring可以说是Java企业开发里最重要的技术。Spring两大核心IOC（Inversion of Control控制反转）和AOP（Aspect Oriented Programming面向切面编程）。IOC技术我们在上一篇文章“&lt;a href=&quot;https://www.cnblogs.com/xxkj/p/13929565.html&quot; target=&quot;_blank&quot;&gt;Spring框架之beans源码完全解析&lt;/a&gt;”中进行了分析，本文对Spring框架的AOP源码进行分析。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        AOP面向切面编程是通过预编译方式和运行其动态代理，实现在不修改源代码的情况下给程序动态统一添加功能的一种技术，是OOP面向对象编程的有效补充。利用AOP技术将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不会影响业务逻辑的代码，实现了解耦，提高了代码的灵活性和可扩展性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        下面就Spring框架的AOP源码进行解析，主要从以下几个方面进行剖析：一是对Spring的几个关键概念进行阐述；二是对AOP源码文件清单进行梳理，一共9大类，204个java文件。三是Spring主要使用JDK动态代理来实现AOP，对JDK动态代理做了一个简单的介绍。四是结合源码对Spring AOP的实现原理进行了分析。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;文章目录&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一、Spring AOP几个关键概念&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、AOP联盟&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、AOP、Spring AOP、AspectJ的区别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、Spring AOP 10个常见概念&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、Advice（通知/增强）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、Advisor(顾问/增强器)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、Pointcut（切点）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7、TargetSource（目标对象）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8、Interceptor（拦截器）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二、AOP源码文件清单&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、aopalliance包含的接口和类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、AOP包含的接口和类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、AOP/aspectj包含的接口和类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、AOP/config包含的接口和类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、AOP/framework包含的接口和类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、AOP/interceptor包含的接口和类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7、AOP/scope包含的接口和类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8、AOP/support包含的接口和类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9、AOP/target包含的接口和类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三、JDK动态代理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（一）什么是代理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（二）Java的动态代理类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（三）动态代理的步骤&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;四、Spring AOP的实现原理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（一）标签的解析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（二）获取增强方法或者增强器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（三）根据获取的增强创建代理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（四）织入&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、Spring AOP几个关键概念&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;、AOP联盟&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        AOP联盟规范了一套用于规范AOP实现的底层API，通过这些统一的底层API，可以使得各个AOP实现及工具产品之间实现相互移植。这些API主要以标准接口的形式提供，是AOP编程思想所要解决的横切交叉关注点问题各部件的最高抽象。Spring的AOP框架中也直接以这些API为基础构建。下面我们来看看当前AOP联盟发布的AOP相关的标准接口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        AOP联盟的API主要包括四个部分，第一个是aop包，定义了一个表示通知Advice的标识接口，各种各样的通知都继承或者实现了该接口。aop包中还包括了一个用于描述AOP系统框架错误运行时异常AspectException。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        第二个部分是intercept包，也就是拦截器包，这个包中规范了AOP核心概念中的连接点及通知Advice的类型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        第三部分及第四部分是instrument及reflect包。这两个包中的API主要包括AOP框架或者产品为了实现把横切关注点的模块和核心应用模块组合集成，所需要使用的设施、技术及底层实现规范等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        aopalliance1.0.jar类结构如下图所示（未包括第三、四部分）：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1804544/202012/1804544-20201206205251901-293578153.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;aopalliance有三个主要的业务实体：Joinpoint 、Advice、Interceptor。这三个接口构成了aopalliance功能结构。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        1、Joinpoint：程序在执行过程中一个运行时Joinpoint，在这些点关联的静态位置通常会安装有一些Interceptor，当程序运行到这个运行时Joinpoint时，AOP框架会拦截运行时Joinpoint的执行，把运行时Joinpoint交给已经安装的Interceptor们进行处理。JoinPoint接口有三个方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               proceed()：该方法用于执行拦截器逻辑；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               getThis()：返回保持当前连接点的静态部分的对象；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               getStaticPart()：返回此连接点的静态部分（通常包含构造函数，成员变量，方法等信息）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        2、Advice只是起到一个超类标记功能。Advice（通知）定义了AOP框架在某个Joinpoint（连接点）的通用处理逻辑。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        3、Interceptor（拦截器）。Interceptor继承了Advice，可以看成是对Advice的特殊功能实现。Interceptor只是Advice处理逻辑中的一种类型或者方式，表示的仅仅是采用拦截处理机制实现了Advice这种功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        Advice和Interceptor两个接口没有任何操作，都是标记接口。（标识接口就是空方法的接口。与其他接口的区别是：这个接口里面什么方法都没有，只是标记而已。例如serilizeabled就是这样一个接口，他只是告诉jvm，继承于这个接口的CLASS需要序列化处理，我们不用实现这个接口的方法。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;、AOP、Spring AOP、AspectJ的区别&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）AOP：Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）AspectJ：AspectJ来自于 Eclipse 基金会，属于静态植入，它是通过修改代码来实现的，它的植入时机可以是：Compile-time weaving编译期织入；Post-compile weaving编译后织入，也就是已经生成了.class 文件，或已经达成 jar 包了；Load-time weaving指的是在加载类的时候进行织入。AspectJ 能干很多 Spring AOP 干不了的事情，它是 AOP 编程的完全解决方案。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）SpringAOP：它基于动态代理来实现AOP。如果使用接口的，用JDK提供的动态代理实现，如果没有接口，使用 CGLIB 实现。Spring AOP 致力于解决的是企业级开发中最普遍的 AOP 需求（方法织入），而不是力求成为一个像 AspectJ 一样的 AOP 编程完全解决方案。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AOP是一种概念，springAOP、AspectJ都是AOP的实现，Spring AOP有自己的语法，但是语法复杂，所以SpringAOP借助了AspectJ的注解，但是底层实现还是自己的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;、Spring AOP 10个常见概念&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）Joinpoint（连接点）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        程序执行的某个特定位置，比如某个方法调用前、调用后，方法抛出异常后，对类成员的访问以及异常处理程序块的执行等。一个类或一段程序代码拥有一些具有边界性质的特定点，这些代码中的特定点就是连接点。它自身还可以嵌套其他的Joinpoint。AOP中的Joinpoint可以有多种类型：构造方法调用，字段的设置和获取，方法的调用，方法的执行，异常的处理执行，类的初始化。Spring仅支持方法执行类型的Joinpoint。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）Pointcut（切点）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        如果连接点相当于数据中的记录，那么切点相当于查询条件，一个切点可以匹配多个连接点。所以切点表示一组Joinpoint，这些Jointpoint或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，它定义了相应的 Advice 将要发生的地方。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）Advice（通知/增强）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        通知是织入到目标类连接点上的一段程序代码。Spring提供的通知接口都是带方位名的，如：BeforeAdvice、AfterReturningAdvice、ThrowsAdvice等。我们通过AOP将横切关注功能加到原有的业务逻辑上，这是对原有业务逻辑的一种增强，可以是前置、后置、返回后、抛出异常时等。其实Advice翻译成“增强”更合理，更能准确表达其本质。既然大部分文献都是称为通知，我们这里也称为通知。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）Introduction（引介）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        引介是一种特殊的通知，它为类添加一些属性和方法。这样，即使一个业务类原本没有实现某个接口，通过引介功能，可以动态的为该业务类添加接口的实现逻辑，让业务类成为这个接口的实现类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）Interceptor（拦截器）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        在Advice的基础上扩展定义，定义了通知的增强方式，也就是通过对Joinpoint（连接点）的拦截。一个通用的拦截器可以拦截发生在基础程序中的运行时事件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（6）Aspect（切面）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        切面是由Pointcut（切点）和Advice（通知）组成的，它包括了对横切关注功能的定义，也包括了对连接点的定义。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（7）Advisor(顾问/增强器)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         Advisor是切面的另一种实现，绑定通知跟切点。没有指定切点的通知是没有意义的，Advisor可以说就是一个绑定在指定切点上的通知。它能够将通知以更为复杂的方式织入到目标对象中，是将通知包装为更复杂切面的装配器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（8）TargetSource&lt;em&gt;（目标对象）&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        包含连接点的对象。也被称作被通知或被代理对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（9）Proxy（代理对象）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        包含了原始对象的代码（是在合适的位置调用目标对象的方法）和增加后的代码（Advice通知的内容）的那个对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（10）Weaving（织入）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        织入是将Advice通知添加到目标类具体连接点上的过程，AOP有三种织入方式：①编译期织入：需要特殊的Java编译期（例如AspectJ的ajc）；②装载期织入：要求使用特殊的类加载器，在装载类的时候对类进行增强；③运行时织入：在运行时为目标类生成代理实现增强。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AspectJ采用了编译期织入和装载期织入的方式，Spring采用了动态代理的方式实现了运行时织入。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;strong&gt;、Advice（通知/增强）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Advice有以下几种常见的类型：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、AspectJMethodBeforeAdvice：前置通知。AspectJ中 before 属性对应的通知（@Before标注的方法会被解析成该通知），在切面方法执行之前执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、AspectJAfterReturningAdvice：后置通知。AspectJ中 afterReturning 属性对应的通知（@AfterReturning 标注的方法会被解析成该通知），在切面方法执行之后执行，如果有异常，则不执行。注意：该通知与AspectJMethodBeforeAdvice对应。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、AspectJAroundAdvice：环绕通知。AspectJ中 around 属性对应的通知（@Around标注的方法会被解析成该通知），在切面方法执行前后执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、AspectJAfterAdvice：返回通知。AspectJ中 after 属性对应的通知（@After 标注的方法会被解析成该通知），不论是否异常都会执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、AspectJAfterThrowingAdvice：异常通知，AspectJ中 after 属性对应的通知（@AfterThrowing标注的方法会被解析成该通知），在连接点抛出异常后执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;strong&gt;、Advisor(顾问/增强器)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;advisor：顾问（切面的另一种实现），封装了spring aop中的切点和通知。通知（advice）中包含了增强的横切代码，切点（pointcut）包含了连接点的描述信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、StaticMethodMatcherPointcut：静态方法切面。定义了一个classFilter，通过重写getClassFilter()方法来指定切面规则。另外实现了StaticMethodMatcher接口，通过重写matches来指定方法匹配规则。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、StaticMethodMatcherPointcutAdvisor：静态方法匹配切面顾问。扩展了切面排序方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、NameMatchMethodPointcut：名称匹配切面。通过指定方法集合变量mappedNames，模糊匹配。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、NameMatchMethodPointcutAdvisor：方法名称切面顾问。内部封装了NameMatchMethodPointcut，通过设置方法名称模糊匹配规则和通知来实现切面功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、RegexpMethodPointcutAdvisor：正则表达式切面顾问。可设置多个正则表达式规则，通过内部封装的JdkRegexpMethodPointcut解析正则表达式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、DefaultPointcutAdvisor：默认切面顾问。比较灵活，可自由组合切面和通知。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7、InstantiationModelAwarePointcutAdvisorImpl：springboot自动装配的顾问类型。是最常用的一种顾问实现。在注解实现的切面中，所有@Aspect类，都会被解析成该对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;advisorCreator：继承 spring ioc的扩展接口 beanPostProcessor，主要用来扫描获取advisor。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、AbstractAutoProxyCreator：Spring 为Spring AOP 模块暴露的可扩展抽象类，也是 AOP 中最核心的抽象类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、BeanNameAutoProxyCreator：根据指定名称创建代理对象。通过设置 advisor，可以对指定的 beanName 进行代理。支持模糊匹配。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、AbstractAdvisorAutoProxyCreator：功能比较强大，默认扫描所有Advisor的实现类。相对于根据Bean名称匹配，该类更加灵活。动态的匹配每一个类，判断是否可以被代理，并寻找合适的增强类，以及生成代理类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、DefaultAdvisorAutoProxyCreator：AbstractAdvisorAutoProxyCreator的默认实现类。可以单独使用，在框架中使用AOP，尽量不要手动创建此对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、AspectJAwareAdvisorAutoProxyCreator：AspectJ的实现方式，也是Spring Aop中最常用的实现方式，如果用注解方式，则用其子类AnnotationAwareAspectJAutoProxyCreator。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、AbstractAutoProxyCreator：Spring 为Spring AOP 模块暴露的可扩展抽象类，也是 AOP 中最核心的抽象类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7、AnnotationAwareAspectJAutoProxyCreator：目前最常用的AOP使用方式。spring aop 开启注解方式之后，该类会扫描所有@Aspect()注释的类，生成对应的advisor。目前SpringBoot框架中默认支持的方式，自动配置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;strong&gt;、Pointcut&lt;/strong&gt;&lt;strong&gt;（切点）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、AnnotationMatchingPointcut：注解匹配切点。根据类上或方法上是否存在指定的注解判断切点的匹配性，如果没有显示指定注解，则匹配所有。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、DynamicMethodMatcherPointcut：动态方法匹配器切点。它本质上是一个方法匹配器，但同时具有了切点的功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、ComposablePointcut：可组合的切点。这种切点可以与或逻辑，任意组合其他的Pointcut、ClassFilter和MethodMatcher。其本质是通过ClassFilters和MethodMatchers两个工具类进行Pointcut内部组件的组合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、JdkRegexpMethodPointcut： JDK正则表达式切点，即使用正则表达式描述方法的拦截规则和排除规则。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、AspectJExpressionPointcut：AspectJ切点表达式切点。顾名思义，使用AspectJ的切点表达式描述筛选规则。表达式基本语法如下（非完整语法）：&lt;/span&gt;&lt;span&gt;execution(&amp;lt;方法修饰符&amp;gt;? &amp;lt;方法返回值类型&amp;gt; &amp;lt;包名&amp;gt;.&amp;lt;类名&amp;gt;.&amp;lt;方法名&amp;gt;(&amp;lt;参数类型&amp;gt;) [throws &amp;lt;异常类型&amp;gt;]?)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        其中，‘*’代表0个或多个任意字符，包名中的..（两个点）代表当前包及其子包，参数列表中的..代表任意个参数。如：execution(public static * *..*.*(..) throws *)，此表达式匹配所有方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;strong&gt;、TargetSource&lt;em&gt;（目标对象）&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        TargetSource被用于获取当前MethodInvocation（方法调用）所需要的target（目标对象），这个target通过反射的方式被调用（如：method.invode(target,args)）。换句话说，proxy（代理对象）代理的不是target，而是TargetSource。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        为什么Spring AOP代理不直接代理target，而需要通过代理TargetSource（target的来源，其内部持有target），间接代理target呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       通常情况下，一个proxy（代理对象）只能代理一个target，每次方法调用的目标也是唯一固定的target。但是，如果让proxy代理TargetSource，可以使得每次方法调用的target实例都不同（当然也可以相同，这取决于TargetSource实现）。这种机制使得方法调用变得灵活，可以扩展出很多高级功能，如：target pool（目标对象池）、hot swap（运行时目标对象热替换）等等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        TargetSource组件本身与Spring IoC容器无关，target的生命周期不一定是受spring容器管理的，我们以往的XML中的AOP配置，只是对受容器管理的bean而言的，我们当然可以手动创建一个target，同时使用Spring的AOP框架（而不使用IoC容器）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        TargetSource包含4个简单实现和3大类实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4个简单实现包括：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）EmptyTargetSource：静态目标源，当不存在target目标对象，或者甚至连targetClass目标类都不存在（或未知）时，使用此类实例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）HotSwappableTargetSource：动态目标源，支持热替换的目标源，支持spring应用运行时替换目标对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）JndiObjectTargetSource：spring对JNDI管理bean的支持，static属性可配置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）SingletonTargetSource：静态目标源，单例目标源。Spring的AOP框架默认为受IoC容器管理的bean创建此目标源。换句话说，SingletonTargetSource、proxy与目标bean三者的声明周期均相同。如果bean被配置为prototype，则spring会在每次getBean时创建新的SingletonTargetSource实例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3大类实现包括：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）AbstractBeanFactoryBasedTargetSource：此类目标源基于IoC容器实现，也就是说target目标对象可以通过beanName从容器中获取。此类又扩展出：① SimpleBeanTargetSource：简单实现，直接调用getBean从容器获取目标对象；② LazyInitTargetSource：延迟初始化目标源，子类可重写postProcessTargetObject方法后置处理目标对象；③AbstractPrototypeBasedTargetSource：原型bean目标源，此抽象类可确保beanName对应的bean的scope属性为prototype。其子类做了简单原型、池化原型、线程隔离原型这3种实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）AbstractRefreshableTargetSource：可刷新的目标源。此类实现可根据配置的刷新延迟时间，在每次获取目标对象时自动刷新目标对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）AbstractLazyCreationTargetSource：此类实现在调用getTarget()获取时才创建目标对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;8&lt;/strong&gt;&lt;strong&gt;、Interceptor（拦截器）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        Interceptor（拦截器）定义了通知的增强方式，也就是通过对Joinpoint（连接点）的拦截。一个通用的拦截器可以拦截发生在基础程序中的运行时事件。这些事件被连接点具体化。运行时连接点可以是一次方法调用、字段访问、异常产生等等。Interceptor接口也在强调概念而非功能，也是一个标记接口。 由Interceptor扩展出的ConstructorInterceptor和MethodInterceptor两个子接口，才具体定义了拦截方式。它们一个用于拦截构造方法，一个用于拦截普通方法。 但是，spring框架并没有支持AOP联盟对构造方法的拦截，因为spring框架本身，通过BeanPostProcessor的定义，对bean的生命周期扩展已经很充分了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         MethodInterceptor只定义了增强方式，我们可以通过实现此接口，自定义具体的增强内容。当然，spring框架也提供了3种预定义的增强内容：BeforeAdvice（前置通知）、AfterAdvice（后置通知）和DynamicIntroductionAdvice（动态引介通知）。BeforeAdvice和AfterAdvice更确切地说是定义了增强内容的执行时机（方法调用之前还是之后）；而DynamicIntroductionAdvice比较特殊，它可以编辑目标类要实现的接口列表。最后，spring预定义的通知还是要通过对应的适配器，适配成MethodInterceptor接口类型的对象（如：MethodBeforeAdviceInterceptor负责适配MethodBeforeAdvice）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;几个常用拦截器：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）MethodBeforeAdviceInterceptor：MethodBeforeAdvice（前置通知，其父接口是BeforeAdvice）接口的适配器，用于支持spring预定义的前置通知，在目标方法调用前调用MethodBeforeAdvice.before()。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）AspectJAfterAdvice ：AspectJ框架的后置通知实现，在目标方法执行结束后，return之前，调用配置指定的方法（注意：此方法调用被写在finally块中，无论如何都会得到执行）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）AfterReturningAdviceInterceptor ：AfterReturningAdvice接口的适配器，用于支持spring预定义的后置通知，在目标方法执行结束后，return之前，调用AfterReturningAdvice.afterReturning()执行（注意：如果目标方法抛出异常，则不会执行这个方法）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）AspectJAfterThrowingAdvice ：AspectJ框架的异常通知，当目标方法执行时产生异常的时候，指定配置指定的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）AspectJAroundAdvice ：AspectJ框架的环绕通知，直接执行配置指定的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（6）ThrowsAdviceInterceptor ：spring框架预定义的异常通知的适配器，此适配器接受任意类型的对象，但是要求对象所在类必须声明public的名称为afterThrowing，且参数个数为1个或4个，且最后一个参数为Throwable类型的方法。该适配器会保存该Throwable对象的实际类型到该方法之间的映射，当目标方法执行产生异常时，根据产生的异常类型找到对应的通知方法进行调用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（7）DelegatingIntroductionInterceptor：通过构造方法传入指定的引介对象，每当调用的目标方法是引介接口定义的方法时，都会调用该引介对象的对应方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（8）DelegatePerTargetObjectIntroductionInterceptor：通过构造函数传入指定的引介接口和接口对应的实现类，该拦截器会为每个目标对象创建新的引介对象（通过调用实现类的默认无参构造）。当调用的方法是引介接口定义的方法时，则调用该新建的引介对象对应的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、AOP源码文件清单&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文进行梳理的AOP源码文件清单是基于版本号为5.2.4.BUILD-SNAPSHOT的Spring源码。一共9大类，204个java文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;、aopalliance&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;aopalliance/aop&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.1  Advice：定义了一个表示通知的标识接口，各种各样的通知都继承或实现了该接口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.2  AspectException：描述AOP系统框架错误的运行时异常。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;aopalliance/intercept&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.3  Joinpoint：连接点。在拦截器中使用，封装了原方法调用的相关信息，如参数、原对象信息，以及直接调用原方法的proceed方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.4  Invocation 运行时的方法调用，继承自joinpoint。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.5  ConstructorInvocation：Invocation的子类，包含了获取构造器的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.6  MethodInvocation：Invocation的子类，返回被调用的方法信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.7  Interceptor：拦截器，Advice的子接口，标记拦截器。拦截器是增强器的一种。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.8  ConstructorInterceptor：构造器拦截器，Interceptor的子接口，拦截构造器并处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.9  MethodInterceptor：方法拦截器，Interceptor的子接口，拦截方法并处理，核心类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;、AOP&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.1  Pointcut：切点的一个顶层抽象。切点的主要作用是定义通知所要应用到的类跟方法。具体的哪些类、哪些方法由ClassFilter和MethodMatcher匹配，只有满足切入点的条件时才插入advice。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.2  TruePointcut：Pointcut（切点）接口的一个最简单的实现类，匹配到所有。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.3  AfterAdvice：无论一个 join point 是正常退出还是发生了异常， 都会被执行的 advice。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.4  AfterReturningAdvice：后置通知（After Returning Advice）后置通知相比较于前置通知，主要有以下几点不同：后置通知可以访问目标方法的返回值，但是不能修改，后置通知是在方法执行完成后执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.5  BeforeAdvice：在 join point 前被执行的 advice。虽然 before advice 是在 join point 前被执行，但是它并不能够阻止 join point 的执行，除非发生了异常(即我们在 before advice 代码中, 不能人为地决定是否继续执行 join point 中的代码)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.6  MethodBeforeAdvice：前置通知（Before Advice）跟环绕通知不同的是，这个接口中定义的方法的返回值是void，所以前置通知是无法修改方法的返回值的。如果在前置通知中发生了异常，那么会直接终止目标方法的执行以及打断整个拦截器链的执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.7  ThrowsAdvice：异常通知（Throws Advice），其中没有定义任何方法，它更像一个标记接口。我们在定义异常通知时需要实现这个接口，同时方法的签名也有要求：1、方法名称必须是afterThrowing。2、方法的参数个数必须是1个或者4个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.8  Advisor：顾问，封装了spring aop中的切点和通知。 就是我们常用的@Aspect 注解标记的类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.9  PointcutAdvisor：代表具有切点的切面，它包含Advice和Pointcut两个类，这样就可以通过类、方法名以及方法方位等信息灵活地定义切面的连接点，提供更具适用性的切面。其有6种实现类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        DefaultPointcutAdvisor：最常用的切面类型，它可以通过任意Pointcut和Advice定义一个切面，唯一不支持的是引介的切面类型，一般可以通过扩展该类实现自定义的切面；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        NameMatchMethodPointcutAdvisor：通过该类可以定义，按方法名定义切点的切面；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        RegexpMethodPointcutAdvisor：按正则表达式匹配方法名进行切点定义的切面；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        StaticMethodMatcherPointcutAdvisor：静态方法匹配器切点定义的切面；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        AspecJExpressionPointcutAdvisor：Aspecj切点表达式定义切点的切面；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        AspecJPointcutAdvisor：使用AspecJ语法定义切点的切面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.10  MethodMatcher：用来匹配方法。MethodMatcher中一共有三个核心方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        matches(Method method, @Nullable Class&amp;lt;?&amp;gt; targetClass)，这个方法用来判断当前定义的切点跟目标类中的指定方法是否匹配，它可以在创建代理的时候就被调用，从而决定是否需要进行代理，这样就可以避免每次方法执行的时候再去做判断。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        isRuntime()，如果这个方法返回true的话，意味着每次执行方法时还需要做一次匹配。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        matches(Method method, @Nullable Class&amp;lt;?&amp;gt; targetClass, Object... args)，当之前的isRuntime方法返回true时，会调用这个方法再次进行一次判断，返回false的话，意味着不对这个方法应用通知。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        接口的实现类有很多，如StaticMethodMatcher（只支持静态匹配，两个参数的matchs）、AspectJExpressionPointcut（AOP重要组件）、TrueMethodMatcher（总是匹配）、AnnotationMethodMatcher（注解匹配）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.11  TrueMethodMatcher：MethodMatcher接口的一个最简单的实现类，匹配到所有的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.12  ClassFilter：主要作用是在类级别上对通知的应用进行一次过滤，如果它的match方法对任意的类都返回true的话，说明在类级别上我们不需要过滤，这种情况下，通知的应用，就完全依赖MethodMatcher的匹配结果。ClassFilter有4中简单方式的实现：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        （1）TypePatternClassFilter：基于AspectJ的类型匹配实现；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        （2）AnnotationClassFilter：通过检查目标类是否存在指定的注解，决定是否匹配；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        （3）RootClassFilter：通过判断目标类是否是指定类型（或其子类型），决定是否匹配；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        （4）TrueClassFilter：这是最简单实现，matches方法总会返回true。此类设计使用了单例模式，且其对象引用直接被在ClassFilter接口中声明成了常量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.13  TrueClassFilter：ClassFilter接口的一个最简单的实现类，匹配到所有的类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.14  IntroductionInfo：描述一个引介需要的基本信息。引介(Introduction)是指在不更改源代码的情况，给一个现有类增加属性、方法，以及让现有类实现其它接口或指定其它父类等，从而改变类的静态结构。是另一种类型的增强，和通知是并列的两种不同的增强。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.15  IntroductionAdvisor：advisor顾问，封装了spring aop中的切点和通知。这个接口是用来处理一个或者多个引入的顾问的父接口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.16  DynamicIntroductionAdvice：引介通知（Introduction Advice）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.17  IntroductionAwareMethodMatcher：继承自MethodMatcher，在进行方法匹配时考虑了引入。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.18  IntroductionInterceptor：AOP联盟中的MethodInterceptor（方法拦截器，拦截方法并处理）的子接口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.19  TargetSource：TargetSource（目标源）是被代理的target（目标对象）实例的来源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.20  TargetClassAware：在代理中用来公开目标类的最小接口，主要被代理对象和代理工厂所实现.。所有的Aop代理对象或者代理工厂（proxy factory)都要实现的接口，该接口用于暴露出被代理目标对象类型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.21  RawTargetAccess：AOP代理的标记接口，用来返回原始的目标对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.22  SpringProxy：标记接口，Spring使用JDK动态代理或者CGLIB的方式来生成代理对象，其中每个代理对象都会实现SpringProxy接口。用来判定是否是Spring产生的代理对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.23  ProxyMethodInvocation：MethodInvocation接口的拓展，能够返回一个代理对象，而当前的Method Invocation是通过该代理对象办到的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.24  AopInvocationException：因为错误的配置或者始料不及的运行时出现的问题，导致AOP运行时方法调用失败时抛出的异常。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;、AOP/aspectj &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.1  AbstractAspectJAdvice：AOP基类，用来包装AspectJ切面（AspectJ aspect）或AspectJ注解（AspectJ-annotated）的通知方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.2  AspectJAfterAdvice：返回通知，AspectJ中 after 属性对应的通知（@After 标注的方法会被解析成该通知），不论是否异常都会执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.3  AspectJAfterReturningAdvice：后置通知，AspectJ中 afterReturning 属性对应的通知（@AfterReturning 标注的方法会被解析成该通知），在切面方法执行之后执行，如果有异常，则不执行。注意：该通知与AspectJMethodBeforeAdvice对应。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.4  AspectJMethodBeforeAdvice：前置通知，AspectJ中 before 属性对应的通知（@Before标注的方法会被解析成该通知），在切面方法执行之前执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.5  AspectJAfterThrowingAdvice：异常通知，AspectJ中 after 属性对应的通知（@AfterThrowing标注的方法会被解析成该通知），在连接点抛出异常后执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.6  AspectJAroundAdvice：环绕通知，AspectJ中 around 属性对应的通知（@Around标注的方法会被解析成该通知），在切面方法执行前后执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.7  AspectJPointcutAdvisor：继承自接口PointcutAdvisor，该类用来调整AbstractAspectJAdvice 使其适应PointcutAdvisor接口 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.8  AspectJExpressionPointcutAdvisor：用来处理对应 AspectJ 的 advice 和切点的，有advice的设置和获取、切点表达式的一些处理、设置切点的Bean工厂，获取该切点等方法。该类创建了一个 AspectJExpressionPointcut，它们之间的关系是一对一的组合关系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.9  DeclareParentsAdvisor：Spring AOP提供的@Before、@After、@AfterReturning、@AfterThrowing、@Around只对类的现有方法进行增强处理。如果需要对现有类增加新的方法，有两种方法可实现：（1）扩展现有类：实现简单，但如果对多个现有类进行扩展时，需增加多个类。（2）使用@DeclareParents注解实现：实现复杂，可使用通配符匹配。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.10  InstantiationModelAwarePointcutAdvisor：由spring aop顾问实现的接口，封装了可能具有延迟初始化策略的AspectJ 切面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.11  AspectJExpressionPointcut：AspectJ表达式切点（通过解析XML配置文件中的&amp;lt;aop:pointcut&amp;gt;元素生成的就是此类型的bean）。它是一种切点，但与一般的切点不同，一般的切点需要持有单独的ClassFilter和MethodMatcher。但是AspectJ表达式切点本身就兼具了这两个组件的功能。因为切点表达式，就是用来描述要代理的目标类和目标方法的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.12  MethodInvocationProceedingJoinPoint：AspectJ的ProceedingJoinPoint接口的一个实现类，包装了MethodInvocation。Proceedingjoinpoint接口 继承自 JoinPoint，是在JoinPoint的基础上暴露出 proceed 这个方法。环绕通知=前置+目标方法执行+后置通知，proceed方法就是用于启动目标方法执行的，暴露出这个方法，就能支持 aop:around 这种切面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.13  AspectInstanceFactory：切面工厂，实现该接口的工厂用来生成AspectJ切面的一个实例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.14  SimpleAspectInstanceFactory：该接口主要用于从给定的类（或者 beanName 等）获取一个切面实例，这是AspectInstanceFactory接口的一个实现类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.15  SingletonAspectInstanceFactory：AspectInstanceFactory接口的一个实现类，用来支持单例的对象，对于每次调用getAspectInstance()，都返回同一个切面实例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.16  AspectJAopUtils：相比于AopUtils，AspectJAopUtils是专门针对于AspectJ advisors的工具类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.17  AspectJProxyUtils：它相对于AopProxyUtils,它只是专门处理AspectJ代理对象的工具类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.18  AspectJAdviceParameterNameDiscoverer：从切点表达式、返回值、抛出异常来推断一个AspectJ通知方法的参数名，如果不存在一个明确的推断，返回Null。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.19  AspectJPrecedenceInformation：存储用来给通知、顾问根据AspectJ的排序规则进行排序用的相关信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.20  AspectJWeaverMessageHandler：实现自AspectJ的IMessageHandler接口，与常规Spring消息一样，使用相同的日志系统来对AspectJ编织消息进行路由。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.21  RuntimeTestWalker：这个类用来封装一些AspectJ内部的结果，在将来解压中再重新推送到AspectJ项目中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.22  TypePatternClassFilter：ClassFilter类过滤器。基于AspectJ的类型匹配实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AOP/aspectj/annotation&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.23  AspectJAdvisorFactory：该类主要用于对切面的校验，从切面中解析 Advisor， Advice 等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.24  AbstractAspectJAdvisorFactory：作为父类完成了 是否切面、切面校验、方法切面注解获取、切面注解封装、切面参数解析等一些列工作，将核心的解析 Advisors Advice 交给了 ReflectiveAspectJAdvisorFactory。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.25  ReflectiveAspectJAdvisorFactory：获取 Advisors，从 MetadataAwareAspectInstanceFactory （包含有切面的元数据信息）中获取切面元数据信息，将方法切点解析为对应的 AspectJExpressionPointcut（通过切点表达式），然后封装成 InstantiationModelAwarePointcutAdvisorImpl 返回。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.26  AspectJProxyFactory：创建AspectJ的AOP对象，用于Spring集成AspectJ的作用，此时，就不需要使用AspectJ特定的编译器了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.27  MetadataAwareAspectInstanceFactory：AspectInstanceFactory的子接口，返回与AspectJ annotated相关的AspectMetedata。本来AspectInstanceFactory包含该方法是最好的，但是AspectMetedata仅仅使用Java 5，所以我们需要单独分离出该子接口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.28  LazySingletonAspectInstanceFactoryDecorator：简单的装饰，使MetadataAwareAspectInstanceFactory实例化一次。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.29  SingletonMetadataAwareAspectInstanceFactory：MetadataAwareAspectInstanceFactory的一个实现类，每次调用getAspectInstance()函数时，都会返回同一个实例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.30  BeanFactoryAspectInstanceFactory：该类就是AspectInstanceFactory接口的一个实现类，用来生成AspectJ切面的一个实例。需要注意的是如果使用原型模式，实例化多次，可能返回的不是你想要的。使用LazySingletonAspectInstanceFactoryDecorator包装该类，这样就可以确保每次都可以得到一个新的切面实例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.31  PrototypeAspectInstanceFactory：多例专用的工厂。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.32  SimpleMetadataAwareAspectInstanceFactory：MetadataAwareAspectInstanceFactory的一个实现类，每次调用getAspectInstance()函数时，都会创建指定的切面类的实例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;             &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.33  AspectMetadata：AspectJ切面类的元数据，每个切面附加一个额外的Spring AOP切点。该类有属性：aspectName、aspectClass、ajType（transient修饰，表示该属性不需要序列，序列化对象的时候,这个属性就不会被序列化）、perClausePointcut。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.34  InstantiationModelAwarePointcutAdvisorImpl：AspectJPointcutAdvisor的内部实现，注意对于每一个目标方法都会有一个该顾问的实例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.35  BeanFactoryAspectJAdvisorsBuilder： Spring AOP内部工具类，用来从bean容器也就是BeanFactory中获取所有使用了@AspectJ注解的bean，最终用于自动代理机制(auto-proxying)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        该工具内部使用了缓存机制，虽然公开的查找方法可能会被调用多次，但并不是每次都会真正查找，而是会利用缓存。最核心的逻辑在其方法buildAspectJAdvisors中，该方法查找容器中所有@AspectJ注解的bean，然后将其中每个advice方法包装成一个Spring Advisor。最终结果以一个List&amp;lt;Advisor&amp;gt;的形式返回给调用者。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.36  AnnotationAwareAspectJAutoProxyCreator：目前最常用的AOP使用方式。spring aop 开启注解方式之后，该类会扫描所有@Aspect()注释的类，生成对应的advisor。目前SpringBoot框架中默认支持的方式，自动配置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.37  NotAnAtAspectException：AopConfigException类的拓展，当试图对一个类生成顾问，但是该类又不是AspectJ 注解类型的切面的时候抛出异常。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AOP/aspectj/autoproxy&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.38  AspectJAwareAdvisorAutoProxyCreator：AspectJ的实现方式，也是Spring Aop中最常用的实现方式，如果用注解方式，则用AnnotationAwareAspectJAutoProxyCreator（该类的一个子类）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.39  AspectJPrecedenceComparator：排序比较器。它优先比较两个增强器所属的切面大小，如果是同一个切面产生的两个增强器，他们的大小是相同的，则需要拿到它们的声明顺序即InstantiationModelAwarePointcutAdvisorImpl的declarationOrder属性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;             &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;strong&gt;、AOP/config  &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.1  PointcutComponentDefinition：创建一个切点的信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.2  AspectComponentDefinition：创建一个切面的信息，包括了嵌套的切点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.3  AdvisorComponentDefinition：创建一个顾问的信息，用来弥合通过&amp;lt;aop:advisor&amp;gt;配置的顾问的bean definition和架构中的部件定义。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.4  AbstractInterceptorDrivenBeanDefinitionDecorator：BeanDefinitionDecorator(接口)装饰相关的自定义属性。该抽象类继承自BeanDefinitionDecorator，用于注册相应的Interceptor bean 定义。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.5  ScopedProxyBeanDefinitionDecorator：&amp;lt;aop:scoped-proxy&amp;gt;标签是spring&amp;lt;bean&amp;gt;标签的装饰标签，AOP命名空间的三大标签之一，它的作用是对生命周期短的bean提供装饰，使其能被生命周期长的bean正确调用。该类负责对该标签进行解析。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;             &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.6  PointcutEntry：实现了接口ParseState.Entry，代表一个切点的入口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ParseState（在包org.springframework.beans.factory.parsing中）在解析进程中作为一个简单的基于栈结构的追踪逻辑位置类。该类中有一个内部标记接口Entry，为了进入ParseState，要实现该内部标记接口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.7  AdviceEntry：实现了接口ParseState.Entry，代表一个通知的入口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.8  AdvisorEntry：实现了接口ParseState.Entry，代表一个顾问的入口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.9  AspectEntry：实现了接口ParseState.Entry，代表一个切面的入口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;             &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.10  SpringConfiguredBeanDefinitionParser：实现了接口BeanDefinitionParser，专门用来解析&amp;lt;aop:spring-configured/&amp;gt;标签。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.11  AspectJAutoProxyBeanDefinitionParser：是一个实现了BeanDefinitionParser接口的类，专门用于解析切面自动代理的Bean定义的解析工作，重点在其parse方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.12  ConfigBeanDefinitionParser：用来解析&amp;lt;aop:config /&amp;gt;标签，并将标签相应的BeanDefinition注册BeanFactory（DefaultListableBeanFactory）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.13  AopConfigUtils：这个是关于AOP配置的工具类。因为配置AOP的方式有多种（比如xml、注解等），此工具类就是针对不同配置，提供不同的工具方法的。它的好处是不管什么配置，最终走底层逻辑都归一了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.14  AopNamespaceHandler：AOP命名空间处理器，Spring为了开放性提供了NamespaceHandler机制，这样我们就可以根据需求自己来处理我们设置的标签元素。我们使用基于xml的spring配置时，可能需要配置如&amp;lt;aop:config /&amp;gt;这样的标签，在配置这个标签之前，通常我们需要引入这个aop所在的命名空间。只有通过配置aop的命名空间才会找到AOP标签的处理器AopNamespaceHandler，在AOP的jar中的spring.handlers配置文件中配置了命名空间和命名空间处理器之间的关系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.15  AopNamespaceUtils：处理Spring AOP命名空间的工具类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.16  MethodLocatingFactoryBean：实现了FactoryBean接口，通过调用getObject()方法获取MethodLocatingFactory对象。主要作用是通过Bean的名称和方法名定位到这个Method，然后通过反射进行调用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.17  SimpleBeanFactoryAwareAspectInstanceFactory：继承自AspectInstanceFactory（切面实例工厂），该类在bean工厂中通过bean的名字可以定位到切面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;             &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;strong&gt;、AOP/framework &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.1  AopProxy：代表一个AopProxy代理对象，可以通过这个对象构造代理对象实例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.2  AopProxyUtils：对org.springframework.aop.support.AopUtils的一个补充。其中比较重要的方法： completeProxiedInterfaces（判断一个advised真正需要代理的目标接口列表 ）和ultimateTargetClass（获取一个代理对象的最终对象类型）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.3  ProxyConfig：AOP配置类，是所有的AOP代理工厂的父类，它包含了创建一个AOP代理所需要的基础的通用的一些配置信息。它有五个属性：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        proxyTargetClass 是否直接对目标类进行代理，而不是通过接口产生代理；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        optimize 标记是否对代理进行优化；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        opaque 标记是否需要阻止通过该配置创建的代理对象转换为Advised类型；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        exposeProxy 标记代理对象是否应该被aop框架通过AopContext以ThreadLocal的形式暴露出去；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        frozen 标记是否需要冻结代理对象，即在代理对象生成之后，是否允许对其进行修改。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.4  ProxyProcessorSupport：提供为代理创建器提供了一些公共方法实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.5  ProxyCreatorSupport：这个类的主要作用是为创建一个AOP代理对象提供一些功能支持，通过它的getAopProxyFactory能获取一个创建代理对象的工厂。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.6  ProxyFactory：ProxyFactory继承自ProxyCreatorSupport，使用它来创建一个代理对象也是要先去设置相关的配置信息，然后再调用创建代理的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.7  ProxyFactoryBean：ProxyFactoryBean的功能：初始化通知器链，获取单例、原型的Aop代理对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.8  AbstractSingletonProxyFactoryBean：FactoryBean的一个超类，主要用来生成singleton-scoped代理对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.9  AopProxyFactory：AopProxy代理工厂类，用于生成代理对象AopProxy。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.10  DefaultAopProxyFactory  AopProxyFactory：AopProxyFactory默认实现类，核心函数createAopProxy。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.11  JdkDynamicAopProxy：生成jdk动态代理。可以看到这个类本身就是一个InvocationHandler，这意味着当调用代理对象中的方法时，最终会调用到JdkDynamicAopProxy的invoke方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.12  CglibAopProxy：生成Cglib动态代理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.13  ObjenesisCglibAopProxy  ：该类继承自CglibAopProxy，重写了createProxyClassAndInstance方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        objenesis是一个小型Java类库用来实例化一个特定class的对象。Java已经支持使用class.newinstance()的类动态实例化，但是必须要有一个合适的构造函数。而很多场景下类不能够用这种方式去实例化，例如：构造函数需要参数（Constructors that require arguments）、有副作用的构造函数（Constructors that have side effects）、会抛出异常的构造函数（Constructors that throw exceptions）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        因此，常见的是在类库中看到类必须要有一个默认的构造函数的限制，Objenesis旨在通过绕过对象实例化的构造函数来克服这些限制。典型用途：（1）序列化，远程调用和持久化-对象需要被实例化并恢复到特定的状态，而不需要调用代码。（2）代理、 AOP 库和 mock 对象-类可以被子类继承而子类不用担心父类的构造器。（3）容器框架-对象可以以非标准的方式动态地实例化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.14  Advised：代表被Advice增强的对象，包括添加advisor的方法、添加advice等的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.15  AdvisedSupport：ProxyConfig类的子类，封装了AOP中通用的对增强（Advice）和通知器（Advisor）的相关操作，对于所有生成AOP代理对象都通用，而代理对象的生成由子类完成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.16  AdvisedSupportListener：监听器，注册在ProxyCreatorSupport对象（用来注册和触发监听器）中，捕获第一个代理创建时和代理创建后通知状态发生改变的事件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.17  AopInfrastructureBean：免被AOP代理的标记接口。是一个标记接口。若Bean实现了此接口，表明它是一个Spring AOP的基础类，那么这个类是不会被AOP给代理的，即使它能被切面切进去。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.18  AbstractAdvisingBeanPostProcessor：继承自BeanPostProcessor，自身内置一个 Advisor，检查当前bean是否符合应用该 Advisor 的条件，符合的话将自己的 Advisor 包裹到当前bean(必要的时候为当前bean创建代理对象以便包裹自己的Advisor)。其中调用了函数AopUtils.canApply(this.advisor, targetClass)，用来检查某个 Advisor 是否可应用到某个 bean 上的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.19  AopConfigException：AOP配置参数非法时抛出的异常。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.20  AopContext：代表AOP的上下文。主要是提供我们访问上下文中当前AOP对象的快速方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.21  AdvisorChainFactory：获取增强器链的工厂接口。提供方法返回所有增强器，以数组返回。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.22  DefaultAdvisorChainFactory：这个工厂类负责生成拦截器链。借助DefaultAdvisorAdapterRegistry将Advisor集合转换成MethodInterceptor集合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.23  InterceptorAndDynamicMethodMatcher：框架的内部类，组合MethodInterceptor实例和MethodMatch作为增强器链中的一个元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.24  ReflectiveMethodInvocation：核心类，激发拦截链工作实现。该类实现了aop联盟的MethodInvocation，间接实现了Invocation和Joinpoint。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;             &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AOP/framework/adapter&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.25  AdvisorAdapter：一个适配器接口，它定义了自己支持的Advice类型，并且能把一个Advisor适配成MethodInterceptor。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;spring aop框架对BeforeAdvice、AfterAdvice、ThrowsAdvice三种通知类型的支持实际上是借助适配器模式来实现的，这样的好处是使得框架允许用户向框架中加入自己想要支持的任何一种通知类型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.26  AdvisorAdapterRegistry：顾问适配器注册的接口，这是一个SPI接口，不会被任何Spring用户所实现。java spi就是提供这样的一个机制：为某个接口寻找服务实现的机制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.27  DefaultAdvisorAdapterRegistry：它用来完成各种通知的适配和注册过程。将Advice包装成Advisor（DefaultPointCutAdvisor），借助AdvisorAdapter，将Advisor包装成MethodInterceptor。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.28  GlobalAdvisorAdapterRegistry：负责拦截器的适配和注册过程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.29  AdvisorAdapterRegistrationManager：继承自BeanPostProcessor后置处理器，利用AdvisorAdapterRegistry在Bean工厂中注册AdvisorAdapter（通知适配器）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;             &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.30  AfterReturningAdviceAdapter：后置通知适配器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        在 Spring 的 Aop 中，适配器模式应用的非常广泛。Spring 使用 Advice（通知）来增强被代理类的功能，Advice 的类型主要有 BeforeAdvice、AfterReturningAdvice、ThrowsAdvice。每种 Advice 都有对应的拦截器，即 MethodBeforeAdviceInterceptor、AfterReturningAdviceInterceptor、ThrowsAdviceInterceptor。各种不同类型的 Interceptor，通过适配器统一对外提供接口。最终调用不同的 advice来实现被代理类的增强。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.31  AfterReturningAdviceInterceptor：后置通知拦截器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.32  MethodBeforeAdviceAdapter：前置通知适配器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.33  MethodBeforeAdviceInterceptor：前置通知拦截器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.34  ThrowsAdviceAdapter：异常通知适配器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.35  ThrowsAdviceInterceptor：异常通知拦截器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.36  UnknownAdviceTypeException：当尝试使用一个不支持的顾问或者通知时抛出的异常。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AOP/framework/autoproxy&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.37  AbstractAdvisorAutoProxyCreator：默认扫描所有Advisor的实现类，相对于根据Bean名称匹配，该类更加灵活。动态的匹配每一个类，判断是否可以被代理，并寻找合适的增强类，以及生成代理类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.38  AbstractAutoProxyCreator：Spring 为Spring AOP 模块暴露的可扩展抽象类，也是 AOP 中最核心的抽象类。自动代理机制的实现其实很简单，就是通过Bean的后置处理器，在创建Bean的最后一步对Bean进行代理，并将代理对象放入到容器中。实现自动代理的核心类就是AbstractAutoProxyCreator。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        它的三个具体的实现类来进行分析，分别是BeanNameAutoProxyCreator、DefaultAdvisorAutoProxyCreator、AnnotationAwareAspectJAutoProxyCreator。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.39  BeanNameAutoProxyCreator：根据指定名称创建代理对象。通过设置 advisor，可以对指定的 beanName 进行代理。支持模糊匹配。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.40  DefaultAdvisorAutoProxyCreator：AbstractAdvisorAutoProxyCreator的默认实现类。可以单独使用，在框架中使用AOP，尽量不要手动创建此对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.41  InfrastructureAdvisorAutoProxyCreator       ：自动代理创建器，所有的创建器都是AbstractAutoProxyCreator抽象类的子类。该类是Spring给自己内部使用的一个自动代理创建器。它主要是读取Advisor类，并对符合的bean进行二次代理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.42  AutoProxyUtils：为自动代理组件准备的工具类。主要用于框架内部使用（AbstractAutoProxyCreator）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.43  ProxyCreationContext：当前代理创建的上下文，主要给自动代理创建器使用。比如AbstractAdvisorAutoProxyCreator。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.44  AbstractBeanFactoryAwareAdvisingPostProcessor：该抽象类定义了这样一类BeanPostProcessor：拥有一个Advisor，对每个bean进行后置处理，如果该bean符合包裹自己所拥有的Advisor的条件，则将该Advisor包裹该bean。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        这里将bean和Advisor包裹该bean的又分两种情况：目标bean是Advised，此时直接使用Advised接口定义的方法添加Advisor到目标bean。目标bean不是Advised，此时为目标对象创建代理对象，并将Advisor添加到目标bean的代理对象上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        以上主要逻辑基本实现在其父类AbstractAdvisingBeanPostProcessor 中，而该类主要是在此基础上实现了BeanFactoryAware接口。并覆盖实现父类的方法prepareProxyFactory，isEligible。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.45  BeanFactoryAdvisorRetrievalHelper：这个类很重要，是一个Spring AOP内部工具类，用来从bean容器（BeanFactory）中获取所有Spring的Advisor bean（这里的 Spring Advisor bean指的是实现了接口org.springframework.aop.Advisor的bean）。是真正去容器中找出所有的Advisor的类。该工具内部使用了缓存机制，虽然公开的查找方法可能会被调用多次，但并不是每次都会真正查找，而是会利用缓存。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.46  TargetSourceCreator：创建专用的target source。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AOP/framework/autoproxy/target&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.47  AbstractBeanFactoryBasedTargetSourceCreator：TargetSourceCreator的一个超类，对于一个原型bean需要创建多个实例时使用。使用一个内部的bean工厂去管理这些target实例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.48  LazyInitTargetSourceCreator：创建的代理对象并没有初始化，直到第一次调用时才进行初始化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.49  QuickTargetSourceCreator：根据beanName的不同前缀创建三种常用的TargetSource类型(bean必须为多例)。（1）CommonsPoolTargetSource：池化TargetSource，每次执行方法时从池中取代理对象，执行完方法再返回池中。（2）ThreadLocalTargetSource：线程级的TargetSource。（3）PrototypeTargetSource：多例TargetSource，每次执行方法创建新的代理对象，执行完销毁该对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;             &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;strong&gt;、AOP/interceptor &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.1  AbstractTraceInterceptor：MethodInterceptor的实现类，主要用于日志记录。默认情况下，写入日志中的消息是记录拦截器类而不是被拦截的类。当把bean属性开关useDynamicLogger设置为true时，拦截器类和被拦截的类日志都会被记录下来。该抽象类的实现子类必须实现方法invokeUnderTrace。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.2  SimpleTraceInterceptor：继承自AbstractTraceInterceptor， 该拦截器可以引入拦截器链中，用来显示被拦截的方法调用的详细跟踪信息，包括方法进入和退出的信息。 如果想要更高级的需求，可以考虑使用自定义的跟踪拦截器CustomizableTraceInterceptor。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.3  CustomizableTraceInterceptor：方法级示踪器。 MethodInterceptor的实现类，使用占位符，来进行自定义的方法层级的示踪器。跟踪在方法入口处消息是否写入，在方法退出时判断方法调用是否成功。如果调用出现异常，那么一个异常消息记录下来。这些跟踪消息和占位符是高度定制化的，你可以将一些运行时信息写入日志系统中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.4  DebugInterceptor：这个拦截器可以引入链中用来将拦截的调用的一些详细信息显示到日志记录器中。在进行调试时，可以将方法入口和出口处&lt;/span&gt;&lt;span&gt;的一些调用细节详细的记录下来，包括调用的参数和调用的次数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.5  ExposeInvocationInterceptor：暴露当前MethodInvocation的拦截器。作为线程本地对象， 我们偶尔需要这样做， 比如切入点时需要知道完整的调用上下文。除非确实有必要，否则不要使用此拦截器。 目标对象应该通常不了解Spring AOP，因为这会产生对Spring API的依赖。目标对象应尽可能是普通的POJO。如果要使用这个拦截器，要将这个拦截器放在拦截链中的开头。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.6  AbstractMonitoringInterceptor：监控拦截器的基类，比如性能监控器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.7  PerformanceMonitorInterceptor：性能监控的拦截器，这个拦截器对于被拦截的方法不会有任何附加的作用。其在实际的性能测量时，使用了简洁的耗时统计小工具org.springframework.util.StopWatch。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.8  JamonPerformanceMonitorInterceptor：性能监控的拦截器，使用了JAMon库对被拦截的方法和输出的状态信息进行性能的监测。另外它也可以对被拦截的方法抛出的异常进行跟踪计数，这些堆栈跟踪足迹可以在JAMopn的web应用中显示出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Jamon的全名是：Java Application Monitor。它是一个小巧的，免费的，高性能的，线程安全的性能监测工具。它可以用来测定系统的性能瓶颈，也可以用来监视用户和应用程序之间的交互情况。 Jamon主要是用来检测jee的应用程序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.9  ConcurrencyThrottleInterceptor：继承自ConcurrencyThrottleSupport，spring控制并发数的工具类。在ConcurrencyThrottleSupport类中，简单的通过synchronized和wati and notify达到控制线程数量的效果，从而实现限流的策略。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        该拦截器中的invoke()方法中，在执行目标方法的前后分别执行beforeAccess()和 afterAccess()方法。在beforeAccess方法中通过内部计数器concurrencyCount来对比设置的阀值concurrencyLimit，如果超过设置值，则阻塞；若没有超过设置值，则concurrencyCount自加。在afterAccess方法中自减concurrencyCount。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.10  AsyncExecutionAspectSupport：异步任务执行切面的一个基类。核心方法determineAsyncExecutor()，返回一个执行异步任务的线程池AsyncTaskExecutor。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.11  AsyncExecutionInterceptor：异步任务选择执行器。其核心方法是invoke，主要流程；（1）获取拦截的方法。（2）根据被拦截的方法来选取执行异步任务的执行器。（3）构建任务（添加异常的处理方式）。（4）执行构建的任务并返回任务执行结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.12  AsyncUncaughtExceptionHandler：异步任务执行抛出的异常catch不到时通过此接口进行处理。一个异步任务通常会返回一个java.util.concurrent.Future实例，以访问潜在的异常，当这个异步任务不提供这个返回值时，这个句柄就负责处理此类捕获不到的异常。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.13  SimpleAsyncUncaughtExceptionHandler：AsyncUncaughtExceptionHandler接口的一个默认实现，用来简单记录这个异常。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.14  ExposeBeanNameAdvisors：当Spring IOC容器创建自动代理bean时可以使用，使得创建顾问更加便捷，将bean name绑定到当前的调用。通常在spring自动代理中使用，在代理创建时，bean的名称就是已知的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;strong&gt;、AOP/scope   &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7.1  ScopedObject：用于作用域对象的AOP引介接口。ScopedProxyFactoryBean创建的对象可以转换到这个接口，能够得到原始的目标对象，从它的目标scopt中剥离出该对象。Spring的Bean是有scope属性的，表示bean的生存周期。scope的值有prototype、singleton、session、request。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7.2  DefaultScopedObject：ScopedObject接口的默认实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7.3  ScopedProxyFactoryBean：便捷的代理工厂bean，用于作用域对象。被这个工厂bean创建的代理是单例的，线程安全，可以会被注入到共享的对象中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7.4  ScopedProxyUtils：创建作用域代理的一些功能性类。主要被ScopedProxyBeanDefinitionDecorator 和 ClassPathBeanDefinitionScanner使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;             &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;8&lt;/strong&gt;&lt;strong&gt;、AOP/support&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.1  AbstractExpressionPointcut：表达式切点类型的抽象超类，提供定位和表达式两个属性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.2  ExpressionPointcut：表达式切点类型，通过表达式匹配，用于支持AspectJ的表达式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.3  NameMatchMethodPointcut：名称匹配切面，通过指定方法集合变量mappedNames，模糊匹配。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.4  DynamicMethodMatcherPointcut    ：动态方法匹配器切点。它本质上是一个方法匹配器，但同时具有了切点的功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.5  StaticMethodMatcherPointcut：静态方法切面，抽象类。定义了一个classFilter，通过重写getClassFilter()方法来指定切面规则。另外实现了StaticMethodMatcher接口，通过重写matches来指定方法匹配规则。子类：NameMatchMethodPointcut（简单字符串匹配方法签名）和 AbstractRegexpMethodPointcut（正则表达式匹配方法签名）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.6  AbstractRegexpMethodPointcut：正则表达式匹配方法签名。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.7  JdkRegexpMethodPointcut：JDK正则表达式切点，即使用正则表达式描述方法的拦截规则和排除规则。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.8  ControlFlowPointcut：流程切点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.9  ComposablePointcut：复合切点。这种切点可以与或逻辑，任意组合其他的Pointcut、ClassFilter和MethodMatcher。其本质是通过ClassFilters和MethodMatchers两个工具类进行Pointcut内部组件的组合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;             &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.10  AbstractPointcutAdvisor：PointcutAdvisor接口的抽象基类，其子类可以返回指定的切点/通知，或者是一个可自由配置的切点/通知。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.11  AbstractGenericPointcutAdvisor：一般的、通用的PointcutAdvisor。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.12  DefaultPointcutAdvisor：默认切面顾问，比较灵活。可自由组合切面和通知。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.13  NameMatchMethodPointcutAdvisor：方法名称切面顾问，内部封装了NameMatchMethodPointcut，通过设置方法名称模糊匹配规则和通知来实现切面功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.14  StaticMethodMatcherPointcutAdvisor：静态方法匹配切面顾问，扩展了切面排序方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.15  RegexpMethodPointcutAdvisor：正则表达式切面顾问，可设置多个正则表达式规则，通过内部封装的JdkRegexpMethodPointcut解析正则表达式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.16  DefaultIntroductionAdvisor：默认的引介通知器，它是一种通知器，但同时兼具了类过滤器的功能，且matches总返回true。它的作用是给所有bean追加指定接口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.17  AbstractBeanFactoryPointcutAdvisor：基于Bean工厂的切点增强器，允许任何通知配置成指向在bean工厂中的通知bean。通过指定通知bean的名字而不是通知对象本身，在初始化时可以降低耦合度，可以切点真正匹配的时候再去初始化通知对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.18  DefaultBeanFactoryPointcutAdvisor：AbstractBeanFactoryPointcutAdvisor抽象类的实现。基于BeanFactory的PointAdvisor，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;             &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.19  AopUtils：该工具类是Spring非常重要的一个工具类。一个外部工具类，我们平时若想要对AOP做一些判断、处理，可使用此工具类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.20  Pointcuts：提供了一些静态方法，在操作切点时有用，包括matches、SetterPointcut、GetterPointcut。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.21  ClassFilters：针对ClassFilter，还有一个工具类——ClassFilters。ClassFilters内部定义了两个私有的静态内部类：IntersectionClassFilter和UnionClassFilter，分别支持以与的逻辑和或的逻辑组合多个ClassFilter。此工具类同时对外提供了组合ClassFilter的API。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.22  RootClassFilter：通过判断目标类是否是指定类型（或其子类型），决定是否匹配。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.23  MethodMatchers：同ClassFilters一样，是一个工具类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.24  DynamicMethodMatcher：动态方法匹配器的一个抽象超类，主要用于关注运行期间的参数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.25  StaticMethodMatcher：静态方法匹配的一个抽象超类，它并不关系运行时期的参数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.26  IntroductionInfoSupport：描述一个引介需要的基本信息接口的增强功能，其实现的子类可以方便的从一个指定的对象所实现的所有接口提取出来，将不应该加入的接口排除掉，同时也可以查询所有引入的接口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.27  DelegatePerTargetObjectIntroductionInterceptor：引介可以看成一种特殊的Advice，在没有改变原先类的定义的情况下为其增加新的方法。这中通知是spring-aop自己定义的，所以没有类似 @Before 这种配置可以直接注入advice到spring容器中，故此需要自己实现 DynamicIntroductionAdvice 这个接口来进行相应逻辑处理，又由于spring没有对 DynamicIntroductionAdvice 的关于MethodInterceptor的适配器，故此我们需要实现的其实是 IntroductionInterceptor 这个接口。DelegatingIntroductionInterceptor 和DelegatePerTargetObjectIntroductionInterceptor 就是接口IntroductionInterceptor的两个实现类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.28  DelegatingIntroductionInterceptor：接口IntroductionInterceptor的一个实现类，这个类就是一个委托引入拦截器，具体解释同上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;             &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AOP/support/annotation  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.29  AnnotationClassFilter：通过检查目标类是否存在指定的注解，决定是否匹配&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.30  AnnotationMatchingPointcut：注解匹配切点，JDK5以后，通过注解方式声明切点。根据类上或方法上是否存在指定的注解判断切点的匹配性，如果没有显示指定注解，则匹配所有。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.31  AnnotationMethodMatcher：注解匹配。寻找指定的Java 5的注解进行简单的方法匹配。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;9&lt;/strong&gt;&lt;strong&gt;、AOP/target   &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9.1  AbstractBeanFactoryBasedTargetSource：此类目标源基于IoC容器实现，也就是说target目标对象可以通过beanName从容器中获取。此类又扩展出：（1）SimpleBeanTargetSource：简单实现，直接调用getBean从容器获取目标对象；（2）LazyInitTargetSource：延迟初始化目标源，子类可重写postProcessTargetObject方法后置处理目标对象；（3）AbstractPrototypeBasedTargetSource：原型bean目标源，此抽象类可确保beanName对应的bean的scope属性为prototype。其子类做了简单原型、池化原型、线程隔离原型这3种实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9.2  SimpleBeanTargetSource：AbstractBeanFactoryBasedTargetSource简单实现，直接调用getBean从容器获取目标对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9.3  EmptyTargetSource：静态目标源，当不存在target目标对象，或者甚至连targetClass目标类都不存在（或未知）时，使用此类实例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9.4  HotSwappableTargetSource：动态目标源，支持热替换的目标源，支持spring应用运行时替换目标对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9.5  AbstractLazyCreationTargetSource：此类实现在调用getTarget()获取时才创建目标对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9.6  LazyInitTargetSource：延迟初始化目标源，子类可重写postProcessTargetObject方法后置处理目标对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9.7  SingletonTargetSource：该接口代表一个目标对象，在aop调用目标对象的时候，使用该接口返回真实的对象。Singleton表示每次调用返回同一个实例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9.8  AbstractPrototypeBasedTargetSource：原型bean目标源，此抽象类可确保beanName对应的bean的scope属性为prototype。其子类做了简单原型、池化原型、线程隔离原型这3种实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9.9  PrototypeTargetSource：该接口代表一个目标对象，在aop调用目标对象的时候，使用该接口返回真实的对象。Prototype表示每次调用返回每次调用返回一个新的实例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9.10  ThreadLocalTargetSource：将获取的bean存储在ThreadLocal ,它在releaseTarget的操作的时候不会从ThreadLocal中释放对应的target。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9.11  ThreadLocalTargetSourceStats：为ThreadLocal目标源做一些统计工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9.12  AbstractPoolingTargetSource：这个抽象类实现了PoolConfig，表示是池类的targetSource 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9.13  PoolingConfig：池类目标对象的配置接口。比如返回池子的最大容量，统计池子中活跃的对象数目，统计池子中空闲的对象数目。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9.14  CommonsPool2TargetSource：利用apache的ObjectPool来存储对应的target对象，它实现了PooledObjectFactory，这个池中的对象还是从beanFactory中获取。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AOP/target/dynamic  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9.15  Refreshable：会被动态目标对象实现的接口，支持通过重新载入，轮询进行刷新。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9.16  AbstractRefreshableTargetSource：可刷新的目标源。此类实现可根据配置的刷新延迟时间，在每次获取目标对象时自动刷新目标对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9.17  BeanFactoryRefreshableTargetSource：可刷新的目标源。其target bean是从bean工厂中获取的，每次刷新周期到来时都会自动进行刷新。其子类也可以重写方法requiresRefresh()，把一些不必要的刷新给取消掉。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、JDK动态代理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        Spring默认采取的动态代理机制实现AOP， 简单来说就是在程序运行期间动态的将某段代码切入到指定方法指定位置进行运行的编程方式。动态代理技术包括Java动态代理和CGLIB动态代理，前者基于接口实现，后者基于类实现。Spring默认采取的Java动态代理机制实现AOP。在介绍Spring AOP原理之前先介绍Java动态代理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（一）什么是代理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        编程中有个思想，不要随意的去修改别人已经写好的代码或者方法。但是如果我想在原有实现的基础上增加额外的功能呢，即对目标对象的功能进行拓展。比如在执行某个方法的时候记录下日志，这个时候就可以使用代理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        代理是一种常见的设计模式，其目的就是为目标对象提供一个代理对象以控制对目标对象的访问，即通过代理对象访问目标对象。其中代理对象是目标对象的拓展，并且会使用到目标对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        代理模式又分为静态代理和动态代理。静态代理简单来说就是代理类和目标类（委托类）实现同一个接口，然后代理类中引入对目标类对象的引用。&lt;strong&gt;目的&lt;/strong&gt;：这样可以实现一些其他功能，但是不会让目标类变得膨胀。&lt;strong&gt;缺点&lt;/strong&gt;：这样必须为目标对象创建一个实现了相同接口的代理对象，并且代理对象中的方法也要和目标对象保持一致。一旦目标对象改动了，代理对象也要变更相应的代码。这样就出现了大量的重复代码，增加了代码的维护复杂度。而且这种方法代理对象只能服务于一种类型的目标对象，如果要服务多个类型的对象，则需要为每一种对象都进行代理。&lt;strong&gt;举例&lt;/strong&gt;：比如我想在调用具体实现类前后打印日志等信息，在不修改已有代码的情况下，我们只需要增加一个代理类，在代理类中增加打印日志的功能，然后去调用目标类，这样就可以避免修改目标类。在创建代理对象时，通过构造器塞入一个目标对象，然后在代理对象的方法内部调用目标对象同名方法，并在调用前后打印日志。也就是说，代理对象=目标对象+增强代码，有了代理对象之后，就不用原对象了。但是如果想让多个目标类都添加打印日志功能，那么就需要增加多个代理类，代理类中各个方法都要增加打印日志功能，这就不堪负重了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        动态代理：上面我们知道静态代理每个代理类只能为一个接口服务，这样程序中就会出现很多代理类，动态代理可以通过一个代理类完成全部的代理功能。这个代理类是在运行时候动态生成的，是通过反射机制动态创建（反射机制是指在运行状态中，对于任意一个类，都能知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意属性和方法。）这样不需要为每一个接口写一个代理类，避免一个类对应一个代理的问题，大大提高了系统的灵活性，减少重复，降低了代码维护的复杂性和成本。Java动态代理机制以巧妙的方式实践了代理模式的设计理念。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        Java动态代理：Java的动态代理是基于接口的，代理类和目标类实现相同的接口，这样他们行为保持了一致性，在访问者看来两者没有丝毫的区别。通过代理类这中间一层，能有效的对委托类的对象的直接访问，可以很好的隐藏和保护委托对象，同时为实施不同的策略预留空间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（二）Java的动态代理类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        Java动态代理机制中有两个重要的接口和类：接口InvocationHandler()和类Proxy()，位于java.lang.reflect包中，这是实现动态代理的核心。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）接口InvocationHandler：动态代理类的调用处理程序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        InvocationHandler接口是proxy代理实例的调用处理程序实现的一个接口，该接口中仅定义了一个方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        public Object invoke(Object proxy, Method method, Object[] args)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        其中：第一个参数proxy表示执行这个方法的代理对象，method表示目标对象实际需要执行的方法，args表示目标对象实际要执行的方法所需要的参数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        每一个proxy代理实例都要有一个关联的调用处理程序，该调用处理程序都必须实现InvocationHandler接口。所以在实际编程中，需要先定义一个实现了InvocationHandler接口的调用处理器对象，然后将它作为创建代理类实例的参数（见Proxy类的newProxyInstance()方法）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）Proxy：动态代理类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        Proxy类就是用来创建一个代理对象的类，最常用的方法是static Object newProxyInstance(ClassLoaderloader, Class[] interfaces, InvocationHandler h)。这个方法的作用就是创建一个代理对象，其中三个参数为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        1、ClassLoader loader：指定当前目标对象使用类加载器，对于不同来源（系统库或网络等）的类需要不同的类加载器来加载，这是Java安全模型的一部分。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        2、Class[] interfaces：一个interface对象数组，目标对象实现的接口的类型。表示我们要给代理对象提供什么样的接口。如果我们提供了这样一个接口对象数组，那么也就是声明了代理类实现了这些接口，代理类就可以调用接口中声明的所有方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        3、InvocationHandler h：一个InvocationHandler调用处理程序对象，它必须是实现了InvocationHandler接口的对象，作用就是定义代理对象中需要执行的具体操作。当执行目标对象的方法时，会关联到一个InvocationHandler对象上，从而触发调用处理程序的方法，会把当前执行目标对象的方法作为参数传入，并最终调用h中的invoke()方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        其实动态代理类可以看做是这样一种类：它是在运行时生成的类，在生成它时你必须提供一组接口给它，然后该类就宣称它实现了这些接口。你当然可以把该类的实例当做这里接口中的任何一个来用。当然，这个动态代理类其实就是一个代理，它不会替你做实质性的工作，在生成它的实例时你必须提供一个handler，由它接管实际的工作。在实际使用代理类的时候，我们必须实现InvocationHandler接口。这样目标对象、需要控制的接口和控制方式都可以动态改变，从而实现灵活的动态代理关系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（三）动态代理的步骤&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、创建目标类（委托类）的接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里定义了两个接口，interface IBusiness1 和interface IBusiness2，各包含一个方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;interface IBusiness1：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.dynamicproxy;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IBusiness1 {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doSomeThing1() ;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;interface IBusiness2：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.dynamicproxy;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IBusiness2 {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doSomeThing2() ;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2、创建目标类（委托类）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;创建一个目标类Business，实现这两个接口。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.dynamicproxy;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Business &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IBusiness1, IBusiness2 {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doSomeThing1() { System.out.println(&quot;执行业务逻辑1&quot;&lt;span&gt;); }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doSomeThing2() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         System.out.println(&quot;执行业务逻辑2&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3、定义一个代理类的调用处理程序。该程序必须实现接口InvocationHandler，且必须实现接口的invoke方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;InvocationHandler接口是proxy代理实例的调用处理程序实现的一个接口，每一个proxy代理实例都有一个关联的调用处理程序；在代理实例调用方法时，方法调用被转发到调用处理程序的invoke方法。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.dynamicproxy;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.InvocationHandler;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LogInvocationHandler &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;目标对象&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object target;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造函数，给目标对象赋值&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    LogInvocationHandler(Object target) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; target;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;     * proxy:代理类
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;     * method:被代理的方法
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;     * args:该方法的参数数组
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在真实的对象执行之前添加自己的操作&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         System.out.println(&quot;日志: 方法&quot; + method.getName() + &quot;即将执行&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行原有逻辑&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         Object rev =&lt;span&gt; method.invoke(target, args);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在真实的对象执行之后添加自己的操作&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         System.out.println(&quot;日志: 方法&quot; + method.getName() + &quot;执行完毕&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; rev;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4、通过Proxy的静态方法newProxyInstance()创建一个代理对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Proxy类就是用来创建一个代理对象的类，它提供了很多方法，但是我们最常用的是newProxyInstance方法。这个方法的作用就是创建一个代理类对象。该方法有三个参数，三个参数具体解释见上述。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.dynamicproxy;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.InvocationHandler;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Proxy;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;要代理的目标对象&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         Business myBusiness = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Business();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;代理类要实现的接口列表&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         Class[] proxyInterface =&lt;span&gt; myBusiness.getClass().getInterfaces();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;代理对象的调用处理程序。我们将要代理的目标对象传入代理对象的调用处理的构造函数中，代理对象的调用处理程序最终会调用目标对象的方法&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         LogInvocationHandler handler = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LogInvocationHandler(myBusiness);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;         * 通过Proxy类的newProxyInstance方法创建代理对象
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;         * 第一个参数：handler.getClass().getClassLoader()，使用handler对象的classloader对象来加载我们的代理对象
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;         * 第二个参数：proxyInterface，这里为代理类提供的接口是目标对象实现的接口，这样代理对象就能像目标对象一样调用接口中的所有方法
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;         * 第三个参数：handler，我们将代理对象关联到上面的InvocationHandler对象上
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         IBusiness1 proxyBusiness =&lt;span&gt; (IBusiness1) Proxy.newProxyInstance(handler.getClass().getClassLoader(), proxyInterface, handler);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用代理类的实例来调用方法。&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        proxyBusiness.doSomeThing1();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        ((IBusiness2) proxyBusiness).doSomeThing2();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;5、通过代理对象调用委托类对象的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实Proxy类只是一个连接桥，把代理（InvocationHandler）与被代理类关联起来，真正处理事情的是InvocaHandler。InvocationHandler接口中的invoke方法在代理类中是动态实现的，当我们通过动态代理调用一个方法的时候，这个方法的调用会被转发到到调用处理程序的invoke方法中。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用代理类的实例来调用方法。&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;proxyBusiness.doSomeThing1();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; ((IBusiness2) proxyBusiness).doSomeThing2();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/HQcTnW5kSbvzNsyVbfk94UQkkVl5Alq4r9yibuS7TwWCqibOEdYcJbFXjX70Nv4ZlCIa4qXULdp8QvCehqcpymxg/640?wx_fmt=jpeg&quot; width=&quot;569&quot; height=&quot;193&quot; data-ratio=&quot;0.3391655450874832&quot; data-type=&quot;jpeg&quot; data-w=&quot;743&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;动态代理的优势就是可以很方便的对目标类的函数进行统一的处理，而不用修改每个目标类的方法。所有被代理执行的方法在调用执行的时候，其方法只是作为参数传入InvocationHandler中的invoke方法，实际是在invoke方法中处理的，这样通过在invoke方法中我们可以对所有被代理的方法进行相同的增强操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、Spring AOP的实现原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面Spring AOP实现流程图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/HQcTnW5kSbvzNsyVbfk94UQkkVl5Alq4lun3ibQibX3WLbCp2sOib8wK4bS5POmeTlwdpRgOQqlnTMsKgsYlXU8yQ/640?wx_fmt=jpeg&quot; data-ratio=&quot;0.6921202274573518&quot; data-type=&quot;jpeg&quot; data-w=&quot;1231&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（一）标签的解析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        首先我们来看下AOP常用的两种实现方式，一种是采用声明的方式来实现（基于XML），一种是采用注解的方式来实现（基于AspectJ）。下面举例说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方式一：xml方式配置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        第一步：创建被加强类&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.ytk.dao;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Repository;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;@Repository
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserDao {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sys() {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         System.out.println(&quot;userDao.....&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;        第二步：创建增强类&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.ytk.strong;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.ProceedingJoinPoint;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Project {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; before1() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         System.out.println(&quot;前置通知。。。。。。。。。&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;环绕通知&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; around(ProceedingJoinPoint point) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         System.out.println(&quot;环绕通知前。。。。。&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        point.proceed();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         System.out.println(&quot;环绕通知后。。。。。。&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; after1() {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         System.out.println(&quot;后置通知。。。。。。。。。&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;span&gt;第三步：配置切点和切面&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;!-- spring bean的配置 --&amp;gt;
&lt;span&gt; 2&lt;/span&gt;     &amp;lt;bean id=&quot;userDao&quot; &lt;span&gt;class&lt;/span&gt;=&quot;cn.ytk.dao.UserDao&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;span&gt; 3&lt;/span&gt;     &amp;lt;bean id=&quot;userService&quot; &lt;span&gt;class&lt;/span&gt;=&quot;cn.ytk.service.UserService&quot;&amp;gt;
&lt;span&gt; 4&lt;/span&gt;         &amp;lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&amp;gt;&amp;lt;/property&amp;gt;
&lt;span&gt; 5&lt;/span&gt;     &amp;lt;/bean&amp;gt;
&lt;span&gt; 6&lt;/span&gt;     &amp;lt;bean id=&quot;project&quot; &lt;span&gt;class&lt;/span&gt;=&quot;cn.ytk.strong.Project&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &amp;lt;aop:config&amp;gt;
&lt;span&gt; 9&lt;/span&gt;         &amp;lt;aop:pointcut expression=&quot;execution(* cn.ytk.dao.UserDao.*(..))&quot; id=&quot;pointcut1&quot;/&amp;gt;
&lt;span&gt;10&lt;/span&gt;         &amp;lt;aop:aspect ref=&quot;project&quot;&amp;gt;
&lt;span&gt;11&lt;/span&gt;             &amp;lt;aop:before method=&quot;before1&quot; pointcut-ref=&quot;pointcut1&quot;/&amp;gt;
&lt;span&gt;12&lt;/span&gt;             &amp;lt;aop:after-returning method=&quot;after1&quot; pointcut-ref=&quot;pointcut1&quot;/&amp;gt;
&lt;span&gt;13&lt;/span&gt;             &amp;lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;pointcut1&quot;/&amp;gt;
&lt;span&gt;14&lt;/span&gt;         &amp;lt;/aop:aspect&amp;gt;
&lt;span&gt;15&lt;/span&gt;     &amp;lt;/aop:config&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;方式二：通过Spring AOP注解实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        第一步：配置spring文件，开启aop注解&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;lt;!-- 开启aop的注解     --&amp;gt;
&lt;span&gt;2&lt;/span&gt;     &amp;lt;aop:aspectj-autoproxy/&amp;gt;
&lt;span&gt;3&lt;/span&gt;     &amp;lt;context:component-scan base-&lt;span&gt;package&lt;/span&gt;=&quot;cn.ytk.*&quot;&amp;gt;&amp;lt;/context:component-scan&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;        第二步：编写增强类&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.ytk.strong;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.ProceedingJoinPoint;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.annotation.AfterReturning;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.annotation.Aspect;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.annotation.Before;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.annotation.Pointcut;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;@Aspect
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Project2 {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;方式1：&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     @Before(value=&quot;execution(* cn.ytk.dao.UserDao.*(..))&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; before() {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         System.out.println(&quot;前置通知。。。。。。&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;方式2：先编写切点在将切点加到加强上。&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     @Pointcut(&quot;execution(* cn.ytk.dao.*.*(..))&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; after() {}
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     @AfterReturning(&quot;after()&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; after1() {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         System.out.println(&quot;....后置通知....&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从示例中看出，XML方式中使用AOP技术的需要做以下几步：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        1）开启AOP注解，&amp;lt;aop:aspectj-autoproxy/&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        2）定义切面类，使用@Aspect注解　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        3）在切面类上加设注解@Component&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 4）在切面类中定义切点方法，使用@PointCut注解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 5）在切面类中定义通知方法，使用@Before、@After、@Around等注解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 6）在通知方法的注解中使用切点方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        声明了自定义的注解，一定会在程序的某个地方注册对应的解析器。&amp;lt;aop:aspectj-autoproxy/&amp;gt;注解使用AspectJAutoProxyBeanDefinitionParser解析器进行解析。这个对应关系在AopNamespaceHandler（package org.springframework.aop.config）类中指定。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; In 2.0 XSD as well as in 2.1 XSD.&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;         registerBeanDefinitionParser(&quot;config&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigBeanDefinitionParser());
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         registerBeanDefinitionParser(&quot;aspectj-autoproxy&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AspectJAutoProxyBeanDefinitionParser());
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         registerBeanDefinitionDecorator(&quot;scoped-proxy&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ScopedProxyBeanDefinitionDecorator());
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Only in 2.0 XSD: moved to context namespace as of 2.1&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt;         registerBeanDefinitionParser(&quot;spring-configured&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SpringConfiguredBeanDefinitionParser());
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;接着来看下AspectJAutoProxyBeanDefinitionParser（package org.springframework.aop.config）解析器的代码。它是一个实现了BeanDefinitionParser接口的类，专门用于解析切面自动代理的Bean定义的解析工作，重点在其parse方法。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    @Nullable
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; BeanDefinition parse(Element element, ParserContext parserContext) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册AnnotationAwareAspectJAutoProxyCreator&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对注解中子类的处理&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;        extendBeanDefinition(element, parserContext);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其中调用了AopNamespaceUtils类（处理Spring AOP命名空间的工具类，package org.springframework.aop.config）的registerAspectJAnnotationAutoProxyCreatorIfNecessary函数。我们进入此函数看一下代码逻辑：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerAspectJAnnotationAutoProxyCreatorIfNecessary(
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;            ParserContext parserContext, Element sourceElement) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册或者升级AutoProxyCreator定义beanName为
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; org.Springframework.aop.config.internalAutoProxyCreator的BeanDefinition&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         BeanDefinition beanDefinition =&lt;span&gt; AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                parserContext.getRegistry(), parserContext.extractSource(sourceElement));
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对于proxy-target-class以及expose-proxy属性的处理&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册组件并通知，便于监听器进一步处理，其中BeanDefinition的className
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为AnnotationAwareAspectJAutoProxyCreator&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        registerComponentIfNecessary(beanDefinition, parserContext);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;上述代码一共三行代码，每行代码完成一件事情，都是一个完整的逻辑。&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第一行代码：&lt;/strong&gt;BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(                      parserContext.getRegistry(), parserContext.extractSource(sourceElement));&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        注册或者升级AnnotatonAwareAspectJAutoProxyCreator。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        我们进入AopConfigUtils类（package org.springframework.aop.config）的registerAspectJAnnotationAutoProxyCreatorIfNecessary函数看看：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;    @Nullable
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; BeanDefinition registerAspectJAnnotationAutoProxyCreatorIfNecessary(
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;            BeanDefinitionRegistry registry, @Nullable Object source) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, registry, source);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面这个函数又实际调用了本类中的registerOrEscalateApcAsRequired函数，我们继续查看该函数的实现逻辑：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;    @Nullable
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; BeanDefinition registerOrEscalateApcAsRequired(
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             Class&amp;lt;?&amp;gt;&lt;span&gt; cls, BeanDefinitionRegistry registry, @Nullable Object source) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;         Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果已经存在了自动代理创建器且存在的自动代理创建器与现在的不一致，
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 那么需要根据优先级判断到底使用哪个&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             BeanDefinition apcDefinition =&lt;span&gt; registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;cls.getName().equals(apcDefinition.getBeanClassName())) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; currentPriority =&lt;span&gt; findPriorityForClass(apcDefinition.getBeanClassName());
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; requiredPriority =&lt;span&gt; findPriorityForClass(cls);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (currentPriority &amp;lt;&lt;span&gt; requiredPriority) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;改变bean最重要的就是改变bean所对应的className属性&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                    apcDefinition.setBeanClassName(cls.getName());
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果已经存在自动代理创建器且与将要创建的一致，那么无需再次创建&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;         RootBeanDefinition beanDefinition = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RootBeanDefinition(cls);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        beanDefinition.setSource(source);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         beanDefinition.getPropertyValues().add(&quot;order&quot;&lt;span&gt;, Ordered.HIGHEST_PRECEDENCE);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; beanDefinition;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;        对于Aop的实现，基本都是靠AnnotatonAwareAspectJAutoProxyCreator去完成的，它可以根据@Point注解定义的切点来自动代理相匹配的bean。但是为了配置简便，Spring使用了自定义的配置帮助我们自动注册AnnotatonAwareAspectJAutoProxyCreator。其注册过程就是在上述函数中实现的。上述代码实现了自动注册AnnotatonAwareAspectJAutoProxyCreator类的功能，同时存在优先级问题，如果已经存在了自动代理创建器，而且存在的与现在的不一致，那么需要根据优先级判断到底使用哪个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二行代码：&lt;/strong&gt;useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        处理proxy-target-class和expose-proxy属性，进入该函数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; useClassProxyingIfNecessary(BeanDefinitionRegistry registry, @Nullable Element sourceElement) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (sourceElement != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对应proxy-target-class属性的处理&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;boolean&lt;/span&gt; proxyTargetClass =&lt;span&gt; Boolean.parseBoolean(sourceElement.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE));
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (proxyTargetClass) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对应expose-proxy属性的处理&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;boolean&lt;/span&gt; exposeProxy =&lt;span&gt; Boolean.parseBoolean(sourceElement.getAttribute(EXPOSE_PROXY_ATTRIBUTE));
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (exposeProxy) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;proxy-target-class和expose-proxy属性解释：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）proxy-target-class属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        Spring AOP使用JDK动态代理或者CGLIB来为目标对象创建代理。如果被代理的目标对象至少实现了一个接口，则使用JDK动态代理，所有该目标类型实现的接口都将被代理。如果该目标对象没有实现任何接口，则创建一个CGLIB代理。也可以强制使用CGLIB代理，强制使用CGLIB代理需要将&amp;lt;aop:config&amp;gt;的proxy-target-class属性设置为true：&lt;/span&gt;&lt;span&gt;&amp;lt;aop:config proxy-target-class=”true”&amp;gt;…&amp;lt;/aop:config&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        当需要使用CGLIB代理和@AspectJ自动代理支持，可以按照下面的方式设置&amp;lt;aop:aspectj-autoproxy&amp;gt;的proxy-target-class属性：&lt;/span&gt;&lt;span&gt;&amp;lt;aop:aspectj-autoproxy proxy-target-class=”true”&amp;gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）expose-proxy属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        Spring AOP无法拦截内部方法调用，比如一个接口里面有两个方法：doSomething1()和doSomething2()。然后在方法1中调用了方法2：this.doSomething2()。此处this指向目标对象，因此调用this.doSomething2()将不会执行doSomething2的增强。（也就是切面只会对doSomething1方法进行增强，但是不会对doSomething2进行增强）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        解决方法：this. doSomething2 ()修改为 ((AService) AopContext.currentProxy()).doSomething2 ()。同时修改Spring AOP的配置：&lt;/span&gt;&lt;span&gt;&amp;lt;aop:aspectj-autoproxy expose-proxy=&quot;true&quot; /&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第三行代码：&lt;/strong&gt;registerComponentIfNecessary(beanDefinition, parserContext);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        注册组件并通知，便于监听器进一步处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（二）获取增强方法或者增强器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        上面通过自定义配置完成了对AnnotatonAwareAspectJAutoProxyCreator（package org.springframework.aop.aspectj.annotation中）的自动注册。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        AnnotatonAwareAspectJAutoProxyCreator类：SpringBoot框架中默认支持的方式。spring aop 开启注解方式之后，该类会扫描所有@Aspect()注释的类，生成对应的advisor。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AnnotationAwareAspectJAutoProxyCreator的继承关系如下：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;       &lt;span&gt; AnnotationAwareAspectJAutoProxyCreator&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            --AspectJAwareAdvisorAutoProxyCreator&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                --AbstractAdvisorAutoProxyCreator&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                    --AbstractAutoProxyCreator&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                        -- ProxyProcessorSupport;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                           SmartInstantiationAwareBeanPostProcessor;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                           BeanFactoryAware;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        其中&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        ProxyProcessorSupport&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            --ProxyConfig;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;              Ordered;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;              BeanClassLoaderAware;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;              AopInfrastructureBean;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;        SmartInstantiationAwareBeanPostProcessor&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            --InstantiationAwareBeanPostProcessor&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                --BeanPostProcessor&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;        BeanFactoryAware&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            --Aware&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        AnnotatonAwareAspectJAutoProxyCreator间接实现了BeanPostProcessor接口，所以当Spring加载这个Bean的时候会在实例化之前调用postProcessAfterInitialization这个方法。一直往父类寻找，在其父类AbstractAutoProxyCreator（package org.springframework.aop.framework.autoproxy）实现了该方法。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object postProcessAfterInitialization(@Nullable Object bean, String beanName) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (bean != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据给定的bean的class和name构建出key，格式：beanClassName_beanName&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;             Object cacheKey =&lt;span&gt; getCacheKey(bean.getClass(), beanName);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.earlyProxyReferences.remove(cacheKey) !=&lt;span&gt; bean) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个非常核心的方法：wrapIfNecessary(),如果它适合被代理，则需要封装指定的bean。&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapIfNecessary(bean, beanName, cacheKey);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bean;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其有一个非常核心的方法：wrapIfNecessary()。继续进入该类中的wrapIfNecessary方法实现逻辑：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * Wrap the given bean if necessary, i.e. if it is eligible for being proxied.
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; bean the raw bean instance
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; beanName the name of the bean
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; cacheKey the cache key for metadata access
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; a proxy wrapping the bean, or the raw bean instance as-is
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果已经处理过&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (StringUtils.hasLength(beanName) &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.targetSourcedBeans.contains(beanName)) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bean;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个bean无需增强&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (Boolean.FALSE.equals(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advisedBeans.get(cacheKey))) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bean;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断给定的bean是否是一个基础设施类，基础设施类不应代理，或者配置了指定bean不需要代理。
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;所谓InfrastructureClass就是指Advice/PointCut/Advisor等接口的实现类。&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (isInfrastructureClass(bean.getClass()) ||&lt;span&gt; shouldSkip(bean.getClass(), beanName)) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advisedBeans.put(cacheKey, Boolean.FALSE);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bean;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果存在增强方法则创建代理
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取这个bean的advice&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果获取到了增强则需要针对增强创建代理&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (specificInterceptors !=&lt;span&gt; DO_NOT_PROXY) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advisedBeans.put(cacheKey, Boolean.TRUE);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建代理&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;             Object proxy =&lt;span&gt; createProxy(
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                     bean.getClass(), beanName, specificInterceptors, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SingletonTargetSource(bean));
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.proxyTypes.put(cacheKey, proxy.getClass());
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; proxy;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advisedBeans.put(cacheKey, Boolean.FALSE);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bean;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从上述代码中我们看到了代理创建的雏形。创建代理主要包含了两个步骤：1、获取增强方法或者增强器。2、根据获取的增强进行代理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面我们先来看下获取增强方法或者增强器：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        AbstractAutoProxyCreator类的wrapIfNecessary方法中调用了getAdvicesAndAdvisorsForBean，AbstractAutoProxyCreator类只对该方法进行定义，真正实现在其子类AbstractAdvisorAutoProxyCreator（package org.springframework.aop.framework.autoproxy）中实现。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Object[] getAdvicesAndAdvisorsForBean(
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;             Class&amp;lt;?&amp;gt;&lt;span&gt; beanClass, String beanName, @Nullable TargetSource targetSource) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt;         List&amp;lt;Advisor&amp;gt; advisors =&lt;span&gt; findEligibleAdvisors(beanClass, beanName);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (advisors.isEmpty()) {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DO_NOT_PROXY;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; advisors.toArray();
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面方法实现又调用了该类中的findEligibleAdvisors方法，进入其代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; List&amp;lt;Advisor&amp;gt; findEligibleAdvisors(Class&amp;lt;?&amp;gt;&lt;span&gt; beanClass, String beanName) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         List&amp;lt;Advisor&amp;gt; candidateAdvisors =&lt;span&gt; findCandidateAdvisors();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         List&amp;lt;Advisor&amp;gt; eligibleAdvisors =&lt;span&gt; findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;        extendAdvisors(eligibleAdvisors);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;eligibleAdvisors.isEmpty()) {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;             eligibleAdvisors =&lt;span&gt; sortAdvisors(eligibleAdvisors);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; eligibleAdvisors;
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;里面有两个函数findCandidateAdvisors和findAdvisorsThatCanApply。这两个方法就是来获取所有的增强以及寻找增强中适用于bean的增强并应用。&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;（1） findCandidateAdvisors方法（获取所有的增强）&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;   我们首先进入findCandidateAdvisors看下：&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; List&amp;lt;Advisor&amp;gt;&lt;span&gt; findCandidateAdvisors() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         Assert.state(&lt;span&gt;this&lt;/span&gt;.advisorRetrievalHelper != &lt;span&gt;null&lt;/span&gt;, &quot;No BeanFactoryAdvisorRetrievalHelper available&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advisorRetrievalHelper.findAdvisorBeans();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;        方法中调用了BeanFactoryAdvisorRetrievalHelper类（package org.springframework.aop.framework.autoproxy中）的findAdvisorBeans方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        BeanFactoryAdvisorRetrievalHelper这个类是一个Spring AOP内部工具类，用来从bean容器中获取所有Spring的Advisor bean（这里的 Spring Advisor bean指的是实现了接口org.springframework.aop.Advisor的bean）。是真正去容器中找出所有的Advisor的类。该工具内部使用了缓存机制，虽然公开的查找方法可能会被调用多次，但并不是每次都会真正查找，而是会利用缓存。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;Advisor&amp;gt;&lt;span&gt; findAdvisorBeans() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;cachedAdvisorBeanNames是advisor名称的缓存&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         String[] advisorNames = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.cachedAdvisorBeanNames;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果cachedAdvisorBeanNames为空，则到容器中查找，并设置缓存，后续直接使用缓存即可&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (advisorNames == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Do not initialize FactoryBeans here: We need to leave all regular beans
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; uninitialized to let the auto-proxy creator apply to them!
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从容器中查找Advisor类型的bean的名称&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             advisorNames =&lt;span&gt; BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                     &lt;span&gt;this&lt;/span&gt;.beanFactory, Advisor.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.cachedAdvisorBeanNames =&lt;span&gt; advisorNames;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (advisorNames.length == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         List&amp;lt;Advisor&amp;gt; advisors = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历advisorNames&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String name : advisorNames) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isEligibleBean(name)) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;忽略郑州创建中的advisor bean&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beanFactory.isCurrentlyInCreation(name)) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isTraceEnabled()) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                         logger.trace(&quot;Skipping currently created advisor '&quot; + name + &quot;'&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用getBean方法从容器中获取名称为name的bean，并将bean添加到advisors中&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;                         advisors.add(&lt;span&gt;this&lt;/span&gt;.beanFactory.getBean(name, Advisor.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                     &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (BeanCreationException ex) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                         Throwable rootCause =&lt;span&gt; ex.getMostSpecificCause();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (rootCause &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; BeanCurrentlyInCreationException) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                             BeanCreationException bce =&lt;span&gt; (BeanCreationException) rootCause;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                             String bceBeanName =&lt;span&gt; bce.getBeanName();
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt; (bceBeanName != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beanFactory.isCurrentlyInCreation(bceBeanName)) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isTraceEnabled()) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                                     logger.trace(&quot;Skipping advisor '&quot; + name +
&lt;span&gt;40&lt;/span&gt;                                             &quot;' with dependency on currently created bean: &quot; +&lt;span&gt; ex.getMessage());
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                                }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Ignore: indicates a reference back to the bean we're trying to advise.
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; We want to find advisors other than the currently created bean itself.&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;                                 &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                         &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; advisors;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;（2）findAdvisorsThatCanApply方法（寻找增强中适用于bean的增强并应用）&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;  我们首先进入findAdvisorsThatCanApply看下：&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; List&amp;lt;Advisor&amp;gt;&lt;span&gt; findAdvisorsThatCanApply(
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             List&amp;lt;Advisor&amp;gt; candidateAdvisors, Class&amp;lt;?&amp;gt;&lt;span&gt; beanClass, String beanName) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        ProxyCreationContext.setCurrentProxiedBeanName(beanName);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             ProxyCreationContext.setCurrentProxiedBeanName(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;  方法调用了AopUtils类（package org.springframework.aop.support中）的findAdvisorsThatCanApply方法。&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;Advisor&amp;gt; findAdvisorsThatCanApply(List&amp;lt;Advisor&amp;gt; candidateAdvisors, Class&amp;lt;?&amp;gt;&lt;span&gt; clazz) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (candidateAdvisors.isEmpty()) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; candidateAdvisors;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         List&amp;lt;Advisor&amp;gt; eligibleAdvisors = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Advisor candidate : candidateAdvisors) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;刷选IntroductionAdvisor引介类型的通知器&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (candidate &lt;span&gt;instanceof&lt;/span&gt; IntroductionAdvisor &amp;amp;&amp;amp;&lt;span&gt; canApply(candidate, clazz)) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                eligibleAdvisors.add(candidate);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; hasIntroductions = !&lt;span&gt;eligibleAdvisors.isEmpty();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Advisor candidate : candidateAdvisors) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (candidate &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; IntroductionAdvisor) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;引介增强已经处理&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;刷选普通类型的通知器&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (canApply(candidate, clazz, hasIntroductions)) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                eligibleAdvisors.add(candidate);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; eligibleAdvisors;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;该函数调用了该类中的canApply方法，该方法实现了重载，其代码如下：&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; canApply(Pointcut pc, Class&amp;lt;?&amp;gt; targetClass, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasIntroductions) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Assert.notNull(pc, &quot;Pointcut must not be null&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用 ClassFilter 匹配 class&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;pc.getClassFilter().matches(targetClass)) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         MethodMatcher methodMatcher =&lt;span&gt; pc.getMethodMatcher();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (methodMatcher ==&lt;span&gt; MethodMatcher.TRUE) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; No need to iterate the methods if we're matching any method anyway...&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         IntroductionAwareMethodMatcher introductionAwareMethodMatcher = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (methodMatcher &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; IntroductionAwareMethodMatcher) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             introductionAwareMethodMatcher =&lt;span&gt; (IntroductionAwareMethodMatcher) methodMatcher;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;         * 查找当前类及其父类（以及父类的父类等等）所实现的接口，由于接口中的方法是 public，
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;         * 所以当前类可以继承其父类，和父类的父类中所有的接口方法
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; classes = &lt;span&gt;new&lt;/span&gt; LinkedHashSet&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Proxy.isProxyClass(targetClass)) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            classes.add(ClassUtils.getUserClass(targetClass));
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass));
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (Class&amp;lt;?&amp;gt;&lt;span&gt; clazz : classes) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取当前类的方法列表，包括从父类中继承的方法&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;             Method[] methods =&lt;span&gt; ReflectionUtils.getAllDeclaredMethods(clazz);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Method method : methods) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用 methodMatcher 匹配方法，匹配成功即可立即返回&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (introductionAwareMethodMatcher != &lt;span&gt;null&lt;/span&gt; ?
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                        introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) :
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                        methodMatcher.matches(method, targetClass)) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; canApply(Advisor advisor, Class&amp;lt;?&amp;gt; targetClass, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasIntroductions) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (advisor &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; IntroductionAdvisor) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;             * 从通知器中获取类型过滤器 ClassFilter，并调用 matchers 方法进行匹配。
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;             * ClassFilter 接口的实现类 AspectJExpressionPointcut 为例，该类的
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;             * 匹配工作由 AspectJ 表达式解析器负责，具体匹配细节这个就没法分析了，我
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;             * AspectJ 表达式的工作流程不是很熟
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;              &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (advisor &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; PointcutAdvisor) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             PointcutAdvisor pca =&lt;span&gt; (PointcutAdvisor) advisor;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对于普通类型的通知器，这里继续调用重载方法进行筛选&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; canApply(pca.getPointcut(), targetClass, hasIntroductions);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; It doesn't have a pointcut so we assume it applies.&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;        以上是通知器筛选的过程，筛选的工作主要由 ClassFilter 和 MethodMatcher 完成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        所以获取增强器的主要流程：（1）获取所有bean名称；（2）遍历所有bean名称找出其中标记Aspect的bean；（3）解析并构造获取bean的所有增强器；（4）将解析到的增强器添加到缓存中；（5）过滤匹配出当前bean的增强器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（三）根据获取的增强创建代理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        我们再回到AbstractAutoProxyCreator类的wrapIfNecessary方法。从这个方法代码中我们看到了代理创建的雏形。创建代理主要包含了两个步骤：1、获取增强方法或者增强器。2、根据获取的增强进行代理。上面我们介绍了获取增强方法或者增强器，下面我们看下根据获取的增强进行代理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        wrapIfNecessary函数中创建代理用了调用了Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        我们进入AbstractAutoProxyCreator类中的createProxy函数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; Object createProxy(Class&amp;lt;?&amp;gt;&lt;span&gt; beanClass, @Nullable String beanName,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;            @Nullable Object[] specificInterceptors, TargetSource targetSource) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.beanFactory &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ConfigurableListableBeanFactory) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beanFactory, beanName, beanClass);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         ProxyFactory proxyFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProxyFactory();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前类中的相关属性&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         proxyFactory.copyFrom(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;proxyFactory.isProxyTargetClass()) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (shouldProxyTargetClass(beanClass, beanName)) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 proxyFactory.setProxyTargetClass(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                evaluateProxyInterfaces(beanClass, proxyFactory);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;         Advisor[] advisors =&lt;span&gt; buildAdvisors(beanName, specificInterceptors);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;加入增强器&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        proxyFactory.addAdvisors(advisors);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置要代理的类&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        proxyFactory.setTargetSource(targetSource);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定制代理&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        customizeProxyFactory(proxyFactory);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用来控制代理工厂被配置后，是否还允许修改通知
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;缺省值为false（即在被代理知乎，不允许修改代理的配置）&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;         proxyFactory.setFrozen(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.freezeProxy);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (advisorsPreFiltered()) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             proxyFactory.setPreFiltered(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最终调用的是 proxyFactory.getProxy()方法， proxyFactory 有 JDK 和 CGLib 的
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;继续进入aop/framework/ProxyFactory类中查看该函数&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; proxyFactory.getProxy(getProxyClassLoader());
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;此函数主要是对ProxyFactory的初始化操作，进而对真正的代理创建做准备。这些初始化操作包括：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;步骤1：获取当前类的属性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;步骤2：添加代理接口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;步骤3：拦截器封装转化为增强器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;步骤4：封装Advisor并加入到ProxyFactory中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;步骤5：设置要代理的类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;步骤6：在Spring中还为子类提供了定制函数customizeProxyFactory，子类可以在此函数中对ProxyFactory进一步封装。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;步骤7：设置是否需要冻结代理对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;步骤8：进行代理操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面我们重点先来看下步骤3、4、8.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        步骤3 ：Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        步骤4：proxyFactory.addAdvisors(advisors);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        步骤8： return proxyFactory.getProxy(getProxyClassLoader())&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（1）步骤3：将拦截器封装转化为增强器。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        首先要将拦截器封装转化为增强器，实现函数为buildAdvisors方法，在该类AbstractAutoProxyCreator中，代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Advisor[] buildAdvisors(@Nullable String beanName, @Nullable Object[] specificInterceptors) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解析注册所有的InterceptorNames&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         Advisor[] commonInterceptors =&lt;span&gt; resolveInterceptorNames();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;         List&amp;lt;Object&amp;gt; allInterceptors = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (specificInterceptors != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;加入拦截器&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            allInterceptors.addAll(Arrays.asList(specificInterceptors));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (commonInterceptors.length &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.applyCommonInterceptorsFirst) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     allInterceptors.addAll(0&lt;span&gt;, Arrays.asList(commonInterceptors));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                    allInterceptors.addAll(Arrays.asList(commonInterceptors));
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isTraceEnabled()) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; nrOfCommonInterceptors =&lt;span&gt; commonInterceptors.length;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; nrOfSpecificInterceptors = (specificInterceptors != &lt;span&gt;null&lt;/span&gt; ? specificInterceptors.length : 0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             logger.trace(&quot;Creating implicit proxy for bean '&quot; + beanName + &quot;' with &quot; + nrOfCommonInterceptors +
&lt;span&gt;22&lt;/span&gt;                     &quot; common interceptors and &quot; + nrOfSpecificInterceptors + &quot; specific interceptors&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;         Advisor[] advisors = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Advisor[allInterceptors.size()];
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; allInterceptors.size(); i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将拦截器进行封装转化成Advisor&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;             advisors[i] = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advisorAdapterRegistry.wrap(allInterceptors.get(i));
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; advisors;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;        上述方法调用了接口advisorAdapterRegistry的wrap方法，DefaultAdvisorAdapterRegistry类（package org.springframework.aop.framework.adapter）是接口advisorAdapterRegistry的默认实现，用来完成各种通知的适配和注册过程。将Advice包装成Advisor（DefaultPointCutAdvisor），借助AdvisorAdapter，将Advisor包装成MethodInterceptor。我们进入此类中的wrap方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Advisor wrap(Object adviceObject) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; UnknownAdviceTypeException {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果要封装的对象本身就是Advisor类型的，那么无需再做过多的处理&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (adviceObject &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Advisor) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (Advisor) adviceObject;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为此封装方法只对Advisor与Advice两种类型的数据有效，如果不是将不能封装&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!(adviceObject &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Advice)) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnknownAdviceTypeException(adviceObject);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         Advice advice =&lt;span&gt; (Advice) adviceObject;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (advice &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; MethodInterceptor) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是MethodInterceptor类型，则使用DefaultPointcutAdvisor封装&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultPointcutAdvisor(advice);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果存在Advisor的适配器，那么也同样需要进行封装&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (AdvisorAdapter adapter : &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.adapters) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Check that it is supported.&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (adapter.supportsAdvice(advice)) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultPointcutAdvisor(advice);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnknownAdviceTypeException(advice);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;（2）步骤4：将Advisor加入到ProxyFactory中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        将拦截器封装转化为增强器后，再通过ProxyFactory提供的addAdvisor方法将增强器置入创建工厂中。AbstractAutoProxyCreator.createProxy函数中直接调用了proxyFactory.addAdvisor (advisors)。proxyFactory继承自ProxyCreatorSupport，ProxyCreatorSupport继承自AdvisedSupport。addAdvisor这个方法实际在AdvisedSupport类（package org.springframework.aop.framework）中给出。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; addAdvisor(&lt;span&gt;int&lt;/span&gt; pos, Advisor advisor) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; AopConfigException {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (advisor &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; IntroductionAdvisor) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;            validateIntroductionAdvisor((IntroductionAdvisor) advisor);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        addAdvisorInternal(pos, advisor);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;（3）步骤8：进行获取代理操作。&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;       我们再回到AbstractAutoProxyCreator.createProxy方法。最后一句代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object getProxy() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用了ProxyCreatorSupport的createAopProxy()方法创建一个AopProxy对象
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 然后调用AopProxy对象的getProxy方法&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; createAopProxy().getProxy();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;        进行解析最重要的一步就是代理类的创建和处理，Spring委托给了ProxyFactory去处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        我们进入ProxyFactory类（package org.springframework.aop.framework）中的getProxy函数。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; AopProxy createAopProxy() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.active) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;            activate();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实际就是使用DefaultAopProxyFactory来创建一个代理对象
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可以看到在调用createAopProxy方法时，传入的参数是this
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这是因为ProxyCreatorSupport本身就保存了创建整个代理对象所需要的配置信息&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; getAopProxyFactory().createAopProxy(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其中就一句话return createAopProxy().getProxy();。createAopProxy 方法没有在ProxyFactory类中定义，createAopProxy方法在其父类ProxyCreatorSupport（package org.springframework.aop.framework）中定义了，进入其代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; AopProxy createAopProxy() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.active) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;            activate();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实际就是使用DefaultAopProxyFactory来创建一个代理对象
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可以看到在调用createAopProxy方法时，传入的参数是this
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这是因为ProxyCreatorSupport本身就保存了创建整个代理对象所需要的配置信息&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; getAopProxyFactory().createAopProxy(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;        核心就一句代码return getAopProxyFactory().createAopProxy(this)。实际用的是AopProxyFactory类的createAopProxy方法。AopProxyFactory只是一个接口，DefaultAopProxyFactory是AopProxyFactory默认实现类，核心函数createAopProxy。所以其实是调用了DefaultAopProxyFactory类的createAopProxy方法。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 就是通过AOP相关的配置信息来决定到底是使用cglib代理还是jdk代理&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; AopProxy createAopProxy(AdvisedSupport config) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; AopConfigException {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果开启了优化，或者ProxyTargetClass设置为true
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 或者没有提供代理类需要实现的接口，那么使用cglib代理
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在前面分析参数的时候已经说过了
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认情况下Optimize都为false,也不建议设置为true,因为会进行一些侵入性的优化
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 除非你对cglib的优化非常了解，否则不建议开启&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (config.isOptimize() || config.isProxyTargetClass() ||&lt;span&gt; hasNoUserSuppliedProxyInterfaces(config)) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             Class&amp;lt;?&amp;gt; targetClass =&lt;span&gt; config.getTargetClass();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (targetClass == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; AopConfigException(&quot;TargetSource cannot determine target class: &quot; +
&lt;span&gt;13&lt;/span&gt;                         &quot;Either an interface or a target is required for proxy creation.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要注意的是，如果需要代理的类本身就是一个接口
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 或者需要被代理的类本身就是一个通过jdk动态代理生成的类
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 那么不管如何设置都会使用jdk动态代理&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (targetClass.isInterface() ||&lt;span&gt; Proxy.isProxyClass(targetClass)) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JdkDynamicAopProxy(config);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjenesisCglibAopProxy(config);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 否则都是jdk代理&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JdkDynamicAopProxy(config);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;至此完成了代理的创建。&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（四）织入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Spring主要使用JDK动态代理，所以先回顾性JDK动态代理的原理（详见上一节JDK动态代理）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Java动态代理机制中有两个重要的接口和类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        （1）接口InvocationHandler：动态代理类的调用处理程序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        （2）Proxy：动态代理类，Proxy类就是用来创建一个代理对象的类，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Java动态代理的步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        1、创建目标类（委托类）的接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        2、创建目标类（委托类）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        3、定义一个代理类的调用处理程序。该程序必须实现接口InvocationHandler，且必须实现接口的invoke方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        4、通过Proxy的静态方法newProxyInstance()创建一个代理对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        5、通过代理对象调用委托类对象的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        其实Proxy类只是一个连接桥，把代理（InvocationHandler）与被代理类关联起来，真正处理事情的是InvocaHandler。InvocationHandler接口中的invoke方法在代理类中是动态实现的，当我们通过动态代理调用一个方法的时候，这个方法的调用会被转发到到调用处理程序的invoke方法中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        Spring的AOP实现也是用了Proxy和InvocationHandler这两个东西。JDK代理中InvocationHandler的创建是最为核心的。在自定义的InvocationHandler中需要重写3个函数。（1）构造函数，将代理的对象传入。（2）invoke方法，此方法中实现了AOP增强的所有逻辑。（3）getProxy方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        我们进入JdkDynamicAopProxy类（package org.springframework.aop.framework）。这个类就是用来生成jdk动态代理。可以看到这个类本身就是一个InvocationHandler，这意味着当调用代理对象中的方法时，最终会调用到JdkDynamicAopProxy的invoke方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        重点看其getProxy函数和invoke函数。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object getProxy(@Nullable ClassLoader classLoader) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isTraceEnabled()) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             logger.trace(&quot;Creating JDK dynamic proxy: &quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advised.getTargetSource());
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里获取到代理类需要实现的所有的接口&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         Class&amp;lt;?&amp;gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(&lt;span&gt;this&lt;/span&gt;.advised, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要明确是否在接口定义了hashCode以及equals方法
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果接口中没有定义，那么在调用代理对象的equals方法的时候
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果两个对象相等，那么意味着它们的目标对象，通知以及实现的接口都相同&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; Proxy.newProxyInstance(classLoader, proxiedInterfaces, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;        JDKProxy的使用关键是创建自定义的InvocationHandler，InvocationHandler中包含了需要覆盖的getProxy，上述方法就是完成了这个操作。JdkDynamicAopProxy实现了接口AopProxy、InvocationHandler和Serializable。InvocationHandler除了getProxy还有invoke函数，JdkDynamicAopProxy类将其核心逻辑写在了这个方法中。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;     * Implementation of {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; InvocationHandler.invoke}.
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;     * &amp;lt;p&amp;gt;Callers will see exactly the exception thrown by the target,
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;     * unless a hook method throws an exception.
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;    @Nullable
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;         Object oldProxy = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; setProxyContext = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; 
&lt;span&gt; 12&lt;/span&gt;         TargetSource targetSource = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advised.targetSource;
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;         Object target = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; 
&lt;span&gt; 15&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 首先处理的是hashCode跟equals方法，如果接口中没有定义这两个方法，那么会调用本类中定义的equals方法
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; equals方法的处理。只有当两个类的目标对象，通知以及实现的接口都相等的情况下equals才会返回true&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.equalsDefined &amp;amp;&amp;amp;&lt;span&gt; AopUtils.isEqualsMethod(method)) {
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The target does not implement the equals(Object) method itself.&lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; equals(args[0&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;hash方法的处理&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.hashCodeDefined &amp;amp;&amp;amp;&lt;span&gt; AopUtils.isHashCodeMethod(method)) {
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The target does not implement the hashCode() method itself.&lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; hashCode();
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 也就是说我们调用的是DecoratingProxy这个接口中的方法
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个接口中只定义了一个getDecoratedClass方法，用于获取到
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最终的目标对象，在方法实现中会通过一个while循环来不断接近
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最终的目标对象，直到得到的目标对象不是一个被代理的对象才会返回&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (method.getDeclaringClass() == DecoratingProxy.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; There is only getDecoratedClass() declared -&amp;gt; dispatch to proxy config.&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; AopProxyUtils.ultimateTargetClass(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advised);
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 说明调用的是Advised接口中的方法，这里只是单纯的进行反射调用&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.advised.opaque &amp;amp;&amp;amp; method.getDeclaringClass().isInterface() &amp;amp;&amp;amp;
&lt;span&gt; 37&lt;/span&gt;                     method.getDeclaringClass().isAssignableFrom(Advised.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Service invocations on ProxyConfig with the proxy config...&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; AopUtils.invokeJoinpointUsingReflection(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advised, method, args);
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; 
&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;            Object retVal;
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; 
&lt;span&gt; 44&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;有时候目标对象内部的自我调用将无法实施切面中的增强则需要通过此属性暴露代理
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将代理类暴露到线程上下文中，调用AopContext.setCurrentProxy方法将其放入到一个threadLocal中&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advised.exposeProxy) {
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Make invocation available if necessary.&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt;                 oldProxy =&lt;span&gt; AopContext.setCurrentProxy(proxy);
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;                 setProxyContext = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; 
&lt;span&gt; 52&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 接下来就是真正的执行代理逻辑了&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt;             target =&lt;span&gt; targetSource.getTarget();
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;             Class&amp;lt;?&amp;gt; targetClass = (target != &lt;span&gt;null&lt;/span&gt; ? target.getClass() : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; 
&lt;span&gt; 56&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取当前方法的拦截器链&lt;/span&gt;
&lt;span&gt; 57&lt;/span&gt;             List&amp;lt;Object&amp;gt; chain = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (chain.isEmpty()) {
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果没有发现任何拦截器链那么直接调用切点方法&lt;/span&gt;
&lt;span&gt; 61&lt;/span&gt;                 Object[] argsToUse =&lt;span&gt; AopProxyUtils.adaptArgumentsIfNecessary(method, args);
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;                 retVal =&lt;span&gt; AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 否则开始执行整个链条&lt;/span&gt;
&lt;span&gt; 65&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将拦截器封装在ReflectiveMethodInvocation以便于使用期proceed进行链接表用拦截器&lt;/span&gt;
&lt;span&gt; 67&lt;/span&gt;                 MethodInvocation invocation =
&lt;span&gt; 68&lt;/span&gt;                         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行拦截器链&lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt;                 retVal =&lt;span&gt; invocation.proceed();
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Massage return value if necessary.
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里是处理一种特殊情况，就是当执行的方法返回值为this的情况
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这种情况下，需要返回当前的代理对象而不是目标对象&lt;/span&gt;
&lt;span&gt; 76&lt;/span&gt;             Class&amp;lt;?&amp;gt; returnType =&lt;span&gt; method.getReturnType();
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (retVal != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; retVal == target &amp;amp;&amp;amp;
&lt;span&gt; 78&lt;/span&gt;                     returnType != Object.&lt;span&gt;class&lt;/span&gt; &amp;amp;&amp;amp; returnType.isInstance(proxy) &amp;amp;&amp;amp;
&lt;span&gt; 79&lt;/span&gt;                     !RawTargetAccess.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(method.getDeclaringClass())) {
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Special case: it returned &quot;this&quot; and the return type of the method
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; is type-compatible. Note that we can't help if the target sets
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; a reference to itself in another returned object.&lt;/span&gt;
&lt;span&gt; 83&lt;/span&gt;                 retVal =&lt;span&gt; proxy;
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (retVal == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; returnType != Void.TYPE &amp;amp;&amp;amp;&lt;span&gt; returnType.isPrimitive()) {
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AopInvocationException(
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;                         &quot;Null return value from advice does not match primitive return type for: &quot; +&lt;span&gt; method);
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; retVal;
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;         &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (target != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;targetSource.isStatic()) {
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Must have come from TargetSource.&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;                targetSource.releaseTarget(target);
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (setProxyContext) {
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Restore old proxy.&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;                AopContext.setCurrentProxy(oldProxy);
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;        上面的函数最主要的工作是创建了一个拦截器链，并使用ReflectiveMethodInvocation类进行了链的封装，而在ReflectiveMethodInvocation类的proceed方法中实现了拦截器的逐一调用。我们继续看proceed方法是怎么实现前置增强在目标方法前调用，后置增强在目标方法后调用的逻辑。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        ReflectiveMethodInvocation（package org.springframework.aop.framework包中）是一个核心类，激发拦截链工作实现。该类实现了aop联盟的MethodInvocation，间接实现了Invocation和Joinpoint。我们进入其proceed函数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    @Nullable
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object proceed() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; We start with an index of -1 and increment early.
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行完所有增强后执行切点方法&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.currentInterceptorIndex == &lt;span&gt;this&lt;/span&gt;.interceptorsAndDynamicMethodMatchers.size() - 1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; invokeJoinpoint();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取下一个要执行的拦截器&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         Object interceptorOrInterceptionAdvice =
&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;.interceptorsAndDynamicMethodMatchers.get(++&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.currentInterceptorIndex);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (interceptorOrInterceptionAdvice &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; InterceptorAndDynamicMethodMatcher) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Evaluate dynamic method matcher here: static part will already have
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; been evaluated and found to match.
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;动态匹配&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             InterceptorAndDynamicMethodMatcher dm =
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                    (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             Class&amp;lt;?&amp;gt; targetClass = (&lt;span&gt;this&lt;/span&gt;.targetClass != &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;this&lt;/span&gt;.targetClass : &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.method.getDeclaringClass());
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (dm.methodMatcher.matches(&lt;span&gt;this&lt;/span&gt;.method, targetClass, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.arguments)) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; dm.interceptor.invoke(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Dynamic matching failed.
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Skip this interceptor and invoke the next in the chain.
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不匹配就不执行拦截器&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; proceed();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; It's an interceptor, so we just invoke it: The pointcut will have
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; been evaluated statically before this object was constructed.
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;普通拦截器，直接调用拦截器。将this作为参赛传入以保障当前实例中调用链的执行。&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;        在proceed方法中，ReflectiveMethodInvocation的主要职责是维护了调用的计数器，记录着当前调用链接的位置，以便可以有序的进行下去。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        本文参考了 郝佳《Spring源码深度解析》第七章AOP及博客园、CSDN部分文献。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;博众家之所长，集群英之荟萃。遴选各IT领域精品雄文！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;欢迎关注“IT架构精选”&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/HQcTnW5kSbst806Nn4L1A3dzplLRpwa86NicxWDQu2825TiaKdhCic1ZkTsSnUM50dVKZU7r4IOmqNsm2ibKkZYJQA/640?wx_fmt=jpeg&quot; title=&quot;qrcode_for_gh_658c796de85f_258.jpg&quot; border=&quot;0&quot; data-backh=&quot;167.5&quot; data-backw=&quot;167.5&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;166&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;166&quot; data-ratio=&quot;1&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; data-width=&quot;100%&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 07 Dec 2020 00:40:00 +0000</pubDate>
<dc:creator>tageerxing</dc:creator>
<og:description>Spring框架之AOP源码完全解析 Spring可以说是Java企业开发里最重要的技术。Spring两大核心IOC（Inversion of Control控制反转）和AOP（Aspect Orie</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xxkj/p/14094203.html</dc:identifier>
</item>
<item>
<title>无所不能的Embedding5 - skip-thought的兄弟们[Trim/CNN-LSTM/quick-thought] - 风雨中的小七</title>
<link>http://www.cnblogs.com/gogoSandy/p/14094590.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gogoSandy/p/14094590.html</guid>
<description>&lt;p&gt;这一章我们来聊聊skip-thought的三兄弟，它们在解决skip-thought遗留问题上做出了不同的尝试【Ref1～4】, 以下paper可能没有给出最优的解决方案(对不同的NLP任务其实没有最优只有最合适）但它们提供了另一种思路和可能性。上一章的skip-thought有以下几个值得进一步探讨的点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Q1 RNN计算效率低：Encoder-Decoder都是用的RNN, RNN这种依赖上一步输出的计算方式天然和并行计算互斥, 所以训练那叫一个慢&lt;/li&gt;
&lt;li&gt;Q2 Decoder：作为最后预测时完全用不到的组件，Decoder在训练时占用了大量时间，能否优化?&lt;/li&gt;
&lt;li&gt;Q3 通用文本向量的样本构建：skip-thought只预测前/后一个句子合理么？&lt;/li&gt;
&lt;li&gt;Q4 两个decoder的神奇设计有道理么?&lt;/li&gt;
&lt;li&gt;Q5 pretrain word embedding考虑一下?&lt;/li&gt;
&lt;li&gt;Q6 除了hidden_state还有别的提取句子向量的方式么？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以下按照文章让人眼前一亮的程度从小到大排序&lt;/p&gt;
&lt;h2 id=&quot;trimrethink-skip-thought&quot;&gt;Trim/Rethink skip-thought&lt;/h2&gt;
&lt;p&gt;【Ref1/2】是同一个作者的a/b篇对skip-thought模型的一些细节进行调整，并在benchmark里拿到了和skip-thought不相上下的结果。主要针对以上Q4，Q5，Q6&lt;/p&gt;
&lt;p&gt;作者认为两个decorder的设计没啥必要，基于中间句子的信息,前后句子可以用相同的decoder进行reconstruct。这个假设感觉对翻译类的语言模型不太能接受，不过放在训练通用文本向量的背景下似乎是可以接受的，因为我们希望encoder部分能尽可能提取最大信息并能够在任意上下文语境中泛化，所以简化Decoder更合适。&lt;/p&gt;
&lt;p&gt;作者对比了用Glove，word2vec来初始化词向量，结果显示在Evaluation上会比随机初始化表现更好。感觉用预训练词向量初始化的好处有两个，一个是加速收敛，另一个是在做vocabulary expansion时，linear-mapping可能会更准确，用预训练词向量来初始化已经是比较通用的解决方案了。&lt;/p&gt;
&lt;p&gt;针对Q6，原始的skip-thought最终输出的文本向量就是Encoder最后一个hidden_state，那我们有没有可能去利用到整个sequence的hiddden state输出呢? 作者提出可以借鉴avg+max pooling, 对Encoder部分所有hidden state做avg, max pooling然后进行拼接作为 输出的文本向量=&lt;span class=&quot;math inline&quot;&gt;\([\frac{\sum_{i=1}^T h_i}{T} , max_{i=1}^T h_i]\)&lt;/span&gt;。这种方案的假设其实不是把embedding作为一个整体来看，而是把embedding的每一个unit单独作为一个/类特征来看，序列不同位置的output state可能提取了不同的信息，通过avg/max来抽取最有代表性的特征作为句子特征。这个问题我们之后还会多次碰到，语言模型训练好了拿什么做句子向量更合适呢？这里留个伏笔吧&lt;/p&gt;
&lt;p&gt;所以感觉自己实现的其实是Trimed skip-thought, 我用的word2vec来初始化，只用了1个decoder来训练pair样本。。。感兴趣的望过来 &lt;a href=&quot;https://github.com/DSXiangLi/Embedding/tree/master/skip_thought&quot;&gt;Github-Embedding-skip_thought&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Trim算是对skip-thought进行了瘦身，想要提速？看下面👇&lt;/p&gt;
&lt;h2 id=&quot;cnn-lstm&quot;&gt;CNN-LSTM&lt;/h2&gt;
&lt;p&gt;【Ref3】对Q1给出的解决方案是用CNN来替代RNN作为提取句子信息的Encoder, 这样就可以解决RNN计算无法并行的问题。具体实现就需要解决两个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如何把不定长的sequence压缩到相同长度&lt;/li&gt;
&lt;li&gt;CNN如何抽取序列特征&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1326688/202012/1326688-20201206215558630-553917244.png&quot; width=&quot;500&quot; height=&quot;200&quot;/&gt;&lt;/p&gt;

&lt;p&gt;模型结构如上，这里sequence的token经过embedding之后作为输入, 假定sequence的padding length相同都是N，embedding的维度都是K, 输入就是N * K。按1维图像来理解，这里N是图像长度，K是图像channel。&lt;/p&gt;
&lt;p&gt;作者定义了3种不同kernel_size=3/4/5的cnn cell，其实和n-gram的原理近似就是分别学习局部window_size=3/4/5的三种序列信息，因为cnn是共享参数的所以1个filter只能提取1种token组合的序列特征，所以每个cnn cell都有800个filter。以kernel_size=3为例，cnn的权重向量维度是3&lt;em&gt;K&lt;/em&gt;800, 和sequence embedding 进行计算后的输出是（N-3+1）* 800。&lt;/p&gt;
&lt;p&gt;为了压缩到相同长度，在以上输出后加入了max_pooling层（多数cnn用于NLP的任中max据说都比avg要好），沿sequence维度进行pooling把以上输出压缩到1* 800，简单理解就是每个filter在该sequence上只保留最显著的1个特征。3个不同kernel_size的输出拼接就得到了hidden_size=2400的向量。这也是最终得到的文本对应的向量表达。&lt;/p&gt;
&lt;p&gt;考虑只有encoder差别比较大，索性把CNN-LSTM和上一章的skip-thought放一块了，只对encoder/decoder的cell选择做了区分。这里只给出CNN Encodere的实现，bridge的部分是参考了google的seq2seq，完整代码看这里&lt;a href=&quot;https://github.com/DSXiangLi/Embedding/tree/master/skip_thought&quot;&gt;Github-Embedding-skip_thought&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def cnn_encoder(input_emb, input_len, params):
    # batch_szie * seq_len * emb_size -&amp;gt; batch_size * (seq_len-kernel_size + 1) * filters
    outputs = []
    params = params['encoder_cell_params']
    for i in range(len(params['filters'])):
        output = tf.layers.conv1d(inputs = input_emb,
                                  filters = params['filters'][i],
                                  kernel_size = params['kernel_size'][i], # window size, simlar as n-gram
                                  strides = params['strides'][i],
                                  padding = params['padding'][i]
                                )
        output = params['activation'][i](output)
        # batch_size * (seq_len-kernel_size + 1) * filters -&amp;gt; batch_size * filters
        outputs.append(tf.reduce_max(output, axis=1))
    # batch_size * sum(filters)
    output = tf.concat(outputs, axis=1)
    return ENCODER_OUTPUT(output=output, state=(output,))
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;感觉这里压缩到相同长度也可以用Padding，以及cnn学习不同长度的文本信息，作者用的是不同kernel size做拼接，也可以尝试stack cnn，这样两个kernel=3的cnn就能学到长度为9的文本序列信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Decoder这里作者使用了LSTM，不过就像之前在skip-thought中提到的，因为有teacher forcing感觉decoder并不十分重要这里就不提了。&lt;/p&gt;
&lt;p&gt;论文还有一个比较有意思的点就Q3，作者对skip-thought的核心假设发出了灵魂提问：为啥中间句子的信息=用于reconstruct前后句子的信息？ （其实上面Trim的论文中中也做了类似的尝试这里和在一起说）&lt;/p&gt;
&lt;p&gt;作者给出了几个方案&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;中间句子reconstruct中间句子的autoencoder任务&lt;/li&gt;
&lt;li&gt;中间句子reconstruct中间句子，以及前/后1个句子的composite任务&lt;/li&gt;
&lt;li&gt;放大时间窗口，用中间句子预测之后好几个句子的hierarchical任务&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;感觉autoencoder更多捕捉intra-sentence的syntax信息，比如语法/句式结构，而前后句子的reconstruct任务学习inter-sentence的semantic信息，例如上下文语境。所以是不是也可以理解为，autoencoder训练得到文本向量的相似可能会长得相似，而前后句子训练得到的文本向量的相似会更多存在语义/上下文语境的相似。&lt;/p&gt;
&lt;p&gt;抛去直觉唯指标论的话，在Trim论文里加入AE的模型只在question-type的分类任务（more syntax)上有提升，对其他例如movie-review等semantic classification任务都有损失。但在CNN的论文里只用AE/加入AE的模型在所有分类任务上表现都更好，我也是有些迷惑。。。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;那究竟什么训练样本可以训练得到通用的文本向量？这里的通用是指在任意downstream任务里都能拿到不错的效果。这里留个疑问吧，看后面USE等基于多任务联合学习的尝试能不能解答这个问题～&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;quick-thought&quot;&gt;Quick-thought&lt;/h2&gt;
&lt;p&gt;【Ref4】终于跳出了翻译类语言模型的框框，对Q2给出了新的解决方案。既然对于文本向量表达来说Decoder又慢又没用，那咱索性不要了，直接把reconstruct任务替换为分类任务。之后这个思路也在BERT预训练中作为NSP训练任务直接使用。&lt;/p&gt;
&lt;p&gt;这里分类任务的思路和word2vec中使用的negative sampling来训练词向量可以说是同样的配方熟悉的味道, 都涉及到正负样本的构建，对于word2vec的skip-gram来说正样本就是window_size内的单词，负样本从词典中随机采样得到。这里Quick-thought和skip-thought保持一致，正样本是window_size内的句子，也就是用中间句子来预测前后句子,负样本则是batch里面除了前后句子之外的其他句子。&lt;/p&gt;
&lt;p&gt;既然提到正负样本，那skip-thought的正负样本是什么呢？ 考虑到teacher-forcing的使用，skip-thought是基于中间句子和前后句子T-1的单词来预测第T个单词是什么，负样本就是除了第T个单词外vocabulary里面的其他单词（和skip-gram一毛一样）。所以作者也在论文中提到这种reconstruct任务可能会学到过于表面的文本信息而难以学到更general的语义信息。而分类任务这种只需要上下文句子整体比其他句子更相似的训练框架不会存在这个问题。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1326688/202012/1326688-20201206215617831-2143696007.png&quot; width=&quot;500&quot; height=&quot;200&quot;/&gt;&lt;/p&gt;

&lt;p&gt;模型结构如上，Encoder部分用任意方式提取信息，可以是skip-thogut里面使用的gru,也可以用上面的CNN。这里和skip-gram一样用两套独立参数的encoder分别对input和target来进行信息提取得到两个定长的output state。为了保证最大化state学到的文本信息，分类器这里采取了最简单的操作，就是两个state直接做向量内积，然后内积直接做binary classification。&lt;/p&gt;
&lt;p&gt;在预测的时候用两个encoder分别对输入句子进行信息提取，然后把得到的state进行拼接作为模型提取的文本向量&lt;/p&gt;
&lt;p&gt;懒得挪地就把quick thought也和skip thought也放在一起了，反正Encoder部分是可以共享的, 完整代码看这里&lt;a href=&quot;https://github.com/DSXiangLi/Embedding/tree/master/skip_thought&quot;&gt;Github-Embedding-skip_thought&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class EncoderBase(object):
    def __init__(self, params):
        self.params = params
        self.init()

    def init(self):
        with tf.variable_scope('embedding', reuse=tf.AUTO_REUSE):
            self.embedding = tf.get_variable(dtype = self.params['dtype'],
                                             initializer=tf.constant(self.params['pretrain_embedding']),
                                             name='word_embedding' )

            add_layer_summary(self.embedding.name, self.embedding)

    def general_encoder(self, features):
        encoder = ENCODER_FAMILY[self.params['encoder_type']]

        seq_emb_input = tf.nn.embedding_lookup(self.embedding, features['tokens']) # batch_size * max_len * emb_size

        encoder_output = encoder(seq_emb_input, features['seq_len'], self.params) # batch_size

        return encoder_output

    def vectorize(self, state_list, features):
        with tf.variable_scope('inference'):
            result={}
            # copy through input for checking
            result['input_tokenid']=tf.identity(features['tokens'], name='input_id')
            token_table = tf.get_collection('token_table')[0]
            result['input_token']= tf.identity(token_table.lookup(features['tokens']), name='input_token')

            result['encoder_state'] = tf.concat(state_list, axis = 1, name ='sentence_vector')

        return result
        
        
class QuickThought(EncoderBase):
    def __init__(self, params):
        super(QuickThought, self).__init__(params)

    def build_model(self, features, labels, mode):
        input_encode = self.input_encode(features)

        output_encode = self.output_encode(features, labels, mode)

        sim_score = tf.matmul(input_encode.state[0], output_encode.state[0], transpose_b=True) # [batch, batch] sim score
        add_layer_summary('sim_score', sim_score)

        loss = self.compute_loss(sim_score)

    def input_encode(self, features):
        with tf.variable_scope('input_encoding', reuse=False):
            encoder_output = self.general_encoder(features)

            add_layer_summary('state', encoder_output.state)
            add_layer_summary('output', encoder_output.output)
        return encoder_output

    def output_encode(self, features, labels, mode):
        with tf.variable_scope('output_encoding', reuse=False):
            if mode == tf.estimator.ModeKeys.PREDICT:
                encoder_output = self.general_encoder(features)
            else:
                encoder_output=self.general_encoder(labels)

            add_layer_summary('state', encoder_output.state)
            add_layer_summary('output', encoder_output.output)
        return encoder_output

    def compute_loss(self, sim_score):
        with tf.variable_scope('compute_loss'):
            batch_size = sim_score.get_shape().as_list()[0]
            sim_score = tf.matrix_set_diag(sim_score, np.zeros(batch_size))

            # create targets: set element within diagonal offset to 1
            targets = np.zeros(shape = (batch_size, batch_size))
            offset = self.params['context_size']//2 ## offset of the diagonal
            for i in chain(range(1, 1+offset), range(-offset, -offset+1)):
                diag = np.diagonal(targets, offset = i)
                diag.setflags(write=True)
                diag.fill(1)

            targets = targets/np.sum(targets, axis=1, keepdims = True)

            targets = tf.constant(targets, dtype = self.params['dtype'])

            losses = tf.nn.softmax_cross_entropy_with_logits(labels = targets,
                                                             logits = sim_score)

            losses = tf.reduce_mean(losses)

        return losses
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;欢迎留言吐槽以及评论哟～&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无所不能的embedding系列👇&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/DSXiangLi/Embedding&quot;&gt;https://github.com/DSXiangLi/Embedding&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/gogoSandy/p/13418257.html&quot;&gt;无所不能的Embedding1 - Word2vec模型详解&amp;amp;代码实现&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/gogoSandy/p/13618077.html&quot;&gt;无所不能的Embedding2 - FastText词向量&amp;amp;文本分类&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/gogoSandy/p/13773327.html&quot;&gt;无所不能的Embedding3 - word2vec-&amp;gt;Doc2vec[PV-DM/PV-DBOW]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/gogoSandy/p/14009265.html&quot;&gt;无所不能的Embedding4 - Doc2vec第二弹[skip-thought &amp;amp; tf-Seq2Seq源码解析]&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;【REF】&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Rethinking Skip-thought: A Neighbourhood based Approach, Tang etc, 2017&lt;/li&gt;
&lt;li&gt;Triming and Improving Skip-thought Vectors, Tang etc, 2017&lt;/li&gt;
&lt;li&gt;Learning Generic Sentence Representations Using Convolutional Neural Netword, Gan etc, 2017&lt;/li&gt;
&lt;li&gt;An Efficient Framework fir learning sentennce representations, Lajanugen etc, 2018&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50443871&quot;&gt;https://zhuanlan.zhihu.com/p/50443871&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 07 Dec 2020 00:32:00 +0000</pubDate>
<dc:creator>风雨中的小七</dc:creator>
<og:description>这一章我们来聊聊skip-thought的三兄弟，它们在解决skip-thought遗留问题上做出了不同的尝试【Ref1～4】, 以下paper可能没有给出最优的解决方案(对不同的NLP任务其实没有最</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/gogoSandy/p/14094590.html</dc:identifier>
</item>
<item>
<title>献给 Dapper 使用者的一份礼物 - nicye</title>
<link>http://www.cnblogs.com/kellynic/p/14095502.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kellynic/p/14095502.html</guid>
<description>&lt;h2 id=&quot;写在开头&quot;&gt;写在开头&lt;/h2&gt;
&lt;p&gt;众所周知 Dapper 是 .NET 下最轻最快的 ORM，它是喜欢写 SQL 码农的福音，相对于 SqlHelper 它更加方便，据统计 10个 .NETer 有 9个 用过 Dapper。&lt;/p&gt;
&lt;p&gt;由于 .NET 环境的特殊，对 Lambda 表达式树的喜爱，于是市面上有很多出现了基于 Dapper 的轻量级 ORM，它们几乎都有共同特点，让 Dapper 支持 Lambda 表达式树，写起来顺畅如流水。&lt;/p&gt;
&lt;p&gt;今天介绍一款本身功能已经很强大的 ORM，他提供一个隐藏得比较深的 API 功能，使用起来和 Dapper 没什么两样。&lt;/p&gt;
&lt;h2 id=&quot;了解-lambda-表达式树&quot;&gt;了解 Lambda 表达式树&lt;/h2&gt;
&lt;p&gt;这要先从 Lambda 表达式开始说起，词语中少了一个“树”字，差别甚大。&lt;/p&gt;
&lt;p&gt;表达式，如下各种语法糖骚操作，产生的 IL 一模一样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;//使用C# 2.0中的匿名方法获取字符串长度
Func&amp;lt;string, int&amp;gt; strLength = delegate(string str) { return str.Length; };
Console.WriteLine(strLength(&quot;Hello World!&quot;));

//使用Lambda表达式
//（显式类型参数列表）=&amp;gt; {语句}，lambda表达式最冗长版本
strLength = (string str) =&amp;gt; { return str.Length; };
Console.WriteLine(strLength(&quot;Hello World!&quot;));

//单一表达式作为主体
//（显式类型参数列表）=&amp;gt; 表达式
strLength = (string str) =&amp;gt; str.Length;
Console.WriteLine(strLength(&quot;Hello World!&quot;));

//隐式类型的参数列表
//（隐式类型参数列表）=&amp;gt; 表达式
strLength = (str) =&amp;gt; str.Length;
Console.WriteLine(strLength(&quot;Hello World!&quot;));

//单一参数的快捷语法
//参数名 =&amp;gt; 表达式
strLength = str =&amp;gt; str.Length;
Console.WriteLine(strLength(&quot;Hello World!&quot;));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而表达式树呢，代码写起来跟表达式差不多，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;Expression&amp;lt;Func&amp;lt;string, int&amp;gt;&amp;gt; strLength = str =&amp;gt; str.Length；
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;表达式树不支持代码块（花括号）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;力求书写简单，一般情况我们都是这样写的，虽然它和表达式代码写起来几乎一样，但是返回值和表达式不一样，多了一个泛型 Expression&amp;lt;&amp;gt;。&lt;/p&gt;
&lt;p&gt;表达式树也称表达式目录树，将代码以一种抽象的方式表示成一个对象树，树中每个节点本身都是一个表达式。表达式树不是可执行代码，它是一种数据结构。它是代码在编译期间将编写的代码转换成一个树结构，以便后续进行逆向解析。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如上：(strLength.Body as MemberExpression).Member.Name 可以得到值 &quot;Length&quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于表达式树可逆向解析的特点，近十年来 EF 是一直是带头大哥，国产每年都要整出好几个 ORM，大部分都是基于表达式树解析做的。&lt;/p&gt;
&lt;h2 id=&quot;表达式树解析&quot;&gt;表达式树解析&lt;/h2&gt;
&lt;p&gt;.NET 技术文章从来不缺少表达式树解析的这类文章，有兴趣的可以百度搜索一下，很多很多，但是想做完美可不是件简单事。&lt;/p&gt;
&lt;p&gt;FreeSql 在表达式树解析上做了下足了工夫，举例：&lt;/p&gt;
&lt;p&gt;1、子表 in 查询&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;.Where(a =&amp;gt; fsql.Select&amp;lt;T&amp;gt;().ToList(b =&amp;gt; b.Id).Contains(a.Id))
//WHERE a.Id in (select id from t)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、子表 exists 查询&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;.Where(a =&amp;gt; fsql.Select&amp;lt;T&amp;gt;().Any(b =&amp;gt; b.Id == a.Id))
//WHERE exists(select 1 from t where Id = a.Id)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、日期格式化&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;ToList(a =&amp;gt; a.CreateTime.ToString(&quot;HH:mm:ss&quot;))
//date_format(a.`CreateTime`, '%H:%i:%s')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4、开窗函数&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;ToList(a =&amp;gt; SqlExt.Rank().Over().OrderBy(a.Id).OrderByDescending(b.EdiId).ToValue())
//rank() over(order by a.Id, b.EdiId desc)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5、Join 子表&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;ToList(a =&amp;gt; string.Join(&quot;,&quot;, fsql.Select&amp;lt;StringJoin01&amp;gt;().ToList(b =&amp;gt; b.Id)))
//(SELECT group_concat(b.`Id` separator ',') FROM `StringJoin01` b) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些特性在不同的数据库，都需要做相应适配实现，FreeSql 还支持对导航属性的表达式树解析，说这些只想证明做到细致真的不容易。&lt;/p&gt;
&lt;p&gt;与其自己造着麻烦，不如直接拿来主义使用？&lt;/p&gt;
&lt;h2 id=&quot;adonet-扩展实现&quot;&gt;Ado.Net 扩展实现&lt;/h2&gt;
&lt;p&gt;与其自己造着麻烦，不如直接拿来主义使用？FreeSql 提供了一种非主打的 API 使用习惯，使用起来跟 Dapper 没什么区别。&lt;/p&gt;
&lt;p&gt;支持 MySql/SqlServer/PostgreSQL/Oracle/Sqlite/Firebird/达梦/神通/人大金仓/翰高/MsAccess 十多种数据库适配，支持 Ado.net/Odbc，并且支持 .NetFramework 4.0 平台、.NET5.0、.NET Core2.1 + 平台。&lt;/p&gt;
&lt;p&gt;第一步：以数据库 SqlServer 访问为例，只需要安装已经划分好的小包：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;dotnet add packages FreeSql.Provider.SqlServer
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;Install-Package FreeSql.Provider.SqlServer
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二步：建立实体类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;class TestConnectionExt {
    public Guid id { get; set; }
    public string title { get; set; }
    public DateTime createTime { get; set; } = DateTime.Now;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第三步：开始 CRUD&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;using (var conn = new SqlConnection(connectString)) {
    var list = conn.Select&amp;lt;TestConnectionExt&amp;gt;().Where(a =&amp;gt; a.id == item.id).ToList();
}

using (var conn = new SqlConnection(connectString)) {
    var item = new TestConnectionExt { title = &quot;testinsert&quot; };
    var affrows = conn.Insert(item).ExecuteAffrows();
}

using (var conn = new SqlConnection(connectString)) {
    var affrows = conn.Update&amp;lt;TestConnectionExt&amp;gt;()
        .Where(a =&amp;gt; a.Id == xxx)
        .Set(a =&amp;gt; a.title, &quot;testupdated&quot;)
        .ExecuteAffrows();
}

using (var conn = new SqlConnection(connectString)) {
    var affrows = conn.Delete&amp;lt;TestConnectionExt&amp;gt;()
        .Where(a =&amp;gt; a.Id == xxx)
        .ExecuteAffrows();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加或更新：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;using (var conn = new SqlConnection(connectString)) {
    var affrows = conn.InsertOrUpdate&amp;lt;TestConnectionExt&amp;gt;()
        .SetSource(item)
        .ExecuteAffrows();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上添加、删除、修改、查询，已经支持实体类操作，并且支持批量插入、批量更新、批量删除、多表查询、导航属性查询。&lt;/p&gt;
&lt;p&gt;可以享用 FreeSql 几乎所有功能。&lt;/p&gt;
&lt;p&gt;思考：使用这种 API 貌似可以很轻松的接入到 abp vnext 中？&lt;/p&gt;
&lt;h2 id=&quot;结束语&quot;&gt;结束语&lt;/h2&gt;
&lt;p&gt;FreeSql 使用世界上最宽松的开源协议 MIT 托管于 github：&lt;a href=&quot;https://github.com/dotnetcore/FreeSql&quot;&gt;https://github.com/dotnetcore/FreeSql&lt;/a&gt; 目前已发布经历两年高频率迭代的稳定版本 v2.0，欢迎关注和使用。&lt;/p&gt;
&lt;p&gt;支持 .NetFramework 4.0+、.NetCore 2.1+、Xamarin 等支持 NetStandard 所有运行平台。&lt;/p&gt;
&lt;p&gt;支持 MySql/SqlServer/PostgreSQL/Oracle/Sqlite/Firebird/达梦/神通/人大金仓/翰高/MsAccess 数据库，支持 Ado.net/Odbc。&lt;/p&gt;
&lt;p&gt;QQ群：4336577(已满)、8578575(在线)、52508226(在线)&lt;/p&gt;
</description>
<pubDate>Mon, 07 Dec 2020 00:31:00 +0000</pubDate>
<dc:creator>nicye</dc:creator>
<og:description>写在开头 众所周知 Dapper 是 .NET 下最轻最快的 ORM，它是喜欢写 SQL 码农的福音，相对于 SqlHelper 它更加方便，据统计 10个 .NETer 有 9个 用过 Dapper</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kellynic/p/14095502.html</dc:identifier>
</item>
<item>
<title>你说说对Java中SPI的理解吧 - 纪莫</title>
<link>http://www.cnblogs.com/jimoer/p/14095489.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jimoer/p/14095489.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近在面试的时候被问到SPI了，没回答上来，主要也是自己的原因，把自己给带沟里去了，因为讲到了类加载器的双亲委派模型，后面就被问到了有哪些是破坏了双亲委派模型的场景，然后我就说到了SPI，JNDI，以及JDK9的模块化都破坏了双亲委派。&lt;br/&gt;然后就被问，那你说说对Java中的SPI的理解吧。然后我就一脸懵逼了，之前只是知道它会破坏双亲委派，也知道是个怎么回事，但是并没有深入了解，那么这次我就好好的来总结一下这个知识吧。&lt;/p&gt;
&lt;h2 id=&quot;什么是spi&quot;&gt;什么是SPI&lt;/h2&gt;
&lt;p&gt;SPI全称Service Provider Interface，字面意思是提供服务的接口，再解释详细一下就是&lt;strong&gt;Java提供的一套用来被第三方实现或扩展的接口，实现了接口的动态扩展，让第三方的实现类能像插件一样嵌入到系统中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;咦。。。&lt;br/&gt;这个解释感觉还是有点绕口。&lt;br/&gt;那就说一下它的本质。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;将接口的实现类的全限定名配置在文件中（文件名是接口的全限定名），由服务加载器读取配置文件，加载实现类。实现了运行时动态为接口替换实现类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;spi示例&quot;&gt;SPI示例&lt;/h2&gt;
&lt;p&gt;还是举例说明吧。&lt;br/&gt;我们创建一个项目，然后创建一个module叫spi-interface。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201206231416917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_40,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;在这个module中我们定义一个接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @author jimoer
 **/
public interface SpiInterfaceService {

    /**
     * 打印参数
     * @param parameter 参数
     */
    void printParameter(String parameter);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再定义一个module，名字叫spi-service-one，pom.xml中依赖spi-interface。&lt;br/&gt;在spi-service-one中定义一个实现类，实现SpiInterfaceService 接口。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.jimoer.spi.service.one;
import com.jimoer.spi.app.SpiInterfaceService;

/**
 * @author jimoer
 **/
public class SpiOneService implements SpiInterfaceService {
    /**
     * 打印参数
     *
     * @param parameter 参数
     */
    @Override
    public void printParameter(String parameter) {
        System.out.println(&quot;我是SpiOneService:&quot;+parameter);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后再spi-service-one的resources目录下创建目录META-INF/services，在此目录下创建一个文件名称为SpiInterfaceService接口的全限定名称，文件内容写入SpiOneService这个实现类的全限定名称。&lt;br/&gt;效果如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201206230909117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_40,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;再创建一个module，名称为：spi-service-one，也是依赖spi-interface，并且定义一个实现类SpiTwoService 来实现SpiInterfaceService 接口。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.jimoer.spi.service.two;
import com.jimoer.spi.app.SpiInterfaceService;
/**
 * @author jimoer
 **/
public class SpiTwoService implements SpiInterfaceService {
    /**
     * 打印参数
     *
     * @param parameter 参数
     */
    @Override
    public void printParameter(String parameter) {
        System.out.println(&quot;我是SpiTwoService:&quot;+parameter);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目录结构如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201206231315234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_40,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;下面再创建一个用来测试的module，名为：spi-app。&lt;img src=&quot;https://img-blog.csdnimg.cn/20201206231517172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_40,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;pom.xml中依赖&lt;code&gt;spi-service-one&lt;/code&gt;和&lt;code&gt;spi-service-two&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.jimoer.spi&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spi-service-one&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.jimoer.spi&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spi-service-two&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建测试类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @author jimoer
 **/
public class SpiService {

    public static void main(String[] args) {

        ServiceLoader&amp;lt;SpiInterfaceService&amp;gt; spiInterfaceServices = ServiceLoader.load(SpiInterfaceService.class);
        Iterator&amp;lt;SpiInterfaceService&amp;gt; iterator = spiInterfaceServices.iterator();
        while (iterator.hasNext()){
            SpiInterfaceService sip = iterator.next();
            sip.printParameter(&quot;参数&quot;);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;我是SpiTwoService:参数
我是SpiOneService:参数
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过运行结果我们可以看到，已经将SpiInterfaceService接口的所有实现都加载到了当前项目中，并且执行了调用。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020120700453760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_40,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;这整个代码结构我们可以看出SPI机制将模块的装配放到了程序外面，就是说，接口的实现可以在程序外面，只需要在使用的时候指定具体的实现。并且动态的加载到自己的项目中。&lt;br/&gt;SPI机制的主要目的：&lt;br/&gt;&lt;strong&gt;一是为了解耦，将接口和具体实现分离开来；&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;二是提高框架的扩展性&lt;/strong&gt;。以前写程序的时候，接口和实现都写在一起，调用方在使用的时候依赖接口来进行调用，无权选择使用具体的实现类。&lt;/p&gt;
&lt;h2 id=&quot;spi的实现&quot;&gt;SPI的实现&lt;/h2&gt;
&lt;p&gt;那么我们来看一下SPI具体是如何实现的呢？&lt;br/&gt;通过上面的例子，我们可以看到，SPI机制的核心代码是下面这段：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ServiceLoader&amp;lt;SpiInterfaceService&amp;gt; spiInterfaceServices = ServiceLoader.load(SpiInterfaceService.class);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么我们来看一下&lt;code&gt;ServiceLoader.load()&lt;/code&gt;方法的源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static &amp;lt;S&amp;gt; ServiceLoader&amp;lt;S&amp;gt; load(Class&amp;lt;S&amp;gt; service) {
    ClassLoader cl = Thread.currentThread().getContextClassLoader();
    return ServiceLoader.load(service, cl);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到&lt;code&gt;Thread.currentThread().getContextClassLoader()&lt;/code&gt;；我就明白是怎么回事了，这个就是&lt;strong&gt;线程上下文类加载器&lt;/strong&gt;，因为&lt;strong&gt;线程上下文类加载器&lt;/strong&gt;就是为了做类加载双亲委派模型的逆序而创建的。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;使用这个线程上下文类加载器去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了，双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，但也是无可奈何的事情。&lt;br/&gt;&lt;strong&gt;《深入理解Java虚拟机（第三版）》&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然知道了它是破坏双亲委派的了，但是具体实现，还是需要具体往下看的。&lt;/p&gt;
&lt;p&gt;在ServiceLoader里找到具体实现hasNext()的方法了，那么继续来看这个方法的实现。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201207000120134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_40,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;hasNext()方法又主要调用了hasNextService()方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 固定路径
private static final String PREFIX = &quot;META-INF/services/&quot;;

private boolean hasNextService() {
     if (nextName != null) {
         return true;
     }
     if (configs == null) {
         try {
                // 固定路径+接口全限定名称
             String fullName = PREFIX + service.getName();
             // 如果当前线程上下文类加载器为空，会用父类加载器（默认是应用程序类加载器）
             if (loader == null)
                 configs = ClassLoader.getSystemResources(fullName);
             else
                 configs = loader.getResources(fullName);
         } catch (IOException x) {
             fail(service, &quot;Error locating configuration files&quot;, x);
         }
     }
     while ((pending == null) || !pending.hasNext()) {
         if (!configs.hasMoreElements()) {
             return false;
         }
         pending = parse(service, configs.nextElement());
     }
     // 后面next()方法中判断当前类是否已经出现化的时候要用
     nextName = pending.next();
     return true;
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主要就是去加载META-INF/services/路径下的接口全限定名称的文件然后去里面找到实现类的类路径将实现类进行类加载。&lt;/p&gt;
&lt;p&gt;继续看迭代器是如何取出每一个实现对象的。那就要看ServiceLoader中实现了迭代器的next()方法了。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201207001419765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_40,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;next()方法主要是nextService()实现的，那么继续看nextService()方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private S nextService() {
     if (!hasNextService())
         throw new NoSuchElementException();
     String cn = nextName;
     nextName = null;
     Class&amp;lt;?&amp;gt; c = null;
     try {
     // 直接加载类，无需初始化（因为上面hasNext()已经初始化了）。
         c = Class.forName(cn, false, loader);
     } catch (ClassNotFoundException x) {
         fail(service,
              &quot;Provider &quot; + cn + &quot; not found&quot;);
     }
     if (!service.isAssignableFrom(c)) {
         fail(service,
              &quot;Provider &quot; + cn  + &quot; not a subtype&quot;);
     }
     try {
        // 将加载好的类实例化出对象。
         S p = service.cast(c.newInstance());
         providers.put(cn, p);
         return p;
     } catch (Throwable x) {
         fail(service,
              &quot;Provider &quot; + cn + &quot; could not be instantiated&quot;,
              x);
     }
     throw new Error();          // This cannot happen
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到这里就可以明白了，是如何创建出对象的了。先在hasNext()将接口的实现类进行加载并判断是否存在接口的实现类，然后在next()方法中将实现类进实例化。&lt;/p&gt;
&lt;p&gt;Java中使用SPI机制的功能其实有很多，像JDBC、JNDI、以及Spring中也有使用，甚至RPC框架（Dubbo）中也有使用SPI机制来实现功能。&lt;/p&gt;
</description>
<pubDate>Mon, 07 Dec 2020 00:10:00 +0000</pubDate>
<dc:creator>纪莫</dc:creator>
<og:description>前言 最近在面试的时候被问到SPI了，没回答上来，主要也是自己的原因，把自己给带沟里去了，因为讲到了类加载器的双亲委派模型，后面就被问到了有哪些是破坏了双亲委派模型的场景，然后我就说到了SPI，JND</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jimoer/p/14095489.html</dc:identifier>
</item>
<item>
<title>跳槽后在新公司的一点感悟 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/13903977.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/13903977.html</guid>
<description>&lt;p&gt;　　最近跳槽到一家创业多年的小公司，带一个前端小团队。&lt;/p&gt;
&lt;p&gt;　　在这一个多月中，主要是熟悉业务，维护老代码，编写新业务等，期间也发现了当前团队出现的种种问题，打算在接下来的日子里好好改造。&lt;/p&gt;
&lt;p&gt;　　接下来给自己定的小目标是，改变混乱的局面，提升工作效率，团队更加稳定和规范化。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202010/211606-20201031220058430-996452266.png&quot; width=&quot;200&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202010/211606-20201031215634625-61325999.png&quot; width=&quot;200&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）规章制度&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　首先要适应公司的规章制度，主要还是要习惯上下班时间，这和以往不同，本来是到点就走的。现在的话，每天都比较忙碌，下班时间也不定。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）新的角色&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　其次是要适应自己的新角色，新公司负责的事情要比老公司多很多，以往还是蛮闲的，但现在不同。&lt;/p&gt;
&lt;p&gt;　　并且要带团队，考虑的层面也得比以前更高一点。不能只想着自己的个人发展，更多的是要关注团队发展，为团队的每个人负责。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）开发模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　接着是要适应当前的开发模式，上家公司只做H5相关的事情，也就是做些效果、小程序之类的纯前端工作。&lt;/p&gt;
&lt;p&gt;　　而这里还会涉及到一些后端任务，用Node做了中间层，整合各类数据，执行Redis缓存，有时候还要直接操纵数据库。&lt;/p&gt;
&lt;p&gt;　　刚开始还真有点不适应，不仅要学会用终端，还得知道怎么通过看日志来排查各类问题等等。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）业务逻辑&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　最后就是要熟悉业务逻辑，前提就是要把项目跑起来，知道怎么修改。&lt;/p&gt;
&lt;p&gt;　　目前公司缺失各类文档，员工离职后很多信息就只能通过代码来了解其中的逻辑了。&lt;/p&gt;
&lt;p&gt;　　为了方便调试，特地搭建了单元测试（主要测试Node方面的代码，&lt;span&gt;&lt;a href=&quot;https://mochajs.cn/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Mocha&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;+&lt;span&gt;&lt;a href=&quot;https://www.chaijs.com/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Chai&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;+&lt;span&gt;&lt;a href=&quot;https://github.com/visionmedia/supertest&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Supertest&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;），这样既能保障代码质量，也方便了解某个函数的功能、变量的值等。&lt;/p&gt;
&lt;p&gt;　　目前还有很多我不了解的业务，未来将会经常遇到。对于这些未知业务，除了被动的遇到后再了解之外，还可以主动与各个组的相关负责人了解，未雨绸缪。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5）难点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　祖传代码还在运行中，代码写的杂乱无章，并且很多服务已无人维护，但是由于缺乏文档，难以轻易地修改。&lt;/p&gt;
&lt;p&gt;　　人员缺乏，每天都疲于修复各种BUG，以及各种杂七杂八的事情，经常要花大精力去查看代码、日志和数据库，计划要写的代码或要做的事情经常无法按时完成，难以达到平衡。虽然短期内加班可以解决，但长期的话还是得补充人员。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）前后端真正分离&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　当前公司对前端的要求有点高， 既要会市面上主流的前端技术（HTML和CSS是必须的，还有React、Vue等），也要有后端开发的经验，比如操作MongoDB和MySQL等。&lt;/p&gt;
&lt;p&gt;　　之前公司已经有好几个员工因为这些原因而离职了。以后如果还这么招人，定会遇到许多阻碍，毕竟没有大厂的条件。&lt;/p&gt;
&lt;p&gt;　　前端会负责一个比较庞大的后台管理系统，如果是些简单的查询更新等数据库语句，其实复杂度上倒也没什么，只不过费时间而已。&lt;/p&gt;
&lt;p&gt;　　但前端还要处理金额敏感信息，这块还是需要交接出去，过来后就和后端的大佬们讨论了方案，做到真正的分离，后端组的人也是积极响应，不过这种交接过程将是比较漫长的，毕竟资源有限。&lt;/p&gt;
&lt;p&gt;　　未来尽量由后端服务器组提供数据源，前端就做数据整合以及页面效果的工作，尽量做到专精。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）统一技术栈&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　当前前端有些技术栈比较老旧，有些活动页面甚至还在用jQuery制作，这样很限制团队成员的发展。&lt;/p&gt;
&lt;p&gt;　　因此打算统一技术栈，将后续的项目迁移到Vue或React这些目前比较主流的库，这样也有利于团队成员的自身发展。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）技术文档&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在我进新公司之时，有个老员工要离职了，他了解很多业务，于是就安排他尽可能多的记录到内网的Wiki中。文档虽然不算全，但好歹有个雏形，未来慢慢补全。&lt;/p&gt;
&lt;p&gt;　　当前前端组维护了多个项目，这些项目又分别使用了不同的技术栈。&lt;/p&gt;
&lt;p&gt;　　例如后台管理系统前台采用的是&lt;span&gt;&lt;a href=&quot;https://umijs.org/zh-CN&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;UmiJS&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;+&lt;span&gt;&lt;a href=&quot;https://dvajs.com/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;DvaJS&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;+&lt;span&gt;&lt;a href=&quot;https://ant.design/index-cn&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Ant Design&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;+&lt;span&gt;&lt;a href=&quot;https://react.docschina.org/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;React&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，后台采用的是&lt;span&gt;&lt;a href=&quot;https://koa.bootcss.com/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;KOA2&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;+&lt;span&gt;&lt;a href=&quot;http://nodejs.cn/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;NodeJS&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;+&lt;span&gt;&lt;a href=&quot;https://www.mysql.com/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;MySQL&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;+&lt;span&gt;&lt;a href=&quot;https://www.mongodb.com/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;MongoDB&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　自己花了点时间和精力探索了一下这两个项目的运行过程（画了几张流程图），还对其中的技术细节做了归纳和总结，降低后续新加入的小伙伴的理解难度。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）代码注释&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　未来的话，还需要完善源代码的各种注释，目前很多组件和函数都是没有注释的，只能一行一行的看代码来理解，很是费劲。&lt;/p&gt;
&lt;p&gt;　　公司也打算用工具（例如&lt;span&gt;&lt;a href=&quot;https://swagger.io/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;swagger&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;）通过写注释的方式，自动生成接口文档。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）各类业务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　其他组应该也会有相关文档，未来需要有个引导页面，跳转到相关业务中。如果没有的话，需要找个协商人，让他安排人手去补齐。&lt;/p&gt;


</description>
<pubDate>Sun, 06 Dec 2020 23:48:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>最近跳槽到一家创业多年的小公司，带一个前端小团队。 在这一个多月中，主要是熟悉业务，维护老代码，编写新业务等，期间也发现了当前团队出现的种种问题，打算在接下来的日子里好好改造。 接下来给自己定的小目标</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/13903977.html</dc:identifier>
</item>
<item>
<title>CoProcessFunction实战三部曲之三：定时器和侧输出 - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/14095463.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/14095463.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;系列文章链接&quot;&gt;系列文章链接&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/109624375&quot;&gt;基本功能&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/109629119&quot;&gt;状态处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/109645214&quot;&gt;定时器和侧输出&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;本篇概览&quot;&gt;本篇概览&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;本文是《CoProcessFunction实战三部曲》的终篇，主要内容是在CoProcessFunction中使用定时器和侧输出，对上一篇的功能进行增强；&lt;/li&gt;
&lt;li&gt;回顾上一篇的功能：一号流收到&lt;span&gt;aaa&lt;/span&gt;后保存在状态中，直到二号流收到aaa，把两个aaa的值相加后输出到下游；&lt;/li&gt;
&lt;li&gt;上述功能有个问题：二号流如果一直收不到&lt;span&gt;aaa&lt;/span&gt;，下游就一直没有aaa的输出，相当于进入一号流的aaa已经石沉大海了；&lt;/li&gt;
&lt;li&gt;今天的实战就是修复上述问题：aaa在一个流中出现后，10秒之内如果出现在另一个流中，就像以前那样值相加，输出到下游，如果10秒内没有出现在另一个流，就流向侧输出，再将所有状态清理干净；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;参考文章&quot;&gt;参考文章&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;理解状态：&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/106040312&quot;&gt;《深入了解ProcessFunction的状态操作(Flink-1.10)》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;理解定时器：&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/109564999&quot;&gt;《理解ProcessFunction的Timer逻辑》&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;梳理流程&quot;&gt;梳理流程&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;为了编码的逻辑正确，咱们把正常和异常的流程先梳理清楚；&lt;/li&gt;
&lt;li&gt;下图是正常流程：aaa在一号流出现后，10秒内又在二号流出现了，于是相加并流向下游：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201207073418461-917425372.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;再来看异常的流程，如下图，一号流在&lt;span&gt;16:14:01&lt;/span&gt;收到aaa，但二号流一直没有收到aaa，等到10秒后，也就是&lt;span&gt;16:14:11&lt;/span&gt;，定时器被触发，从状态1得知10秒前一号流收到过aaa，于是将数据流向一号侧输出：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201207073418704-1654788180.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;接下来编码实现上面的功能；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;源码下载&quot;&gt;源码下载&lt;/h3&gt;
&lt;p&gt;如果您不想写代码，整个系列的源码可在GitHub下载到，地址和链接信息如下表所示(&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;)：&lt;/p&gt;
&lt;p&gt;这个git项目中有多个文件夹，本章的应用在&lt;span&gt;flinkstudy&lt;/span&gt;文件夹下，如下图红框所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201207073420708-744335415.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;coprocessfunction的子类&quot;&gt;CoProcessFunction的子类&lt;/h3&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;前面的两篇实战中，&lt;span&gt;CoProcessFunction&lt;/span&gt;的子类都写成了匿名类，如下图红框：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201207073420994-231561697.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;本文中，CoProcessFunction子类会用到外部类的成员变量，因此不能再用匿名类了，新增CoProcessFunction的子类&lt;span&gt;ExecuteWithTimeoutCoProcessFunction.java&lt;/span&gt;，稍后会说明几个关键点：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.coprocessfunction;

import com.bolingcavalry.Utils;
import org.apache.flink.api.common.state.ValueState;
import org.apache.flink.api.common.state.ValueStateDescriptor;
import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.configuration.Configuration;
import org.apache.flink.streaming.api.functions.co.CoProcessFunction;
import org.apache.flink.util.Collector;
import org.apache.flink.util.OutputTag;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * 实现双流业务逻辑的功能类
 */
public class ExecuteWithTimeoutCoProcessFunction extends CoProcessFunction&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;, Tuple2&amp;lt;String, Integer&amp;gt;, Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; {

    private static final Logger logger = LoggerFactory.getLogger(ExecuteWithTimeoutCoProcessFunction.class);

    /**
     * 等待时间
     */
    private static final long WAIT_TIME = 10000L;

    public ExecuteWithTimeoutCoProcessFunction(OutputTag&amp;lt;String&amp;gt; source1SideOutput, OutputTag&amp;lt;String&amp;gt; source2SideOutput) {
        super();
        this.source1SideOutput = source1SideOutput;
        this.source2SideOutput = source2SideOutput;
    }

    private OutputTag&amp;lt;String&amp;gt; source1SideOutput;

    private OutputTag&amp;lt;String&amp;gt; source2SideOutput;

    // 某个key在processElement1中存入的状态
    private ValueState&amp;lt;Integer&amp;gt; state1;

    // 某个key在processElement2中存入的状态
    private ValueState&amp;lt;Integer&amp;gt; state2;

    // 如果创建了定时器，就在状态中保存定时器的key
    private ValueState&amp;lt;Long&amp;gt; timerState;

    // onTimer中拿不到当前key，只能提前保存在状态中（KeyedProcessFunction的OnTimerContext有API可以取到，但是CoProcessFunction的OnTimerContext却没有）
    private ValueState&amp;lt;String&amp;gt; currentKeyState;

    @Override
    public void open(Configuration parameters) throws Exception {
        // 初始化状态
        state1 = getRuntimeContext().getState(new ValueStateDescriptor&amp;lt;&amp;gt;(&quot;myState1&quot;, Integer.class));
        state2 = getRuntimeContext().getState(new ValueStateDescriptor&amp;lt;&amp;gt;(&quot;myState2&quot;, Integer.class));
        timerState = getRuntimeContext().getState(new ValueStateDescriptor&amp;lt;&amp;gt;(&quot;timerState&quot;, Long.class));
        currentKeyState = getRuntimeContext().getState(new ValueStateDescriptor&amp;lt;&amp;gt;(&quot;currentKeyState&quot;, String.class));
    }

    /**
     * 所有状态都清理掉
     */
    private void clearAllState() {
        state1.clear();
        state2.clear();
        currentKeyState.clear();
        timerState.clear();
    }

    @Override
    public void processElement1(Tuple2&amp;lt;String, Integer&amp;gt; value, Context ctx, Collector&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; out) throws Exception {
        logger.info(&quot;processElement1：处理元素1：{}&quot;, value);

        String key = value.f0;

        Integer value2 = state2.value();

        // value2为空，就表示processElement2还没有处理或这个key，
        // 这时候就把value1保存起来
        if(null==value2) {
            logger.info(&quot;processElement1：2号流还未收到过[{}]，把1号流收到的值[{}]保存起来&quot;, key, value.f1);
            state1.update(value.f1);

            currentKeyState.update(key);

            // 开始10秒的定时器，10秒后会进入
            long timerKey = ctx.timestamp() + WAIT_TIME;
            ctx.timerService().registerProcessingTimeTimer(timerKey);
            // 保存定时器的key
            timerState.update(timerKey);
            logger.info(&quot;processElement1：创建定时器[{}]，等待2号流接收数据&quot;, Utils.time(timerKey));
        } else {
            logger.info(&quot;processElement1：2号流收到过[{}]，值是[{}]，现在把两个值相加后输出&quot;, key, value2);

            // 输出一个新的元素到下游节点
            out.collect(new Tuple2&amp;lt;&amp;gt;(key, value.f1 + value2));

            // 删除定时器（这个定时器应该是processElement2创建的）
            long timerKey = timerState.value();
            logger.info(&quot;processElement1：[{}]的新元素已输出到下游，删除定时器[{}]&quot;, key, Utils.time(timerKey));
            ctx.timerService().deleteProcessingTimeTimer(timerKey);

            clearAllState();
        }
    }

    @Override
    public void processElement2(Tuple2&amp;lt;String, Integer&amp;gt; value, Context ctx, Collector&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; out) throws Exception {
        logger.info(&quot;processElement2：处理元素2：{}&quot;, value);

        String key = value.f0;

        Integer value1 = state1.value();

        // value1为空，就表示processElement1还没有处理或这个key，
        // 这时候就把value2保存起来
        if(null==value1) {
            logger.info(&quot;processElement2：1号流还未收到过[{}]，把2号流收到的值[{}]保存起来&quot;, key, value.f1);
            state2.update(value.f1);

            currentKeyState.update(key);

            // 开始10秒的定时器，10秒后会进入
            long timerKey = ctx.timestamp() + WAIT_TIME;
            ctx.timerService().registerProcessingTimeTimer(timerKey);
            // 保存定时器的key
            timerState.update(timerKey);
            logger.info(&quot;processElement2：创建定时器[{}]，等待1号流接收数据&quot;, Utils.time(timerKey));
        } else {
            logger.info(&quot;processElement2：1号流收到过[{}]，值是[{}]，现在把两个值相加后输出&quot;, key, value1);

            // 输出一个新的元素到下游节点
            out.collect(new Tuple2&amp;lt;&amp;gt;(key, value.f1 + value1));

            // 删除定时器（这个定时器应该是processElement1创建的）
            long timerKey = timerState.value();
            logger.info(&quot;processElement2：[{}]的新元素已输出到下游，删除定时器[{}]&quot;, key, Utils.time(timerKey));
            ctx.timerService().deleteProcessingTimeTimer(timerKey);

            clearAllState();
        }
    }

    @Override
    public void onTimer(long timestamp, OnTimerContext ctx, Collector&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; out) throws Exception {
        super.onTimer(timestamp, ctx, out);

        String key = currentKeyState.value();

        // 定时器被触发，意味着此key只在一个中出现过
        logger.info(&quot;[{}]的定时器[{}]被触发了&quot;, key, Utils.time(timestamp));

        Integer value1 = state1.value();
        Integer value2 = state2.value();

        if(null!=value1) {
            logger.info(&quot;只有1号流收到过[{}]，值为[{}]&quot;, key, value1);
            // 侧输出
            ctx.output(source1SideOutput, &quot;source1 side, key [&quot; + key+ &quot;], value [&quot; + value1 + &quot;]&quot;);
        }

        if(null!=value2) {
            logger.info(&quot;只有2号流收到过[{}]，值为[{}]&quot;, key, value2);
            // 侧输出
            ctx.output(source2SideOutput, &quot;source2 side, key [&quot; + key+ &quot;], value [&quot; + value2 + &quot;]&quot;);
        }

        clearAllState();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;关键点之一：新增状态&lt;span&gt;timerState&lt;/span&gt;，用于保存定时器的key；&lt;/li&gt;
&lt;li&gt;关键点之二：CoProcessFunction的&lt;span&gt;onTimer&lt;/span&gt;中拿不到当前key(KeyedProcessFunction可以，其OnTimerContext类提供了API)，因此新增状态&lt;span&gt;currentKeyState&lt;/span&gt;，这样在onTimer中就知道当前key了；&lt;/li&gt;
&lt;li&gt;关键点之三：processElement1中，处理aaa时， 如果2号流还没收到过aaa，就存入状态，并启动10秒定时器；&lt;/li&gt;
&lt;li&gt;关键点之四：processElement2处理aaa时，发现1号流收到过aaa，就相加再输出到下游，并且删除processElement1中创建的定时器，aaa相关的所有状态也全部清理掉；&lt;/li&gt;
&lt;li&gt;关键点之五：如果10秒内aaa在两个流中都出现过，那么一定会流入下游并且定时器会被删除，因此，一旦&lt;span&gt;onTimer&lt;/span&gt;被执行，意味着aaa只在一个流中出现过，而且已经过去10秒了，此时在&lt;span&gt;onTimer&lt;/span&gt;中可以执行流向侧输出的操作；&lt;/li&gt;
&lt;li&gt;以上就是双流处理的逻辑和代码，接下来编写&lt;span&gt;AbstractCoProcessFunctionExecutor&lt;/span&gt;的子类；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;业务执行类addtwosourcevaluewithtimeout&quot;&gt;业务执行类AddTwoSourceValueWithTimeout&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;负责执行整个功能的，是抽象类&lt;span&gt;AbstractCoProcessFunctionExecutor&lt;/span&gt;的子类，如下，稍后会说明几个关键点：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.coprocessfunction;

import com.bolingcavalry.Utils;
import org.apache.flink.api.java.tuple.Tuple;
import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.streaming.api.datastream.KeyedStream;
import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.functions.AssignerWithPeriodicWatermarks;
import org.apache.flink.streaming.api.functions.co.CoProcessFunction;
import org.apache.flink.streaming.api.watermark.Watermark;
import org.apache.flink.util.OutputTag;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * @author will
 * @email zq2599@gmail.com
 * @date 2020-11-11 09:48
 * @description 将两个流中相通key的value相加，当key在一个流中出现后，
 *              会在有限时间内等待它在另一个流中出现，如果超过等待时间任未出现就在旁路输出
 */
public class AddTwoSourceValueWithTimeout extends AbstractCoProcessFunctionExecutor {

    private static final Logger logger = LoggerFactory.getLogger(AddTwoSourceValueWithTimeout.class);

    // 假设aaa流入1号源后，在2号源超过10秒没有收到aaa，那么1号源的aaa就会流入source1SideOutput
    final OutputTag&amp;lt;String&amp;gt; source1SideOutput = new OutputTag&amp;lt;String&amp;gt;(&quot;source1-sideoutput&quot;){};

    // 假设aaa流入2号源后，如果1号源超过10秒没有收到aaa，那么2号源的aaa就会流入source2SideOutput
    final OutputTag&amp;lt;String&amp;gt; source2SideOutput = new OutputTag&amp;lt;String&amp;gt;(&quot;source2-sideoutput&quot;){};

    /**
     * 重写父类的方法，保持父类逻辑不变，仅增加了时间戳分配器，向元素中加入时间戳
     * @param port
     * @return
     */
    @Override
    protected KeyedStream&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;, Tuple&amp;gt; buildStreamFromSocket(StreamExecutionEnvironment env, int port) {
        return env
                // 监听端口
                .socketTextStream(&quot;localhost&quot;, port)
                // 得到的字符串&quot;aaa,3&quot;转成Tuple2实例，f0=&quot;aaa&quot;，f1=3
                .map(new WordCountMap())
                // 设置时间戳分配器，用当前时间作为时间戳
                .assignTimestampsAndWatermarks(new AssignerWithPeriodicWatermarks&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt;() {

                    @Override
                    public long extractTimestamp(Tuple2&amp;lt;String, Integer&amp;gt; element, long previousElementTimestamp) {
                        long timestamp = System.currentTimeMillis();
                        logger.info(&quot;添加时间戳，值：{}，时间戳：{}&quot;, element, Utils.time(timestamp));
                        // 使用当前系统时间作为时间戳
                        return timestamp;
                    }

                    @Override
                    public Watermark getCurrentWatermark() {
                        // 本例不需要watermark，返回null
                        return null;
                    }
                })
                // 将单词作为key分区
                .keyBy(0);
    }

    @Override
    protected CoProcessFunction&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;, Tuple2&amp;lt;String, Integer&amp;gt;, Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; getCoProcessFunctionInstance() {
        return new ExecuteWithTimeoutCoProcessFunction(source1SideOutput, source2SideOutput);
    }

    @Override
    protected void doSideOutput(SingleOutputStreamOperator&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; mainDataStream) {
        // 两个侧输出都直接打印
        mainDataStream.getSideOutput(source1SideOutput).print();
        mainDataStream.getSideOutput(source2SideOutput).print();
    }

    public static void main(String[] args) throws Exception {
        new AddTwoSourceValueWithTimeout().execute();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;关键点之一：增减成员变量&lt;span&gt;source1SideOutput&lt;/span&gt;和&lt;span&gt;source2SideOutput&lt;/span&gt;，用于侧输出；&lt;/li&gt;
&lt;li&gt;关键点之二：重写父类的buildStreamFromSocket方法，加了个时间戳分配器，这样每个元素都带有时间戳；&lt;/li&gt;
&lt;li&gt;关键点之三：重写父类的doSideOutput方法，这里面会把侧输出的数据打印出来；&lt;/li&gt;
&lt;li&gt;以上就是所有代码了，接下来开始验证；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;验证（不超时的操作）&quot;&gt;验证（不超时的操作）&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;分别开启本机的&lt;span&gt;9998&lt;/span&gt;和&lt;span&gt;9999&lt;/span&gt;端口，我这里是MacBook，执行&lt;span&gt;nc -l 9998&lt;/span&gt;和&lt;span&gt;nc -l 9999&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;启动Flink应用，如果您和我一样是Mac电脑，直接运行&lt;span&gt;AddTwoSourceValueWithTimeout.main&lt;/span&gt;方法即可（如果是windows电脑，我这没试过，不过做成jar在线部署也是可以的）；&lt;/li&gt;
&lt;li&gt;在监听9998端口的控制台输入&lt;span&gt;aaa,1&lt;/span&gt;，此时flink控制台输出如下，可见processElement1方法中，读取state2为空，表示aaa在2号流还未出现过，此时的aaa是首次出现，应该放入state中保存，并且创建了定时器：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;18:18:10,472 INFO  AddTwoSourceValueWithTimeout  - 添加时间戳，值：(aaa,1)，时间戳：2020-11-12 06:18:10
18:18:10,550 INFO  ExecuteWithTimeoutCoProcessFunction  - processElement1：处理元素1：(aaa,1)
18:18:10,550 INFO  ExecuteWithTimeoutCoProcessFunction  - processElement1：2号流还未收到过[aaa]，把1号流收到的值[1]保存起来
18:18:10,553 INFO  ExecuteWithTimeoutCoProcessFunction  - processElement1：创建定时器[2020-11-12 06:18:20]，等待2号流接收数据
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;尽快在监听9999端口的控制台输入&lt;span&gt;aaa,2&lt;/span&gt;，flink日志如下所示，可见相加后输出到下游，并且定时器也删除了：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;18:18:15,813 INFO  AddTwoSourceValueWithTimeout  - 添加时间戳，值：(aaa,2)，时间戳：2020-11-12 06:18:15
18:18:15,887 INFO  ExecuteWithTimeoutCoProcessFunction  - processElement2：处理元素2：(aaa,2)
18:18:15,887 INFO  ExecuteWithTimeoutCoProcessFunction  - processElement2：1号流收到过[aaa]，值是[1]，现在把两个值相加后输出
(aaa,3)
18:18:15,888 INFO  ExecuteWithTimeoutCoProcessFunction  - processElement2：[aaa]的新元素已输出到下游，删除定时器[2020-11-12 06:18:20]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;验证（超时的操作）&quot;&gt;验证（超时的操作）&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;前面试过了正常流程，再来试试超时流程是否符合预期；&lt;/li&gt;
&lt;li&gt;在监听9998端口的控制台输入&lt;span&gt;aaa,1&lt;/span&gt;，然后等待十秒，flink控制台输出如下，可见定时器被触发，并且aaa流向了1号流的侧输出：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;18:23:37,393 INFO  AddTwoSourceValueWithTimeout - 添加时间戳，值：(aaa,1)，时间戳：2020-11-12 06:23:37
18:23:37,417 INFO  ExecuteWithTimeoutCoProcessFunction - processElement1：处理元素1：(aaa,1)
18:23:37,417 INFO  ExecuteWithTimeoutCoProcessFunction - processElement1：2号流还未收到过[aaa]，把1号流收到的值[1]保存起来
18:23:37,417 INFO  ExecuteWithTimeoutCoProcessFunction - processElement1：创建定时器[2020-11-12 06:23:47]，等待2号流接收数据
18:23:47,398 INFO  ExecuteWithTimeoutCoProcessFunction - [aaa]的定时器[2020-11-12 06:23:47]被触发了
18:23:47,399 INFO  ExecuteWithTimeoutCoProcessFunction - 只有1号流收到过[aaa]，值为[1]
source1 side, key [aaa], value [1]
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;至此，CoProcessFunction实战三部曲已经全部完成了，希望这三次实战能够给您一些参考，帮您更快掌握和理解CoProcessFunction；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;你不孤单，欣宸原创一路相伴&quot;&gt;你不孤单，欣宸原创一路相伴&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105068742&quot;&gt;Java系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086498&quot;&gt;Spring系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086732&quot;&gt;Docker系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086794&quot;&gt;kubernetes系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086850&quot;&gt;数据库+中间件系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086920&quot;&gt;DevOps系列&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 06 Dec 2020 23:34:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/14095463.html</dc:identifier>
</item>
<item>
<title>5.3 Spring5源码--Spring AOP使用接口方式实现 - 盛开的太阳</title>
<link>http://www.cnblogs.com/ITPower/p/14095453.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ITPower/p/14095453.html</guid>
<description>&lt;p&gt;&lt;strong&gt;Spring 提供了很多的实现AOP的方式：Spring 接口方式，schema配置方式和注解.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文重点介绍Spring使用接口方式实现AOP. 研究使用接口方式实现AOP, 以了解为目的. 更好地理解spring使用动态代理实现AOP. 通常我们使用的更多的是使用注解的方式实现AOP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面来看看如何实现接口方式的AOP&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;strong&gt;要在项目中使用Spring AOP 则需要在项目中导入除了spring jar包之外, 还需要引入&lt;/strong&gt;aspectjrt.jar，aspectjweaver.jar，aopalliance.jar ，spring-aop-3.2.0.M2.jar和cglib.jar &lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;使用Spring aop接口方式实现aop, 可以通过自定义通知来供Spring AOP识别. 常见的自己定义通知有:前置通知, 后置通知, 返回通知, 异常通知, 环绕通知. 对应实现的接口是:&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;前置通知: MethodBeforeAdvice&lt;/li&gt;
&lt;li&gt;后置通知: AfterAdvice&lt;/li&gt;
&lt;li&gt;返回通知:AfterReturningAdvice&lt;/li&gt;
&lt;li&gt;异常通知:ThrowsAdvice&lt;/li&gt;
&lt;li&gt;环绕通知:MethodInterceptor&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;实现步骤如下:&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;1. 业务接口实现&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package com.lxl.www.aop.interfaceAop;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * &lt;span&gt;&lt;strong&gt;使用接口方式实现AOP, 默认通过JDK的动态代理来实现. 非接口方式, 使用的是cglib实现动态代理&lt;/strong&gt;&lt;/span&gt;
 *
 * 业务接口类-- 计算器接口类
 *
 * 定义三个业务逻辑方法
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IBaseCalculate {

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; numA, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; numB);

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; sub(&lt;span&gt;int&lt;/span&gt; numA, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; numB);

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; div(&lt;span&gt;int&lt;/span&gt; numA, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; numB);

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; multi(&lt;span&gt;int&lt;/span&gt; numA, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; numB);

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mod(&lt;span&gt;int&lt;/span&gt; numA, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; numB);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;2. 业务类&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
package com.lxl.www.aop.interfaceAop;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;业务类，也是目标对象&lt;/span&gt;
&lt;span&gt;
import com.lxl.www.aop.Calculate;

import org.springframework.aop.framework.AopContext;
import org.springframework.stereotype.Service;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 业务实现类 -- 基础计算器
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt;&lt;strong&gt; BaseCalculate implements IBaseCalculate&lt;/strong&gt; {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; numA, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; numB) {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;执行目标方法: add&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; numA +&lt;span&gt; numB;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; sub(&lt;span&gt;int&lt;/span&gt; numA, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; numB) {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;执行目标方法: sub&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; numA -&lt;span&gt; numB;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; multi(&lt;span&gt;int&lt;/span&gt; numA, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; numB) {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;执行目标方法: multi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; numA *&lt;span&gt; numB;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; div(&lt;span&gt;int&lt;/span&gt; numA, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; numB) {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;执行目标方法: div&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; numA /&lt;span&gt; numB;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; mod(&lt;span&gt;int&lt;/span&gt; numA, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; numB) {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;执行目标方法: mod&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; retVal =&lt;span&gt; ((Calculate) AopContext.currentProxy()).add(numA, numB);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; retVal %&lt;span&gt; numA;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;3. 通知类&lt;/h2&gt;
&lt;p&gt;前置通知&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package com.lxl.www.aop.interfaceAop;

import org.springframework.aop.MethodBeforeAdvice;
import org.springframework.stereotype.Component;

import java.lang.reflect.Method;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 定义前置通知
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseBeforeAdvice implements MethodBeforeAdvice {

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     *
     * @param method 切入的方法
     * @param args 切入方法的参数
     * @param target 目标对象
     * @throws Throwable
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; before(Method method, Object[] args, Object target) throws Throwable {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;===========进入beforeAdvice()============&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;目标对象:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; target);
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;方法名: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;method);

        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;即将进入切入点方法&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;后置通知&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package com.lxl.www.aop.interfaceAop;

import org.aspectj.lang.annotation.AfterReturning;
import org.springframework.aop.AfterAdvice;
import org.springframework.aop.AfterReturningAdvice;
import org.springframework.stereotype.Component;

import java.lang.reflect.Method;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseAfterReturnAdvice implements AfterReturningAdvice {

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     *
     * @param returnValue 切入点执行完方法的返回值，但不能修改
     * @param method 切入点方法
     * @param args 切入点方法的参数数组
     * @param target 目标对象
     * @throws Throwable
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;==========进入afterReturning()=========== \n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;切入点方法执行完成&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;后置通知--目标对象:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; target);
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;后置通知--方法名: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;method);
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;后置通知--方法入参: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt; args.toString());
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;后置通知--方法返回值: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt; returnValue);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;异常通知&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package com.lxl.www.aop.interfaceAop;

import org.springframework.aop.ThrowsAdvice;
import org.springframework.stereotype.Component;

import java.lang.reflect.Method;
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseAfterThrowsAdvice implements ThrowsAdvice {

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * @param method    可选：切入的方法
     * @param args      可选：切入的方法的参数
     * @param target    可选：目标对象
     * @param throwable 必填 : 异常子类，出现这个异常类的子类，则会进入这个通知。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterThrowing(Method method, Object[] args, Object target, Throwable throwable) {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;出错啦&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;环绕通知&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package com.lxl.www.aop.interfaceAop;

import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;
import org.springframework.stereotype.Component;

import java.lang.reflect.Method;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 环绕通知
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseAroundAdvice implements MethodInterceptor {

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * invocation ：连接点
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object invoke(MethodInvocation invocation) throws Throwable {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;===========around环绕通知方法 开始===========&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用目标方法之前执行的动作&lt;/span&gt;
        System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;环绕通知--调用方法之前: 执行&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用方法的参数&lt;/span&gt;
        Object[] args =&lt;span&gt; invocation.getArguments();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用的方法&lt;/span&gt;
        Method method =&lt;span&gt; invocation.getMethod();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取目标对象&lt;/span&gt;
        Object target =&lt;span&gt; invocation.getThis();
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入参数:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + args[&lt;span&gt;0&lt;/span&gt;] + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + method + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; target);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行完方法的返回值：调用proceed()方法，就会触发切入点方法执行&lt;/span&gt;
        Object returnValue =&lt;span&gt; invocation.proceed();

        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;环绕通知--调用方法之后: 执行&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
      
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输出参数：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + args[&lt;span&gt;0&lt;/span&gt;] + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + method + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + target + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; returnValue);

        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;===========around环绕通知方法  结束===========&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; returnValue;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;4. 自定义切点&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package com.lxl.www.aop.interfaceAop;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 切点
 *
 * 继承NameMatchMethodPointcut类，来用方法名匹配
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
import org.springframework.aop.support.NameMatchMethodPointcut;
import org.springframework.stereotype.Component;

import java.lang.reflect.Method;

@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Pointcut extends NameMatchMethodPointcut {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; final &lt;span&gt;long&lt;/span&gt; serialVersionUID = &lt;span&gt;3990456017285944475L&lt;/span&gt;&lt;span&gt;;

    @SuppressWarnings(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rawtypes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; boolean matches(Method method, Class targetClass) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置单个方法匹配&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.setMappedName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置多个方法匹配&lt;/span&gt;
        String[] methods = { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
      
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;也可以用“ * ” 来做匹配符号
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; this.setMappedName(&quot;get*&quot;);&lt;/span&gt;
      
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setMappedNames(methods);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; super.matches(method, targetClass);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;5. 配置&lt;strong&gt;xml文件&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;?&amp;gt;
&amp;lt;beans xmlns=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/beans&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:xsi&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.w3.org/2001/XMLSchema-instance&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:p&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:context&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/context&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:aop&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/aop&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
       xsi:schemaLocation&lt;/span&gt;=&lt;span&gt;&quot;
&lt;/span&gt;          http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans&lt;/span&gt;
          http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans-3.0.xsd&lt;/span&gt;
&lt;span&gt;
          http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context&lt;/span&gt;
          http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context/spring-context-3.0.xsd&lt;/span&gt;
&lt;span&gt;
         http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop&lt;/span&gt;
          http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop/spring-aop-3.0.xsd&quot;&lt;/span&gt;
&amp;gt;

    &amp;lt;!-- ==============================aop配置================================ --&amp;gt;
    &amp;lt;!-- 声明一个业务类 --&amp;gt;
    &amp;lt;bean id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baseCalculate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.lxl.www.aop.interfaceAop.BaseCalculate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;

    &amp;lt;!-- 声明通知类 --&amp;gt;
    &amp;lt;bean id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baseBefore&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.lxl.www.aop.interfaceAop.BaseBeforeAdvice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
    &amp;lt;bean id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baseAfterReturn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.lxl.www.aop.interfaceAop.BaseAfterReturnAdvice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
    &amp;lt;bean id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baseAfterThrows&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.lxl.www.aop.interfaceAop.BaseAfterThrowsAdvice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
    &amp;lt;bean id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baseAround&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.lxl.www.aop.interfaceAop.BaseAroundAdvice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;

    &amp;lt;!-- 指定切点匹配类 --&amp;gt;
    &amp;lt;bean id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pointcut&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.lxl.www.aop.interfaceAop.Pointcut&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;

    &amp;lt;!-- 包装通知，指定切点 --&amp;gt;
    &amp;lt;bean id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;matchBeforeAdvisor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;org.springframework.aop.support.DefaultPointcutAdvisor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;property name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pointcut&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;&lt;span&gt;ref&lt;/span&gt; bean=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pointcut&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;property name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;advice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;&lt;span&gt;ref&lt;/span&gt; bean=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baseBefore&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!-- 使用ProxyFactoryBean 产生代理对象 --&amp;gt;
    &amp;lt;bean id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;businessProxy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;org.springframework.aop.framework.ProxyFactoryBean&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;!-- 代理对象所实现的接口 ，如果有接口可以这样设置 --&amp;gt;
        &amp;lt;property name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;proxyInterfaces&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;value&amp;gt;com.lxl.www.aop.interfaceAop.IBaseCalculate&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;

        &amp;lt;!-- 设置目标对象 --&amp;gt;
        &amp;lt;property name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;target&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;&lt;span&gt;ref&lt;/span&gt; bean=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baseCalculate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;!-- 代理对象所使用的拦截器 --&amp;gt;
        &amp;lt;property name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;interceptorNames&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;list&amp;gt;
                &amp;lt;value&amp;gt;matchBeforeAdvisor&amp;lt;/value&amp;gt;
                &amp;lt;value&amp;gt;baseAfterReturn&amp;lt;/value&amp;gt;
                &amp;lt;value&amp;gt;baseAround&amp;lt;/value&amp;gt;
            &amp;lt;/list&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;6. 方法入口&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package com.lxl.www.aop.interfaceAop;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InterfaceMainClass{

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ApplicationContext context &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aop/aop.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        BaseCalculate calculate &lt;/span&gt;= (BaseCalculate) context.getBean(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baseCalculate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        calculate.add(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;各种类型通知的执行顺序: &lt;strong&gt;前置方法会在切入点方法之前执行，后置会在切入点方法执行之后执行，环绕则会在切入点方法执行前执行同事方法结束也会执行对应的部分。主要是调用proceed()方法来执行切入点方法。来作为环绕通知前后方法的分水岭&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在xml 配置 businessProxy这个bean的时候，ProxyFactoryBean类中指定了，proxyInterfaces参数。这里把他配置了IBaseCalculate接口。因为在项目开发过程中，往往业务类都会有对应的接口，以方便利用IOC解耦。但Spring AOP却也能支持没有接口的代理。这就是为什么需要导入cglib.jar包了。看过spring的源码，&lt;span&gt;&lt;strong&gt;知道在目标切入对象如果有实现接口，spring会默认使用jdk动态代理来实现代理类。如果没有接口，则会通过cglib来实现代理类。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　&lt;/em&gt;这个业务类现在有 前置通知，后置通知，环绕三个通知同时作用，可能以及更多的通知进行作用。那么这些通知的执行顺序是怎么样的？就这个例子而言，同时实现了三个通知。在例 子xml中，则显示执行before通知，然后执行around的前处理，执行切点方法，再执行return处理。最后执行around的后处理。经过测 试，知道spring 处理顺序是按照xml配置顺序依次处理通知，以队列的方式存放前通知，以压栈的方式存放后通知。所以是前通知依次执行，后通知到切入点执行完之后，从栈里 在后进先出的形式把后通知执行。&lt;br/&gt;　　在实现过程中发现通知执行对应目标对象的整个类中的方法，如何精确到某个方法，则需要定义一个切点匹配的方式：spring提供了方法名匹配或正则方式来匹配。然后通过DefaultPointcutAdvisor来包装通知，指定切点。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;　使用接口方式配置起来，可见代码还是非常的厚重的，定义一个切面就要定义一个切面类，然而切面类中，就一个通知方法，着实没有必要。所以Spring提供了，依赖aspectj的schema配置和基于aspectj 注解方式。这两种方式非常简单方便使用，也是项目中普遍的使用方式。&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 06 Dec 2020 22:59:00 +0000</pubDate>
<dc:creator>盛开的太阳</dc:creator>
<og:description>Spring 提供了很多的实现AOP的方式：Spring 接口方式，schema配置方式和注解. 本文重点介绍Spring使用接口方式实现AOP. 研究使用接口方式实现AOP, 以了解为目的. 更好地</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ITPower/p/14095453.html</dc:identifier>
</item>
<item>
<title>Zabbix监控使用进阶 - Praywu</title>
<link>http://www.cnblogs.com/hgzero/p/14092120.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hgzero/p/14092120.html</guid>
<description>&lt;h2&gt;1. Zabbix基于SNMP监控&lt;/h2&gt;
&lt;h3&gt;1.1 zabbix-web所能指定的监控方式&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
ssh/&lt;span&gt;telnet

agent：master&lt;/span&gt;/&lt;span&gt;agent

SNMP：Simple Network Management Protocol 

IPMI：Intelligent Platform Management Interface 智慧平台管理接口
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 原本是一种Interl架构的企业系统的周边设备所采用的一种工业标准&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; IPMI也是一个开放的免费标准，使用者无需支付额外的费用即可使用此标准&lt;/span&gt;
&lt;span&gt;
JMX：Java Management eXtension （Java管理扩展）
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用于通过Java自己的接口对java程序进行监控&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 监控JVM虚拟机&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; zabbix-java-gateway用于获取监控数据&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果在服务器端定义Type为Trapper，那么客户端可以向服务器端发送任意类型的数据&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 服务端收到把它保存下来就可以了&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1.2 SNMP概述&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）snmp协议用途&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SNMP：Simple Network Management Protocol 简单网络管理协议（非常古老的协议）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用于网络管理的协议&lt;/li&gt;
&lt;li&gt;SNMP用于网络设备的管理：交换机、路由器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;版本：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;v1：1989&lt;/li&gt;
&lt;li&gt;v2c：1993&lt;/li&gt;
&lt;li&gt;v3：1998&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2）snmp的组件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MIB：Management Information Base 管理信息库（每一个agent都有一个MIB库）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定义了所有可被管理对方的集合，而且还额外定义了被管理对象的名称、访问权限、数据类型等属性&lt;/li&gt;
&lt;li&gt;实现了能够定义双方可接受的监控组件以及监控组件中数据存储格式的一个组件&lt;/li&gt;
&lt;li&gt;还能实现将每一个被管理对象的ID （Object ID，OID）对应到名称的转换&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;MIB视图：MIB库的子集&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;授权：将某MIB视图与某Community绑定来实现&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;SMI：MIB表示符号&lt;/p&gt;
&lt;p&gt;SNMP协议本身&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）snmp通信方式&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; NMS端&lt;/span&gt;
&lt;span&gt;“读”（get，getnext） 操作：管理员向设备获取数据
“写” （set）操作：管理员向设备执行设置操作
“Trap”（trap）操作：设备需要在重要状况改变的时候，向管理员通报事件的发生

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Agent端&lt;/span&gt;
Response：返回一个或多个参数值
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4）所使用的端口&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Agent：161/udp&lt;/li&gt;
&lt;li&gt;NMS：162/dup&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;5）工作模式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;NMS端向agent端采集数据（NMS表示监控节点）&lt;/li&gt;
&lt;li&gt;agent端向NMS端报告数据&lt;/li&gt;
&lt;li&gt;NMS请求agent修改配置&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;1.3 Linux上启用snmp&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 安装相关的程序包&lt;/span&gt;
yum install -y net-snmp net-snmp-utils net-snmp-&lt;span&gt;libs

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义配置文件&lt;/span&gt;
vim /etc/snmp/&lt;span&gt;snmpd.conf
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 为了方便，干脆就定义成 .1.3.6.1.2.1   ，把最后一个1去掉&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 启动服务&lt;/span&gt;
systemctl start snmpd      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 被监控端开启的服务，监听在 161/udp 上&lt;/span&gt;
systemctl start snmptrapd  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 监控端开启的服务（如果允许被监控端启动主动监控时启用）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1.4 snmp配置文件&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）配置文件概览&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278240/202012/1278240-20201206122155352-1657587957.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;定义认证符，将社区名称&quot;public&quot;映射为&quot;安全名称&quot;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;md-plain&quot;&gt;将安全名称映射到一个组名&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;为我们创建一个视图，让我们的团队有权利&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;2）OID（Object ID）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;1.3.6.1.2.1&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后一个1才表示跟Internet相关，从这里开始定义一台主机的相关对象，具体有：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;：system
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.3.6.1.2.1.1&lt;/span&gt;

2&lt;span&gt;：interface
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.3.6.1.2.1.2&lt;/span&gt;

4&lt;span&gt;：ip
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.3.6.1.2.1.4&lt;/span&gt;

6&lt;span&gt;：tcp
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.3.6.1.2.1.6&lt;/span&gt;

7&lt;span&gt;：udp
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.3.6.1.2.1.7&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1.5 配置SNMP监控&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）配置并启动snmp&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 修改配置文件&lt;/span&gt;
[root@c7_110 ~]&lt;span&gt;# &lt;strong&gt;vim /etc/snmp/snmpd.conf&lt;/strong&gt;&lt;/span&gt;
view    systemview    included   .1.3.6.1.2.1.1&lt;span&gt;
view    systemview    included   .&lt;/span&gt;1.3.6.1.2.1.2      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 网络接口的相关数据&lt;/span&gt;
view    systemview    included   .1.3.6.1.4.1.2021   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 系统资源负载，memory, disk io, cpu load &lt;/span&gt;
view    systemview    included   .1.3.6.1.2.1.25
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果不想定义这么多，为了方便，可以直接定义一个 .1.3.6.1.2.1&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 然后启动snmp&lt;/span&gt;
[root@c7_110 ~]&lt;span&gt;# &lt;strong&gt;systemctl start snmpd&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2）添加一个snmp接口并配置templates&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278240/202012/1278240-20201206123831740-815349019.png&quot; alt=&quot;&quot; width=&quot;758&quot; height=&quot;392&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1278240/202012/1278240-20201206125106611-566988350.png&quot; alt=&quot;&quot; width=&quot;754&quot; height=&quot;324&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278240/202012/1278240-20201206125619220-109605343.png&quot; alt=&quot;&quot; width=&quot;921&quot; height=&quot;377&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2. Zabbix基于JMX监控&lt;/h2&gt;
&lt;h3&gt;2.1 JMX概述&lt;/h3&gt;
&lt;p&gt;Java虚拟机（JVM）具有内置的插件，使得能够使用JMX监视和管理它，还可以使用JMX监视工具化的应用程序&lt;/p&gt;
&lt;p&gt;JMX（Java Management Extensions）Java管理扩展&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278240/202012/1278240-20201206125748579-1118528037.png&quot; alt=&quot;&quot; width=&quot;316&quot; height=&quot;203&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.2 JMX监控配置过程&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）zabbix-java-gateway主机设置&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在某主机上（不一定要是在Zabbix_Server上）安装zabbix-java-gateway程序包&lt;/span&gt;
yum install -y zabbix-java-&lt;span&gt;gateway

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对zabbix-java-gateway进行配置，也可以不用配置，直接启动&lt;/span&gt;
vim /etc/zabbix/&lt;span&gt;zabbix_java_gateway.conf
　　Listen_IP&lt;/span&gt;=10.0.0.110  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 监听地址，可修改成0.0.0.0&lt;/span&gt;
　　Listen_PORT=10052     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 监听zabbix_java进程的端口，默认是10052&lt;/span&gt;
　　TIMEOUT=10            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; zabbix_java的超时时间&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 启动zabbix-java-gateway&lt;/span&gt;
systemctl start zabbix-java-gateway.service
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2）配置zabbix-server访问java-gateway&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre readability=&quot;4&quot;&gt;
JavaGateway=10.0.0.110   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;即 zabbix server IP地址&lt;/span&gt;
JavaGatewayPort=10052&lt;span&gt;
StartJavaPollers&lt;/span&gt;=5  &lt;span&gt;#&lt;/span&gt;&lt;span readability=&quot;2&quot;&gt; 与启动进程轮询个数&lt;p&gt;# 配置完成之后需要重启zabbix-server&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3）开启JMX远程监控&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
vim /usr/local/tomcat/bin/catalina.sh  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果是yum安装的tomcat，要在/etc/sysconfig/tomcat中修改&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;启用JVM接口，默认没有启用&lt;/span&gt;
export CATALINA_OPTS=$CATALINA_OPTS &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-Djava.rmi.server.hostname=10.0.0.110 &lt;/span&gt;
    -Djavax.management.builder.initial= -Dcom.sun.management.jmxremote=&lt;span&gt;true   
    &lt;/span&gt;-Dcom.sun.management.jmxremote.port=12345   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里可能需要修改    &lt;/span&gt;
    -Dcom.sun.management.jmxremote.ssl=&lt;span&gt;false  
    &lt;/span&gt;-Dcom.sun.management.jmxremote.authenticate=false&lt;span&gt;&quot;&lt;/span&gt;    

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;##&lt;/span&gt;
&lt;span&gt;jmx[object_name,attribute_name]
object name        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 它代表MBean的对象名称&lt;/span&gt;
attribute name -   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一个MBean属性名称，可选的复合数据字段名称以点分隔&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 示例：jmx[&quot;java.lang:type=Memory&quot;,&quot;HeapMemoryUsage.used&quot;]&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 配置完成后需要重启tomcat&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4）在web上定义JMX监控&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和SNMP相同，只需要定义一个JMX Interface即可，然后添加一个JMX的templates，其他操作完全相同&lt;/p&gt;
&lt;h3&gt;2.3 从外部导入Templates模板&lt;/h3&gt;
&lt;h2&gt;3. Zabbix分布式监控 &lt;/h2&gt;
&lt;h3&gt;3.1 分布式监控概述&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）Zabbix的三种架构&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Server-agent&lt;/li&gt;
&lt;li&gt;Server-Node-agent：使用节点（node）&lt;/li&gt;
&lt;li&gt;Server-Proxy-agent：使用代理（proxy）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;zabbix能高效的监控分布式IT架构，在大型环境中zabbix提供两种解决方案：proxy和node&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2） Proxy or Node&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代理（proxy）用于本区域数据搜集，并将数据发送给server&lt;/p&gt;
&lt;p&gt;节点（node）提供完整的zabbix server用以建立分布式监控中的层级&lt;/p&gt;
&lt;h3&gt;3.2 使用节点（node）&lt;/h3&gt;
&lt;p&gt;节点（node）提供完整的Zabbix Server用以建立分布式监控中的层级&lt;/p&gt;
&lt;p&gt;Node本身是一台server，它有有整的web页面，完整的数据库，它将数据源源不断的传送给Master&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;解决host过多时单台Server面临性能瓶颈的问题&lt;/li&gt;
&lt;li&gt;使用多个instance，每个instance是独立的一套zabbix，有database和Frontent（optional）&lt;/li&gt;
&lt;li&gt;支持热插播，Node和Server的连接可以随时断开，但不影响Node的正常运行&lt;/li&gt;
&lt;li&gt;Node定时给Server发送configuration、history、event&lt;/li&gt;
&lt;li&gt;Server定时给Node发送configuration&lt;/li&gt;
&lt;li&gt;所有配置变更只能在Node节点操作，不能在Server操作&lt;/li&gt;
&lt;li&gt;支持树状结构，Node又可以是一个Server&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;3.3 使用代理（proxy）&lt;/h3&gt;
&lt;p&gt;代理（proxy）用于本区域数据手机，并将数据发送给server&lt;/p&gt;
&lt;p&gt;Proxy只有一个proxy的daemon进程，Proxy也有自己的数据库，但它的数据库只会保存一定时间的数据，它与Master通信是将一批信息打包后发送到Master，Master将这些数据merge如Master数据库&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Proxy不会向Server同步 configuration ，只会接收&lt;/li&gt;
&lt;li&gt;Proxy的数据库定时会将数据传送该Server，Proxy本地数据库只保存最近没有发送的数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Master-Proxy相比Master-Node的优先：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Proxy压力小，数据库只存储一定时间数据&lt;/li&gt;
&lt;li&gt;Master压力变小，数据不是源源不断获取，减小IO压力&lt;/li&gt;
&lt;li&gt;架构更清晰，易维护&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;3.4 Server-Proxy-agent配置示例&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）在proxy主机上安装软件包&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
yum install -y zabbix-proxy zabbix-proxy-mysql zabbix-get zabbix-agent zabbix-sender
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2）为proxy创建一个数据库并授权&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建数据库&lt;/span&gt;
&lt;span&gt;create database zabbix_proxy character set utf8;

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建用户并授权&lt;/span&gt;
grant all on zabbix_proxy.* to zbxuser@&lt;span&gt;'10.0.%&lt;/span&gt;&lt;span&gt;.%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; identified by &lt;span&gt;'&lt;/span&gt;&lt;span&gt;woshiniba&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 刷新权限&lt;/span&gt;
flush privileges
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3）导入sql文件&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;zabbix-proxy-mysql 包里面带有&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278240/202012/1278240-20201206200241510-103976216.png&quot; alt=&quot;&quot; width=&quot;398&quot; height=&quot;248&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 复制并解压&lt;/span&gt;
cp /usr/share/doc/zabbix-proxy-mysql-3.4.4/schema.sql.gz ./  
gzip -&lt;span&gt;d schema.sql.gz 

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导入数据，导入到刚刚建好的zabbix_proxy库中&lt;/span&gt;
mysql -root -p zabbix_proxy &amp;lt; schema.sql 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4）配置并启用zabbix-proxy&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;## 配置zabbix-proxy&lt;/span&gt;
vim &lt;strong&gt;&lt;span&gt;/etc/zabbix/&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;zabbix_proxy.conf&lt;/span&gt;&lt;/strong&gt;

Server&lt;/span&gt;=10.0.0.202             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; server 的IP&lt;/span&gt;
ServerPort=10051              &lt;span&gt;#&lt;/span&gt;&lt;span&gt; server 的端口&lt;/span&gt;
&lt;span&gt;
Hostname&lt;/span&gt;=zbxproxy.hgzero.com  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 主机名&lt;/span&gt;
ListenPort=10051              &lt;span&gt;#&lt;/span&gt;&lt;span&gt; proxy自己的监听端口&lt;/span&gt;
EnableRemoteCommands=1        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 允许远程命令&lt;/span&gt;
LogRemoteCommands=1           &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录远程命令的日志&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 数据的配置&lt;/span&gt;
DBHost=10.0.0.88             &lt;span&gt;
DBName&lt;/span&gt;=&lt;span&gt;zabbix_proxy 
DBUser&lt;/span&gt;=&lt;span&gt;zbxuser
DBPassword&lt;/span&gt;=&lt;span&gt;woshiniba

ConfigFrequency&lt;/span&gt;=30      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 多长时间，去服务端拖一次有自己监控的操作配置；为了实验更快的生效，这里设置30秒，默认3600s&lt;/span&gt;
DataSenderFrequency=1   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 每一秒向server 端发一次数据，发送频度&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;## 启动zabbix-proxy&lt;/span&gt;
systemctl start zabbix-proxy
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;5）通过proxy代理的节点上操作&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;假设有一台节点node2，通过proxy代理&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在node2的zabbix_agent配置文件中填入Zabbix Server和Proxy的地址&lt;/span&gt;
vim /etc/zabbix/&lt;span&gt;zabbix_agentd.conf
    Server&lt;/span&gt;=10.0.0.88,10.0.0.202&lt;span&gt;
    ServerActive&lt;/span&gt;=10.0.0.88,10.0.0.202
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;6）在web上创建配置agent 代理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278240/202012/1278240-20201206211631389-679202823.png&quot; alt=&quot;&quot; width=&quot;692&quot; height=&quot;212&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278240/202012/1278240-20201206212047314-82526932.png&quot; alt=&quot;&quot; width=&quot;711&quot; height=&quot;331&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; 这个时候再创建Host时，就可以看到刚刚配置的proxy了，可以选择是否通过proxy来监控&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278240/202012/1278240-20201206212329357-1124181341.png&quot; alt=&quot;&quot; width=&quot;696&quot; height=&quot;570&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;4. Zabbix通过微信发告警信息&lt;/h2&gt;
&lt;h3&gt;4.1 注册企业微信并配置&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）注册企业微信&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278240/202012/1278240-20201206215625762-232118513.png&quot; alt=&quot;&quot; width=&quot;468&quot; height=&quot;386&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; 注册成功后进入后台进行配置&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2）添加告警组并添加成员&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278240/202012/1278240-20201206220614722-618042774.png&quot; alt=&quot;&quot; width=&quot;687&quot; height=&quot;471&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278240/202012/1278240-20201206220712794-1894893219.png&quot; alt=&quot;&quot; width=&quot;825&quot; height=&quot;188&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）记录企业ID&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278240/202012/1278240-20201206221309257-140049898.png&quot; alt=&quot;&quot; width=&quot;731&quot; height=&quot;559&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4）创建应用并&lt;span class=&quot;md-plain md-expand&quot;&gt;填写相关信息&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278240/202012/1278240-20201206222226256-981703315.png&quot; alt=&quot;&quot; width=&quot;719&quot; height=&quot;521&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1278240/202012/1278240-20201206222405157-90575194.png&quot; alt=&quot;&quot; width=&quot;709&quot; height=&quot;371&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1278240/202012/1278240-20201206223244593-647401717.png&quot; alt=&quot;&quot; width=&quot;723&quot; height=&quot;364&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4.2 配置Zabbix Server&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）确认刚刚记录的信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;告警组用户的账号、企业ID、创建应用的Secret、Agentld&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）下载消息推送脚本并测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下载脚本后，将脚本保存在 /usr/lib/zabbix/alertscripts 后，修改权限及属主属组：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
chmod 755&lt;span&gt; wechat
chown zabbix.zabbix wechat&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试脚本：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
[root@c7_node_02 alertscripts]&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&lt;span&gt; ./wechat --corpid=wwd43fee2ab4dbfb21&lt;/span&gt; &lt;/span&gt;
　　　　--corpsecret=&lt;span&gt;pa2dgtdf8V0lFWwYaoG62345g_R39dodmK37RPJeOMOs 
　　　　&lt;/span&gt;--msg=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;现在在进行告警测试&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; 
　　　　--user=&lt;span&gt;hgzerowzh 
　　　　&lt;/span&gt;--agentid=1000002&lt;span&gt;
{&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;errcode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:0,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;errmsg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;invaliduser&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;}


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参数说明&lt;/span&gt;
-corpid=&lt;span&gt; 我们企业里面的id
&lt;/span&gt;--corpsecret=&lt;span&gt; 这里就是我们Secret里面的id
&lt;/span&gt;-msg=&lt;span&gt; 内容
&lt;/span&gt;-user=我们邀请用户的账号
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;注意：脚本在安放完成之后，要重启zabbix-server&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;3）在Zabbix Server上添加报警媒介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278240/202012/1278240-20201207051657864-1323746122.png&quot; alt=&quot;&quot; width=&quot;683&quot; height=&quot;484&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4）为对应的用户添加报警媒介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278240/202012/1278240-20201207051854601-1389511521.png&quot; alt=&quot;&quot; width=&quot;669&quot; height=&quot;393&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5）创建Action&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建Action时，在“操作”中选择 “Send Message”，并通过 “微信报警” 发送给用户&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1278240/202012/1278240-20201207032538526-567128015.png&quot; alt=&quot;&quot; width=&quot;766&quot; height=&quot;648&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 操作信息内容&lt;/span&gt;
&lt;span&gt;故障发生：{TRIGGER.NAME}
故障主机：{HOSTNAME1}
IP地址：{HOST.CONN} 
告警时间：{EVENT.DATE}{EVENT.TIME} 
告警等级：{TRIGGER.SEVERITY} 
告警信息：{TRIGGER.NAME} 
告警项目：{TRIGGER.KEY1} 
问题详情：{ITEM.NAME} : {ITEM.VALUE} 
当前状态：{TRIGGER.STATUS} : {ITEM.VALUE1} 
事件ID：{EVENT.ID}

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 恢复操作信息内容&lt;/span&gt;
&lt;span&gt;故障恢复：{HOSTNAME1} 已恢复！
IP地址：{HOST.CONN} 
告警时间：{EVENT.DATE}{EVENT.TIME} 
告警等级：{TRIGGER.SEVERITY} 
告警信息：{TRIGGER.NAME} 
告警项目：{TRIGGER.KEY1} 
问题详情：{ITEM.NAME} : {ITEM.VALUE} 
当前状态：{TRIGGER.STATUS} : {ITEM.VALUE1} 
事件ID：{EVENT.ID}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;6）微信接受信息查看&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主动触发事件后，来查看微信是否能接受到信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278240/202012/1278240-20201207053231744-368573767.png&quot; alt=&quot;&quot; width=&quot;252&quot; height=&quot;521&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;5. Zabbix调优相关&lt;/h2&gt;
&lt;h3&gt;5.1 Zabbix调优&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-heading&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;1）Database&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;历史数据不要保存太长时长；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;尽量让数据缓存在数据库服务器的内存中；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;2）触发器表达式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;减少使用聚合函数min(), max(), avg()；尽量使用last()，nodata()，因为聚合函数，要运算&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;数据收集：polling较慢(减少使用SNMP/agentless/agent）；&lt;span class=&quot;md-pair-s&quot;&gt;&lt;strong&gt;尽量使用trapping（agent(active）主动监控）；&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;数据类型：文本型数据处理速度较慢；&lt;span class=&quot;md-pair-s&quot;&gt;&lt;strong&gt;尽量少&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;收集类型为&lt;span class=&quot;md-pair-s&quot;&gt;&lt;strong&gt;文本&lt;/strong&gt; &lt;span class=&quot;md-plain&quot;&gt;text或string类型的数据；&lt;span class=&quot;md-pair-s&quot;&gt;&lt;strong&gt;多使用&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;类型为numeric &lt;span class=&quot;md-pair-s&quot;&gt;&lt;strong&gt;数值型数据&lt;/strong&gt; &lt;span class=&quot;md-plain&quot;&gt;的；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;5.2 zabbix服务器的进程&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-heading&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;1）服务器组件的数量&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;alerter, discoverer, escalator, http poller, hourekeeper, icmp pinger, ipmi polller, poller, trapper, configration syncer, ...

StartPollers&lt;/span&gt;=60&lt;span&gt;
StartPingers&lt;/span&gt;=10&lt;span&gt;
　　...
StartDBSyncer&lt;/span&gt;=5&lt;span&gt;
　　...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-heading&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;2）设定合理的缓存大小&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
CacheSize=&lt;span&gt;8M
HistoryCacheSize&lt;/span&gt;=&lt;span&gt;16M
HistoryIndexCacheSize&lt;/span&gt;=&lt;span&gt;4M
TrendCacheSize&lt;/span&gt;=&lt;span&gt;4M
ValueCacheSize&lt;/span&gt;=4M
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-heading&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;3）数据库优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 分表：&lt;/span&gt;
　　　　history_*&lt;span&gt;

　　　　trends&lt;/span&gt;*&lt;span&gt;

　　　　events&lt;/span&gt;*
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;5.3 其它解决方案&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 其他解决方案，grafana+collectd+influxdb&lt;/span&gt;
&lt;span&gt;grafana：展示
collectd：收集
influxdb：存储

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; prometheus&lt;/span&gt;
&lt;span&gt;exporter：收集
alertmanager:
grafana：展示&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



</description>
<pubDate>Sun, 06 Dec 2020 21:43:00 +0000</pubDate>
<dc:creator>Praywu</dc:creator>
<og:description>1. Zabbix基于SNMP监控 1.1 zabbix-web所能指定的监控方式 ssh/telnet agent：master/agent SNMP：Simple Network Manageme</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hgzero/p/14092120.html</dc:identifier>
</item>
<item>
<title>浅析 - 微信先享卡 - 木深</title>
<link>http://www.cnblogs.com/sam-zhang/p/14095426.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sam-zhang/p/14095426.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/2db7009b-8962-4569-8423-afd163f5c331.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=2v%252F1oFEzIT1qPLULD9cLFLJ%252FGAI%253D&amp;amp;Expires=1607367856&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;大家好，我是木小深，高级产品经理。我们的公众号主要是分享关于产品经理个人成长和职业发展相关的话题。今天分享的是一款基于微信支付分的营销产品-微信先享卡。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;初稿｜木深、木小深&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编辑｜牟深、Sam、Ella&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/39f48e57-2ad6-46ce-8432-3e75dab191c7.jpg?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=xBoVqlJbV8GBzMtb3Rq1m74lR4s%253D&amp;amp;Expires=1607367427&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6.5&quot;&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;疫情助推了线上零售与数字化运营的普及，微信支付助力品牌打造私域运营空间，未来也将逐渐成为品牌运营发展的新常态。&lt;/p&gt;
&lt;p&gt;目前微信先享卡已接入超过100家企业官方店铺与包括零售、餐饮、健身等多个场景，而微信支付分免押先享共计覆盖场景超过70个，上线服务1000余种，为消费者累计节省押金1000亿，降低商户坏账91%。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/0e1c147c-7eee-4f39-8560-5b6deeb50638.jpg?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=hsUpAZ8ORiertGaZH8HFs0e7gQk%253D&amp;amp;Expires=1607367428&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;产品简介&quot;&gt;产品简介&lt;/h2&gt;
&lt;h3 id=&quot;微信先享卡介绍&quot;&gt;微信先享卡介绍&lt;/h3&gt;
&lt;p&gt;根据商户定制的约定内容，用户领卡后可&lt;strong&gt;提前享受优惠&lt;/strong&gt;，提前退出或到期未完成约定则扣回优惠。&lt;/p&gt;
&lt;p&gt;约定内容可以是&lt;strong&gt;支付行为（消费次数、金额等）&lt;/strong&gt;，也可以是&lt;strong&gt;非支付行为（签到、分享好友、使用指定服务等）&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;微信先享卡价值&quot;&gt;微信先享卡价值&lt;/h3&gt;
&lt;h4 id=&quot;价值to商户&quot;&gt;价值TO商户&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;复购效果&lt;/strong&gt;提升高于同类营销产品&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;营销成本杠杆&lt;/strong&gt;最大化&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;全流程消息提醒&lt;/strong&gt;，通过微信支付公众号主动提醒用卡&lt;/li&gt;
&lt;li&gt;加入&lt;strong&gt;社交分享激励玩法&lt;/strong&gt;，提升用户触达范围和转化效果&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;价值to用户&quot;&gt;价值TO用户&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;优惠先享&lt;/li&gt;
&lt;li&gt;可随时退出，用不用都不亏&lt;/li&gt;
&lt;li&gt;完成约定可积累信用&lt;/li&gt;
&lt;li&gt;和朋友一起参与更有乐趣&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;案例数据&quot;&gt;案例数据&lt;/h2&gt;
&lt;h3 id=&quot;落地场景案例（脉动）&quot;&gt;落地场景案例（脉动）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/41ff68e6-d822-4b81-bb73-bec776beed21.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=YwutjRRJozDa8xoP32HpRqcrxZA%253D&amp;amp;Expires=1607362227&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/cfd7508d-5eb4-45af-8da6-814ba2e2c342.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=7YOoOs2pwjchi1ixY%252BfrlLDht6g%253D&amp;amp;Expires=1607362227&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;h3 id=&quot;约定内容：&quot;&gt;约定内容：&lt;/h3&gt;
&lt;p&gt;约定15天内购买脉动单品3次&lt;/p&gt;
&lt;h3 id=&quot;奖励内容：&quot;&gt;奖励内容：&lt;/h3&gt;
&lt;p&gt;每次满4元立减1.5元&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;h3 id=&quot;数据效果：（0630-0727）&quot;&gt;数据效果：（06.30-07.27）&lt;/h3&gt;
&lt;p&gt;开卡使用率----------------68%&lt;/p&gt;
&lt;p&gt;完成约定率----------------46%&lt;/p&gt;
&lt;p&gt;人均履约次数--------------2.8次&lt;/p&gt;
&lt;p&gt;优惠券核销率※------------59%&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;※ 同期营销方式核销率：&lt;br/&gt;扫码领券 72%、小程序领券25%、支付有礼4%、附近发券3%&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;h3 id=&quot;复购率&quot;&gt;复购率&lt;/h3&gt;
&lt;p&gt;145%↑ （开通用户）&lt;/p&gt;
&lt;p&gt;129%↑ （履约用户）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/e53c1488-af53-4475-b94f-4b47778338ad.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=pfBe4pcnlo9Hy%252FiCMsuQ8K9Aak8%253D&amp;amp;Expires=1607363223&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;h3 id=&quot;用户消费总额&quot;&gt;用户消费总额&lt;/h3&gt;
&lt;p&gt;179% ↑ （开通用户）&lt;/p&gt;
&lt;p&gt;169% ↑ （履约用户）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/af606e94-4a9b-4e0b-8128-e1f6c353165b.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=9T4JWJNtRBGrz45OPNjBbjy6rrw%253D&amp;amp;Expires=1607363224&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;h3 id=&quot;tips：&quot;&gt;Tips：&lt;/h3&gt;
&lt;p&gt;活动前：6月02日-6月29日&lt;/p&gt;
&lt;p&gt;活动期：6月30日-7月27日&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;覆盖情况&quot;&gt;覆盖情况&lt;/h3&gt;
&lt;p&gt;合作案例覆盖零售、餐饮、品牌电商、话费流量、本地生鲜、运动健身、美妆、美容美发、家居、加油出行等十几个场景&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/a5b73731-64f7-4880-984e-8b9cf088d814.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=%252Bh5aBRWg2xaUB%252BssCH64LpYxuSI%253D&amp;amp;Expires=1607363672&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/7a7abbdd-7786-4250-affc-daa0abc14bc4.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=Kxct6kcceKFzFxAwFoxyu6EdNS0%253D&amp;amp;Expires=1607363672&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;落地案例（小程序电商）&quot;&gt;落地案例（小程序电商）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;零食：洽洽&quot;&gt;零食：洽洽&lt;/h3&gt;
&lt;p&gt;约定30天内消费3次&lt;/p&gt;
&lt;p&gt;先享每笔8.8折优惠&lt;/p&gt;
&lt;p&gt;人均消费频次&lt;strong&gt;59%↑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;人均消费总额&lt;strong&gt;67%↑&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/4d4e547b-eda3-4127-a3ae-4ff5b6479fb5.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=U5Fk5Xy2H2n5P8VO8nEOhKfaDps%253D&amp;amp;Expires=1607363861&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;日用品：abc&quot;&gt;日用品：ABC&lt;/h3&gt;
&lt;p&gt;约定60天内消费2次&lt;/p&gt;
&lt;p&gt;先享每笔9.8折优惠&lt;/p&gt;
&lt;p&gt;人均消费频次&lt;strong&gt;42%↑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;人均消费总额&lt;strong&gt;36%↑&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/847bfe5b-9561-4d63-b71d-c10e78023479.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=iRvXAXZOSIrZkZb3xZdgegnFNWI%253D&amp;amp;Expires=1607364079&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;饮品：meco&quot;&gt;饮品：Meco&lt;/h3&gt;
&lt;p&gt;约定30天内消费2次&lt;/p&gt;
&lt;p&gt;先享每笔9.3折优惠&lt;/p&gt;
&lt;p&gt;人均消费频次&lt;strong&gt;28%↑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;人均消费总额&lt;strong&gt;43%↑&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/ba686884-04d5-4859-b5f6-66d8bb7d00f2.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=1PZLGTXEjqxv6bPoRdhv2Q6992M%253D&amp;amp;Expires=1607364177&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;4&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;h3 id=&quot;自助设备：乐摇摇&quot;&gt;自助设备：乐摇摇&lt;/h3&gt;
&lt;p&gt;约定30天内消费3次&lt;/p&gt;
&lt;p&gt;先享每笔8.8折优惠&lt;/p&gt;
&lt;p&gt;人均消费频次&lt;strong&gt;92%↑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;人均消费总额&lt;strong&gt;165%↑&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/47bdd17b-abde-4147-b29a-ff2337b01bf1.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=3wNcaX1%252ByLi%252BzzsgCD3HFQxLFLA%253D&amp;amp;Expires=1607364228&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;h3 id=&quot;电商平台：网易严选小程序&quot;&gt;电商平台：网易严选小程序&lt;/h3&gt;
&lt;p&gt;约定30天内邀请3个新用户领取新人福袋即可先享指定商品1分钱优惠&lt;/p&gt;
&lt;p&gt;新客下单转化率&lt;strong&gt;41%↑&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/926d81a4-078a-429a-89d9-fb81d3f1aa7e.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=%252BRtJI9zAs7kaJosU%252FOBBW2wcZ7I%253D&amp;amp;Expires=1607364307&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;产品流程&quot;&gt;产品流程&lt;/h2&gt;
&lt;h3 id=&quot;领取路径&quot;&gt;领取路径&lt;/h3&gt;
&lt;p&gt;商户小程序/app/H5/好友分享/中心化入口等多场景&lt;br/&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/c7df4b43-27b6-4c43-a7a9-e69484b8cab7.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=Gqpn4abs4tdHwoq%252BexUH84jE3pI%253D&amp;amp;Expires=1607364383&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;↓&lt;/p&gt;
&lt;p&gt;先享卡页面&lt;br/&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/9c72e566-3c4a-4588-b7c6-d8e098885d61.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=SKgHzBdyBZmxSrSJEQcINIsiS%252Bs%253D&amp;amp;Expires=1607364382&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;↓&lt;/p&gt;
&lt;p&gt;领取成功&lt;br/&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/d5d1bacf-e01d-4a2b-8b9b-0d895c639ad5.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=gt%252FDnLVu%252BbyliQz3gV%252BOek2k0E8%253D&amp;amp;Expires=1607364382&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;↓&lt;/p&gt;
&lt;p&gt;获得优惠&lt;br/&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/026a7d00-be8e-4080-bcc6-355ad9454f36.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=Jm4MasWkqN6SvKVyaiLS16toU5U%253D&amp;amp;Expires=1607364383&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;约定页面&quot;&gt;约定页面&lt;/h3&gt;
&lt;p&gt;约定进行中&lt;br/&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/a79aa99c-0eb1-44ee-8eea-d36618c08b64.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=onYdHVqtaVZ6tYrvnVitnDtO6nk%253D&amp;amp;Expires=1607364733&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;↓&lt;/p&gt;
&lt;p&gt;用户完成约定&lt;br/&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/ffb2c96c-f25e-45a5-9ae1-aeaad5ed5f05.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=Xm%252BIhf%252F2uYLgIGQeh%252BXRDUoAvsc%253D&amp;amp;Expires=1607364733&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;↓&lt;/p&gt;
&lt;p&gt;用户主动退出&lt;br/&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/89b2f7ad-4ffe-4f58-9ba6-0a9beaadc763.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=JZFD%252B7jWy32fS1Y6WU01QdlxIHI%253D&amp;amp;Expires=1607364733&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;↓&lt;/p&gt;
&lt;p&gt;优惠金额退回&lt;br/&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/18bfe597-ff78-48ec-8b6a-3682c95f7e9c.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=MpyI64v%252BL%252BOiEF7OCsYhh8hPahM%253D&amp;amp;Expires=1607364733&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;消息提醒能力&quot;&gt;消息提醒能力&lt;/h3&gt;
&lt;p&gt;领卡成功通知&lt;br/&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/e2deb2d1-375a-4224-9057-ca06d2e69722.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=ufuvKk5Opazc1mbmv5WINnEbzHE%253D&amp;amp;Expires=1607364957&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;↓&lt;/p&gt;
&lt;p&gt;状态更新通知（根据活动规则可多次提醒触达）&lt;br/&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/1cf74369-aad5-4ee8-8606-20f8b2b29a78.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=qu8vw%252B3ue96RN854C3%252Fbd6vv0Xs%253D&amp;amp;Expires=1607364976&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;↓&lt;/p&gt;
&lt;p&gt;到期前提醒（商户可自定义提醒时间）&lt;br/&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/e15dda20-e416-4160-8558-7acfd1b51ea9.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=sb2hST3uXlwg2p19cTeZ1N4a3B8%253D&amp;amp;Expires=1607364995&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;↓&lt;/p&gt;
&lt;p&gt;已完成约定提醒&lt;br/&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/4ce7773d-a274-4c5c-bb4d-f937251bbb8b.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=VoHAYR%252B248Ylx4OmJVnVn232Dj4%253D&amp;amp;Expires=1607365009&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;用户教育&quot;&gt;用户教育&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;未完成约定时，提前通知用户后，扣回优惠；扣款原因清晰，无客诉风险&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;扣款提醒&lt;br/&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/449aa36f-994d-4559-a38f-035163e7c143.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=x16%252BONO8BW%252BZmePfkhI5ZyPxu4o%253D&amp;amp;Expires=1607365106&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;↓&lt;/p&gt;
&lt;p&gt;扣款通知&lt;br/&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/2b4fa127-da18-4211-a74c-f58f76313bf1.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=dmcsok%252FE2ykVuwsvzrAx9ll6WXA%253D&amp;amp;Expires=1607365121&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;社交玩法-分享有礼&quot;&gt;社交玩法-分享有礼&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;

&lt;p&gt;用户A领取先享卡后，可将同规则的先享卡邀请给好友B，B完成自己先享卡任务后，A可获得商户的自定义奖励，邀请越多，奖励越多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/639e222e-79ee-4838-b8f6-5fe26145de82.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=gLrimNaQEYePge8dEmkUGi2zgI8%253D&amp;amp;Expires=1607365289&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;社交玩法-邀请好友&quot;&gt;社交玩法-邀请好友&lt;/h3&gt;
&lt;p&gt;邀请活动详情页&lt;br/&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/9b37f821-4a2d-46b6-b48e-51d0f0357ead.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=uDfl6mDy%252Fu4t%252F4deOMfHQ1cYP7Q%253D&amp;amp;Expires=1607365422&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;↓&lt;/p&gt;
&lt;p&gt;发送邀请&lt;br/&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/e73bacc3-b550-40ba-812c-14b5da909470.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=TlvdfC8RqVY5%252BqoqeiXWuq2mqT0%253D&amp;amp;Expires=1607365422&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;↓&lt;/p&gt;
&lt;p&gt;邀请发送成功&lt;br/&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/4dddb9ee-bd38-414d-80ff-ab364b639f19.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=t%252Fd14vMTmmWHz%252BhsMT8sbht9zA0%253D&amp;amp;Expires=1607365422&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;↓&lt;/p&gt;
&lt;p&gt;查看邀请好友奖励&lt;br/&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/21ffacbc-6bcd-49bf-8710-9e9349e05ce4.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=lVeywjMj2xFNknBV2Y1jQDW5ed0%253D&amp;amp;Expires=1607365422&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;社交玩法-领卡流程&quot;&gt;社交玩法-领卡流程&lt;/h3&gt;
&lt;p&gt;与邀请者的聊天窗&lt;br/&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/d83e0d8c-40d1-46a9-b91c-eeb48882b0d2.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=4%252B9JOUOwvh5R%252Ft1466GQGqRubtU%253D&amp;amp;Expires=1607365576&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;↓&lt;/p&gt;
&lt;p&gt;领卡页&lt;br/&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/37194d07-4e09-4de8-9b31-29faa6272796.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=zG81rbJy4s99wDQeSZtM9wK5cvE%253D&amp;amp;Expires=1607365575&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;↓&lt;/p&gt;
&lt;p&gt;领卡成功&lt;br/&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/b8fcb800-72c4-4562-9697-3fce85944aec.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=QBrskfFM%252BcLiohSRBxLdQB1ySaA%253D&amp;amp;Expires=1607365575&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;结束语&quot;&gt;结束语&lt;/h2&gt;
&lt;p&gt;疫情助推了线上零售与数字化运营的普及，微信支付助力品牌打造私域运营空间，未来也将逐渐成为品牌运营发展的新常态。目前微信先享卡已接入超过100家企业官方店铺与包括零售、餐饮、健身等多个场景，而微信支付分免押先享共计覆盖场景超过70个，上线服务1000余种，为消费者累计节省押金1000亿，降低商户坏账91%。&lt;/p&gt;
&lt;p&gt;食品零售行业一方面应当拥抱新趋势，跟上潮流，另一方面，对于品牌来说“人货场”仍然缺一不可，微信支付可以帮助企业构建更高效互动与交易的“场”，但企业想要发挥微信支付的最大优势，也应确保产品服务同样到位。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;产品经理的前进道路，不应该是一场孤独求索的旅行 。沿途那些美好的风景，有趣的人文，我愿意沉淀下来，分享与同行的你，或者是在路上的他。&lt;/p&gt;
&lt;p&gt;以上，希望对小伙伴儿们有所帮助，共勉~&lt;/p&gt;
&lt;p&gt;如果你有任何问题，请在留言区告诉我们。也请记得订阅&lt;strong&gt;公众号：木小深&lt;/strong&gt;和我们的专栏，欢迎分享给其它有需要的人。我们这期分享就到这里了，再见❤️。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/a1cdcb78-0b1a-469b-baa0-1d7e2d25c4c6.jpg?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=KxwhKKy0Ukw1n%252BJYaO%252BIPQiYVh4%253D&amp;amp;Expires=1607367428&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 06 Dec 2020 19:28:00 +0000</pubDate>
<dc:creator>木深</dc:creator>
<og:description>浅析 - 微信先享卡 大家好，我是木小深，高级产品经理。我们的公众号主要是分享关于产品经理个人成长和职业发展相关的话题。今天分享的是一款基于微信支付分的营销产品-微信先享卡。 初稿｜木深、木小深 编辑</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sam-zhang/p/14095426.html</dc:identifier>
</item>
</channel>
</rss>