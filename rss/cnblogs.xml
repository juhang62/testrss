<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>深入了解C#（TPL）之Parallel.ForEach异步  - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/13149429.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/13149429.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;最近在做项目过程中使用到了如题并行方法，当时还是有点犹豫不决，因为平常使用不多， 于是借助周末时间稍微深入了下，发现我用错了，故此做一详细记录，希望对也不是很了解的童鞋在看到本文此文后不要再犯和我同样的错误。&lt;/p&gt;
&lt;h2&gt;并行遍历异步表象&lt;/h2&gt;
&lt;p&gt;这里我们就不再讲解该语法的作用以及和正常遍历处理的区别，网上文章比比皆是，我们直接进入主题，本文所演示程序在控制台中进行。可能大部分童鞋都是如下大概这样用的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Parallel.ForEach(Enumerable.Range(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;), index =&amp;gt;&lt;span&gt;
{
    Console.WriteLine(index);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202006/589642-20200619225346004-885801998.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们采取并行方式遍历10个元素，然后结果也随机打印出10个元素，一点毛病也没有。然而我是用的异步方式，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Parallel.ForEach(Enumerable.Range(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;), &lt;span&gt;async&lt;/span&gt; index =&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; AsyncTask(index);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; AsyncTask(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i)
{
    &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Task.Delay(&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
    
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; calculate = i * &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
    
    Console.WriteLine(calculate);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; calculate;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202006/589642-20200619225912150-858325477.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们只是将并行操作更改为了异步形式，然后对每个元素进行对应处理，打印无序结果，一切也是如我们所期望，接下来我再来看一个例子，经过并行异步处理后猜猜最终字典中元素个数可能或一定为多少呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; dicts = &lt;span&gt;new&lt;/span&gt; ConcurrentDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;();

Parallel.ForEach(Enumerable.Range(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;), &lt;span&gt;async&lt;/span&gt; index =&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; AsyncTask(index);

    dicts.TryAdd(index.ToString(), result);
});

Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;element count in dictionary {dicts.Count}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202006/589642-20200619230738622-945516622.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果对该并行方法没有深入了解的话，大概率都会猜错，我们看到字典中元素为0，主要原因是用了异步后引起的，为何会这样呢？我们首先从表象上来分析，当我们在控制台上对并行方法用了异步后，你会发现编译器会告警（主函数入口已用异步标识），如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202006/589642-20200619231618551-2091339037.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们再来看看调用该并行异步方法的最终调用构造，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ParallelLoopResult ForEach&amp;lt;TSource&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt; source, Action&amp;lt;TSource&amp;gt; body);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二个参数为内置委托Action，所以我们也可以看出并不能用于异步，因为要是异步至少也是Func&amp;lt;Task&amp;gt;，比如如下方法参数形式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task AsyncDemo(Func&amp;lt;&lt;span&gt;int&lt;/span&gt;,Task&amp;gt;&lt;span&gt; func)
{
    &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; func(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;并行遍历异步本质&lt;/h2&gt;
&lt;p&gt;通过如上表象的分析我们得出并行遍历方法应该是并不支持异步（通过最终结果分析得知，表述为不能用于异步更恰当），但是在实际项目开发中我们若没有注意到该方法的构造很容易就会误以为支持异步，如我一样写完也没报错，也就草草了事。那么接下来我们反编译看下最终实际情况会是怎样的呢。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202006/589642-20200619235641262-1567081036.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进入主函数，我们已将主函数进行异步标识，所以将主函数放在状态机中执行（状态机类，&amp;lt;Main&amp;gt;d_0），这点我们毫无保留的赞同，接下来实例化字典，并通过并行遍历异步处理元素集合并将其结果尝试放入到字典中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202006/589642-20200620000505214-1588640236.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由上我们可以看到主函数是在状态机中运行且构造为AsyncTaskMethodBuilder，当我们通过并行遍历异步处理时每次都会实例化一个状态机类即如上&amp;lt;&amp;lt;Main&amp;gt;b__0&amp;gt;d，但我们发现此状态机的构造是AsyncVoidMethodBuilder，利用此状态机类来异步处理每一个元素，如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202006/589642-20200620001312502-1192496972.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终调用AsyncTask异步方法，这里我就不再截图，同样也是生成一个此异步方法的状态机类。稍加分析想必我们已经知晓结果，AsyncTaskMethodBuilder指的就是（async task），而AsyncVoidMethodBuilder指的是（async void），所以对并行遍历异步操作是将其隐式转换为async void，而不是async task，这也和我们从其构造为Action得出的结论一致，我们知道（async void）仅限于基于事件的处理程序（常见于客户端应用程序），其他情况避免用async void，也就是说将返回值放在Task或Task&amp;lt;T&amp;gt;中。当并行执行任务时，由于返回值为void，不会等待操作完成，这也就不难解释为何字典中元素个数为0。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;当时并没有过多的去了解，只是想当然的认为用了异步也没出现编译报错，但是又由于没怎么用过，我还是抱着怀疑的态度，于是再深究了下，发现用法是大错特错。通过构造仅接受为Action委托，这也就意味着根本无法等待异步操作完成，之所以能接受异步索引其本质是隐式转换为（async void），从另外一个角度看，异步主要用于IO密集型，而并行处理用于CPU密集型计算，基于此上种种一定不能用于异步，否则结果你懂的。&lt;/p&gt;
</description>
<pubDate>Sat, 20 Jun 2020 00:36:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<og:description>前言 最近在做项目过程中使用到了如题并行方法，当时还是有点犹豫不决，因为平常使用不多， 于是借助周末时间稍微深入了下，发现我用错了，故此做一详细记录，希望对也不是很了解的童鞋在看到本文此文后不要再犯和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CreateMyself/p/13149429.html</dc:identifier>
</item>
<item>
<title>Spring中基于xml的AOP - 心有玲曦遇奇缘</title>
<link>http://www.cnblogs.com/mingqi-420/p/13167414.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mingqi-420/p/13167414.html</guid>
<description>&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;1、Aop 全程是Aspect Oriented Programming 即面向切面编程，通过预编译方式和运行期动态代理实现程序功能的同一维护的一种技术。Aop是oop的延续，是软件开发中的 一个热点，也是Spring框架中一个重要的内容。是函数式编程的一个衍生范例，利用Aop可以对业务逻辑各个部分进行分割，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用行，提高了开发效率。简单的说就是把我们程序中的重复代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上已有的方法进行增强，（使用动态代理的方式实现）&lt;/p&gt;
&lt;p&gt;相关术语&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JoinPoint&lt;/strong&gt;：链接点 那些被拦截到的点，在spring中，这些点指的是方法，因为spring只支持方法类型的连接点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Pointcut&lt;/strong&gt;：切入点   是指我们要对哪些JoinPont进行拦截的定义&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Advice&lt;/strong&gt;：通知/增强  拦截到Joinpoint之后所要做的事情就是通知&lt;/p&gt;
&lt;p&gt;通知类型：前置通知、后置通知、异常通知、最终通知、环绕通知&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Introduction&lt;/strong&gt;：引介   是一种特殊的通知，在不修改类代码的前提下，Introduction可以在运行期为类动态的添加一些方法或field&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Target&lt;/strong&gt;：目标对象，代理的目标对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Weaving &lt;/strong&gt;织入   是指把增强应用到目标对象来创建新的代理对象的过程，spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proxy&lt;/strong&gt;：代理，一类类被Aop织入增强后，就产生一个结果代理类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Aspect&lt;/strong&gt;：切面   是切入点和通知（引介）的结合&lt;/p&gt;
&lt;p&gt;在 spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。&lt;/p&gt;
&lt;p&gt;基于XMl的AOP步骤&lt;/p&gt;
&lt;p&gt;1、创建Maven项目引入spring坐标&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span&gt;
         xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
         xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.mingqi&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;SpringIOC&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;pom&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-context&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;5.0.2.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.aspectj&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;aspectjweaver&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.8.7&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;junit&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;junit&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.12&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、创建业务层接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.mingqi.services;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IAccountService {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 模拟登陆账户
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; saveAccount();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 模拟更新账户
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; id
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; updateAccount(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 模拟删除账户
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; deleteAccount();

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.创建业务层实现类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.mingqi.services.impl;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.mingqi.services.IAccountService;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AccountServicesImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IAccountService {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; saveAccount() {
        System.out.println(&lt;/span&gt;&quot;执行了保存&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; updateAccount(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id) {
        System.out.println(&lt;/span&gt;&quot;执行了更新&quot;+&lt;span&gt;id);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; deleteAccount() {
        System.out.println(&lt;/span&gt;&quot;执行了删除&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、创建工具类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.mingqi.utils;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.ProceedingJoinPoint;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 用户记录日志的工具类，里面提供公共的代码
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Logger {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 用于打印日志：计划让其在切入点方法执行前执行（切入点方法就是业务层方法）
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;&lt;span&gt; beforePrintLog(){
        System.out.println(&lt;/span&gt;&quot;Logger类中的pringLog方法开始记录日志了。。。&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterReturningPrintLog()
    {
        System.out.println(&lt;/span&gt;&quot;后置通知Logger类中的beforePrintLog方法开始记录日志了。。。&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 异常通知
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterThrowingPrintLog()
    {
        System.out.println(&lt;/span&gt;&quot;异常通知Logger类中的afterThrowingPrintLog方法开始记录日志了。。。&quot;&lt;span&gt;);

    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 最终通知
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterPrintLog()
    {
        System.out.println(&lt;/span&gt;&quot;最终通知Logger类中的afterPrintLog方法开始记录日志了。。。&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 环绕通知
     * 问题  当我们配置了环绕通知以后，切入点方法没有执行，而通知方法执行了
     * 分析： 通过对比动态代理中的环绕通知代码，发现动态代理中的环绕通知有明确的切入点方法调用，而我们的代码中没有
     * 解决： Spring 框架为我们提供了一个接口：ProceedingJoinPoint。该接口有一个方法proceed（），此方法就相当于明确调用切入点的方法
     *        该接口可以作为环绕通知的参数方法，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用
     * spring中的环绕通知
     *      他是spring框架为我们提供的一种可以在代码中手动控制增强方法何时会执行的方式
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; pjp
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object aroundPringLog(ProceedingJoinPoint pjp){
        Object rtValue &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            Object[] args &lt;/span&gt;= pjp.getArgs();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到方法执行所需的参数&lt;/span&gt;
&lt;span&gt;
            System.out.println(&lt;/span&gt;&quot;Logger类中的aroundPringLog方法开始记录日志了。。。前置&quot;&lt;span&gt;);

            rtValue &lt;/span&gt;= pjp.proceed(args);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;明确调用业务层方法（切入点方法）&lt;/span&gt;
&lt;span&gt;
            System.out.println(&lt;/span&gt;&quot;Logger类中的aroundPringLog方法开始记录日志了。。。后置&quot;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rtValue;
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t){
            System.out.println(&lt;/span&gt;&quot;Logger类中的aroundPringLog方法开始记录日志了。。。异常&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuntimeException(t);
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;Logger类中的aroundPringLog方法开始记录日志了。。。最终&quot;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、创建bean配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:aop&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;/span&gt;&lt;span&gt;
       xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 配置spring的IOC，把service对象配置进来&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;accountSevice&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.mingqi.services.impl.AccountServicesImpl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; spring 中基于xml的Aop配置步骤
         1、把通知Bean也交给spring来管理
         2、使用aop：config标签表名开始aop的配置
         3、使用aop:aspect标签表明配置切面
             id属性：是给切面提供一个唯一标识
             ref属性：是指定通知类的id
         4、在aop:aspect标签的内部使用对应的标签来配置通知的类型
             我们现在的示例是让printlog方法在切入点方法执行之前执行，所以是前置通知
             aop:before:标识前置通知
                method属性： 用于指定Logger类中的方法哪个是前置通知
                pointcut属性： 用于指定切入点表达式，该表达式的含义指的是对业务层中的哪些方法增强
                切入点表达式的写法：
                   关键字：execution（表达式）
                   表达式：  访问修饰符 返回值 包名.包名.包名....类名.方法名(参数列表)
                   标准的写法： public void com.mingqi.service.impl.AccountServiceImpl.saveAccount()
                   访问修饰符可以省略：void com.mingqi.service.impl.AccountServiceImpl.saveAccount()
                   返回值可以使用通配符，标识任意返回值：* com.mingqi.service.impl.AccountServiceImpl.saveAccount()
                   包名可以使用通配符，表示任意包，但是有几级包就需要写几个*  *.*.*.*.*.AccountServiceImpl.saveAccount()
                   包名可以使用..代表当前包及其子包：* *.AccountServiceImpl.saveAccount()
                   类名和方法名都可以使用*来实现统配 * *..*.*();
                   参数列表： 可以直接写数据类型:
                                 基本类型直接写名称：int
                                 引用类型写包名.类名的方式： java.lang.String
                                可以使用通配符来标识任意类型，单必须有参数
                                可以使用..标识有无参数均可，有参数可以是任意类型

                      全通配写法：
                    * *..*.*(..)
                   实际开发中 切入点表达式的通常写法：
                          切到业务层实现类的所有方法，* com.mingqi.service.impl.*.*(..);
         &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 配置Logger类&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;logger&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.mingqi.utils.Logger&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;使用aop：config标签表名开始aop的配置&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:config&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
              &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:pointcut &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;pt1&quot;&lt;/span&gt;&lt;span&gt; expression&lt;/span&gt;&lt;span&gt;=&quot;execution(* com.mingqi.services.impl.*.*(..))&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aop:pointcut&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
              &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;使用aop:aspect标签表明配置切面&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
              &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:aspect &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;LogAdvice&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;logger&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 配置前置通知：在切入点方法执行之前执行
                     &amp;lt;aop:before method=&quot;beforePrintLog&quot; pointcut-ref=&quot;pt1&quot;&amp;gt;&amp;lt;/aop:before&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;

                     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 配置后置通知：在切入点方法正常执行之后值。它和异常通知永远只能执行一个
                          &amp;lt;aop:after-returning method=&quot;afterReturningPrintLog&quot; pointcut-ref=&quot;pt1&quot;&amp;gt;&amp;lt;/aop:after-returning&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 配置异常通知：在切入点方法执行产生异常之后执行。它和后置通知永远只能执行一个
                         &amp;lt;aop:after-throwing method=&quot;afterThrowingPrintLog&quot; pointcut-ref=&quot;pt1&quot;&amp;gt;&amp;lt;/aop:after-throwing&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 配置最终通知：无论切入点方法是否正常执行它都会在其后面执行
                        &amp;lt;aop:after method=&quot;afterPrintLog&quot; pointcut-ref=&quot;pt1&quot;&amp;gt;&amp;lt;/aop:after&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 配置环绕通知 详细的注释请看Logger类中&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:around &lt;/span&gt;&lt;span&gt;method&lt;/span&gt;&lt;span&gt;=&quot;aroundPringLog&quot;&lt;/span&gt;&lt;span&gt; pointcut-ref&lt;/span&gt;&lt;span&gt;=&quot;pt1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aop:around&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aop:aspect&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aop:config&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;6、创建测试类&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.mingqi.test;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.mingqi.services.IAccountService;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.ApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.support.ClassPathXmlApplicationContext;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SpringIoc {
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TestAccount()
    {
        ApplicationContext ac&lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;beam.xml&quot;&lt;span&gt;);
        IAccountService accountService&lt;/span&gt;=(IAccountService) ac.getBean(&quot;accountSevice&quot;&lt;span&gt;);
        accountService.saveAccount();
        accountService.updateAccount(&lt;/span&gt;22&lt;span&gt;);
        accountService.deleteAccount();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://common.cnblogs.com/images/loading.gif&quot; alt=&quot;&quot; id=&quot;uploading_image_93960&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 20 Jun 2020 00:10:00 +0000</pubDate>
<dc:creator>心有玲曦遇奇缘</dc:creator>
<og:description>1、Aop 全程是Aspect Oriented Programming 即面向切面编程，通过预编译方式和运行期动态代理实现程序功能的同一维护的一种技术。Aop是oop的延续，是软件开发中的 一个热点</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mingqi-420/p/13167414.html</dc:identifier>
</item>
<item>
<title>[白话解析] 通过实例来梳理二分类评估概念 ：混淆矩阵, Accuracy, Recall-Precision, F1 Score - 罗西的思考</title>
<link>http://www.cnblogs.com/rossiXYZ/p/13166899.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rossiXYZ/p/13166899.html</guid>
<description>&lt;p&gt;二分类评估是对二分类算法的预测结果进行效果评估。本文将构造出一个水泊梁山的具体实例带领大家梳理相关概念。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;338.16294122724&quot;&gt;


&lt;h2 id=&quot;0x00-摘要&quot;&gt;0x00 摘要&lt;/h2&gt;
&lt;p&gt;二分类评估是对二分类算法的预测结果进行效果评估。本文将构造出一个水泊梁山的具体实例带领大家梳理相关概念。&lt;/p&gt;
&lt;h2 id=&quot;0x01-本文缘由&quot;&gt;0x01 本文缘由&lt;/h2&gt;
&lt;p&gt;笔者最近在研究Alink源码，本来计划分析二分类评估，结果打开Alink相关文档发现里面给出不少概念和公式。于是本文先带领大家一起复习/熟悉其中部分概念和公式，为后续分析源码打下良好的基础。&lt;/p&gt;
&lt;p&gt;以下是Alink中 “二分类评估” 的说明。&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;支持Roc曲线，LiftChart曲线，Recall-Precision曲线绘制。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;流式的实验支持累计统计和窗口统计。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;给出整体的评估指标包括：AUC、K-S、PRC, 不同阈值下的Precision、Recall、F-Measure、Sensitivity、Accuracy、Specificity和Kappa。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些概念基本都是评价指标，这是针对模型性能优劣的一个定量指标。一种评价指标只能反映模型一部分性能，如果选择的评价指标不合理，那么可能会得出错误的结论，故而应该针对具体的数据、模型选取不同的的评价指标。&lt;/p&gt;
&lt;p&gt;接下来就分析梳理其中部分概念。&lt;/p&gt;
&lt;h2 id=&quot;0x02-例子构建&quot;&gt;0x02 例子构建&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;目标&lt;/strong&gt;：因为在招安大计上，鲁智深提出了反对意见，所以宋公明希望在梁山内部查找和鲁智深有关联的人。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;样本全体&lt;/strong&gt;：林冲，武松，史进，杨志，张青，孙二娘，呼延灼，关胜，石秀，杨雄。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;宋江对蒋敬说：贤弟你是神算子，快帮哥哥想想如何能够找出与大和尚有串联的人，&lt;/p&gt;
&lt;p&gt;蒋敬说：哥哥这个要求是 “二分类问题”（例如预测患或未患心脏病、股票涨或跌等这种只有两类情况的问题），里面门道甚多，哥哥且听我慢慢道来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;0x03-混淆矩阵&quot;&gt;0x03 混淆矩阵&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;蒋敬说：首先小弟介绍的概念是混淆矩阵，这是一个 2 维方阵，它主要用于评估二分类问题的好坏。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;31-四种分类情况&quot;&gt;3.1 四种分类情况&lt;/h3&gt;
&lt;p&gt;针对一个二分类问题，即将实例分成正类（positive）或负类（negative），在实际分类中会出现以下四种情况：&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;TN (True Negative )：算法预测为负例（N），实际上也是负例（N）的个数，即算法预测对了（True）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;FP (False Positive )：算法预测为正例（P），实际上是负例（N）的个数，即算法预测错了（False）&lt;/p&gt;
&lt;p&gt;这里指的是：实际为负例但被分类器划分为正例的实例数。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;FN (False Negative )：算法预测为负例（N），实际上是正例（P）的个数，即算法预测错了（False）&lt;/p&gt;
&lt;p&gt;这里指的是：即实际为正例但被分类器划分为负例的实例数。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;TP (True Positive )：算法预测为正例（P），实际上也是正例（P）的个数，即算法预测对了（True）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;宋江道：如此说来，“与鲁智深有关联人” 就是 TP + FP了。&lt;/p&gt;
&lt;p&gt;蒋敬说：哥哥误会了，&lt;u&gt;实际为正例的样本数应该是 TP + FN&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;这里有个记忆诀窍听小弟道来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;记忆诀窍&lt;/strong&gt;是 ：这 4 个定义由两个字母组成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第 1 个字母表示算法预测正确或者错误，即 True、False 描述的是这个分类器是否判断正确。&lt;/li&gt;
&lt;li&gt;第 2 个字母表示算法预测的结果，即 Positive、Negative 是这个分类器的分类结果。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以再次澄清：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;TP ：预测为正样本，实际也是正样本。&lt;/li&gt;
&lt;li&gt;FP ：预测为正样本，实际是负样本。&lt;/li&gt;
&lt;li&gt;FN ：预测为负样本，实际是正样本。&lt;/li&gt;
&lt;li&gt;TN：预测为负样本，实际也是负样本。&lt;/li&gt;
&lt;li&gt;P = TP + FN ：所有 &quot;&lt;u&gt;实际&lt;/u&gt;为正例&quot; 的样本数&lt;/li&gt;
&lt;li&gt;N = FP + TN ：所有 &quot;&lt;u&gt;实际&lt;/u&gt; 为负例&quot; 的样本数&lt;/li&gt;
&lt;li&gt;P~ = TP + FP ：所有 &quot;&lt;u&gt;预测&lt;/u&gt;为正例&quot; 的样本数&lt;/li&gt;
&lt;li&gt;N~ = TN + FN ：所有 &quot;&lt;u&gt;预测&lt;/u&gt;为负例&quot; 的样本数&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;32-混淆矩阵&quot;&gt;3.2 混淆矩阵&lt;/h3&gt;
&lt;p&gt;混淆矩阵是把真实值和预测值相对应的样本数量列出来的一张交叉表。这样，所有正确的预测结果都在其对角线上，所以从混淆矩阵中可以很直观地看出哪里有错误。&lt;/p&gt;
&lt;p&gt;矩阵的每一行是样本的预测分类，每一列是样本的真实分类（反过来也可以）。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;预测值 0 (与鲁智深无关联)&lt;/th&gt;
&lt;th&gt;预测值 1 (与鲁智深有关联)&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;真实值 0 (与鲁智深无关联)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;TN&lt;/td&gt;
&lt;td&gt;FP&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;真实值 1 (与鲁智深有关联)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;FN&lt;/td&gt;
&lt;td&gt;TP&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;记忆方法&lt;/strong&gt;：真实值更重要，所以真实值处在第一个维度，就是行。&lt;/p&gt;
&lt;h2 id=&quot;0x04-准确率-accuracy&quot;&gt;0x04 准确率 Accuracy&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;蒋敬说：小弟介绍的第二个概念是准确率 Accuracy。这 Accuracy 指的是预测正确的样本数量占总量的百分比。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;41-公式&quot;&gt;4.1 公式&lt;/h3&gt;
&lt;p&gt;\[Accuray = \frac {TP + TN}{TP + TN + FP + FN} = \frac {TP + TN}{P + N} \]&lt;/p&gt;
&lt;p&gt;按照我们上文的定义：&lt;u&gt;第 1 个字母表示算法预测正确或者错误，第 2 个字母表示算法预测的结果&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;所以分母是全部四种数据；分子中第一个字母是 T 表示 &quot;算法预测正确了&quot;。&lt;/p&gt;
&lt;h3 id=&quot;42-特点&quot;&gt;4.2 特点&lt;/h3&gt;
&lt;p&gt;准确率有一个&lt;strong&gt;缺点&lt;/strong&gt;，就是数据的样本不均衡，这个指标是不能评价模型的性能优劣的。&lt;/p&gt;
&lt;p&gt;假如一个测试集有正样本99个，负样本1个。我们设计的模型是个无脑模型，即把所有的样本都预测为正样本，那么模型的Accuracy为99%，看评价指标，模型的效果很好，但实际上模型没有任何预测能力。&lt;/p&gt;
&lt;h2 id=&quot;0x05-精准率-precision&quot;&gt;0x05 精准率 Precision&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;蒋敬说：小弟介绍的第三个概念是精准率，又称为&lt;strong&gt;查准率&lt;/strong&gt;，就是 “预测为正例&quot; 的那些数据里 &quot;预测正确&quot; 的数据个数。即&lt;strong&gt;在模型预测为正样本的结果中，真正是正样本所占的百分比&lt;/strong&gt;。或者说是 在预测为正样本的结果中，有多少是准确的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;51-公式&quot;&gt;5.1 公式&lt;/h3&gt;
&lt;p&gt;\[Precision = \frac {TP}{TP + FP} \]&lt;/p&gt;
&lt;p&gt;按照我们上文的定义：&lt;u&gt;第 1 个字母表示算法预测正确或者错误，第 2 个字母表示算法预测的结果&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;所以分母中, TP表示 : 算法预测正确 &amp;amp; 预测的是正例，FP表示 : 算法预测错误 &amp;amp; 预测的是正例（实际是负例）&lt;/p&gt;
&lt;h3 id=&quot;52-特点&quot;&gt;5.2 特点&lt;/h3&gt;
&lt;p&gt;这个指标比较谨慎，分类阈值较高。&lt;/p&gt;
&lt;h3 id=&quot;53-应用场景&quot;&gt;5.3 应用场景&lt;/h3&gt;
&lt;p&gt;需要尽可能地把所需的类别检测准确，而不在乎这些类别是否都被检测出来。比如对于罪犯的预测，我们希望预测结果是非常准确的，&lt;u&gt;即使放过了一些真正的罪犯，也不能错怪一个好人&lt;/u&gt;。&lt;/p&gt;
&lt;h2 id=&quot;0x06-准确率-vs-精准率&quot;&gt;0x06 准确率 VS 精准率&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;宋江说，贤弟这两个中文词长得也太像太坑爹了，哥哥我很难区别。&lt;/p&gt;
&lt;p&gt;蒋敬说：哥哥，这两个词是从英文翻译过来的，咱慢慢推敲。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;让我们看看其英文原意。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Accuracy在词典中的定义是：the quality or state of being correct or precise&lt;/li&gt;
&lt;li&gt;Precision在词典中的定义是：the quality, condition, or fact of being exact and accurate&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Accuracy首先是correct（正确），而precision首先是exact（精确，或者说确切）。首先准确，然后才谈得上精确。一个结果必须要同时符合准确与精密这两个条件，才可算是精准。&lt;/p&gt;
&lt;p&gt;这两个词也 &lt;u&gt;有点类似 偏差（bias）与方差（variance）&lt;/u&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;偏差（bias）反映了模型在样本上的期望输出与真实标记之间的差距，即模型本身的精准度，反映的是模型本身的拟合能力。这就很像 Precision。&lt;/li&gt;
&lt;li&gt;方差（variance）反映了模型在不同训练数据集下学得的函数的输出与期望输出之间的误差，即模型的稳定性，反应的是模型的波动情况。这有点像 Accuracy。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;宋江说，贤弟你这偏差，方差的，哥哥也听着像天书。&lt;/p&gt;
&lt;p&gt;蒋敬说：待小弟给哥哥找一个合适的例子。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如大概可以类比成咱射箭，准确率要看你射中靶心的概率；精准率要看你射中的是靶心区域的哪个位置。&lt;/p&gt;
&lt;h2 id=&quot;0x07-召回率-recall&quot;&gt;0x07 召回率 Recall&lt;/h2&gt;
&lt;p&gt;这是针对原始样本而言的一个评价指标。召回率又称为&lt;strong&gt;查全率&lt;/strong&gt;，就是&lt;strong&gt;在实际为正样本中，被预测为正样本所占的百分比。&lt;/strong&gt; 即所有&lt;strong&gt;正例&lt;/strong&gt;中，有多少被&lt;strong&gt;正确&lt;/strong&gt;地判定为正。&lt;/p&gt;
&lt;h3 id=&quot;71-公式&quot;&gt;7.1 公式&lt;/h3&gt;
&lt;p&gt;\[recall= \frac {𝑇𝑃}{TP+FN} = \frac {𝑇𝑃}{All\,Real\,Positive} \]&lt;/p&gt;
&lt;p&gt;按照我们上文的定义：&lt;u&gt;第 1 个字母表示算法预测正确或者错误，第 2 个字母表示算法预测的结果&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;所以分母中 TP+FN ，表示 “预测正确且预测为正样本“ + “预测错误且预测为负样本(实际是真实正例)“。即 所有 &quot;&lt;u&gt;实际&lt;/u&gt;为正例&quot; 的样本数&lt;/p&gt;
&lt;p&gt;分子是：预测正确 且 被预测为正样本。&lt;/p&gt;
&lt;h3 id=&quot;72-特点&quot;&gt;7.2 特点&lt;/h3&gt;
&lt;p&gt;召回率分类阈值较低。尽量检测数据，不遗漏数据，所谓的&lt;u&gt;宁肯错杀一千，不肯放过一个&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;我们看看英文解释，Recall : to remember sth; to make sb think of sth; to order sb to return; to ask for sth to be returned, often because there is sth wrong with it。&lt;/p&gt;
&lt;p&gt;因为Recall有记忆的意思，所以可以试着把 Recall 理解为“记忆率”。就是记忆一个事件需要多少细节，这个细节就是当我们问检索系统某一件事的所有细节时（输入检索query），检索系统能“Recall 回忆”起那些事的多少细节，通俗来讲就是“回忆的能力”。能回忆起来的细节数 除以 系统知道这件事的所有细节，就是“记忆率”，也就是recall——召回率。&lt;/p&gt;
&lt;h3 id=&quot;73-应用场景&quot;&gt;7.3 应用场景&lt;/h3&gt;
&lt;p&gt;召回率的应用场景是：需要尽可能地把所需的类别检测出来，而不在乎结果是否准确。&lt;/p&gt;
&lt;p&gt;比如对于地震的预测，我们希望每次地震都能被预测出来，这个时候可以牺牲precision。假如一共发生了10次地震，我们情愿发出1000次警报，这样能把这10次地震都涵盖进去（此时recall是100%，precision是1%），也不要发出100次警报，其中有8次地震给预测到了，但漏了2次（此时recall是80%，precision是8%）。&lt;/p&gt;
&lt;h3 id=&quot;74-sensitivity&quot;&gt;7.4 Sensitivity&lt;/h3&gt;
&lt;p&gt;sensitive = TP / P，表示的是所有正例中被分对的比例，衡量了分类器对正例的识别能力；可以看到，sensitive和Recall是一样的。&lt;/p&gt;
&lt;p&gt;\[Sensitivity=\dfrac{TP}{TP+FN} \]&lt;/p&gt;
&lt;h2 id=&quot;0x08-精准率--vs-召回率&quot;&gt;0x08 精准率 VS 召回率&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;宋江说，贤弟你给哥哥好好解释下精准率 和 召回率这两个概念&lt;/p&gt;
&lt;p&gt;蒋敬说：待小弟慢慢道来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;81-概念区别&quot;&gt;8.1 概念区别&lt;/h3&gt;
&lt;p&gt;首先，用一个图例来看看概念区别，图中椭圆就是 “预测为正类” 的样本。也能看出两个概念的定义。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850883/202006/1850883-20200620075748335-1823678697.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;82-关注点不同&quot;&gt;8.2 关注点不同&lt;/h3&gt;
&lt;p&gt;召回率是覆盖面的度量，度量有多个真实正例被预测为正例。精度是精确性的度量，表示被预测为正例的示例中实际为正例的比例。&lt;/p&gt;
&lt;p&gt;在不同的应用场景下，我们的关注点不同，例如:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在预测股票的时候，我们更关心&lt;strong&gt;精准率&lt;/strong&gt;，即我们预测升的那些股票里，真的升了有多少，因为那些我们预测升的股票都是我们投钱的。&lt;/li&gt;
&lt;li&gt;而在预测病患的场景下，我们更关注&lt;strong&gt;召回率&lt;/strong&gt;，即真的患病的那些人里我们预测错了情况应该越少越好，因为真的患病如果没有检测出来，结果其实是很严重的，之前那个无脑的算法，召回率就是 0。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;u&gt;在信息检索中，准确率和召回率是互相影响的&lt;/u&gt;，虽然两者都高是一种期望的理想情况，然而实际中常常是如果阈值较高，那么精准率会高，但是会漏掉很多数据；如果阈值较低，召回率高，但是预测的会很不准确。所以在实际中常常需要根据具体情况做出取舍，例如:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对一般搜索的情况是在保证召回率的情况下提升准确率，&lt;/li&gt;
&lt;li&gt;而如果是疾病监测、反垃圾邮件等，则是在保证准确率的条件下，提升召回率。&lt;/li&gt;
&lt;li&gt;有时候，需要兼顾两者，那么就可以用&lt;em&gt;F&lt;/em&gt;-score指标。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;83-为什么准确率和召回率是互相影响&quot;&gt;8.3 为什么准确率和召回率是互相影响&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;宋江说，看到这里，我就有一个疑问了，为什么准确率和召回率是互相影响的？&lt;/p&gt;
&lt;p&gt;蒋敬说：这个问题比较复杂&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先说大致原理。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;recall和precision是相互矛盾的。如果想要更高的recall，那么就要让模型的预测能覆盖到更多的样本，但是这样模型就更有可能犯错，也就是说precision会比较低。如果模型很保守，只能检测出它很确定的样本，那么其precision会很高，但是recall会相对低。&lt;/li&gt;
&lt;li&gt;recall（TPR）的分母是样本中正类的个数，因此样本一旦确定，其分母即为定值，也就是说recall的变化随分子增加而单调递增；precision的分母是样本中预测为正类的个数，其会随着分类阈值的变化而变化，因此Precision的变化受TP和FP的综合影响，不单调，变化情况不可预测。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;83-实例说明&quot;&gt;8.3 实例说明&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;蒋敬说：具体用真实数据说明最好，咱就真实操作下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;831-混淆矩阵&quot;&gt;8.3.1 混淆矩阵&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;样本全体&lt;/strong&gt;：林冲，武松，史进，杨志，张青，孙二娘，呼延灼，关胜，石秀，杨雄。&lt;/p&gt;
&lt;p&gt;这些好汉将会被分成四类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;TP：查找到的，相关的 （搜到的也想要的）&lt;/li&gt;
&lt;li&gt;FP：查找到的，但是不相关的 （搜到的但没用的）&lt;/li&gt;
&lt;li&gt;FN：未查找到的，但却是相关的 （没搜到，然而实际上想要的）&lt;/li&gt;
&lt;li&gt;TN：未查找到的，也不相关的 （没搜到也没用的）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们再次看看混淆矩阵：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;预测值 0 (与鲁智深无关联)&lt;/th&gt;
&lt;th&gt;预测值 1 (与鲁智深有关联)&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;真实值 0 (与鲁智深无关联)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;TN&lt;/td&gt;
&lt;td&gt;FP&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;真实值 1 (与鲁智深有关联)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;FN&lt;/td&gt;
&lt;td&gt;TP&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;832-为什么要有召回率&quot;&gt;8.3.2 为什么要有召回率&lt;/h4&gt;
&lt;p&gt;首先我们看，为什么要有召回率这个指标？&lt;/p&gt;
&lt;p&gt;在梁山好汉中查找和鲁智深有关联的人。比如有18人和鲁智深有关联，90人和鲁智深没关联。&lt;/p&gt;
&lt;p&gt;我们做个算法做预测：&lt;u&gt;就是所有好汉都预测为没联系&lt;/u&gt;。这样，90个肯定预测对了，看着准确率很高。&lt;/p&gt;
&lt;p&gt;但是这个算法对于“和鲁智深有关联的人”的预测准确率是0，所以这个算法是没有任何意义的。&lt;/p&gt;
&lt;p&gt;所以就要引入Recall。Recall就是在这18个中能找出来的，比如找出12个，则recall = 66%。&lt;/p&gt;
&lt;h4 id=&quot;833-分析&quot;&gt;8.3.3 分析&lt;/h4&gt;
&lt;p&gt;下面我们回顾下定义：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;精准率（查准率）Precision = TP / (TP+FP) ：查找到的相关好汉 / 所有被查找到的好汉。追求 精准率（查准率）意味着&lt;u&gt;查找到的好汉中，相关的越多越好，不相关的越少越好&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;召回率（查全率）Recall = TP / (TP+FN) ：查找到的相关好汉 / 全体样本中所有的相关好汉。追求 召回率（查全率）意味着&lt;u&gt;样本中的相关好汉，被查找到越多越好&lt;/u&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为什么相互制约？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;由于“查找策略”并不完美，希望更多相关的好汉被检索到时，放宽“查找策略”时，往往也会伴随出现一些不相关的结果，从而使准确率受到影响。&lt;/li&gt;
&lt;li&gt;而希望去除查找结果中的不相关好汉时，务必要将“查找策略”定的更加严格，这样也会使有一些相关的好汉不再能被查找到，从而使召回率受到影响。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;834-原始查找策略&quot;&gt;8.3.4 原始“查找策略”&lt;/h4&gt;
&lt;p&gt;蒋敬首先定的 &quot;查找策略&quot;是：桃花山 + 军官。这个容易理解，鲁智深是在桃花山落草，且本身是提辖，可能和宋军将领有私交。&lt;/p&gt;
&lt;p&gt;得到如下混淆矩阵&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;预测值 0 (与鲁智深无关联)&lt;/th&gt;
&lt;th&gt;预测值 1 (与鲁智深有关联)&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;真实值 0 (与鲁智深无关联)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;TN 石秀，杨雄，裴宣，汤隆，刘唐，陶宗旺&lt;/td&gt;
&lt;td&gt;FP 关胜，呼延灼&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;strong&gt;真实值 1 (与鲁智深有关联)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;FN 史进，杨春，陈达，周通&lt;/td&gt;
&lt;td&gt;TP 武松，杨志，张青，孙二娘&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;于是推算出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Precision = TP / (TP + FP) = 4 / (4 + 2) = 2/3

Recall = TP / (TP + FN)  = 4 / (4 + 4) = 1/2 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;835-追求召回率--放宽查找策略&quot;&gt;8.3.5 追求召回率 / 放宽“查找策略”&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;宋江道：找到的相关人太少，我们得提高召回率（查全率）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;追求 召回率（查全率）意味着&lt;u&gt;样本中所有相关的好汉，被查找到的越多越好&lt;/u&gt;，那就应该放宽“查找策略”。放宽“查找策略”时，往往也会伴随出现一些不相关的结果，从而使准确率受到影响。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;于是公明哥哥需要放宽“查找策略” ：少华山史大郎和鲁智深以前结拜过；鲁智深以前在&quot;老种经略相公&quot;麾下，种师道统帅陕西，所以鲁智深可能和西北人有交往。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;u&gt;放宽后的 &quot;查找策略&quot; 是：桃花山 + 少华山 + 军官 + 西北人（裴宣，汤隆，刘唐，陶宗旺）&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;于是得到混淆矩阵是：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;预测值 0 (与鲁智深无关联)&lt;/th&gt;
&lt;th&gt;预测值 1 (与鲁智深有关联)&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;真实值 0 (与鲁智深无关联)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;TN 石秀，杨雄&lt;/td&gt;
&lt;td&gt;FP 关胜，呼延灼，裴宣，汤隆，刘唐，陶宗旺&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;真实值 1 (与鲁智深有关联)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;FN 周通&lt;/td&gt;
&lt;td&gt;TP 武松，杨志，张青，孙二娘，史进，杨春，陈达&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;所以得到&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Precision = TP / (TP + FP) = 7 / (7 + 6) = 7/13   ---- 降低

Recall = TP / (TP + FN)  = 7 / (7 + 1) = 7/8 ---- 提高
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出来，&lt;u&gt;希望提高TP，降低FN，所以放宽“查找策略”，导致FP也增加了&lt;/u&gt;。&lt;/p&gt;
&lt;h4 id=&quot;836-追求精准率--加强查找策略&quot;&gt;8.3.6 追求精准率 / 加强“查找策略”&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;宋江道：找到的相关人太多了，我们得提高精准率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;希望 &lt;u&gt;去除查找结果中的不相关好汉&lt;/u&gt; 。这时务必要将“查找策略”定的更加严格，这样也会使有一些相关的好汉不再能被查找到，从而使召回率受到影响。&lt;/p&gt;
&lt;p&gt;所以要加强 &quot;查找策略&quot;，&lt;u&gt;新的 &quot;查找策略&quot;是：桃花山好汉中，男的。&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;于是得到混淆矩阵是：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;预测值 0 (与鲁智深无关联)&lt;/th&gt;
&lt;th&gt;预测值 1 (与鲁智深有关联)&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;strong&gt;真实值 0 (与鲁智深无关联)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;TN 石秀，杨雄，裴宣，汤隆，刘唐，陶宗旺, 关胜，呼延灼&lt;/td&gt;
&lt;td&gt;FP&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;strong&gt;真实值 1 (与鲁智深有关联)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;FN 周通，孙二娘，史进，杨春，陈达&lt;/td&gt;
&lt;td&gt;TP 武松，杨志，张青&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;所以得到&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Precision = TP / (TP + FP) = 3 / (3 + 0) = 3/3 ---- 提高

Recall = TP / (TP + FN)  = 3 / (3 + 5) = 3/8 ---  降低
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出来，&lt;u&gt;希望提高TP，降低FP，所以加强“查找策略”，导致FN也增加了&lt;/u&gt;。&lt;/p&gt;
&lt;h2 id=&quot;0x09-f-measure--f1-score&quot;&gt;0x09 F-Measure / F1 Score&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;宋江道：精准率和召回率看来是此消彼长的，这便如何是好？

蒋敬说：我们有其他指标可以考虑，比如 F1 Score
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在一些场景下要兼顾精准率和召回率，就有 F1 score。F1值就是精确值和召回率的调和均值。&lt;/p&gt;
&lt;h3 id=&quot;91-公式&quot;&gt;9.1 公式&lt;/h3&gt;
&lt;p&gt;\[F1=\dfrac{2TP}{2TP+FP+FN}=\dfrac{2\cdot Precision \cdot Recall}{Precision+Recall} \]&lt;/p&gt;
&lt;h3 id=&quot;92-特点&quot;&gt;9.2 特点&lt;/h3&gt;
&lt;p&gt;precision一定情况下反映了模型控制假阳 FP 个数的能力，Recall 值反映了正样本的检出率，F1 值综合了两方面。&lt;/p&gt;
&lt;p&gt;其实 F1 score 是精准率和召回率的调和平均数，调和平均数的性质就是，只有当精准率和召回率二者都非常高的时候，它们的调和平均才会高。如果其中之一很低，&lt;u&gt;调和平均就会被拉得接近于那个很低的数&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;为什么？&lt;u&gt;因为调和平均值上面是一个乘积，所以其更接近较小值&lt;/u&gt;，这样查准率或查全率中哪个值较小，调和平均值就更接近这个值，这样的测量指标更严格。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;记忆方法&lt;/strong&gt;：金龙鱼调和油。&lt;/p&gt;
&lt;h3 id=&quot;93-应用场景&quot;&gt;9.3 应用场景&lt;/h3&gt;
&lt;p&gt;在precision和recall两者要求同样高的情况下，可以用F1来衡量。&lt;/p&gt;
&lt;h2 id=&quot;0x10-tpr，fpr，tnr，fnr&quot;&gt;0x10 TPR，FPR，TNR，FNR&lt;/h2&gt;
&lt;p&gt;最后介绍个四胞胎，他们长得特别容易混淆。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;真正率&lt;/strong&gt; True Positive Rate，TPR = TP / (TP+FN)；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;刻画的是被分类器正确分类的正实例占所有正实例的比例。即所有&lt;strong&gt;正例&lt;/strong&gt;中，有多少被&lt;strong&gt;正确&lt;/strong&gt;地判定为正。我们能看到 TPR 就等于&lt;strong&gt;sensitivity&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;假阳性率 / 假正率&lt;/strong&gt; False Positive Rate，FPR = FP / (TN+FP)；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;刻画的是在所有实际为负类的样本中，预测错误的比例，即所有&lt;strong&gt;负例&lt;/strong&gt;中，有多少被&lt;strong&gt;错误&lt;/strong&gt;地判定为正。在医学上又称&lt;strong&gt;误诊率&lt;/strong&gt;（没有病的人被检测出有病），等于 &lt;strong&gt;1 - 特异性（Specificity）&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;真负率&lt;/strong&gt; True Negative Rate, TNR= TN / N = 1 - FPR;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;刻画的是被分类器正确分类的负实例占所有负实例的比例，也称为&lt;strong&gt;特异度(specificity)&lt;/strong&gt;。衡量了分类器对负例的识别能力。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;假阴性率&lt;/strong&gt; False Negative Rate，FNR = FN / (TP + FN)；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是在所有实际为正类的样本中，预测错误的比例，在医学上又称&lt;strong&gt;漏诊率&lt;/strong&gt;（有病的人没有被检测出来），等于 &lt;strong&gt;1 - 灵敏性（Sensitivity）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;让我们通过一张表格来总结下&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;缩写&lt;/th&gt;
&lt;th&gt;中文名称&lt;/th&gt;
&lt;th&gt;等同&lt;/th&gt;
&lt;th&gt;医学意义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;TPR&lt;/td&gt;
&lt;td&gt;真正率&lt;/td&gt;
&lt;td&gt;Sensitivity&lt;/td&gt;
&lt;td&gt;越大越好，如果为1意味着医生医术高明,诊断全对&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;FPR&lt;/td&gt;
&lt;td&gt;假阳性率&lt;/td&gt;
&lt;td&gt;1 - Specificity&lt;/td&gt;
&lt;td&gt;误诊率（没有病的人被检测出有病）。越小越好&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TNR&lt;/td&gt;
&lt;td&gt;真负率&lt;/td&gt;
&lt;td&gt;Specificity&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;FNR&lt;/td&gt;
&lt;td&gt;假阴性率&lt;/td&gt;
&lt;td&gt;1 - Sensitivity&lt;/td&gt;
&lt;td&gt;漏诊率（有病的人没有被检测出来）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这里再介绍一个&lt;strong&gt;记忆诀窍&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Sensitivity 这个词有&quot;过敏&quot;的意思，和患病对应，这样关联起来比较好记。&lt;/li&gt;
&lt;li&gt;Specificity 这个词有&quot;免疫&quot;的意思，能和未患病相关联，所以也很好记。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;0x11-tpr-vs-fpr&quot;&gt;0x11 TPR vs FPR&lt;/h2&gt;
&lt;p&gt;TPR越大越好，FPR越小越好，但这两个指标通常是矛盾的。为了增大TPR，可以预测更多的样本为正例，与此同时也增加了更多负例被误判为正例的情况。&lt;/p&gt;
&lt;p&gt;放在具体领域来理解上述两个指标。如在医学诊断中,判断有病的样本。&lt;/p&gt;
&lt;p&gt;那么尽量把有病的揪出来是主要任务,也就是第一个指标TPR,要越高越好。&lt;/p&gt;
&lt;p&gt;而把没病的样本误诊为有病的,也就是第二个指标FPR,要越低越好。&lt;/p&gt;
&lt;p&gt;不难发现,这两个指标之间是相互制约的。如果某个医生对于有病的症状比较敏感,稍微的小症状都判断为有病,那么他的第一个指标应该会很高,但是第二个指标也就相应地变高。最极端的情况下,他把所有的样本都看做有病,那么第一个指标达到1,第二个指标也为1。&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;(TPR=1，FPR=0)，为完美分类,也就是这个医生医术高明,诊断全对。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;(TPR &amp;gt; FPR)，医生的判断大体是正确的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;(TPR = FPR), 中线上的点，也就是医生全都是蒙的,蒙对一半,蒙错一半;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;(TPR &amp;lt; FPR)，这个医生说你有病，那么你很可能没有病，医生的话我们要反着听，为真庸医。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;与recall和precision相互矛盾不同，TPR和FPR呈正相关关系，也就是说TPR增大，FPR也会变大。我们希望TPR能够越大越好（为1），FPR越小越好（为0），但这通常是不可能发生的。&lt;/p&gt;
&lt;h2 id=&quot;0x12-参考&quot;&gt;0x12 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/liweiwei1419/p/9870034.html&quot;&gt;二分类算法的评价指标：准确率、精准率、召回率、混淆矩阵、AUC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/110015537&quot;&gt;分类算法评价指标详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sina.com.cn/s/blog_4a1853330100l4xw.html&quot;&gt;召回率与准确率（Precision and Recall）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/HuZihu/p/11146557.html&quot;&gt;查全率（Recall），查准率（Precision），灵敏性（Sensitivity），特异性（Specificity），F1，PR曲线，ROC，AUC的应用场景&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/87260891&quot;&gt;二分类评估指标F1 &amp;amp; AUC &amp;amp; LogLoss&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/JesusAlone/p/9758471.html&quot;&gt;ROC曲线与AUC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/JesusAlone/p/9762352.html&quot;&gt;ROC曲线 vs Precision-Recall曲线&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u011331731/article/details/72834115&quot;&gt;ROC曲线与AUC以及LIFT&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/wang7807564/article/details/80252362&quot;&gt;机器学习中多分类模型的评估方法之--kappa系数&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/111473451&quot;&gt;ROC、K-S 曲线、Lift 曲线、PR 曲线&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/65afca09fab1&quot;&gt;二分类评估，从混淆矩阵说起&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ddyyll988/article/details/54915641/&quot;&gt;检验方法、混淆矩阵、模型评估&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 19 Jun 2020 23:54:00 +0000</pubDate>
<dc:creator>罗西的思考</dc:creator>
<og:description>二分类评估是对二分类算法的预测结果进行效果评估。本文将构造出一个水泊梁山的具体实例带领大家梳理相关概念。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/rossiXYZ/p/13166899.html</dc:identifier>
</item>
<item>
<title>区块链系列教程之:比特币的钱包与交易 - flydean</title>
<link>http://www.cnblogs.com/flydean/p/bitcoin-transactions.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flydean/p/bitcoin-transactions.html</guid>
<description>&lt;p&gt;钱包在比特币中是做什么的呢？比特币的交易又有什么特点呢？怎么才能伪造比特币的交易呢？今天和大家一起学习一下比特币中的钱包和交易。&lt;/p&gt;

&lt;p&gt;之前我们提到过比特币使用的并不是什么新技术，只是对于老的技术比如：P2P网络，分布式系统，密码学，共识算法的重新而又巧妙的应用。&lt;/p&gt;
&lt;p&gt;在钱包和交易生成验证的过程中，都需要使用到密码学的计算。这里我们先介绍一下比特币中会使用到的几种密码学技术。&lt;/p&gt;
&lt;p&gt;更多精彩内容且看：&lt;/p&gt;
&lt;h2 id=&quot;单向散列函数（hash算法）&quot;&gt;单向散列函数（hash算法）&lt;/h2&gt;
&lt;p&gt;在介绍单向散列函数之前，我们先了解一下什么情况下需要使用到单向散列函数。&lt;/p&gt;
&lt;p&gt;如果你需要从国外的网站上下载一个软件，但是因为种种原因，国外的网络太慢了，下载几个G的数据几乎是不可能的。刚好国内有镜像网站，可以从国内下载数据。但是如何保证国内的镜像不是被篡改过后的呢？这个时候就需要单向散列函数了。一般来说网站会提供MD5或者SHA的值作为验证值。&lt;/p&gt;
&lt;p&gt;单向散列函数有一个输入和输出。输入称为消息，输出称为散列值。&lt;/p&gt;
&lt;p&gt;散列值的长度跟消息的长度无关，不论多少大小的长度的消息，都会计算出固定长度的散列值。&lt;/p&gt;
&lt;p&gt;hash算法有下面几个特点：&lt;/p&gt;
&lt;ol readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;能够根据任意长度的消息计算出固定长度的散列值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算速度要快。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;消息不同，散列值也不同。&lt;/p&gt;
&lt;p&gt;这就意味着，如果仅仅是一点点的变动都会引起整个散列值的巨大变化。&lt;/p&gt;
&lt;p&gt;因为散列值的大小是固定的，所以有可能会出现不同的消息产生相同散列值的情况。这种情况叫做碰撞。&lt;/p&gt;
&lt;p&gt;难以发现碰撞的性质被称为抗碰撞性。当给定某条消息的散列值时，必须保证很难找到和该消息具有相同散列值的另一条消息。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;单向散列函数必须具有单向性。所谓单向性是指无法通过散列值来反推出消息的性质。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;比特币使用的散列算法是SHA256，他是安全散列算法SHA（Secure Hash Algorithm）系列算法的一种（另外还有SHA-1、SHA-224、SHA-384 和 SHA-512 等变体），SHA是美国国家安全局 （NSA） 设计，美国国家标准与技术研究院（NIST） 发布的，主要适用于数字签名标准（DigitalSignature Standard DSS）里面定义的数字签名算法（Digital Signature Algorithm DSA）。&lt;/p&gt;
&lt;p&gt;RIPEMD（RACE Integrity Primitives Evaluation Message Digest，RACE原始完整性校验消息摘要），是Hans Dobbertin等3人在md4,md5的基础上，于1996年提出来的。&lt;/p&gt;
&lt;h2 id=&quot;非对称加密算法&quot;&gt;非对称加密算法&lt;/h2&gt;
&lt;p&gt;非对称加密算法也叫公钥密码算法，通过生成的公私钥来对明文密文进行加密解密。&lt;/p&gt;
&lt;p&gt;非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200331134503633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_35,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;扩展阅读：同态加密&quot;&gt;扩展阅读：同态加密&lt;/h2&gt;
&lt;p&gt;同态加密是一种加密形式，它允许人们对密文进行特定的代数运算得到仍然是加密的结果，将其解密所得到的结果与对明文进行同样的运算结果一样。换言之，这项技术令人们可以在加密的数据中进行诸如检索、比较等操作，得出正确的结果，而在整个处理过程中无需对数据进行解密。其意义在于，真正从根本上解决将数据及其操作委托给第三方时的保密问题，例如对于各种云计算的应用。&lt;/p&gt;

&lt;p&gt;比特币的所有权是通过数字密钥、比特币地址和数字签名来确立的。数字密钥实际上并不是存储在网络中，而是由用户生成并存储在一个文件或简单的数据库 中，称为钱包。存储在用户钱包中的数字密钥完全独立于比特币协议，可由用户的钱包软件生成并管理，而无需区块链或网络连接。密钥实现了比特币的许多有趣特性，包括去中心化信任和控制、所有权认证和基于密码学证明的安全模型。&lt;/p&gt;
&lt;p&gt;比特币钱包只包含私钥而不是比特币。每一个用户有一个包含多个私钥的钱包。钱包中包含成对的私钥和公钥。用户用这些私钥来签名交易，从而证明它们拥有交易的输出（也就是其中的比特币）。比特币是以交易输出的形式来储存在区块链中（通常记为vout或txout）。&lt;/p&gt;
&lt;p&gt;如果钱包只包含私钥，那么钱包地址是什么呢？钱包地址是从公钥的hash值的出来的，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200608220335798.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;首先使用随机数发生器生成一个『私钥』。一般来说这是一个256bits的数，拥有了这串数字就可以对相应『钱包地址』中的比特币进行操作，所以必须被安全地保存起来。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;『私钥』经过SECP256K1算法处理生成了『公钥』。SECP256K1是一种椭圆曲线算法，通过一个已知『私钥』时可以算得『公钥』，而『公钥』已知时却无法反向计算出『私钥』。这是保障比特币安全的算法基础。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;同SHA256一样，RIPEMD160也是一种Hash算法，由『公钥』可以计算得到『公钥哈希』，而反过来是行不通的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;将一个字节的地址版本号连接到『公钥哈希』头部（对于比特币网络的pubkey地址，这一字节为“0”），然后对其进行两次SHA256运算，将结果的前4字节作为『公钥哈希』的校验值，连接在其尾部。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;将上一步结果使用BASE58进行编码(比特币定制版本)，就得到了『钱包地址』。 比如,1A1zP1eP5QGefi2DMPTfTL5TTmv7DivfNa。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所以私钥，公钥和钱包地址的关系如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200608220530700.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大家看到钱包地址1A1zP1eP5QGefi2DMPTfTL5TTmv7DivfNa有什么想法呢？&lt;/p&gt;
&lt;p&gt;肯定有人在想，这么一大长串字母和数字实在是太不好记忆了。能不能生产一个比较好记的钱包地址呢？ 比如MyNameIsHanMeiMei....这样开头的地址呢？&lt;/p&gt;
&lt;p&gt;当然可以，这叫做靓号地址，只不过需要大量的算力才行。&lt;/p&gt;

&lt;p&gt;简单来说，交易就是告知全网：比特币的持有者已授权把比特币转帐给其他人。而新持有者能够再次授权，转移给该比特币所有权链中的其他人。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意， 在比特币的世界里既没有账户，也没有余额，只有分散到区块链里的UTXO（Unspent Transaction Outputs）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;怎么理解这个UTXO呢？没有账户也没有余额，那么钱包里面的金额是怎么计算出来的呢？&lt;/p&gt;
&lt;p&gt;别急，让我们一一道来。&lt;/p&gt;
&lt;p&gt;话说，在比特币中，比特币钱包间的转账是通过交易（Transaction）实现的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200608225429272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_35,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看一个标准的交易流程。&lt;/p&gt;
&lt;p&gt;那么问题来了，世界上第一个比特币是哪里来的呢？&lt;/p&gt;
&lt;p&gt;答，是挖矿来的。好了，我们的001交易表示的就是一个挖矿的过程，在这个交易中，输入就是挖矿，输出编号1，BTC数目是50，目的地址是A，表示这50个BTC给A了。&lt;/p&gt;
&lt;p&gt;接下来，A想发25个BTC给B，怎么构造这个交易呢？&lt;/p&gt;
&lt;p&gt;同样的，我们需要一个输入，这个输入就是001交易的1号输出，我们用001.1来表示。输出分为两个，第一个输出编号1，表示要付25个BTC给B。第二个输出编号2，表示剩下的BTC要还给A。&lt;/p&gt;
&lt;p&gt;大家可能会问了，输入是50BTC，两个输出加起来才45个BTC，好像还少了5个BTC？没错，这个5个BTC就是给矿工的挖矿所得。&lt;/p&gt;
&lt;p&gt;接下来，A又继续转账给C，同样的道理，把一个一个的交易连接起来。&lt;/p&gt;
&lt;p&gt;从上面的例子我们可以看到，实际上钱是存在一个一个的交易记录里面的，那些未被花费的输出，就叫做UTXO（Unspent Transaction Outputs）。&lt;/p&gt;
&lt;p&gt;那么怎么保证转账给B的钱，不会被其他的人消费呢？这就涉及到交易的加密过程了。&lt;/p&gt;
&lt;p&gt;我们以单个输入和输出为例来详细了解一下交易的构成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200608231017101.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中，交易的输入就是txid，也就是之前生成的还有未花费暑输出的交易ID。output index就是交易的输出id。&lt;/p&gt;
&lt;p&gt;一个非常重要的ScriptSig是输入交易的验证，表明这个用户拥有这个账户的转账权限。&lt;/p&gt;
&lt;p&gt;输出是一个脚本，只有满足脚本运行条件的人才能花费这个output。这也就是ScriptSig需要验证的脚本。&lt;/p&gt;
&lt;p&gt;我们看下脚本是怎么做认证的吧。&lt;/p&gt;
&lt;p&gt;比特币的标准输出形式有两种。Pay To Public Key Hash (P2PKH) 和 Pay To Script Hash (P2SH)。两者的区别在于，一个是输出到public key的hash,一个是输出到任意的一个脚本输出hash。&lt;/p&gt;
&lt;p&gt;为了保证输出只能由特定的人来花费，一般的情况下是直接输出到对方的public key hash。由于只有对方拥有的私钥能够生成这个public key hash，也就是说只有对方才能够对这个输出进行验证。&lt;/p&gt;
&lt;p&gt;但每次都需要知道对方的public key hash还是比较麻烦的，更简单的做法就是，发送者直接输出到一个特定的hash值就行了，只要对方能够生成这个hash就可以。&lt;/p&gt;
&lt;p&gt;下面的例子是一个P2PKH的脚本形式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200608231552560.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;P2PKH的输出是一个脚本，里面一个重要的值就是PK hash。&lt;/p&gt;
&lt;p&gt;怎么验证呢？&lt;/p&gt;
&lt;p&gt;验证方提供两个值，一个是sig，一个是PubKey。因为比特币的虚拟机是栈结构的，我们先把这两个值入栈。&lt;/p&gt;
&lt;p&gt;然后调用OP_DUP对最上层的PubKey进行拷贝，然后调用OP_HASH160算法来计算Pk Hash，然后将发送方保存的Pk Hash入栈。接下来调用OP_EQUALVERIFY对两个PK Hash进行对比。&lt;/p&gt;
&lt;p&gt;如果对比成功，最后一步就是验证Sig和PubKey是否匹配。&lt;/p&gt;
&lt;p&gt;如果都成功，说明接收方的确是这个PK Hash的拥有者。那么对方就可以尽情使用了。&lt;/p&gt;

&lt;p&gt;和冯·诺伊曼同为现代计算机奠基人的阿兰·图灵（AlanTurin）在1950年提出了判定计算机能否像人那般实际“思考”的标准，也就是著名的“图灵检验”。&lt;/p&gt;
&lt;p&gt;他设想一台超级计算机和一个人躲藏在幕后回答提问者的问题，而提问者则试图分辨哪个是人哪个是计算机。&lt;/p&gt;
&lt;p&gt;图灵争辩说，假如计算机伪装得如此巧妙，以致没有人可以在实际上把它和一个真人分辨开来的话，那么我们就可以声称，这台计算机和人一样具备了思考能力，或者说，意识（他的原词是“智慧”）。&lt;/p&gt;
&lt;p&gt;在可计算性理论里，如果一系列操作数据的规则（如指令集、编程语言、细胞自动机）按照一定的顺序可以计算出结果，被称为图灵完备（turing complete）。&lt;/p&gt;
&lt;p&gt;比特币脚本语言不是图灵完备的，具有一定的局限性，它没有循环语句和复杂的条件控制语句。&lt;/p&gt;

&lt;p&gt;本文介绍了比特币的钱包和交易的概念，希望大家能够喜欢。&lt;/p&gt;
&lt;blockquote readability=&quot;8.58&quot;&gt;
&lt;p&gt;本文作者：flydean程序那些事&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a href=&quot;http://www.flydean.com/bitcoin-transactions/&quot;&gt;http://www.flydean.com/bitcoin-transactions/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文来源：flydean的博客&lt;/p&gt;
&lt;p&gt;欢迎关注我的公众号:程序那些事，更多精彩等着您！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 19 Jun 2020 23:29:00 +0000</pubDate>
<dc:creator>flydean</dc:creator>
<og:description>简介 钱包在比特币中是做什么的呢？比特币的交易又有什么特点呢？怎么才能伪造比特币的交易呢？今天和大家一起学习一下比特币中的钱包和交易。 比特币密码学的基础 之前我们提到过比特币使用的并不是什么新技术，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flydean/p/bitcoin-transactions.html</dc:identifier>
</item>
<item>
<title>一文读懂：防止过拟合的所有方法 - 忽逢桃林</title>
<link>http://www.cnblogs.com/PythonLearner/p/13167288.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PythonLearner/p/13167288.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/wp_editor_md_992a6088cd9ce6d89bde94d77ccdfa72.jpg&quot;&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/wp_editor_md_992a6088cd9ce6d89bde94d77ccdfa72.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;过拟合就是在训练集上表现得非常好，在测试集上表现得不好。也就是我们俗称的&lt;strong&gt;泛化能力弱&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;过拟合无法避免，只能缓解，那么如何缓解呢？方法太多了。这篇文章一一介绍。&lt;/p&gt;

&lt;p&gt;图像上，翻转，平移，缩放，旋转，镜像，增强对比度，增强亮度等诸多方式。&lt;br/&gt;我在下面的内容中介绍了图像处理的图像增强的方法：&lt;br/&gt;&lt;a href=&quot;http://helloworld2020.net/393/&quot;&gt;【预处理库函数】albumentations库的简单了解和使用&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;训练模型的时候，训练误差往往是不断下降的，但是验证数据集的误差，是先下降后上升。 两个数据集的误差出现分歧的时候，说明模型开始过拟合了。所以Early Stopping就是当验证数据集的误差不在下降的时候，结束训练，保存模型参数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;L1正则&lt;/strong&gt;：模型中只有少部分特征对模型的泛化能力有贡献，所以L1就是限制模型中非零参数的数量。让大部分的模型参数都是0，只有真正对泛化能力其作用的参数才是非零的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;L2正则&lt;/strong&gt;：我们希望模型找到的极小值是平坦的，为什么呢？&lt;br/&gt;&lt;a href=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/wp_editor_md_28b8d0244f6d95a3cb4e7e926418d921.jpg&quot;&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/wp_editor_md_28b8d0244f6d95a3cb4e7e926418d921.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;br/&gt;图中表示的意思，就是平坦的极小值，可以有更多的容忍，容忍什么呢？容忍训练数据集和测试数据集之前的分布偏差。现在，如果模型的某些参数特别大，那么就算输入的样本只有很小的区别，但是经过特别大的参数之后，模型给出的结果很可能是非常不同的。这就是太陡峭。所以L2正则就是限制模型参数的大小。参数的平方的和作为损失的一部分，当参数数值越大，那么梯度下降的损失越大，就会强迫参数变小。&lt;/p&gt;
&lt;p&gt;这里有两幅图：&lt;br/&gt;&lt;a href=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/wp_editor_md_a81f462547a0e450c0ca4e21a41a2084.jpg&quot;&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/wp_editor_md_a81f462547a0e450c0ca4e21a41a2084.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;br/&gt;这一幅图体现的是假设只有两个参数的情况下，增加L1正则的情况。圆圈圈体现的是损失等值线，方框是L1正则的损失。假设没有L1正则，那么参数应该收敛到最小的那个圆圈中的。但是因为增加了L1正则，所以需要权衡两个部分的损失，然后找到接触的交点位置。因为&lt;strong&gt;圆形和矩形在矩形的顶点&lt;/strong&gt;相交的可能性大，而矩形的顶点就是某一个参数为0的情况。所以L1正则会让模型参数有更大的可能性为0.&lt;br/&gt;【在更多参数的模型中，会有更多的顶点。不过二维图像就画不出来了】&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/qZyU0Lx7pJ-compress.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;这个是L2正则的示意图。L2正则式一个原型因为是参数的平方和。相比L1的（0,1）这样的交点，L2更希望每一个参数都普遍较小，不希望某一个参数特别大。&lt;/p&gt;

&lt;p&gt;这个就是神经网络中，在全连接网络中经常用到的。&lt;/p&gt;
&lt;p&gt;在每一个Batch数据训练的时候，Dropout层按照概率P随机让一些神经元失活，然后保留下来的神经元的参数被更新。&lt;strong&gt;dropout&lt;/strong&gt;是只有在训练的时候才使用的，在测试的时候并不适用。&lt;/p&gt;
&lt;p&gt;我个人理解的dropout其实就相当于一个多模型融合的过程。因为每一次都会失活一部分的神经元，所以每一次的模型都是不那么一样的，相当于不同的模型吧。&lt;/p&gt;

&lt;h2 id=&quot;输入中增加噪音&quot;&gt;输入中增加噪音&lt;/h2&gt;
&lt;p&gt;输入中有噪音&lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt;，那么输出中就会有一个类似于&lt;span class=&quot;math inline&quot;&gt;\(\epsilon \omega\)&lt;/span&gt;,这样的损失项。 从而限制权值的大小。&lt;/p&gt;
&lt;p&gt;当然这样也可以增加模型对输入的容忍度，我觉得也可以理解为一种数据增强。 去噪自编码器DAE就是利用这样的方法的。&lt;/p&gt;
&lt;h2 id=&quot;权值中加噪音&quot;&gt;权值中加噪音&lt;/h2&gt;
&lt;p&gt;这个用的不多，在初始化网络的时候，用0均值的高斯分布作为参数的初始化。&lt;/p&gt;

&lt;p&gt;集成主要是bagging，boosting，之前说的dropout我觉得也可以算作集成的方法&lt;/p&gt;
&lt;h2 id=&quot;bagging&quot;&gt;bagging&lt;/h2&gt;
&lt;p&gt;将数据集抽取一部分，比如抽取70%的样本，然后用这些样本去训练一个模型。然后再从数据集中抽取70%的样本，再训练一个新的。典型的就是随机森林。&lt;br/&gt;【神经网络因为训练速度的问题，所以一般不用这样的方法。决策树lgb啥的可以用】&lt;/p&gt;
&lt;h2 id=&quot;boosting&quot;&gt;boosting&lt;/h2&gt;
&lt;p&gt;训练复杂神经网络比较慢，所以&lt;strong&gt;可以通过训练多个简单的分类器，然后加权平均每一个分类器的输出。&lt;/strong&gt;这就是Boost的思想。【这句话给我背下来！】&lt;/p&gt;
&lt;p&gt;之后整理一下Adaboost和XGBoost的这些算法。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;限制网络的层数和复杂度&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;center&gt;**END**&lt;/center&gt;
&lt;hr/&gt;&lt;p&gt;喜欢的话请关注我们的微信公众号~《你好世界炼丹师》或者知乎【你好世界炼丹师】。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;公众号主要讲统计学，数据科学，机器学习，深度学习，以及一些参加Kaggle竞赛的经验。&lt;/li&gt;
&lt;li&gt;公众号内容建议作为课后的一些相关知识的补充，饭后甜点。&lt;/li&gt;
&lt;li&gt;此外，为了不过多打扰，公众号每周推送一次，每次4~6篇精选文章。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;微信搜索公众号：你好世界炼丹师。期待您的关注。&lt;/p&gt;
</description>
<pubDate>Fri, 19 Jun 2020 18:45:00 +0000</pubDate>
<dc:creator>忽逢桃林</dc:creator>
<og:description>什么是过拟合 过拟合就是在训练集上表现得非常好，在测试集上表现得不好。也就是我们俗称的泛化能力弱。 过拟合无法避免，只能缓解，那么如何缓解呢？方法太多了。这篇文章一一介绍。 数据集增强Augmenta</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/PythonLearner/p/13167288.html</dc:identifier>
</item>
<item>
<title>Linux MySQL分库分表之Mycat - 陈彦斌</title>
<link>http://www.cnblogs.com/chenyanbin/p/13159469.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenyanbin/p/13159469.html</guid>
<description>&lt;h2&gt;背景&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;当&lt;span&gt;&lt;strong&gt;表的个数达到了几百千万张表&lt;/strong&gt;&lt;/span&gt;时，众多的业务模块都访问这个数据库，压力会比较大，考虑对其进行分库&lt;/li&gt;
&lt;li&gt;当&lt;span&gt;&lt;strong&gt;表的数据达到几千万级别&lt;/strong&gt;&lt;/span&gt;，在做很多操作都比较吃力，考虑对其进行分库或分表&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;数据切分(sharding)方案&lt;/h2&gt;
&lt;p&gt;　　数据的切分（Sharding）根据其切分规则的类型，可以分为两种切分模式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;垂直切分&lt;/strong&gt;&lt;/span&gt;：按照业务模块进行切分，将不同模块的表切分到不同的数据库中&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;水平切分&lt;/strong&gt;&lt;/span&gt;，将一张大表按照一定的切分规则，按照行切分成不同的表或者切分到不同的库中&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;如何理解垂直切分？&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;垂直分库&lt;/strong&gt;&lt;/span&gt;：主要&lt;span&gt;&lt;strong&gt;解决&lt;/strong&gt;&lt;/span&gt;的问题是单个数据库中[&lt;span&gt;&lt;strong&gt;数据表&lt;/strong&gt;&lt;/span&gt;]&lt;span&gt;&lt;strong&gt;过多问题&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;垂直分表&lt;/strong&gt;&lt;/span&gt;：主要&lt;span&gt;&lt;strong&gt;解决&lt;/strong&gt;&lt;/span&gt;的问题是单个&lt;span&gt;&lt;strong&gt;表&lt;/strong&gt;&lt;/span&gt;中[&lt;strong&gt;&lt;span&gt;过多&lt;/span&gt;&lt;/strong&gt;问题(将一张大表，拆分不同的关联表)。&lt;/p&gt;
&lt;h3&gt;如何理解水平切分？&lt;/h3&gt;
&lt;p&gt;　　水平切分主要&lt;span&gt;&lt;strong&gt;解决&lt;/strong&gt;&lt;/span&gt;的问题就是对于[&lt;span&gt;&lt;strong&gt;单表数据量过大&lt;/strong&gt;&lt;/span&gt;]的问题(1000W以上数据性能会有所下降)&lt;/p&gt;
&lt;h3&gt;切分原则&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;能不切尽量不要切分&lt;/li&gt;
&lt;li&gt;如果要切分一定要选择合适的切分规则，提前规划好&lt;/li&gt;
&lt;li&gt;数据切分尽量通过冗余或表分组(Table Group)来降低跨库Join的可能&lt;/li&gt;
&lt;li&gt;由于数据库中间件对数据Join实现的优劣难以把握，而且实现高性能难度极大，业务读取尽量少使用多表Join&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;分库分表之后带来问题？&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;跨库Join：订单表需要关联会员信息(订单表和会员表拆分为两个库的表)
&lt;ol&gt;&lt;li&gt;应用层由一个查询拆分为多个&lt;/li&gt;
&lt;li&gt;全局表，每个库都存储相同的数据，比如字典表、地址表&lt;/li&gt;
&lt;li&gt;字段冗余&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;Mycat技术可以实现跨库Join，只能实现2张表跨库Join&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;分布式事务(Mycat没有很好实现分布式事务)
&lt;ol&gt;&lt;li&gt;强一致性(互联网项目不推荐，性能不好)&lt;/li&gt;
&lt;li&gt;最终一致性(异步方式去实现，需要通过日志信息)&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;主键问题(保证ID的连续性和唯一性)
&lt;ol&gt;&lt;li&gt;UUID(性能不好)&lt;/li&gt;
&lt;li&gt;redis incr命令&lt;/li&gt;
&lt;li&gt;zookeeper&lt;/li&gt;
&lt;li&gt;雪花算法&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;跨库进行排序问题
&lt;ol&gt;&lt;li&gt;在应用层进行排序&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;官网链接&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.mycat.org.cn/&quot; target=&quot;_blank&quot;&gt;点我直达&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Mycat核心概念&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Schema&lt;/strong&gt;：由它制定逻辑数据库(相当于MySQL的database数据库)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Table&lt;/strong&gt;：逻辑表(相当于MySQL的table表)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DataNode&lt;/strong&gt;：真正存储数据的物理节点&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DataHost&lt;/strong&gt;：存储节点所在的数据库主机(指定MySQL数据库的连接信息)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;User&lt;/strong&gt;：MyCat的用户(类似于MySQL的用户，支持多用户)&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;MyCat主要解决的问题&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;海量数据存储&lt;/li&gt;
&lt;li&gt;查询优化&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;Mycat对数据库的支持&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202006/1504448-20200619151137867-1309609552.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;Mycat安装&lt;/h2&gt;
&lt;h3&gt;安装要求&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;jdk：要求jdk必须是1.7及以上版本 （&lt;span&gt;我使用的是jdk 1.8&lt;/span&gt;）&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;Mysql：推荐mysql是5.5以上版本（&lt;strong&gt;&lt;span&gt;我使用的是mysql 5.7&lt;/span&gt;&lt;/strong&gt;）&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;安装jdk&lt;/h3&gt;
&lt;p&gt;具体教程：&lt;a href=&quot;https://www.cnblogs.com/chenyanbin/p/12843149.html&quot; target=&quot;_blank&quot;&gt;点我直达&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202006/1504448-20200619150705902-954523072.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;Mcat下载&lt;/h3&gt;
&lt;p&gt;下载链接：&lt;a href=&quot;https://github.com/MyCATApache/Mycat-download&quot; target=&quot;_blank&quot;&gt;点我直达&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
百度云盘地址：https://pan.baidu.com/s/14A3BAwnBRGZppc3AicF5Hw  密码: gkrp
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202006/1504448-20200619160411588-1329871529.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;解压&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202006/1504448-20200619160720986-1957907621.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202006/1504448-20200619160823309-331413739.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;修改配置文件&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;路径：/cyb/soft/mycat/conf&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;server.xml&lt;/h3&gt;
&lt;p&gt;用途：用于配置用户信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202006/1504448-20200619224311463-888343357.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; - - Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); 
    - you may not use this file except in compliance with the License. - You 
    may obtain a copy of the License at - - http://www.apache.org/licenses/LICENSE-2.0 
    - - Unless required by applicable law or agreed to in writing, software - 
    distributed under the License is distributed on an &quot;AS IS&quot; BASIS, - WITHOUT 
    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. - See the 
    License for the specific language governing permissions and - limitations 
    under the License. &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE mycat:server SYSTEM &quot;server.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mycat:server &lt;/span&gt;&lt;span&gt;xmlns:mycat&lt;/span&gt;&lt;span&gt;=&quot;http://io.mycat/&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;system&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;useSqlStat&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 1为开启实时统计、0为关闭 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;useGlobleTableCheck&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 1为开启全加班一致性检测、0为关闭 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sequnceHandlerType&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;  &amp;lt;property name=&quot;useCompression&quot;&amp;gt;1&amp;lt;/property&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;1为开启mysql压缩协议&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;  &amp;lt;property name=&quot;fakeMySQLVersion&quot;&amp;gt;5.6.20&amp;lt;/property&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;设置模拟的MySQL版本号&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; &amp;lt;property name=&quot;processorBufferChunk&quot;&amp;gt;40960&amp;lt;/property&amp;gt; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 
    &amp;lt;property name=&quot;processors&quot;&amp;gt;1&amp;lt;/property&amp;gt; 
    &amp;lt;property name=&quot;processorExecutor&quot;&amp;gt;32&amp;lt;/property&amp;gt; 
     &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;默认为type 0: DirectByteBufferPool | type 1 ByteBufferArena&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;processorBufferPoolType&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;默认是65535 64K 用于sql解析时最大文本长度 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;&amp;lt;property name=&quot;maxStringLiteralLength&quot;&amp;gt;65535&amp;lt;/property&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;&amp;lt;property name=&quot;sequnceHandlerType&quot;&amp;gt;0&amp;lt;/property&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;&amp;lt;property name=&quot;backSocketNoDelay&quot;&amp;gt;1&amp;lt;/property&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;&amp;lt;property name=&quot;frontSocketNoDelay&quot;&amp;gt;1&amp;lt;/property&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;&amp;lt;property name=&quot;processorExecutor&quot;&amp;gt;16&amp;lt;/property&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;
            &amp;lt;property name=&quot;serverPort&quot;&amp;gt;8066&amp;lt;/property&amp;gt; &amp;lt;property name=&quot;managerPort&quot;&amp;gt;9066&amp;lt;/property&amp;gt; 
            &amp;lt;property name=&quot;idleTimeout&quot;&amp;gt;300000&amp;lt;/property&amp;gt; &amp;lt;property name=&quot;bindIp&quot;&amp;gt;0.0.0.0&amp;lt;/property&amp;gt; 
            &amp;lt;property name=&quot;frontWriteQueueSize&quot;&amp;gt;4096&amp;lt;/property&amp;gt; &amp;lt;property name=&quot;processors&quot;&amp;gt;32&amp;lt;/property&amp;gt; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;分布式事务开关，0为不过滤分布式事务，1为过滤分布式事务（如果分布式事务内只涉及全局表，则不过滤），2为不过滤分布式事务,但是记录分布式事务日志&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;handleDistributedTransactions&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;
            off heap for merge/order/group/limit      1开启   0关闭
        &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;useOffHeapForMerge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;
            单位为m
        &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;memoryPageSize&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1m&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;
            单位为k
        &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;spillsFileBufferSize&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1k&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;useStreamOutput&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;
            单位为m
        &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;systemReserveMemorySize&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;384m&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;


        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;是否采用zookeeper协调切换  &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;useZKSwitch&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;


    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;system&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 全局SQL防火墙设置 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 
    &amp;lt;firewall&amp;gt; 
       &amp;lt;whitehost&amp;gt;
          &amp;lt;host host=&quot;127.0.0.1&quot; user=&quot;mycat&quot;/&amp;gt;
          &amp;lt;host host=&quot;127.0.0.2&quot; user=&quot;mycat&quot;/&amp;gt;
       &amp;lt;/whitehost&amp;gt;
       &amp;lt;blacklist check=&quot;false&quot;&amp;gt;
       &amp;lt;/blacklist&amp;gt;
    &amp;lt;/firewall&amp;gt;
    &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;user &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;root&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;root&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;schemas&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;TESTDB&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 表级 DML 权限设置 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;         
        &amp;lt;privileges check=&quot;false&quot;&amp;gt;
            &amp;lt;schema name=&quot;TESTDB&quot; dml=&quot;0110&quot; &amp;gt;
                &amp;lt;table name=&quot;tb01&quot; dml=&quot;0000&quot;&amp;gt;&amp;lt;/table&amp;gt;
                &amp;lt;table name=&quot;tb02&quot; dml=&quot;1111&quot;&amp;gt;&amp;lt;/table&amp;gt;
            &amp;lt;/schema&amp;gt;
        &amp;lt;/privileges&amp;gt;        
         &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;user &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;user&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;user&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;schemas&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;TESTDB&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;readOnly&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mycat:server&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;schema.xml&lt;/h3&gt;
&lt;p&gt;用途：管理逻辑表&lt;/p&gt;
&lt;p&gt;为了演示方便，删掉一些不必要的标签，标签详细用法：&lt;a href=&quot;https://www.jianshu.com/p/4e15cad5ce6a&quot; target=&quot;_blank&quot;&gt;点我直达&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202006/1504448-20200620000248684-2048999107.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE mycat:schema SYSTEM &quot;schema.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mycat:schema &lt;/span&gt;&lt;span&gt;xmlns:mycat&lt;/span&gt;&lt;span&gt;=&quot;http://io.mycat/&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;schema &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;TESTDB&quot;&lt;/span&gt;&lt;span&gt; checkSQLschema&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt; sqlMaxLimit&lt;/span&gt;&lt;span&gt;=&quot;100&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; auto sharding by id (long) &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;cyb_test&quot;&lt;/span&gt;&lt;span&gt; dataNode&lt;/span&gt;&lt;span&gt;=&quot;dn1,dn2,dn3&quot;&lt;/span&gt;&lt;span&gt; rule&lt;/span&gt;&lt;span&gt;=&quot;mod-long&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;schema&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dataNode &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dn1&quot;&lt;/span&gt;&lt;span&gt; dataHost&lt;/span&gt;&lt;span&gt;=&quot;localhost1&quot;&lt;/span&gt;&lt;span&gt; database&lt;/span&gt;&lt;span&gt;=&quot;db1&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dataNode &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dn2&quot;&lt;/span&gt;&lt;span&gt; dataHost&lt;/span&gt;&lt;span&gt;=&quot;localhost1&quot;&lt;/span&gt;&lt;span&gt; database&lt;/span&gt;&lt;span&gt;=&quot;db2&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dataNode &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dn3&quot;&lt;/span&gt;&lt;span&gt; dataHost&lt;/span&gt;&lt;span&gt;=&quot;localhost1&quot;&lt;/span&gt;&lt;span&gt; database&lt;/span&gt;&lt;span&gt;=&quot;db3&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dataHost &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;localhost1&quot;&lt;/span&gt;&lt;span&gt; maxCon&lt;/span&gt;&lt;span&gt;=&quot;1000&quot;&lt;/span&gt;&lt;span&gt; minCon&lt;/span&gt;&lt;span&gt;=&quot;10&quot;&lt;/span&gt;&lt;span&gt; balance&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;
              writeType&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; dbType&lt;/span&gt;&lt;span&gt;=&quot;mysql&quot;&lt;/span&gt;&lt;span&gt; dbDriver&lt;/span&gt;&lt;span&gt;=&quot;native&quot;&lt;/span&gt;&lt;span&gt; switchType&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;  slaveThreshold&lt;/span&gt;&lt;span&gt;=&quot;100&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;heartbeat&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;select user()&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;heartbeat&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; can have multi write hosts &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;writeHost &lt;/span&gt;&lt;span&gt;host&lt;/span&gt;&lt;span&gt;=&quot;hostM1&quot;&lt;/span&gt;&lt;span&gt; url&lt;/span&gt;&lt;span&gt;=&quot;192.168.31.200:3306&quot;&lt;/span&gt;&lt;span&gt; user&lt;/span&gt;&lt;span&gt;=&quot;root&quot;&lt;/span&gt;&lt;span&gt;
                   password&lt;/span&gt;&lt;span&gt;=&quot;root&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; can have multi read hosts &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;readHost &lt;/span&gt;&lt;span&gt;host&lt;/span&gt;&lt;span&gt;=&quot;hostS2&quot;&lt;/span&gt;&lt;span&gt; url&lt;/span&gt;&lt;span&gt;=&quot;192.168.31.201:3306&quot;&lt;/span&gt;&lt;span&gt; user&lt;/span&gt;&lt;span&gt;=&quot;root&quot;&lt;/span&gt;&lt;span&gt; password&lt;/span&gt;&lt;span&gt;=&quot;root&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;writeHost&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dataHost&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mycat:schema&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;rule.xml&lt;/h3&gt;
&lt;p&gt;用途：定义了我们对表进行拆分所涉及到的规则定义，视情况修改参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; - - Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); 
    - you may not use this file except in compliance with the License. - You 
    may obtain a copy of the License at - - http://www.apache.org/licenses/LICENSE-2.0 
    - - Unless required by applicable law or agreed to in writing, software - 
    distributed under the License is distributed on an &quot;AS IS&quot; BASIS, - WITHOUT 
    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. - See the 
    License for the specific language governing permissions and - limitations 
    under the License. &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE mycat:rule SYSTEM &quot;rule.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mycat:rule &lt;/span&gt;&lt;span&gt;xmlns:mycat&lt;/span&gt;&lt;span&gt;=&quot;http://io.mycat/&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tableRule &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;rule1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;id&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;func1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tableRule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tableRule &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;rule2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;user_id&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;func1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tableRule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tableRule &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sharding-by-intfile&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;sharding_id&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;hash-int&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tableRule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tableRule &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;auto-sharding-long&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;id&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;rang-long&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tableRule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tableRule &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;mod-long&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;id&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mod-long&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tableRule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tableRule &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sharding-by-murmur&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;id&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;murmur&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tableRule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tableRule &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;crc32slot&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;id&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;crc32slot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tableRule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tableRule &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sharding-by-month&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;create_time&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;partbymonth&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tableRule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tableRule &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;latest-month-calldate&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;calldate&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;latestMonth&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tableRule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tableRule &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;auto-sharding-rang-mod&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;id&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;rang-mod&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tableRule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tableRule &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;jch&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;id&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jump-consistent-hash&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tableRule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;function &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;murmur&quot;&lt;/span&gt;&lt;span&gt;
        class&lt;/span&gt;&lt;span&gt;=&quot;io.mycat.route.function.PartitionByMurmurHash&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;seed&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 默认是0 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;count&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 要分片的数据库节点数量，必须指定，否则没法分片 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;virtualBucketTimes&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;160&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 一个实际的数据库节点被映射为这么多虚拟节点，默认是160倍，也就是虚拟节点数是物理节点数的160倍 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; &amp;lt;property name=&quot;weightMapFile&quot;&amp;gt;weightMapFile&amp;lt;/property&amp;gt; 节点的权重，没有指定权重的节点默认是1。以properties文件的格式填写，以从0开始到count-1的整数值也就是节点索引为key，以节点权重值为值。所有权重值必须是正整数，否则以1代替 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; &amp;lt;property name=&quot;bucketMapPath&quot;&amp;gt;/etc/mycat/bucketMapPath&amp;lt;/property&amp;gt; 
            用于测试时观察各物理节点与虚拟节点的分布情况，如果指定了这个属性，会把虚拟节点的murmur hash值与物理节点的映射按行输出到这个文件，没有默认值，如果不指定，就不会输出任何东西 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;function &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;crc32slot&quot;&lt;/span&gt;&lt;span&gt;
              class&lt;/span&gt;&lt;span&gt;=&quot;io.mycat.route.function.PartitionByCRC32PreSlot&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;count&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 要分片的数据库节点数量，必须指定，否则没法分片 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;function &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;hash-int&quot;&lt;/span&gt;&lt;span&gt;
        class&lt;/span&gt;&lt;span&gt;=&quot;io.mycat.route.function.PartitionByFileMap&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;mapFile&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;partition-hash-int.txt&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;function &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;rang-long&quot;&lt;/span&gt;&lt;span&gt;
        class&lt;/span&gt;&lt;span&gt;=&quot;io.mycat.route.function.AutoPartitionByLong&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;mapFile&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;autopartition-long.txt&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;function &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;mod-long&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;io.mycat.route.function.PartitionByMod&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; how many data nodes &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;count&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;function &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;func1&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;io.mycat.route.function.PartitionByLong&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;partitionCount&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;partitionLength&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;128&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;function &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;latestMonth&quot;&lt;/span&gt;&lt;span&gt;
        class&lt;/span&gt;&lt;span&gt;=&quot;io.mycat.route.function.LatestMonthPartion&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;splitOneDay&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;24&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;function &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;partbymonth&quot;&lt;/span&gt;&lt;span&gt;
        class&lt;/span&gt;&lt;span&gt;=&quot;io.mycat.route.function.PartitionByMonth&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dateFormat&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;yyyy-MM-dd&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sBeginDate&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2015-01-01&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;function &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;rang-mod&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;io.mycat.route.function.PartitionByRangeMod&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;mapFile&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;partition-range-mod.txt&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;function &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;jump-consistent-hash&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;io.mycat.route.function.PartitionByJumpConsistentHash&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;totalBuckets&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mycat:rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;启动mycat&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;进入mycat/bin，启动mycat

启动命令：./mycat start
停止命令：./mycat stop
重启命令：./mycat restart
查看状态命令：./mycat status&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意，可以使用mysql的客户端直接连接mycat服务，默认端口为8066&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;错误日志(&lt;span&gt;重要&lt;/span&gt;)&lt;/h2&gt;
&lt;p&gt;　　部署过程中，我碰到点小问题，找不到主机名，具体解决方案，请看我另一篇：&lt;a href=&quot;https://www.cnblogs.com/chenyanbin/p/13166797.html&quot; target=&quot;_blank&quot;&gt;点我直达&lt;/a&gt; ，&lt;span&gt;如果Mycat服务起不来，记得看错误日志哟！&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;测试&lt;/h2&gt;
&lt;p&gt;ip：192.168.31.200(&lt;strong&gt;&lt;span&gt;mysql主服务器&lt;/span&gt;&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;ip：192.168.31.201(&lt;span&gt;&lt;strong&gt;mysql从服务器&lt;/strong&gt;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;ip：192.168.31.209(&lt;span&gt;&lt;strong&gt;mycat服务器&lt;/strong&gt;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;　　注：演示过程中，因为mysql搭建了集群，主从复制，可能网络原因，有些延迟，或者mysql主从复制同步机制问题，导致刷新好几次，才显示出来，因为图片较大，被分割几张gif，内容都是连续的，验证结果，达到预期，演示成功！&lt;/p&gt;
&lt;p&gt;　　MySQL集群搭建主从复制：&lt;a href=&quot;https://www.cnblogs.com/chenyanbin/p/13154225.html&quot; target=&quot;_blank&quot;&gt;点我直达&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202006/1504448-20200620002812981-1131289204.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202006/1504448-20200620003253712-1824381442.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202006/1504448-20200620003607929-53565370.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202006/1504448-20200620004520786-1670452459.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202006/1504448-20200620004943728-2053543743.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 19 Jun 2020 16:52:00 +0000</pubDate>
<dc:creator>陈彦斌</dc:creator>
<og:description>介绍 背景 当表的个数达到了几百千万张表时，众多的业务模块都访问这个数据库，压力会比较大，考虑对其进行分库 当表的数据达到几千万级别，在做很多操作都比较吃力，考虑对其进行分库或分表 数据切分(shar</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenyanbin/p/13159469.html</dc:identifier>
</item>
<item>
<title>容器技术之Docker-machine - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/13160915.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/13160915.html</guid>
<description>&lt;p&gt;　　前文我们聊了下docker容器的资源限制，回顾请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/13138725.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/13138725.html&lt;/a&gt;；今天我们来聊一聊docker machine；docker machine是docker 官方提供的工具，这个工具可以在不同主机/不同系统上快速安装、管理docker环境；docker machine 的实现原理就是通过不同的驱动来连接不同类型节点，来实现docker machine管理不同平台上的docker环境；&lt;/p&gt;
&lt;p&gt;　　docker machine 安装&lt;/p&gt;
&lt;p&gt;　　1、下载二进制程序文件到本地&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# base=https://github.com/docker/machine/releases/download/v0.16.0 &amp;amp;&amp;amp;
&amp;gt;   curl -L $base/docker-machine-$(uname -s)-$(uname -m) &amp;gt;/tmp/docker-machine &amp;amp;&amp;amp;
&amp;gt;   sudo mv /tmp/docker-machine /usr/local/bin/docker-machine &amp;amp;&amp;amp;
&amp;gt;   chmod +x /usr/local/bin/docker-machine
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   638  100   638    0     0    590      0  0:00:01  0:00:01 --:--:--   590
100 26.8M  100 26.8M    0     0  11911      0  0:39:24  0:39:24 --:--:-- 16907
[root@node1 ~]# ll /usr/local/bin/docker-machine 
-rwxr-xr-x 1 root root 28164576 Jun 18 11:28 /usr/local/bin/docker-machine
[root@node1 ~]# docker-machine version
docker-machine version 0.16.0, build 702c267f
[root@node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上命令主要就做了三件事，下载对应系统的对应系统架构的docker-machine到本地/tmp/下，并保存为docker-machine;然后把/tmp/docker-machine移动至/usr/local/bin/下，然后给/usr/local/bin/docker-machine添加执行权限；如果下载完我们可以在终端运行docker-machine version 能够看到对应的版本信息，就表示docker-machine安装好了；docker-machine程序是安装好了，现在我们还不能直接使用；我们上面说过docker-machine本质就是通过不同的驱动去连接节点，连接节点实际上就是通过ssh链到节点服务器上，然后执行安装docker;所以为了能够很好的使用docker-machine 我们需要对管理的节点做免密登录；&lt;/p&gt;
&lt;p&gt;　　2、管理节点对work节点做免密登录&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# ssh-keygen 
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa): 
/root/.ssh/id_rsa already exists.
Overwrite (y/n)? y
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:4HrdVnoO+W/+J/ewP4A1m8HnneKWAKMKo3Ad2uExJ1k root@node1
The key's randomart image is:
+---[RSA 2048]----+
|                 |
|      E          |
|     o.     .    |
|    B... o   = . |
|   = B. S o + B o|
|. oo+. o . * = o.|
|... + o . * + =  |
| .   o   . = +o+o|
|            +++=B|
+----[SHA256]-----+
[root@node1 ~]# ssh-copy-id root@192.168.0.42
/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: &quot;/root/.ssh/id_rsa.pub&quot;
The authenticity of host '192.168.0.42 (192.168.0.42)' can't be established.
ECDSA key fingerprint is SHA256:EG9nua4JJuUeofheXlgQeL9hX5H53JynOqf2vf53mII.
ECDSA key fingerprint is MD5:57:83:e6:46:2c:4b:bb:33:13:56:17:f7:fd:76:71:cc.
Are you sure you want to continue connecting (yes/no)? yes
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
root@192.168.0.42's password: 

Number of key(s) added: 1

Now try logging into the machine, with:   &quot;ssh 'root@192.168.0.42'&quot;
and check to make sure that only the key(s) you wanted were added.

[root@node1 ~]# ssh-copy-id root@192.168.0.43
/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: &quot;/root/.ssh/id_rsa.pub&quot;
The authenticity of host '192.168.0.43 (192.168.0.43)' can't be established.
ECDSA key fingerprint is SHA256:EG9nua4JJuUeofheXlgQeL9hX5H53JynOqf2vf53mII.
ECDSA key fingerprint is MD5:57:83:e6:46:2c:4b:bb:33:13:56:17:f7:fd:76:71:cc.
Are you sure you want to continue connecting (yes/no)? yes
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
root@192.168.0.43's password: 

Number of key(s) added: 1

Now try logging into the machine, with:   &quot;ssh 'root@192.168.0.43'&quot;
and check to make sure that only the key(s) you wanted were added.

[root@node1 ~]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：有关免密登录的详细说明可以参考本人博客&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/11783371.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/11783371.html&lt;/a&gt;；接下来我们就可以使用docker-machine来对节点主机进行操作了；&lt;/p&gt;
&lt;p&gt;　　对节点主机安装docker环境&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200619215126873-118365014.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：提示：以上命令表示创建一个docker-machine主机，使用generic驱动，generic表示对linux主机，如果是windows需要用到--virtualbox;--generic-ip-address表示指定节点主机的ip地址；然后在给上一名称；从上面的信息可以看到，docker-node01这台machine已经启动，它告诉我们要查看怎么连接docker-node01这台虚拟主机，请运行docker-machine env docker-node01 查看；&lt;/p&gt;
&lt;p&gt;　　查看怎么连接docker-node01这台虚拟主机&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200619220946748-1995546522.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：它告诉我们运行下面的命令可以配置我们的shell&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200619221812389-2107080025.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：从上面的信息可以看到我们运行 eval $(docker-machine env docker-node01)这条命令就表示把环境切换到docker-node01上；接下来的操作都会发送到docker node01上；&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200619222959178-745870218.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：从上面的信息可以看到，当我们使用eval $(docker-machine env docker-node01)把当前环境切换到docker-node01后，在当前终端运行的容器和下载的镜像，在退出当前终端重新登录后，本地的是没有nginx镜像的；这意味着我们切换环境后，运行容器的操作上发送给docker-node01上执行了；&lt;/p&gt;
&lt;p&gt;　　测试：我们登录到docker-node01看看是否有nginx镜像和n1容器？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200619223405879-2038516306.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：用docker-machine创建虚拟主机来对节点主机管理时，我们给定虚拟主机的名称docker-machine会把该名称当作主机名，把节点主机的主机名更改为我们指定的名称；从上面的信息可以看到docker-node01这台主机上有nginx镜像和n1容器；这说明我们刚才的操作都是发送给docker-node01上了；从上面的演示可以看到，我们在docker-machine上切换环境，当前shell并不能反映我们是否切换到对应的环境了；这样一来在主机特别多的情况，很容易出错；接下来我们配置当前shell的PS1的环境变量；&lt;/p&gt;
&lt;p&gt;　　下载docker-machine-wrapper.bash、docker-machine-prompt.bash和docker-machine.bash&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# cat /etc/bash_completion.d/down.bash
base=https://raw.githubusercontent.com/docker/machine/v0.16.0
for i in docker-machine-prompt.bash docker-machine-wrapper.bash docker-machine.bash
do
  sudo wget &quot;$base/contrib/completion/bash/${i}&quot; -P /etc/bash_completion.d
done
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上脚本主要是循环下载上面说的三个脚本；执行该脚本直接有source命令即可；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200619224342566-646963557.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：我们用source命令来执行上面的脚本，提示我们连接拒绝；这是因为没有解析到raw.githubusercontent.com的地址造成的；解决办法在/etc/hosts文件中介入raw.githubusercontent.com的解析地址即可；&lt;a href=&quot;https://site.ip138.com/raw.githubusercontent.com/&quot; target=&quot;_blank&quot;&gt;https://site.ip138.com/raw.githubusercontent.com/&lt;/a&gt;；这个网站可以查询到raw.githubusercontent.com的地址；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200619224811174-1947286759.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200619225207224-82964617.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：更改/etc/hosts文件后，接下在用source命令执行上面的脚本就不会提示我们链接拒绝了；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200619225422978-235808327.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到/etc/bash_completion.d/目录下有我们要的脚本了；接下来我们就需要配置当前用户的PS1环境的值；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200619225834456-253758521.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上信息表示导入上面的三个脚本到当前登录用户的终端；配置好以上.bashrc后，我们在来切换环境，当前shell就不一样了；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200619230111643-568626246.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：导入了docker-machine-wrapper.bash、docker-machine-prompt.bash和docker-machine.bash这三个脚本配合现在新定义的PS1变量，我们切换环境就很容易的辨识，我们操作的node节点主机是那一台；退出当前环境，直接使用exit即可；&lt;/p&gt;
&lt;p&gt;　　到此docker-machine的环境就搭建好了；接下我们再来说说docker-machine的常用命令使用和说明&lt;/p&gt;
&lt;p&gt;　　docker-machine active:查看当前激活状态的docker主机&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# docker-machine active
docker-node01
[root@node01 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：所谓激活状态的docker主机就是指的当前的DOCKER_HOST环境变量所指向的主机；&lt;/p&gt;
&lt;p&gt;　　docker-machine ls：列出所有管理的主机&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# docker-machine ls
NAME            ACTIVE   DRIVER    STATE     URL                       SWARM   DOCKER      ERRORS
docker-node01   *        generic   Running   tcp://192.168.0.42:2376           v19.03.11   
docker-node02   -        generic   Running   tcp://192.168.0.43:2376           v19.03.11   
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　docker-machine config:查看激活的docker主机的连接信息；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# docker-machine config docker-node01
--tlsverify
--tlscacert=&quot;/root/.docker/machine/machines/docker-node01/ca.pem&quot;
--tlscert=&quot;/root/.docker/machine/machines/docker-node01/cert.pem&quot;
--tlskey=&quot;/root/.docker/machine/machines/docker-node01/key.pem&quot;
-H=tcp://192.168.0.42:2376
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　docker-machine inspect :以json格式输出指定docker主机的详细信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;90&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# docker-machine inspect docker-node01
{
    &quot;ConfigVersion&quot;: 3,
    &quot;Driver&quot;: {
        &quot;IPAddress&quot;: &quot;192.168.0.42&quot;,
        &quot;MachineName&quot;: &quot;docker-node01&quot;,
        &quot;SSHUser&quot;: &quot;root&quot;,
        &quot;SSHPort&quot;: 22,
        &quot;SSHKeyPath&quot;: &quot;&quot;,
        &quot;StorePath&quot;: &quot;/root/.docker/machine&quot;,
        &quot;SwarmMaster&quot;: false,
        &quot;SwarmHost&quot;: &quot;&quot;,
        &quot;SwarmDiscovery&quot;: &quot;&quot;,
        &quot;EnginePort&quot;: 2376,
        &quot;SSHKey&quot;: &quot;&quot;
    },
    &quot;DriverName&quot;: &quot;generic&quot;,
    &quot;HostOptions&quot;: {
        &quot;Driver&quot;: &quot;&quot;,
        &quot;Memory&quot;: 0,
        &quot;Disk&quot;: 0,
        &quot;EngineOptions&quot;: {
            &quot;ArbitraryFlags&quot;: [],
            &quot;Dns&quot;: null,
            &quot;GraphDir&quot;: &quot;&quot;,
            &quot;Env&quot;: [],
            &quot;Ipv6&quot;: false,
            &quot;InsecureRegistry&quot;: [],
            &quot;Labels&quot;: [],
            &quot;LogLevel&quot;: &quot;&quot;,
            &quot;StorageDriver&quot;: &quot;&quot;,
            &quot;SelinuxEnabled&quot;: false,
            &quot;TlsVerify&quot;: true,
            &quot;RegistryMirror&quot;: [],
            &quot;InstallURL&quot;: &quot;https://get.docker.com&quot;
        },
        &quot;SwarmOptions&quot;: {
            &quot;IsSwarm&quot;: false,
            &quot;Address&quot;: &quot;&quot;,
            &quot;Discovery&quot;: &quot;&quot;,
            &quot;Agent&quot;: false,
            &quot;Master&quot;: false,
            &quot;Host&quot;: &quot;tcp://0.0.0.0:3376&quot;,
            &quot;Image&quot;: &quot;swarm:latest&quot;,
            &quot;Strategy&quot;: &quot;spread&quot;,
            &quot;Heartbeat&quot;: 0,
            &quot;Overcommit&quot;: 0,
            &quot;ArbitraryFlags&quot;: [],
            &quot;ArbitraryJoinFlags&quot;: [],
            &quot;Env&quot;: null,
            &quot;IsExperimental&quot;: false
        },
        &quot;AuthOptions&quot;: {
            &quot;CertDir&quot;: &quot;/root/.docker/machine/certs&quot;,
            &quot;CaCertPath&quot;: &quot;/root/.docker/machine/certs/ca.pem&quot;,
            &quot;CaPrivateKeyPath&quot;: &quot;/root/.docker/machine/certs/ca-key.pem&quot;,
            &quot;CaCertRemotePath&quot;: &quot;&quot;,
            &quot;ServerCertPath&quot;: &quot;/root/.docker/machine/machines/docker-node01/server.pem&quot;,
            &quot;ServerKeyPath&quot;: &quot;/root/.docker/machine/machines/docker-node01/server-key.pem&quot;,
            &quot;ClientKeyPath&quot;: &quot;/root/.docker/machine/certs/key.pem&quot;,
            &quot;ServerCertRemotePath&quot;: &quot;&quot;,
            &quot;ServerKeyRemotePath&quot;: &quot;&quot;,
            &quot;ClientCertPath&quot;: &quot;/root/.docker/machine/certs/cert.pem&quot;,
            &quot;ServerCertSANs&quot;: [],
            &quot;StorePath&quot;: &quot;/root/.docker/machine/machines/docker-node01&quot;
        }
    },
    &quot;Name&quot;: &quot;docker-node01&quot;
}
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上命令也支持-f选项来指定格式，用法同docker image/container inspect 类似；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# docker-machine inspect -f {{.HostOptions.AuthOptions.StorePath}} docker-node01
/root/.docker/machine/machines/docker-node01
[root@node01 ~]# docker-machine inspect -f {{.DriverName}} docker-node01                                      
generic
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　docker-machine ip :获取指定docker主机的ip地址&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# docker-machine ip docker-node01
192.168.0.42
[root@node01 ~]# docker-machine ip docker-node02
192.168.0.43
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　docker-machine ssh :连接指定docker执行命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# docker-machine ssh docker-node01 &quot;ip a&quot;
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens33: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 00:0c:29:91:99:30 brd ff:ff:ff:ff:ff:ff
    inet 192.168.0.42/24 brd 192.168.0.255 scope global ens33
       valid_lft forever preferred_lft forever
    inet6 fe80::20c:29ff:fe91:9930/64 scope link 
       valid_lft forever preferred_lft forever
4: docker0: &amp;lt;NO-CARRIER,BROADCAST,MULTICAST,UP&amp;gt; mtu 1500 qdisc noqueue state DOWN group default 
    link/ether 02:42:0f:e1:e0:f7 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:fff:fee1:e0f7/64 scope link 
       valid_lft forever preferred_lft forever
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　docker-machine scp：在docker主机间以及docker主机和本地之间通过scp命令来远程复制文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# echo &quot;this is test file&quot; &amp;gt; /tmp/test.txt
[root@node01 ~]# cat /tmp/test.txt
this is test file
[root@node01 ~]# docker-machine scp /tmp/test.txt docker-node01:/root/
test.txt                                                                                                                                 100%   18     5.4KB/s   00:00    
[root@node01 ~]# docker-machine ssh docker-node01 &quot;ls -l /root/&quot;
total 4
-rw-r--r-- 1 root root 18 Jun 19 11:26 test.txt
[root@node01 ~]# docker-machine ssh docker-node01 &quot;cat /root/test.txt&quot;
this is test file
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：同scp命令用法类似；&lt;/p&gt;
&lt;p&gt;　　docker-machine rm：删除指定名称的docker主机对应的虚拟主机；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# docker-machine ls
NAME            ACTIVE   DRIVER    STATE     URL                       SWARM   DOCKER      ERRORS
docker-node01   *        generic   Running   tcp://192.168.0.42:2376           v19.03.11   
docker-node02   -        generic   Running   tcp://192.168.0.43:2376           v19.03.11   
[root@node01 ~]# docker-machine rm docker-node02
About to remove docker-node02
WARNING: This action will delete both local reference and remote instance.
Are you sure? (y/n): y
Successfully removed docker-node02
[root@node01 ~]# docker-machine ls
NAME            ACTIVE   DRIVER    STATE     URL                       SWARM   DOCKER      ERRORS
docker-node01   *        generic   Running   tcp://192.168.0.42:2376           v19.03.11   
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：docker-machine rm 只是删除docker-machine上的虚拟主机，对于真正的物理节点上的docker环境并没有删除；实际上就切断对指定docker主机的管控；&lt;/p&gt;
&lt;p&gt;　　docker-machine upgrade:将指定主机的docker版本更新为最新&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# docker-machine upgrade docker-node01
Waiting for SSH to be available...
Detecting the provisioner...
Upgrading docker...
Restarting docker...
[root@node01 ~]# docker-machine ls
NAME            ACTIVE   DRIVER    STATE     URL                       SWARM   DOCKER      ERRORS
docker-node01   *        generic   Running   tcp://192.168.0.42:2376           v19.03.11   
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：如果指定docker主机的版本已经是最新的版本，那么它将不会再更新；&lt;/p&gt;
&lt;p&gt;　　docker-machine url：获取指定主机监听URL&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# docker-machine url docker-node01
tcp://192.168.0.42:2376
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：通过docker-machine安装的docker环境，实际上就是把yum安装的docker环境，客户端和服务端分离了，各个节点就是各个服务端，而docker-machine就是同一的客户端，因为客户端和服务端不再同一主机，所以它会把docker监听在一个TCP端口上，方便客户端的来连接管理；&lt;/p&gt;
</description>
<pubDate>Fri, 19 Jun 2020 15:45:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>前文我们聊了下docker容器的资源限制，回顾请参考https://www.cnblogs.com/qiuhom-1874/p/13138725.html；今天我们来聊一聊docker machine</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/13160915.html</dc:identifier>
</item>
<item>
<title>Thunk函数的使用 - WindrunnerMax</title>
<link>http://www.cnblogs.com/WindrunnerMax/p/13167010.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/WindrunnerMax/p/13167010.html</guid>
<description>&lt;p&gt;编译器的求值策略通常分为传值调用以及传名调用，&lt;code&gt;Thunk&lt;/code&gt;函数是应用于编译器的传名调用实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体，这个临时函数就叫做&lt;code&gt;Thunk&lt;/code&gt; 函数。&lt;/p&gt;
&lt;h2 id=&quot;求值策略&quot;&gt;求值策略&lt;/h2&gt;
&lt;p&gt;编译器的求值策略通常分为传值调用以及传名调用，在下面的例子中，将一个表达式作为参数进行传递，传值调用以及传名调用中实现的方式有所不同。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;var x = 1;

function s(y){
    console.log(y + 1); // 3
}

s(x + 1);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上述的例子中，无论是使用传值调用还是使用传名调用，执行的结果都是一样的，但是其调用过程不同：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;传值调用：首先计算&lt;code&gt;x + 1&lt;/code&gt;，然后将计算结果&lt;code&gt;2&lt;/code&gt;传递到&lt;code&gt;s&lt;/code&gt;函数，即相当于调用&lt;code&gt;s(2)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;传名调用：直接将&lt;code&gt;x + 1&lt;/code&gt;表达式传递给&lt;code&gt;y&lt;/code&gt;，使用时再计算&lt;code&gt;x + 1&lt;/code&gt;，即相当于计算&lt;code&gt;(x + 1) + 1&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;传值调用与传名调用各有利弊，传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成没有必要的计算。传名调用可以解决这个问题，但是实现相对来说比较复杂。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;var x = 1;

function s(y){
    console.log(y + 1); // 3
}

s(x + 1, x + 2);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面这个例子中，函数&lt;code&gt;s&lt;/code&gt;并没有用到&lt;code&gt;x + 2&lt;/code&gt;这个表达式求得的值，使用传名调用的话只将表达式传入而并未计算，只要在函数中没有用到&lt;code&gt;x + 2&lt;/code&gt;这个表达式就不会计算，使用传值调用的话就会首先将&lt;code&gt;x + 2&lt;/code&gt;的值计算然后传入，如果没有用到这个值，那么就多了一次没有必要的计算。&lt;code&gt;Thunk&lt;/code&gt;函数就是作为传名调用的实现而构建的，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体，这个临时函数就叫做&lt;code&gt;Thunk&lt;/code&gt; 函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;var x = 1;

function s(y){
    console.log(y + 1); // 3
}

s(x + 1);

// 等同于

var x = 1;

function s(thunk){
    console.log(thunk() + 1); // 3
}

var thunk = function(){
    return x + 1;
}

s(thunk);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;js中的thunk函数&quot;&gt;Js中的Thunk函数&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Js&lt;/code&gt;中的求值策略是是传值调用，在&lt;code&gt;Js&lt;/code&gt;中使用&lt;code&gt;Thunk&lt;/code&gt;函数需要手动进行实现且含义有所不同，在&lt;code&gt;Js&lt;/code&gt;中，&lt;code&gt;Thunk&lt;/code&gt;函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;// 假设一个延时函数需要传递一些参数
// 通常使用的版本如下
var delayAsync = function(time, callback, ...args){
    setTimeout(() =&amp;gt; callback(...args), time);
}

var callback = function(x, y, z){
    console.log(x, y, z);
}

delayAsync(1000, callback, 1, 2, 3);

// 使用Thunk函数

var thunk = function(time, ...args){
    return function(callback){
        setTimeout(() =&amp;gt; callback(...args), time);
    }
}

var callback = function(x, y, z){
    console.log(x, y, z);
}

var delayAsyncThunk = thunk(1000, 1, 2, 3);
delayAsyncThunk(callback);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现一个简单的&lt;code&gt;Thunk&lt;/code&gt;函数转换器，对于任何函数，只要参数有回调函数，就能写成&lt;code&gt;Thunk&lt;/code&gt;函数的形式。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;var convertToThunk = function(funct){
  return function (...args){
    return function (callback){
      return funct.apply(this, args);
    }
  };
};

var callback = function(x, y, z){
    console.log(x, y, z);
}

var delayAsyncThunk = convertToThunk(function(time, ...args){
    setTimeout(() =&amp;gt; callback(...args), time);
});

thunkFunct = delayAsyncThunk(1000, 1, 2, 3);
thunkFunct(callback);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Thunk&lt;/code&gt;函数在&lt;code&gt;ES6&lt;/code&gt;之前可能应用比较少，但是在&lt;code&gt;ES6&lt;/code&gt;之后，出现了&lt;code&gt;Generator&lt;/code&gt;函数，通过使用&lt;code&gt;Thunk&lt;/code&gt;函数就可以可以用于&lt;code&gt;Generator&lt;/code&gt;函数的自动流程管理。首先是关于&lt;code&gt;Generator&lt;/code&gt;函数的基本使用，调用一个生成器函数并不会马上执行它里面的语句，而是返回一个这个生成器的迭代器&lt;code&gt;iterator&lt;/code&gt; 对象，他是一个指向内部状态对象的指针。当这个迭代器的&lt;code&gt;next()&lt;/code&gt;方法被首次（后续）调用时，其内的语句会执行到第一个（后续）出现&lt;code&gt;yield&lt;/code&gt;的位置为止，&lt;code&gt;yield&lt;/code&gt;后紧跟迭代器要返回的值，也就是指针就会从函数头部或者上一次停下来的地方开始执行到下一个&lt;code&gt;yield&lt;/code&gt;。或者如果用的是&lt;code&gt;yield*&lt;/code&gt;，则表示将执行权移交给另一个生成器函数（当前生成器暂停执行）。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;function* f(x) {
    yield x + 10;
    yield x + 20;
    return x + 30;
}
var g = f(1);
console.log(g); // f {&amp;lt;suspended&amp;gt;}
console.log(g.next()); // {value: 11, done: false}
console.log(g.next()); // {value: 21, done: false}
console.log(g.next()); // {value: 31, done: true}
console.log(g.next()); // {value: undefined, done: true} // 可以无限next()，但是value总为undefined，done总为true
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于&lt;code&gt;Generator&lt;/code&gt;函数能够将函数的执行暂时挂起，那么他就完全可以操作一个异步任务，当上一个任务完成之后再继续下一个任务，下面这个例子就是将一个异步任务同步化表达，当上一个延时定时器完成之后才会进行下一个定时器任务，可以通过这种方式解决一个异步嵌套的问题，例如利用回调的方式需要在一个网络请求之后加入一次回调进行下一次请求，很容易造成回调地狱，而通过&lt;code&gt;Generator&lt;/code&gt;函数就可以解决这个问题，事实上&lt;code&gt;async/await&lt;/code&gt;就是利用的&lt;code&gt;Generator&lt;/code&gt;函数以及&lt;code&gt;Promise&lt;/code&gt;实现的异步解决方案。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;var it = null;

function f(){
    var rand = Math.random() * 2;
    setTimeout(function(){
        if(it) it.next(rand);
    },1000)
}

function* g(){ 
    var r1 = yield f();
    console.log(r1);
    var r2 = yield f();
    console.log(r2);
    var r3 = yield f();
    console.log(r3);
}

it = g();
it.next();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然上边的例子能够自动执行，但是不够方便，现在实现一个&lt;code&gt;Thunk&lt;/code&gt;函数的自动流程管理，其自动帮我们进行回调函数的处理，只需要在&lt;code&gt;Thunk&lt;/code&gt;函数中传递一些函数执行所需要的参数比如例子中的&lt;code&gt;index&lt;/code&gt;，然后就可以编写&lt;code&gt;Generator&lt;/code&gt;函数的函数体，通过左边的变量接收&lt;code&gt;Thunk&lt;/code&gt;函数中&lt;code&gt;funct&lt;/code&gt;执行的参数，在使用&lt;code&gt;Thunk&lt;/code&gt;函数进行自动流程管理时，必须保证&lt;code&gt;yield&lt;/code&gt;后是一个&lt;code&gt;Thunk&lt;/code&gt;函数。&lt;br/&gt;关于自动流程管理&lt;code&gt;run&lt;/code&gt;函数，首先需要知道在调用&lt;code&gt;next()&lt;/code&gt;方法时，如果传入了参数，那么这个参数会传给上一条执行的&lt;code&gt;yield&lt;/code&gt;语句左边的变量，在这个函数中，第一次执行&lt;code&gt;next&lt;/code&gt;时并未传递参数，而且在第一个&lt;code&gt;yield&lt;/code&gt;上边也并不存在接收变量的语句，无需传递参数，接下来就是判断是否执行完这个生成器函数，在这里并没有执行完，那么将自定义的&lt;code&gt;next&lt;/code&gt;函数传入&lt;code&gt;res.value&lt;/code&gt;中，这里需要注意&lt;code&gt;res.value&lt;/code&gt;是一个函数，可以在下边的例子中将注释的那一行执行，然后就可以看到这个值是&lt;code&gt;f(funct){...}&lt;/code&gt;，此时我们将自定义的&lt;code&gt;next&lt;/code&gt;函数传递后，就将&lt;code&gt;next&lt;/code&gt;的执行权限交予了&lt;code&gt;f&lt;/code&gt;这个函数，在这个函数执行完异步任务后，会执行回调函数，在这个回调函数中会触发生成器的下一个&lt;code&gt;next&lt;/code&gt;方法，并且这个&lt;code&gt;next&lt;/code&gt;方法是传递了参数的，上文提到传入参数后会将其传递给上一条执行的&lt;code&gt;yield&lt;/code&gt;语句左边的变量，那么在这一次执行中会将这个参数值传递给&lt;code&gt;r1&lt;/code&gt;，然后在继续执行&lt;code&gt;next&lt;/code&gt;，不断往复，直到生成器函数结束运行，这样就实现了流程的自动管理。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;function thunkFunct(index){
    return function f(funct){
        var rand = Math.random() * 2;
        setTimeout(() =&amp;gt; funct({rand:rand, index: index}), 1000)
    }
}

function* g(){ 
    var r1 = yield thunkFunct(1);
    console.log(r1.index, r1.rand);
    var r2 = yield thunkFunct(2);
    console.log(r2.index, r2.rand);
    var r3 = yield thunkFunct(3);
    console.log(r3.index, r3.rand);
}

function run(generator){
    var g = generator();

    var next = function(data){
        var res = g.next(data);
        if(res.done) return ;
        // console.log(res.value);
        res.value(next);
    }

    next();
}

run(g);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;每日一题&quot;&gt;每日一题&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;https://github.com/WindrunnerMax/EveryDay
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;https://www.jianshu.com/p/9302a1d01113
https://segmentfault.com/a/1190000017211798
http://www.ruanyifeng.com/blog/2015/05/thunk.html
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 19 Jun 2020 15:33:00 +0000</pubDate>
<dc:creator>WindrunnerMax</dc:creator>
<og:description>Thunk函数的使用 编译器的求值策略通常分为传值调用以及传名调用，Thunk函数是应用于编译器的传名调用实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体，这个临时函数就叫做Thun</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/WindrunnerMax/p/13167010.html</dc:identifier>
</item>
<item>
<title>C#中的闭包和意想不到的坑 - 老胡写代码</title>
<link>http://www.cnblogs.com/deatharthas/p/13166987.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/deatharthas/p/13166987.html</guid>
<description>&lt;p&gt;虽然闭包主要是函数式编程的玩意儿，而C#的最主要特征是面向对象，但是利用委托或lambda表达式，C#也可以写出具有函数式编程风味的代码。同样的，使用委托或者lambda表达式，也可以在C#中使用闭包。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;根据WIKI的定义，闭包又称语法闭包或函数闭包，是在函数式编程语言中实现语法绑定的一种技术。闭包在实现上是一个结构体，它存储了一个函数（通常是其入口地址）和一个关联的环境（相当于一个符号查找表）。闭包也可以延迟变量的生存周期。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;嗯。。看定义好像有点迷糊，让我们看看下面的例子吧&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;    class Program
    {
        static Action CreateGreeting(string message)
        {
            return () =&amp;gt; { Console.WriteLine(&quot;Hello &quot; + message); };
        }

        static void Main()
        {
            Action action = CreateGreeting(&quot;DeathArthas&quot;);
            action();
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个例子非常简单，用lambda表达式创建一个Action对象，之后再调用这个Action对象。&lt;br/&gt;但是仔细观察会发现，当Action对象被调用的时候，&lt;strong&gt;CreateGreeting&lt;/strong&gt;方法已经返回了，作为它的实参的message应该已经被销毁了，那么为什么我们在调用Action对象的时候，还是能够得到正确的结果呢？&lt;br/&gt; &lt;br/&gt;原来奥秘就在于，这里形成了闭包。虽然CreateGreeting已经返回了，但是它的局部变量被返回的lambda表达式所捕获，延迟了其生命周期。怎么样，这样再回头看闭包定义，是不是更清楚了一些？&lt;br/&gt; &lt;br/&gt;闭包就是这么简单，其实我们经常都在使用，只是有时候我们都不自知而已。比如大家肯定都写过类似下面的代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;void AddControlClickLogger(Control control, string message)
{
        control.Click += delegate
        {
                Console.WriteLine(&quot;Control clicked: {0}&quot;, message);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的代码其实就用了闭包，因为我们可以肯定，在control被点击的时候，这个message早就超过了它的声明周期。合理使用闭包，可以确保我们写出在空间和时间上面解耦的委托。&lt;br/&gt; &lt;br/&gt;不过在使用闭包的时候，要注意一个陷阱。因为闭包会延迟局部变量的生命周期，在某些情况下程序产生的结果会和预想的不一样。让我们看看下面的例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;    class Program
    {
        static List&amp;lt;Action&amp;gt; CreateActions()
        {
            var result = new List&amp;lt;Action&amp;gt;();
            for(int i = 0; i &amp;lt; 5; i++)
            {
                result.Add(() =&amp;gt; Console.WriteLine(i));
            }
            return result;
        }

        static void Main()
        {
            var actions = CreateActions();
            for(int i = 0;i&amp;lt;actions.Count;i++)
            {
                actions[i]();
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个例子也非常简单，创建一个Action链表并依次执行它们。看看结果&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/699616/202006/699616-20200619232302496-478930213.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/699616/202006/699616-20200619232323070-260733096.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相信很多人看到这个结果的表情是这样的！！难道不应该是0，1，2，3，4吗？出了什么问题？&lt;/p&gt;
&lt;p&gt;刨根问底，这儿的问题还是出现在闭包的本质上面，作为“闭包延迟了变量的生命周期”这个硬币的另外一面，是一个变量可能在不经意间被多个闭包所引用。&lt;/p&gt;
&lt;p&gt;在这个例子里面，局部变量i同时被5个闭包引用，这5个闭包共享i，所以最后他们打印出来的值是一样的，都是i最后退出循环时候的值5。&lt;/p&gt;
&lt;p&gt;要想解决这个问题也很简单，多声明一个局部变量，让各个闭包引用自己的局部变量就可以了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;     //其他都保持与之前一致
        static List&amp;lt;Action&amp;gt; CreateActions()
        {
            var result = new List&amp;lt;Action&amp;gt;();
            for (int i = 0; i &amp;lt; 5; i++)
            {
                int temp = i; //添加局部变量
                result.Add(() =&amp;gt; Console.WriteLine(temp));
            }
            return result;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/699616/202006/699616-20200619232402717-947425187.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样各个闭包引用不同的局部变量，刚刚的问题就解决了。&lt;/p&gt;
&lt;p&gt;除此之外，还有一个修复的方法，在创建闭包的时候，使用&lt;strong&gt;foreach&lt;/strong&gt;而不是&lt;strong&gt;for&lt;/strong&gt;。至少在C# 7.0 的版本上面，这个问题已经被注意到了，使用foreach的时候编译器会自动生成代码绕过这个闭包陷阱。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;     //这样fix也是可以的
        static List&amp;lt;Action&amp;gt; CreateActions()
        {
            var result = new List&amp;lt;Action&amp;gt;();
            foreach (var i in Enumerable.Range(0,5))
            {
                result.Add(() =&amp;gt; Console.WriteLine(i));
            }
            return result;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就是在闭包在C#中的使用和其使用中的一个小陷阱，希望大家能通过老胡的文章了解到这个知识点并且在开发中少走弯路！&lt;/p&gt;
</description>
<pubDate>Fri, 19 Jun 2020 15:25:00 +0000</pubDate>
<dc:creator>老胡写代码</dc:creator>
<og:description>虽然闭包主要是函数式编程的玩意儿，而C#的最主要特征是面向对象，但是利用委托或lambda表达式，C#也可以写出具有函数式编程风味的代码。同样的，使用委托或者lambda表达式，也可以在C#中使用闭包</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/deatharthas/p/13166987.html</dc:identifier>
</item>
<item>
<title>从 0 开始机器学习 - 神经网络反向 BP 算法！ - 登龙</title>
<link>http://www.cnblogs.com/dlonng/p/13166974.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dlonng/p/13166974.html</guid>
<description>&lt;p&gt;最近一个月项目好忙，终于挤出时间把这篇 BP 算法基本思想写完了，公式的推导放到下一篇讲吧。&lt;/p&gt;
&lt;h2 id=&quot;一、神经网络的代价函数&quot;&gt;一、神经网络的代价函数&lt;/h2&gt;
&lt;p&gt;神经网络可以看做是复杂逻辑回归的组合，因此与其类似，我们训练神经网络也要定义代价函数，之后再使用梯度下降法来最小化代价函数，以此来训练最优的权重矩阵。&lt;/p&gt;
&lt;h3 id=&quot;11-从逻辑回归出发&quot;&gt;1.1 从逻辑回归出发&lt;/h3&gt;
&lt;p&gt;我们从经典的逻辑回归代价函数引出，先来复习下：&lt;/p&gt;
&lt;p&gt;\[J(\theta) = \frac{1}{m}\sum\limits_{i = 1}^{m}{[-{y^{(i)}}\log ({h_\theta}({x^{(i)}}))-( 1-{y^{(i)}})\log ( 1 - h_\theta({x^{(i)}}))]} + \frac{\lambda}{2m} \sum\limits_{j=1}^{n}{\theta_j^2} \]&lt;/p&gt;
&lt;p&gt;逻辑回归代价函数计算每个样本的输入与输出的误差，然后累加起来除以样本数，再加上正则化项，这个我之前的博客已经写过了：&lt;/p&gt;
&lt;p&gt;这里补充一点对单变量逻辑回归代价函数的理解，虽然这一行代价公式很长：&lt;/p&gt;
&lt;p&gt;\[cost(i) = -{y^{(i)}}\log ({h_\theta}({x^{(i)}}))-( 1-{y^{(i)}})\log ( 1 - h_\theta({x^{(i)}})) \]&lt;/p&gt;
&lt;p&gt;但是其实可以把它简单的理解为输出与输入的方差，虽然形式上差别很大，但是可以帮助我们理解上面这个公式到底在计算什么，就是计算输出与输入的方差，这样理解就可以：&lt;/p&gt;
&lt;p&gt;\[cost(i) = h_{\theta}(x^{(i)} - y^{(i)})^2 \]&lt;/p&gt;
&lt;h3 id=&quot;12-一步步写出神经网络代价函数&quot;&gt;1.2 一步步写出神经网络代价函数&lt;/h3&gt;
&lt;p&gt;前面讲的简单逻辑回归的只有一个输出变量，但是在神经网络中输出层可以有多个神经元，所以可以有很多种的输出，比如 K 分类问题，神经元的输出是一个 K 维的向量：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dlonng.oss-cn-shenzhen.aliyuncs.com/blog/k_output.jpeg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此我们需要对每个维度计算预测输出与真实标签值的误差，即对 K 个维度的误差做一次求和：&lt;/p&gt;
&lt;p&gt;\[\sum\limits_{i = 1}^{k}{[-{y_k^{(i)}}\log ({h_\theta}({x^{(i)}}))_k-( 1-{y_k^{(i)}})\log ( 1 - h_\theta({x^{(i)}})_k)]} \]&lt;/p&gt;
&lt;p&gt;然后累加训练集的 m 个样本：&lt;/p&gt;
&lt;p&gt;\[-\frac{1}{m}[\sum\limits_{i = 1}^{m}\sum\limits_{k = 1}^{k}{[-{y_k^{(i)}}\log ({h_\theta}({x^{(i)}}))_k-( 1-{y_k^{(i)}})\log ( 1 - h_\theta({x^{(i)}})_k)]}] \]&lt;/p&gt;
&lt;p&gt;再加上所有权重矩阵元素的正则化项，注意 &lt;span class=&quot;math inline&quot;&gt;\(i, j\)&lt;/span&gt; 都是从 1 开始的，因为每一层的 &lt;span class=&quot;math inline&quot;&gt;\(\theta_0\)&lt;/span&gt; 是偏置单元，不需要对其进行正则化：&lt;/p&gt;
&lt;p&gt;\[\frac{\lambda}{2m}\sum\limits_{i = l}^{L - 1}\sum\limits_{i = 1}^{S_l}\sum\limits_{j = 1}^{S_l + 1}(\theta_{ji}^{(l)})^2 \]&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最内层求和：循环一个权重矩阵所有的行，行数是 &lt;span class=&quot;math inline&quot;&gt;\(S_l + 1\)&lt;/span&gt; 层激活单元数&lt;/li&gt;
&lt;li&gt;中间层求和：循环一个权重矩阵所有的列，列数是 &lt;span class=&quot;math inline&quot;&gt;\(S_l\)&lt;/span&gt; 层激活单元数&lt;/li&gt;
&lt;li&gt;最外层求和：循环所有的权重矩阵&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这就得到了输出层为 K 个单元神经网络最终的代价函数：&lt;/p&gt;
&lt;p&gt;\[J(\theta) = -\frac{1}{m}[\sum\limits_{i = 1}^{m}\sum\limits_{k = 1}^{k}{[-{y_k^{(i)}}\log ({h_\theta}({x^{(i)}}))_k-( 1-{y_k^{(i)}})\log ( 1 - h_\theta({x^{(i)}})_k)]}] + \frac{\lambda}{2m}\sum\limits_{i = l}^{L - 1}\sum\limits_{i = 1}^{S_l}\sum\limits_{j = 1}^{S_l + 1}(\theta_{ji}^{(l)})^2 \]&lt;/p&gt;
&lt;p&gt;有了代价函数后，就可以通过反向传播算法来训练一个神经网络啦！&lt;/p&gt;
&lt;h2 id=&quot;二、神经网络反向-bp（back-propagation）-算法&quot;&gt;二、神经网络反向 BP（Back Propagation） 算法&lt;/h2&gt;
&lt;h3 id=&quot;21-bp-算法简介&quot;&gt;2.1 BP 算法简介&lt;/h3&gt;
&lt;p&gt;之前写神经网络基础的时候，跟大家分享了如何用训练好的神经网络来预测手写字符：&lt;a href=&quot;https://dlonng.com/posts/neural-digit&quot;&gt;从 0 开始机器学习 - 神经网络识别手写字符！&lt;/a&gt;,只不过当时我们没有训练网络，而是使用已经训练好的神经网络的权重矩阵来进行前馈预测，那么我们如何自己训练神经网络呢？&lt;/p&gt;
&lt;p&gt;这就需要学习反向 BP 算法，这个算法可以帮助我们求出神经网络权重矩阵中每个元素的偏导数，进而利用梯度下降法来最小化上面的代价函数，你可以联想简单的线性回归算法：&lt;a href=&quot;https://dlonng.com/posts/ml-multi-feature&quot;&gt;从 0 开始机器学习 - 一文入门多维特征梯度下降法！&lt;/a&gt;，也是先求每个参数的偏导数，然后在梯度下降算法中使用求出的偏导数来迭代下降。&lt;/p&gt;
&lt;p&gt;因此训练神经网络的关键就是：&lt;strong&gt;如何求出每个权重系数的偏导数？&lt;/strong&gt;，反向 BP 就可以解决这个问题！这里强烈建议你学习的时候完全搞懂 BP 算法的原理，最好自己独立推导一遍公式，因为你以后学习深度学习那些复杂的网络，不管是哪种，最终都要使用反向 BP 来训练，这个 BP 算法是最核心的东西，面试也逃不过的，所以既然要学，就要学懂，不然就是在浪费时间。&lt;/p&gt;
&lt;h3 id=&quot;22-bp-算法基本原理&quot;&gt;2.2 BP 算法基本原理&lt;/h3&gt;
&lt;p&gt;我先用个例子简单介绍下 BP 算法的基本原理和步骤，公式的推导放到下一节，反向 BP 算法顾名思义，与前馈预测方向相反：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;计算最后一层输出与实际标签值的误差，反向传播到倒数第二层&lt;/li&gt;
&lt;li&gt;计算倒数第二层的传播误差，反向传播到倒数第三层&lt;/li&gt;
&lt;li&gt;以此类推，一层一层地求出各层的误差&lt;/li&gt;
&lt;li&gt;直到第二层结束，因为第一层是输入特征，不是我们计算的，所以不需要求误差&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以下面这个 4 层的神经网络为例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dlonng.oss-cn-shenzhen.aliyuncs.com/blog/bp-example.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假如我们的训练集只有 1 个样本 &lt;span class=&quot;math inline&quot;&gt;\((x^{(1)}, y^{(1)})\)&lt;/span&gt;，每层所有激活单元的输出用 &lt;span class=&quot;math inline&quot;&gt;\(a^{(i)}\)&lt;/span&gt; 向量表示，每层所有激活单元的误差用 &lt;span class=&quot;math inline&quot;&gt;\(\delta^{(i)}\)&lt;/span&gt; 向量表示，来看下反向传播的计算步骤（公式的原理下一节讲）：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;输出层的误差为预测值减去真实值：&lt;span class=&quot;math inline&quot;&gt;\(\delta^{(4)} = a^{(4)} - y^{(1)}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;倒数第二层的误差为：&lt;span class=&quot;math inline&quot;&gt;\(\delta^{(3)} = (W^{(3)})^T \delta^{(4)} * g'(z^{(3)})\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;倒数第三层的误差为：&lt;span class=&quot;math inline&quot;&gt;\(\delta^{(2)} = (W^{(2)})^T \delta^{(3)} * g'(z^{(2)})\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;第一层是输入变量，不需要计算误差&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;有了每层所有激活单元的误差后，就可以计算代价函数对每个权重参数的偏导数，即每个激活单元的输出乘以对应的误差，这里不考虑正则化：&lt;/p&gt;
&lt;p&gt;\[\frac {\partial}{\partial W_{ij}^{(l)}} J (W) = a_{j}^{(l)} \delta_{i}^{(l+1)} \]&lt;/p&gt;
&lt;p&gt;解释下这个偏导数的计算：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt; 表示目前计算的是第几层&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt; 表示当前层中正在计算的激活单元下标（&lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt; 作为列）&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 表示下一层误差单元的下标（&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 作为行）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个计算过程是对一个样本进行的，网络的输入是一个特征向量，所以每层计算的误差也是向量，但是我们的网络输入是特征矩阵的话，就不能用一个个向量来表示误差了，而是应该也将误差向量组成误差矩阵，因为特征矩阵就是多个样本，每个样本都做一个反向传播，就会计算误差，所以我们每次都把一个样本计算的误差累加到误差矩阵中：&lt;/p&gt;
&lt;p&gt;\[\Delta_{ij}^{(l)} = \Delta_{ij}^{(l)} + a_{j}^{(l)} \delta_{i}^{(l+1)} \]&lt;/p&gt;
&lt;p&gt;然后，我们需要除以样本总数 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;，因为上面的误差是累加了所有 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 个训练样本得到的，并且我们还需要考虑加上正则化防止过拟合，注意对偏置单元不需要正则化，这点已经提过好多次了：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;非偏置单元正则化后的偏导数 &lt;span class=&quot;math inline&quot;&gt;\(j \neq 0\)&lt;/span&gt;：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;\[D_{ij}^{(l)} = \frac {1}{m}\Delta_{ij}^{(l)}+\lambda W_{ij}^{(l)} \]&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;偏置单元正则化后的偏导数 &lt;span class=&quot;math inline&quot;&gt;\(j = 0\)&lt;/span&gt;：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;\[D_{ij}^{(l)} = \frac{1}{m}\Delta_{ij}^{(l)} \]&lt;/p&gt;
&lt;p&gt;最后计算的所有偏导数就放在误差矩阵中：&lt;/p&gt;
&lt;p&gt;\[\frac {\partial}{\partial W_{ij}^{(l)}} J (W) = D_{ij}^{(l)} \]&lt;/p&gt;
&lt;p&gt;这样我们就求出了每个权重参数的偏导数，再回想之前的梯度下降法，我们有了偏导数计算方法后，直接送到梯度下降法中进行迭代就可以最小化代价函数了，比如我在 Python 中把上面的逻辑写成一个正则化梯度计算的函数 &lt;code&gt;regularized_gradient&lt;/code&gt;，然后再用 &lt;code&gt;scipy.optimize&lt;/code&gt; 等优化库直接最小化文章开头提出的神经网络代价函数，以此来使用反向 BP 算法训练一个神经网络：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import scipy.optimize as opt

res = opt.minimize(fun = 神经网络代价函数,
                       x0 = init_theta,
                       args = (X, y, 1),
                       method = 'TNC',
                       jac = regularized_gradient,
                       options = {'maxiter': 400})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以神经网络反向 BP 算法关键就是理解每个权重参数偏导数的计算步骤和方法！关于偏导数计算公式的详细推导过程，我打算在下一篇文章中单独分享，本次就不带大家一步步推导了，否则内容太多，先把基本步骤搞清楚，后面推导公式就容易理解。&lt;/p&gt;
&lt;h3 id=&quot;23-反向-bp-算法的直观理解&quot;&gt;2.3 反向 BP 算法的直观理解&lt;/h3&gt;
&lt;p&gt;之前学习前馈预测时，我们知道一个激活单元是输入是上一层所有激活单元的输出与权重的加权和（包含偏置），计算方向从左到右，计算的是每个激活单元的输出，看图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dlonng.oss-cn-shenzhen.aliyuncs.com/blog/forward_prect.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实反向 BP 算法也是做类似的计算，一个激活单元误差的输入是后一层所有误差与权重的加权和（可能不包含偏置），只不过这里计算的反向是从右向左，计算的是每个激活单元的误差，对比看图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dlonng.oss-cn-shenzhen.aliyuncs.com/blog/back_bp_delta.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你只需要把单个神经元的前馈预测和反向 BP 的计算步骤搞清楚就可以基本理解反向 BP 的基本过程，因为所有的参数都是这样做的。&lt;/p&gt;
&lt;h2 id=&quot;三、神经网络编程细节&quot;&gt;三、神经网络编程细节&lt;/h2&gt;
&lt;h3 id=&quot;31-随机初始化&quot;&gt;3.1 随机初始化&lt;/h3&gt;
&lt;p&gt;每种优化算法都需要初始化参数，之前的线性回归初始化参数为 0 是没问题的，但是如果把神经网络的初始参数都设置为 0，就会有问题，因为第二层的输入是要用到权重与激活单元输出的乘积：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果权重都是 0，则每层网络的输出都是 0&lt;/li&gt;
&lt;li&gt;如果权重都是相同的常数 &lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt;，则每层网络的输出也都相同，只是不为 0&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://dlonng.oss-cn-shenzhen.aliyuncs.com/blog/random_init.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以为了在神经网络中避免以上的问题，我们采用随机初始化，把所有的参数初始化为 &lt;span class=&quot;math inline&quot;&gt;\([-\epsilon, \epsilon]\)&lt;/span&gt; 之间的随机值，比如初始化一个 10 X 11 的权重参数矩阵：&lt;/p&gt;
&lt;p&gt;\[initheta = rand(10, 11) * (2 * \epsilon) - \epsilon \]&lt;/p&gt;
&lt;h3 id=&quot;32-矩阵---向量&quot;&gt;3.2 矩阵 &amp;lt;-&amp;gt; 向量&lt;/h3&gt;
&lt;p&gt;注意上面优化库的输入 &lt;code&gt;X0 = init_theta&lt;/code&gt; 是一个向量，而我们的神经网络每 2 层之间就有一个权重矩阵，所以为了把权重矩阵作为优化库的输入，我们必须要把所有的权重参数都组合到一个向量中，也就是实现一个把矩阵组合到向量的功能，但是优化库的输出也是一个包含所有权重参数的向量，我们拿到向量后还需要把它转换为每 2 层之间的权重矩阵，这样才能进行前馈预测：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;训练前：初始多个权重矩阵 -&amp;gt; 一个初始向量&lt;/li&gt;
&lt;li&gt;训练后：一个最优向量 -&amp;gt; 多个最优权重矩阵&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://dlonng.oss-cn-shenzhen.aliyuncs.com/blog/matrix2vec.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;33-梯度校验&quot;&gt;3.3 梯度校验&lt;/h3&gt;
&lt;p&gt;梯度校验是用来检验我们的 BP 算法计算的偏导数是否和真实的偏导数存在较大误差，计算以下 2 个偏导数向量的误差：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;反向 BP 算法计算的偏导数&lt;/li&gt;
&lt;li&gt;利用导数定义计算的偏导数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于单个参数，在一点 &lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt; 处的导数可由 &lt;span class=&quot;math inline&quot;&gt;\([\theta - \epsilon, \theta + \epsilon]\)&lt;/span&gt; 表示，这也是导数定义的一种：&lt;/p&gt;
&lt;p&gt;\[grad = \frac{J(\theta + \epsilon) - J(\theta - \epsilon)}{2 \epsilon} \]&lt;/p&gt;
&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dlonng.oss-cn-shenzhen.aliyuncs.com/blog/grad_check.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是我们的神经网络代价函数有很多参数，当我们把参数矩阵转为向量后，可以对向量里的每个参数进行梯度检验，只需要分别用定义求偏导数即可，比如检验 &lt;span class=&quot;math inline&quot;&gt;\(\theta_1\)&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;\[\frac {\partial J}{\partial \theta_1} = \frac {J (\theta_1 + \varepsilon_1, \theta_2, \theta_3 ... \theta_n ) - J(\theta_1 - \varepsilon_1, \theta_2, \theta_3 ... \theta_n)}{2 \varepsilon} \]&lt;/p&gt;
&lt;p&gt;以此类推，检验 &lt;span class=&quot;math inline&quot;&gt;\(\theta_n\)&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;\[\frac {\partial J}{\partial \theta_n} = \frac {J (\theta_1, \theta_2, \theta_3 ... \theta_n + \varepsilon_n) - J(\theta_1, \theta_2, \theta_3 ... \theta_n - \varepsilon_n)}{2 \varepsilon} \]&lt;/p&gt;
&lt;p&gt;求出导数定义的偏导数后，与 BP 算法计算的偏导数计算误差，在误差范围内认为 BP 算法计算的偏导数（D_vec）是正确的，梯度检验的伪代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;for i = 1 : n
  theta_plus = theta
  theta_plus[i] = theta_plus + epsilon
  
  theta_minu = theta
  theta_minu[i] = theta_minu - epsilon
  
  grad = (J(theta_plus) - J(theta_minu)) / (2 * epsilon)
end

check 误差: grad 是否约等于 D_vec
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意一点&lt;/strong&gt;：梯度检验通常速度很慢，在训练神经网络前先别进行检验！&lt;/p&gt;
&lt;p&gt;今天就到这，溜了溜了，下篇文章见：）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dlonng.oss-cn-shenzhen.aliyuncs.com/yingliu_code/yinliu_code.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 19 Jun 2020 15:22:00 +0000</pubDate>
<dc:creator>登龙</dc:creator>
<og:description>最近一个月项目好忙，终于挤出时间把这篇 BP 算法基本思想写完了，公式的推导放到下一篇讲吧。 一、神经网络的代价函数 神经网络可以看做是复杂逻辑回归的组合，因此与其类似，我们训练神经网络也要定义代价函</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dlonng/p/13166974.html</dc:identifier>
</item>
</channel>
</rss>