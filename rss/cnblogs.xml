<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>[开源] SEPP——研发协作一站式管理平台 - 槽神刘叫兽</title>
<link>http://www.cnblogs.com/fudax/p/12169461.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fudax/p/12169461.html</guid>
<description>&lt;pre&gt;
&lt;code&gt;[http://www.seqcer.com](http://www.seqcer.com)&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;推荐注册并创建自己的项目便于隔离数据胡搞而不影响其他试用者&quot;&gt;推荐注册，并创建自己的项目，便于隔离数据胡搞而不影响其他试用者&lt;/h4&gt;
&lt;h4 id=&quot;仅对chrome浏览器做了完全适配其他chromium核心浏览器或者firefoxsafari也能使用但是不推荐&quot;&gt;仅对chrome浏览器做了完全适配，其他chromium核心浏览器或者firefox、safari也能使用，但是不推荐&lt;/h4&gt;
&lt;/blockquote&gt;


&lt;ul&gt;&lt;li&gt;先赏个STAR&lt;/li&gt;
&lt;li&gt;再加QQ群：362260709&lt;/li&gt;
&lt;li&gt;再问问题，当然，建议提问之前仔细看完下面的说明&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;前端：vue2、axios、element等等等等&lt;/li&gt;
&lt;li&gt;后端：springboot、guava、lombok等等等等&lt;/li&gt;
&lt;li&gt;基础组件：mariadb(10.3)、nginx(1.15.3)、nodejs(8.12.0)、fastdfs、npm(6.7.0)、webpack4等等&lt;/li&gt;
&lt;li&gt;插件：swagger2、quartz、aviator、h2等等&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;启动方式&quot;&gt;启动方式：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;Main Class：com.pr.sepp.SeppApplication（线上可注释掉@EnableSwagger2）&lt;/li&gt;
&lt;li&gt;本地VM options：-Denv=local&lt;/li&gt;
&lt;li&gt;注意：&lt;strong&gt;本地开发请务必安装好IDE的lombok插件&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;线上部署：
&lt;ul&gt;&lt;li&gt;rm -rf src/main/resources/spring.properties&lt;/li&gt;
&lt;li&gt;mvn clean package -Dmaven.test.skip=true&lt;/li&gt;
&lt;li&gt;mv target/sepp*.jar ${your_path}/sepp.jar&lt;/li&gt;
&lt;li&gt;java -Dpath=${your_conf_path}/spring.properties -jar ${your_path}/sepp.jar &amp;amp;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;集群：已测试HAProxy、keepalived，其余未测试&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;组件使用说明&quot;&gt;组件使用说明&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;mariadb（&amp;gt;= 10.3），必须设置lower_case_table_names=1，参考conf/database/my.conf&lt;/li&gt;
&lt;li&gt;FastDfs，与nginx绑定使用，二者配置参考conf/fastdfs/*.properties、conf/nginx/*.properties&lt;/li&gt;
&lt;li&gt;octopus监控需要配置octopus.admin.address和context.env两个参数&lt;/li&gt;
&lt;li&gt;Quartz请注意spring-boot-starter-quartz和boot版本的兼容性问题，最好自己指定版本（参考pom.xml）&lt;/li&gt;
&lt;li&gt;邮件服务、Jenkins服务、git仓库服务、sonarQube服务、LDAP认证服务，皆可使用超级管理员进入系统设置进行配置，持久化到数据库，同时Jenkins服务和邮件服务也可以通过配置文件实现，其中Jenkins使用持久化的配置需要配置jenkins.enable-programmatic=false&lt;/li&gt;
&lt;li&gt;基础设置&amp;gt;监控中心，请参考：https://github.com/fudax/octopus 工程说明，并且更新spring.properties和前端src/components/monitor/MonitorAdmin.vue文件配置&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;安装步骤&quot;&gt;安装步骤&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;git clone https://github.com/purang-fintech/seppf.git      // 下载到本地
cd seppf            // 进入项目目录
npm install         // 安装项目依赖，等待安装完成之后&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;本地开发修改好config目录下的环境配置之后开启服务器浏览器访问-httplocalhost8080&quot;&gt;本地开发，修改好config目录下的环境配置之后开启服务器，浏览器访问 http://localhost:8080&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;npm run dev&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;构建生产&quot;&gt;构建生产&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;npm run build&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;组件使用说明与演示&quot;&gt;组件使用说明与演示&lt;/h4&gt;
&lt;h5 id=&quot;element-ui&quot;&gt;element-ui&lt;/h5&gt;
&lt;blockquote readability=&quot;4.453125&quot;&gt;
&lt;p&gt;一套基于vue.js2.0的桌面组件库。访问地址：&lt;a href=&quot;http://element.eleme.io/#/zh-CN/component/layout&quot;&gt;element&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;axios&quot;&gt;axios&lt;/h5&gt;
&lt;blockquote readability=&quot;4.4444444444444&quot;&gt;
&lt;p&gt;HTTP请求处理组件。访问地址：&lt;a href=&quot;https://github.com/axios/axios&quot;&gt;axios&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;echarts&quot;&gt;echarts&lt;/h5&gt;
&lt;blockquote readability=&quot;4.1860465116279&quot;&gt;
&lt;p&gt;图表展示组件。访问地址：&lt;a href=&quot;https://github.com/apache/incubator-echarts&quot;&gt;echarts&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;vue-simplemde&quot;&gt;Vue-SimpleMDE&lt;/h5&gt;
&lt;blockquote readability=&quot;3.9344262295082&quot;&gt;
&lt;p&gt;Vue.js的Markdown Editor组件。访问地址：&lt;a href=&quot;https://github.com/F-loat/vue-simplemde&quot;&gt;Vue-SimpleMDE&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;vue.draggable&quot;&gt;Vue.Draggable&lt;/h5&gt;
&lt;blockquote readability=&quot;3.8793103448276&quot;&gt;
&lt;p&gt;基于Vue的可拖拽组件。访问地址：&lt;a href=&quot;https://github.com/SortableJS/Vue.Draggable&quot;&gt;Vue.Draggable&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;3.8793103448276&quot;&gt;
&lt;p&gt;基于Vue右键菜单组件。访问地址：&lt;a href=&quot;https://github.com/snokier/v-contextmenu&quot;&gt;v-contextmenu&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;vue-cropperjs&quot;&gt;vue-cropperjs&lt;/h5&gt;
&lt;blockquote readability=&quot;3.9344262295082&quot;&gt;
&lt;p&gt;基于Vue的图片裁剪处理。访问地址：&lt;a href=&quot;https://github.com/Agontuk/vue-cropperjs&quot;&gt;vue-cropperjs&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;inline-attachment&quot;&gt;inline-attachment&lt;/h5&gt;
&lt;blockquote readability=&quot;5.0943396226415&quot;&gt;
&lt;p&gt;基于Vue的图片文件拖拽上传和粘贴板截图快捷上传处理。访问地址：&lt;a href=&quot;https://github.com/Rovak/InlineAttachment&quot;&gt;InlineAttachment&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;html2canvas&quot;&gt;html2canvas&lt;/h5&gt;
&lt;blockquote readability=&quot;4.0833333333333&quot;&gt;
&lt;p&gt;html直接转换为canvas图形。访问地址：&lt;a href=&quot;https://github.com/niklasvh/html2canvas&quot;&gt;html2canvas&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;gantt-elastic&quot;&gt;gantt-elastic&lt;/h5&gt;
&lt;blockquote readability=&quot;3.8181818181818&quot;&gt;
&lt;p&gt;增强型甘特图插件。访问地址：&lt;a href=&quot;https://github.com/neuronetio/gantt-elastic&quot;&gt;gantt-elastic&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;json2csv&quot;&gt;json2csv&lt;/h5&gt;
&lt;blockquote readability=&quot;4.2452830188679&quot;&gt;
&lt;p&gt;表格导出下载到本地。访问地址：&lt;a href=&quot;https://github.com/zemirco/json2csv&quot;&gt;json2csv&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;kityminder-core&quot;&gt;kityminder-core&lt;/h5&gt;
&lt;blockquote readability=&quot;3.6842105263158&quot;&gt;
&lt;p&gt;百度脑图核心控件。访问地址：&lt;a href=&quot;https://github.com/fex-team/kityminder-core&quot;&gt;kityminder-core&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;js-sha256&quot;&gt;js-sha256&lt;/h5&gt;
&lt;blockquote readability=&quot;3.9772727272727&quot;&gt;
&lt;p&gt;SHA256加密JS版。访问地址：&lt;a href=&quot;https://github.com/emn178/js-sha256&quot;&gt;js-sha256&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;vue-markdown&quot;&gt;vue-markdown&lt;/h5&gt;
&lt;blockquote readability=&quot;3.8&quot;&gt;
&lt;p&gt;markdown展示组件。访问地址：&lt;a href=&quot;https://github.com/miaolz123/vue-markdown&quot;&gt;vue-markdown&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-acb3e1f1ff42124df3838019f6a3f4030b2.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-952240248c84e2e5e3ee4a5099979540110.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-ba564e36ff4dd851fed653ccb955e222345.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-8ccdd82e7297e9d68ab169e99e632ae74e7.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-5588a4ad7c015a160ee0d142f03ab529237.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-4ba4077b38a3525d291352742c60ec47a75.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-635da8552d6f2a92e36d27e2df80810e926.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 09 Jan 2020 00:18:00 +0000</pubDate>
<dc:creator>槽神刘叫兽</dc:creator>
<og:description>演示地址 &amp;quot;http://www.seqcer.com&amp;quot; 推荐注册，并创建自己的项目，便于隔离数据胡搞而不影响其他试用者 仅对chrome浏览器做了完全适配，其他chromium核</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fudax/p/12169461.html</dc:identifier>
</item>
<item>
<title>一文总结软件架构设计常用概念、原则与思想 - Nauyus</title>
<link>http://www.cnblogs.com/lkxsnow/p/12169458.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lkxsnow/p/12169458.html</guid>
<description>&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;导读&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文一文总结软件架构设计常用概念、原则与思想，包括面向对象六大原则，DID原则，ACID、CAP、BASE理论，中间层思想，缓存思想等。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;面向对象设计六大原则&lt;/span&gt;&lt;/h2&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一 单一职责原则(SRP)：&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定义是就一个类而言，应该仅有一个引起他变化的原因。也就是说一个类应该只负责一件事情；&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二 开闭原则(OCP)：&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定义是软件中的对象(类，模块，函数等)应该对于扩展是开放的，但是对于修改是关闭的；当需求发生改变的时候，我们需要对代码进行修改，这个时候我们应该尽量去扩展原来的代码，而不是去修改原来的代码，因为这样可能会引起更多的问题；&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;三 里氏替换原则(LSP)：&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有引用基类的地方必须能够透明地使用其子类的对象；子类可以去扩展父类的功能，但是不能改变父类原有的功能，它包含以下几层意思： 1.子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法； 2.子类可以增加自己独有的方法； 3.当子类的方法重载父类的方法时候，方法的形参要比父类的方法的输入参数更加宽松； 4.当子类的方法实现父类的抽象方法时，方法的返回值要比父类更严格；&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;四 依赖倒置原则(DIP)：&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;高层模块不应该依赖底层模块，两个都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象；定义有点绕，说白了，就是要针对接口编程，而不是对实现编程；(抽象指的是接口或者抽象类，两者皆不能实例化；而细节就是实现类，也就是实现了接口或者继承了抽象类的类，它是可以被实例化的；高层模块指的是调用端，底层模块是具体的实现类，在java中，依赖倒置原则是指模块间的依赖是通过抽象来发生的，实现类之间不发生直接的依赖关系，其依赖关系是通过接口来实现的，这就是通俗的面向接口编程)&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;五 接口隔离原则(ISP)：&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端不应该依赖他不需要的接口；&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;六 迪米特原则(LOD)：&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个对象应该对其他对象保持最小的了解；&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Robert C Martin在21世纪早期将单一职责，开闭原则，里氏替换，接口隔离和依赖倒置5个原则定义为SOLID原则。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;DID原则&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Design(D)设计20倍的容量；Implement(I)实施3倍的容量；Deploy（D）部署1.5倍的容量。 DID为产品扩展提供了经济，有效，及时的方法。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;中间层思想&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算机系统软件体系结构采用一种层的结构，有人说过一句名言：&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;Any problem in computer science can be solved by another layer of indirection. （计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这句话几乎概括了计算机系统软件体系结构的设计要点，整个体系结构从上到下都是按照严格的层次结构设计的，不仅是计算机系统软件整个体系是这样的，体系里面的每个组件比如OS本身，很多应用程序、软件系统甚至很多硬件结构都是按照这种层次的结构组织和设计的。 纵观计算机体系，中间层思想无处不在，比如&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;MVC三层架构&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;四层/七层网络模型&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;添加缓存层提升系统性能&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;……&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缓存思想&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;世界是相似的，在商业的世界中，有一句经典语录叫 “现金为王”。在互联网乃至整个软件技术世界中，与之对应的一个说法就是 “缓存为王”。 纵观整个系统，缓存无处不在。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;CPU缓存&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于CPU的运算速度要比内存读写速度快很多，CPU总有等待数据的时候，而高速缓存则解决了CPU运算速度与内存读写速度不匹配的矛盾。当CPU调用数据时，先从缓存中调用，从而加快读取速度。而且，CPU是有多级缓存的。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;浏览器缓存&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前端页面缓存有两层含义，一个是页面自身对某些页面元素或全部元素进行缓存，另一层意思是服务端将静态页面或动态页面的元素进行缓存，然后给客户端使用。这里的页面缓存指的是页面自身的缓存或者离线应用缓存。 HTML5 支持了离线缓存和本地存储，使用这种特性可以很方便的创建页面应用。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;网络中的缓存&lt;/span&gt;&lt;/h3&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;CDN缓存&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;反向代理缓存&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;服务端缓存&lt;/span&gt;&lt;/h3&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;内存级缓存&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;分布式缓存&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据库缓存&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拿mysql来说。mysql使用查询缓冲机制。将select语句和结果存在缓冲区。下次遇到相同select就直接从缓冲区拿数据。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;ACID(酸)&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ACID，指数据库事务正确执行的四个基本要素的缩写。数据库必须同时满足ACID支持强一致性，ACID指如下内容:&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;A:原子性（Atomicity）&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;C:一致性（Consistency）&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务前后数据的完整性必须保持一致。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;I:隔离性（Isolation）&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;D:持久性（Durability）&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;CAP（帽子原理）&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CAP原则又称CAP定理，指的是在一个分布式系统中，CAP三个要素最多只能同时实现两点，不可能三者兼顾。 CAP分别是指&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;C:一致性（Consistency）&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有节点在同一时间的数据完全一致，这里的一致性指的是强一致性&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;A:可用性（Availability）&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于一个可用性的分布式系统，每一个非故障的节点必须对每一个请求作出响应。通常我们用&lt;code&gt;几个9&lt;/code&gt;来描述可用性，比如5个9的可用性意思为可用水平是99.999%，即全年停机时间不超过 (1-0.99999)36524*60 = 5.256 min。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;P:分区容错性（Partition tolerance）&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分区容错性指分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;BASE（碱）&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;eBay的架构师Dan Pritchett源于对大规模分布式系统的实践总结，在ACM上发表文章提出BASE理论，BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;BA:基本可用(Basically Available)&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。 电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;S:软状态(Soft state)&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;E:最终一致(Eventually consistent)&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;酸碱平衡理论&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ACID是传统数据库常用的设计理念，追求强一致性模型。BASE支持的是大型分布式系统，提出通过牺牲强一致性获得高可用性。 ACID和BASE代表了两种截然相反的设计哲学，基于根据ACID与BASE提出了&lt;code&gt;酸碱平衡理论&lt;/code&gt;，即在不同场景下，分别使用ACID与BASE解决分布式一致性问题。&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;感谢阅读，原创不易，如有启发，点个赞吧！这将是我写作的最强动力！本文不同步发布于不止于技术的技术公众号 &lt;code&gt;Nauyus&lt;/code&gt; ,主要分享一些编程语言，架构设计，思维认知类文章， 2019年12月起开启周更模式，欢迎关注，共同学习成长！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/8/16f83d94a18e4f77?w=2001&amp;amp;h=1080&amp;amp;f=jpeg&amp;amp;s=398705&quot; alt=&quot;&quot;/&gt;</description>
<pubDate>Thu, 09 Jan 2020 00:10:00 +0000</pubDate>
<dc:creator>Nauyus</dc:creator>
<og:description>本文一文总结软件架构设计常用概念、原则与思想，包括面向对象六大原则，DID原则，ACID、CAP、BASE理论，中间层思想，缓存思想等。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lkxsnow/p/12169458.html</dc:identifier>
</item>
<item>
<title>从0开发3D引擎（四）：搭建测试环境 - Wonder-YYC</title>
<link>http://www.cnblogs.com/chaogex/p/12169434.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chaogex/p/12169434.html</guid>
<description>&lt;p&gt;大家好，本文介绍了3D引擎的测试方法，搭建了本地的测试环境。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/chaogex/p/12164689.html&quot;&gt;从0开发3D引擎（三）：搭建开发环境&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对于引擎开发这种复杂、长期的项目，为了减少bug，提升长期的开发效率，自动化测试必不可少。在我们的&lt;a href=&quot;https://github.com/Wonder-Technology/Wonder.js&quot;&gt;Wonder.js&lt;/a&gt;引擎中，包括了本节介绍的3种自动化测试，测试覆盖率达到了95%。&lt;/p&gt;
&lt;p&gt;本系列为了节省篇幅，不进行自动化测试。因此本节只进行简单的介绍，不给出实际的案例，读者可以到&lt;a href=&quot;https://github.com/Wonder-Technology/Wonder.js/tree/master/test&quot;&gt;Wonder.js-&amp;gt;test/&lt;/a&gt;目录下查看自动化测试实例。&lt;/p&gt;
&lt;h2 id=&quot;单元测试&quot;&gt;单元测试&lt;/h2&gt;
&lt;p&gt;我们需要写测试用例对单个函数进行单元测试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;搭建环境&lt;/strong&gt;&lt;br/&gt;使用&lt;a href=&quot;https://jestjs.io/&quot;&gt;jest&lt;/a&gt;作为测试框架，&lt;a href=&quot;https://sinonjs.org/&quot;&gt;sinon&lt;/a&gt;进行stub。&lt;br/&gt;如果读者想了解stub的概念，可以参考&lt;a href=&quot;https://www.cnblogs.com/chaogex/p/3388386.html&quot;&gt;我对Stub和Mock的理解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因为不能直接使用js库，需要写对应的&lt;a href=&quot;https://reasonml.github.io/docs/en/external&quot;&gt;FFI&lt;/a&gt;（类似于typescript的d.ts文件）才能在Reason中被调用，所以我们可以使用&lt;a href=&quot;https://github.com/glennsl/bs-jest&quot;&gt;bs-jest&lt;/a&gt;和Wonder的&lt;a href=&quot;https://github.com/Wonder-Technology/Wonder-bs-sinon&quot;&gt;Wonder-bs-sinon&lt;/a&gt;作为FFI&lt;/p&gt;
&lt;h2 id=&quot;集成测试&quot;&gt;集成测试&lt;/h2&gt;
&lt;p&gt;相对于单元测试，集成测试的测试目标变为某个特性，该特性跨越多个函数或多个模块。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;搭建环境&lt;/strong&gt;&lt;br/&gt;与单元测试的环境一样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目录结构&lt;/strong&gt;&lt;br/&gt;可以在test/unit/目录下写单元测试用例，而在test/integration/目录下写集成测试用例。&lt;/p&gt;
&lt;h2 id=&quot;端对端测试&quot;&gt;端对端测试&lt;/h2&gt;
&lt;p&gt;也称为e2e测试，包括了“渲染测试”和“性能测试”。它们都需要安装&lt;a href=&quot;https://github.com/puppeteer/puppeteer&quot;&gt;puppeteer&lt;/a&gt;，通过chrome内核渲染3D场景来进行测试。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;渲染测试&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;渲染测试是针对特定的场景（如只有一个模型的场景，或者只有一个光源的场景）进行测试，从而保证&lt;strong&gt;渲染&lt;/strong&gt;的正确性。&lt;/p&gt;
&lt;p&gt;测试步骤为：&lt;br/&gt;1、预先渲染一张正确图片&lt;br/&gt;2、使用引擎渲染一张当前图片&lt;br/&gt;3、逐个像素地比较两者，如果95%以上的像素都相同，则测试通过；否则测试失败&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;性能测试&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;性能测试是针对极端场景（如5000个box）进行测试，从而保证&lt;strong&gt;花费的时间&lt;/strong&gt;和&lt;strong&gt;占用的内存大小&lt;/strong&gt;符合要求。&lt;/p&gt;
&lt;p&gt;测试步骤为：&lt;br/&gt;1、预先准备基准数据&lt;br/&gt;使用引擎运行场景多次，取平均值，记录到json文件中&lt;br/&gt;2、使用引擎运行场景多次（少于“准备基准数据”的运行次数），取平均值，得到当前数据&lt;br/&gt;3、比较两者的&lt;strong&gt;花费的时间&lt;/strong&gt;和&lt;strong&gt;占用的内存大小&lt;/strong&gt;，如果在误差范围内，则测试通过；否则测试失败&lt;/p&gt;
&lt;p&gt;注意事项：&lt;br/&gt;只有在本地测试时，保持基准数据不变。如果在云端（如在push到Github仓库时使用CI工具-travis进行测试）或者其它环境（如换一台电脑进行测试）进行性能测试，需要在每次测试时更新基准数据（因为不同的环境，性能不一样，所以对应的基准数据也不一样）。&lt;/p&gt;
&lt;h2 id=&quot;通过打印日志来调试&quot;&gt;通过打印日志来调试&lt;/h2&gt;
&lt;p&gt;有以下的原因使得可以在单元测试和集成测试中通过打印日志来进行调试：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;因为在自动化测试中打开watch，代码修改后能够立即刷新，所以能够即时看到打印的结果，测试很方便&lt;/li&gt;
&lt;li&gt;因为在函数式编程中，函数为纯函数（Reason也允许非纯），没有状态，所以我们可以通过打印函数的输入和输出，来验证该函数是否正确&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本系列通过在Chrome浏览器中进行运行测试来验证程序的正确性。&lt;/p&gt;
&lt;p&gt;通过以下的方式进行运行测试：&lt;/p&gt;
&lt;h2 id=&quot;断点调试&quot;&gt;断点调试&lt;/h2&gt;
&lt;p&gt;因为浏览器运行的是Reason编译后的js代码，所以我们可以在浏览器的控制台-&amp;gt;Sources中通过断点来调试js代码&lt;/p&gt;
&lt;p&gt;具体可以参考：&lt;br/&gt;&lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/javascript/breakpoints&quot;&gt;使用断点暂停代码&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;通过spector.js测试webgl&quot;&gt;通过Spector.js测试WebGL&lt;/h2&gt;
&lt;p&gt;Spector.js调试预览：&lt;br/&gt;&lt;img src=&quot;http://static.zybuluo.com/yangyc/b4g322wpdjvxu8cqzyrztqtp/68747470733a2f2f73706563746f72646f632e626162796c6f6e6a732e636f6d2f70696374757265732f7469746c652e706e67.png&quot; alt=&quot;68747470733a2f2f73706563746f72646f632e626162796c6f6e6a732e636f6d2f70696374757265732f7469746c652e706e67.png-258.5kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Spector.js能查看一帧中WebGL的调用情况、shader代码和WebGL的状态，它支持WebGL 1.0或WebGL 2.0，也支持WebGL 1.0的VAO等扩展。&lt;/p&gt;
&lt;p&gt;另外，Spector.js支持多个canvas，能查看指定的canvas对应的WebGL信息。这对于调试编辑器（如我们的&lt;a href=&quot;https://editor.wonder-3d.com/&quot;&gt;Wonder-Editor&lt;/a&gt;在线编辑器）很有用。因为编辑器有多个canvas（如一个canvas进行主场景绘制，另一个canvas以材质球的方式显示单个material资产的效果），而我们希望分别调试从每个canvas中取得上下文的WebGL。&lt;/p&gt;
&lt;p&gt;Spector.js可以在Chrome的&lt;a href=&quot;https://chrome.google.com/webstore/detail/spectorjs/denbgaamihkadbghdceggmchnflmhpmk&quot;&gt;扩展&lt;/a&gt;中安装，详情请见&lt;a href=&quot;https://github.com/BabylonJS/Spector.js&quot;&gt;官方Github&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;通过log调试shader&quot;&gt;通过log调试Shader&lt;/h2&gt;
&lt;p&gt;本系列通过在fragment shader中，将变量作为输出的颜色，来调试Shader的变量值。&lt;/p&gt;
&lt;p&gt;更多可以参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://learnopengl-cn.readthedocs.io/zh/latest/06%20In%20Practice/01%20Debugging/&quot;&gt;调试OpenGL&lt;/a&gt; -&amp;gt; 调试着色器输出&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/30735616&quot;&gt;OpenGL shader如何调试？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/freeblues/p/5724774.html&quot;&gt;OpenGL ES 2.0 Shader 调试新思路(一): 改变提问方式&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;移动端测试&quot;&gt;移动端测试&lt;/h2&gt;
&lt;p&gt;我们通过下面两种方法进行测试：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;模拟测试&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们可以在Chrome浏览器上，点击控制台-&amp;gt;Toggle Device Toolbar，打开用于模拟移动设备视口的界面。&lt;/p&gt;
&lt;p&gt;本系列主要用该方法测试引擎对于移动端touch事件的支持。&lt;/p&gt;
&lt;p&gt;详细的介绍参考：&lt;br/&gt;&lt;a href=&quot;https://developers.google.cn/web/tools/chrome-devtools/device-mode&quot;&gt;使用 Chrome DevTools 中的 Device Mode 模拟移动设备&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;真机测试&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体步骤如下：&lt;br/&gt;1、在测试html页面中引入vConsole库&lt;br/&gt;从而可以通过打印日志的方式，在手机上查看错误和日志信息&lt;br/&gt;vConsole介绍参考：&lt;br/&gt;&lt;a href=&quot;https://www.jianshu.com/p/3df8862481c8&quot;&gt;前端开发 - 在手机上调试利器vConsole&lt;/a&gt;&lt;br/&gt;2、把测试页面push到测试环境的服务器上（如使用Github Pages搭建的服务器）&lt;br/&gt;3、把测试页面的访问地址转换为二维码&lt;br/&gt;如使用&lt;a href=&quot;https://cli.im/&quot;&gt;草料二维码&lt;/a&gt;在线转换&lt;br/&gt;4、用测试手机的微信扫该二维码，运行测试页面，验证渲染结果，查看错误和日志信息&lt;/p&gt;

&lt;p&gt;因为本系列开发的引擎重视性能，所以会通过手动的性能测试，来指导引擎优化。&lt;/p&gt;
&lt;p&gt;性能测试的指标包括时间开销和内存开销，下面分别分析：&lt;/p&gt;
&lt;h2 id=&quot;测试时间开销&quot;&gt;测试时间开销&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;使用Chrome DevTools的Javascript Profiler&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过在测试页面记录profile，查看每个函数的时间开销，从而定位到热点函数进行优化。&lt;/p&gt;
&lt;p&gt;相关资料可参考：&lt;br/&gt;&lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/rendering-tools/js-execution&quot;&gt;加速执行 JavaScript&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.jianshu.com/p/504bde348956&quot;&gt;Chrome DevTools 之 Profiles，深度性能优化必备&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用Chrome DevTools的Performance&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过时间线Timeline，可以查看CPU端各个线程和GPU的执行顺序和热点函数的时间开销。&lt;/p&gt;
&lt;p&gt;本系列主要用该方法测试在&lt;strong&gt;多线程&lt;/strong&gt;中，每个线程的执行顺序和性能开销&lt;/p&gt;
&lt;p&gt;相关资料可参考：&lt;br/&gt;&lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool?utm_campaign=2016q3&amp;amp;utm_medium=redirect&amp;amp;utm_source=dcc&quot;&gt;如何使用 Timeline 工具&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.jianshu.com/p/b8cdcd9bfad8&quot;&gt;Chrome DevTools 之 Timeline，快捷性能优化工具&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用Chrome DevTools的NetWork&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;查看各个资源的加载时间和顺序。&lt;/p&gt;
&lt;p&gt;本系列用该方法测试在“使用函数式反应式编程的流来异步加载 js、二进制文件等资源”时，各个资源的加载顺序是否正确。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用Performance.now&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用该方法打印某段逻辑的时间开销，多用于自动化测试-&amp;gt;端对端测试—&amp;gt;性能测试。&lt;/p&gt;
&lt;p&gt;本系列在使用profile定位到热点函数后，会使用该方法确定具体代码的时间开销。通过比较优化前和优化后的时间开销，来评估优化的效果。&lt;/p&gt;
&lt;p&gt;示例代码为：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var n1 = performance.now();

执行某些逻辑


var n2 = performance.now();

//打印逻辑的时间开销（ms为单位）
console.log(n2 - n1);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;使用Console.profile&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;相对于Chrome DevTools的Javascript Profiler，该方法可以测试某一段逻辑的profile，而不是整个页面的profile，粒度更小，更加可控。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/yangyc/i2x7a5q8q0zzs4r70wcanw2c/%E6%88%AA%E5%B1%8F2020-01-08%E4%B8%8B%E5%8D%885.31.44.png&quot; alt=&quot;截屏2020-01-08下午5.31.44.png-311.6kB&quot;/&gt;&lt;br/&gt;（图来自&lt;a href=&quot;https://segmentfault.com/a/1190000002511877&quot;&gt;Chrome 控制台console的用法（学了之后对于调试js可是大大有用的哦）&lt;/a&gt;）&lt;/p&gt;
&lt;h2 id=&quot;测试内存开销&quot;&gt;测试内存开销&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;使用Chrome DevTools的Memory&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本系列对这个工具的应用：&lt;br/&gt;使用Allocation sampling，定位内存占用的热点函数；&lt;br/&gt;使用Allocation instrumentation on timeline来比较每一帧内存开销的增长情况，从而确定是否有内存泄漏。如果有内存泄漏，则通过Heap snapshot，记录多个内存快照并进行比较，定位到具体是哪些地方增加了内存。&lt;/p&gt;
&lt;p&gt;相关资料可参考：&lt;br/&gt;&lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/memory-problems/?hl=zh-cn#allocation-profile&quot;&gt;解决内存问题&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;运行测试和性能测试不仅需要使用Chrome浏览器的控制台功能，还需要：&lt;br/&gt;1、安装Spector.js&lt;br/&gt;Spector.js可以在Chrome的&lt;a href=&quot;https://chrome.google.com/webstore/detail/spectorjs/denbgaamihkadbghdceggmchnflmhpmk&quot;&gt;扩展&lt;/a&gt;中安装&lt;br/&gt;2、进行移动端测试时，需要在测试页面中引入vConsole库，并使用Github Pages搭建测试服务器&lt;/p&gt;
</description>
<pubDate>Wed, 08 Jan 2020 23:11:00 +0000</pubDate>
<dc:creator>Wonder-YYC</dc:creator>
<og:description>大家好，本文介绍了3D引擎的测试方法，搭建了本地的测试环境。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chaogex/p/12169434.html</dc:identifier>
</item>
<item>
<title>曹工说Spring Boot源码（8）-- Spring解析xml文件，到底从中得到了什么（util命名空间） - 三国梦回</title>
<link>http://www.cnblogs.com/grey-wolf/p/12158935.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/grey-wolf/p/12158935.html</guid>
<description>&lt;p&gt;相关背景及资源：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12044199.html&quot;&gt;曹工说Spring Boot源码（1）-- Bean Definition到底是什么，附spring思维导图分享&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12051957.html&quot;&gt;曹工说Spring Boot源码（2）-- Bean Definition到底是什么，咱们对着接口，逐个方法讲解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12070377.html&quot;&gt;曹工说Spring Boot源码（3）-- 手动注册Bean Definition不比游戏好玩吗，我们来试一下&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12078673.html&quot;&gt;曹工说Spring Boot源码（4）-- 我是怎么自定义ApplicationContext，从json文件读取bean definition的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12093929.html&quot;&gt;曹工说Spring Boot源码（5）-- 怎么从properties文件读取bean&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12114604.html&quot;&gt;曹工说Spring Boot源码（6）-- Spring怎么从xml文件里解析bean的&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12151809.html&quot;&gt;曹工说Spring Boot源码（7）-- Spring解析xml文件，到底从中得到了什么（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/ckl111/spring-boot-first-version-learn&quot;&gt;工程代码地址&lt;/a&gt; &lt;a href=&quot;https://www.processon.com/view/link/5deeefdee4b0e2c298aa5596&quot;&gt;思维导图地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;工程结构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201912/519126-20191215144930717-1919774390.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;先给大家看看spring支持的xml配置，我列了个表格如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;util&lt;/td&gt;
&lt;td&gt;constant、property-path、list、set、map、properties&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;context&lt;/td&gt;
&lt;td&gt;property-placeholder、property-override、annotation-config、component-scan、load-time-weaver、spring-configured、mbean-export、mbean-server&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;beans&lt;/td&gt;
&lt;td&gt;import、bean、alias&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;task&lt;/td&gt;
&lt;td&gt;annotation-driven、scheduler、scheduled-tasks、executor&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;cache&lt;/td&gt;
&lt;td&gt;advice、annotation-driven&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;aop&lt;/td&gt;
&lt;td&gt;config、scoped-proxy、aspectj-autoproxy&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;我标题的意思是，既然spring支持这么多种xml配置，那解析这些xml的代码，是否是有共性的呢？还是说，就是很随意的，产品经理说要支持这个元素的解析，就写个分支呢？&lt;/p&gt;
&lt;p&gt;看过我上讲的同学应该知道，不管是什么元素，不管在哪个namespace下，其对应的解析代码，都是一种类，这种类，叫做：&lt;code&gt;BeanDefinitionParser&lt;/code&gt;，这个类的接口如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;org.springframework.beans.factory.xml.BeanDefinitionParser
public interface BeanDefinitionParser {

    /**
     * 解析指定额element，注册其返回的BeanDefinition到BeanDefinitionRegistry
     * （使用参数ParserContext#getRegistry()得到BeanDefinitionRegistry）
     */
    BeanDefinition parse(Element element, ParserContext parserContext);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个接口的实现类，相当多，除了beans命名空间下的xml元素，其他namespace下的xml元素的解析代码都实现了这个接口。&lt;/p&gt;
&lt;p&gt;首先是util命名空间下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/202001/519126-20200106213353136-208384769.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其次是context命名空间：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/202001/519126-20200106213527511-784909857.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里面有大家熟悉的。&lt;/p&gt;
&lt;p&gt;这里就不一一列举了，所以大家知道了，每个xml元素的解析器，都是实现了&lt;code&gt;BeanDefinitionParser&lt;/code&gt;，这个接口的方法，就是交给各个子类去实现：针对指定的xml元素，如何获取到对应的&lt;code&gt;bean definition&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;有的xml元素，比较简单，比如上一篇提到的，只能得到一个&lt;code&gt;bean definition&lt;/code&gt;（factory bean）；还有的xml元素，则是群攻魔法，比如&amp;lt;context：component-scan&amp;gt;这种，一把就能捞一大波&lt;code&gt;bean definition&lt;/code&gt;上来。&lt;/p&gt;
&lt;p&gt;本讲，我们会继续从&lt;code&gt;util namespace开始&lt;/code&gt;，将比较常见的xml元素，一路扫过去&lt;/p&gt;

&lt;p&gt;用法如下：&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;#test.properties
name=xxx system&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import lombok.Data;

@Data
public class TestPropertiesBean {
    private String appName;
}   &lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    spring xml中如下配置：
    &amp;lt;util:properties id=&quot;properties&quot;
                     location=&quot;classpath:test.properties&quot;/&amp;gt;

    &amp;lt;bean class=&quot;org.springframework.utilnamespace.TestPropertiesBean&quot;&amp;gt;
        // 注意，这里的value，#{properties.name}，点号前面引用了上面的properties bean的id，点号后面
        // 是properties文件里key的名称
        &amp;lt;property name=&quot;appName&quot; value=&quot;#{properties.name}&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Slf4j
public class TestProperties {
    public static void main(String[] args) {
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]{&quot;classpath:util-namespace-test-properties.xml&quot;},false);
        context.refresh();

        List&amp;lt;BeanDefinition&amp;gt; list =
                context.getBeanFactory().getBeanDefinitionList();
        MyFastJson.printJsonStringForBeanDefinitionList(list);

        Object o = context.getBean(TestPropertiesBean.class);
        System.out.println(o);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;TestPropertiesBean(appName=xxx system)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;原理解析&quot;&gt;原理解析&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;UtilNamespaceHandler&lt;/code&gt;中，我们看看该元素对应的&lt;code&gt;BeanDefinitionParser&lt;/code&gt;是啥：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class UtilNamespaceHandler extends NamespaceHandlerSupport {


    public void init() {
        registerBeanDefinitionParser(&quot;constant&quot;, new ConstantBeanDefinitionParser());
        registerBeanDefinitionParser(&quot;property-path&quot;, new PropertyPathBeanDefinitionParser());
        registerBeanDefinitionParser(&quot;list&quot;, new ListBeanDefinitionParser());
        registerBeanDefinitionParser(&quot;set&quot;, new SetBeanDefinitionParser());
        registerBeanDefinitionParser(&quot;map&quot;, new MapBeanDefinitionParser());
        registerBeanDefinitionParser(&quot;properties&quot;, new PropertiesBeanDefinitionParser());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ok！ 是&lt;code&gt;PropertiesBeanDefinitionParser&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/202001/519126-20200107213048415-61471696.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体的解析过程，和上一讲里的相似，这里只说不同的：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static class PropertiesBeanDefinitionParser extends AbstractSimpleBeanDefinitionParser {
        
         // 这里就是指定了bean definition里的bean class
        @Override
        protected Class getBeanClass(Element element) {
            return PropertiesFactoryBean.class;
        }
        
        // 一些定制逻辑，无需操心
        @Override
        protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {
            super.doParse(element, parserContext, builder);
            Properties parsedProps = parserContext.getDelegate().parsePropsElement(element);
            builder.addPropertyValue(&quot;properties&quot;, parsedProps);
            String scope = element.getAttribute(SCOPE_ATTRIBUTE);
            if (StringUtils.hasLength(scope)) {
                builder.setScope(scope);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里其实，主要就是指定了&lt;code&gt;beanClass&lt;/code&gt;，其他逻辑都不甚重要。这里的beanClass就是&lt;code&gt;PropertiesFactoryBean&lt;/code&gt;，类型是一个工厂bean。&lt;/p&gt;
&lt;p&gt;因为我们的主题是，Spring解析xml文件，从中得到了什么，所以我们不会进一步剖析实现，从对上面这个元素的解析来说，就是得到了&lt;strong&gt;一个工厂bean&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用法如下：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:util=&quot;http://www.springframework.org/schema/util&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                http://www.springframework.org/schema/util  http://www.springframework.org/schema/util/spring-util.xsd&quot;&amp;gt;

    &amp;lt;util:list id=&quot;testList&quot; list-class=&quot;java.util.ArrayList&quot;&amp;gt;
        &amp;lt;value&amp;gt;a&amp;lt;/value&amp;gt;
        &amp;lt;value&amp;gt;b&amp;lt;/value&amp;gt;
        &amp;lt;value&amp;gt;c&amp;lt;/value&amp;gt;
    &amp;lt;/util:list&amp;gt;

    &amp;lt;bean id=&quot;testPropertiesBeanA&quot; class=&quot;org.springframework.utilnamespace.TestPropertiesBean&quot;&amp;gt;
        &amp;lt;property name=&quot;appName&quot; value=&quot;xxx&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;testPropertiesBeanB&quot; class=&quot;org.springframework.utilnamespace.TestPropertiesBean&quot;&amp;gt;
        &amp;lt;property name=&quot;appName&quot; value=&quot;yyy&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;util:list id=&quot;testBeanList&quot; list-class=&quot;java.util.ArrayList&quot;&amp;gt;
        &amp;lt;ref bean=&quot;testPropertiesBeanA&quot;/&amp;gt;
        &amp;lt;ref bean=&quot;testPropertiesBeanB&quot;/&amp;gt;
    &amp;lt;/util:list&amp;gt;


&amp;lt;/beans&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Slf4j
public class TestUtilListElement {
    public static void main(String[] args) {
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(
                new String[]{&quot;classpath:util-namespace-test-list.xml&quot;},false);
        context.refresh();

        Map&amp;lt;String, Object&amp;gt; map = context.getDefaultListableBeanFactory().getAllSingletonObjectMap();
        log.info(&quot;singletons:{}&quot;, JSONObject.toJSONString(map));

        List&amp;lt;BeanDefinition&amp;gt; list =
                context.getBeanFactory().getBeanDefinitionList();
        MyFastJson.printJsonStringForBeanDefinitionList(list);
        
        Object bean = context.getBean(&quot;testList&quot;);
        System.out.println(&quot;bean:&quot; + bean);

        bean = context.getBean(&quot;testBeanList&quot;);
        System.out.println(&quot;bean:&quot; + bean);

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;23:32:06.396 [main] DEBUG o.s.b.f.s.DefaultListableBeanFactory - Returning cached instance of singleton bean 'testList'
bean:[a, b, c]
23:32:06.396 [main] DEBUG o.s.b.f.s.DefaultListableBeanFactory - Returning cached instance of singleton bean 'testBeanList'
bean:[TestPropertiesBean(appName=xxx), TestPropertiesBean(appName=yyy)]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看看这两个bean的&lt;code&gt;beanDefinitionParser&lt;/code&gt;，&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static class ListBeanDefinitionParser extends AbstractSingleBeanDefinitionParser {
   // 这里指定本bean的class，可以看到，这也是一个工厂bean
   @Override
   protected Class getBeanClass(Element element) {
      return ListFactoryBean.class;
   }
    
   //解析元素里的属性等
   @Override
   protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {
      String listClass = element.getAttribute(&quot;list-class&quot;);
      List parsedList = parserContext.getDelegate().parseListElement(element, builder.getRawBeanDefinition());
      builder.addPropertyValue(&quot;sourceList&quot;, parsedList);
      if (StringUtils.hasText(listClass)) {
         builder.addPropertyValue(&quot;targetListClass&quot;, listClass);
      }
      String scope = element.getAttribute(SCOPE_ATTRIBUTE);
      if (StringUtils.hasLength(scope)) {
         builder.setScope(scope);
      }
   }
}   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;回到题目，spring 从这个元素获得了什么，&lt;strong&gt;一个工厂bean&lt;/strong&gt;，和前面一样。&lt;/p&gt;
&lt;p&gt;我们可以仔细看看beandefinition，我这里的测试类是用json输出了的：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;abstract&quot;: false,
    &quot;autowireCandidate&quot;: true,
    &quot;autowireMode&quot;: 0,
    &quot;beanClassName&quot;: &quot;org.springframework.beans.factory.config.ListFactoryBean&quot;,
    &quot;constructorArgumentValues&quot;: {
      &quot;argumentCount&quot;: 0,
      &quot;empty&quot;: true,
      &quot;genericArgumentValues&quot;: [],
      &quot;indexedArgumentValues&quot;: {}
    },
    &quot;dependencyCheck&quot;: 0,
    &quot;enforceDestroyMethod&quot;: true,
    &quot;enforceInitMethod&quot;: true,
    &quot;lazyInit&quot;: false,
    &quot;lenientConstructorResolution&quot;: true,
    &quot;methodOverrides&quot;: {
      &quot;empty&quot;: true,
      &quot;overrides&quot;: []
    },
    &quot;nonPublicAccessAllowed&quot;: true,
    &quot;primary&quot;: false,
    &quot;propertyValues&quot;: {
      &quot;converted&quot;: false,
      &quot;empty&quot;: false,
      &quot;propertyValueList&quot;: [
        {
          &quot;converted&quot;: false,
          &quot;name&quot;: &quot;sourceList&quot;,
          &quot;optional&quot;: false,
          &quot;value&quot;: [
            {
              &quot;beanName&quot;: &quot;testPropertiesBeanA&quot;,
              &quot;toParent&quot;: false
            },
            {
              &quot;beanName&quot;: &quot;testPropertiesBeanB&quot;,
              &quot;toParent&quot;: false
            }
          ]
        },
        {
          &quot;converted&quot;: false,
          &quot;name&quot;: &quot;targetListClass&quot;,
          &quot;optional&quot;: false,
          &quot;value&quot;: &quot;java.util.ArrayList&quot;
        }
      ]
    },
    &quot;prototype&quot;: false,
    &quot;qualifiers&quot;: [],
    &quot;resolvedAutowireMode&quot;: 0,
    &quot;role&quot;: 0,
    &quot;scope&quot;: &quot;&quot;,
    &quot;singleton&quot;: true,
    &quot;synthetic&quot;: false
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面可以看出，beanClass是&lt;code&gt;ListFactoryBean&lt;/code&gt;，而我们xml里配置的元素，则被解析后，存放到了&lt;code&gt;propertyValues&lt;/code&gt;，被作为了这个bean的属性对待。&lt;/p&gt;

&lt;p&gt;util命名空间还有几个别的元素，比如map、set，都差不多，spring都把它们解析为了一个工厂bean。&lt;/p&gt;
&lt;p&gt;工厂bean和普通bean的差别，会放到后面再说，下一讲，会继续讲解context命名空间的元素。&lt;/p&gt;
&lt;p&gt;源码我放在：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/ckl111/spring-boot-first-version-learn/tree/master/all-demo-in-spring-learning/spring-xml-demo/src/main/java/org/springframework/utilnamespace&quot; class=&quot;uri&quot;&gt;https://gitee.com/ckl111/spring-boot-first-version-learn/tree/master/all-demo-in-spring-learning/spring-xml-demo/src/main/java/org/springframework/utilnamespace&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎大家和我一起学习spring/spring boot源码，有问题欢迎一起交流！&lt;/p&gt;
</description>
<pubDate>Wed, 08 Jan 2020 15:45:00 +0000</pubDate>
<dc:creator>三国梦回</dc:creator>
<og:description>写在前面的话 相关背景及资源： &amp;quot;曹工说Spring Boot源码（1） Bean Definition到底是什么，附spring思维导图分享&amp;quot; &amp;quot;曹工说Spring B</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/grey-wolf/p/12158935.html</dc:identifier>
</item>
<item>
<title>东拼西凑完成一个“前端框架”(6) - 按钮 - CharlesShang</title>
<link>http://www.cnblogs.com/xinwang/p/12169190.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xinwang/p/12169190.html</guid>
<description>&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;完成了整体框架的工作，下面开始写一些组件；从按钮开始，设计的思路主要参照 &lt;a href=&quot;https://www.bootcss.com&quot;&gt;Bootstrap&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;基类&quot;&gt;基类&lt;/h2&gt;
&lt;p&gt;首先定义按钮的基类 &lt;code&gt;btn&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;css&quot;&gt;CSS&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;.btn {
    display: inline-block;
    font-weight: 400;
    color: #212529;
    text-align: center;
    vertical-align: middle;
    cursor: pointer;
    background-color: #fbfbfb;
    border: 1px solid #ddd;
    padding: 5px 10px;
    font-size: 13px;
    line-height: 1.5;
    border-radius: 4px;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;定义了常规状态后，我们还需要定义按钮的 &lt;code&gt;hover&lt;/code&gt;、&lt;code&gt;disabled&lt;/code&gt;、&lt;code&gt;active&lt;/code&gt;、&lt;code&gt;focus&lt;/code&gt;的状态：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;.btn:focus {
    outline: 0;
}

.btn:hover {
    background-color: #f6f6f6;
}

.btn:active {
    background-color: #eee;
}

.btn:disabled {
    cursor: not-allowed;
    background: #f5f5f5;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;按钮子类&quot;&gt;按钮子类&lt;/h2&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;下面是按钮的子类，参照 &lt;strong&gt;BootStrap&lt;/strong&gt; ,我也把按钮的子类区分为 &lt;code&gt;Primary&lt;/code&gt;、&lt;code&gt;Success&lt;/code&gt;、&lt;code&gt;Danger&lt;/code&gt;、&lt;code&gt;Info&lt;/code&gt;、&lt;code&gt;Warn&lt;/code&gt;、&lt;code&gt;Link&lt;/code&gt;，下面以 &lt;code&gt;Primary&lt;/code&gt;为例，首先定义一般状态下的按钮样式，由于基类样式已经定义了一些一本属性，所以我们只需要定义 &lt;code&gt;background-color&lt;/code&gt;、&lt;code&gt;color&lt;/code&gt;、&lt;code&gt;border-color&lt;/code&gt;即可：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;.btn-primary {
    color: #fff;
    background-color: #1d7ce3;
    border-color: #1d7ce3;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样定义按钮的 &lt;code&gt;hover&lt;/code&gt;、&lt;code&gt;disabled&lt;/code&gt;、&lt;code&gt;active&lt;/code&gt;、&lt;code&gt;focus&lt;/code&gt; 的状态：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.btn-primary:hover {
    color: #fff;
    background-color: #1c70cc;
    border-color: #1c70cc;
}

.btn-primary:active {
    color: #fff;
    background-color: #1a68bc;
    background-color: #1a68bc;
}

.btn-primary:disabled {
    background: #74b5fc;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;其它&quot;&gt;其它&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;
.btn-success {
    color: #fff;
    background-color: #20be44;
    border-color: #20be44;
}

.btn-success:hover {
    color: #fff;
    background-color: #1da73d;
    border-color: #1da73d;
}

.btn-success:active {
    color: #fff;
    background-color: #1b9838;
    border-color: #1d9f3b;
}

.btn-success:disabled {
    background: #74e28d;
}

.btn-danger {
    color: #fff;
    background-color: #eb2a2a;
    border-color: #eb2a2a;
}

.btn-danger:hover {
    color: #fff;
    background-color: #d42a2a;
    border-color: #d42a2a;
}

.btn-danger:active {
    color: #fff;
    background-color: #b92020;
    border-color: #b92020;
}

.btn-danger:disabled {
    background: #ee7171;
}

.btn-warning {
    color: #fff;
    background-color: #fbc305;
    border-color: #fbc305;
}

.btn-warning:hover {
    color: #fff;
    background-color: #eab708;
    border-color: #eab708;
}

.btn-warning:active {
    color: #fff;
    background-color: #d6a707;
    background-color: #d6a707;
}

.btn-warning:disabled {
    background: #fadc77;
}

.btn-link {
    color: #1c70cc;
    border-color: transparent;
    background: transparent;
}

.btn-link:hover {
    text-decoration: underline;
    background: transparent;
}

.btn-link:active {
    color: #e53c0a;
}

.btn-link:disabled {
    background: transparent;
    color: #92c2f6;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;size&quot;&gt;Size&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;定义了按钮的基本状态后，我们还可以定义按钮的大小：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;.btn-large {
    font-size: 16px;
    padding: 8px 16px;
    border-radius: 6px;
}

.btn-mini {
    font-size: 8px;
    padding: 3px 6px;
    border-radius: 2px;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;block&quot;&gt;Block&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;.btn-block {
    display: block;
    width: 100%;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;效果&quot;&gt;效果&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/8/16f85b79d7faf93a?w=1371&amp;amp;h=891&amp;amp;f=gif&amp;amp;s=310993&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;欢迎批评指正&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;源码地址&quot;&gt;源码地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LaosanShang/ls-admin-frontend&quot; class=&quot;uri&quot;&gt;https://github.com/LaosanShang/ls-admin-frontend&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 08 Jan 2020 15:18:00 +0000</pubDate>
<dc:creator>CharlesShang</dc:creator>
<og:description>目录 &amp;quot;东拼西凑完成一个后台 ”前端框架“ (1) 布局&amp;quot; &amp;quot;东拼西凑完成一个后台 ”前端框架“ (2) 字体图标&amp;quot; &amp;quot;东拼西凑完成一个“前端框架”(</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xinwang/p/12169190.html</dc:identifier>
</item>
<item>
<title>#ICCV2019论文阅读#Fully_convolutional_Features - uwbb</title>
<link>http://www.cnblogs.com/saurywb/p/12168610.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/saurywb/p/12168610.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一 知识背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;3D scan&amp;amp;cloud&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt; &lt;span&gt;&lt;em&gt;&lt;strong&gt;points(点&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;云）patch-based&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt; &lt;span&gt;&lt;em&gt;&lt;strong&gt;features，fully convolutional network, deep metric learning, sparse tensors,sparse convolutions, hard negetive-mining, contrastive loss, triplet loss, batch normalization...&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.cloud points(点云）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　“在&lt;a href=&quot;https://baike.baidu.com/item/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/5097433&quot; target=&quot;_blank&quot; data-lemmaid=&quot;5097433&quot;&gt;逆向工程&lt;/a&gt;中通过测量仪器得到的产品外观表面的点数据集合也称之为点云，通常使用三维坐标测量机所得到的点数量比较少，点与点的间距也比较大，叫稀疏点云；而使用&lt;a href=&quot;https://baike.baidu.com/item/%E4%B8%89%E7%BB%B4%E6%BF%80%E5%85%89%E6%89%AB%E6%8F%8F%E4%BB%AA/5796256&quot; target=&quot;_blank&quot; data-lemmaid=&quot;5796256&quot;&gt;三维激光扫描仪&lt;/a&gt;或照相式扫描仪得到的点云，点数量比较大并且比较密集，叫密集点云，&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;点云是在和目标表面特性的海量点集合。根据激光测量原理得到的点云，包括三维坐标（XYZ）和激光反射强度（Intensity）。根据摄影测量原理得到的点云，包括三维坐标（XYZ）和颜色信息（RGB）。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;结合激光测量和摄影测量原理得到点云，包括三维坐标（XYZ）、激光反射强度（Intensity）和颜色信息（RGB）。在获取物体表面每个采样点的空间坐标后，得到的是一个点的集合，称之为“点云”(Point Cloud)。点云的格式：; *.pts; *.asc ; *.dat; *.stl ;*.imw；*.xyz;。”&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;-----from 百度百科。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.patch-based features&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即基于一块数据的特征。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.fully convolutional networks&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;15.618290258449&quot;&gt;具体可参见Long[2014]年的论文&lt;span&gt;&lt;a href=&quot;https://arxiv.org/abs/1411.4038&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;FCN&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，还可参见这篇博客&lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/tuuzhang/article/details/81004731&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;CSDN_Blog&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。简单的说，Long等人将传统CNN网络如AlexNet, VGGNet的后几个全连接层全部改装成卷积层，因为Long提到全连接层可以看作卷积核覆盖整个输入的卷积（”these fully connected layers can also be viewed as convolutions with kernels that cover their entire input regions.&quot;)，这种转换非常有效的提升了计算效率,因为它不必重复的计算重叠的patch上的卷积。&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4 deep metric learning(深度度量学习&lt;/strong&gt;&lt;/span&gt;）&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;10.738613861386&quot;&gt;如何有效的度量物体间的相似性？如果通过使用深度学习的方法去学习到这种度量的策略即是deep metric learning。现有的依赖对比（contrastive loss)和三元组损失（triplet loss),由于正负样本可组合的数量极多，因此人们多采用仅对训练有意义的正负样本采样，也被称为“难例挖掘”（hard negative mining)。可参考&lt;span&gt;&lt;a href=&quot;http://tis.hrbeu.edu.cn/oa/darticle.aspx?type=view&amp;amp;id=201906045&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;这篇综述&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。综述里包括了对&lt;em&gt;&lt;strong&gt;hard negetive-mining, contrastive loss, triplet&lt;/strong&gt;&lt;/em&gt; &lt;strong&gt;loss&lt;/strong&gt;的解释说明。&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.hard negative mining(难例挖掘）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;8.3527397260274&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://www.zhihu.com/question/46292829&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;参见此知乎回答&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。大量的简单负例会使真正的对训练有意义的难例的梯度被“淹没”。难例挖掘就是在训练时，尽量多挖掘其难负例加入负样本集，这样比easy negative组成的负样本集更好。[具体的R-CNN中的hard negative mining]。&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;6.sparse tensors和作者定义的generalized(广义）sparse convolution&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在作者的工作中的3D data是对物体表面的3D扫描。在这样的3D空间中，大部分的空间是empty的。为了解决这种高维的稀疏矩阵,论文作者用sparse tensor,一个sparse tensor可以用一个矩阵Matrix去表示其坐标，另一个矩阵'向量'代表其特征（Features)：&lt;/p&gt;
&lt;div class=&quot;para&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1772242/202001/1772242-20200108172118072-2128474517.png&quot; alt=&quot;&quot; width=&quot;560&quot; height=&quot;397&quot;/&gt;

&lt;/div&gt;
&lt;p&gt;接着作者定义了广义的稀疏卷积。系数卷积不是第一次出现，作者在这里只是描述。不过作者这种定义方法确实不容易理解，我的意思是所用的数学公式。如图所示。&lt;/p&gt;
&lt;div class=&quot;para&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1772242/202001/1772242-20200108203252976-1815787310.png&quot; alt=&quot;&quot;/&gt;

&lt;/div&gt;
&lt;div class=&quot;para&quot; readability=&quot;30&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1772242/202001/1772242-20200108202206571-541543773.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt; 在稀疏的卷积中和权值${W}$相乘的${x}$必须在${C}$中，这样的系数卷积得到的也是一个稀疏的结果。文中的${V^(3){-1,0,1}}$我觉得其中的元素不必是固定的${{-1,0,1}}$,如果非要是这样，卷积（相关）就无法计算了（这也是我在阅读时遇到的困惑）。当然最主要的还是要在code中去实现这个系数卷积。[接下来的时间我会探索一下]。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;文章正文：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从3D扫描或者是点云上提取几何特征是许多工作的第一步。例如注册（registration),重建（reconstruction)和跟踪(tracking）。现今的(state of art)方法需要将低阶（low-level)的特征作为输入来计算。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“低层次特征提取算法基于兴趣点所在表面及临近点的空间分布，提取基本的二维、三维几何属性作为兴趣点特征信息，&lt;em id=&quot;__mceDel&quot;&gt;如线性、平面性等。低层次特征提取算法复杂度低、运算效率&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;高、内存消耗少，但领域尺寸的选择对识别效果影响较大。”&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;em&gt;&lt;span&gt;“高层次特征提取算法基于低层次几何特征及临近点空间分布，定义并计算更复杂的几何属性作为特征信息。根据几何属性的定义又可细分为基于显著性、基于直方图、基于显著性直方图与基于其他特征的四大类提取算法[1][2]。”&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;span&gt;或者是基于有限感知域的块特征。在该文章中作者提出了有3D全卷积网络计算得来的一种全卷积的几何特征。同时作者提出了一个metric learning 的损失函数，这个损失函数极大的提高了算法的性能。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;接着作者吹捧了一波自己的全卷积几何特征，说这种特征是很紧凑（compact),然后能结合很大的空间的上下文的信息，而且能够拓展到很大的场景（scenes）。接着说这种特征不需要预处理（preprocessing),在室内和室外的数据集上比之前最精确的方法快290倍，而且自己的特征维数只有32维哦~&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;给张图感受下全卷积特征的“统治力”：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;91&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1772242/202001/1772242-20200108210434678-994432438.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;

&lt;p&gt; 这里说明下指标：recall 中文叫查全率又叫召回率，其计算公式如下：&lt;/p&gt;
&lt;p&gt;$recal{l_c} = \frac{{T{P_c}}}{{T{P_c} + F{N_c}}}$&lt;/p&gt;
&lt;p&gt;意思是某一类判断正确占到该类总数的百分比。理所当然的想要提升recall可以遵循“宁可错杀一百，不可放过一人”的思想。嘿嘿~&lt;/p&gt;
&lt;p&gt;接着我们给出作者用的网络框架：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1772242/202001/1772242-20200108211951072-839376369.png&quot; alt=&quot;&quot; width=&quot;212&quot; height=&quot;565&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 这是一个ResUNet的架构，两个白框是输入输出层，每个块用三个参数来描述：kernel size, stride, channel dimensionality.(核大小，步幅，和通道维度）除了最后一层其他的卷积层后面都有Batch normalization然后跟一个非线性（Relu).&lt;/p&gt;
&lt;p&gt;那说了半天啥是全卷积特征啊？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1772242/202001/1772242-20200108212553287-1176619573.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 全卷积特征作者说了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1772242/202001/1772242-20200108212635677-77452147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我给你翻译翻译：&lt;/p&gt;
&lt;p&gt;全卷积网络纯粹的由具有平移不变性的操作组成，像卷积和元素级别的非线性。（我不懂啥是元素级别的非线性啊？）同样，我们吧稀疏卷积网络（注这里是因为他用的稀疏卷积所以将这个网络将spase convolution network)给一个稀疏的tensor用上，我们得到的也是个稀疏的tensor，我们把这个稀疏的tensor输出叫做全卷积特征。&lt;/p&gt;
&lt;p&gt;OK。&lt;/p&gt;
&lt;p&gt;重头戏来了，嘿嘿~&lt;/p&gt;
&lt;p&gt;作者自己说自己搞了个新的Metric learning的新的损失函数。在看他的新家伙式儿之前，我们不妨回顾下他站在谁的肩膀上搞了个大新闻。。&lt;/p&gt;
&lt;p&gt;在前面的背景知识里有提到，就是negative mining 和标准的metric learning 的损失函数。这个作者说自己用全卷积网络了搞了个metric learning，而且还把negative mining整合到对比损失函数和三元组损失函数里了，他自己把整合后的这个新的损失函数叫做“Hardest contrastive&quot;和”hardest-triplet&quot;&lt;/p&gt;
&lt;p&gt;网络：“我太难了（哭腔）&quot;。&lt;/p&gt;
&lt;p&gt;好言归正传，想要搞metric learning必须遵循两个约束，一个是类似的特征必须和彼此之间挨的足够近，对于分类来说，肯定是越近越好，那么有&lt;/p&gt;
&lt;p&gt;$D({{f}_{i}},{{f}_{j}})\to 0\forall (i,j)\in P$&lt;/p&gt;
&lt;p&gt;啥意思？${P}$是正确配对feature-match成功的特征，${(i,j)}$是其中的一个组合。相反的不相似的特征必然挨的越远越好，那我们就给他一个警戒线称之为margin(注：margin在英语里由差距，差额之意）用数学来说就是&lt;/p&gt;
&lt;p&gt;$D({{f}_{i}},{{f}_{j}})&amp;gt;m\forall (i,j)\in N$&lt;/p&gt;
&lt;p&gt;这里的${D}$是一种距离的衡量手段，原文没说啥距离，我觉得应该可以用欧氏距离。&lt;/p&gt;
&lt;p&gt;文章说Lin等人说这些对于正例的约束会导致网络过拟合，然后搞出个针对正例的基于margin的损失函数。式子里右下角的+号代表着大于0时就取这个值，否则就取0。说实话，我因为一直吧这里边的${I_{ij}}$当是个示性函数，以为根据后边中括号里边的东西来取值，一直没搞懂，后来偶来见发现tm这两货是分开的。我真想吐槽这作者。。&lt;/p&gt;
&lt;p&gt;作者的对正例加了个margin的约束后，可以解决网络过拟合的现像。&lt;/p&gt;
&lt;p&gt;接着又弄个三元组（triplet loss)损失，我一并给出原文，瞅瞅：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1772242/202001/1772242-20200108215859131-1782869092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 在许多的文献了这篇文章后边也用了，这（4）里边的这个${f}$叫做anchor（中文名叫锚）而${f_+}$代表正例里边的元素。带负号的就不难说了。&lt;/p&gt;
&lt;p&gt;在negative mining里边就说了，网络的性能会被小部分”人&quot;左右，是谁呢？就是那些对于网络来说非常难啃的硬骨头——“hardest negatives&quot;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;接着作者讨论一个容易被人忽视，但却至关重要的存在：全卷积特征的特性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;传统的Metric learning 认为特征是独立同分布的（iid)，为啥？作者说了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1772242/202001/1772242-20200108222150730-785376384.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;因为batch是随机采样来的。&lt;/p&gt;
&lt;p&gt;这里需要和大家回顾下啥是epoch,batch,iteration???&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;epoch：代表在整个数据集上的一次迭代（所有一切都包含在训练模型中）；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;batch：是指当我们无法一次性将整个数据集输入神经网络时，将数据集分割成的一些更小的数据集批次；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;iteration：是指运行一个 epoch 所需的 batch 数。举个例子，如果我们的数据集包含 10000 张图像，批大小（batch_size）是 200，则一个 epoch 就包含 50 次迭代（10000 除以 200）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;虽说基础，但也要温故而知新嘛~&lt;/p&gt;
&lt;p&gt;然而，然而...&lt;/p&gt;
&lt;p&gt;在全卷积特征的提取过程中，相邻特征的位置是相关的。（我也不懂...）&lt;/p&gt;




&lt;/div&gt;
</description>
<pubDate>Wed, 08 Jan 2020 15:01:00 +0000</pubDate>
<dc:creator>uwbb</dc:creator>
<og:description>一 知识背景 3D scan&amp;amp;cloud points(点云）patch-based features，fully convolutional network, deep metric lea</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/saurywb/p/12168610.html</dc:identifier>
</item>
<item>
<title>Python 线性回归（Linear Regression) 基本理解 - 不忘初心mao</title>
<link>http://www.cnblogs.com/learnbydoing/p/12169130.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/learnbydoing/p/12169130.html</guid>
<description>&lt;p&gt;学习 &lt;a href=&quot;https://realpython.com/linear-regression-in-python/&quot;&gt;Linear Regression in Python – Real Python&lt;/a&gt;，对线性回归理论上的理解做个回顾，文章是前天读完，今天凭着记忆和理解写一遍，再回温更正。&lt;/p&gt;

&lt;p&gt;刚好今天听大妈讲机器学习，各种复杂高大上的算法，其背后都是在求”拟合“。&lt;/p&gt;
&lt;p&gt;线性回归估计是最简单的拟合了。也是基础中的基础。&lt;/p&gt;
&lt;p&gt;依然是从字面上先来试着拆解和组合：&lt;/p&gt;
&lt;p&gt;首先，&lt;strong&gt;Regression&lt;/strong&gt; 回归，指的是研究变量之间的关系，这个由来在&lt;a href=&quot;https://bemself.github.io/python/Python-Linear-Regression-Concept.html&quot;&gt;Python 线性回归（Linear Regression) - 到底什么是 regression？&lt;/a&gt;一文中讲多了，这里不多重复。&lt;/p&gt;
&lt;p&gt;然后，&lt;strong&gt;linear&lt;/strong&gt; 线性，很直观：直线。&lt;/p&gt;
&lt;p&gt;二者连在一起，便是：变量之间呈直线关系。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那具体是哪些变量之间？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因变量 y 和 自变量 (x1...xr) 之间。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;𝑦 = 𝛽₀ + 𝛽₁𝑥₁ + ⋯ + 𝛽ᵣ𝑥ᵣ + 𝜀&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当只有一个 x1 的时候，就是最简单的线性回归 &lt;code&gt;𝑦 = 𝛽₀ + 𝛽₁𝑥₁&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体怎么理解这个公式呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举个简化的例子：员工的工资 y 与 学历 x 的关系。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;假设学历越高，工资也越高，二者是某种程度上的线性关系，&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那在&lt;strong&gt;理论上&lt;/strong&gt;会存在这么一个公式 &lt;code&gt;y = 𝛽₀ + 𝛽₁𝑥&lt;/code&gt;，其中，x1...xn, y1...yn：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;x 和 y 的数据很容易拿到（当然合法渠道了，假设你是 hr 总监）&lt;/li&gt;
&lt;li&gt;hr 总监想做的是，根据这组 (x y)数据，找出 𝛽₀ 和 𝛽₁ 的值，二者称为&lt;strong&gt;回归系数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;这样，下一次招聘的时候，根据应聘者的学历，可以先估一个工资了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个过程便是：数据 -&amp;gt; 建立模型 f(x) -&amp;gt; 预测&lt;/p&gt;
&lt;p&gt;只是，理论和实际总是有差别的，就像 1/3 ~= 0.3333333333333...&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;实际拟合&lt;/strong&gt;到的模型可能是这样的： &lt;code&gt;f(x) = 𝑏₀ + 𝑏₁𝑥&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;𝛽₀ 和 𝛽₁ 分别与 𝑏₀ 和 𝑏₁ 有多接近？&lt;/p&gt;
&lt;p&gt;当然是拟合出来的越接近越好；&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1147676/202001/1147676-20200108225455955-738489336.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何知道有多接近？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将 x1...xn 代入到拟合后的模型中 f(x),&lt;/li&gt;
&lt;li&gt;求得新的 new_y1...new_yn&lt;/li&gt;
&lt;li&gt;再跟原 y1...yn 比较，比如 &lt;code&gt;new_y1 - y1&lt;/code&gt; （称为残差）
&lt;ul&gt;&lt;li&gt;这里要用到最小二乘法（method of ordinary least squares）&lt;/li&gt;
&lt;li&gt;因为残差可能是负的，&lt;/li&gt;
&lt;li&gt;所以用残差平方和&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;回归要解决的问题就是：&lt;/strong&gt;以最简单的线性回归为例：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;找到最佳的 𝑏₀ 和 𝑏₁， 使模型 &lt;code&gt;f(x) = 𝑏₀ + 𝑏₁𝑥&lt;/code&gt; 最接近理论上的线性模型 &lt;code&gt;y = 𝛽₀ + 𝛽₁𝑥&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;然后，用这个拟合好的模型 &lt;code&gt;f(x) = 𝑏₀ + 𝑏₁𝑥&lt;/code&gt; 来预测新的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了上面例子中的最简单的线性回归，还有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;多元线性回归：Multiple linear Regression
&lt;ul&gt;&lt;li&gt;&lt;code&gt;𝑓(𝑥₁, 𝑥₂) = 𝑏₀ + 𝑏₁𝑥₁ + 𝑏₂𝑥₂&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;多项式回归：Polynomial Regression
&lt;ul&gt;&lt;li&gt;&lt;code&gt;𝑓(𝑥) = 𝑏₀ + 𝑏₁𝑥 + 𝑏₂𝑥²&lt;/code&gt;....&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;即从二维转为三维、多维空间拟合了。这个有点复杂了，不过原理和前面是相通的。&lt;/p&gt;

&lt;p&gt;过犹不及用在这里也适合，过度拟合也很脆弱的，因为可能新增加一个或几个数据就破坏了之前的完美，就好像专门为你定制的帽子戴在别人头上就没那么合适和美了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1147676/202001/1147676-20200108225457456-1955838327.png&quot; alt=&quot;overfitting&quot;/&gt;](&lt;a href=&quot;https://files.realpython.com/media/poly-reg.5790f47603d8.png&quot; class=&quot;uri&quot;&gt;https://files.realpython.com/media/poly-reg.5790f47603d8.png&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;当然，拟合的不及也不好，这时候可能就要换模型或者调参了吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1147676/202001/1147676-20200108225458747-1948324477.png&quot; alt=&quot;underfitting&quot;/&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;4.1509433962264&quot;&gt;
&lt;p&gt;本文由博客一文多发平台 &lt;a href=&quot;https://openwrite.cn?from=article_bottom&quot;&gt;OpenWrite&lt;/a&gt; 发布！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 08 Jan 2020 14:55:00 +0000</pubDate>
<dc:creator>不忘初心mao</dc:creator>
<og:description>背景 学习 &amp;quot;Linear Regression in Python – Real Python&amp;quot; ，对线性回归理论上的理解做个回顾，文章是前天读完，今天凭着记忆和理解写一遍，再回</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/learnbydoing/p/12169130.html</dc:identifier>
</item>
<item>
<title>当Parallel遇上了DI - Spring并行数据聚合最佳实践 - lvyahui</title>
<link>http://www.cnblogs.com/lvyahui/p/12169119.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lvyahui/p/12169119.html</guid>
<description>&lt;h2 id=&quot;分析淘宝pdp&quot;&gt;分析淘宝PDP&lt;/h2&gt;
&lt;p&gt;让我们先看个图, Taobao的PDP(Product Detail Page)页.&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/6/16f7acf6cf406b93?w=385&amp;amp;h=876&amp;amp;f=png&amp;amp;s=327055&quot; width=&quot;35%&quot;/&gt;&lt;/div&gt;
&lt;p&gt;打开Chrome Network面板, 让我们来看taobao是怎么加载这个页面数据的. 根据经验, 一般是异步加载的, 要么是XHR,要么就是js(jsonp), 你应该很快可以找到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/6/16f7ad3a59459ed7?w=1072&amp;amp;h=533&amp;amp;f=png&amp;amp;s=406202&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还能看到这个接口的性能&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/6/16f7ad67966e7534?w=1157&amp;amp;h=373&amp;amp;f=png&amp;amp;s=53324&quot;/&gt;&lt;/p&gt;
&lt;p&gt;神奇的是, &lt;span&gt;&lt;strong&gt;taobao竟然在一次请求中拉下了整个PDP页的完整数据, 而且服务端处理耗时不到125ms&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先, 这么做有什么好处?&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;前后端开发对接简单&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在一次网络连接中尽可能多的传输数据(数据大小要不影响用户体验, 一般不会超过300kb), 减少建立连接的次数和请求头浪费的流量.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后, 这又是怎么做到的呢?&lt;/p&gt;
&lt;p&gt;你可能会说缓存, 但你要知道, 这样一个对电商极为重要的页面, 绝对涉及到了非常多的团队, 比如:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;商品团队&lt;/li&gt;
&lt;li&gt;卖家团队&lt;/li&gt;
&lt;li&gt;评价团队&lt;/li&gt;
&lt;li&gt;订单团队&lt;/li&gt;
&lt;li&gt;会员团队&lt;/li&gt;
&lt;li&gt;优惠团队&lt;/li&gt;
&lt;li&gt;问答团队&lt;/li&gt;
&lt;li&gt;推荐团队&lt;/li&gt;
&lt;li&gt;物流系统&lt;/li&gt;
&lt;li&gt;etc/等等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;即使每个团队的数据全都是缓存的, 你一个个去拿, 要在125ms内拿完也不容易.&lt;/strong&gt;&lt;/span&gt; 而且作为跟钱相关的页面, 部分数据必须保证绝对实时有效, 能用缓存的地方不多. 怎么办, 如果是你, 你会怎么做? 离线打标? 数据预热? etc..&lt;/p&gt;
&lt;p&gt;此时, 并行调用不失为一种好办法.&lt;/p&gt;
&lt;p&gt;分析一下这个页面, 你会发现, &lt;span&gt;&lt;strong&gt;每一个模块除了属于同一个商品(入参相同), 其实各个模块的数据之间, 并没有依赖性, 完全可以并行去获取.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;并行就没有问题了吗&quot;&gt;并行就没有问题了吗?&lt;/h2&gt;
&lt;p&gt;并行获取数据, 可以提高我们的接口性能. 但也会引入一些问题, 如:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;依赖的项可能很多, 怎么使代码简洁清晰?&lt;/li&gt;
&lt;li&gt;依赖关系很可能是一个有向图, 如果做到有向图中的每个节点都可以并行执行?&lt;/li&gt;
&lt;li&gt;异步处理后, 超时怎么处理? 业务代码抛出异常了怎么处理?&lt;/li&gt;
&lt;li&gt;依赖关系如果有死循环怎么办?&lt;/li&gt;
&lt;li&gt;异步之后, ThreadLocal中的内容怎么处理? 一些基于ThreadLocal实现的Context不work怎么办?&lt;/li&gt;
&lt;li&gt;事务被线程隔离了怎么办?&lt;/li&gt;
&lt;li&gt;如何监控每一次异步执行, 每个节点的性能?&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面, 我们来讨论下如何简单\易用\高效的并行获取数据; 如何解决上述异步问题.&lt;/p&gt;
&lt;h2 id=&quot;常见的并行方式&quot;&gt;常见的并行方式&lt;/h2&gt;
&lt;p&gt;假如你现在需要用户的基础信息\博客列表\粉丝列表 3份数据. 哪么你有哪些方式可以并行获取呢?&lt;/p&gt;
&lt;h3 id=&quot;java-threadpool并行&quot;&gt;Java ThreadPool并行&lt;/h3&gt;
&lt;p&gt;最简单原始的办法, 直接使用Java提供了的线程池和Future机制.&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public User getUserDataByParallel(Long userId) throws InterruptedException, ExecutionException {
    ExecutorService executorService = Executors.newFixedThreadPool(3);
    CountDownLatch countDownLatch = new CountDownLatch(3);
    Future&amp;lt;User&amp;gt; userFuture = executorService.submit(() -&amp;gt; {
        try{
            return userService.get(userId);
        }finally {
            countDownLatch.countDown();
        }
    });
    Future&amp;lt;List&amp;lt;Post&amp;gt;&amp;gt; postsFuture = executorService.submit(() -&amp;gt; {
        try{
            return postService.getPosts(userId);
        }finally {
            countDownLatch.countDown();
        }
    });
    Future&amp;lt;List&amp;lt;User&amp;gt;&amp;gt; followersFuture = executorService.submit(() -&amp;gt; {
        try{
            return followService.getFollowers(userId);
        }finally {
            countDownLatch.countDown();
        }
    });
    countDownLatch.await();
    User user = userFuture.get();
    user.setFollowers(followersFuture.get());
    user.setPosts(postsFuture.get());
    return user;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;spring的异步并行&quot;&gt;Spring的异步并行&lt;/h3&gt;
&lt;p&gt;我们知道, Spring支持@Async注解, 可以方便的实现异步, 并且支持获取返回值. 参考: https://www.baeldung.com/spring-async#2-methods-with-return-type&lt;/p&gt;
&lt;p&gt;@Async实现的原理实际是在Bean的代理类的方法中, 拦截方法调用, 向taskExecutor Bean中提交Callable任务. 原理跟自己用Java ThreadPool写其实区别不大.&lt;/p&gt;
&lt;p&gt;那么要用Spring Async实现上述功能. 首先需要修改下面3个方法的返回值, 并且修改返回值类型, 并为方法添加 @Async注解&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class UserServiceImpl implements UserService {
    @Async
    public Future&amp;lt;User&amp;gt; get(Long userId) {
        // ... something
    }
}
class PostServiceImpl implements PostService {
    @Async
    public Future&amp;lt;List&amp;lt;Post&amp;gt; getPosts(Long userId) {
        // ... something
    }
}
class FollowServiceImpl implements FollowService {
    @Async
    public Future&amp;lt;List&amp;lt;User&amp;gt; getFollowers(Long userId) {
        // ... something
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并行获取3份用户数据然后聚合, 代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public User getUserDataByParallel(Long userId) throws InterruptedException, ExecutionException {
    Future&amp;lt;User&amp;gt; userFuture = userService.get(userId);
    Future&amp;lt;List&amp;lt;Post&amp;gt;&amp;gt; postsFuture = postService.getPosts(userId);
    Future&amp;lt;List&amp;lt;User&amp;gt;&amp;gt; followersFuture = followService.getFollowers(userId);
    
    User user = whileGet(userFuture);
    user.setFollowers(whileGet(followersFuture));
    user.setPosts(whileGet(postsFuture));
    return user;
}

private &amp;lt;T&amp;gt; T whileGet(Future&amp;lt;T&amp;gt; future) throws ExecutionException, InterruptedException {
    while(true) {
        if (future.isDone()) {
            break;
        }
    }
    return future.get();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里使用自旋去获取异步数据. 当然你也可以像前面那样, 传递一个闭锁(CountDownLatch)到Service中去, 然后让主调线程在一个闭锁上面等待.&lt;/p&gt;
&lt;h2 id=&quot;并行结合di依赖注入&quot;&gt;并行结合DI(依赖注入)&lt;/h2&gt;
&lt;p&gt;上面2种方式的确能实现功能, 但首先, 它们都很不直观, 而且没有处理前面讲到的异步问题, 一旦出现超时\异常\ThreadLocal, 代码可能不会按照你预期的方式工作. 那有没有更简单方便可靠的方法呢?&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;试想这样一种方式, 如果你需要的数据, 都可以通过方法入参自动并行获取, 然后传递给你, 那是不是很方便? 就像这样:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
public class UserAggregate {
    @DataProvider(&quot;userWithPosts&quot;)
    public User userWithPosts(
            @DataConsumer(&quot;user&quot;) User user,
            @DataConsumer(&quot;posts&quot;) List&amp;lt;Post&amp;gt; posts,
            @DataConsumer(&quot;followers&quot;) List&amp;lt;User&amp;gt; followers) {
        user.setPosts(posts);
        user.setFollowers(followers);
        return user;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;这里的&lt;code&gt;@DataConsumer&lt;/code&gt;声明了你要异步获取的数据id. &lt;code&gt;@DataProvider&lt;/code&gt;声明了这个方法提供数据, 并且id为userWithPosts.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;或者你&lt;span&gt;不想写这样一个Aggregate类, 你不需要复用, 你想直接创建一个&quot;匿名Provider&quot;. 那么你可以直接在任何地方像下面这样调用拿结果&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;User user = dataBeanAggregateQueryFacade.get(
     Collections.singletonMap(&quot;userId&quot;, 1L), 
     new Function3&amp;lt;User, List&amp;lt;Post&amp;gt;,List&amp;lt;User&amp;gt;, User&amp;gt;() {
            @Override
            public User apply(@DataConsumer(&quot;user&quot;) User user, 
                              @DataConsumer(&quot;posts&quot;) List&amp;lt;Post&amp;gt; posts,
                              @DataConsumer(&quot;followers&quot;) List&amp;lt;User&amp;gt; followers) {
                user.setPosts(posts);
                user.setFollowers(followers);
                return user;
            }
     });
Assert.notNull(user,&quot;user not null&quot;);
Assert.notNull(user.getPosts(),&quot;user posts not null&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的Function3接收4个泛型参数, 最后一个User表示返回值类型, 前3个参数依次对应apply方法的3个入参类型. 项目预定义了Function2-Function5, 支持不超过5个参数, 如果你需要更多参数, 可以编写一个接口(FunctionInterface), 继承MultipleArgumentsFunction接口即可.&lt;/p&gt;
&lt;p&gt;很显然&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每一个 &lt;code&gt;@DataConsumer&lt;/code&gt; 只会对应一个 &lt;code&gt;@DataProvider&lt;/code&gt; .&lt;/li&gt;
&lt;li&gt;一个 &lt;code&gt;@DataProvider&lt;/code&gt; 可能被多个 &lt;code&gt;@DataConsumer&lt;/code&gt; 消费 .&lt;/li&gt;
&lt;li&gt;一个 &lt;code&gt;@DataProvider&lt;/code&gt; 通过多个 &lt;code&gt;@DataConsumer&lt;/code&gt; 依赖上多个 &lt;code&gt;@DataProvider&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;你不用care底层如何实现. 只有在你有定制化的需求时, 才去关心一些配置参数. 去扩展一些能力.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;实现原理&quot;&gt;实现原理&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/7/16f801ad8f984b10?w=595&amp;amp;h=520&amp;amp;f=png&amp;amp;s=45315&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;在Spring启动之时, 扫描应用中的 &lt;code&gt;@DataProvider&lt;/code&gt; 和 &lt;code&gt;@DataConsumer&lt;/code&gt; 注解. 分析记录下依赖关系(有向非连通图), 并且记录好&lt;code&gt;@DataProvider&lt;/code&gt;和Spring Bean的映射关系.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当进行查询时, 从已经记录好的依赖关系中拿出依赖树, 使用线程池和闭锁(CountLatchDown), 递归异步调用孩子节点对应的Bean方法, 拿到结果后作为入参注入当前节点 (近似广度优先, 但因为并行的原因, 节点的访问顺序是不确定的).&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在发起递归调用前, 传入进一个map, 用来存放查询参数, 方法中没有&lt;code&gt;@DataConsumer&lt;/code&gt;注解的入参, 将从此map中取值.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@DataProvider&lt;/code&gt; 和 &lt;code&gt;@DataConsumer&lt;/code&gt; 注解可以支持一些参数, 用来控制超时时间\异常处理方式\是否幂等缓存等等.&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;怎么解决并行异步后引入的新问题&quot;&gt;怎么解决并行/异步后引入的新问题&lt;/h3&gt;
&lt;h4 id=&quot;超时怎么控制&quot;&gt;超时怎么控制 ?&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;@DataProvider&lt;/code&gt; 注解支持 &lt;code&gt;timeout&lt;/code&gt; 参数, 用来控制超时. 实现原理是通过闭锁的超时等待方法.&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;java.util.concurrent.CountDownLatch#await(long, java.util.concurrent.TimeUnit)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;异常怎么处理&quot;&gt;异常怎么处理 ?&lt;/h4&gt;
&lt;p&gt;对异常提供两种处理方式: 吞没或者向上层抛出.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@DataConsumer&lt;/code&gt; 注解支持&lt;code&gt;exceptionProcessingMethod&lt;/code&gt; 参数, 用来表示这个Consumer想怎么处理Provider抛出的异常.&lt;/p&gt;
&lt;p&gt;当然, 也支持在全局维度配置. 全局配置的优先级低于(&amp;lt;)Consumer配置的优先级.&lt;/p&gt;
&lt;h4 id=&quot;依赖关系有死循环怎么办&quot;&gt;依赖关系有死循环怎么办 ?&lt;/h4&gt;
&lt;p&gt;Spring Bean初始化, 因为Bean创建和Bean属性赋值分了两步走, 因此可以用所谓的&quot;早期引用&quot;解决循环依赖的问题.&lt;/p&gt;
&lt;p&gt;但如果你循环依赖的Bean, 依赖关系定义在构造函数入参上, 那么是没法解决循环依赖的问题的.&lt;/p&gt;
&lt;p&gt;同理, 我们通过方法入参, 异步注入依赖数据, 在方法入参没有变化的情况下, 也是无法结束死循环的. 因此必须禁止循环依赖.&lt;/p&gt;
&lt;p&gt;那么问题变为了怎么禁止循环依赖. 或者说, 怎么检测有向非联通图中的循环依赖, 两个办法:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;带染色的DFS遍历: 节点入栈访问前, 先标记节点状态为&quot;访问中&quot;, 之后递归访问孩子节点, 递归完成后, 将节点标记为&quot;访问完成&quot;. &lt;strong&gt;如果在DFS递归过程中, 再次访问到&quot;访问中&quot;的节点, 说明有环.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;拓扑排序: 把有向图的节点排成一个序列, 不存在索引号较高的节点指向索引号较低的节点, 表示图存在拓扑排序. 拓扑排序的实现方法是, 先删除入度为0的节点, 并将领接节点的入度 - 1, 直到所有节点都被删除. &lt;strong&gt;很显然, 如果有向图中有环, 那么环里节点的入度不可能为0 , 那么节点不可能删完. 因此, 只要满足节点未删完 &amp;amp;&amp;amp; 不存在入度为0的节点, 那么一定有环.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里我们用领接表+DFS染色搜索, 来实现环的检查&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void checkCycle(Map&amp;lt;String,Set&amp;lt;String&amp;gt;&amp;gt; graphAdjMap) {
    Map&amp;lt;String,Integer&amp;gt; visitStatusMap = new HashMap&amp;lt;&amp;gt;(graphAdjMap.size() * 2);
    for (Map.Entry&amp;lt;String, Set&amp;lt;String&amp;gt;&amp;gt; item : graphAdjMap.entrySet()) {
        if (visitStatusMap.containsKey(item.getKey())) {
            continue;
        }
        dfs(graphAdjMap,visitStatusMap,item.getKey());
    }
}

private void dfs(Map&amp;lt;String,Set&amp;lt;String&amp;gt;&amp;gt; graphAdjMap,Map&amp;lt;String,Integer&amp;gt; visitStatusMap, String node) {
    if (visitStatusMap.containsKey(node)) {
        if(visitStatusMap.get(node) == 1) {
            List&amp;lt;String&amp;gt; relatedNodes = new ArrayList&amp;lt;&amp;gt;();
            for (Map.Entry&amp;lt;String,Integer&amp;gt; item : visitStatusMap.entrySet()) {
                if (item.getValue() == 1) {
                    relatedNodes.add(item.getKey());
                }
            }
            throw new IllegalStateException(&quot;There are loops in the dependency graph. Related nodes:&quot; + StringUtils.join(relatedNodes));
        }
        return ;
    }
    visitStatusMap.put(node,1);
    log.info(&quot;visited:{}&quot;, node);
    for (String relateNode : graphAdjMap.get(node)) {
        dfs(graphAdjMap,visitStatusMap,relateNode);
    }
    visitStatusMap.put(node,2);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;threadlocal怎么处理&quot;&gt;ThreadLocal怎么处理?&lt;/h4&gt;
&lt;p&gt;许多的框架都使用了ThreadLocal来实现Context来保存单次请求中的一些共享数据, Spring也不例外.&lt;/p&gt;
&lt;p&gt;众所周知, ThreadLocal实际是访问Thread中一个特殊Map的入口. ThreadLocal只能访问当前Thread的数据(副本), 如果跨越了线程, 是拿不到到其他ThreadLocalMap的数据的.&lt;/p&gt;
&lt;h5 id=&quot;解决方法&quot;&gt;解决方法&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/8/16f80d51efd8083f?w=537&amp;amp;h=356&amp;amp;f=png&amp;amp;s=38489&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在当前线程提交异步任务前, 将当前线程ThreadLocal执行的数据&quot;捆绑&quot;到任务实例中&lt;/li&gt;
&lt;li&gt;当任务开始执行时, 从任务实例中取出数据, 恢复到当前异步线程的ThreadLocal中&lt;/li&gt;
&lt;li&gt;当任务结束后, 清理当前异步线程的ThreadLocal.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里, 我们先定义一个接口, 来描述这3个动作&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface AsyncQueryTaskWrapper {
    /**
     * 任务提交之前执行. 此方法在提交任务的那个线程中执行
     */
    void beforeSubmit();

    /**
     * 任务开始执行前执行. 此方法在异步线程中执行
     * @param taskFrom 提交任务的那个线程
     */
    void beforeExecute(Thread taskFrom);

    /**
     * 任务执行结束后执行. 此方法在异步线程中执行
     * 注意, 不管用户的方法抛出何种异常, 此方法都会执行.
     * @param taskFrom 提交任务的那个线程
     */
    void afterExecute(Thread taskFrom);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了让我们定义的3个动作起作用. 我们需要重写一下 java.util.concurrent.Callable#call方法.&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract class AsyncQueryTask&amp;lt;T&amp;gt; implements Callable&amp;lt;T&amp;gt; {
    Thread      taskFromThread;
    AsyncQueryTaskWrapper asyncQueryTaskWrapper;

    public AsyncQueryTask(Thread taskFromThread, AsyncQueryTaskWrapper asyncQueryTaskWrapper) {
        this.taskFromThread = taskFromThread;
        this.asyncQueryTaskWrapper = asyncQueryTaskWrapper;
    }

    @Override
    public T call() throws Exception {
        try {
            if(asyncQueryTaskWrapper != null) {
                asyncQueryTaskWrapper.beforeExecute(taskFromThread);
            }
            return execute();
        } finally {
            if (asyncQueryTaskWrapper != null) {
                asyncQueryTaskWrapper.afterExecute(taskFromThread);
            }
        }
    }

    /**
     * 提交任务时, 业务方实现这个替代方法
     *
     * @return
     * @throws Exception
     */
    public abstract T  execute() throws Exception;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来, 向线程池提交任务时, 不再直接提交Callable匿名类实例, 而是提交AsyncQueryTask实例. 并且在提交前触发 &lt;code&gt;taskWrapper.beforeSubmit();&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;AsyncQueryTaskWrapper taskWrapper = new CustomAsyncQueryTaskWrapper();
// 任务提交前执行动作.
taskWrapper.beforeSubmit();
Future&amp;lt;?&amp;gt; future = executorService.submit(new AsyncQueryTask&amp;lt;Object&amp;gt;(Thread.currentThread(),taskWrapper) {
    @Override
    public Object execute() throws Exception {
        try {
            // something to do
        } finally {
            stopDownLatch.countDown();
        }
    }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;你要做什么&quot;&gt;你要做什么?&lt;/h5&gt;
&lt;p&gt;你只需要定义一个类, 实现这个接口, 并将这个类加到配置文件中去.&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Slf4j
public class CustomAsyncQueryTaskWrapper implements AsyncQueryTaskWrapper {
    /**
     * &quot;捆绑&quot; 在任务实例中的数据
     */
    private Long tenantId;
    private User user;

    @Override
    public void beforeSubmit() {
        /* 提交任务前, 先从当前线程拷贝出ThreadLocal中的数据到任务中 */
        log.info(&quot;asyncTask beforeSubmit. threadName: {}&quot;,Thread.currentThread().getName());
        this.tenantId = RequestContext.getTenantId();
        this.user = ExampleAppContext.getUser();
    }

    @Override
    public void beforeExecute(Thread taskFrom) {
        /* 任务提交后, 执行前, 在异步线程中用数据恢复ThreadLocal(Context) */
        log.info(&quot;asyncTask beforeExecute. threadName: {}, taskFrom: {}&quot;,Thread.currentThread().getName(),taskFrom.getName());
        RequestContext.setTenantId(tenantId);
        ExampleAppContext.setLoggedUser(user);
    }

    @Override
    public void afterExecute(Thread taskFrom) {
        /* 任务执行完成后, 清理异步线程中的ThreadLocal(Context) */
        log.info(&quot;asyncTask afterExecute. threadName: {}, taskFrom: {}&quot;,Thread.currentThread().getName(),taskFrom.getName());
        RequestContext.removeTenantId();
        ExampleAppContext.remove();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加配置使TaskWapper生效.&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;io.github.lvyahui8.spring.task-wrapper-class=io.github.lvyahui8.spring.example.wrapper.CustomAsyncQueryTaskWrapper&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;怎么监控每一次的异步调用&quot;&gt;怎么监控每一次的异步调用?&lt;/h4&gt;
&lt;h5 id=&quot;解决办法&quot;&gt;解决办法&lt;/h5&gt;
&lt;p&gt;我们先把一次查询, 分为以下几个生命周期&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;查询任务初次提交 (querySubmitted)&lt;/li&gt;
&lt;li&gt;某一个Provider节点开始执行前 (queryBefore)&lt;/li&gt;
&lt;li&gt;某一个Provider节点执行完成后 (queryAfter)&lt;/li&gt;
&lt;li&gt;查询全部完成 (queryFinished)&lt;/li&gt;
&lt;li&gt;查询异常 (exceptionHandle)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;转换成接口如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface AggregateQueryInterceptor {
    /**
     * 查询正常提交, Context已经创建
     *
     * @param aggregationContext 查询上下文
     * @return 返回为true才继续执行
     */
    boolean querySubmitted(AggregationContext aggregationContext) ;

    /**
     * 每个Provider方法执行前, 将调用此方法. 存在并发调用
     *
     * @param aggregationContext 查询上下文
     * @param provideDefinition 将被执行的Provider
     */
    void queryBefore(AggregationContext aggregationContext, DataProvideDefinition provideDefinition);

    /**
     * 每个Provider方法执行成功之后, 调用此方法. 存在并发调用
     *
     * @param aggregationContext 查询上下文
     * @param provideDefinition 被执行的Provider
     * @param result 查询结果
     * @return 返回结果, 如不修改不, 请直接返回参数中的result
     */
    Object queryAfter(AggregationContext aggregationContext, DataProvideDefinition provideDefinition, Object result);

    /**
     * 每个Provider执行时, 如果抛出异常, 将调用此方法. 存在并发调用
     *
     * @param aggregationContext  查询上下文
     * @param provideDefinition 被执行的Provider
     * @param e Provider抛出的异常
     */
    void exceptionHandle(AggregationContext aggregationContext, DataProvideDefinition provideDefinition, Exception e);

    /**
     * 一次查询全部完成.
     *
     * @param aggregationContext 查询上下文
     */
    void queryFinished(AggregationContext aggregationContext);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;在Spring应用启动之初, 获取所有实现了AggregateQueryInterceptor接口的Bean, 并按照Order注解排序, 作为拦截器链.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;至于拦截器如何执行. 很简单, 在递归提交查询任务时, 插入执行一些钩子(hook)函数即可. 涉及到的代码很多, 就不贴在这里, 感兴趣的可以去github clone代码查看.&lt;/p&gt;
&lt;h5 id=&quot;你要做什么-1&quot;&gt;你要做什么?&lt;/h5&gt;
&lt;p&gt;你可以实现一个拦截器, 在拦截器中输出日志, 监控节点执行状态(耗时, 出入参), 如下:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
@Order(2)
@Slf4j
public class SampleAggregateQueryInterceptor implements AggregateQueryInterceptor {
    @Override
    public boolean querySubmitted(AggregationContext aggregationContext) {
        log.info(&quot;begin query. root:{}&quot;,aggregationContext.getRootProvideDefinition().getMethod().getName());
        return true;
    }

    @Override
    public void queryBefore(AggregationContext aggregationContext, DataProvideDefinition provideDefinition) {
        log.info(&quot;query before. provider:{}&quot;,provideDefinition.getMethod().getName());
    }

    @Override
    public Object queryAfter(AggregationContext aggregationContext, DataProvideDefinition provideDefinition, Object result) {
        log.info(&quot;query after. provider:{},result:{}&quot;,provideDefinition.getMethod().getName(),result.toString());
        return result;
    }

    @Override
    public void exceptionHandle(AggregationContext aggregationContext, DataProvideDefinition provideDefinition, Exception e) {
        log.error(e.getMessage());
    }

    @Override
    public void queryFinished(AggregationContext aggregationContext) {
        log.info(&quot;query finish. root: {}&quot;,aggregationContext.getRootProvideDefinition().getMethod().getName());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;项目地址&quot;&gt;项目地址&lt;/h2&gt;
&lt;p&gt;最后, 再次贴一下&lt;strong&gt;项目地址:&lt;/strong&gt; . &lt;a href=&quot;https://github.com/lvyahui8/spring-boot-data-aggregator&quot;&gt;spring-boot-data-aggregator&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎拍砖, 欢迎star, 欢迎使用&lt;/p&gt;
</description>
<pubDate>Wed, 08 Jan 2020 14:49:00 +0000</pubDate>
<dc:creator>lvyahui</dc:creator>
<og:description>分析淘宝PDP 让我们先看个图, Taobao的PDP(Product Detail Page)页. 打开Chrome Network面板, 让我们来看taobao是怎么加载这个页面数据的. 根据经验</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lvyahui/p/12169119.html</dc:identifier>
</item>
<item>
<title>Java 并发进阶常见面试题总结 - 不懒人</title>
<link>http://www.cnblogs.com/wuwuyong/p/12169102.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuwuyong/p/12169102.html</guid>
<description>

&lt;h2&gt;1. synchronized 关键字&lt;/h2&gt;
&lt;h3&gt;1.1. 说一说自己对于 synchronized 关键字的了解&lt;/h3&gt;
&lt;p&gt;synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。&lt;/p&gt;
&lt;p&gt;另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。&lt;/p&gt;
&lt;h3&gt;1.2. 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗&lt;/h3&gt;
&lt;p&gt;synchronized关键字最主要的三种使用方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;修饰实例方法: 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁&lt;/li&gt;
&lt;li&gt;修饰静态方法: 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。&lt;/li&gt;
&lt;li&gt;修饰代码块: 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总结： synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！&lt;/p&gt;
&lt;p&gt;下面我以一个常见的面试题为例讲解一下 synchronized 关键字的具体使用。&lt;/p&gt;
&lt;p&gt;面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”&lt;/p&gt;
&lt;p&gt;双重校验锁实现对象单例（线程安全）&lt;/p&gt;
&lt;div class=&quot;white&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span id=&quot;LC1&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kd&quot;&gt;class &lt;span class=&quot;nc&quot;&gt;Singleton &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC2&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC3&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;private &lt;span class=&quot;kd&quot;&gt;volatile &lt;span class=&quot;kd&quot;&gt;static &lt;span class=&quot;nc&quot;&gt;Singleton &lt;span class=&quot;n&quot;&gt;uniqueInstance&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC4&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC5&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;private &lt;span class=&quot;nf&quot;&gt;Singleton&lt;span class=&quot;o&quot;&gt;() &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC6&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;o&quot;&gt;}
&lt;span id=&quot;LC7&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC8&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kd&quot;&gt;static &lt;span class=&quot;nc&quot;&gt;Singleton &lt;span class=&quot;nf&quot;&gt;getUniqueInstance&lt;span class=&quot;o&quot;&gt;() &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC9&quot; class=&quot;line&quot;&gt;       &lt;span class=&quot;c1&quot;&gt;//先判断对象是否已经实例过，没有实例化过才进入加锁代码
&lt;span id=&quot;LC10&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;k&quot;&gt;if &lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;uniqueInstance &lt;span class=&quot;o&quot;&gt;== &lt;span class=&quot;kc&quot;&gt;null&lt;span class=&quot;o&quot;&gt;) &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC11&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;c1&quot;&gt;//类对象加锁
&lt;span id=&quot;LC12&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;kd&quot;&gt;synchronized &lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;nc&quot;&gt;Singleton&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;class&lt;span class=&quot;o&quot;&gt;) &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC13&quot; class=&quot;line&quot;&gt;                &lt;span class=&quot;k&quot;&gt;if &lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;uniqueInstance &lt;span class=&quot;o&quot;&gt;== &lt;span class=&quot;kc&quot;&gt;null&lt;span class=&quot;o&quot;&gt;) &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC14&quot; class=&quot;line&quot;&gt;                    &lt;span class=&quot;n&quot;&gt;uniqueInstance &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;nc&quot;&gt;Singleton&lt;span class=&quot;o&quot;&gt;();
&lt;span id=&quot;LC15&quot; class=&quot;line&quot;&gt;                &lt;span class=&quot;o&quot;&gt;}
&lt;span id=&quot;LC16&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;o&quot;&gt;}
&lt;span id=&quot;LC17&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;o&quot;&gt;}
&lt;span id=&quot;LC18&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;k&quot;&gt;return &lt;span class=&quot;n&quot;&gt;uniqueInstance&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC19&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;o&quot;&gt;}
&lt;span id=&quot;LC20&quot; class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。&lt;/p&gt;
&lt;p&gt;uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;为 uniqueInstance 分配内存空间&lt;/li&gt;
&lt;li&gt;初始化 uniqueInstance&lt;/li&gt;
&lt;li&gt;将 uniqueInstance 指向分配的内存地址&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&amp;gt;3-&amp;gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。&lt;/p&gt;
&lt;p&gt;使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。&lt;/p&gt;
&lt;h3&gt;1.3. 讲一下 synchronized 关键字的底层原理&lt;/h3&gt;
&lt;p&gt;synchronized 关键字底层原理属于 JVM 层面。&lt;/p&gt;
&lt;p&gt;① synchronized 同步语句块的情况&lt;/p&gt;
&lt;div class=&quot;white&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span id=&quot;LC1&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kd&quot;&gt;class &lt;span class=&quot;nc&quot;&gt;SynchronizedDemo &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC2&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kt&quot;&gt;void &lt;span class=&quot;nf&quot;&gt;method&lt;span class=&quot;o&quot;&gt;() &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC3&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;kd&quot;&gt;synchronized &lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;k&quot;&gt;this&lt;span class=&quot;o&quot;&gt;) &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC4&quot; class=&quot;line&quot;&gt;                    &lt;span class=&quot;nc&quot;&gt;System&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;out&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;println&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;s&quot;&gt;&quot;synchronized 代码块&quot;&lt;span class=&quot;o&quot;&gt;);
&lt;span id=&quot;LC5&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;o&quot;&gt;}
&lt;span id=&quot;LC6&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;o&quot;&gt;}
&lt;span id=&quot;LC7&quot; class=&quot;line&quot;&gt;}
&lt;span id=&quot;LC8&quot; class=&quot;line&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;通过 JDK 自带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：首先切换到类的对应目录执行 &lt;code&gt;javac SynchronizedDemo.java&lt;/code&gt; 命令生成编译后的 .class 文件，然后执行&lt;code&gt;javap -c -s -v -l SynchronizedDemo.class&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86.png&quot; alt=&quot;synchronized关键字原理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面我们可以看出：&lt;/p&gt;
&lt;p&gt;synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。&lt;/p&gt;
&lt;p&gt;② synchronized 修饰方法的的情况&lt;/p&gt;
&lt;div class=&quot;white&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span id=&quot;LC1&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kd&quot;&gt;class &lt;span class=&quot;nc&quot;&gt;SynchronizedDemo2 &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC2&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kd&quot;&gt;synchronized &lt;span class=&quot;kt&quot;&gt;void &lt;span class=&quot;nf&quot;&gt;method&lt;span class=&quot;o&quot;&gt;() &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC3&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;nc&quot;&gt;System&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;out&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;println&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;s&quot;&gt;&quot;synchronized 方法&quot;&lt;span class=&quot;o&quot;&gt;);
&lt;span id=&quot;LC4&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;o&quot;&gt;}
&lt;span id=&quot;LC5&quot; class=&quot;line&quot;&gt;}
&lt;span id=&quot;LC6&quot; class=&quot;line&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%862.png&quot; alt=&quot;synchronized关键字原理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。&lt;/p&gt;
&lt;h3&gt;1.4. 说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗&lt;/h3&gt;
&lt;p&gt;JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。&lt;/p&gt;
&lt;p&gt;锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。&lt;/p&gt;
&lt;p&gt;关于这几种优化的详细信息可以查看笔主的这篇文章：&lt;a href=&quot;https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/Multithread/synchronized.md&quot;&gt;https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/Multithread/synchronized.md&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;1.5. 谈谈 synchronized和ReentrantLock 的区别&lt;/h3&gt;
&lt;p&gt;① 两者都是可重入锁&lt;/p&gt;
&lt;p&gt;两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。&lt;/p&gt;
&lt;p&gt;② synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API&lt;/p&gt;
&lt;p&gt;synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。&lt;/p&gt;
&lt;p&gt;③ ReentrantLock 比 synchronized 增加了一些高级功能&lt;/p&gt;
&lt;p&gt;相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。&lt;/li&gt;
&lt;li&gt;ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。 ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的&lt;code&gt;ReentrantLock(boolean fair)&lt;/code&gt;构造方法来制定是否是公平的。&lt;/li&gt;
&lt;li&gt;synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果你想使用上述功能，那么选择ReentrantLock是一个不错的选择。&lt;/p&gt;
&lt;p&gt;④ 性能已不是选择标准&lt;/p&gt;
&lt;h2&gt;2. volatile关键字&lt;/h2&gt;
&lt;h3&gt;2.1. 讲一下Java内存模型&lt;/h3&gt;
&lt;p&gt;在 JDK1.2 之前，Java的内存模型实现总是从主存（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4.png&quot; alt=&quot;数据不一致&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要解决这个问题，就需要把变量声明为volatile，这就指示 JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。&lt;/p&gt;
&lt;p&gt;说白了， volatile 关键字的主要作用就是保证变量的可见性然后还有一个作用是防止指令重排序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7.png&quot; alt=&quot;volatile关键字的可见性&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.2. 说说 synchronized 关键字和 volatile 关键字的区别&lt;/h3&gt;
&lt;p&gt;synchronized关键字和volatile关键字比较&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。&lt;/li&gt;
&lt;li&gt;多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞&lt;/li&gt;
&lt;li&gt;volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。&lt;/li&gt;
&lt;li&gt;volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;3. ThreadLocal&lt;/h2&gt;
&lt;h3&gt;3.1. ThreadLocal简介&lt;/h3&gt;
&lt;p&gt;通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。如果想实现每一个线程都有自己的专属本地变量该如何解决呢？ JDK中提供的&lt;code&gt;ThreadLocal&lt;/code&gt;类正是为了解决这样的问题。 &lt;code&gt;ThreadLocal&lt;/code&gt;类主要解决的就是让每个线程绑定自己的值，可以将&lt;code&gt;ThreadLocal&lt;/code&gt;类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。&lt;/p&gt;
&lt;p&gt;如果你创建了一个&lt;code&gt;ThreadLocal&lt;/code&gt;变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是&lt;code&gt;ThreadLocal&lt;/code&gt;变量名的由来。他们可以使用 &lt;code&gt;get（）&lt;/code&gt; 和 &lt;code&gt;set（）&lt;/code&gt; 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。&lt;/p&gt;
&lt;p&gt;再举个简单的例子：&lt;/p&gt;
&lt;p&gt;比如有两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么ThreadLocal就是用来避免这两个线程竞争的。&lt;/p&gt;
&lt;h3&gt;3.2. ThreadLocal示例&lt;/h3&gt;
&lt;p&gt;相信看了上面的解释，大家已经搞懂 ThreadLocal 类是个什么东西了。&lt;/p&gt;
&lt;div class=&quot;white&quot; readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;span id=&quot;LC1&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import &lt;span class=&quot;nn&quot;&gt;java.text.SimpleDateFormat&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC2&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import &lt;span class=&quot;nn&quot;&gt;java.util.Random&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC3&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC4&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kd&quot;&gt;class &lt;span class=&quot;nc&quot;&gt;ThreadLocalExample &lt;span class=&quot;kd&quot;&gt;implements &lt;span class=&quot;nc&quot;&gt;Runnable&lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC5&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC6&quot; class=&quot;line&quot;&gt;     &lt;span class=&quot;c1&quot;&gt;// SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本
&lt;span id=&quot;LC7&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;private &lt;span class=&quot;kd&quot;&gt;static &lt;span class=&quot;kd&quot;&gt;final &lt;span class=&quot;nc&quot;&gt;ThreadLocal&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;span class=&quot;nc&quot;&gt;SimpleDateFormat&lt;span class=&quot;o&quot;&gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;formatter &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;nc&quot;&gt;ThreadLocal&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;withInitial&lt;span class=&quot;o&quot;&gt;(() &lt;span class=&quot;o&quot;&gt;-&amp;gt; &lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;nc&quot;&gt;SimpleDateFormat&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;s&quot;&gt;&quot;yyyyMMdd HHmm&quot;&lt;span class=&quot;o&quot;&gt;));
&lt;span id=&quot;LC8&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC9&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kd&quot;&gt;static &lt;span class=&quot;kt&quot;&gt;void &lt;span class=&quot;nf&quot;&gt;main&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;nc&quot;&gt;String&lt;span class=&quot;o&quot;&gt;[] &lt;span class=&quot;n&quot;&gt;args&lt;span class=&quot;o&quot;&gt;) &lt;span class=&quot;kd&quot;&gt;throws &lt;span class=&quot;nc&quot;&gt;InterruptedException &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC10&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;nc&quot;&gt;ThreadLocalExample &lt;span class=&quot;n&quot;&gt;obj &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;nc&quot;&gt;ThreadLocalExample&lt;span class=&quot;o&quot;&gt;();
&lt;span id=&quot;LC11&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;k&quot;&gt;for&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;kt&quot;&gt;int &lt;span class=&quot;n&quot;&gt;i&lt;span class=&quot;o&quot;&gt;=&lt;span class=&quot;mi&quot;&gt;0 &lt;span class=&quot;o&quot;&gt;; &lt;span class=&quot;n&quot;&gt;i&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;span class=&quot;mi&quot;&gt;10&lt;span class=&quot;o&quot;&gt;; &lt;span class=&quot;n&quot;&gt;i&lt;span class=&quot;o&quot;&gt;++){
&lt;span id=&quot;LC12&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;nc&quot;&gt;Thread &lt;span class=&quot;n&quot;&gt;t &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;nc&quot;&gt;Thread&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;obj&lt;span class=&quot;o&quot;&gt;, &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;span class=&quot;o&quot;&gt;+&lt;span class=&quot;n&quot;&gt;i&lt;span class=&quot;o&quot;&gt;);
&lt;span id=&quot;LC13&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;nc&quot;&gt;Thread&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;sleep&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;nc&quot;&gt;Random&lt;span class=&quot;o&quot;&gt;().&lt;span class=&quot;na&quot;&gt;nextInt&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;mi&quot;&gt;1000&lt;span class=&quot;o&quot;&gt;));
&lt;span id=&quot;LC14&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;n&quot;&gt;t&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;start&lt;span class=&quot;o&quot;&gt;();
&lt;span id=&quot;LC15&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;o&quot;&gt;}
&lt;span id=&quot;LC16&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;o&quot;&gt;}
&lt;span id=&quot;LC17&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC18&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;nd&quot;&gt;@Override
&lt;span id=&quot;LC19&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kt&quot;&gt;void &lt;span class=&quot;nf&quot;&gt;run&lt;span class=&quot;o&quot;&gt;() &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC20&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;nc&quot;&gt;System&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;out&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;println&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;s&quot;&gt;&quot;Thread Name= &quot;&lt;span class=&quot;o&quot;&gt;+&lt;span class=&quot;nc&quot;&gt;Thread&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;currentThread&lt;span class=&quot;o&quot;&gt;().&lt;span class=&quot;na&quot;&gt;getName&lt;span class=&quot;o&quot;&gt;()+&lt;span class=&quot;s&quot;&gt;&quot; default Formatter = &quot;&lt;span class=&quot;o&quot;&gt;+&lt;span class=&quot;n&quot;&gt;formatter&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;get&lt;span class=&quot;o&quot;&gt;().&lt;span class=&quot;na&quot;&gt;toPattern&lt;span class=&quot;o&quot;&gt;());
&lt;span id=&quot;LC21&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;k&quot;&gt;try &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC22&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;nc&quot;&gt;Thread&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;sleep&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;nc&quot;&gt;Random&lt;span class=&quot;o&quot;&gt;().&lt;span class=&quot;na&quot;&gt;nextInt&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;mi&quot;&gt;1000&lt;span class=&quot;o&quot;&gt;));
&lt;span id=&quot;LC23&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;o&quot;&gt;} &lt;span class=&quot;k&quot;&gt;catch &lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;nc&quot;&gt;InterruptedException &lt;span class=&quot;n&quot;&gt;e&lt;span class=&quot;o&quot;&gt;) &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC24&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;n&quot;&gt;e&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;printStackTrace&lt;span class=&quot;o&quot;&gt;();
&lt;span id=&quot;LC25&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;o&quot;&gt;}
&lt;span id=&quot;LC26&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;c1&quot;&gt;//formatter pattern is changed here by thread, but it won't reflect to other threads
&lt;span id=&quot;LC27&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;n&quot;&gt;formatter&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;set&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;nc&quot;&gt;SimpleDateFormat&lt;span class=&quot;o&quot;&gt;());
&lt;span id=&quot;LC28&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC29&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;nc&quot;&gt;System&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;out&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;println&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;s&quot;&gt;&quot;Thread Name= &quot;&lt;span class=&quot;o&quot;&gt;+&lt;span class=&quot;nc&quot;&gt;Thread&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;currentThread&lt;span class=&quot;o&quot;&gt;().&lt;span class=&quot;na&quot;&gt;getName&lt;span class=&quot;o&quot;&gt;()+&lt;span class=&quot;s&quot;&gt;&quot; formatter = &quot;&lt;span class=&quot;o&quot;&gt;+&lt;span class=&quot;n&quot;&gt;formatter&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;get&lt;span class=&quot;o&quot;&gt;().&lt;span class=&quot;na&quot;&gt;toPattern&lt;span class=&quot;o&quot;&gt;());
&lt;span id=&quot;LC30&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;o&quot;&gt;}
&lt;span id=&quot;LC31&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC32&quot; class=&quot;line&quot;&gt;}
&lt;span id=&quot;LC33&quot; class=&quot;line&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;div class=&quot;white&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span id=&quot;LC1&quot; class=&quot;line&quot;&gt;Thread Name= 0 default Formatter = yyyyMMdd HHmm
&lt;span id=&quot;LC2&quot; class=&quot;line&quot;&gt;Thread Name= 0 formatter = yy-M-d ah:mm
&lt;span id=&quot;LC3&quot; class=&quot;line&quot;&gt;Thread Name= 1 default Formatter = yyyyMMdd HHmm
&lt;span id=&quot;LC4&quot; class=&quot;line&quot;&gt;Thread Name= 2 default Formatter = yyyyMMdd HHmm
&lt;span id=&quot;LC5&quot; class=&quot;line&quot;&gt;Thread Name= 1 formatter = yy-M-d ah:mm
&lt;span id=&quot;LC6&quot; class=&quot;line&quot;&gt;Thread Name= 3 default Formatter = yyyyMMdd HHmm
&lt;span id=&quot;LC7&quot; class=&quot;line&quot;&gt;Thread Name= 2 formatter = yy-M-d ah:mm
&lt;span id=&quot;LC8&quot; class=&quot;line&quot;&gt;Thread Name= 4 default Formatter = yyyyMMdd HHmm
&lt;span id=&quot;LC9&quot; class=&quot;line&quot;&gt;Thread Name= 3 formatter = yy-M-d ah:mm
&lt;span id=&quot;LC10&quot; class=&quot;line&quot;&gt;Thread Name= 4 formatter = yy-M-d ah:mm
&lt;span id=&quot;LC11&quot; class=&quot;line&quot;&gt;Thread Name= 5 default Formatter = yyyyMMdd HHmm
&lt;span id=&quot;LC12&quot; class=&quot;line&quot;&gt;Thread Name= 5 formatter = yy-M-d ah:mm
&lt;span id=&quot;LC13&quot; class=&quot;line&quot;&gt;Thread Name= 6 default Formatter = yyyyMMdd HHmm
&lt;span id=&quot;LC14&quot; class=&quot;line&quot;&gt;Thread Name= 6 formatter = yy-M-d ah:mm
&lt;span id=&quot;LC15&quot; class=&quot;line&quot;&gt;Thread Name= 7 default Formatter = yyyyMMdd HHmm
&lt;span id=&quot;LC16&quot; class=&quot;line&quot;&gt;Thread Name= 7 formatter = yy-M-d ah:mm
&lt;span id=&quot;LC17&quot; class=&quot;line&quot;&gt;Thread Name= 8 default Formatter = yyyyMMdd HHmm
&lt;span id=&quot;LC18&quot; class=&quot;line&quot;&gt;Thread Name= 9 default Formatter = yyyyMMdd HHmm
&lt;span id=&quot;LC19&quot; class=&quot;line&quot;&gt;Thread Name= 8 formatter = yy-M-d ah:mm
&lt;span id=&quot;LC20&quot; class=&quot;line&quot;&gt;Thread Name= 9 formatter = yy-M-d ah:mm&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;从输出中可以看出，Thread-0已经改变了formatter的值，但仍然是thread-2默认格式化程序与初始化值相同，其他线程也一样。&lt;/p&gt;
&lt;p&gt;上面有一段代码用到了创建 &lt;code&gt;ThreadLocal&lt;/code&gt; 变量的那段代码用到了 Java8 的知识，它等于下面这段代码，如果你写了下面这段代码的话，IDEA会提示你转换为Java8的格式(IDEA真的不错！)。因为ThreadLocal类在Java 8中扩展，使用一个新的方法&lt;code&gt;withInitial()&lt;/code&gt;，将Supplier功能接口作为参数。&lt;/p&gt;
&lt;div class=&quot;white&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span id=&quot;LC1&quot; class=&quot;line&quot;&gt; &lt;span class=&quot;kd&quot;&gt;private &lt;span class=&quot;kd&quot;&gt;static &lt;span class=&quot;kd&quot;&gt;final &lt;span class=&quot;nc&quot;&gt;ThreadLocal&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;span class=&quot;nc&quot;&gt;SimpleDateFormat&lt;span class=&quot;o&quot;&gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;formatter &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;nc&quot;&gt;ThreadLocal&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;span class=&quot;nc&quot;&gt;SimpleDateFormat&lt;span class=&quot;o&quot;&gt;&amp;gt;(){
&lt;span id=&quot;LC2&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;nd&quot;&gt;@Override
&lt;span id=&quot;LC3&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;kd&quot;&gt;protected &lt;span class=&quot;nc&quot;&gt;SimpleDateFormat &lt;span class=&quot;nf&quot;&gt;initialValue&lt;span class=&quot;o&quot;&gt;()
&lt;span id=&quot;LC4&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC5&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;k&quot;&gt;return &lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;nf&quot;&gt;SimpleDateFormat&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;s&quot;&gt;&quot;yyyyMMdd HHmm&quot;&lt;span class=&quot;o&quot;&gt;);
&lt;span id=&quot;LC6&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;o&quot;&gt;}
&lt;span id=&quot;LC7&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;3.3. ThreadLocal原理&lt;/h3&gt;
&lt;p&gt;从 &lt;code&gt;Thread&lt;/code&gt;类源代码入手。&lt;/p&gt;
&lt;div class=&quot;white&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span id=&quot;LC1&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kd&quot;&gt;class &lt;span class=&quot;nc&quot;&gt;Thread &lt;span class=&quot;kd&quot;&gt;implements &lt;span class=&quot;nc&quot;&gt;Runnable &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC2&quot; class=&quot;line&quot;&gt; &lt;span class=&quot;o&quot;&gt;......
&lt;span id=&quot;LC3&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//与此线程有关的ThreadLocal值。由ThreadLocal类维护
&lt;span id=&quot;LC4&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;nc&quot;&gt;ThreadLocal&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;ThreadLocalMap &lt;span class=&quot;n&quot;&gt;threadLocals &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;kc&quot;&gt;null&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC5&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC6&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护
&lt;span id=&quot;LC7&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;nc&quot;&gt;ThreadLocal&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;ThreadLocalMap &lt;span class=&quot;n&quot;&gt;inheritableThreadLocals &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;kc&quot;&gt;null&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC8&quot; class=&quot;line&quot;&gt; &lt;span class=&quot;o&quot;&gt;......
&lt;span id=&quot;LC9&quot; class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;从上面&lt;code&gt;Thread&lt;/code&gt;类 源代码可以看出&lt;code&gt;Thread&lt;/code&gt; 类中有一个 &lt;code&gt;threadLocals&lt;/code&gt; 和 一个 &lt;code&gt;inheritableThreadLocals&lt;/code&gt; 变量，它们都是 &lt;code&gt;ThreadLocalMap&lt;/code&gt; 类型的变量,我们可以把 &lt;code&gt;ThreadLocalMap&lt;/code&gt; 理解为&lt;code&gt;ThreadLocal&lt;/code&gt; 类实现的定制化的 &lt;code&gt;HashMap&lt;/code&gt;。默认情况下这两个变量都是null，只有当前线程调用 &lt;code&gt;ThreadLocal&lt;/code&gt; 类的 &lt;code&gt;set&lt;/code&gt;或&lt;code&gt;get&lt;/code&gt;方法时才创建它们，实际上调用这两个方法的时候，我们调用的是&lt;code&gt;ThreadLocalMap&lt;/code&gt;类对应的 &lt;code&gt;get()&lt;/code&gt;、&lt;code&gt;set() &lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;类的&lt;code&gt;set()&lt;/code&gt;方法&lt;/p&gt;
&lt;div class=&quot;white&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span id=&quot;LC1&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kt&quot;&gt;void &lt;span class=&quot;nf&quot;&gt;set&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;no&quot;&gt;T &lt;span class=&quot;n&quot;&gt;value&lt;span class=&quot;o&quot;&gt;) &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC2&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;nc&quot;&gt;Thread &lt;span class=&quot;n&quot;&gt;t &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;nc&quot;&gt;Thread&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;currentThread&lt;span class=&quot;o&quot;&gt;();
&lt;span id=&quot;LC3&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;nc&quot;&gt;ThreadLocalMap &lt;span class=&quot;n&quot;&gt;map &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;n&quot;&gt;getMap&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;t&lt;span class=&quot;o&quot;&gt;);
&lt;span id=&quot;LC4&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;k&quot;&gt;if &lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;map &lt;span class=&quot;o&quot;&gt;!= &lt;span class=&quot;kc&quot;&gt;null&lt;span class=&quot;o&quot;&gt;)
&lt;span id=&quot;LC5&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;n&quot;&gt;map&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;set&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;k&quot;&gt;this&lt;span class=&quot;o&quot;&gt;, &lt;span class=&quot;n&quot;&gt;value&lt;span class=&quot;o&quot;&gt;);
&lt;span id=&quot;LC6&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;k&quot;&gt;else
&lt;span id=&quot;LC7&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;nf&quot;&gt;createMap&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;t&lt;span class=&quot;o&quot;&gt;, &lt;span class=&quot;n&quot;&gt;value&lt;span class=&quot;o&quot;&gt;);
&lt;span id=&quot;LC8&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;o&quot;&gt;}
&lt;span id=&quot;LC9&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;nc&quot;&gt;ThreadLocalMap &lt;span class=&quot;nf&quot;&gt;getMap&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;nc&quot;&gt;Thread &lt;span class=&quot;n&quot;&gt;t&lt;span class=&quot;o&quot;&gt;) &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC10&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;k&quot;&gt;return &lt;span class=&quot;n&quot;&gt;t&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;threadLocals&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC11&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;通过上面这些内容，我们足以通过猜测得出结论：最终的变量是放在了当前线程的 &lt;code&gt;ThreadLocalMap&lt;/code&gt; 中，并不是存在 &lt;code&gt;ThreadLocal&lt;/code&gt; 上，&lt;code&gt;ThreadLocal&lt;/code&gt; 可以理解为只是&lt;code&gt;ThreadLocalMap&lt;/code&gt;的封装，传递了变量值。 &lt;code&gt;ThrealLocal&lt;/code&gt; 类中可以通过&lt;code&gt;Thread.currentThread()&lt;/code&gt;获取到当前线程对象后，直接通过&lt;code&gt;getMap(Thread t)&lt;/code&gt;可以访问到该线程的&lt;code&gt;ThreadLocalMap&lt;/code&gt;对象。&lt;/p&gt;
&lt;p&gt;每个&lt;code&gt;Thread&lt;/code&gt;中都具备一个&lt;code&gt;ThreadLocalMap&lt;/code&gt;，而&lt;code&gt;ThreadLocalMap&lt;/code&gt;可以存储以&lt;code&gt;ThreadLocal&lt;/code&gt;为key的键值对。 比如我们在同一个线程中声明了两个 &lt;code&gt;ThreadLocal&lt;/code&gt; 对象的话，会使用 &lt;code&gt;Thread&lt;/code&gt;内部都是使用仅有那个&lt;code&gt;ThreadLocalMap&lt;/code&gt; 存放数据的，&lt;code&gt;ThreadLocalMap&lt;/code&gt;的 key 就是 &lt;code&gt;ThreadLocal&lt;/code&gt;对象，value 就是 &lt;code&gt;ThreadLocal&lt;/code&gt; 对象调用&lt;code&gt;set&lt;/code&gt;方法设置的值。&lt;code&gt;ThreadLocal&lt;/code&gt; 是 map结构是为了让每个线程可以关联多个 &lt;code&gt;ThreadLocal&lt;/code&gt;变量。这也就解释了 ThreadLocal 声明的变量为什么在每一个线程都有自己的专属本地变量。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ThreadLocalMap&lt;/code&gt;是&lt;code&gt;ThreadLocal&lt;/code&gt;的静态内部类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/ThreadLocal%E5%86%85%E9%83%A8%E7%B1%BB.png&quot; alt=&quot;ThreadLocal内部类&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.4. ThreadLocal 内存泄露问题&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ThreadLocalMap&lt;/code&gt; 中使用的 key 为 &lt;code&gt;ThreadLocal&lt;/code&gt; 的弱引用,而 value 是强引用。所以，如果 &lt;code&gt;ThreadLocal&lt;/code&gt; 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，&lt;code&gt;ThreadLocalMap&lt;/code&gt; 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 &lt;code&gt;set()&lt;/code&gt;、&lt;code&gt;get()&lt;/code&gt;、&lt;code&gt;remove()&lt;/code&gt; 方法的时候，会清理掉 key 为 null 的记录。使用完 &lt;code&gt;ThreadLocal&lt;/code&gt;方法后 最好手动调用&lt;code&gt;remove()&lt;/code&gt;方法&lt;/p&gt;
&lt;div class=&quot;white&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span id=&quot;LC1&quot; class=&quot;line&quot;&gt;      &lt;span class=&quot;kd&quot;&gt;static &lt;span class=&quot;kd&quot;&gt;class &lt;span class=&quot;nc&quot;&gt;Entry &lt;span class=&quot;kd&quot;&gt;extends &lt;span class=&quot;nc&quot;&gt;WeakReference&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;span class=&quot;nc&quot;&gt;ThreadLocal&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&amp;gt; &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC2&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;cm&quot;&gt;/** The value associated with this ThreadLocal. */
&lt;span id=&quot;LC3&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;nc&quot;&gt;Object &lt;span class=&quot;n&quot;&gt;value&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC4&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC5&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;nc&quot;&gt;Entry&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;nc&quot;&gt;ThreadLocal&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt; &lt;span class=&quot;n&quot;&gt;k&lt;span class=&quot;o&quot;&gt;, &lt;span class=&quot;nc&quot;&gt;Object &lt;span class=&quot;n&quot;&gt;v&lt;span class=&quot;o&quot;&gt;) &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC6&quot; class=&quot;line&quot;&gt;                &lt;span class=&quot;kd&quot;&gt;super&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;k&lt;span class=&quot;o&quot;&gt;);
&lt;span id=&quot;LC7&quot; class=&quot;line&quot;&gt;                &lt;span class=&quot;n&quot;&gt;value &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;n&quot;&gt;v&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC8&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;o&quot;&gt;}
&lt;span id=&quot;LC9&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;弱引用介绍：&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。&lt;/p&gt;
&lt;p&gt;弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;4. 线程池&lt;/h2&gt;
&lt;h3&gt;4.1. 为什么要用线程池？&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;池化技术相比大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。&lt;/p&gt;
&lt;p&gt;这里借用《Java 并发编程的艺术》提到的来说一下使用线程池的好处：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。&lt;/li&gt;
&lt;li&gt;提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。&lt;/li&gt;
&lt;li&gt;提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;4.2. 实现Runnable接口和Callable接口的区别&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Runnable&lt;/code&gt;自Java 1.0以来一直存在，但&lt;code&gt;Callable&lt;/code&gt;仅在Java 1.5中引入,目的就是为了来处理&lt;code&gt;Runnable&lt;/code&gt;不支持的用例。&lt;code&gt;Runnable&lt;/code&gt; 接口不会返回结果或抛出检查异常，但是**&lt;code&gt;Callable&lt;/code&gt; 接口**可以。所以，如果任务不需要返回结果或抛出异常推荐使用 &lt;code&gt;Runnable&lt;/code&gt; 接口，这样代码看起来会更加简洁。&lt;/p&gt;
&lt;p&gt;工具类 &lt;code&gt;Executors&lt;/code&gt; 可以实现 &lt;code&gt;Runnable&lt;/code&gt; 对象和 &lt;code&gt;Callable&lt;/code&gt; 对象之间的相互转换。（&lt;code&gt;Executors.callable（Runnable task&lt;/code&gt;）或 &lt;code&gt;Executors.callable（Runnable task，Object resule）&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Runnable.java&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;white&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span id=&quot;LC1&quot; class=&quot;line&quot;&gt;@FunctionalInterface
&lt;span id=&quot;LC2&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kd&quot;&gt;interface &lt;span class=&quot;nc&quot;&gt;Runnable &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC3&quot; class=&quot;line&quot;&gt;   &lt;span class=&quot;cm&quot;&gt;/**
&lt;span id=&quot;LC4&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;cm&quot;&gt;    * 被线程执行，没有返回值也无法抛出异常
&lt;span id=&quot;LC5&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;cm&quot;&gt;    */
&lt;span id=&quot;LC6&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kd&quot;&gt;abstract &lt;span class=&quot;kt&quot;&gt;void &lt;span class=&quot;nf&quot;&gt;run&lt;span class=&quot;o&quot;&gt;();
&lt;span id=&quot;LC7&quot; class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Callable.java&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;white&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span id=&quot;LC1&quot; class=&quot;line&quot;&gt;@FunctionalInterface
&lt;span id=&quot;LC2&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kd&quot;&gt;interface &lt;span class=&quot;nc&quot;&gt;Callable&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;span class=&quot;no&quot;&gt;V&lt;span class=&quot;o&quot;&gt;&amp;gt; &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC3&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;cm&quot;&gt;/**
&lt;span id=&quot;LC4&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;cm&quot;&gt;     * 计算结果，或在无法这样做时抛出异常。
&lt;span id=&quot;LC5&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;cm&quot;&gt;     * @return 计算得出的结果
&lt;span id=&quot;LC6&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;cm&quot;&gt;     * @throws 如果无法计算结果，则抛出异常
&lt;span id=&quot;LC7&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;cm&quot;&gt;     */
&lt;span id=&quot;LC8&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;no&quot;&gt;V &lt;span class=&quot;nf&quot;&gt;call&lt;span class=&quot;o&quot;&gt;() &lt;span class=&quot;kd&quot;&gt;throws &lt;span class=&quot;nc&quot;&gt;Exception&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC9&quot; class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;4.3. 执行execute()方法和submit()方法的区别是什么呢？&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;execute()&lt;/code&gt;方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;submit()&lt;/code&gt;方法用于提交需要返回值的任务。线程池会返回一个 &lt;code&gt;Future&lt;/code&gt; 类型的对象，通过这个 &lt;code&gt;Future&lt;/code&gt; 对象可以判断任务是否执行成功，并且可以通过 &lt;code&gt;Future&lt;/code&gt; 的 &lt;code&gt;get()&lt;/code&gt;方法来获取返回值，&lt;code&gt;get()&lt;/code&gt;方法会阻塞当前线程直到任务完成，而使用 &lt;code&gt;get（long timeout，TimeUnit unit）&lt;/code&gt;方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们以**&lt;code&gt;AbstractExecutorService&lt;/code&gt;**接口中的一个 &lt;code&gt;submit&lt;/code&gt; 方法为例子来看看源代码：&lt;/p&gt;
&lt;div class=&quot;white&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span id=&quot;LC1&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;nc&quot;&gt;Future&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt; &lt;span class=&quot;n&quot;&gt;submit&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;nc&quot;&gt;Runnable &lt;span class=&quot;n&quot;&gt;task&lt;span class=&quot;o&quot;&gt;) &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC2&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;k&quot;&gt;if &lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;task &lt;span class=&quot;o&quot;&gt;== &lt;span class=&quot;kc&quot;&gt;null&lt;span class=&quot;o&quot;&gt;) &lt;span class=&quot;k&quot;&gt;throw &lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;nc&quot;&gt;NullPointerException&lt;span class=&quot;o&quot;&gt;();
&lt;span id=&quot;LC3&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;nc&quot;&gt;RunnableFuture&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;span class=&quot;nc&quot;&gt;Void&lt;span class=&quot;o&quot;&gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;ftask &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;n&quot;&gt;newTaskFor&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;task&lt;span class=&quot;o&quot;&gt;, &lt;span class=&quot;kc&quot;&gt;null&lt;span class=&quot;o&quot;&gt;);
&lt;span id=&quot;LC4&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;n&quot;&gt;execute&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;ftask&lt;span class=&quot;o&quot;&gt;);
&lt;span id=&quot;LC5&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;k&quot;&gt;return &lt;span class=&quot;n&quot;&gt;ftask&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC6&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;上面方法调用的 &lt;code&gt;newTaskFor&lt;/code&gt; 方法返回了一个 &lt;code&gt;FutureTask&lt;/code&gt; 对象。&lt;/p&gt;
&lt;div class=&quot;white&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span id=&quot;LC1&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;protected &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;span class=&quot;no&quot;&gt;T&lt;span class=&quot;o&quot;&gt;&amp;gt; &lt;span class=&quot;nc&quot;&gt;RunnableFuture&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;span class=&quot;no&quot;&gt;T&lt;span class=&quot;o&quot;&gt;&amp;gt; &lt;span class=&quot;nf&quot;&gt;newTaskFor&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;nc&quot;&gt;Runnable &lt;span class=&quot;n&quot;&gt;runnable&lt;span class=&quot;o&quot;&gt;, &lt;span class=&quot;no&quot;&gt;T &lt;span class=&quot;n&quot;&gt;value&lt;span class=&quot;o&quot;&gt;) &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC2&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;k&quot;&gt;return &lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;nc&quot;&gt;FutureTask&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;span class=&quot;no&quot;&gt;T&lt;span class=&quot;o&quot;&gt;&amp;gt;(&lt;span class=&quot;n&quot;&gt;runnable&lt;span class=&quot;o&quot;&gt;, &lt;span class=&quot;n&quot;&gt;value&lt;span class=&quot;o&quot;&gt;);
&lt;span id=&quot;LC3&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;我们再来看看&lt;code&gt;execute()&lt;/code&gt;方法：&lt;/p&gt;
&lt;div class=&quot;white&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span id=&quot;LC1&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kt&quot;&gt;void &lt;span class=&quot;nf&quot;&gt;execute&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;nc&quot;&gt;Runnable &lt;span class=&quot;n&quot;&gt;command&lt;span class=&quot;o&quot;&gt;) &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC2&quot; class=&quot;line&quot;&gt;      &lt;span class=&quot;o&quot;&gt;...
&lt;span id=&quot;LC3&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;4.4. 如何创建线程池&lt;/h3&gt;
&lt;p&gt;《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Executors 返回线程池对象的弊端如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致OOM。&lt;/li&gt;
&lt;li&gt;CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;方式一：通过构造方法实现 &lt;img src=&quot;https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/ThreadPoolExecutor%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95.png&quot; alt=&quot;ThreadPoolExecutor构造方法&quot;/&gt; 方式二：通过Executor 框架的工具类Executors来实现 我们可以创建三种类型的ThreadPoolExecutor：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FixedThreadPool ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。&lt;/li&gt;
&lt;li&gt;SingleThreadExecutor： 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。&lt;/li&gt;
&lt;li&gt;CachedThreadPool： 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对应Executors工具类中的方法如图所示： &lt;img src=&quot;https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/Executor%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB.png&quot; alt=&quot;Executor框架的工具类&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4.5 ThreadPoolExecutor 类分析&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 类中提供的四个构造方法。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生（其他几个构造方法说白点都是给定某些默认参数的构造方法比如默认制定拒绝策略是什么），这里就不贴代码讲了，比较简单。&lt;/p&gt;
&lt;div class=&quot;white&quot; readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;16&quot;&gt;
&lt;pre&gt;
&lt;span id=&quot;LC1&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;cm&quot;&gt;/**
&lt;span id=&quot;LC2&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;cm&quot;&gt;     * 用给定的初始参数创建一个新的ThreadPoolExecutor。
&lt;span id=&quot;LC3&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;cm&quot;&gt;     */
&lt;span id=&quot;LC4&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;nf&quot;&gt;ThreadPoolExecutor&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;kt&quot;&gt;int &lt;span class=&quot;n&quot;&gt;corePoolSize&lt;span class=&quot;o&quot;&gt;,
&lt;span id=&quot;LC5&quot; class=&quot;line&quot;&gt;                              &lt;span class=&quot;kt&quot;&gt;int &lt;span class=&quot;n&quot;&gt;maximumPoolSize&lt;span class=&quot;o&quot;&gt;,
&lt;span id=&quot;LC6&quot; class=&quot;line&quot;&gt;                              &lt;span class=&quot;kt&quot;&gt;long &lt;span class=&quot;n&quot;&gt;keepAliveTime&lt;span class=&quot;o&quot;&gt;,
&lt;span id=&quot;LC7&quot; class=&quot;line&quot;&gt;                              &lt;span class=&quot;nc&quot;&gt;TimeUnit &lt;span class=&quot;n&quot;&gt;unit&lt;span class=&quot;o&quot;&gt;,
&lt;span id=&quot;LC8&quot; class=&quot;line&quot;&gt;                              &lt;span class=&quot;nc&quot;&gt;BlockingQueue&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;span class=&quot;nc&quot;&gt;Runnable&lt;span class=&quot;o&quot;&gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;workQueue&lt;span class=&quot;o&quot;&gt;,
&lt;span id=&quot;LC9&quot; class=&quot;line&quot;&gt;                              &lt;span class=&quot;nc&quot;&gt;ThreadFactory &lt;span class=&quot;n&quot;&gt;threadFactory&lt;span class=&quot;o&quot;&gt;,
&lt;span id=&quot;LC10&quot; class=&quot;line&quot;&gt;                              &lt;span class=&quot;nc&quot;&gt;RejectedExecutionHandler &lt;span class=&quot;n&quot;&gt;handler&lt;span class=&quot;o&quot;&gt;) &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC11&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;k&quot;&gt;if &lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;corePoolSize &lt;span class=&quot;o&quot;&gt;&amp;lt; &lt;span class=&quot;mi&quot;&gt;0 &lt;span class=&quot;o&quot;&gt;||
&lt;span id=&quot;LC12&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;n&quot;&gt;maximumPoolSize &lt;span class=&quot;o&quot;&gt;&amp;lt;= &lt;span class=&quot;mi&quot;&gt;0 &lt;span class=&quot;o&quot;&gt;||
&lt;span id=&quot;LC13&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;n&quot;&gt;maximumPoolSize &lt;span class=&quot;o&quot;&gt;&amp;lt; &lt;span class=&quot;n&quot;&gt;corePoolSize &lt;span class=&quot;o&quot;&gt;||
&lt;span id=&quot;LC14&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;n&quot;&gt;keepAliveTime &lt;span class=&quot;o&quot;&gt;&amp;lt; &lt;span class=&quot;mi&quot;&gt;0&lt;span class=&quot;o&quot;&gt;)
&lt;span id=&quot;LC15&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;k&quot;&gt;throw &lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;nf&quot;&gt;IllegalArgumentException&lt;span class=&quot;o&quot;&gt;();
&lt;span id=&quot;LC16&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;k&quot;&gt;if &lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;workQueue &lt;span class=&quot;o&quot;&gt;== &lt;span class=&quot;kc&quot;&gt;null &lt;span class=&quot;o&quot;&gt;|| &lt;span class=&quot;n&quot;&gt;threadFactory &lt;span class=&quot;o&quot;&gt;== &lt;span class=&quot;kc&quot;&gt;null &lt;span class=&quot;o&quot;&gt;|| &lt;span class=&quot;n&quot;&gt;handler &lt;span class=&quot;o&quot;&gt;== &lt;span class=&quot;kc&quot;&gt;null&lt;span class=&quot;o&quot;&gt;)
&lt;span id=&quot;LC17&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;k&quot;&gt;throw &lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;nf&quot;&gt;NullPointerException&lt;span class=&quot;o&quot;&gt;();
&lt;span id=&quot;LC18&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;k&quot;&gt;this&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;corePoolSize &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;n&quot;&gt;corePoolSize&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC19&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;k&quot;&gt;this&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;maximumPoolSize &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;n&quot;&gt;maximumPoolSize&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC20&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;k&quot;&gt;this&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;workQueue &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;n&quot;&gt;workQueue&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC21&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;k&quot;&gt;this&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;keepAliveTime &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;n&quot;&gt;unit&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;toNanos&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;keepAliveTime&lt;span class=&quot;o&quot;&gt;);
&lt;span id=&quot;LC22&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;k&quot;&gt;this&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;threadFactory &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;n&quot;&gt;threadFactory&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC23&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;k&quot;&gt;this&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;handler &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;n&quot;&gt;handler&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC24&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;下面这些对创建 非常重要，在后面使用线程池的过程中你一定会用到！所以，务必拿着小本本记清楚。&lt;/p&gt;
&lt;h4&gt;4.5.1 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt;构造函数重要参数分析&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 3 个最重要的参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;corePoolSize&lt;/code&gt; : 核心线程数线程数定义了最小可以同时运行的线程数量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;maximumPoolSize&lt;/code&gt; : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;workQueue&lt;/code&gt;: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;其他常见参数:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;keepAliveTime&lt;/code&gt;:当线程池中的线程数量大于 &lt;code&gt;corePoolSize&lt;/code&gt; 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 &lt;code&gt;keepAliveTime&lt;/code&gt;才会被回收销毁；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unit&lt;/code&gt; : &lt;code&gt;keepAliveTime&lt;/code&gt; 参数的时间单位。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;threadFactory&lt;/code&gt; :executor 创建新线程的时候会用到。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;handler&lt;/code&gt; :饱和策略。关于饱和策略下面单独介绍一下。&lt;/li&gt;
&lt;/ol&gt;&lt;h4&gt;4.5.2 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 饱和策略&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 饱和策略定义:&lt;/p&gt;
&lt;p&gt;如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任时，&lt;code&gt;ThreadPoolTaskExecutor&lt;/code&gt; 定义一些策略:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ThreadPoolExecutor.AbortPolicy&lt;/code&gt;：抛出 &lt;code&gt;RejectedExecutionException&lt;/code&gt;来拒绝新任务的处理。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ThreadPoolExecutor.CallerRunsPolicy&lt;/code&gt;：调用执行自己的线程运行任务。您不会任务请求。但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ThreadPoolExecutor.DiscardPolicy&lt;/code&gt;： 不处理新任务，直接丢弃掉。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ThreadPoolExecutor.DiscardOldestPolicy&lt;/code&gt;： 此策略将丢弃最早的未处理的任务请求。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举个例子： Spring 通过 &lt;code&gt;ThreadPoolTaskExecutor&lt;/code&gt; 或者我们直接通过 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 的构造函数创建线程池的时候，当我们不指定 &lt;code&gt;RejectedExecutionHandler&lt;/code&gt; 饱和策略的话来配置线程池的时候默认使用的是 &lt;code&gt;ThreadPoolExecutor.AbortPolicy&lt;/code&gt;。在默认情况下，&lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 将抛出 &lt;code&gt;RejectedExecutionException&lt;/code&gt; 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 &lt;code&gt;ThreadPoolExecutor.CallerRunsPolicy&lt;/code&gt;。当最大池被填满时，此策略为我们提供可伸缩队列。（这个直接查看 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 的构造函数源码就可以看出，比较简单的原因，这里就不贴代码了）&lt;/p&gt;
&lt;h3&gt;4.6 一个简单的线程池Demo:&lt;code&gt;Runnable&lt;/code&gt;+&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;为了让大家更清楚上面的面试题中的一些概念，我写了一个简单的线程池 Demo。&lt;/p&gt;
&lt;p&gt;首先创建一个 &lt;code&gt;Runnable&lt;/code&gt; 接口的实现类（当然也可以是 &lt;code&gt;Callable&lt;/code&gt; 接口，我们上面也说了两者的区别。）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MyRunnable.java&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;white&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span id=&quot;LC1&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import &lt;span class=&quot;nn&quot;&gt;java.util.Date&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC2&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC3&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;cm&quot;&gt;/**
&lt;span id=&quot;LC4&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;cm&quot;&gt; * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。
&lt;span id=&quot;LC5&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;cm&quot;&gt; * @author shuang.kou
&lt;span id=&quot;LC6&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;cm&quot;&gt; */
&lt;span id=&quot;LC7&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kd&quot;&gt;class &lt;span class=&quot;nc&quot;&gt;MyRunnable &lt;span class=&quot;kd&quot;&gt;implements &lt;span class=&quot;nc&quot;&gt;Runnable &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC8&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC9&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;private &lt;span class=&quot;nc&quot;&gt;String &lt;span class=&quot;n&quot;&gt;command&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC10&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC11&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;nf&quot;&gt;MyRunnable&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;nc&quot;&gt;String &lt;span class=&quot;n&quot;&gt;s&lt;span class=&quot;o&quot;&gt;) &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC12&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;k&quot;&gt;this&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;command &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;n&quot;&gt;s&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC13&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;o&quot;&gt;}
&lt;span id=&quot;LC14&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC15&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;nd&quot;&gt;@Override
&lt;span id=&quot;LC16&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kt&quot;&gt;void &lt;span class=&quot;nf&quot;&gt;run&lt;span class=&quot;o&quot;&gt;() &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC17&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;nc&quot;&gt;System&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;out&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;println&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;nc&quot;&gt;Thread&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;currentThread&lt;span class=&quot;o&quot;&gt;().&lt;span class=&quot;na&quot;&gt;getName&lt;span class=&quot;o&quot;&gt;() &lt;span class=&quot;o&quot;&gt;+ &lt;span class=&quot;s&quot;&gt;&quot; Start. Time = &quot; &lt;span class=&quot;o&quot;&gt;+ &lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;nc&quot;&gt;Date&lt;span class=&quot;o&quot;&gt;());
&lt;span id=&quot;LC18&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;n&quot;&gt;processCommand&lt;span class=&quot;o&quot;&gt;();
&lt;span id=&quot;LC19&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;nc&quot;&gt;System&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;out&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;println&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;nc&quot;&gt;Thread&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;currentThread&lt;span class=&quot;o&quot;&gt;().&lt;span class=&quot;na&quot;&gt;getName&lt;span class=&quot;o&quot;&gt;() &lt;span class=&quot;o&quot;&gt;+ &lt;span class=&quot;s&quot;&gt;&quot; End. Time = &quot; &lt;span class=&quot;o&quot;&gt;+ &lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;nc&quot;&gt;Date&lt;span class=&quot;o&quot;&gt;());
&lt;span id=&quot;LC20&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;o&quot;&gt;}
&lt;span id=&quot;LC21&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC22&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;private &lt;span class=&quot;kt&quot;&gt;void &lt;span class=&quot;nf&quot;&gt;processCommand&lt;span class=&quot;o&quot;&gt;() &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC23&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;k&quot;&gt;try &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC24&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;nc&quot;&gt;Thread&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;sleep&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;mi&quot;&gt;5000&lt;span class=&quot;o&quot;&gt;);
&lt;span id=&quot;LC25&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;o&quot;&gt;} &lt;span class=&quot;k&quot;&gt;catch &lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;nc&quot;&gt;InterruptedException &lt;span class=&quot;n&quot;&gt;e&lt;span class=&quot;o&quot;&gt;) &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC26&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;n&quot;&gt;e&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;printStackTrace&lt;span class=&quot;o&quot;&gt;();
&lt;span id=&quot;LC27&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;o&quot;&gt;}
&lt;span id=&quot;LC28&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;o&quot;&gt;}
&lt;span id=&quot;LC29&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC30&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;nd&quot;&gt;@Override
&lt;span id=&quot;LC31&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;nc&quot;&gt;String &lt;span class=&quot;nf&quot;&gt;toString&lt;span class=&quot;o&quot;&gt;() &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC32&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;k&quot;&gt;return &lt;span class=&quot;k&quot;&gt;this&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;command&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC33&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;o&quot;&gt;}
&lt;span id=&quot;LC34&quot; class=&quot;line&quot;&gt;}
&lt;span id=&quot;LC35&quot; class=&quot;line&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;编写测试程序，我们这里以阿里巴巴推荐的使用 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 构造函数自定义参数的方式来创建线程池。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ThreadPoolExecutorDemo.java&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;white&quot; readability=&quot;10&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;span id=&quot;LC1&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import &lt;span class=&quot;nn&quot;&gt;java.util.concurrent.ArrayBlockingQueue&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC2&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import &lt;span class=&quot;nn&quot;&gt;java.util.concurrent.ThreadPoolExecutor&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC3&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import &lt;span class=&quot;nn&quot;&gt;java.util.concurrent.TimeUnit&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC4&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC5&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kd&quot;&gt;class &lt;span class=&quot;nc&quot;&gt;ThreadPoolExecutorDemo &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC6&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC7&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;private &lt;span class=&quot;kd&quot;&gt;static &lt;span class=&quot;kd&quot;&gt;final &lt;span class=&quot;kt&quot;&gt;int &lt;span class=&quot;no&quot;&gt;CORE_POOL_SIZE &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;mi&quot;&gt;5&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC8&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;private &lt;span class=&quot;kd&quot;&gt;static &lt;span class=&quot;kd&quot;&gt;final &lt;span class=&quot;kt&quot;&gt;int &lt;span class=&quot;no&quot;&gt;MAX_POOL_SIZE &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;mi&quot;&gt;10&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC9&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;private &lt;span class=&quot;kd&quot;&gt;static &lt;span class=&quot;kd&quot;&gt;final &lt;span class=&quot;kt&quot;&gt;int &lt;span class=&quot;no&quot;&gt;QUEUE_CAPACITY &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;mi&quot;&gt;100&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC10&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;private &lt;span class=&quot;kd&quot;&gt;static &lt;span class=&quot;kd&quot;&gt;final &lt;span class=&quot;nc&quot;&gt;Long &lt;span class=&quot;no&quot;&gt;KEEP_ALIVE_TIME &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;mi&quot;&gt;1L&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC11&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kd&quot;&gt;static &lt;span class=&quot;kt&quot;&gt;void &lt;span class=&quot;nf&quot;&gt;main&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;nc&quot;&gt;String&lt;span class=&quot;o&quot;&gt;[] &lt;span class=&quot;n&quot;&gt;args&lt;span class=&quot;o&quot;&gt;) &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC12&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC13&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;c1&quot;&gt;//使用阿里巴巴推荐的创建线程池的方式
&lt;span id=&quot;LC14&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;c1&quot;&gt;//通过ThreadPoolExecutor构造函数自定义参数创建
&lt;span id=&quot;LC15&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;nc&quot;&gt;ThreadPoolExecutor &lt;span class=&quot;n&quot;&gt;executor &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;nc&quot;&gt;ThreadPoolExecutor&lt;span class=&quot;o&quot;&gt;(
&lt;span id=&quot;LC16&quot; class=&quot;line&quot;&gt;                &lt;span class=&quot;no&quot;&gt;CORE_POOL_SIZE&lt;span class=&quot;o&quot;&gt;,
&lt;span id=&quot;LC17&quot; class=&quot;line&quot;&gt;                &lt;span class=&quot;no&quot;&gt;MAX_POOL_SIZE&lt;span class=&quot;o&quot;&gt;,
&lt;span id=&quot;LC18&quot; class=&quot;line&quot;&gt;                &lt;span class=&quot;no&quot;&gt;KEEP_ALIVE_TIME&lt;span class=&quot;o&quot;&gt;,
&lt;span id=&quot;LC19&quot; class=&quot;line&quot;&gt;                &lt;span class=&quot;nc&quot;&gt;TimeUnit&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;SECONDS&lt;span class=&quot;o&quot;&gt;,
&lt;span id=&quot;LC20&quot; class=&quot;line&quot;&gt;                &lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;nc&quot;&gt;ArrayBlockingQueue&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;(&lt;span class=&quot;no&quot;&gt;QUEUE_CAPACITY&lt;span class=&quot;o&quot;&gt;),
&lt;span id=&quot;LC21&quot; class=&quot;line&quot;&gt;                &lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;nc&quot;&gt;ThreadPoolExecutor&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;CallerRunsPolicy&lt;span class=&quot;o&quot;&gt;());
&lt;span id=&quot;LC22&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC23&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;k&quot;&gt;for &lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;kt&quot;&gt;int &lt;span class=&quot;n&quot;&gt;i &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;mi&quot;&gt;0&lt;span class=&quot;o&quot;&gt;; &lt;span class=&quot;n&quot;&gt;i &lt;span class=&quot;o&quot;&gt;&amp;lt; &lt;span class=&quot;mi&quot;&gt;10&lt;span class=&quot;o&quot;&gt;; &lt;span class=&quot;n&quot;&gt;i&lt;span class=&quot;o&quot;&gt;++) &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC24&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;c1&quot;&gt;//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）
&lt;span id=&quot;LC25&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;nc&quot;&gt;Runnable &lt;span class=&quot;n&quot;&gt;worker &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;nc&quot;&gt;MyRunnable&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;s&quot;&gt;&quot;&quot; &lt;span class=&quot;o&quot;&gt;+ &lt;span class=&quot;n&quot;&gt;i&lt;span class=&quot;o&quot;&gt;);
&lt;span id=&quot;LC26&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;c1&quot;&gt;//执行Runnable
&lt;span id=&quot;LC27&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;n&quot;&gt;executor&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;execute&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;worker&lt;span class=&quot;o&quot;&gt;);
&lt;span id=&quot;LC28&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;o&quot;&gt;}
&lt;span id=&quot;LC29&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;c1&quot;&gt;//终止线程池
&lt;span id=&quot;LC30&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;n&quot;&gt;executor&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;shutdown&lt;span class=&quot;o&quot;&gt;();
&lt;span id=&quot;LC31&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;k&quot;&gt;while &lt;span class=&quot;o&quot;&gt;(!&lt;span class=&quot;n&quot;&gt;executor&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;isTerminated&lt;span class=&quot;o&quot;&gt;()) &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC32&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;o&quot;&gt;}
&lt;span id=&quot;LC33&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;nc&quot;&gt;System&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;out&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;println&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;s&quot;&gt;&quot;Finished all threads&quot;&lt;span class=&quot;o&quot;&gt;);
&lt;span id=&quot;LC34&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;o&quot;&gt;}
&lt;span id=&quot;LC35&quot; class=&quot;line&quot;&gt;}
&lt;span id=&quot;LC36&quot; class=&quot;line&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;可以看到我们上面的代码指定了：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;corePoolSize&lt;/code&gt;: 核心线程数为 5。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;maximumPoolSize&lt;/code&gt; ：最大线程数 10&lt;/li&gt;
&lt;li&gt;&lt;code&gt;keepAliveTime&lt;/code&gt; : 等待时间为 1L。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unit&lt;/code&gt;: 等待时间的单位为 TimeUnit.SECONDS。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;workQueue&lt;/code&gt;：任务队列为 &lt;code&gt;ArrayBlockingQueue&lt;/code&gt;，并且容量为 100;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;handler&lt;/code&gt;:饱和策略为 &lt;code&gt;CallerRunsPolicy&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Output：&lt;/p&gt;
&lt;div class=&quot;white&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span id=&quot;LC1&quot; class=&quot;line&quot;&gt;pool-1-thread-2 Start. Time = Tue Nov 12 20:59:44 CST 2019
&lt;span id=&quot;LC2&quot; class=&quot;line&quot;&gt;pool-1-thread-5 Start. Time = Tue Nov 12 20:59:44 CST 2019
&lt;span id=&quot;LC3&quot; class=&quot;line&quot;&gt;pool-1-thread-4 Start. Time = Tue Nov 12 20:59:44 CST 2019
&lt;span id=&quot;LC4&quot; class=&quot;line&quot;&gt;pool-1-thread-1 Start. Time = Tue Nov 12 20:59:44 CST 2019
&lt;span id=&quot;LC5&quot; class=&quot;line&quot;&gt;pool-1-thread-3 Start. Time = Tue Nov 12 20:59:44 CST 2019
&lt;span id=&quot;LC6&quot; class=&quot;line&quot;&gt;pool-1-thread-5 End. Time = Tue Nov 12 20:59:49 CST 2019
&lt;span id=&quot;LC7&quot; class=&quot;line&quot;&gt;pool-1-thread-3 End. Time = Tue Nov 12 20:59:49 CST 2019
&lt;span id=&quot;LC8&quot; class=&quot;line&quot;&gt;pool-1-thread-2 End. Time = Tue Nov 12 20:59:49 CST 2019
&lt;span id=&quot;LC9&quot; class=&quot;line&quot;&gt;pool-1-thread-4 End. Time = Tue Nov 12 20:59:49 CST 2019
&lt;span id=&quot;LC10&quot; class=&quot;line&quot;&gt;pool-1-thread-1 End. Time = Tue Nov 12 20:59:49 CST 2019
&lt;span id=&quot;LC11&quot; class=&quot;line&quot;&gt;pool-1-thread-2 Start. Time = Tue Nov 12 20:59:49 CST 2019
&lt;span id=&quot;LC12&quot; class=&quot;line&quot;&gt;pool-1-thread-1 Start. Time = Tue Nov 12 20:59:49 CST 2019
&lt;span id=&quot;LC13&quot; class=&quot;line&quot;&gt;pool-1-thread-4 Start. Time = Tue Nov 12 20:59:49 CST 2019
&lt;span id=&quot;LC14&quot; class=&quot;line&quot;&gt;pool-1-thread-3 Start. Time = Tue Nov 12 20:59:49 CST 2019
&lt;span id=&quot;LC15&quot; class=&quot;line&quot;&gt;pool-1-thread-5 Start. Time = Tue Nov 12 20:59:49 CST 2019
&lt;span id=&quot;LC16&quot; class=&quot;line&quot;&gt;pool-1-thread-2 End. Time = Tue Nov 12 20:59:54 CST 2019
&lt;span id=&quot;LC17&quot; class=&quot;line&quot;&gt;pool-1-thread-3 End. Time = Tue Nov 12 20:59:54 CST 2019
&lt;span id=&quot;LC18&quot; class=&quot;line&quot;&gt;pool-1-thread-4 End. Time = Tue Nov 12 20:59:54 CST 2019
&lt;span id=&quot;LC19&quot; class=&quot;line&quot;&gt;pool-1-thread-5 End. Time = Tue Nov 12 20:59:54 CST 2019
&lt;span id=&quot;LC20&quot; class=&quot;line&quot;&gt;pool-1-thread-1 End. Time = Tue Nov 12 20:59:54 CST 2019
&lt;span id=&quot;LC21&quot; class=&quot;line&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;4.7 线程池原理分析&lt;/h3&gt;
&lt;p&gt;承接 4.6 节，我们通过代码输出结果可以看出：线程池每次会同时执行 5 个任务，这 5 个任务执行完之后，剩余的 5 个任务才会被执行。 大家可以先通过上面讲解的内容，分析一下到底是咋回事？（自己独立思考一会）&lt;/p&gt;
&lt;p&gt;现在，我们就分析上面的输出内容来简单分析一下线程池原理。&lt;/p&gt;
&lt;p&gt;**为了搞懂线程池的原理，我们需要首先分析一下 &lt;code&gt;execute&lt;/code&gt;方法。**在 4.6 节中的 Demo 中我们使用 &lt;code&gt;executor.execute(worker)&lt;/code&gt;来提交一个任务到线程池中去，这个方法非常重要，下面我们来看看它的源码：&lt;/p&gt;
&lt;div class=&quot;white&quot; readability=&quot;11&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;17&quot;&gt;
&lt;pre&gt;
&lt;span id=&quot;LC1&quot; class=&quot;line&quot;&gt;   &lt;span class=&quot;c1&quot;&gt;// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)
&lt;span id=&quot;LC2&quot; class=&quot;line&quot;&gt;   &lt;span class=&quot;kd&quot;&gt;private &lt;span class=&quot;kd&quot;&gt;final &lt;span class=&quot;nc&quot;&gt;AtomicInteger &lt;span class=&quot;n&quot;&gt;ctl &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;nc&quot;&gt;AtomicInteger&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;ctlOf&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;no&quot;&gt;RUNNING&lt;span class=&quot;o&quot;&gt;, &lt;span class=&quot;mi&quot;&gt;0&lt;span class=&quot;o&quot;&gt;));
&lt;span id=&quot;LC3&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC4&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;private &lt;span class=&quot;kd&quot;&gt;static &lt;span class=&quot;kt&quot;&gt;int &lt;span class=&quot;nf&quot;&gt;workerCountOf&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;kt&quot;&gt;int &lt;span class=&quot;n&quot;&gt;c&lt;span class=&quot;o&quot;&gt;) &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC5&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;k&quot;&gt;return &lt;span class=&quot;n&quot;&gt;c &lt;span class=&quot;o&quot;&gt;&amp;amp; &lt;span class=&quot;no&quot;&gt;CAPACITY&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC6&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;o&quot;&gt;}
&lt;span id=&quot;LC7&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC8&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;private &lt;span class=&quot;kd&quot;&gt;final &lt;span class=&quot;nc&quot;&gt;BlockingQueue&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;span class=&quot;nc&quot;&gt;Runnable&lt;span class=&quot;o&quot;&gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;workQueue&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC9&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC10&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kt&quot;&gt;void &lt;span class=&quot;nf&quot;&gt;execute&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;nc&quot;&gt;Runnable &lt;span class=&quot;n&quot;&gt;command&lt;span class=&quot;o&quot;&gt;) &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC11&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;c1&quot;&gt;// 如果任务为null，则抛出异常。
&lt;span id=&quot;LC12&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;k&quot;&gt;if &lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;command &lt;span class=&quot;o&quot;&gt;== &lt;span class=&quot;kc&quot;&gt;null&lt;span class=&quot;o&quot;&gt;)
&lt;span id=&quot;LC13&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;k&quot;&gt;throw &lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;nf&quot;&gt;NullPointerException&lt;span class=&quot;o&quot;&gt;();
&lt;span id=&quot;LC14&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;c1&quot;&gt;// ctl 中保存的线程池当前的一些状态信息
&lt;span id=&quot;LC15&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;kt&quot;&gt;int &lt;span class=&quot;n&quot;&gt;c &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;n&quot;&gt;ctl&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;get&lt;span class=&quot;o&quot;&gt;();
&lt;span id=&quot;LC16&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC17&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;c1&quot;&gt;//  下面会涉及到 3 步 操作
&lt;span id=&quot;LC18&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;c1&quot;&gt;// 1.首先判断当前线程池中之行的任务数量是否小于 corePoolSize
&lt;span id=&quot;LC19&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;c1&quot;&gt;// 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。
&lt;span id=&quot;LC20&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;k&quot;&gt;if &lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;workerCountOf&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;c&lt;span class=&quot;o&quot;&gt;) &lt;span class=&quot;o&quot;&gt;&amp;lt; &lt;span class=&quot;n&quot;&gt;corePoolSize&lt;span class=&quot;o&quot;&gt;) &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC21&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;k&quot;&gt;if &lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;addWorker&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;command&lt;span class=&quot;o&quot;&gt;, &lt;span class=&quot;kc&quot;&gt;true&lt;span class=&quot;o&quot;&gt;))
&lt;span id=&quot;LC22&quot; class=&quot;line&quot;&gt;                &lt;span class=&quot;k&quot;&gt;return&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC23&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;n&quot;&gt;c &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;n&quot;&gt;ctl&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;get&lt;span class=&quot;o&quot;&gt;();
&lt;span id=&quot;LC24&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;o&quot;&gt;}
&lt;span id=&quot;LC25&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;c1&quot;&gt;// 2.如果当前之行的任务数量大于等于 corePoolSize 的时候就会走到这里
&lt;span id=&quot;LC26&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;c1&quot;&gt;// 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态才会被并且队列可以加入任务，该任务才会被加入进去
&lt;span id=&quot;LC27&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;k&quot;&gt;if &lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;isRunning&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;c&lt;span class=&quot;o&quot;&gt;) &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp; &lt;span class=&quot;n&quot;&gt;workQueue&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;offer&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;command&lt;span class=&quot;o&quot;&gt;)) &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC28&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;kt&quot;&gt;int &lt;span class=&quot;n&quot;&gt;recheck &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;n&quot;&gt;ctl&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;get&lt;span class=&quot;o&quot;&gt;();
&lt;span id=&quot;LC29&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;c1&quot;&gt;// 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。
&lt;span id=&quot;LC30&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;k&quot;&gt;if &lt;span class=&quot;o&quot;&gt;(!&lt;span class=&quot;n&quot;&gt;isRunning&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;recheck&lt;span class=&quot;o&quot;&gt;) &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp; &lt;span class=&quot;n&quot;&gt;remove&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;command&lt;span class=&quot;o&quot;&gt;))
&lt;span id=&quot;LC31&quot; class=&quot;line&quot;&gt;                &lt;span class=&quot;n&quot;&gt;reject&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;command&lt;span class=&quot;o&quot;&gt;);
&lt;span id=&quot;LC32&quot; class=&quot;line&quot;&gt;                &lt;span class=&quot;c1&quot;&gt;// 如果当前线程池为空就新创建一个线程并执行。
&lt;span id=&quot;LC33&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;k&quot;&gt;else &lt;span class=&quot;nf&quot;&gt;if &lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;workerCountOf&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;recheck&lt;span class=&quot;o&quot;&gt;) &lt;span class=&quot;o&quot;&gt;== &lt;span class=&quot;mi&quot;&gt;0&lt;span class=&quot;o&quot;&gt;)
&lt;span id=&quot;LC34&quot; class=&quot;line&quot;&gt;                &lt;span class=&quot;n&quot;&gt;addWorker&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;kc&quot;&gt;null&lt;span class=&quot;o&quot;&gt;, &lt;span class=&quot;kc&quot;&gt;false&lt;span class=&quot;o&quot;&gt;);
&lt;span id=&quot;LC35&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;o&quot;&gt;}
&lt;span id=&quot;LC36&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;c1&quot;&gt;//3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。
&lt;span id=&quot;LC37&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;c1&quot;&gt;//如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。
&lt;span id=&quot;LC38&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;k&quot;&gt;else &lt;span class=&quot;nf&quot;&gt;if &lt;span class=&quot;o&quot;&gt;(!&lt;span class=&quot;n&quot;&gt;addWorker&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;command&lt;span class=&quot;o&quot;&gt;, &lt;span class=&quot;kc&quot;&gt;false&lt;span class=&quot;o&quot;&gt;))
&lt;span id=&quot;LC39&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;n&quot;&gt;reject&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;command&lt;span class=&quot;o&quot;&gt;);
&lt;span id=&quot;LC40&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;通过下图可以更好的对上面这 3 步做一个展示，下图是我为了省事直接从网上找到，原地址不明。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png&quot; alt=&quot;图解线程池实现原理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在，让我们在回到 4.6 节我们写的 Demo， 现在应该是不是很容易就可以搞懂它的原理了呢？&lt;/p&gt;
&lt;p&gt;没搞懂的话，也没关系，可以看看我的分析：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;我们在代码中模拟了 10 个任务，我们配置的核心线程数为 5 、等待队列容量为 100 ，所以每次只可能存在 5 个任务同时执行，剩下的 5 个任务会被放到等待队列中去。当前的 5 个任务之行完成后，才会之行剩下的 5 个任务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;5. Atomic 原子类&lt;/h2&gt;
&lt;h3&gt;5.1. 介绍一下Atomic 原子类&lt;/h3&gt;
&lt;p&gt;Atomic 翻译成中文是原子的意思。在化学上，我们知道原子是构成一般物质的最小单位，在化学反应中是不可分割的。在我们这里 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。&lt;/p&gt;
&lt;p&gt;所以，所谓原子类说简单点就是具有原子/原子操作特征的类。&lt;/p&gt;
&lt;p&gt;并发包 &lt;code&gt;java.util.concurrent&lt;/code&gt; 的原子类都存放在&lt;code&gt;java.util.concurrent.atomic&lt;/code&gt;下,如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/JUC%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%A6%82%E8%A7%88.png&quot; alt=&quot;JUC原子类概览&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5.2. JUC 包中的原子类是哪4类?&lt;/h3&gt;
&lt;p&gt;基本类型&lt;/p&gt;
&lt;p&gt;使用原子的方式更新基本类型&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AtomicInteger：整形原子类&lt;/li&gt;
&lt;li&gt;AtomicLong：长整型原子类&lt;/li&gt;
&lt;li&gt;AtomicBoolean：布尔型原子类&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;数组类型&lt;/p&gt;
&lt;p&gt;使用原子的方式更新数组里的某个元素&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AtomicIntegerArray：整形数组原子类&lt;/li&gt;
&lt;li&gt;AtomicLongArray：长整形数组原子类&lt;/li&gt;
&lt;li&gt;AtomicReferenceArray：引用类型数组原子类&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;引用类型&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AtomicReference：引用类型原子类&lt;/li&gt;
&lt;li&gt;AtomicStampedReference：原子更新引用类型里的字段原子类&lt;/li&gt;
&lt;li&gt;AtomicMarkableReference ：原子更新带有标记位的引用类型&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对象的属性修改类型&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AtomicIntegerFieldUpdater：原子更新整形字段的更新器&lt;/li&gt;
&lt;li&gt;AtomicLongFieldUpdater：原子更新长整形字段的更新器&lt;/li&gt;
&lt;li&gt;AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;5.3. 讲讲 AtomicInteger 的使用&lt;/h3&gt;
&lt;p&gt;AtomicInteger 类常用方法&lt;/p&gt;
&lt;div class=&quot;white&quot; readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;span id=&quot;LC1&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kd&quot;&gt;final &lt;span class=&quot;kt&quot;&gt;int &lt;span class=&quot;nf&quot;&gt;get&lt;span class=&quot;o&quot;&gt;() &lt;span class=&quot;c1&quot;&gt;//获取当前的值
&lt;span id=&quot;LC2&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kd&quot;&gt;final &lt;span class=&quot;kt&quot;&gt;int &lt;span class=&quot;nf&quot;&gt;getAndSet&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;kt&quot;&gt;int &lt;span class=&quot;n&quot;&gt;newValue&lt;span class=&quot;o&quot;&gt;)&lt;span class=&quot;c1&quot;&gt;//获取当前的值，并设置新的值
&lt;span id=&quot;LC3&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kd&quot;&gt;final &lt;span class=&quot;kt&quot;&gt;int &lt;span class=&quot;nf&quot;&gt;getAndIncrement&lt;span class=&quot;o&quot;&gt;()&lt;span class=&quot;c1&quot;&gt;//获取当前的值，并自增
&lt;span id=&quot;LC4&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kd&quot;&gt;final &lt;span class=&quot;kt&quot;&gt;int &lt;span class=&quot;nf&quot;&gt;getAndDecrement&lt;span class=&quot;o&quot;&gt;() &lt;span class=&quot;c1&quot;&gt;//获取当前的值，并自减
&lt;span id=&quot;LC5&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kd&quot;&gt;final &lt;span class=&quot;kt&quot;&gt;int &lt;span class=&quot;nf&quot;&gt;getAndAdd&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;kt&quot;&gt;int &lt;span class=&quot;n&quot;&gt;delta&lt;span class=&quot;o&quot;&gt;) &lt;span class=&quot;c1&quot;&gt;//获取当前的值，并加上预期的值
&lt;span id=&quot;LC6&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;kt&quot;&gt;boolean &lt;span class=&quot;nf&quot;&gt;compareAndSet&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;kt&quot;&gt;int &lt;span class=&quot;n&quot;&gt;expect&lt;span class=&quot;o&quot;&gt;, &lt;span class=&quot;kt&quot;&gt;int &lt;span class=&quot;n&quot;&gt;update&lt;span class=&quot;o&quot;&gt;) &lt;span class=&quot;c1&quot;&gt;//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）
&lt;span id=&quot;LC7&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kd&quot;&gt;final &lt;span class=&quot;kt&quot;&gt;void &lt;span class=&quot;nf&quot;&gt;lazySet&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;kt&quot;&gt;int &lt;span class=&quot;n&quot;&gt;newValue&lt;span class=&quot;o&quot;&gt;)&lt;span class=&quot;c1&quot;&gt;//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;AtomicInteger 类的使用示例&lt;/p&gt;
&lt;p&gt;使用 AtomicInteger 之后，不用对 increment() 方法加锁也可以保证线程安全。&lt;/p&gt;
&lt;div class=&quot;white&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span id=&quot;LC1&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;kd&quot;&gt;class &lt;span class=&quot;nc&quot;&gt;AtomicIntegerTest &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC2&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;kd&quot;&gt;private &lt;span class=&quot;nc&quot;&gt;AtomicInteger &lt;span class=&quot;n&quot;&gt;count &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;nc&quot;&gt;AtomicInteger&lt;span class=&quot;o&quot;&gt;();
&lt;span id=&quot;LC3&quot; class=&quot;line&quot;&gt;      &lt;span class=&quot;c1&quot;&gt;//使用AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。
&lt;span id=&quot;LC4&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kt&quot;&gt;void &lt;span class=&quot;nf&quot;&gt;increment&lt;span class=&quot;o&quot;&gt;() &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC5&quot; class=&quot;line&quot;&gt;                  &lt;span class=&quot;n&quot;&gt;count&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;incrementAndGet&lt;span class=&quot;o&quot;&gt;();
&lt;span id=&quot;LC6&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;o&quot;&gt;}
&lt;span id=&quot;LC7&quot; class=&quot;line&quot;&gt;     
&lt;span id=&quot;LC8&quot; class=&quot;line&quot;&gt;       &lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kt&quot;&gt;int &lt;span class=&quot;nf&quot;&gt;getCount&lt;span class=&quot;o&quot;&gt;() &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC9&quot; class=&quot;line&quot;&gt;                &lt;span class=&quot;k&quot;&gt;return &lt;span class=&quot;n&quot;&gt;count&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;get&lt;span class=&quot;o&quot;&gt;();
&lt;span id=&quot;LC10&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;o&quot;&gt;}
&lt;span id=&quot;LC11&quot; class=&quot;line&quot;&gt;}
&lt;span id=&quot;LC12&quot; class=&quot;line&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;5.4. 能不能给我简单介绍一下 AtomicInteger 类的原理&lt;/h3&gt;
&lt;p&gt;AtomicInteger 线程安全原理简单分析&lt;/p&gt;
&lt;p&gt;AtomicInteger 类的部分源码：&lt;/p&gt;
&lt;div class=&quot;white&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span id=&quot;LC1&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;c1&quot;&gt;// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）
&lt;span id=&quot;LC2&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;private &lt;span class=&quot;kd&quot;&gt;static &lt;span class=&quot;kd&quot;&gt;final &lt;span class=&quot;nc&quot;&gt;Unsafe &lt;span class=&quot;n&quot;&gt;unsafe &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;nc&quot;&gt;Unsafe&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;getUnsafe&lt;span class=&quot;o&quot;&gt;();
&lt;span id=&quot;LC3&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;private &lt;span class=&quot;kd&quot;&gt;static &lt;span class=&quot;kd&quot;&gt;final &lt;span class=&quot;kt&quot;&gt;long &lt;span class=&quot;n&quot;&gt;valueOffset&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC4&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC5&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;static &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC6&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;k&quot;&gt;try &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC7&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;n&quot;&gt;valueOffset &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;n&quot;&gt;unsafe&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;objectFieldOffset
&lt;span id=&quot;LC8&quot; class=&quot;line&quot;&gt;                &lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;nc&quot;&gt;AtomicInteger&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;class&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;getDeclaredField&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;s&quot;&gt;&quot;value&quot;&lt;span class=&quot;o&quot;&gt;));
&lt;span id=&quot;LC9&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;o&quot;&gt;} &lt;span class=&quot;k&quot;&gt;catch &lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;nc&quot;&gt;Exception &lt;span class=&quot;n&quot;&gt;ex&lt;span class=&quot;o&quot;&gt;) &lt;span class=&quot;o&quot;&gt;{ &lt;span class=&quot;k&quot;&gt;throw &lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;nc&quot;&gt;Error&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;ex&lt;span class=&quot;o&quot;&gt;); &lt;span class=&quot;o&quot;&gt;}
&lt;span id=&quot;LC10&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;o&quot;&gt;}
&lt;span id=&quot;LC11&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC12&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;private &lt;span class=&quot;kd&quot;&gt;volatile &lt;span class=&quot;kt&quot;&gt;int &lt;span class=&quot;n&quot;&gt;value&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。&lt;/p&gt;
&lt;p&gt;CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个volatile变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。&lt;/p&gt;
&lt;p&gt;关于 Atomic 原子类这部分更多内容可以查看我的这篇文章：并发编程面试必备：&lt;a href=&quot;https://mp.weixin.qq.com/s/joa-yOiTrYF67bElj8xqvg&quot;&gt;JUC 中的 Atomic 原子类总结&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;6. AQS&lt;/h2&gt;
&lt;h3&gt;6.1. AQS 介绍&lt;/h3&gt;
&lt;p&gt;AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/AQS%E7%B1%BB.png&quot; alt=&quot;AQS类&quot;/&gt;&lt;/p&gt;
&lt;p&gt;AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。&lt;/p&gt;
&lt;h3&gt;6.2. AQS 原理分析&lt;/h3&gt;
&lt;p&gt;AQS 原理这部分参考了部分博客，在5.2节末尾放了链接。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在面试中被问到并发知识的时候，大多都会被问到“请你说一下自己对于AQS原理的理解”。下面给大家一个示例供大家参加，面试不是背题，大家一定要加入自己的思想，即使加入不了自己的思想也要保证自己能够通俗的讲出来而不是背出来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面大部分内容其实在AQS类注释上已经给出了，不过是英语看着比较吃力一点，感兴趣的话可以看看源码。&lt;/p&gt;
&lt;h4&gt;6.2.1. AQS 原理概览&lt;/h4&gt;
&lt;p&gt;AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看个AQS(AbstractQueuedSynchronizer)原理图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/AQS%E5%8E%9F%E7%90%86%E5%9B%BE.png&quot; alt=&quot;AQS原理图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。&lt;/p&gt;
&lt;div class=&quot;white&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span id=&quot;LC1&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;kd&quot;&gt;private &lt;span class=&quot;kd&quot;&gt;volatile &lt;span class=&quot;kt&quot;&gt;int &lt;span class=&quot;n&quot;&gt;state&lt;span class=&quot;o&quot;&gt;;&lt;span class=&quot;c1&quot;&gt;//共享变量，使用volatile修饰保证线程可见性&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;状态信息通过protected类型的getState，setState，compareAndSetState进行操作&lt;/p&gt;
&lt;div class=&quot;white&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;span id=&quot;LC1&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC2&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//返回同步状态的当前值
&lt;span id=&quot;LC3&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;kd&quot;&gt;protected &lt;span class=&quot;kd&quot;&gt;final &lt;span class=&quot;kt&quot;&gt;int &lt;span class=&quot;nf&quot;&gt;getState&lt;span class=&quot;o&quot;&gt;() &lt;span class=&quot;o&quot;&gt;{  
&lt;span id=&quot;LC4&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;k&quot;&gt;return &lt;span class=&quot;n&quot;&gt;state&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC5&quot; class=&quot;line&quot;&gt;}
&lt;span id=&quot;LC6&quot; class=&quot;line&quot;&gt; &lt;span class=&quot;c1&quot;&gt;// 设置同步状态的值
&lt;span id=&quot;LC7&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;kd&quot;&gt;protected &lt;span class=&quot;kd&quot;&gt;final &lt;span class=&quot;kt&quot;&gt;void &lt;span class=&quot;nf&quot;&gt;setState&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;kt&quot;&gt;int &lt;span class=&quot;n&quot;&gt;newState&lt;span class=&quot;o&quot;&gt;) &lt;span class=&quot;o&quot;&gt;{ 
&lt;span id=&quot;LC8&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;n&quot;&gt;state &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;n&quot;&gt;newState&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC9&quot; class=&quot;line&quot;&gt;}
&lt;span id=&quot;LC10&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）
&lt;span id=&quot;LC11&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;kd&quot;&gt;protected &lt;span class=&quot;kd&quot;&gt;final &lt;span class=&quot;kt&quot;&gt;boolean &lt;span class=&quot;nf&quot;&gt;compareAndSetState&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;kt&quot;&gt;int &lt;span class=&quot;n&quot;&gt;expect&lt;span class=&quot;o&quot;&gt;, &lt;span class=&quot;kt&quot;&gt;int &lt;span class=&quot;n&quot;&gt;update&lt;span class=&quot;o&quot;&gt;) &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC12&quot; class=&quot;line&quot;&gt;        &lt;span class=&quot;k&quot;&gt;return &lt;span class=&quot;n&quot;&gt;unsafe&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;compareAndSwapInt&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;k&quot;&gt;this&lt;span class=&quot;o&quot;&gt;, &lt;span class=&quot;n&quot;&gt;stateOffset&lt;span class=&quot;o&quot;&gt;, &lt;span class=&quot;n&quot;&gt;expect&lt;span class=&quot;o&quot;&gt;, &lt;span class=&quot;n&quot;&gt;update&lt;span class=&quot;o&quot;&gt;);
&lt;span id=&quot;LC13&quot; class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h4&gt;6.2.2. AQS 对资源的共享方式&lt;/h4&gt;
&lt;p&gt;AQS定义两种资源共享方式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Exclusive（独占）：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：
&lt;ul&gt;&lt;li&gt;公平锁：按照线程在队列中的排队顺序，先到者先拿到锁&lt;/li&gt;
&lt;li&gt;非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Share（共享）：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。&lt;/p&gt;
&lt;p&gt;不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。&lt;/p&gt;
&lt;h4&gt;6.2.3. AQS底层使用了模板方法模式&lt;/h4&gt;
&lt;p&gt;同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）&lt;/li&gt;
&lt;li&gt;将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。&lt;/p&gt;
&lt;p&gt;AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：&lt;/p&gt;
&lt;div class=&quot;white&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span id=&quot;LC1&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;n&quot;&gt;isHeldExclusively&lt;span class=&quot;o&quot;&gt;()&lt;span class=&quot;c1&quot;&gt;//该线程是否正在独占资源。只有用到condition才需要去实现它。
&lt;span id=&quot;LC2&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;n&quot;&gt;tryAcquire&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;kt&quot;&gt;int&lt;span class=&quot;o&quot;&gt;)&lt;span class=&quot;c1&quot;&gt;//独占方式。尝试获取资源，成功则返回true，失败则返回false。
&lt;span id=&quot;LC3&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;n&quot;&gt;tryRelease&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;kt&quot;&gt;int&lt;span class=&quot;o&quot;&gt;)&lt;span class=&quot;c1&quot;&gt;//独占方式。尝试释放资源，成功则返回true，失败则返回false。
&lt;span id=&quot;LC4&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;n&quot;&gt;tryAcquireShared&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;kt&quot;&gt;int&lt;span class=&quot;o&quot;&gt;)&lt;span class=&quot;c1&quot;&gt;//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
&lt;span id=&quot;LC5&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;n&quot;&gt;tryReleaseShared&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;kt&quot;&gt;int&lt;span class=&quot;o&quot;&gt;)&lt;span class=&quot;c1&quot;&gt;//共享方式。尝试释放资源，成功则返回true，失败则返回false。
&lt;span id=&quot;LC6&quot; class=&quot;line&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;默认情况下，每个方法都抛出 &lt;code&gt;UnsupportedOperationException&lt;/code&gt;。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS类中的其他方法都是final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。&lt;/p&gt;
&lt;p&gt;以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。&lt;/p&gt;
&lt;p&gt;再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS(Compare and Swap)减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。&lt;/p&gt;
&lt;p&gt;一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现&lt;code&gt;tryAcquire-tryRelease&lt;/code&gt;、&lt;code&gt;tryAcquireShared-tryReleaseShared&lt;/code&gt;中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;推荐两篇 AQS 原理和相关源码分析的文章：&lt;/p&gt;
&lt;h3&gt;6.3. AQS 组件总结&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Semaphore(信号量)-允许多个线程同时访问： synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。&lt;/li&gt;
&lt;li&gt;CountDownLatch （倒计时器）： CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。&lt;/li&gt;
&lt;li&gt;CyclicBarrier(循环栅栏)： CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await()方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;7 Reference&lt;/h2&gt;
</description>
<pubDate>Wed, 08 Jan 2020 14:44:00 +0000</pubDate>
<dc:creator>不懒人</dc:creator>
<og:description>Java 并发进阶常见面试题总结 1. synchronized 关键字 1.1. 说一说自己对于 synchronized 关键字的了解 synchronized关键字解决的是多个线程之间访问资源的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wuwuyong/p/12169102.html</dc:identifier>
</item>
<item>
<title>2019年总结 - lilicat</title>
<link>http://www.cnblogs.com/lilicat/p/12169080.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lilicat/p/12169080.html</guid>
<description>&lt;p class=&quot;code-line&quot; data-line=&quot;0&quot;&gt;文/2020年1月8日&lt;/p&gt;

&lt;p class=&quot;code-line&quot; data-line=&quot;3&quot;&gt;失业2月，钱包空空。&lt;/p&gt;
&lt;p class=&quot;code-line&quot; data-line=&quot;5&quot;&gt;今天终于静下心来，对于2019年的自己做个总结。2019无疑是慌乱的，繁忙的。工作中的项目一个接着一个，想做的事情一件接着一件。&lt;/p&gt;
&lt;h2 id=&quot;%E5%9B%9E%E9%A1%BE2019&quot; class=&quot;code-line&quot; data-line=&quot;7&quot;&gt;回顾2019&lt;/h2&gt;
&lt;p class=&quot;code-line&quot; data-line=&quot;8&quot;&gt;三个角度总结我的2019，工作、学习、生活。&lt;/p&gt;
&lt;h3 id=&quot;%E5%B7%A5%E4%BD%9C&quot; class=&quot;code-line&quot; data-line=&quot;10&quot;&gt;工作&lt;/h3&gt;
&lt;p class=&quot;code-line&quot; data-line=&quot;11&quot;&gt;在工作中一直从事的开发，相似的工作经历，虽然项目众多，然而毫无意义。面试官询问：你的技术难点和亮点是什么。说一下你的开源项目。一瞬间懵逼。安逸的工作环境真的很容易让人处于一个舒适区。我原没有想到我会这么快重新再找工作，然而公司这座大船于11月突然沉没，全部人员离职。这完全打乱了我的节奏。12月的时候，开始写简历，天啦噜，过去的一年半我都做了些什么。好似就是一个个项目的堆叠，我有做了什么么？我懂得哪些技术栈？我的项目经验大同小异，乏善可陈，我的技术零零落落，不成体系。18年的时候决定学习的全栈路线呢，没有完成。意外来临的时候，什么准备都没有。我开始回顾过往的一个个项目，哦，过往的记忆仿佛蒙着一层纱，虽然是自己写的代码，要很用力的回想才能拾起一丝丝的当时的逻辑想法。还好当时，还是有些遇到的问题，做了摘录，还是有些项目的总结，做了分享。所以20年一定要慢慢来，重新出发，定个计划，将技术栈知识树补全。以及每个项目做过以后，都要写个总结回顾。与此同时，我也是庆幸这段时间的休息和思考，让我有时间做一个回顾，外部的压力帮我敲响了警钟，让我重新审视我自己，要时刻保持竞争力，在浪头打过来的时候，才能不被淹没。&lt;/p&gt;
&lt;h3 id=&quot;%E5%AD%A6%E4%B9%A0&quot; class=&quot;code-line&quot; data-line=&quot;13&quot;&gt;学习&lt;/h3&gt;
&lt;p class=&quot;code-line&quot; data-line=&quot;14&quot;&gt;学习感悟最深的就是，量变引起质变了。很多时候，我都有急于求成，好高骛远的心态。想学一个东西，就想很快学成功。这种心理最后的结局往往让我一事无成，心态失衡。所以一个计划是很重要的。很多时候，你只需要规划一件小事情，如果每天都坚持做。那么在若干年后，回顾这一路来，才能看到收获。&lt;/p&gt;
&lt;p class=&quot;code-line&quot; data-line=&quot;16&quot;&gt;19年对于技术的学习好像乏善可陈。17年花了半年时间看库的源码，现在好似全部忘光了一样。19年的一年是陷入重复做业务的一年。技术上，学习node，koa，typescript和vue源码，但是说不出来，没有掌握，20年的目标就是提高自己的表达能力，将这些知识掌握。18年双十一买了3年服务器，19年也没有做什么。20年的目标写一个项目。&lt;/p&gt;
&lt;p class=&quot;code-line&quot; data-line=&quot;21&quot;&gt;坚持leetcode，3年多了，从一个渣渣到半个渣渣，从一道题，要思考半天，到现在一道题，思考小半天，哈哈哈哈。英语题目能够看懂七七八八。过去都是很死板的做题。今后，会针对题型做一下总结，最重要的是，可以表达出来，说出原理，否则太惨了啦啦啦啦。只知招式，不练内功，非长远之道。&lt;/p&gt;
&lt;p class=&quot;code-line&quot; data-line=&quot;23&quot;&gt;学习英语，突然间兴起学习英语的原因，可能只是想看懂技术文档，也有可能是别人的经历鼓舞了我。记得当时看了一个帖子，一个程序员学习了三年，把新概念英语，从最开始的音标开始，到最后可以流利交流。三年的跨度时间，很漫长。不过，过往时间教给我的经验教训就是，不要害怕。三年前的我没有开始，但三年后的我可能会说，真好，三年前的你开始了。选了一个考试，作为我学习成果的验收，BEC考试，虽然这并不能说明什么。6月份和11月份，我参加了两次，一个FAIL，一个B1，成绩提高了23分。我是真真切切的感受到了时间带给我的力量。当你每天都去做一件事情，时间会给你最后的答案。&lt;/p&gt;
&lt;h3 id=&quot;%E7%94%9F%E6%B4%BB&quot; class=&quot;code-line&quot; data-line=&quot;25&quot;&gt;生活&lt;/h3&gt;
&lt;p class=&quot;code-line&quot; data-line=&quot;26&quot;&gt;坚持健身，健身给我的回报是巨大的。动起来会很快乐很满足。期间也认识了很多一起健身的小伙伴，她们都so cool。10月份进行了系统学习。健身的世界太大了，入了门，才发现原来的自己其实很无知。然后20年的计划，继续保持健身的习惯，将健身的情况记录下来，等21年的时候再做个比较哈哈哈，看自己有没有什么变化。很喜欢keep的一句话：自律给我自由。 做个回顾，2019年1月1日开始到2019年12月31日结束，体重减少3.6斤，脂肪变化-1%，肌肉变化+0.7%。工作使人肥胖是真的哈哈哈，19年最重的时候有105斤哈哈哈，然后失业的两个月体重减少6.7斤，脂肪变化-1.3%，肌肉变化+0.9%。&lt;/p&gt;
&lt;h3 id=&quot;%E7%94%9F%E6%B4%BB&quot; class=&quot;code-line&quot; data-line=&quot;25&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;19年完成的事情：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;问题摘录&lt;/li&gt;
&lt;li&gt;保持健身，学习理论知识&lt;/li&gt;
&lt;li&gt;项目总结&lt;/li&gt;
&lt;li&gt;英语进步&lt;/li&gt;
&lt;li&gt;LeetCode开始做中级题目&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;19年没有完成的事情&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;学习全栈&lt;/li&gt;
&lt;li&gt;每个项目的总结&lt;/li&gt;
&lt;li&gt;做个自己的项目&lt;/li&gt;
&lt;li&gt;知识点总结&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;2020%E4%BB%A5%E5%90%8E&quot; class=&quot;code-line&quot; data-line=&quot;28&quot;&gt;2020以后&lt;/h2&gt;
&lt;p class=&quot;code-line&quot; data-line=&quot;29&quot;&gt;要做的事情&lt;/p&gt;
&lt;ol&gt;&lt;li class=&quot;code-line&quot; data-line=&quot;30&quot;&gt;学习全栈&lt;/li&gt;
&lt;li class=&quot;code-line&quot; data-line=&quot;31&quot;&gt;做个项目&lt;/li&gt;
&lt;li class=&quot;code-line&quot; data-line=&quot;32&quot;&gt;保持健身&lt;/li&gt;
&lt;li class=&quot;code-line&quot; data-line=&quot;33&quot;&gt;继续英语&lt;/li&gt;
&lt;li class=&quot;code-line&quot; data-line=&quot;34&quot;&gt;项目总结&lt;/li&gt;
&lt;li class=&quot;code-line&quot; data-line=&quot;35&quot;&gt;刻意练习&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;code-line&quot; data-line=&quot;37&quot;&gt;剩下的，就看2020年结束的时候啦。&lt;/p&gt;
</description>
<pubDate>Wed, 08 Jan 2020 14:36:00 +0000</pubDate>
<dc:creator>lilicat</dc:creator>
<og:description>文/2020年1月8日 2019年总结 失业2月，钱包空空。 今天终于静下心来，对于2019年的自己做个总结。2019无疑是慌乱的，繁忙的。工作中的项目一个接着一个，想做的事情一件接着一件。 回顾20</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lilicat/p/12169080.html</dc:identifier>
</item>
</channel>
</rss>