<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>VMware虚拟机安装及免密码登录 - 矮子国王</title>
<link>http://www.cnblogs.com/yxkcode/p/10185376.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yxkcode/p/10185376.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;1，安装&lt;/span&gt;VMware&lt;span&gt;虚拟机软件。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt; （1）&lt;span&gt;、安装&lt;/span&gt;Ubuntu&lt;span&gt;之前的准备工作&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;     1.1 &lt;span&gt;点击编辑&lt;/span&gt;-&amp;gt;&lt;span&gt;虚拟网络编辑器&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;     1.2&lt;span&gt;选择&lt;/span&gt;VMnet8&lt;span&gt;，点击更改设置，在弹出的用户账户控制对话框中，选择是&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     1.3&lt;span&gt;选择&lt;/span&gt;VMnet8&lt;span&gt;，去掉“使用本地&lt;/span&gt;&lt;span&gt;DHCP&lt;/span&gt;&lt;span&gt;服务器将&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;地址分配给虚拟机”选项，子网选项中&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;地址前三个字段和本机&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;地址前三个字段相同（在命令提示符中通过&lt;/span&gt;&lt;span&gt;ipconfig&lt;/span&gt;&lt;span&gt;命令查看本机&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;地址），然后点击&lt;/span&gt;&lt;span&gt;NAT&lt;/span&gt;&lt;span&gt;设置，如图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                            &lt;img src=&quot;https://img2018.cnblogs.com/blog/1560113/201812/1560113-20181227151416291-2076400890.png&quot; alt=&quot;&quot; width=&quot;307&quot; height=&quot;243&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;15&quot;&gt;    1.4&lt;span&gt;网关&lt;/span&gt;IP&lt;span&gt;选项&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;地址前三个字段和本机&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;前三个字段相同，点击确定，设置完成&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;                          &lt;img src=&quot;https://img2018.cnblogs.com/blog/1560113/201812/1560113-20181227151523058-441085488.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;2，新建三台虚拟机，名称分布为&lt;/span&gt;master&lt;span&gt;、&lt;/span&gt;&lt;span&gt;slave&lt;/span&gt;1&lt;span&gt;和&lt;/span&gt;slave2&lt;span&gt;，安装&lt;/span&gt;ubuntu server 16.04.3 LTS&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;版&lt;/strong&gt;，下载地址&lt;/span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;a href=&quot;http://mirrors.opencas.org/ubuntu-releases/16.04.3/ubuntu-16.04.3-server-amd64.iso&quot;&gt;&lt;span&gt;http://mirrors.opencas.org/ubuntu-releases/16.04.3/ubuntu-16.04.3-server-amd64.iso&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;      （1）. &lt;span&gt;下载好镜像文件后，我们进行安装工作，在&lt;/span&gt;&lt;span&gt;VMware&lt;/span&gt;&lt;span&gt;里创建新虚拟机，&lt;/span&gt;&lt;span&gt;虚拟机&lt;/span&gt;IP&lt;span&gt;地址设置完成，等待虚拟机安装完成后启动&lt;/span&gt;。 &lt;span&gt;如图&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;                       &lt;img src=&quot;https://img2018.cnblogs.com/blog/1560113/201812/1560113-20181227151807227-1962940762.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;     （2）&lt;span&gt;图&lt;/span&gt;2-1-1&lt;span&gt;是创建好新的虚拟机后重启的页面&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;                      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1560113/201812/1560113-20181227151855438-1564621931.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt; &lt;/p&gt;

&lt;p class=&quot;15&quot;&gt;    （3）安装后登录后的页面&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;                                 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1560113/201812/1560113-20181227152120377-810087576.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;   （4）克隆三台虚拟机&lt;/p&gt;
&lt;p&gt;                              &lt;img src=&quot;https://img2018.cnblogs.com/blog/1560113/201812/1560113-20181227152203473-491651926.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.修改&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;root&lt;span&gt;密码，安装&lt;/span&gt;&lt;span&gt;vim&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;openssh-server&lt;/span&gt;&lt;span&gt;软件，配置&lt;/span&gt;&lt;span&gt;ssh&lt;/span&gt;&lt;span&gt;，允许&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;用户登录。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       (1)&lt;span&gt;一般安装后，&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;用户的密码是随机的，即每次开机密码都不一样，我们可以用我们可以在终端输入命令&lt;/span&gt; &lt;span&gt;sudo passwd&lt;/span&gt;&lt;span&gt;，然后输入当前用户的密码&lt;/span&gt;enter&lt;span&gt;，&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;终端会提示我们输入新的密码并确认，此时的密码就是&lt;/span&gt;root&lt;span&gt;新密码。修改成功后，输入命令&lt;/span&gt; &lt;span&gt;su root&lt;/span&gt;&lt;span&gt;，再输入新的密码就&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;三台虚拟机都要做此操作，如图&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;                       &lt;img id=&quot;uploading_image_36279&quot; src=&quot;https://common.cnblogs.com/images/loading.gif&quot; alt=&quot;&quot;/&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/1560113/201812/1560113-20181227152037561-685425669.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;     （2）、安装包、修改主机名及配置网络&lt;/p&gt;
&lt;p&gt;                    3.1.1&lt;span&gt;、&lt;/span&gt;&lt;span&gt;安装&lt;/span&gt;vim&lt;span&gt;和&lt;/span&gt;&lt;span&gt;openssh-server&lt;/span&gt;&lt;span&gt;，命令如下：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;                                sudo apt-get install vim openssh-server&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;                   3.1.2、配置每台虚拟机的IP地址，用如下命令：&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;                                  vi /etc/network/interfaces&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;                                  192.168.145.129 master&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;                                  192.168.145.130 slave1&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;                                  192.168.145.131 slave2&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;                  3.1.3&lt;span&gt;、 修改每台机器名称&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;                                 vi /etc/hostname&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;                                 HOSTNAME=master&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;                                HOSTNAME=slave1&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;                                HOSTNAME=slave2&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;                3.1.4&lt;span&gt;、为每一台增加&lt;/span&gt;&lt;span&gt;ip&lt;/span&gt;&lt;span&gt;和机器名称的映射关系&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;                             vi /etc/hosts&lt;span&gt;，类似于如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1560113/201812/1560113-20181227153142154-2041140095.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;                             我们用ping&lt;span&gt;命令三台虚拟机都可以&lt;/span&gt;&lt;span&gt;ping&lt;/span&gt;&lt;span&gt;得通，如图：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;                       &lt;img src=&quot;https://img2018.cnblogs.com/blog/1560113/201812/1560113-20181227153209888-2023363433.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;15&quot;&gt;                  3.1.5&lt;span&gt;、在每台虚拟机上执行以下命令：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;                                      systemctl stop NetworkManager&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;                                      systemctl disable NetworkManager&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;                                     &lt;span&gt;为什么要执行这两条命令勒&lt;/span&gt;?&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;                                     解决网络冲突，避免今后启动时会出网关启动失败&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;                   3.1.6 &lt;span&gt;配置&lt;/span&gt;&lt;span&gt;ssh&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;                                      Vim /etc/ssh/sshd_config&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;                                      /etc/init.d/ssh restart&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;                                   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1560113/201812/1560113-20181227153348871-1412791990.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;strong&gt;4.&lt;span&gt;配置&lt;/span&gt;master&lt;span&gt;免密码登录到&lt;/span&gt;&lt;span&gt;slave&lt;/span&gt;1&lt;span&gt;和&lt;/span&gt;slave2。&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;    (1) &lt;span&gt;、用命令&lt;/span&gt;ssh-keygen -t dsa -P '' -f ~/.ssh/id_dsa&lt;span&gt;生成密钥，&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;         &lt;img src=&quot;https://img2018.cnblogs.com/blog/1560113/201812/1560113-20181227153557487-1228250229.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;       (2) &lt;span&gt;再进入&lt;/span&gt;.ssh&lt;span&gt;目录下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           用&lt;/span&gt;ls -al&lt;span&gt;查看生成了&lt;/span&gt;&lt;span&gt;id_rsa.pub&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                        &lt;img src=&quot;https://img2018.cnblogs.com/blog/1560113/201812/1560113-20181227153630205-2047838555.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;         (3) &lt;span&gt;将&lt;/span&gt;id_dsa.pub&lt;span&gt;（公钥）追加到授权的&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;                       &lt;img src=&quot;https://img2018.cnblogs.com/blog/1560113/201812/1560113-20181227153701528-1397477041.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt; &lt;/p&gt;

&lt;p class=&quot;16&quot;&gt;          (4)&lt;span&gt;将认证文件复制到其它节点上：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;                      scp ~/.ssh/authorized_keys root@slave1:~/.ssh/&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;         将认证文件复制到其它节点上：&lt;/span&gt;scp ~/.ssh/authorized_keys &lt;a&gt;root&lt;span&gt;@slave2:~/.ssh/&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;         分别&lt;/span&gt;ssh slave1&lt;span&gt;、&lt;/span&gt;&lt;span&gt;ssh slave2&lt;/span&gt; &lt;span&gt;就直接登录了，不用密码，如图&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;           &lt;img src=&quot;https://img2018.cnblogs.com/blog/1560113/201812/1560113-20181227153855087-1040746989.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt; &lt;/p&gt;
&lt;p&gt;                      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1560113/201812/1560113-20181227153908274-1632505976.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;






&lt;p class=&quot;15&quot;&gt;  &lt;/p&gt;

</description>
<pubDate>Thu, 27 Dec 2018 07:45:00 +0000</pubDate>
<dc:creator>矮子国王</dc:creator>
<og:description>1，安装VMware虚拟机软件。 （1）、安装Ubuntu之前的准备工作 1.1 点击编辑-&gt;虚拟网络编辑器 1.2选择VMnet8，点击更改设置，在弹出的用户账户控制对话框中，选择是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yxkcode/p/10185376.html</dc:identifier>
</item>
<item>
<title>机器学习笔记(6)  线性回归算法 - sdu20112013</title>
<link>http://www.cnblogs.com/sdu20112013/p/10178643.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sdu20112013/p/10178643.html</guid>
<description>&lt;p&gt;先从最简单的例子开始,假设我们有一组样本(如下图的一个个黑色的圆点),只有一个特征,如下图,横轴是特征值,纵轴是label。比如横轴是房屋面积,纵轴是房屋价格.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201812/583030-20181226133903662-1760449250.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们要做什么呢？我们试图找到一条直线y=ax+b,可以尽量好的拟合这些点.&lt;/p&gt;
&lt;p&gt;你可能要问了,为啥是直线,不是曲线,不是折线？因为我们的前提就是我们假设数据是有线性关系的啊！一方面,这种假设方便我们用数学知识推导出a,b. 另一方面,假设成折线,曲线尽可能地贴合上图中的点是没有意义的,因为尽可能地贴合了训练数据,只能说明你的模型过拟合了,我们想要得到的是一个尽量通用的模型,能够在我们的测试数据上取得好的表现.即希望我们的模型泛化能力足够强.&lt;/p&gt;
&lt;p&gt;这里要插一句,每一种机器学习算法都可以看做是一种看待数据的角度,线性回归就是从&quot;数据可能存在线性关系&quot;这个角度来观察数据.  你当然也可以从别的角度观察数据.这就涉及到了集成学习,可以看看&lt;a href=&quot;https://www.cnblogs.com/sdu20112013/p/10032795.html&quot; target=&quot;_blank&quot;&gt;这篇博文&lt;/a&gt;.  &lt;span&gt;所以啊,没有尽量多的数据,尽量有意义的数据,尽量有效的特征提取,只有机器学习算法的话,其实没什么用.因为数据太少了,你再怎么从各种角度分析数据也不会取得很好的效果&lt;/span&gt;.这也是为啥大数据和机器学习总是被经常一起提到的原因.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ok，书归正传,到了这里,问题来了,我们怎么评价&quot;尽量好&quot;地拟合呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对某个样本点,其本来横坐标上是x,纵坐标是y。  我们把x带入我们的直线方程y=ax+b可以得到$\hat y=ax+b$，此即我们的预测值.我们以这二者之差的大小作为&quot;尽量好&quot;的评价标准.越小说明我们的预测值与真实值差别越小,拟合效果越好.&lt;/p&gt;
&lt;p&gt;具体地说,有以下几种评价标准&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;均方误差MSE&lt;/li&gt;
&lt;li&gt;均方根误差RMSE&lt;/li&gt;
&lt;li&gt;平均绝对误差MAE&lt;/li&gt;
&lt;li&gt;R Squared&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;均方误差MSE&lt;/strong&gt; $$\frac 1 m \sum_{i=1}^m(y^{(i)} - \hat y^{(i)})^2$$&lt;/p&gt;
&lt;p&gt;表明了总误差平摊到每一个样本上是多少,即均方误差.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;均方根误差RMSE&lt;/strong&gt;  $$\sqrt {\sum_{i=1}^m(y^{i} - \hat y^{i})^2}$$&lt;/p&gt;
&lt;p&gt;MSE的一个问题是,假如y是有量纲的,MSE的结果把量纲改变了.比如y的单位是dollar,MSE的结果变成了$dollar^2$。RSME就避免了这个问题.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;平均绝对误差MAE&lt;/strong&gt;$$\frac 1 m \sum _{i=1}^m |y^{(i)} - \hat y^{(i)}|$$&lt;/p&gt;
&lt;p&gt;我们为啥不用这个作为我们评判“尽可能好”的标准呢,因为不好求导.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R Squared&lt;/strong&gt;  $$R^2 = 1 - \frac {\sum _{i=1}^m(\hat y^{(i)} - y^{(i)})^2} {\sum _{i=1}^m(\bar y  - y^{(i)})^2}$$&lt;/p&gt;
&lt;p&gt;假设我们简单的取y的均值,即$y=\bar y$作为我们的模型,那误差就是$\sum_{i=1}^m(\bar y - y^{i})^2$。所以&lt;span&gt;$R^2$表达的就是我们的模型相较于简单的取$\bar y$作为我们的模型有多少差异&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;当$R^2$接近0时,说明我们的模型和直接取均值差别不大&lt;/p&gt;
&lt;p&gt;当$R^2$接近1时,说明我们的模型相当不错,我们预测值和真实值几乎没误差.&lt;/p&gt;
&lt;p&gt;当$R^2$为负时,说明我们的模型比直接取均值还要烂.此时你的数据可能就不存在线性关系.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比较常用的是RMSE和R平方.&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;现在问题变成了我们怎么求出a,b使得$ {\sum _{i=1}^m(\hat y^{(i)} - y^{(i)})^2} = {\sum _{i=1}^m(ax^{i}+b - y^{(i)})^2} $最小.这个函数就是所谓的损失函数.注意这个函数的未知数是a,b。这是很多机器学习算法的一个套路,首先定义出一个合适的损失函数,然后最小化损失函数从而得出我们的模型&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;以上,我们是用一个特征做例子的,实际上,当样本有N个特征,道理也是一样的。&lt;/p&gt;
&lt;p&gt;$y = a_1x_1+a_2x_2+…+a_nx_n+b$&lt;/p&gt;
&lt;p&gt;那么第i个样本的预测值为$y^i =  a_1x_1^i+a_2x_2+…+a_nx_n+b$我们改写成向量的形势就是&lt;/p&gt;
&lt;p&gt;$$\hat y^{(i)} = \begin{bmatrix} 1&amp;amp; X_1^{(i)}&amp;amp;X_2^{(i)}&amp;amp; … &amp;amp;X_n^{(i)}\end{bmatrix}\begin{bmatrix}  \theta_ 0 \\  \theta_ 1 \\  \theta_ 2 \\  … \\  \theta_ n \\ \end{bmatrix}$$&lt;/p&gt;
&lt;p&gt;令$X_b=\left[ \begin{matrix} 1 &amp;amp; x_{11} &amp;amp; x_{12} &amp;amp; ... &amp;amp; x_{1n} \\ 1 &amp;amp; x_{21} &amp;amp; x_{22} &amp;amp; ... &amp;amp; x_{2n} \\ ...\\ 1 &amp;amp; x_{m1} &amp;amp; x_{m2} &amp;amp; ... &amp;amp; x_{mn} \end{matrix} \right] $&lt;/p&gt;
&lt;p&gt;则$\hat y^{i} = X_b^{(i)}\theta$，$\hat y^ = X_b\theta$,此时我们的损失函数变为$f_{loss} = \sum_{i=1}^m(y - X_b^i  \theta)^2$&lt;/p&gt;
&lt;p&gt;转换成矩阵的表达$f_{loss} = (y-X_b\theta)^T(y - X_b\theta)$。现在我们的目标变为使这个$f_{loss}$最小,注意未知数是$\theta$。注意一下这个$\theta$是个向量,是一系列值,不是标量.在二维平面中比如$y=f(x)$中,我们知道求极值即求导数$f^{'}(x)=0$.同样的为了求出$f_{loss}$的最小值,我们对$f_{loss}$求导$\frac {\partial f_{loss}}{\partial \theta}$,实际上就是对$\theta$的每一项求偏导数.一系列复杂的数学推导后,我们可得$$\theta=(X_b^TX_b)^{-1}X_b^Ty$$&lt;/p&gt;
&lt;p&gt;$\theta=\begin{bmatrix}  \theta_ 0\\  \theta_ 1\\  \theta_ 2\\  …\\  \theta_ n\\ \end{bmatrix}$&lt;/p&gt;
&lt;p&gt;其中$\theta_0$是多元线性方程的截距(intercept), $\theta_1$到$\theta_n$是系数(coefficients).&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;线性回归具有很好的可解释性,下面通过一个具体例子看一下.&lt;/p&gt;
&lt;blockquote readability=&quot;28.694431445952&quot;&gt;
&lt;pre&gt;
Boston House Prices dataset
===========================

Notes
------
Data Set Characteristics:  

    :Number of Instances: 506 

    :Number of Attributes: 13 numeric/categorical predictive
    
    :Median Value (attribute 14) is usually the target

    :Attribute Information (in order):
        - CRIM     per capita crime rate by town
        - ZN       proportion of residential land zoned for lots over 25,000 sq.ft.
        - INDUS    proportion of non-retail business acres per town
        - CHAS     Charles River dummy variable (= 1 if tract bounds river; 0 otherwise)
        - NOX      nitric oxides concentration (parts per 10 million)
        - RM       average number of rooms per dwelling
        - AGE      proportion of owner-occupied units built prior to 1940
        - DIS      weighted distances to five Boston employment centres
        - RAD      index of accessibility to radial highways
        - TAX      full-value property-tax rate per $10,000
        - PTRATIO  pupil-teacher ratio by town
        - B        1000(Bk - 0.63)^2 where Bk is the proportion of blacks by town
        - LSTAT    % lower status of the population
        - MEDV     Median value of owner-occupied homes in $1000's

    :Missing Attribute Values: None

    :Creator: Harrison, D. and Rubinfeld, D.L.

This is a copy of UCI ML housing dataset.
&lt;a href=&quot;http://archive.ics.uci.edu/ml/datasets/Housing&quot; target=&quot;_blank&quot;&gt;http://archive.ics.uci.edu/ml/datasets/Housing&lt;/a&gt;


This dataset was taken from the StatLib library which is maintained at Carnegie Mellon University.

The Boston house-price data of Harrison, D. and Rubinfeld, D.L. 'Hedonic
prices and the demand for clean air', J. Environ. Economics &amp;amp; Management,
vol.5, 81-102, 1978.   Used in Belsley, Kuh &amp;amp; Welsch, 'Regression diagnostics
...', Wiley, 1980.   N.B. Various transformations are used in the table on
pages 244-261 of the latter.

The Boston house-price data has been used in many machine learning papers that address regression
problems.   
     
**References**

   - Belsley, Kuh &amp;amp; Welsch, 'Regression diagnostics: Identifying Influential Data and Sources of Collinearity', Wiley, 1980. 244-261.
   - Quinlan,R. (1993). Combining Instance-Based and Model-Based Learning. In Proceedings on the Tenth International Conference of Machine Learning, 236-243, University of Massachusetts, Amherst. Morgan Kaufmann.
   - many more! (see &lt;a href=&quot;http://archive.ics.uci.edu/ml/datasets/Housing)&quot; target=&quot;_blank&quot;&gt;http://archive.ics.uci.edu/ml/datasets/Housing)&lt;/a&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;boston数据集有13个特征,包括了房间数目,房龄，是否临河,离商圈距离等等,一个label，表示房屋价格.&lt;/p&gt;
&lt;p&gt;用sklearn中的LinearRegression来做训练.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
boston =&lt;span&gt; datasets.load_boston()  
X &lt;/span&gt;=&lt;span&gt; boston.data
y &lt;/span&gt;=&lt;span&gt; boston.target  
X &lt;/span&gt;= X[y &amp;lt; 50.0&lt;span&gt;] 
y &lt;/span&gt;= y[y &amp;lt; 50.0&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.linear_model &lt;span&gt;import&lt;/span&gt;&lt;span&gt; LinearRegression
lin_reg &lt;/span&gt;=&lt;span&gt; LinearRegression()
lin_reg.fit(X, y)

print(lin_reg.coef_)&lt;br/&gt;&lt;/span&gt;####&lt;br/&gt;array([ -1.05574295e-01,   3.52748549e-02,  -4.35179251e-02,
&lt;/pre&gt;
&lt;pre&gt;
         4.55405227e-01,  -1.24268073e+01,   3.75411229e+00,
        -2.36116881e-02,  -1.21088069e+00,   2.50740082e-01,
        -1.37702943e-02,  -8.38888137e-01,   7.93577159e-03,
        -3.50952134e-01]&lt;br/&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;em&gt;&lt;span&gt;print(boston.feature_names[np.argsort(lin_reg.coef_)])&lt;br/&gt;####&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;array(['NOX', 'DIS', 'PTRATIO', 'LSTAT', 'CRIM', 'INDUS', 'AGE', 'TAX',&lt;br/&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;       'B', 'ZN', 'RAD', 'CHAS', 'RM'], &lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;dtype='&amp;lt;U7')&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;coef系数越大越正相关,越小越负相关.上面例子里可以看出,特征'NOX'最不想干,特征'RM'最相关.&lt;/p&gt;

&lt;p&gt;有关LinearRegression更多的详细解释和用法请戳&lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LinearRegression.html#sklearn.linear_model.LinearRegression&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt;.&lt;/p&gt;
</description>
<pubDate>Thu, 27 Dec 2018 07:44:00 +0000</pubDate>
<dc:creator>sdu20112013</dc:creator>
<og:description>先从最简单的例子开始,假设我们有一组样本(如下图的一个个黑色的圆点),只有一个特征,如下图,横轴是特征值,纵轴是label。比如横轴是房屋面积,纵轴是房屋价格. 现在我们要做什么呢？我们试图找到一条直</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sdu20112013/p/10178643.html</dc:identifier>
</item>
<item>
<title>聊聊数据库~SQL环境篇 - 鲲逸鹏</title>
<link>http://www.cnblogs.com/dotnetcrazy/p/9887708.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dotnetcrazy/p/9887708.html</guid>
<description>&lt;p&gt;上篇文章：聊聊数据库~开篇 &lt;a href=&quot;https://www.cnblogs.com/dotnetcrazy/p/9690466.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/dotnetcrazy/p/9690466.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本来准备直接开讲NoSQL的（当时开篇就是说的NoSQL）考虑到有些同志可能连MySQL系都没接触过，所以我们2019说数据系的时候预计从&lt;code&gt;MySQL&lt;/code&gt;（穿插&lt;code&gt;MSSQL&lt;/code&gt;）开始，这篇文章就当试水篇，效果好就继续往下写~（这篇偏理论和运维）&lt;/p&gt;
&lt;h2 id=&quot;mariadb-and-mysql&quot;&gt;1.1.MariaDB and MySQL&lt;/h2&gt;
&lt;p&gt;官方文档：&lt;code&gt;https://mariadb.com/kb/zh-cn/mariadb&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;目前主流：&lt;code&gt;MySQL 5.7&lt;/code&gt; or &lt;strong&gt;&lt;code&gt;MariaDB 5.5.x&lt;/code&gt;&lt;/strong&gt;（推荐）&lt;/p&gt;
&lt;p&gt;多一句嘴，&lt;code&gt;MySQL&lt;/code&gt;当年被&lt;code&gt;Oracle&lt;/code&gt;收购后，&lt;code&gt;MySQL之父&lt;/code&gt;觉得靠&lt;code&gt;Oracle&lt;/code&gt;维护&lt;code&gt;MySQL&lt;/code&gt;很不靠谱，然后就跳槽弄了个&lt;code&gt;MariaDB&lt;/code&gt;（很多&lt;code&gt;Oracle&lt;/code&gt;竞争对手扶持着），目前&lt;code&gt;MariaDB&lt;/code&gt;是发展最快的&lt;code&gt;MySQL&lt;/code&gt;分支版本（PS：&lt;code&gt;MySQL&lt;/code&gt;现在是双协议了，大部分公司用的版本都是&lt;code&gt;&amp;lt;=5.7&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;然后得说下迁移问题：&lt;code&gt;MySQL 5.x&lt;/code&gt;到 &lt;code&gt;MariaDB 5.x&lt;/code&gt;基本上是无缝的，&lt;code&gt;MariaDB最新稳定版为：MariaDB 5.5&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MariaDB&lt;/code&gt;与&lt;code&gt;MySQL&lt;/code&gt;兼容性可以查看：&lt;br/&gt;https://mariadb.com/kb/en/library/mariadb-vs-mysql-compatibility&lt;/p&gt;
&lt;p&gt;PS：国内比较火的还有阿里的&lt;code&gt;MySQL分支&lt;/code&gt;：&lt;code&gt;https://github.com/alibaba/AliSQL&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;不谈其他的，咱们看看它们开发的积极程度就知道为什么&lt;code&gt;MariaDB&lt;/code&gt;是主流了&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201812/1127869-20181226114927826-720399690.png&quot; alt=&quot;1.积极.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;mariadb部署&quot;&gt;1.2.MariaDB部署&lt;/h2&gt;
&lt;h3 id=&quot;环境配置和初始化&quot;&gt;1.环境配置和初始化&lt;/h3&gt;
&lt;p&gt;安装很简单，以&lt;code&gt;CentOS&lt;/code&gt;为例：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201812/1127869-20181226231314430-1618955434.png&quot; alt=&quot;1.CentOS.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;systemctl start mariadb.service   # 启动MariaDB
systemctl enable mariadb.service  # 设置开机启动

systemctl stop mariadb.service    # 停止MariaDB
systemctl restart mariadb.service # 重启MariaDB&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PS：Win安装注意这一步：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201812/1127869-20181226231342520-1201124099.png&quot; alt=&quot;1.win.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行文件简单说明：有时候我们 &lt;code&gt;ps aux | grep mysql&lt;/code&gt; 的时候，发现运行的并不是&lt;code&gt;/usr/bin/&lt;/code&gt;下的&lt;code&gt;mysqld&lt;/code&gt;而是&lt;code&gt;mysqld_safe&lt;/code&gt;，那这个&lt;code&gt;mysqld_safe&lt;/code&gt;是啥呢？==&amp;gt; &lt;strong&gt;线程安全的实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MariaDB&lt;/code&gt;的程序组成：&lt;code&gt;ls /usr/bin | grep mysql&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Client：
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;mysql&lt;/code&gt;&lt;/strong&gt; 命令行客户端&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;mysqldump&lt;/code&gt;&lt;/strong&gt; 数据库备份用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;mysqladmin&lt;/code&gt;&lt;/strong&gt; 远程管理工具&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;mysqlbinlog&lt;/code&gt;&lt;/strong&gt; 二进制日志管理工具&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Server：
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;mysqld_safe&lt;/code&gt;&lt;/strong&gt; 线程安全的实例&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mysqld_multi&lt;/code&gt; 多实例&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mysqld&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;mysql_secure_installation&lt;/code&gt;&lt;/strong&gt; 安全初始化工具(记得先启动数据库哦)&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;mysql&lt;/code&gt;的账号由两部分组成：&lt;code&gt;username&lt;/code&gt;@&lt;code&gt;host&lt;/code&gt;，MySQL客户端连接参数：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;-u用户名&lt;/code&gt;：默认为&lt;code&gt;root&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-h服务器主机&lt;/code&gt;：默认为&lt;code&gt;localhost&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;host&lt;/code&gt;用于限制用户可以通过哪些主机连接&lt;/li&gt;
&lt;li&gt;支持通配符：
&lt;ul&gt;&lt;li&gt;&lt;code&gt;%&lt;/code&gt;匹配任意长度的任意字符：172.16.0.0/16 ==&amp;gt; 172.16.%.%&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_&lt;/code&gt;匹配任意单个字符&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-p密码&lt;/code&gt;：默认为&lt;code&gt;空&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;安装完成后运行&lt;code&gt;mysql_secure_installation&lt;/code&gt;来设置密码并初始化&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;很多人安装完成后是这样设置密码的：(&lt;strong&gt;不推荐&lt;/strong&gt;)&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201812/1127869-20181226230835330-601019989.png&quot; alt=&quot;1.不推荐.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正确打开方式：&lt;code&gt;mysql_secure_installation&lt;/code&gt;&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201812/1127869-20181226225313373-1042152945.png&quot; alt=&quot;1.安全初始化1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果允许root远程登录：&lt;code&gt;Disallow root login remotely? [Y/n] n&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201812/1127869-20181226225701877-196565629.png&quot; alt=&quot;1.安全初始化2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安全初始化后登录图示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201812/1127869-20181226230645032-776720431.png&quot; alt=&quot;1.安全初始化后登录.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201812/1127869-20181226232704832-766679019.png&quot; alt=&quot;1.基本信息.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置文件&quot;&gt;2.配置文件&lt;/h3&gt;
&lt;p&gt;以&lt;code&gt;MariaDB 5.5.60&lt;/code&gt;为例：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Linux：配置文件查找顺序(找不到就往下继续)
&lt;ul&gt;&lt;li&gt;&lt;code&gt;/etc/my.cnf&lt;/code&gt; --&amp;gt; &lt;strong&gt;&lt;code&gt;/etc/mysql/conf.d/*.cnf&lt;/code&gt;&lt;/strong&gt; --&amp;gt; &lt;code&gt;~/.my.cnf&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Windows：&lt;code&gt;MariaDB安装目录/data/my.ini&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;PS：一般配置文件都会设置这3个&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 指定数据库文件存放路径
datadir = /home/dnt/data
# 独立表空间: 每一个表都有一个.frm表描述文件，还有一个.ibd文件
innodb_file_per_table=on
# 不对连接进行DNS解析(省时)
skip_name_resolve=on&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其他配置&lt;code&gt;MariaDB&lt;/code&gt;提供了样本：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[dnt@localhost ~] ls /usr/share/mysql/ | grep .cnf
my-huge.cnf            # 超大内存配置参考
my-innodb-heavy-4G.cnf # 4G内存配置参考
my-large.cnf           # 大内存配置
my-medium.cnf          # 中等内存配置
my-small.cnf           # 小内存配置&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PS：&lt;code&gt;thread_concurrency&lt;/code&gt;=&lt;code&gt;CPU数*2&lt;/code&gt;最佳，&lt;strong&gt;修改配置后记得重启数据库&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;远程访问&quot;&gt;3.远程访问&lt;/h3&gt;
&lt;p&gt;1.之前安全初始化的时候把&lt;code&gt;root&lt;/code&gt;禁止远程登录了，现在我们创建一个其他用户&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201812/1127869-20181227153211084-1542804218.png&quot; alt=&quot;1.新增用户.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.给用户权限&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201812/1127869-20181227154329334-308689111.png&quot; alt=&quot;1.给权限.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.防火墙放行指定端口&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201812/1127869-20181227154746690-1949205505.png&quot; alt=&quot;1.防火墙.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.远程客户端测试一下&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201812/1127869-20181227132048960-1914298109.png&quot; alt=&quot;1.成功.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Code如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# root账户登录
mysql -uroot -p

# 新增用户
insert into mysql.user(user,host,password) values(&quot;用户名&quot;,&quot;%&quot;,password(&quot;密码&quot;));

# 刷新设置
flush privileges;

# 分配权限
grant all privileges on 数据库.* to 用户名@&quot;%&quot; identified by &quot;密码&quot;;

# 刷新设置
flush privileges;

# 显示服务状态
systemctl status firewalld

# 添加 --permanent永久生效(没有此参数重启后失效)
firewall-cmd --zone=public --add-port=80/tcp --permanent

# 重新载入
firewall-cmd --reload

# 查看
firewall-cmd --zone= public --query-port=80/tcp
# 删除
firewall-cmd --zone= public --remove-port=80/tcp --permanent&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;SQLServer远程连接&lt;/strong&gt;：&lt;a href=&quot;https://www.cnblogs.com/dunitian/p/5474501.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/dunitian/p/5474501.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;mysql军规58&quot;&gt;MySQL军规（58）&lt;/h2&gt;
&lt;p&gt;文章结尾贴一节&lt;code&gt;58&lt;/code&gt;的&lt;code&gt;MySQL&lt;/code&gt;军规：（&lt;strong&gt;适用于并发量大，数据量大的典型互联网业务&lt;/strong&gt;）&lt;/p&gt;
&lt;h3 id=&quot;基础规范&quot;&gt;1.基础规范&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;表存储引擎必须使用&lt;code&gt;InnoDB&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;表字符集默认使用&lt;code&gt;utf8&lt;/code&gt;，必要时候使用&lt;code&gt;utf8mb4&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;utf8&lt;/code&gt;通用，无乱码风险，汉字3字节，英文1字节&lt;/li&gt;
&lt;li&gt;&lt;code&gt;utf8mb4&lt;/code&gt;是&lt;code&gt;utf8的超集&lt;/code&gt;，存储4字节时使用（eg：表情符号）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;禁止使用存储过程，视图，触发器，Event&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;调试，排错，迁移都比较困难，扩展性较差&lt;/li&gt;
&lt;li&gt;对数据库性能影响较大，互联网业务，能让站点层和服务层干的事情，不要交到数据库层&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;禁止在数据库中存储大文件（eg：照片）
&lt;ul&gt;&lt;li&gt;可以将大文件存储在对象存储系统，数据库中存储路径&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;禁止在线上环境做数据库压力测试
&lt;ul&gt;&lt;li&gt;测试，开发，线上数据库环境必须隔离&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;命名规范&quot;&gt;2.命名规范&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;库名，表名，列名必须用小写，采用下划线分隔&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;abc，Abc，ABC都是给自己埋坑&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;库名，表名，列名必须见名知义，长度不要超过32字符
&lt;ul&gt;&lt;li&gt;tmp，wushan谁TM知道这些库是干嘛的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;库备份必须以bak为前缀，以日期为后缀
&lt;ul&gt;&lt;li&gt;从库必须以-s为后缀&lt;/li&gt;
&lt;li&gt;备库必须以-ss为后缀&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;表设计规范&quot;&gt;3.表设计规范&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;单实例表个数必须控制在&lt;code&gt;2000&lt;/code&gt;个以内&lt;/li&gt;
&lt;li&gt;单表分表个数必须控制在&lt;code&gt;1024&lt;/code&gt;个以内&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;表必须有主键，推荐使用&lt;code&gt;unsigned&lt;/code&gt;整数为主键&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;潜在坑：删除无主键的表，如果是row模式的主从架构，从库会挂住&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;禁止使用外键，如果要保证完整性，应由应用程式实现
&lt;ul&gt;&lt;li&gt;外键使得表之间相互耦合，影响&lt;code&gt;update/delete&lt;/code&gt;等SQL性能&lt;/li&gt;
&lt;li&gt;有可能造成死锁，高并发情况下容易成为数据库瓶颈&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;建议将大字段，访问频度低的字段拆分到单独的表中存储，分离冷热数据
&lt;ul&gt;&lt;li&gt;垂直拆分的依据，尽量把长度较短，访问频率较高的属性放在主表里&lt;/li&gt;
&lt;li&gt;流量大数据量大时，数据访问要有&lt;code&gt;service&lt;/code&gt;层，并且&lt;code&gt;service&lt;/code&gt;层不要通过&lt;code&gt;join&lt;/code&gt;来获取主表和扩展表的属性&lt;/li&gt;
&lt;li&gt;具体可以参考沈剑大牛写的&lt;a href=&quot;https://mp.weixin.qq.com/s/ezD0CWHAr0RteC9yrwqyZA&quot; target=&quot;_blank&quot;&gt;《如何实施数据库垂直拆分》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;列设计规范&quot;&gt;4.列设计规范&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;根据业务区分使用&lt;code&gt;tinyint&lt;/code&gt;/&lt;code&gt;int&lt;/code&gt;/&lt;code&gt;bigint&lt;/code&gt;，分别会占用&lt;code&gt;1&lt;/code&gt;/&lt;code&gt;4&lt;/code&gt;/&lt;code&gt;8&lt;/code&gt;字节&lt;/li&gt;
&lt;li&gt;根据业务区分使用&lt;code&gt;char&lt;/code&gt;/&lt;code&gt;varchar&lt;/code&gt;（PS：没有MSSQL里的&lt;code&gt;nvarchar&lt;/code&gt;）
&lt;ul&gt;&lt;li&gt;字段长度固定，或者长度近似的业务场景，适合使用&lt;code&gt;char&lt;/code&gt;，&lt;strong&gt;能够减少碎片，查询性能高&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;字段长度相差较大，或者更新较少的业务场景，适合使用&lt;code&gt;varchar&lt;/code&gt;，能够&lt;strong&gt;减少空间&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;根据业务区分使用&lt;code&gt;datetime&lt;/code&gt;/&lt;code&gt;timestamp&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;datetime&lt;/code&gt;占用5个字节，&lt;code&gt;timestamp&lt;/code&gt;占用4个字节&lt;/li&gt;
&lt;li&gt;存储年使用&lt;code&gt;year&lt;/code&gt;，存储日期使用&lt;code&gt;date&lt;/code&gt;，存储时间使用&lt;code&gt;datetime&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;必须把字段定义为&lt;code&gt;NOT NULL&lt;/code&gt;并设默认值&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;NULL需要更多的存储空间&lt;/li&gt;
&lt;li&gt;NULL的列使用索引，索引统计，值都更加复杂，MySQL更难优化&lt;/li&gt;
&lt;li&gt;NULL只能采用IS NULL或者IS NOT NULL，而在=/!=/in/not in时有大坑&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用&lt;code&gt;int unsigned&lt;/code&gt;存储&lt;code&gt;IPv4&lt;/code&gt;&lt;/strong&gt;，不要用&lt;code&gt;char(15)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用&lt;code&gt;varchar(20)&lt;/code&gt;存储手机号，不要使用整数&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;手机号不会用来做数学运算&lt;/li&gt;
&lt;li&gt;&lt;code&gt;varchar&lt;/code&gt;可以模糊查询(eg：like ‘138%’)&lt;/li&gt;
&lt;li&gt;牵扯到国家代号，可能出现&lt;code&gt;+、-、()&lt;/code&gt;等字符，eg：&lt;code&gt;+86&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;tinyint&lt;/code&gt;来代替&lt;code&gt;enum&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;enum&lt;/code&gt;增加新值要进行&lt;code&gt;DDL&lt;/code&gt;操作&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;索引规范常用&quot;&gt;5.索引规范（常用）&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;唯一索引使用&lt;code&gt;uniq_字段名&lt;/code&gt;来命名&lt;/li&gt;
&lt;li&gt;非唯一索引使用&lt;code&gt;idx_字段名&lt;/code&gt;来命名&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单张表索引数量建议控制在5个以内&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;互联网高并发业务，太多索引会影响写性能&lt;/li&gt;
&lt;li&gt;异常复杂的查询需求，可以选择&lt;code&gt;ES&lt;/code&gt;等更为适合的方式存储&lt;/li&gt;
&lt;li&gt;&lt;code&gt;生成执行计划时，如果索引太多，会降低性能，并可能导致MySQL选择不到最优索引&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;组合索引字段数不建议超过5个&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;如果5个字段还不能极大缩小row范围，八成是设计有问题&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不建议在频繁更新的字段上建立索引&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非必要不要进行&lt;code&gt;join&lt;/code&gt;查询，如果要进行&lt;code&gt;join&lt;/code&gt;查询，被&lt;code&gt;join&lt;/code&gt;的字段必须类型相同，并建立索引&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;join&lt;/code&gt;字段类型不一致容易导致全表扫描&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;理解组合索引最左前缀原则，避免重复建设索引
&lt;ul&gt;&lt;li&gt;如果建立了&lt;code&gt;(a,b,c)&lt;/code&gt;，相当于建立了&lt;code&gt;(a)&lt;/code&gt;, &lt;code&gt;(a,b)&lt;/code&gt;, &lt;code&gt;(a,b,c)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;sql规范常用&quot;&gt;6.SQL规范（常用）&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;禁止使用&lt;code&gt;select *&lt;/code&gt;，只获取必要字段&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;指定字段能有效利用索引覆盖&lt;/li&gt;
&lt;li&gt;&lt;code&gt;select *&lt;/code&gt;会增加&lt;code&gt;cpu/io/内存/带宽&lt;/code&gt;的消耗&lt;/li&gt;
&lt;li&gt;&lt;code&gt;指定字段查询，在表结构变更时，能保证对应用程序无影响&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;insert&lt;/code&gt;必须指定字段，禁止使用&lt;code&gt;insert into T values()&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;指定字段插入，在表结构变更时，能保证对应用程序无影响&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隐式类型转换会使索引失效，导致全表扫描&lt;/strong&gt;（很重要）&lt;/li&gt;
&lt;li&gt;禁止在&lt;code&gt;where&lt;/code&gt;条件列使用函数或者表达式
&lt;ul&gt;&lt;li&gt;导致不能命中索引，全表扫描&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;禁止负向查询以及&lt;code&gt;%&lt;/code&gt;开头的模糊查询
&lt;ul&gt;&lt;li&gt;导致不能命中索引，全表扫描&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;禁止大表&lt;code&gt;join&lt;/code&gt;和&lt;code&gt;子查询&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;同一个字段上的&lt;code&gt;or&lt;/code&gt;必须改写为&lt;code&gt;in&lt;/code&gt;，&lt;code&gt;in&lt;/code&gt;的值必须少于50个&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;应用程序必须捕获SQL异常（方便定位线上问题）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;课后思考：为什么&lt;code&gt;select uid from user where phone=13811223344&lt;/code&gt;不能命中phone索引？&lt;/p&gt;
&lt;p&gt;课后拓展：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MyISAM与InnoDB两者之间区别与选择
https://www.cnblogs.com/y-rong/p/5309392.html
https://www.cnblogs.com/y-rong/p/8110596.html

了解下Mysql的间隙锁及产生的原因
https://www.cnblogs.com/wt645631686/p/8324671.html

grant授权和revoke回收权限
https://www.cnblogs.com/kevingrace/p/5719536.html

centos7自带数据库MariaDB重启和修改密码
https://blog.csdn.net/shachao888/article/details/50341857

MySQL添加用户、删除用户与授权
https://www.cnblogs.com/wanghetao/p/3806888.html

深度认识 Sharding-JDBC：做最轻量级的数据库中间层
https://my.oschina.net/editorial-story/blog/888650&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 27 Dec 2018 07:08:00 +0000</pubDate>
<dc:creator>鲲逸鹏</dc:creator>
<og:description>上篇文章：聊聊数据库~开篇 传统数据库 本来准备直接开讲NoSQL的（当时开篇就是说的NoSQL）考虑到有些同志可能连MySQL系都没接触过，所以我们2019说数据系的时候预计从 （穿插 ）开始，这篇</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dotnetcrazy/p/9887708.html</dc:identifier>
</item>
<item>
<title>Spring Cloud 终于按捺不住推出了自己的服务网关 Gateway - 先充一个亿试试</title>
<link>http://www.cnblogs.com/xianchonyigeyi/p/10185047.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xianchonyigeyi/p/10185047.html</guid>
<description>
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;
&lt;div class=&quot;image-view&quot; data-width=&quot;500&quot; data-height=&quot;324&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-8294e63fd5e3c260?imageMogr2/auto-orient/strip%7CimageView2/2/w/500/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-8294e63fd5e3c260&quot; data-original-width=&quot;500&quot; data-original-height=&quot;324&quot; data-original-format=&quot;image/jpeg&quot; data-original-filesize=&quot;24126&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Spring 官方最终还是按捺不住推出了自己的网关组件：Spring Cloud Gateway ，相比之前我们使用的 Zuul（1.x） 它有哪些优势呢？Zuul（1.x） 基于 Servlet，使用阻塞 API，它不支持任何长连接，如 WebSockets，Spring Cloud Gateway 使用非阻塞 API，支持 WebSockets，支持限流等新特性&lt;/p&gt;
&lt;p&gt;                                                                                                              Spring Cloud Gateway&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。&lt;/p&gt;
&lt;p&gt;Spring Cloud Gateway 作为 Spring Cloud 生态系统中的网关，目标是替代 Netflix Zuul，其不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/指标，和限流。&lt;/p&gt;
&lt;p&gt;相关概念:&lt;/p&gt;
&lt;p&gt;·Route（路由）：这是网关的基本构建块。它由一个 ID，一个目标 URI，一组断言和一组过滤器定义。如果断言为真，则路由匹配。&lt;/p&gt;
&lt;p&gt;·Predicate（断言）：这是一个 Java 8 的 Predicate。输入类型是一个 ServerWebExchange。我们可以使用它来匹配来自 HTTP 请求的任何内容，例如 headers 或参数。&lt;/p&gt;
&lt;p&gt;·Filter（过滤器）：这是org.springframework.cloud.gateway.filter.GatewayFilter的实例，我们可以使用它修改请求和响应。&lt;/p&gt;
&lt;p&gt;工作流程：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;443&quot; data-height=&quot;595&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-42d02772d6f0229f?imageMogr2/auto-orient/strip%7CimageView2/2/w/443/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-42d02772d6f0229f&quot; data-original-width=&quot;443&quot; data-original-height=&quot;595&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;14368&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;客户端向 Spring Cloud Gateway 发出请求。如果 Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到 Gateway Web Handler。Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。&lt;/p&gt;
&lt;p&gt;过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（“pre”）或之后（“post”）执行业务逻辑。&lt;/p&gt;
&lt;p&gt;Spring Cloud Gateway 的特征：&lt;/p&gt;
&lt;p&gt;·基于 Spring Framework 5，Project Reactor 和 Spring Boot 2.0&lt;/p&gt;
&lt;p&gt;·动态路由&lt;/p&gt;
&lt;p&gt;·Predicates 和 Filters 作用于特定路由&lt;/p&gt;
&lt;p&gt;·集成 Hystrix 断路器&lt;/p&gt;
&lt;p&gt;·集成 Spring Cloud DiscoveryClient&lt;/p&gt;
&lt;p&gt;·易于编写的 Predicates 和 Filters&lt;/p&gt;
&lt;p&gt;·限流&lt;/p&gt;
&lt;p&gt;·路径重写&lt;/p&gt;
&lt;p&gt;                                                                                                                 快速上手&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;Spring Cloud Gateway 网关路由有两种配置方式：&lt;/p&gt;
&lt;p&gt;·在配置文件 yml 中配置&lt;/p&gt;
&lt;p&gt;·通过@Bean自定义 RouteLocator，在启动主类 Application 中配置&lt;/p&gt;
&lt;p&gt;这两种方式是等价的，建议使用 yml 方式进配置。&lt;/p&gt;
&lt;p&gt;使用 Spring Cloud Finchley 版本，Finchley 版本依赖于 Spring Boot 2.0.6.RELEASE。&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;597&quot; data-height=&quot;303&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-a90bf4d740d62ffc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/597/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-a90bf4d740d62ffc.png&quot; data-original-width=&quot;597&quot; data-original-height=&quot;303&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;27041&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;608&quot; data-height=&quot;84&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-9e6434ebe87798ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/608/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-9e6434ebe87798ba.png&quot; data-original-width=&quot;608&quot; data-original-height=&quot;84&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;6028&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;添加项目需要使用的依赖包&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;597&quot; data-height=&quot;78&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-ec253e04756594d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/597/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-ec253e04756594d0.png&quot; data-original-width=&quot;597&quot; data-original-height=&quot;78&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;7219&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Spring Cloud Gateway 是使用 netty+webflux 实现因此不需要再引入 web 模块。&lt;/p&gt;
&lt;p&gt;我们先来测试一个最简单的请求转发。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;598&quot; data-height=&quot;172&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-cd0a1ebdbdde874d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/598/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-cd0a1ebdbdde874d.png&quot; data-original-width=&quot;598&quot; data-original-height=&quot;172&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;9406&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;各字段含义如下：&lt;/p&gt;
&lt;p&gt;id：我们自定义的路由 ID，保持唯一&lt;/p&gt;
&lt;p&gt;uri：目标服务地址&lt;/p&gt;
&lt;p&gt;predicates：路由条件，Predicate 接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）。&lt;/p&gt;
&lt;p&gt;filters：过滤规则，本示例暂时没用。&lt;/p&gt;
&lt;p&gt;上面这段配置的意思是，配置了一个 id 为 neo_route 的路由规则，当访问地址http://localhost:8080/spring-cloud时会自动转发到地址：http://www.ityouknow.com/spring-cloud。配置完成启动项目即可在浏览器访问进行测试&lt;/p&gt;
&lt;p&gt;转发功能同样可以通过代码来实现，我们可以在启动类 GateWayApplication 中添加方法 customRouteLocator() 来定制转发规则。&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;599&quot; data-height=&quot;270&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-b8ba9672852c3e33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/599/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-b8ba9672852c3e33.png&quot; data-original-width=&quot;599&quot; data-original-height=&quot;270&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;21144&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;上面配置了一个 id 为 path_route 的路由，当访问地址http://localhost:8080/about时会自动转发到地址：http://www.ityouknow.com/about和上面的转发效果一样，只是这里转发的是以项目地址/about格式的请求地址。&lt;/p&gt;
&lt;p&gt;上面两个示例中 uri 都是指向了我的个人网站，在实际项目使用中可以将 uri 指向对外提供服务的项目地址，统一对外输出接口。&lt;/p&gt;
&lt;p&gt;以上便是 Spring Cloud Gateway 最简单的两个请求示例，Spring Cloud Gateway 还有更多实用的功能接下来我们一一介绍。&lt;/p&gt;
&lt;p&gt;                                                                                                                路由规则&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;Spring Cloud Gateway 的功能很强大，我们仅仅通过 Predicates 的设计就可以看出来，前面我们只是使用了 predicates 进行了简单的条件匹配，其实 Spring Cloud Gataway 帮我们内置了很多 Predicates 功能。&lt;/p&gt;
&lt;p&gt;Spring Cloud Gateway 是通过 Spring WebFlux 的HandlerMapping做为底层支持来匹配到转发路由，Spring Cloud Gateway 内置了很多 Predicates 工厂，这些 Predicates 工厂通过不同的 HTTP 请求参数来匹配，多个 Predicates 工厂可以组合使用。&lt;/p&gt;
&lt;p&gt;Predicate 介绍&lt;/p&gt;
&lt;p&gt;Predicate 来源于 Java 8，是 Java 8 中引入的一个函数，Predicate 接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）。可以用于接口请求参数校验、判断新老数据是否有变化需要进行更新操作。and--与、or--或、negate--非&lt;/p&gt;
&lt;p&gt;在 Spring Cloud Gateway 中 Spring 利用 Predicate 的特性实现了各种路由匹配规则，有通过 Header、请求参数等不同的条件来进行作为条件匹配到对应的路由。网上有一张图总结了 Spring Cloud 内置的几种 Predicate 的实现。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;988&quot; data-height=&quot;515&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-1964cd371386c84c?imageMogr2/auto-orient/strip%7CimageView2/2/w/988/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-1964cd371386c84c&quot; data-original-width=&quot;988&quot; data-original-height=&quot;515&quot; data-original-format=&quot;image/jpeg&quot; data-original-filesize=&quot;79338&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;说白了 Predicate 就是为了实现一组匹配规则，方便让请求过来找到对应的 Route 进行处理，接下来我们接下 Spring Cloud GateWay 内置几种 Predicate 的使用。&lt;/p&gt;
&lt;p&gt;通过时间匹配&lt;/p&gt;
&lt;p&gt;Predicate 支持设置一个时间，在请求进行转发的时候，可以通过判断在这个时间之前或者之后进行转发。比如我们现在设置只有在2019年1月1日才会转发到我的网站，在这之前不进行转发，我就可以这样配置：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;598&quot; data-height=&quot;143&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-56a018617b6f6e5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/598/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-56a018617b6f6e5e.png&quot; data-original-width=&quot;598&quot; data-original-height=&quot;143&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;9609&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Spring 是通过 ZonedDateTime 来对时间进行的对比，ZonedDateTime 是 Java 8 中日期时间功能里，用于表示带时区的日期与时间信息的类，ZonedDateTime 支持通过时区来设置时间，中国的时区是：Asia/Shanghai。&lt;/p&gt;
&lt;p&gt;After Route Predicate 是指在这个时间之后的请求都转发到目标地址。上面的示例是指，请求时间在 2018年1月20日6点6分6秒之后的所有请求都转发到地址http://ityouknow.com。+08:00是指时间和UTC时间相差八个小时，时间地区为Asia/Shanghai。&lt;/p&gt;
&lt;p&gt;添加完路由规则之后，访问地址http://localhost:8080会自动转发到http://ityouknow.com。&lt;/p&gt;
&lt;p&gt;Before Route Predicate 刚好相反，在某个时间之前的请求的请求都进行转发。我们把上面路由规则中的 After 改为 Before，如下：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;599&quot; data-height=&quot;140&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-1f2aa084ab18322c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/599/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-1f2aa084ab18322c.png&quot; data-original-width=&quot;599&quot; data-original-height=&quot;140&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;9627&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;就表示在这个时间之前可以进行路由，在这时间之后停止路由，修改完之后重启项目再次访问地址http://localhost:8080，页面会报 404 没有找到地址。&lt;/p&gt;
&lt;p&gt;除过在时间之前或者之后外，Gateway 还支持限制路由请求在某一个时间段范围内，可以使用 Between Route Predicate 来实现。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;597&quot; data-height=&quot;141&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-9c642fc1e6a034eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/597/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-9c642fc1e6a034eb.png&quot; data-original-width=&quot;597&quot; data-original-height=&quot;141&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;9887&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这样设置就意味着在这个时间段内可以匹配到此路由，超过这个时间段范围则不会进行匹配。通过时间匹配路由的功能很酷，可以用在限时抢购的一些场景中。&lt;/p&gt;
&lt;p&gt;通过 Cookie 匹配&lt;/p&gt;
&lt;p&gt;Cookie Route Predicate 可以接收两个参数，一个是 Cookie name ,一个是正则表达式，路由规则会通过获取对应的 Cookie name 值和正则表达式去匹配，如果匹配上就会执行路由，如果没有匹配上则不执行。&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;598&quot; data-height=&quot;142&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-0bb2ac16f77fc6b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/598/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-0bb2ac16f77fc6b2.png&quot; data-original-width=&quot;598&quot; data-original-height=&quot;142&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;8400&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;使用 curl 测试，命令行输入:&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;596&quot; data-height=&quot;30&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-af506eb79a1acc14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/596/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-af506eb79a1acc14.png&quot; data-original-width=&quot;596&quot; data-original-height=&quot;30&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;3091&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;则会返回页面代码，如果去掉--cookie &quot;ityouknow=kee.e&quot;，后台汇报 404 错误。&lt;/p&gt;
&lt;p&gt;通过 Header 属性匹配&lt;/p&gt;
&lt;p&gt;Header Route Predicate 和 Cookie Route Predicate 一样，也是接收 2 个参数，一个 header 中属性名称和一个正则表达式，这个属性值和正则表达式匹配则执行。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;596&quot; data-height=&quot;141&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-413637d024743bad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/596/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-413637d024743bad.png&quot; data-original-width=&quot;596&quot; data-original-height=&quot;141&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;8267&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;使用 curl 测试，命令行输入:&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;598&quot; data-height=&quot;31&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-7da8896bb10bdb44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/598/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-7da8896bb10bdb44.png&quot; data-original-width=&quot;598&quot; data-original-height=&quot;31&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;3042&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;则返回页面代码证明匹配成功。将参数-H &quot;X-Request-Id:666666&quot;改为-H &quot;X-Request-Id:neo&quot;再次执行时返回404证明没有匹配。&lt;/p&gt;
&lt;p&gt;通过 Host 匹配&lt;/p&gt;
&lt;p&gt;Host Route Predicate 接收一组参数，一组匹配的域名列表，这个模板是一个 ant 分隔的模板，用.号作为分隔符。它通过参数中的主机地址作为匹配规则。&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;598&quot; data-height=&quot;140&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-ee4c25e7a023e6e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/598/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-ee4c25e7a023e6e5.png&quot; data-original-width=&quot;598&quot; data-original-height=&quot;140&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;8269&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;使用 curl 测试，命令行输入:&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;597&quot; data-height=&quot;42&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-623537efdf45e845.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/597/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-623537efdf45e845.png&quot; data-original-width=&quot;597&quot; data-original-height=&quot;42&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;5494&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;经测试以上两种 host 均可匹配到 host_route 路由，去掉 host 参数则会报 404 错误。&lt;/p&gt;
&lt;p&gt;通过请求方式匹配&lt;/p&gt;
&lt;p&gt;可以通过是 POST、GET、PUT、DELETE 等不同的请求方式来进行路由。&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;597&quot; data-height=&quot;142&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-e7c09011601fb33a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/597/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-e7c09011601fb33a.png&quot; data-original-width=&quot;597&quot; data-original-height=&quot;142&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;7754&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;使用 curl 测试，命令行输入:&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;597&quot; data-height=&quot;45&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-d067166958955e2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/597/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-d067166958955e2f.png&quot; data-original-width=&quot;597&quot; data-original-height=&quot;45&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;3532&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;测试返回页面代码，证明匹配到路由，我们再以 POST 的方式请求测试。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;598&quot; data-height=&quot;44&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-1927a6941865ea71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/598/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-1927a6941865ea71.png&quot; data-original-width=&quot;598&quot; data-original-height=&quot;44&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;3868&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;返回 404 没有找到，证明没有匹配上路由&lt;/p&gt;
&lt;p&gt;通过请求路径匹配&lt;/p&gt;
&lt;p&gt;Path Route Predicate 接收一个匹配路径的参数来判断是否走路由。&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;598&quot; data-height=&quot;139&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-da8d090d95f6aa65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/598/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-da8d090d95f6aa65.png&quot; data-original-width=&quot;598&quot; data-original-height=&quot;139&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;8220&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;如果请求路径符合要求，则此路由将匹配，例如：/foo/1 或者 /foo/bar。&lt;/p&gt;
&lt;p&gt;使用 curl 测试，命令行输入:&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;597&quot; data-height=&quot;60&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-273957ff29ff6e03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/597/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-273957ff29ff6e03.png&quot; data-original-width=&quot;597&quot; data-original-height=&quot;60&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;5392&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;经过测试第一和第二条命令可以正常获取到页面返回值，最后一个命令报404，证明路由是通过指定路由来匹配。&lt;/p&gt;
&lt;p&gt;通过请求参数匹配&lt;/p&gt;
&lt;p&gt;Query Route Predicate 支持传入两个参数，一个是属性名一个为属性值，属性值可以是正则表达式。&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;598&quot; data-height=&quot;140&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-66a695e862f96072.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/598/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-66a695e862f96072.png&quot; data-original-width=&quot;598&quot; data-original-height=&quot;140&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;7931&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这样配置，只要请求中包含 smile 属性的参数即可匹配路由。&lt;/p&gt;
&lt;p&gt;使用 curl 测试，命令行输入:&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;596&quot; data-height=&quot;29&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-bd14e7736c695c61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/596/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-bd14e7736c695c61.png&quot; data-original-width=&quot;596&quot; data-original-height=&quot;29&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;2414&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;经过测试发现只要请求汇总带有 smile 参数即会匹配路由，不带 smile 参数则不会匹配。&lt;/p&gt;
&lt;p&gt;还可以将 Query 的值以键值对的方式进行配置，这样在请求过来时会对属性值和正则进行匹配，匹配上才会走路由。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;598&quot; data-height=&quot;140&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-5436b5f2138bd28b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/598/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-5436b5f2138bd28b.png&quot; data-original-width=&quot;598&quot; data-original-height=&quot;140&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;8062&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这样只要当请求中包含 keep 属性并且参数值是以 pu 开头的长度为三位的字符串才会进行匹配和路由。&lt;/p&gt;
&lt;p&gt;使用 curl 测试，命令行输入:&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;597&quot; data-height=&quot;30&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-19db2ba7be27b65f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/597/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-19db2ba7be27b65f.png&quot; data-original-width=&quot;597&quot; data-original-height=&quot;30&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;2148&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;测试可以返回页面代码，将 keep 的属性值改为 pubx 再次访问就会报 404,证明路由需要匹配正则表达式才会进行路由。&lt;/p&gt;
&lt;p&gt;通过请求 ip 地址进行匹配&lt;/p&gt;
&lt;p&gt;Predicate 也支持通过设置某个 ip 区间号段的请求才会路由，RemoteAddr Route Predicate 接受 cidr 符号(IPv4 或 IPv6 )字符串的列表(最小大小为1)，例如 192.168.0.1/16 (其中 192.168.0.1 是 IP 地址，16 是子网掩码)。&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;596&quot; data-height=&quot;140&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-f1d4e5f4a8b73149.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/596/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-f1d4e5f4a8b73149.png&quot; data-original-width=&quot;596&quot; data-original-height=&quot;140&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;8801&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;可以将此地址设置为本机的 ip 地址进行测试。&lt;/p&gt;
&lt;p&gt;果请求的远程地址是 192.168.1.10，则此路由将匹配。&lt;/p&gt;
&lt;p&gt;组合使用&lt;/p&gt;
&lt;p&gt;上面为了演示各个 Predicate 的使用，我们是单个单个进行配置测试，其实可以将各种 Predicate 组合起来一起使用。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;598&quot; data-height=&quot;252&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-8144fd187ad495bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/598/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-8144fd187ad495bb.png&quot; data-original-width=&quot;598&quot; data-original-height=&quot;252&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;17672&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;各种 Predicates 同时存在于同一个路由时，请求必须同时满足所有的条件才被这个路由匹配。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;一个请求满足多个路由的谓词条件时，请求只会被首个成功匹配的路由转发&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结&lt;/p&gt;
&lt;p&gt;通过今天的学习发现 Spring Cloud Gateway 使用非常的灵活，可以根据不同的情况来进行路由分发，在实际项目中可以自由组合使用。同时 Spring Cloud Gateway 还有更多很酷的功能，比如 Filter 、熔断和限流等，下次我们继续学习 Spring Cloud Gateway 的高级功能。&lt;/p&gt;
</description>
<pubDate>Thu, 27 Dec 2018 07:04:00 +0000</pubDate>
<dc:creator>先充一个亿试试</dc:creator>
<og:description>Spring 官方最终还是按捺不住推出了自己的网关组件：Spring Cloud Gateway ，相比之前我们使用的 Zuul（1.x） 它有哪些优势呢？Zuul（1.x） 基于 Servlet，使</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xianchonyigeyi/p/10185047.html</dc:identifier>
</item>
<item>
<title>使用Server Trigger保护重要数据库对象 - 东山絮柳仔</title>
<link>http://www.cnblogs.com/xuliuzai/p/10185033.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuliuzai/p/10185033.html</guid>
<description>&lt;h3&gt;一 .Server Trigger的简单介绍&lt;/h3&gt;
&lt;p&gt;在SQL Server数据库中，Server Trigger 是一种特殊类型的存储过程&lt;strong&gt;，&lt;/strong&gt;它可以对特定表、视图或存储中的必然事件自动响应，不由用户调用。创建触发器时对其进行定义，以便在对特定的数据库对象作特定类型的修改时执行，根据触发器定义的动作做出反应。&lt;/p&gt;
&lt;p&gt;其主要被用在保持数据库对象的完整性方面。例如，防止数据库中已建好的表和存储过程被更改或删除。此外还可以 进行更改历史记录的追踪，查看表或存储被修改的记录。&lt;/p&gt;
&lt;p&gt;Server Trigger比Database Trigger所管控的范围更广，可以管控Server下的所有Database的对象。&lt;/p&gt;

&lt;h3&gt;二. 主要表 及创建脚本&lt;/h3&gt;
&lt;p&gt;表Protected_Objects ，主要用来存储被保护的数据库对象，例如 表和存储过程。 字段 ActiveFlag设置为Y时有效，N是无效。&lt;/p&gt;
&lt;p&gt;有新的数据库对象创建，最自动Insert一笔数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Protected_Objects&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;(
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;ServerIP&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;ServerName&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;DBName&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;ObjName&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Objtype&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Creator&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;ActiveFlag&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;TransDateTime&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;datetime&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;
) &lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;表DBTrigger_Log，主要存储数据库对象变动记录。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;122&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;DBTrigger_Log&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;(
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;ServerIP&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;ServerName&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;DBName&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;ObjectName&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;ObjectType&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;EventType&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;HostName&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;128&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;AppName&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;128&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;EventData&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;xml&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;TransDateTime&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;datetime&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Flag&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; ((&lt;span&gt;0&lt;/span&gt;&lt;span&gt;))
) &lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; TEXTIMAGE_ON &lt;span&gt;[&lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;SET&lt;/span&gt; ANSI_PADDING &lt;span&gt;OFF&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;EXEC&lt;/span&gt; sys.sp_addextendedproperty &lt;span&gt;@name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MS_Description&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@value&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;服务器IP&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , &lt;span&gt;@level0type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SCHEMA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level0name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level1type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level1name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DBTrigger_Log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level2type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;COLUMN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level2name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ServerIP&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;EXEC&lt;/span&gt; sys.sp_addextendedproperty &lt;span&gt;@name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MS_Description&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@value&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;服务器名称&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , &lt;span&gt;@level0type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SCHEMA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level0name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level1type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level1name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DBTrigger_Log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level2type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;COLUMN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level2name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ServerName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;EXEC&lt;/span&gt; sys.sp_addextendedproperty &lt;span&gt;@name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MS_Description&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@value&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;数据库名称&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , &lt;span&gt;@level0type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SCHEMA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level0name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level1type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level1name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DBTrigger_Log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level2type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;COLUMN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level2name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DBName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;EXEC&lt;/span&gt; sys.sp_addextendedproperty &lt;span&gt;@name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MS_Description&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@value&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;对象名称&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , &lt;span&gt;@level0type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SCHEMA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level0name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level1type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level1name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DBTrigger_Log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level2type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;COLUMN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level2name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ObjectName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;EXEC&lt;/span&gt; sys.sp_addextendedproperty &lt;span&gt;@name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MS_Description&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@value&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;对象类型&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , &lt;span&gt;@level0type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SCHEMA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level0name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level1type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level1name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DBTrigger_Log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level2type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;COLUMN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level2name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ObjectType&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;EXEC&lt;/span&gt; sys.sp_addextendedproperty &lt;span&gt;@name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MS_Description&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@value&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;事件类型&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , &lt;span&gt;@level0type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SCHEMA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level0name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level1type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level1name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DBTrigger_Log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level2type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;COLUMN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level2name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;EventType&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;EXEC&lt;/span&gt; sys.sp_addextendedproperty &lt;span&gt;@name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MS_Description&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@value&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;终端机器名&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , &lt;span&gt;@level0type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SCHEMA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level0name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level1type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level1name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DBTrigger_Log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level2type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;COLUMN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level2name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;HostName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;EXEC&lt;/span&gt; sys.sp_addextendedproperty &lt;span&gt;@name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MS_Description&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@value&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;名称&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , &lt;span&gt;@level0type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SCHEMA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level0name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level1type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level1name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DBTrigger_Log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level2type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;COLUMN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level2name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;AppName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;EXEC&lt;/span&gt; sys.sp_addextendedproperty &lt;span&gt;@name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MS_Description&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@value&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;触发事件xml&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , &lt;span&gt;@level0type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SCHEMA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level0name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level1type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level1name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DBTrigger_Log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level2type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;COLUMN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level2name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;EventData&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;EXEC&lt;/span&gt; sys.sp_addextendedproperty &lt;span&gt;@name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MS_Description&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@value&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;发生时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , &lt;span&gt;@level0type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SCHEMA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level0name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level1type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level1name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DBTrigger_Log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level2type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;COLUMN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level2name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TransDateTime&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;EXEC&lt;/span&gt; sys.sp_addextendedproperty &lt;span&gt;@name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MS_Description&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@value&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;是否上传&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , &lt;span&gt;@level0type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SCHEMA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level0name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level1type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level1name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DBTrigger_Log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level2type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;COLUMN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level2name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Flag&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;三. 创建Server Trigger的脚本&lt;/h3&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;175&quot;&gt;
&lt;pre&gt;
&lt;span&gt;USE&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;master&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;***** Object:  DdlTrigger [ServerDBTrigger_ProtectObjects]    Script Date: 2018/12/27 13:36:00 *****&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;SET&lt;/span&gt; ANSI_NULLS &lt;span&gt;ON&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;SET&lt;/span&gt; QUOTED_IDENTIFIER &lt;span&gt;ON&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;


&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;###########################################################################################
*Program*:            &amp;lt;DB Trigger&amp;gt;
*Description*:        &amp;lt;Protect SQL key objects&amp;gt;
*programer*:         &amp;lt;&amp;gt;
*Date*:             2015-12-03

---0001  2015-12-03  11:12      第一阶段期间只保留修改记录，暂时不阻止（不RollBack） 
---0002  2015-12-03  15:32      增加发邮件的功能.  
---0003  2015-12-04  14:20      出现set ANSI_PADDING Off后，还有（如果是script出来的表，其中有索引约束等，
---                             需要Alter表时，就会报错。）代码时，@xEvent.query会报错。
##############################################################################################&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TRIGGER&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;ServerDBTrigger_DBA_ProtectObjects&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;ON&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;&lt;span&gt; SERVER
&lt;/span&gt;&lt;span&gt;FOR&lt;/span&gt;&lt;span&gt; DROP_TABLE,DROP_PROCEDURE,DROP_VIEW,DROP_FUNCTION, 
CREATE_TABLE,CREATE_PROCEDURE,CREATE_VIEW,CREATE_FUNCTION,
ALTER_PROCEDURE,ALTER_VIEW,ALTER_TABLE,ALTER_FUNCTION,RENAME

&lt;/span&gt;&lt;span&gt;AS&lt;/span&gt;
  &lt;span&gt;SET&lt;/span&gt; NOCOUNT &lt;span&gt;ON&lt;/span&gt;&lt;span&gt; ;
  &lt;/span&gt;&lt;span&gt;BEGIN&lt;/span&gt;&lt;span&gt; TRY

    &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@ServerIP&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@ServerName&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@AppName&lt;/span&gt; &lt;span&gt;nvarchar&lt;/span&gt;(&lt;span&gt;128&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@HostName&lt;/span&gt; &lt;span&gt;nvarchar&lt;/span&gt;(&lt;span&gt;128&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@DBName&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@ObjectName&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@ObjectType&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@EventType&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@ObjectAction&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@xEvent&lt;/span&gt;&lt;span&gt; XML
    &lt;/span&gt;&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@xEvent&lt;/span&gt; &lt;span&gt;=&lt;/span&gt;&lt;span&gt; EVENTDATA()
    &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--------------------0003 start ----------&lt;/span&gt;
    &lt;span&gt;--&lt;/span&gt;&lt;span&gt;Set @DBName=CONVERT(VARCHAR(100),@xEvent.query('data(/EVENT_INSTANCE/DatabaseName)'))&lt;/span&gt;
    &lt;span&gt;--&lt;/span&gt;&lt;span&gt;Set @ObjectName=CONVERT(VARCHAR(100),@xEvent.query('data(/EVENT_INSTANCE/ObjectName)'))&lt;/span&gt;
    &lt;span&gt;--&lt;/span&gt;&lt;span&gt;Set @ObjectType=CONVERT(VARCHAR(100),@xEvent.query('data(/EVENT_INSTANCE/ObjectType)'))&lt;/span&gt;
    &lt;span&gt;--&lt;/span&gt;&lt;span&gt;Set @ObjectAction=CONVERT(VARCHAR(100),@xEvent.query('data(/EVENT_INSTANCE/EventType)'))&lt;/span&gt;
    &lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@EventData&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;MAX&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;@EventData&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;CONVERT&lt;/span&gt;(&lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;MAX&lt;/span&gt;),&lt;span&gt;@xEvent&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@DBName&lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;SUBSTRING&lt;/span&gt; (&lt;span&gt;@EventData&lt;/span&gt;, &lt;span&gt;CHARINDEX&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;DatabaseName&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@EventData&lt;/span&gt;)&lt;span&gt;+&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;, &lt;span&gt;CHARINDEX&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/DatabaseName&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@EventData&lt;/span&gt;)&lt;span&gt;-&lt;/span&gt;&lt;span&gt;CHARINDEX&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;DatabaseName&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@EventData&lt;/span&gt;)&lt;span&gt;-&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@ObjectName&lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;SUBSTRING&lt;/span&gt; (&lt;span&gt;@EventData&lt;/span&gt;, &lt;span&gt;CHARINDEX&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;ObjectName&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@EventData&lt;/span&gt;)&lt;span&gt;+&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;, &lt;span&gt;CHARINDEX&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/ObjectName&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@EventData&lt;/span&gt;)&lt;span&gt;-&lt;/span&gt;&lt;span&gt;CHARINDEX&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;ObjectName&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@EventData&lt;/span&gt;)&lt;span&gt;-&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@ObjectType&lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;SUBSTRING&lt;/span&gt; (&lt;span&gt;@EventData&lt;/span&gt;, &lt;span&gt;CHARINDEX&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;ObjectType&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@EventData&lt;/span&gt;)&lt;span&gt;+&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;, &lt;span&gt;CHARINDEX&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/ObjectType&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@EventData&lt;/span&gt;)&lt;span&gt;-&lt;/span&gt;&lt;span&gt;CHARINDEX&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;ObjectType&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@EventData&lt;/span&gt;)&lt;span&gt;-&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@ObjectAction&lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;SUBSTRING&lt;/span&gt; (&lt;span&gt;@EventData&lt;/span&gt;, &lt;span&gt;CHARINDEX&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;EventType&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@EventData&lt;/span&gt;)&lt;span&gt;+&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;, &lt;span&gt;CHARINDEX&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/EventType&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@EventData&lt;/span&gt;)&lt;span&gt;-&lt;/span&gt;&lt;span&gt;CHARINDEX&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;EventType&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@EventData&lt;/span&gt;)&lt;span&gt;-&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@EventType&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;SUBSTRING&lt;/span&gt;(&lt;span&gt;@EventData&lt;/span&gt;, &lt;span&gt;CHARINDEX&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;EventType&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@EventData&lt;/span&gt;)&lt;span&gt;+&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;, &lt;span&gt;CHARINDEX&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/EventType&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@EventData&lt;/span&gt;)&lt;span&gt;-&lt;/span&gt;&lt;span&gt;CHARINDEX&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;EventType&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@EventData&lt;/span&gt;)&lt;span&gt;-&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----------0003 end ---------------&lt;/span&gt;
    &lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;@HostName&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;HOST_NAME&lt;/span&gt;(),&lt;span&gt;@AppName&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;APP_NAME&lt;/span&gt;&lt;span&gt;()
    &lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@ServerName&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@@SERVERNAME&lt;/span&gt;
    &lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@ServerIP&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;MIN&lt;/span&gt;(LOCAL_NET_ADDRESS) &lt;span&gt;FROM&lt;/span&gt; SYS.DM_EXEC_CONNECTIONS &lt;span&gt;WHERE&lt;/span&gt; LOCAL_NET_ADDRESS &lt;span&gt;IS&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;
    &lt;span&gt;IF&lt;/span&gt; &lt;span&gt;EXISTS&lt;/span&gt;(&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;TOP&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; ObjName &lt;span&gt;FROM&lt;/span&gt; Protected_Objects &lt;span&gt;WITH&lt;/span&gt;(NOLOCK) &lt;span&gt;WHERE&lt;/span&gt; ServerName &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@@SERVERNAME&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; DBName&lt;span&gt;=&lt;/span&gt;&lt;span&gt;@DBName&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; ObjName&lt;span&gt;=&lt;/span&gt;&lt;span&gt;@ObjectName&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; ActiveFlag&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;BEGIN&lt;/span&gt;
        &lt;span&gt;IF&lt;/span&gt; (&lt;span&gt;@ObjectName&lt;/span&gt; &lt;span&gt;LIKE&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;TMP%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;span&gt;OR&lt;/span&gt; (&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;@ObjectAction LIKE 'ALTER%' AND &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;@ObjectName&lt;/span&gt; &lt;span&gt;LIKE&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;[_]%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
         &lt;/span&gt;&lt;span&gt;BEGIN&lt;/span&gt;
            &lt;span&gt;INSERT&lt;/span&gt;  &lt;span&gt;INTO&lt;/span&gt;&lt;span&gt;  DBTrigger_Log
                                ( ServerIP ,ServerName ,DBName ,ObjectName ,ObjectType,EventType ,HostName , AppName ,&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;EventData&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; ,TransDateTime)
                        &lt;/span&gt;&lt;span&gt;VALUES&lt;/span&gt;  ( &lt;span&gt;@ServerIP&lt;/span&gt; ,&lt;span&gt;@ServerName&lt;/span&gt; , &lt;span&gt;@DBName&lt;/span&gt; , &lt;span&gt;@ObjectName&lt;/span&gt; ,&lt;span&gt;@ObjectType&lt;/span&gt; ,&lt;span&gt;@EventType&lt;/span&gt;,&lt;span&gt;@HostName&lt;/span&gt; ,&lt;span&gt;@AppName&lt;/span&gt; ,&lt;span&gt;@EventData&lt;/span&gt; , &lt;span&gt;GETDATE&lt;/span&gt;&lt;span&gt;())
         &lt;/span&gt;&lt;span&gt;END&lt;/span&gt;
        &lt;span&gt;ELSE&lt;/span&gt; 
         &lt;span&gt;BEGIN&lt;/span&gt; 
         
            &lt;span&gt;--&lt;/span&gt;&lt;span&gt;---------------0001 start ---&lt;/span&gt;
            &lt;span&gt;INSERT&lt;/span&gt;  &lt;span&gt;INTO&lt;/span&gt;&lt;span&gt;  DBTrigger_Log
                                ( ServerIP ,ServerName ,DBName ,ObjectName ,ObjectType,EventType ,HostName , AppName ,&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;EventData&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; ,TransDateTime)
                        &lt;/span&gt;&lt;span&gt;VALUES&lt;/span&gt;  ( &lt;span&gt;@ServerIP&lt;/span&gt; ,&lt;span&gt;@ServerName&lt;/span&gt; , &lt;span&gt;@DBName&lt;/span&gt; , &lt;span&gt;@ObjectName&lt;/span&gt; ,&lt;span&gt;@ObjectType&lt;/span&gt; ,&lt;span&gt;@EventType&lt;/span&gt;,&lt;span&gt;@HostName&lt;/span&gt; ,&lt;span&gt;@AppName&lt;/span&gt; ,&lt;span&gt;@EventData&lt;/span&gt; , &lt;span&gt;GETDATE&lt;/span&gt;&lt;span&gt;())
            
            &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;Rollback TRANSACTION&lt;/span&gt;
            &lt;span&gt;--&lt;/span&gt;&lt;span&gt;---------------end --------&lt;/span&gt;
            &lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----------0002 begin ----------------&lt;/span&gt;
              
            &lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@Subject&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;nvarchar&lt;/span&gt;(&lt;span&gt;200&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@Body&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;nvarchar&lt;/span&gt;(&lt;span&gt;MAX&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@SPName&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;nvarchar&lt;/span&gt;(&lt;span&gt;MAX&lt;/span&gt;&lt;span&gt;)
            
            &lt;/span&gt;&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@Subject&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ServerDBTrigger-重要!;ServerIP:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;@ServerIP&lt;/span&gt;
                        &lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@SPName&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;
                        &lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@Body&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;Dear All,&amp;lt;br&amp;gt; &amp;lt;br&amp;gt;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;ServerName:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;@ServerName&lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt; ; ServerIP:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;@ServerIP&lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;上的object已被改动,请及时检查!!!
                       &amp;lt;br&amp;gt;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;You can get detail information from DBA_DBTrigger_Log. &amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;table border=1 bgcolor=#aaff11&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; 
                        &lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@Body&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@Body&lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;tr bgcolor=#ffaa11&amp;gt;&amp;lt;td&amp;gt;ServerName&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;ServerIP&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;DBName&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;EventType&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;ObjectName&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;ObjectType&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;HostName &amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;TransDateTime&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
                        &lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@SPName&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@SPName&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;tr bgcolor=#ffaa11&amp;gt;&amp;lt;td&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;CAST&lt;/span&gt;(&lt;span&gt;@ServerName&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;NVARCHAR&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;))&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;CAST&lt;/span&gt;(&lt;span&gt;@ServerIP&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;NVARCHAR&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;))&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;CAST&lt;/span&gt;(&lt;span&gt;@DBName&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;NVARCHAR&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;)) &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;CAST&lt;/span&gt;(&lt;span&gt;@EventType&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;NVARCHAR&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;))&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;CAST&lt;/span&gt;(&lt;span&gt;@ObjectName&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;NVARCHAR&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;))&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;CAST&lt;/span&gt;(&lt;span&gt;@ObjectType&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;NVARCHAR&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;))&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;SUBSTRING&lt;/span&gt;(&lt;span&gt;REPLACE&lt;/span&gt;(&lt;span&gt;CAST&lt;/span&gt;(&lt;span&gt;@HostName&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;500&lt;/span&gt;)), &lt;span&gt;CHAR&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;), &lt;span&gt;''&lt;/span&gt;), &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;500&lt;/span&gt;)&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;CONVERT&lt;/span&gt;(&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;), &lt;span&gt;GETDATE&lt;/span&gt;(), &lt;span&gt;21&lt;/span&gt;)&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
                        &lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@Body&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@Body&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;@SPName&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/table&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

            &lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@BODY&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;REPLACE&lt;/span&gt;(&lt;span&gt;@BODY&lt;/span&gt;,&lt;span&gt;''''&lt;/span&gt;,&lt;span&gt;''&lt;/span&gt;&lt;span&gt;)

            &lt;/span&gt;&lt;span&gt;IF&lt;/span&gt; &lt;span&gt;REPLACE&lt;/span&gt;(&lt;span&gt;@BODY&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;,&lt;span&gt;''&lt;/span&gt;)&lt;span&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;
                &lt;span&gt;BEGIN&lt;/span&gt;
                    &lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@AllEmailToAddress&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;3000&lt;/span&gt;)&lt;span&gt;=&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;
                    &lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@AllEmailCcAddress&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;3000&lt;/span&gt;)&lt;span&gt;=&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;
                    &lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@Allprofile_name&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;)&lt;span&gt;=&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;
                    &lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;@AllEmailToAddress&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;收件人的地址&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
                    &lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;@AllEmailCcAddress&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;抄送人的地址&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

                    &lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;TOP&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;@Allprofile_name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;NAME &lt;span&gt;FROM&lt;/span&gt; msdb.dbo.sysmail_profile &lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt;&lt;span&gt; profile_id

                    &lt;/span&gt;&lt;span&gt;EXEC&lt;/span&gt; msdb..sp_send_dbmail &lt;span&gt;@profile_name&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@Allprofile_name&lt;/span&gt;     &lt;span&gt;--&lt;/span&gt;&lt;span&gt; profile 名称 &lt;/span&gt;
                     ,&lt;span&gt;@recipients&lt;/span&gt;   &lt;span&gt;=&lt;/span&gt;  &lt;span&gt;@AllEmailToAddress&lt;/span&gt;         &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 收件人邮箱 &lt;/span&gt;
                     ,&lt;span&gt;@copy_recipients&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;@AllEmailCcAddress&lt;/span&gt;&lt;span&gt;
                     ,&lt;/span&gt;&lt;span&gt;@subject&lt;/span&gt;      &lt;span&gt;=&lt;/span&gt;  &lt;span&gt;@Subject&lt;/span&gt;                   &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 邮件标题 &lt;/span&gt;
                     ,&lt;span&gt;@body&lt;/span&gt;         &lt;span&gt;=&lt;/span&gt;  &lt;span&gt;@BODY&lt;/span&gt;                      &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 邮件内容 &lt;/span&gt;
                     ,&lt;span&gt;@body_format&lt;/span&gt;  &lt;span&gt;=&lt;/span&gt;  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;HTML&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;                     &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 邮件格式 &lt;/span&gt;
                     ,&lt;span&gt;@file_attachments&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;
                &lt;span&gt;END&lt;/span&gt;     
              &lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----------    0002 end ------------&lt;/span&gt;
            
         &lt;span&gt;END&lt;/span&gt;            
    &lt;span&gt;END&lt;/span&gt;
    &lt;span&gt;--&lt;/span&gt;&lt;span&gt;--新建对象自动塞入保护表&lt;/span&gt;
    &lt;span&gt;ELSE&lt;/span&gt; 
    &lt;span&gt;BEGIN&lt;/span&gt;
        &lt;span&gt;--&lt;/span&gt;&lt;span&gt;PRINT 3 &lt;/span&gt;
        &lt;span&gt;DELETE&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; Protected_Objects &lt;span&gt;WHERE&lt;/span&gt; ServerName &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@@SERVERNAME&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; DBName&lt;span&gt;=&lt;/span&gt;&lt;span&gt;@DBName&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; ObjName&lt;span&gt;=&lt;/span&gt;&lt;span&gt;@ObjectName&lt;/span&gt;
        &lt;span&gt;IF&lt;/span&gt; &lt;span&gt;@ObjectAction&lt;/span&gt; &lt;span&gt;LIKE&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Create%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; &lt;span&gt;@AppName&lt;/span&gt; &lt;span&gt;LIKE&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%Microsoft SQL Server Management Studio%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; 
            &lt;span&gt;AND&lt;/span&gt; &lt;span&gt;@ObjectName&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;LIKE&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;[_]%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; &lt;span&gt;@ObjectName&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;LIKE&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;TMP%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
        &lt;span&gt;BEGIN&lt;/span&gt; 
            &lt;span&gt;INSERT&lt;/span&gt;  &lt;span&gt;INTO&lt;/span&gt;&lt;span&gt; Protected_Objects
                        &lt;/span&gt;&lt;span&gt;VALUES&lt;/span&gt;  ( &lt;span&gt;@ServerIP&lt;/span&gt;, &lt;span&gt;@ServerName&lt;/span&gt;, &lt;span&gt;@DBName&lt;/span&gt;, &lt;span&gt;@ObjectName&lt;/span&gt;,&lt;span&gt;@ObjectType&lt;/span&gt;, &lt;span&gt;@HostName&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;GETDATE&lt;/span&gt;&lt;span&gt;() )
            &lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt;  &lt;span&gt;INTO&lt;/span&gt;&lt;span&gt;  DBTrigger_Log
                                ( ServerIP ,ServerName ,DBName ,ObjectName ,ObjectType,EventType ,HostName , AppName ,&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;EventData&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; ,TransDateTime)
                        &lt;/span&gt;&lt;span&gt;VALUES&lt;/span&gt;  ( &lt;span&gt;@ServerIP&lt;/span&gt; ,&lt;span&gt;@ServerName&lt;/span&gt; , &lt;span&gt;@DBName&lt;/span&gt; , &lt;span&gt;@ObjectName&lt;/span&gt; ,&lt;span&gt;@ObjectType&lt;/span&gt; ,&lt;span&gt;@EventType&lt;/span&gt;,&lt;span&gt;@HostName&lt;/span&gt; ,&lt;span&gt;@AppName&lt;/span&gt; ,&lt;span&gt;@EventData&lt;/span&gt; , &lt;span&gt;GETDATE&lt;/span&gt;&lt;span&gt;())
        &lt;/span&gt;&lt;span&gt;END&lt;/span&gt; 
        &lt;span&gt;ELSE&lt;/span&gt; &lt;span&gt;IF&lt;/span&gt;  &lt;span&gt;@ObjectAction&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;LIKE&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Create%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; &lt;span&gt;@AppName&lt;/span&gt; &lt;span&gt;LIKE&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%Microsoft SQL Server Management Studio%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;AND&lt;/span&gt; &lt;span&gt;@ObjectName&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;LIKE&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;[_]%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;    
        &lt;span&gt;BEGIN&lt;/span&gt;
            &lt;span&gt;INSERT&lt;/span&gt;  &lt;span&gt;INTO&lt;/span&gt;&lt;span&gt;  DBTrigger_Log
                                ( ServerIP ,ServerName ,DBName ,ObjectName ,ObjectType,EventType ,HostName , AppName ,&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;EventData&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; ,TransDateTime)
                        &lt;/span&gt;&lt;span&gt;VALUES&lt;/span&gt;  ( &lt;span&gt;@ServerIP&lt;/span&gt; ,&lt;span&gt;@ServerName&lt;/span&gt; , &lt;span&gt;@DBName&lt;/span&gt; , &lt;span&gt;@ObjectName&lt;/span&gt; ,&lt;span&gt;@ObjectType&lt;/span&gt; ,&lt;span&gt;@EventType&lt;/span&gt;,&lt;span&gt;@HostName&lt;/span&gt; ,&lt;span&gt;@AppName&lt;/span&gt; ,&lt;span&gt;@EventData&lt;/span&gt; , &lt;span&gt;GETDATE&lt;/span&gt;&lt;span&gt;())

        &lt;/span&gt;&lt;span&gt;END&lt;/span&gt;
    &lt;span&gt;END&lt;/span&gt;     
&lt;span&gt;END&lt;/span&gt;&lt;span&gt; TRY
&lt;/span&gt;&lt;span&gt;BEGIN&lt;/span&gt;&lt;span&gt; CATCH
    &lt;/span&gt;&lt;span&gt;PRINT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;@ObjectName:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;@ObjectName&lt;/span&gt;
    &lt;span&gt;PRINT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;@ObjectType:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;@ObjectType&lt;/span&gt;
    &lt;span&gt;PRINT&lt;/span&gt;&lt;span&gt; ERROR_MESSAGE()
    &lt;/span&gt;&lt;span&gt;ROLLBACK&lt;/span&gt; &lt;span&gt;TRANSACTION&lt;/span&gt;
&lt;span&gt;END&lt;/span&gt;&lt;span&gt; CATCH

&lt;/span&gt;&lt;span&gt;SET&lt;/span&gt; ANSI_NULLS &lt;span&gt;OFF&lt;/span&gt;


&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;SET&lt;/span&gt; ANSI_NULLS &lt;span&gt;OFF&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;SET&lt;/span&gt; QUOTED_IDENTIFIER &lt;span&gt;OFF&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;&lt;span&gt;

ENABLE &lt;/span&gt;&lt;span&gt;TRIGGER&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;ServerDBTrigger_ProtectObjects&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;ON&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;&lt;span&gt; SERVER
&lt;/span&gt;&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;四. 补充&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;创建Server Trigger 后，此时表Protected_Objects是空的，没有被保护的数据库对象。我们可以将数据库下面的对象批量插入。例如，我们将数据库XXXX下除 _和unuse开头之外的所有对象批量插入。其脚本如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt;&lt;span&gt; Protected_Objects(DBName,ObjName,ObjType,Creator,ActiveFlag,TransDateTime)
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;XXXXXX&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,Name, &lt;span&gt;CASE&lt;/span&gt; xtype &lt;span&gt;WHEN&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;U&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;THEN&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Table&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;WHEN&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;THEN&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Procedure&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;WHEN&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;FN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;THEN&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Function&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;WHEN&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;TF&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;THEN&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Function&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;WHEN&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;V&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;THEN&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;View&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;END&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;HOST_NAME&lt;/span&gt;(),&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; ,&lt;span&gt;CONVERT&lt;/span&gt;(&lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;),&lt;span&gt;DATEADD&lt;/span&gt;(&lt;span&gt;DAY&lt;/span&gt;,&lt;span&gt;-&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;,&lt;span&gt;GETDATE&lt;/span&gt;()),&lt;span&gt;120&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;XXXXXXX&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.dbo.sysobjects &lt;span&gt;WHERE&lt;/span&gt; xtype &lt;span&gt;IN&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;U&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;FN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;V&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TF&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  
    &lt;/span&gt;&lt;span&gt;AND&lt;/span&gt;  name &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;LIKE&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;[_]%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; 
    &lt;span&gt;AND&lt;/span&gt; name &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;LIKE&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;unuse%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 27 Dec 2018 07:03:00 +0000</pubDate>
<dc:creator>东山絮柳仔</dc:creator>
<og:description>一 .Server Trigger的简单介绍 在SQL Server数据库中，Server Trigger 是一种特殊类型的存储过程，它可以对特定表、视图或存储中的必然事件自动响应，不由用户调用。创建</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuliuzai/p/10185033.html</dc:identifier>
</item>
<item>
<title>angular4自定义组件非input元素实现ngModel双向数据绑定 - Amor丶Diamond</title>
<link>http://www.cnblogs.com/amor17/p/10185015.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/amor17/p/10185015.html</guid>
<description>&lt;p&gt;&lt;span&gt;在angular里我们一般都是给input元素添加[(ngModel)]=&quot;value&quot;实现数据双向绑定，如果想实现自定义的组件上实现ngModel双向数据绑定应该怎么办呐。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;网上找了一下，没看懂记录一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;场景：组件能获取父组件通过ngModel绑定的值，能通过ngModel改变父组件对应的数据。如下代码：&lt;/span&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;app-child [(ngModel])=&quot;appData&quot;&amp;gt;&amp;lt;/app-child&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;1、先贴出效果图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1040946/201812/1040946-20181227143151778-37756846.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2、下面是app-child组件的代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
import { Component, forwardRef } from '@angular/core'&lt;span&gt;;
import { ControlValueAccessor, NG_VALUE_ACCESSOR } from &lt;/span&gt;'@angular/forms'&lt;span&gt;;

@Component({
  selector: &lt;/span&gt;'app-child'&lt;span&gt;,
  templateUrl: &lt;/span&gt;'./child.component.html'&lt;span&gt;,
  styleUrls: [&lt;/span&gt;'./child.component.css'&lt;span&gt;],
  providers: [{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() &lt;/span&gt;=&amp;gt;&lt;span&gt; ChildComponent),
    multi: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
  }]
})
export class ChildComponent implements ControlValueAccessor {
  constructor() { }
  _data: any;
  add () {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.childData ++&lt;span&gt;;
  }
  change &lt;/span&gt;= (value: any) =&amp;gt; {}; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先定义一个方法，很重要，用于接收registerOnChange()方法里传递回来的方法，然后通过这个方法就能通知到外部组件数据更新。&lt;/span&gt;
  set childData(value: number) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; childData被更改走该方法&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;._data =&lt;span&gt; value;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.change(&lt;span&gt;this&lt;/span&gt;._data); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将更新后的数据通知到外部组件&lt;/span&gt;
&lt;span&gt;  }
  get childData() { &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 页面或者方法里面有调用childData就会走该方法&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._data;
  }
  writeValue(val): &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化时，获取并监听父组件通过ngModel传递进来的数据&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (val) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._data =&lt;span&gt; val;
    }
  }
  registerOnChange(fn: any): &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化后，执行该方法，并保存控件接收到 change 事件后，调用的函数&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.change =&lt;span&gt; fn;
  }
  registerOnTouched(fn: any): &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; {
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;3、下面开始说下实现的过程吧：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果添加ngModel后报如下错误，检查组件对应的Module文件有没有导入FormsModule&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1040946/201812/1040946-20181227130913918-2122555561.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
import { FormsModule } from '@angular/forms'&lt;span&gt;;
@NgModule({
  ...
  imports: [
    ...,
    FormsModule
  ],
  ...
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　import FormsModule后，控制台任然会报错：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1040946/201812/1040946-20181227131203742-1608543029.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这是因为我们需要在使用ngModel的组件里实现ControlValueAccessor的接口方法。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　先引入和使用我们必须使用的配置：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
import { Component, forwardRef } from '@angular/core'&lt;span&gt;;
import { ControlValueAccessor, NG_VALUE_ACCESSOR } from &lt;/span&gt;'@angular/forms'&lt;span&gt;;

@Component({
  selector: &lt;/span&gt;'app-child'&lt;span&gt;,
  templateUrl: &lt;/span&gt;'./child.component.html'&lt;span&gt;,
  styleUrls: [&lt;/span&gt;'./child.component.css'&lt;span&gt;],
  providers: [{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() &lt;/span&gt;=&amp;gt;&lt;span&gt; ChildComponent), // 这里的组件名为当前组件的名字
    multi: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
  }]
})
export class ChildComponent implements ControlValueAccessor {
  constructor() { }
  childData &lt;/span&gt;= 2&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　处理完成后控制台的报错信息已经改变：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1040946/201812/1040946-20181227132238688-2037865370.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　这是因为ControlValueAccessor的接口有几个必须存在的方法，会自动去调用：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  writeValue(val): &lt;span&gt;void&lt;/span&gt;&lt;span&gt; {
  }
  registerOnChange(fn: any): &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; {
  }
  registerOnTouched(fn: any): &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; {
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;初始化的时候调用 &lt;code&gt;writeValue()&lt;/code&gt; 方法，将会使用表单模型中对应的初始值作为参数（也就是ngModel里的值）。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;registerOnChange() 可以用来通知外部，组件已经发生变化。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;registerOnTouched() 方法用于设置当控件接收到 touched 事件后，调用的函数。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;　　知道了这三个方法后，我们就可以在writeValue方法里给组件设置父组件通过ngModel传递过来的值了。如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
writeValue(val): &lt;span&gt;void&lt;/span&gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (val) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.childData =&lt;span&gt; val;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　那么怎么将组件里更新的数据传递给父组件呐。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
registerOnChange(fn: any): &lt;span&gt;void&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化后，执行该方法，并保存控件接收到 change 事件后，调用的函数&lt;/span&gt;
  &lt;span&gt;this&lt;/span&gt;.change =&lt;span&gt; fn;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　writeValue()方法后就会执行registerOnChange()方法，我们就是通过该方法传递回来的方法参数来通知到外部组件数据更新的，所以我们要在最开始就定义一个方法来接收。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
change = (value: any) =&amp;gt; {}; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先定义一个方法，很重要，用于接收registerOnChange()方法里传递回来的方法，然后通过这个方法就能通知到外部组件数据更新。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后就可以通过change方法通知外部组件了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
set childData(value: number) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; childData被更改走该方法&lt;/span&gt;
  &lt;span&gt;this&lt;/span&gt;._data =&lt;span&gt; value;
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.change(&lt;span&gt;this&lt;/span&gt;._data); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将更新后的数据通知到外部组件&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　最开始贴出来的代码，中间使用了set 和get去处理了数据，在get childData()方法里打断点发现会执行很多次该方法，其实也可以修改成通过更新数据的时候就直接调用change()方法来通知外部组件数据更新，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
import { Component, forwardRef } from '@angular/core'&lt;span&gt;;
import { ControlValueAccessor, NG_VALUE_ACCESSOR } from &lt;/span&gt;'@angular/forms'&lt;span&gt;;

@Component({
  selector: &lt;/span&gt;'app-child'&lt;span&gt;,
  templateUrl: &lt;/span&gt;'./child.component.html'&lt;span&gt;,
  styleUrls: [&lt;/span&gt;'./child.component.css'&lt;span&gt;],
  providers: [{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() &lt;/span&gt;=&amp;gt;&lt;span&gt; ChildComponent),
    multi: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
  }]
})
export class ChildComponent implements ControlValueAccessor {
  constructor() { }
  _data: any;
  childData &lt;/span&gt;= 1&lt;span&gt;;
  add () {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.childData ++&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.change(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.childData);
  }
  change &lt;/span&gt;= (value: any) =&amp;gt; {}; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先定义一个方法，很重要，用于接收registerOnChange()方法里传递回来的方法，然后通过这个方法就能通知到外部组件数据更新。&lt;/span&gt;
  writeValue(val): &lt;span&gt;void&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化时，获取并监听父组件通过ngModel传递进来的数据&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (val) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.childData =&lt;span&gt; val;
    }
  }
  registerOnChange(fn: any): &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化后，执行该方法，并保存控件接收到 change 事件后，调用的函数&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.change =&lt;span&gt; fn;
  }
  registerOnTouched(fn: any): &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; {
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　中间不用使用get和set，不知道两种方法哪种更好。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　其实通过子组件通知父级组件数据更新，可以使用@Input和@Output来实现的，如果是@Input获取的父级组件的数据，父级组件数据更新，子组件需要在ngOnChanges生命周期里去监听对应的数据变更并处理相应的逻辑。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　不过在自定义组件上使用ngModel实现数据的双向绑定还可以用作表单处理上，比如表单模板和表单验证。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 27 Dec 2018 07:01:00 +0000</pubDate>
<dc:creator>Amor丶Diamond</dc:creator>
<og:description>在angular里我们一般都是给input元素添加[(ngModel)]=&quot;value&quot;实现数据双向绑定，如果想实现自定义的组件上实现ngModel双向数据绑定应该怎么办呐。。。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/amor17/p/10185015.html</dc:identifier>
</item>
<item>
<title>redis 系列27 Cluster高可用 (2) - 花阴偷移</title>
<link>http://www.cnblogs.com/MrHSR/p/10184619.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MrHSR/p/10184619.html</guid>
<description>&lt;h3&gt;一. ASK错误&lt;/h3&gt;
&lt;p&gt;　　集群上篇最后讲到，对于重新分片由redis-trib负责执行，关于该工具以后再介绍。在进行重新分片期间，源节点向目标节点迁移一个槽的过程中，可以会出现该槽中的一部分键值对保存在源节点中，另一部份键值对则保存在目标节点中。&lt;/p&gt;
&lt;p&gt;　　当客户端向源节点发送一个与数据库键有关的命令时，并且命令要处理的数据库键正好就是正在被迁移的槽时，会出现二种情况的一种：&lt;/p&gt;
&lt;p&gt;　　(1) 源节点会先在自己的数据库中查找指定的键，如果找到的话，就会直接执行客户端发送的命令。&lt;/p&gt;
&lt;p&gt;　　(2) 相反，如果在源节点找不到指定的键，那么键有可能已经被迁移到了目标节点，源节点将向客户端返回一个ASK错误，指引客户端转向正在导入槽的目标节点，并再次发送之前想要执行的命令。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注意：&lt;/span&gt;和接到Moved错误时的情况一样，集群模式的redis-cli在接到ask错误时也不会打印错误，而是自动根据错误提供的ip和port进行转向(Redirected to ..)动作。&lt;/p&gt;

&lt;h4&gt;　　1.1 cluster setslot importing 命令实现&lt;/h4&gt;
&lt;p&gt;　　　　在clusterState结构的importing_slots_from数组中，记录了当前节点正在从其他节点导入的槽号。在集群进行重新分片的时候，向&lt;span&gt;&lt;strong&gt;目标节点&lt;/strong&gt;&lt;/span&gt;发送以下命令，格式为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    cluster setslot &amp;lt; slot &amp;gt; importing &amp;lt;node ID&amp;gt;    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　slot 和 node_id是指：源节点槽号和源节点ID。比如在上一篇结尾，原属于7002节点的14042 号槽，迁移到了目标7003节点，在7003节点中内部clusterState结构的importing_slots_from数组下记录了14042号槽，并且还记录了源节点ip和端口（127.0.0.1 7002）。&lt;/p&gt;

&lt;h4&gt;　　1.2 cluster setslot migrating命令实现&lt;/h4&gt;
&lt;p&gt;　　　　在clusterState结构的   migrating_slots_to数组中，记录了当前节点正在迁移至其他节点的槽。在集群进行重新分片的时候，向&lt;span&gt;&lt;strong&gt;源节点&lt;/strong&gt;&lt;/span&gt;发送命令以下命令，格式为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    cluster setslot &amp;lt; slot &amp;gt; migrating &amp;lt;node ID&amp;gt;    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　slot 和 node_id是指：目标节点槽号和目标节点ID。&lt;/p&gt;
&lt;p&gt;　　　　下图左边7003目标节点 importing_slots_from数组 和 右边7002源节点的migrating_slots_to数组：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201812/151560-20181227140207268-1827306743.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　1.3 ASK错误后的引导&lt;/h4&gt;
&lt;p&gt;　　　　如果节点收到一个关于键key的命令请求，并且键key所属的槽i正好就指派给了这个节点， 如果节点没有在自己的数据库里找到键key，那么节点会检查自己的迁移数组clusterState.migrating_slots_to[i], 看键key所属的槽i是否正在进行迁移，如果槽 i 的确在进行迁移，那么节点会向客户端发送一个ask错误，引导客户端到正在导入槽 i 的节点去查找键key。&lt;/p&gt;
&lt;h4&gt;　　1.4  ASK错误和Moved错误的区别&lt;/h4&gt;
&lt;p&gt;　　　　ASK错误和Moved错误都会导致客户端转向，它们区别在于：&lt;/p&gt;
&lt;p&gt;　　　　(1) Moved错误代表槽的负责权，已经从一个节点转移到了另一个节点：在客户端收到关于槽i的mvoed错误之后，客户端每次遇到关于槽i的命令请求时，都可以直接将命令请求发送到moved错误所指向的节点，因为该节点就是目前负责槽i的节点。&lt;/p&gt;
&lt;p&gt;　　　　(2) 与此相反，ASK错误只是两个节点在迁移槽的过程中使用的一种临时措施：在客户端收到关于槽 i 的ASK错误之后，客户端只会在接下来的一次命令请求中将关于槽 i 的命令请求发送到ASK错误所指示的节点。&lt;/p&gt;

&lt;h3&gt;二. 复制与故障转移&lt;/h3&gt;
&lt;p&gt;　　集群中的节点分为主节点和从节点，主节点用于处理槽，而从节点则用于复制某个主节点，当主节点下线时，从节点代替主节点继续处理命令请求。&lt;/p&gt;
&lt;p&gt;　　　　复制设置从节点：在主节点将设置 node_id (node_id为从节点),脚本如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    CLUSTER REPLICATE &amp;lt;node_id&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;　　2.1 节点故障检测&lt;/h4&gt;
&lt;p&gt;　　　　集群中的每个节点都会定期向群集中的其他节点发送ping消息，以此来检测对方是否在线，如果接收ping消息的节点没有在规定的时间内返回pong消息，那么发送节点就会将接收节点标记为疑似下线pfail(probable fail)。&lt;/p&gt;
&lt;p&gt;　　　　集群中的各个节点会通过互相发送消息的方式来交换集群中各个节点的状态信息，来判断节点是处于在线、疑似下线还是下线(fail) 状态。&lt;/p&gt;
&lt;p&gt;　　　　在集群中，负责处理槽的节点在半数以上都将某个主节点x 报告为疑似下线状态时，那么这个主节点x将标记为已下线 fail。 将主节点x标记为已下线的节点会向集群广播一条关于主节点x的fail消息。　&lt;/p&gt;

&lt;h4&gt;　　2.2 故障转移实现步骤&lt;/h4&gt;
&lt;p&gt;　　　　当一个从节点发现自己正在复制的主节点进入已下线状态时，从节点将开始对下线主节点进行故障转移，步骤如下:&lt;/p&gt;
&lt;p&gt;　　　　(1) 复制下线主节点的所有从节点，会有一个从节点被选中。&lt;/p&gt;
&lt;p&gt;　　　　(2) 被选中的从节点会执行slaveof  no  one 命令，成为新的主节点。&lt;/p&gt;
&lt;p&gt;　　　　(3) 新的主节点会撤消所有对已下线主节点的槽指派，并将这些槽指派给自己。&lt;/p&gt;
&lt;p&gt;　　　　(4) 新的主节点向集群广播一条pong消息，这条pong消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点，并且接管了原本已下线的节点负责处理的槽。&lt;/p&gt;
&lt;p&gt;　　　　(5) 新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。&lt;/p&gt;

&lt;h4&gt;　　2.3 节点之间的通信&lt;/h4&gt;
&lt;p&gt;　　　　集群中的各个节点通过发送和接收消息来进行通信，节点发送的消息主要以5种：&lt;/p&gt;
&lt;p&gt;　　　　(1) meet消息: 发送者向接收者发送meet消息，请求接收者加入到发送者当前所处的集群中。&lt;/p&gt;
&lt;p&gt;　　　　(2) ping消息:集群中每个节点默认每隔1秒就会从已知节点列表随机选出5个节点，然后对这5个节点中最长时间没有发送过ping消息的节点发送ping消息，以此来检测被选中的节点是否在线。&lt;/p&gt;
&lt;p&gt;　　　　(3) pong消息：当接收者收到meet或ping消息时，会向发送者返回一条pong消息，以此表明自己(接收者)节点是正常的。另外一个节点也可以通过向集群广播自己的pong消息来让集群中的其他节点刷新关于这个节点的认识。&lt;/p&gt;
&lt;p&gt;　　　　(4) Fail消息: 当一个主节点A判断另一个主节点B已经进入Fall状态时，节点A会向集群广播一条关于节点B的Fall消息，所有收到这条消息的节点都会立即将节点B标记为已下线。&lt;/p&gt;
&lt;p&gt;　　　　(5) publish消息: 当节点接收到一个publish命令时，节点会执行这个命令，并向集群广播一条publish消息，所有接收到这条publish消息的节点都会执行相同的publish命令。&lt;/p&gt;

&lt;h3&gt;三. 集群知识点总结&lt;/h3&gt;
&lt;p&gt;　　(1) 节点通过握手来将其他节点添加到自己所处的集群当中。&lt;/p&gt;
&lt;p&gt;　　(2) 集群中的16384个槽可以分别指派给集群中的各个节点，通过cluster nodes命令可以看到节点的槽分布。&lt;/p&gt;
&lt;p&gt;　　(3) 节点在接到一个命令请求时，先检查这个命令请求要处理的键所在的槽是否由自己负责，如果不是，节点向客户端返回一个moved错误，moved错误携带的信息可以指引客户端转向至正在负责相关槽的节点继续来处理。&lt;/p&gt;
&lt;p&gt;　　(4)对Redis集群的重新分片工作是由redis-trib负责执行的，重新分片是将属于某个槽的所有键值对从一个节点转移至另一个节点。&lt;/p&gt;
&lt;p&gt;　　(5)如果节点A正在迁移槽 i 到节点B，当节点A没能在自己的数据库中找到命令指定的键时，节点A向客户端返回一个ASK错误，指引客户端到节点B继续查找指定键。&lt;/p&gt;
&lt;p&gt;　　(6) Moved错误代表槽的负责权已经从一个节点转移到了另一个节点，而ASK错误只是两个节点在迁移槽的过程中使用的一种临时措施。&lt;/p&gt;
&lt;p&gt;　　(7) 集群中的从节点用于复制主节点，并在主节点下线时，代替主节点继续处理命令请求。&lt;/p&gt;
&lt;p&gt;　　(8) 集群中的节点通过发送和接收消息来进行通信，常见的消息包括meet;ping ;pong;publish;fail五种。                &lt;/p&gt;


</description>
<pubDate>Thu, 27 Dec 2018 06:41:00 +0000</pubDate>
<dc:creator>花阴偷移</dc:creator>
<og:description>一. ASK错误 集群上篇最后讲到，对于重新分片由redis-trib负责执行，关于该工具以后再介绍。在进行重新分片期间，源节点向目标节点迁移一个槽的过程中，可以会出现该槽中的一部分键值对保存在源节点</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MrHSR/p/10184619.html</dc:identifier>
</item>
<item>
<title>常见排序算法总结 -- java实现 - ZT1994</title>
<link>http://www.cnblogs.com/zt19994/p/10184608.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zt19994/p/10184608.html</guid>
<description>&lt;h2 id=&quot;常见排序算法总结----java实现&quot;&gt;常见排序算法总结 -- java实现&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://files-cdn.cnblogs.com/files/zt19994/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.gif&quot; width=&quot;90%&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;排序算法可以分为两大类&quot;&gt;排序算法可以分为两大类：&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;非线性时间比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。&lt;/li&gt;
&lt;li&gt;线性时间非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png&quot; width=&quot;90%&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;相关概念&quot;&gt;相关概念&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。&lt;/li&gt;
&lt;li&gt;不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。&lt;/li&gt;
&lt;li&gt;时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。&lt;/li&gt;
&lt;li&gt;空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;一插入排序&quot;&gt;一、插入排序&lt;/h3&gt;
&lt;h4 id=&quot;直接插入排序&quot;&gt;1.1 直接插入排序&lt;/h4&gt;
&lt;p&gt;  插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。&lt;/p&gt;
&lt;p&gt;直接插入排序的算法思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;设置监视哨temp，将待插入记录的值赋值给temp；&lt;/li&gt;
&lt;li&gt;设置开始查找的位置j；&lt;/li&gt;
&lt;li&gt;在数组arr中进行搜索，搜索中将第j个记录后移，直至temp≥arr[j]为止；&lt;/li&gt;
&lt;li&gt;将temp插入arr[j+1]的位置上。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 直接插入排序
 */
public void insertSort(int[] arr) {
    //外层循环确定待比较数值
    //必须i=1，因为开始从第二个数与第一个数进行比较
    for (int i = 1; i &amp;lt; arr.length; i++) {
        //待比较数值
        int temp = arr[i];
        int j = i - 1;
        //内层循环为待比较数值确定其最终位置
        //待比较数值比前一位置小，应插往前插一位
        for (; j &amp;gt;= 0 &amp;amp;&amp;amp; arr[j] &amp;gt; temp; j--) {
            //将大于temp的值整体后移一个单位
            arr[j + 1] = arr[j];
        }
        //待比较数值比前一位置大，最终位置无误
        arr[j + 1] = temp;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;希尔排序&quot;&gt;1.2 希尔排序&lt;/h4&gt;
&lt;p&gt;  希尔排序(Shell's Sort)是插入排序的一种，又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因D.L.Shell于1959年提出而得名。&lt;/p&gt;
&lt;p&gt;希尔排序的算法思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;把数组按下标的一定增量分组；&lt;/li&gt;
&lt;li&gt;对每组使用直接插入排序算法排序；&lt;/li&gt;
&lt;li&gt;随着增量逐渐减少，每组包含的值越来越多，当增量减至1时，整个文件被分成一组，算法便终止。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 希尔排序
 */
public void shellSort(int[] arr) {
    int d = arr.length;
    while (d &amp;gt;= 1) {
        d = d / 2;
        for (int x = 0; x &amp;lt; d; x++) {
            //按下标的一定增量分组然后进行插入排序
            for (int i = x + d; i &amp;lt; arr.length; i = i + d) {
                int temp = arr[i];
                int j;
                for (j = i - d; j &amp;gt;= 0 &amp;amp;&amp;amp; arr[j] &amp;gt; temp; j = j - d) {
                    //移动下标
                    arr[j + d] = arr[j];
                }
                arr[j + d] = temp;
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二交换排序&quot;&gt;二、交换排序&lt;/h3&gt;
&lt;h4 id=&quot;冒泡排序&quot;&gt;2.1 冒泡排序&lt;/h4&gt;
&lt;p&gt;  在一组数据中，相邻元素依次比较大小，最大的放后面，最小的冒上来。&lt;/p&gt;
&lt;p&gt;冒泡排序算法的算法思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;比较相邻的元素。如果第一个比第二个大，就交换他们两个。&lt;/li&gt;
&lt;li&gt;对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。&lt;/li&gt;
&lt;li&gt;针对所有的元素重复以上的步骤，除了最后一个。&lt;/li&gt;
&lt;li&gt;持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 冒泡排序
 */
public void bubbleSort(int[] arr) {
    for (int i = 0; i &amp;lt; arr.length - 1; i++) {
        for (int j = 0; j &amp;lt; arr.length  - i - 1; j++) {
            if (arr[j] &amp;gt; arr[j + 1]) {
                // temp 临时存储 arr[j] 的值
                int temp = arr[j];
                //交换 arr[j] 和 arr[j+1] 的值
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;快速排序&quot;&gt;2.2 快速排序&lt;/h4&gt;
&lt;p&gt;  快速排序（Quicksort）是对冒泡排序的一种改进。&lt;/p&gt;&lt;p&gt;  通过一次排序将数组分成两个子数组，其中一个数字的值都比另外一个数字的值小，然后再对这两子数组分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。&lt;/p&gt;
&lt;p&gt;快速排序的算法思路：（分治法）&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先从数列中取出一个数作为中间值middle；&lt;/li&gt;
&lt;li&gt;将比这个数小的数全部放在它的左边，&lt;strong&gt;大于或等于&lt;/strong&gt;它的数全部放在它的右边；&lt;/li&gt;
&lt;li&gt;对左右两个小数列重复第二步，直至各区间只有1个数。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 快速排序
 *
 * @param arr 待排序数组
 */
public void quickSort(int[] arr) {
    //查看数组是否为空
    if (arr.length &amp;gt; 0) {
        sort(arr, 0, arr.length - 1);
    }
}

/**
 * @param arr  待排序数组
 * @param low  开始位置
 * @param high 结束位置
 */
private void sort(int[] arr, int low, int high) {
    if (low &amp;lt; high) {
        int mid = getMiddle(arr, low, high); //将numbers数组进行一分为二
        sort(arr, low, mid - 1);  //对低字段表进行递归排序
        sort(arr, mid + 1, high); //对高字段表进行递归排序
    }
}

/**
 * 查找出中轴（默认是最低位low）的在arr数组排序后所在位置
 *
 * @param arr  待排序数组
 * @param low  开始位置
 * @param high 结束位置
 * @return 中轴所在位置
 */
private int getMiddle(int[] arr, int low, int high) {
    int temp = arr[low]; //数组的第一个作为中轴
    while (low &amp;lt; high) {
        while (low &amp;lt; high &amp;amp;&amp;amp; arr[high] &amp;gt;= temp) {
            high--;
        }
        arr[low] = arr[high];//比中轴小的记录移到低端
        while (low &amp;lt; high &amp;amp;&amp;amp; arr[low] &amp;lt; temp) {
            low++;
        }
        arr[high] = arr[low]; //比中轴大的记录移到高端
    }
    arr[low] = temp; //中轴记录到尾
    return low; // 返回中轴的位置
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;三选择排序&quot;&gt;三、选择排序&lt;/h3&gt;
&lt;h4 id=&quot;简单选择排序&quot;&gt;3.1 简单选择排序&lt;/h4&gt;
&lt;p&gt;  选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。&lt;/p&gt;
&lt;p&gt;简单选择排序的算法思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置&lt;/li&gt;
&lt;li&gt;再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾&lt;/li&gt;
&lt;li&gt;以此类推，直到所有元素均排序完毕。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 简单选择排序
 */
public void selectSort(int[] arr) {
    int minIndex = 0;
    int temp;
    for (int i = 0; i &amp;lt; arr.length - 1; i++) {
        minIndex = i;
        for (int j = i + 1; j &amp;lt; arr.length; j++) {
            // 找到当前循环最小值索引
            if (arr[j] &amp;lt; arr[minIndex]) {
                minIndex = j;
            }
        }
        temp = arr[i];
        // 交换当前循环起点值和最小值索引位置的值
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;堆排序&quot;&gt;3.2 堆排序&lt;/h4&gt;
&lt;p&gt;  堆排序（英语：Heap Sort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。在堆的数据结构中，堆中的最大值总是位于根节点（在优先队列中使用堆的话堆中的最小值位于根节点）。&lt;/p&gt;
&lt;p&gt;堆排序的算法思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;最大堆调整（Max Heapify）：将堆的末端子节点作调整，某个节点的值最多和其父节点的值一样大；&lt;/li&gt;
&lt;li&gt;创建最大堆（Build Max Heap）：将堆中的所有数据重新排序,堆中的最大元素存放在根节点中；&lt;/li&gt;
&lt;li&gt;堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 堆排序
 */
public void heapSort(int[] arr) {
    buildMaxHeap(arr);
    
    //进行n-1次循环，完成排序
    for (int i = arr.length - 1; i &amp;gt; 0; i--) {
        //最后一个元素和第一个元素进行交换
        int temp = arr[i];
        arr[i] = arr[0];
        arr[0] = temp;
        // 筛选 R[0] 结点，得到i-1个结点的堆 将arr中前i-1个记录重新调整为大顶堆
        heapAdjust(arr, 0, i);
    }
}


/**
 * 构建大顶堆
 * &amp;lt;p&amp;gt;
 * 将数组中最大的值放在根节点
 */
private void buildMaxHeap(int[] arr) {
    for (int i = arr.length / 2; i &amp;gt;= 0; i--) {
        heapAdjust(arr, i, arr.length - 1);
    }
}

/**
 * 堆调整
 * &amp;lt;p&amp;gt;
 * 将数组中最大的值放在根节点
 *
 * @param arr    待排序数组
 * @param parent 父节点索引
 * @param length 数组长度
 */
private void heapAdjust(int[] arr, int parent, int length) {
    int temp = arr[parent]; //temp保存当前父节点
    int child = 2 * parent + 1; //获取左子节点

    while (child &amp;lt; length) {
        // 如果有右子结点，并且右子结点的值大于左子结点的值，则选取右子结点的值
        if (child + 1 &amp;lt; length &amp;amp;&amp;amp; arr[child] &amp;lt; arr[child + 1]) {
            child++;
        }
        // 如果父结点的值已经大于子结点的值，则直接结束
        if (temp &amp;gt;= arr[child]) {
            break;
        }
        // 把子结点的值赋给父结点
        arr[parent] = arr[child];
        // 选取子结点的左子结点,继续向下筛选
        parent = child;
        child = 2 * child + 1;
    }
    arr[parent] = temp;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;四归并排序&quot;&gt;四、归并排序&lt;/h3&gt;
&lt;h4 id=&quot;二路归并排序&quot;&gt;4.1 二路归并排序&lt;/h4&gt;
&lt;p&gt;  归并排序（mergeSort）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。&lt;/p&gt;&lt;p&gt;  若将两个有序表合并成一个有序表，称为二路归并。例如：将2个有序数组合并。比较2个数组的第一个数，谁小就先取谁，取了后就在对应数组中删除这个数。然后再进行比较，如果有数组为空，那直接将另一个数组的数依次取出即可。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;二路归并排序的算法思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将数组分成A，B 两个数组，如果这2个数组都是有序的，那么就可以很方便的将这2个数组进行排序。&lt;/li&gt;
&lt;li&gt;让这2个数组有序，可以将A，B组各自再分成2个数组。依次类推，当分出来的数组只有1个数据时，可以认为数组已经达到了有序。&lt;/li&gt;
&lt;li&gt;然后再合并相邻的2个数组。这样通过先递归的分解数组，再合并数组就完成了归并排序。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 二路归并排序
 */
public void mergeSort(int[] arr) {
    int[] temp = new int[arr.length]; //临时数组
    sort(arr, temp, 0, arr.length - 1);
}

/**
 * @param arr   待排序数组
 * @param left  开始位置
 * @param right 结束位置
 */
private void sort(int[] arr, int[] temp, int left, int right) {
    if (left &amp;gt;= right) {
        return;
    }
    int mid = left + (right - left) / 2;
    sort(arr, temp, left, mid);
    sort(arr, temp, mid + 1, right);
    merge(arr, temp, left, mid, right);
}

/**
 * 将两个有序表归并成一个有序表
 *
 * @param arr       待排序数组
 * @param temp      临时数组
 * @param leftStart 左边开始下标
 * @param leftEnd   左边结束下标(mid)
 * @param rightEnd  右边结束下标
 */
private static void merge(int[] arr, int[] temp, int leftStart, int leftEnd, int rightEnd) {
    int rightStart = leftEnd + 1;
    int tempIndex = leftStart; // 从左边开始算
    int len = rightEnd - leftStart + 1; // 元素个数
    while (leftStart &amp;lt;= leftEnd &amp;amp;&amp;amp; rightStart &amp;lt;= rightEnd) {
        if (arr[leftStart] &amp;lt;= arr[rightStart]) {
            temp[tempIndex++] = arr[leftStart++];
        } else {
            temp[tempIndex++] = arr[rightStart++];
        }
    }
    // 左边如果有剩余 将左边剩余的归并
    while (leftStart &amp;lt;= leftEnd) {
        temp[tempIndex++] = arr[leftStart++];
    }
    // 右边如果有剩余 将右边剩余的归并
    while (rightStart &amp;lt;= rightEnd) {
        temp[tempIndex++] = arr[rightStart++];
    }
    // 从临时数组拷贝到原数组
    for (int i = 0; i &amp;lt; len; i++) {
        arr[rightEnd] = temp[rightEnd];
        rightEnd--;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;五计数排序&quot;&gt;五、计数排序&lt;/h3&gt;
&lt;p&gt;  计数排序（Counting sort）不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。&lt;/p&gt;
&lt;p&gt;计数排序的算法思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;求出待排序数组的最大值 max 和最小值 min。&lt;/li&gt;
&lt;li&gt;实例化辅助计数数组temp，temp数组中每个下标对应arr中的一个元素，temp用来记录每个元素出现的次数。&lt;/li&gt;
&lt;li&gt;计算 arr 中每个元素在temp中的位置 position = arr[i] - min。&lt;/li&gt;
&lt;li&gt;根据 temp 数组求得排序后的数组。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 计数排序
 */
public void countSort(int[] arr) {
    if (arr == null || arr.length == 0) {
        return;
    }

    int max = Integer.MIN_VALUE;
    int min = Integer.MAX_VALUE;

    //找出数组中的最大最小值
    for (int i = 0; i &amp;lt; arr.length; i++) {
        max = Math.max(max, arr[i]);
        min = Math.min(min, arr[i]);
    }

    int[] temp = new int[max];

    //找出每个数字出现的次数
    for (int i = 0; i &amp;lt; arr.length; i++) {
        //每个元素在temp中的位置 position = arr[i] - min
        int position = arr[i] - min;
        temp[position]++;
    }

    int index = 0;
    for (int i = 0; i &amp;lt; temp.length; i++) {
        //temp[i] 大于0 表示有重复元素
        while (temp[i]-- &amp;gt; 0) {
            arr[index++] = i + min;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;六桶排序&quot;&gt;六、桶排序&lt;/h3&gt;
&lt;p&gt;  桶排序 (Bucket sort)的工作原理是将数组分到有限数量的桶里。每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。但桶排序并不是比较排序，他不受到 O(n log n) 下限的影响，桶排序可用于最大最小值相差较大的数据情况。&lt;/p&gt;
&lt;p&gt;桶排序的算法思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;找出待排序数组中的最大值max和最小值min；&lt;/li&gt;
&lt;li&gt;我们使用动态数组ArrayList 作为桶，桶里放的元素也用 ArrayList 存储。桶的数量为 (max-min) / arr.length + 1；&lt;/li&gt;
&lt;li&gt;遍历数组 arr，计算每个元素 arr[i] 放的桶；&lt;/li&gt;
&lt;li&gt;每个桶各自排序；&lt;/li&gt;
&lt;li&gt;遍历桶数组，把排序好的元素放进输出数组。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 桶排序
 *
 * @param arr 待排序数组
 */
public static void bucketSort(int[] arr) {
    int max = Integer.MIN_VALUE;
    int min = Integer.MAX_VALUE;
    for (int i = 0; i &amp;lt; arr.length; i++) {
        max = Math.max(max, arr[i]);
        min = Math.min(min, arr[i]);
    }

    //桶数
    int bucketNum = (max - min) / arr.length + 1;
    ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; bucketArr = new ArrayList&amp;lt;&amp;gt;(bucketNum);
    for (int i = 0; i &amp;lt; bucketNum; i++) {
        bucketArr.add(new ArrayList&amp;lt;&amp;gt;());
    }

    //将每个元素放入桶
    for (int i = 0; i &amp;lt; arr.length; i++) {
        int num = (arr[i] - min) / arr.length;
        bucketArr.get(num).add(arr[i]);
    }

    //对每个桶进行排序
    for (int i = 0; i &amp;lt; bucketNum; i++) {
        Collections.sort(bucketArr.get(i));
    }

    int position = 0;
    //合并桶
    for (int i = 0; i &amp;lt; bucketNum; i++) {
        for (int j = 0; j &amp;lt; bucketArr.get(i).size(); j++) {
            arr[position++] = bucketArr.get(i).get(j);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;七基数排序&quot;&gt;七、基数排序&lt;/h3&gt;
&lt;p&gt;  基数排序（radix sort）是桶排序的扩展，基本思想是将整数按位数切割成不同的数字，然后按每个位数分别比较。&lt;/p&gt;&lt;p&gt;  基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。&lt;/p&gt;
&lt;p&gt;基数排序的算法思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;取得数组中的最大数，并取得位数；&lt;/li&gt;
&lt;li&gt;arr为原始数组，从最低位开始取每个位组成radix数组；&lt;/li&gt;
&lt;li&gt;对radix进行计数排序（利用计数排序适用于小范围数的特点）。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 基数排序
 *
 * @param arr 待排序数组
 */
public void radixSort(int[] arr) {
    int max = getMax(arr);  // 数组arr中的最大值

    for (int exp = 1; max / exp &amp;gt; 0; exp *= 10) {
        //从个位开始，对数组arr按&quot;exp指数&quot;进行排序
        countSort(arr, exp);
        //bucketSort(arr, exp);
    }
}

/**
 * 获取数组中最大值
 */
private int getMax(int[] arr) {
    int max = arr[0];
    for (int i = 1; i &amp;lt; arr.length; i++) {
        if (arr[i] &amp;gt; max) {
            max = arr[i];
        }
    }
    return max;
}

/**
 * 对数组按照&quot;某个位数&quot;进行排序(计数排序)
 * &amp;lt;p&amp;gt;
 * 例如:
 * 1、当exp=1 表示按照&quot;个位&quot;对数组进行排序
 * 2、当exp=10 表示按照&quot;十位&quot;对数组进行排序
 *
 * @param arr 待排序数组
 * @param exp 指数 对数组arr按照该指数进行排序
 */
private void countSort(int[] arr, int exp) {
    int[] temp = new int[arr.length]; // 存储&quot;被排序数据&quot;的临时数组
    int[] buckets = new int[10];

    // 将数据出现的次数存储在buckets[]中
    for (int i = 0; i &amp;lt; arr.length; i++) {
        buckets[(arr[i] / exp) % 10]++;
    }

    // 计算数据在temp[]中的位置 0 1 2 2 3 --&amp;gt; 0 1 3 5 8
    for (int i = 1; i &amp;lt; 10; i++) {
        buckets[i] += buckets[i - 1];
    }

    // 将数据存储到临时数组temp[]中
    for (int i = arr.length - 1; i &amp;gt;= 0; i--) {
        temp[buckets[(arr[i] / exp) % 10] - 1] = arr[i];
        buckets[(arr[i] / exp) % 10]--;
    }

    // 将排序好的数据赋值给arr[]
    for (int i = 0; i &amp;lt; arr.length; i++) {
        arr[i] = temp[i];
    }
}


/**
 * 桶排序
 */
private void bucketSort(int[] arr, int exp) {
    int[][] buckets = new int[10][arr.length];   //这是二维数组组成的桶
    int[] counter = new int[10];    //此数组用来记录0-9每个桶中的数字个数，计数器
    for (int i = 0; i &amp;lt; arr.length; i++) {
        int index = (arr[i] / exp) % 10;    //得出相应位置（如个位、十位）上的数字
        buckets[index][counter[index]] = arr[i];   //取出来放到桶里
        counter[index]++;   //相应的计数器加1
    }

    int position = 0;
    //合并桶
    for (int i = 0; i &amp;lt; 10; i++) {
        for (int j = 0; j &amp;lt; counter[i]; j++) {
            arr[position++] = buckets[i][j];
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/zt19994/leetcode/tree/master/src/Learn/SortAlgorithm&quot; class=&quot;uri&quot;&gt;https://github.com/zt19994/leetcode/tree/master/src/Learn/SortAlgorithm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://www.cnblogs.com/onepixel/articles/7674659.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/onepixel/articles/7674659.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 27 Dec 2018 06:04:00 +0000</pubDate>
<dc:creator>ZT1994</dc:creator>
<og:description>常见排序算法总结 java实现 排序算法可以分为两大类： 1. 非线性时间比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。 2. 线</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zt19994/p/10184608.html</dc:identifier>
</item>
<item>
<title>用企业微信实现预警（shell + python） - 自由早晚乱余生</title>
<link>http://www.cnblogs.com/operationhome/p/10184367.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/operationhome/p/10184367.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;一-注册企业微信&quot;&gt;一 注册企业微信&lt;/h2&gt;
&lt;p&gt;本文所有内容是基于2018年12月26日时的企业微信版本所做的教程。后面可能由于企业微信界面规则更改导致部分流程不一致。（大家看文章时请注意这一点）&lt;/p&gt;
&lt;h3 id=&quot;注册企业微信必备条件&quot;&gt;注册企业微信必备条件&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;微信号（实名认证了）&lt;/li&gt;
&lt;li&gt;手机号&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;之前我有个误区，就是以为注册企业微信就一定要有营业执照之类的证件才可以注册，实际是不需要也可以的，因为我们直接注册后，即使不绑定企业，我们也是可以正常使用的，未绑定实际企业的，有200人的数的上限（难道你们技术部有200人？不存在的，哈哈!）&lt;/p&gt;
&lt;h3 id=&quot;注册&quot;&gt;注册&lt;/h3&gt;
&lt;p&gt;注册链接：&lt;a href=&quot;https://work.weixin.qq.com/wework_admin/register_wx&quot;&gt;企业微信&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://djxblog.oss-cn-shenzhen.aliyuncs.com/picture/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E9%A2%84%E8%AD%A6/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%B3%A8%E5%86%8C.jpg&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;企业名称可以随便填，建议填真实的啊，其他的你就按照实际情况填了。&lt;/p&gt;
&lt;h2 id=&quot;二-创建消息&quot;&gt;二 创建消息&lt;/h2&gt;
&lt;h3 id=&quot;创建部门&quot;&gt;创建部门&lt;/h3&gt;
&lt;p&gt;首先我们需要创建一个部门，然后将成员添加到一个部门里面&lt;br/&gt;&lt;img src=&quot;https://djxblog.oss-cn-shenzhen.aliyuncs.com/picture/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E9%A2%84%E8%AD%A6/%E6%B7%BB%E5%8A%A0%E9%83%A8%E9%97%A8.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;邀请成员加入&quot;&gt;邀请成员加入&lt;/h3&gt;
&lt;p&gt;我们可以在首页点击进行邀请。&lt;br/&gt;&lt;img src=&quot;https://djxblog.oss-cn-shenzhen.aliyuncs.com/picture/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E9%A2%84%E8%AD%A6/%E9%82%80%E8%AF%B7%E5%8A%A0%E5%85%A5.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也可以在选中要添加的部门后再选右边的添加成员或者微信邀请。&lt;br/&gt;&lt;img src=&quot;https://djxblog.oss-cn-shenzhen.aliyuncs.com/picture/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E9%A2%84%E8%AD%A6/%E9%82%80%E8%AF%B7%E6%88%90%E5%91%982.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;创建应用&quot;&gt;创建应用&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://djxblog.oss-cn-shenzhen.aliyuncs.com/picture/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E9%A2%84%E8%AD%A6/%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建的时候指定下可以接收的消息的部门&lt;br/&gt;&lt;img src=&quot;https://djxblog.oss-cn-shenzhen.aliyuncs.com/picture/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E9%A2%84%E8%AD%A6/%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A82.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;关注微工作平台&quot;&gt;关注微工作平台&lt;/h3&gt;
&lt;p&gt;在我的企业 ---》 微工作平台 ---》邀请关注&lt;br/&gt;&lt;img src=&quot;https://djxblog.oss-cn-shenzhen.aliyuncs.com/picture/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E9%A2%84%E8%AD%A6/%E5%85%B3%E6%B3%A8%E5%BE%AE%E5%B9%B3%E5%8F%B0.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三-实现预警&quot;&gt;三 实现预警&lt;/h2&gt;
&lt;p&gt;在完成的上面的所有准备工作后，我们还需要获取三个东西 ：&lt;/p&gt;
&lt;p&gt;1 企业ID&lt;/p&gt;
&lt;p&gt;2 获取应用ID和Secret&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取企业ID&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://djxblog.oss-cn-shenzhen.aliyuncs.com/picture/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E9%A2%84%E8%AD%A6/%E8%8E%B7%E5%8F%96%E4%BC%81%E4%B8%9AID.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取应用ID和Secret&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://djxblog.oss-cn-shenzhen.aliyuncs.com/picture/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E9%A2%84%E8%AD%A6/%E8%8E%B7%E5%8F%96%E5%BA%94%E7%94%A8id%E5%92%8C%E8%AE%A4%E8%AF%81.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;通过shell-脚本实现监控预警&quot;&gt;通过shell 脚本实现监控预警&lt;/h3&gt;
&lt;p&gt;该shell 脚本实现的功能： 检测端口是否在监听状态，不在则进行微信预警。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/bash
###############
#$Auth= djx
#$Function= monitoring service
#Date= 2018-12-26
###############
# 日志储存文件
log_file='/var/log/ljf_status.log'
# 主机名
hostname=`hostname`
# 监听的端口数组
check_port=(&quot;3306&quot; &quot;3329&quot; &quot;4567&quot;)
# 数组长度
num=${#check_port[*]}
#  报警消息
msg=&quot;&quot;
echo &quot;--------------------------$(date +%F_%T)-----------------&quot; &amp;gt;&amp;gt;$log_file

for i in  `seq 0 $num`
do
    netstat -tnlp|grep &quot;${check_port[${i}]}&quot;  &amp;gt;&amp;gt;/dev/null
    if [ $? -ne 0 ]
    then
        msg=&quot;\\n${hostname}:The Port ${check_port[${i}]} is down \\n&quot;${msg}
        echo &quot;$(date +%F_%T)  ${hostname}:The Port ${check_port[${i}]} is down&quot;&amp;gt;&amp;gt;$log_file
    fi
done
if [ &quot;${msg}&quot; !=  &quot;&quot; ]
then
    CropID=&quot;&quot;   #填入企业ID值
    Secret=&quot;&quot;   #填入认证密码
    GURL=&quot;https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=$CropID&amp;amp;corpsecret=$Secret&quot;  
    # 获取token
    Gtoken=$(/usr/bin/curl -s -G $GURL | awk -F\&quot; '{print $10}')  
    PURL=&quot;https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=$Gtoken&quot; 
    body='{
    &quot;touser&quot;: &quot;@all&quot;,
    &quot;msgtype&quot;: &quot;text&quot;,
    &quot;agentid&quot;: &quot;1000002&quot;, #要更改为我们的应用ID
    &quot;text&quot;:{
          &quot;content&quot;:&quot;
    故障：'$msg' &quot;
             },
    &quot;safe&quot;:0
    }'
    /usr/bin/curl --data-ascii &quot;$body&quot; $PURL &amp;gt;&amp;gt;$log_file 2&amp;gt;&amp;amp;1
fi&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;通过python-脚本实现监控预警&quot;&gt;通过python 脚本实现监控预警&lt;/h3&gt;
&lt;p&gt;由于centos7和centos6 默认安装的都是python2版本，所以下面的脚本是基于python2写的，这样我们就可以直接拿到我们的服务器上使用了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# -*- coding: utf-8 -*-
# @Time    : 2018/12/27 0021 11:58
# @Author  : djx
# @Email   : 1120236774@qq.com
# @File    : 微信预警脚本.py
# @Software: PyCharm
import os
import time
import urllib2
import json


# 企业号ID
wxid = &quot;&quot;
# 应用ID
depid = &quot;&quot;
# 认证密码
secret = &quot;&quot;
# 获取主机的名称
hostname = os.popen(&quot;hostname&quot;).read()
# 日志储存文件
log_file = '/var/log/ljf_status.log'
# 监听的端口列表
check_port = (
    &quot;8500&quot;,
    &quot;3306&quot;)
# 发送的消息
msg = &quot;&quot;
# 获取当前的时间
date_time = time.strftime(&quot;%Y-%m-%d %X&quot;)
# 检查端口是否在监听
for i in check_port:
    shell = &quot;netstat -nutlp |grep \&quot;&quot; + i + &quot;\&quot;&quot;
    recv = os.popen(shell).read()
    if recv == &quot;&quot;:
        msg = msg  + hostname + &quot;: The Port &quot; + i + &quot;is down \n&quot;
# 预警判断
if msg != &quot;&quot;:
    url = &quot;https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=&quot; + \
        wxid + &quot;&amp;amp;corpsecret=&quot; + secret
    request = urllib2.Request(url)
    response = urllib2.urlopen(request)
    recv_info = response.read()
    recv_info = eval(recv_info) 
    wx_token = recv_info['access_token']
    msg_url = &quot;https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=&quot; + wx_token
    send_msg = {
        &quot;touser&quot;: &quot;@all&quot;,
        &quot;msgtype&quot;: &quot;text&quot;,
        &quot;agentid&quot;: depid,
        &quot;text&quot;: {&quot;content&quot;: msg},
        &quot;safe&quot;: 0
    }
    send_msg_json = json.dumps(send_msg)
    request_post = urllib2.urlopen(msg_url,send_msg_json)
    recv_msg = request_post.read()
    with open(log_file,mode='a') as f:
        f.write(date_time)
        f.write(&quot;\n&quot;)
        f.write(msg)
        f.write(recv_msg)
        f.write(&quot;\n&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的脚本也可以应用在zabbix或者是Open-falcon。&lt;/p&gt;
&lt;p&gt;最后送上一句觉得不错的话 ： &lt;strong&gt;立志要如山，行道要如水，如山能坚定，如水能曲达&lt;/strong&gt;。&lt;/p&gt;
</description>
<pubDate>Thu, 27 Dec 2018 05:01:00 +0000</pubDate>
<dc:creator>自由早晚乱余生</dc:creator>
<og:description>[TOC] 一 注册企业微信 本文所有内容是基于2018年12月26日时的企业微信版本所做的教程。后面可能由于企业微信界面规则更改导致部分流程不一致。（大家看文章时请注意这一点） 注册企业微信必备条件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/operationhome/p/10184367.html</dc:identifier>
</item>
<item>
<title>分布式系统中&quot;身份证&quot;是如何生成的？ - 一天不进步，就是退步</title>
<link>http://www.cnblogs.com/davidwang456/p/10183183.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/davidwang456/p/10183183.html</guid>
<description>&lt;p&gt;1.公民身份证是如何生产的？&lt;/p&gt;
&lt;p&gt;根据中华人民共和国国家标准GB 11643-1999 公民身份号码规则&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/486074/201812/486074-20181227092258752-1970853328.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/486074/201812/486074-20181227092845622-1659794725.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;校验码公式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/486074/201812/486074-20181227092928129-198753373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;校验码规则说明&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/486074/201812/486074-20181227101257350-803844772.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.分布式系统中&quot;身份证&quot;&lt;/p&gt;
&lt;p&gt;分布式系统，有的业务系统，都有生成ID的需求，如订单id，商品id，文章ID等。这个&quot;身份证&quot;一般要求：&lt;/p&gt;
&lt;p&gt;&amp;gt;&amp;gt;全局唯一&lt;/p&gt;
&lt;p&gt;&amp;gt;&amp;gt;有序&lt;/p&gt;
&lt;p&gt;分布式系统中&quot;身份证&quot;生成常用方法：&lt;/p&gt;
&lt;p&gt;1.数据库生成法&lt;/p&gt;
&lt;p&gt;　　沈剑老师在&amp;lt;&lt;a href=&quot;https://mp.weixin.qq.com/s/0H-GEXlFnM1z-THI8ZGV2Q&quot; target=&quot;_blank&quot;&gt;细聊分布式ID生成方法&lt;/a&gt;&amp;gt;中提到两个方法：1.单个法(auto_increment) 2.批量法(也称步长法) 其中详述了它们的优缺点，我就不一一赘述了。&lt;/p&gt;
&lt;p&gt;2.redis生成法&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;amp;mid=2247484269&amp;amp;idx=1&amp;amp;sn=795446b290f75c3129c50f8fa2e0b2c8&amp;amp;chksm=ebf6db12dc815204e81f6fddc4e690c3315c0e3ce71753b73720e74d47b9d08c633a617ccd95&amp;amp;scene=27#wechat_redirect&quot; target=&quot;_blank&quot;&gt;分布式唯一ID极简教程&lt;/a&gt; 中提到，不赘述  &lt;/p&gt;
&lt;p&gt;3.zk生成法&lt;/p&gt;
&lt;p&gt;     与redis类似，不赘述。&lt;/p&gt;
&lt;p&gt;4.mongo生成法&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;amp;mid=2247484269&amp;amp;idx=1&amp;amp;sn=795446b290f75c3129c50f8fa2e0b2c8&amp;amp;chksm=ebf6db12dc815204e81f6fddc4e690c3315c0e3ce71753b73720e74d47b9d08c633a617ccd95&amp;amp;scene=27#wechat_redirect&quot; target=&quot;_blank&quot;&gt;分布式唯一ID极简教程&lt;/a&gt; 中提到，不赘述  &lt;/p&gt;
&lt;p&gt;5.类snowflakes生成法&lt;/p&gt;
&lt;p&gt;沈剑老师在&amp;lt;&lt;a href=&quot;https://mp.weixin.qq.com/s/0H-GEXlFnM1z-THI8ZGV2Q&quot; target=&quot;_blank&quot;&gt;细聊分布式ID生成方法&lt;/a&gt;&amp;gt;中也提到，不赘述&lt;/p&gt;
&lt;p&gt;6.uuid法&lt;/p&gt;
&lt;p&gt;沈剑老师在&amp;lt;&lt;a href=&quot;https://mp.weixin.qq.com/s/0H-GEXlFnM1z-THI8ZGV2Q&quot; target=&quot;_blank&quot;&gt;细聊分布式ID生成方法&lt;/a&gt;&amp;gt;中也提到，不赘述&lt;/p&gt;
&lt;p&gt;7.msic法&lt;/p&gt;
&lt;p&gt;其中，1~6种方法，网上都可以轻易找到，这里就不赘述了。&lt;/p&gt;
&lt;p&gt;重点是方式 7，通过业务结合，灵活利用1~6来做，下面是我根据公民身份证唯一的思路来设计&lt;span&gt;订单号&lt;/span&gt;一种方式，仅供参考&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;1.时间戳为毫秒级&lt;/p&gt;
&lt;p&gt;2.用户号9位可以满足大部分系统需求，可以根据系统修正&lt;/p&gt;
&lt;p&gt;3.顺序码 3位 是该用户同时下单的顺序码，先从redis查找，该用户在1分钟之内是否有订单，没有则设置为1，返回1，否则增加1&lt;/p&gt;
&lt;p&gt;4.校验码，验证订单号是否符合规则，不符合规则的抛弃。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/486074/201812/486074-20181227123117384-1151103591.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 5. 建议使用数据库+redis缓存方式来做，多库的时候订单号也可以加上库信息&lt;/p&gt;
&lt;p&gt;小结：&lt;/p&gt;
&lt;p&gt;总体而言，分布式唯一ID需要满足以下条件：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;9&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;高可用性：不能有单点故障。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;全局唯一性：不能出现重复的ID号，既然是唯一标识，这是最基本的要求。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;趋势递增：在MySQL InnoDB引擎中使用的是聚集索引，由于多数RDBMS使用B-tree的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;时间有序：以时间为序，或者ID里包含时间。这样一是可以少一个索引，二是冷热数据容易分离。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;分片支持：可以控制ShardingId。比如某一个用户的文章要放在同一个分片内，这样查询效率高，修改也容易。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;单调递增：保证下一个ID一定大于上一个ID，例如事务版本号、IM增量消息、排序等特殊需求。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;长度适中：不要太长，最好64bit。使用long比较好操作，如果是96bit，那就要各种移位相当的不方便，还有可能有些组件不能支持这么大的ID。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;信息安全：如果ID是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定URL即可；如果是订单号就更危险了，竞争对手可以直接知道我们一天的单量。所以在一些应用场景下，会需要ID无规则、不规则。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;【1】https://mp.weixin.qq.com/s/0H-GEXlFnM1z-THI8ZGV2Q&lt;/p&gt;
&lt;p&gt;【2】https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;amp;mid=2247484269&amp;amp;idx=1&amp;amp;sn=795446b290f75c3129c50f8fa2e0b2c8&amp;amp;chksm=ebf6db12dc815204e81f6fddc4e690c3315c0e3ce71753b73720e74d47b9d08c633a617ccd95&amp;amp;scene=27#wechat_redirect &lt;/p&gt;

</description>
<pubDate>Thu, 27 Dec 2018 04:46:00 +0000</pubDate>
<dc:creator>一天不进步，就是退步</dc:creator>
<og:description>1.公民身份证是如何生产的？ 根据中华人民共和国国家标准GB 11643-1999 公民身份号码规则 示例： 校验码公式 校验码规则说明 2.分布式系统中&quot;身份证&quot; 分布式系统，有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/davidwang456/p/10183183.html</dc:identifier>
</item>
</channel>
</rss>