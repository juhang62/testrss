<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>最通俗易懂的 Java 10 新特性讲解 - 未读代码</title>
<link>http://www.cnblogs.com/niumoo/p/12365081.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niumoo/p/12365081.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1202902/202002/1202902-20200226084645510-1747640936.png&quot; alt=&quot;Java 10 新特性&quot;/&gt;&lt;/p&gt;
&lt;p&gt;自从 &lt;code&gt;Java 9&lt;/code&gt; 开始，Oracle 调整了 Java 版本的发布策略，不再是之前的 N 年一个大版本，取而代之的是 6 个月一个小版本，三年一个大版本，这样可以让 Java 的最新改变迅速上线，而小版本的维护周期缩短到下个版本发布之前，大版本的维护周期则是 3 年之久。而 10 就是这么一个小版本，因为 Java 的后续版本基本都会包含之前新特性，所以还是把 &lt;code&gt;Java 10&lt;/code&gt; 带来的改变单独写一写。&lt;/p&gt;
&lt;h2 id=&quot;jep-322---基于时间的版本号&quot;&gt;1. JEP 322 - 基于时间的版本号&lt;/h2&gt;
&lt;p&gt;就像上面说的，Java 调整了发布策略，为了适应这种发布节奏，随着改变的还有 Java 版本号的记录方式。&lt;/p&gt;
&lt;p&gt;版本号的新模式是：&lt;code&gt;$FEATURE.$INTERIM.$UPDATE.$PATCH&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;$FEATURE&lt;/code&gt; ：基于发布版本，如 Java 10 的 10 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$INTERIM&lt;/code&gt; ：问题修复和功能增强时 + 1，默认是 0 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$UPDATE&lt;/code&gt; ：在进行兼容更新，修复新功能安全问题时 +1。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$PATCH&lt;/code&gt; ：特殊问题修复时 +1。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;查看自己的 &lt;code&gt;Java 10&lt;/code&gt; 版本。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;$ java -version
java version &quot;10.0.1&quot; 2018-04-17
Java(TM) SE Runtime Environment 18.3 (build 10.0.1+10)
Java HotSpot(TM) 64-Bit Server VM 18.3 (build 10.0.1+10, mixed mode)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;jep-286---局部类型推断&quot;&gt;2. JEP 286 - 局部类型推断&lt;/h2&gt;
&lt;p&gt;JEP 286 提案让 Java 增加了局部类型推断（Local-Variable Type Inference）功能，这让 Java 可以像 &lt;code&gt;Js&lt;/code&gt; 里的 &lt;code&gt;var&lt;/code&gt; 或者其他语言的 &lt;code&gt;auto&lt;/code&gt; 一样可以自动推断数据类型。这其实只是一个新的语法糖，底层并没有变化，在编译时就已经把 &lt;code&gt;var&lt;/code&gt; 转化成具体的数据类型了，但是这样可以减少代码的编写。&lt;/p&gt;
&lt;p&gt;你可以像下面这样使用 &lt;code&gt;var&lt;/code&gt; 语法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;var hashMap = new HashMap&amp;lt;String, String&amp;gt;();
hashMap.put(&quot;微信&quot;,&quot;wn8398&quot;);
var string = &quot;hello java 10&quot;;
var stream = Stream.of(1, 2, 3, 4);
var list = new ArrayList&amp;lt;String&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你反编译编译后的这段代码，你会发现还是熟悉的代码片段。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;HashMap&amp;lt;String, String&amp;gt; hashMap = new HashMap();
hashMap.put(&quot;微信&quot;, &quot;wn8398&quot;);
String string = &quot;hello java 10&quot;;
Stream&amp;lt;Integer&amp;gt; stream = Stream.of(1, 2, 3, 4);
ArrayList&amp;lt;String&amp;gt; list = new ArrayList();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;var&lt;/code&gt; 看似好用，其实也有很多限制，官方介绍了 &lt;code&gt;var&lt;/code&gt; 只能用于下面的几种情况。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;仅限带有初始化的程序的局部变量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for&lt;/code&gt; 循环或者&lt;code&gt;增强for&lt;/code&gt; 循环中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for&lt;/code&gt;循环中的声明。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面演示三种使用情况。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void testVar() {
    // 情况1，没有初始化会报错
    // var list;
    var list = List.of(1, 2, 3, 4);
    // 情况2
    for (var integer : list) {
        System.out.println(integer);
    }
    // 情况3
    for (var i = 0; i &amp;lt; list.size(); i++) {
        System.out.println(list.get(i));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;尽管对 &lt;code&gt;var&lt;/code&gt; 的使用场景增加了很多限制，但在实际使用时你还是要注意，就像下面的代码，你可能一眼并不能看出 &lt;code&gt;result&lt;/code&gt; 的数据类型。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;var query = &quot;xxx&quot;;
var result = dbUtil.executeQuery(query);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;jep-317---基于-java-的-jit-编译器实验性&quot;&gt;3. JEP 317 - 基于 Java 的 JIT 编译器（实验性）&lt;/h2&gt;
&lt;p&gt;这个功能让基于 Java 开发的 JIT 编译器 &lt;code&gt;Graal&lt;/code&gt; 结合 &lt;code&gt;Java 10&lt;/code&gt; 用在 Linux / x64 平台上，这是一个实验性的 JIT 编译器，有人说这也是 &lt;code&gt;Java 10&lt;/code&gt; 中最具有未来感的引入。Graal 其实在 &lt;code&gt;Java 9&lt;/code&gt; 中就已经引入了，它带来了 Java 中的 AOT （Ahead Of Time）编译，还支持多种语言，如 Js、Python、Ruby、R、以及其他基于 JVM （如 Java、Kotlin）的和基于 LLVM （如 C、C++）的语言。&lt;/p&gt;
&lt;p&gt;想切换到 &lt;code&gt;Graal&lt;/code&gt; 可以使用下面的 &lt;code&gt;jvm&lt;/code&gt; 参数。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里面有一点我觉得很有意思，看这个图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1202902/202002/1202902-20200226084645695-465287350.png&quot; alt=&quot;Graal 由 Java 编写&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这就很有意思了，&lt;code&gt;Graal&lt;/code&gt; 是 Java 语言编写的，用 Java 编写的编译器，然后用来将 Java 字节码编译机器代码。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Graal&lt;/code&gt; 官网：&lt;a href=&quot;https://www.graalvm.org/&quot; class=&quot;uri&quot;&gt;https://www.graalvm.org/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;jep-310---类数据共享&quot;&gt;4. JEP 310 - 类数据共享&lt;/h2&gt;
&lt;p&gt;JVM 启动时有一步是需要在内存中加载类，而如果有多个 jar，加载第一个 jar 的速度是最慢的。这就延长了程序的启动时间，为了减少这个时间，&lt;code&gt;Java 10&lt;/code&gt; 引入了应用程序类数据共享（CDS）机制，它可以把你想共享的类共享在程序之间，使不同的 Java 进程之间共享这个类来减少这个类占用的空间以及加载速度。&lt;/p&gt;
&lt;h2 id=&quot;jep-307---g1-并行全gc&quot;&gt;5. JEP 307 - G1 并行全GC&lt;/h2&gt;
&lt;p&gt;早在 &lt;code&gt;Java 9&lt;/code&gt; 时就已经引入了 G1 垃圾收集器，G1 的优点很多。而在 &lt;code&gt;Java 10&lt;/code&gt; 中还是做了小小调整，当 G1 的并发收集线程不能快速的完成全 GC 时，就会自动切换到&lt;strong&gt;并行&lt;/strong&gt;收集，这可以减少在最坏情况下的 GC 速度。&lt;/p&gt;
&lt;h2 id=&quot;jep-314---unicode-语言标签扩展&quot;&gt;6. JEP 314 - Unicode 语言标签扩展&lt;/h2&gt;
&lt;p&gt;这个提案让 JDK 实现了最新的 &lt;a href=&quot;http://www.unicode.org/reports/tr35/tr35.html#Locale_Extension_Key_and_Type_Data&quot;&gt;LDML 规范&lt;/a&gt;中指定的更多的扩展。&lt;/p&gt;
&lt;p&gt;主要增加了下面几个扩展方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;java.time.temporal.WeekFields::of
java.util.Calendar::{getFirstDayOfWeek,getMinimalDaysInWeek}
java.util.Currency::getInstance
java.util.Locale::getDisplayName
java.util.spi.LocaleNameProvider
java.text.DateFormat::get*Instance
java.text.DateFormatSymbols::getInstance
java.text.DecimalFormatSymbols::getInstance
java.text.NumberFormat::get*Instance
java.time.format.DateTimeFormatter::localizedBy
java.time.format.DateTimeFormatterBuilder::getLocalizedDateTimePattern
java.time.format.DecimalStyle::of&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;尝试一下。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Currency chinaCurrency = Currency.getInstance(Locale.CHINA);
Currency usCurrency = Currency.getInstance(Locale.US);
System.out.println(&quot;本地货币：&quot; + chinaCurrency);
System.out.println(&quot;US.货币：&quot; + usCurrency);

String displayName = Locale.getDefault().getDisplayName();
String displayLanguage = Locale.getDefault().getDisplayLanguage();
String displayCountry = Locale.getDefault().getDisplayCountry();
System.out.println(&quot;本地名称：&quot; + displayName);
System.out.println(&quot;本地语言：&quot; + displayLanguage);
System.out.println(&quot;本地国家：&quot; + displayCountry);
int firstDayOfWeek = Calendar.getInstance().getFirstDayOfWeek();
System.out.println(&quot;本地每周第一天：&quot; + firstDayOfWeek);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;本地货币：CNY
US.货币：USD
本地名称：中文 (中国)
本地语言：中文
本地国家：中国
本地每周第一天：1&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;api-更新&quot;&gt;7. API 更新&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Java 10&lt;/code&gt; 删除了部分 API，也增加了一些实用方法。比如可以通过 &lt;code&gt;Collection.copyOf&lt;/code&gt; 复制得到一个不可改变集合，即使原来的集合元素发生了变化也不会有影响。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;var list = new ArrayList&amp;lt;String&amp;gt;();
list.add(&quot;wechat&quot;);
list.add(&quot;wn8398&quot;);
List&amp;lt;String&amp;gt; copyList = List.copyOf(list);
list.add(&quot;test&quot;);
System.out.println(copyList);
// result
// [wechat, wn8398]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也为 &lt;code&gt;Optional&lt;/code&gt; 增加了一个新的方法 &lt;code&gt;orElseThrow&lt;/code&gt;。调用这个方法也可以获取到 &lt;code&gt;optional&lt;/code&gt; 中的 &lt;code&gt;value&lt;/code&gt; , 但是如果 &lt;code&gt;value&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，就会抛出异常。&lt;/p&gt;
&lt;p&gt;另外在 &lt;code&gt;Stream&lt;/code&gt; 最后收集数据的时候，&lt;code&gt;Collectors&lt;/code&gt; 可以直接指定收集的集合为不可变集合，像下面这样。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;list.stream().collect(Collectors.toUnmodifiableList());
list.stream().collect(Collectors.toUnmodifiableSet());&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;其他更新&quot;&gt;其他更新&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Java 10&lt;/code&gt; 的更新内容不止这些，上面只是列举了常用的以及比较有意思的新特性。还有部分更新如：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;JEP 312：Thread-Local Handshakes，JVM 内部功能，可以提高 JVM 性能。&lt;/li&gt;
&lt;li&gt;JEP 313：删除了 &lt;code&gt;javah&lt;/code&gt; 工具，说是删除，其实功能已经包含在 &lt;code&gt;Java 8&lt;/code&gt; 中的 &lt;code&gt;javac&lt;/code&gt; 里。&lt;/li&gt;
&lt;li&gt;JEP 316：让 JVM 可以在备用的存储设备（如 NV-DIMM）上分配堆内存，而不用更改程序代码。&lt;/li&gt;
&lt;li&gt;JEP 319：在JDK中提供一组默认的根证书颁发机构（CA）证书。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;文章案例都已经上传到 Github：&lt;a href=&quot;https://github.com/niumoo/jdk-feature&quot;&gt;niumoo/jdk-feature&lt;/a&gt;&lt;br/&gt;&amp;lt;完&amp;gt;&lt;br/&gt;这片文章是&lt;strong&gt;达西&lt;/strong&gt;的原创文章。&lt;br/&gt;如果你也喜欢，可以关注公众号，不断推送原创文章与你分享。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1202902/202002/1202902-20200226084647720-216191035.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 26 Feb 2020 00:47:00 +0000</pubDate>
<dc:creator>未读代码</dc:creator>
<og:description>自从 开始，Oracle 调整了 Java 版本的发布策略，不再是之前的 N 年一个大版本，取而代之的是 6 个月一个小版本，三年一个大版本，这样可以让 Java 的最新改变迅速上线，而小版本的维护周</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/niumoo/p/12365081.html</dc:identifier>
</item>
<item>
<title>从零开始学习MySQL全文索引 - 雪山飞猪</title>
<link>http://www.cnblogs.com/chenqionghe/p/12364524.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenqionghe/p/12364524.html</guid>
<description>&lt;p&gt;我们在用一个东西前，得知道为什么要用它，使用全文索引无非有以下原因&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;like查询太慢、json字段查询太慢（车太慢了）&lt;/li&gt;
&lt;li&gt;没时间引入ElasticSearch、Solr或者Sphinx这样的软件，或者根本就不会用（无法将五菱宏光换成兰博基尼，即使有兰博基尼也不会开）&lt;/li&gt;
&lt;li&gt;加索引、联合索引啥的都已经慢得不行了（限速80，车顶盖都卸了也只能开到30）&lt;/li&gt;
&lt;li&gt;为了提升一下自己的逼格（人家问你有没有开过法拉利，你说开过肯定更有气质一点）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;简单的说，全文索引就相当于大词典中的目录，通过查询目录可以快速定位到想看的内容。&lt;br/&gt;全文索引通过建立&lt;code&gt;倒排索引&lt;/code&gt;来快速匹配文档（仅在mysql5.6版本以上支持）&lt;br/&gt;全文索引将连续的&lt;code&gt;字母、数字和下划线&lt;/code&gt;当做一个单词，分割单词一般用&lt;code&gt;空格/逗号/句号&lt;/code&gt;&lt;br/&gt;MySQL的全文索引支持以下3种查询模式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;自然语言模式（&lt;code&gt;IN NATURAL LANGUAGE MODE&lt;/code&gt;）&lt;br/&gt;通过MATCH AGAINST 传递某个特定的字符串来进行检索&lt;/li&gt;
&lt;li&gt;布尔模式（&lt;code&gt;IN BOOLEAN MODE&lt;/code&gt;）&lt;br/&gt;支持操作符，例如+表示包含，-表示不包含&lt;/li&gt;
&lt;li&gt;扩展模式（&lt;code&gt;WITH QUERY EXPANSION&lt;/code&gt;）&lt;br/&gt;相当于自然语言模式下的一个扩展，执行两次检索，第一次使用给定短语检索，第二次是结合第一次相关性比较高的行进行检索.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;更多请看：&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.6/en/fulltext-search.htmll&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面教大家如何创建全文索引，并创建测试数据演示三种查询模式的使用&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;方式一：建表时指定&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;CREATE TABLE light_weight_baby ( 
    id INT AUTO_INCREMENT NOT NULL PRIMARY KEY, 
    title VARCHAR(200), 
    content TEXT, 
    FULLTEXT(title, content) 
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ; &lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;方式二：ALTER添加&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt; ALTER TABLE table_name ADD FULLTEXT INDEX index_name (column1,column2,...);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;方式三：CRATE INDEX添加&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;CREATE FULLTEXT INDEX index_name ON table_name (column1,column2,...);&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;创建一个数据库用来演示这三种模式下的检索&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CREATE DATABASE chenqionghe DEFAULT CHARSET utf8;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建一个文章表并插入测试数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CREATE TABLE articles (
    id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,
    title VARCHAR(200),
    body TEXT,
    FULLTEXT (title,body)
) ENGINE=InnoDB;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;插入测试数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;INSERT INTO articles (title,body) VALUES
    ('MySQL Tutorial','DBMS stands for DataBase ...'),
    ('How To Use MySQL Well','After you went through a ...'),
    ('Optimizing MySQL','In this tutorial we will show ...'),
    ('1001 MySQL Tricks','1. Never run mysqld as root. 2. ...'),
    ('MySQL vs. YourSQL','In the following database comparison ...'),
    ('MySQL Security','When configured properly, MySQL ...');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果如下&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/202002/662544-20200225232701251-206526538.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这是MySQL的默认查询模式，简单示例如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT * FROM articles
    WHERE MATCH (title,body)
    AGAINST ('database' IN NATURAL LANGUAGE MODE);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/202002/662544-20200225232817449-773214737.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，不区分大小写，title或body包含database的都返回了，另外，返回的结果将以相关性进行排序。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;相关性：根据行中的字段、唯一单词的数量、集合中单词总数和包含特定单词的行数计算。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面通过两种方式统计数量&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 第一种方式
 SELECT COUNT(*) FROM articles
    WHERE MATCH (title,body)
    AGAINST ('database' IN NATURAL LANGUAGE MODE);
# 第二种方式
SELECT
   COUNT(IF(MATCH (title,body) AGAINST ('database' IN NATURAL LANGUAGE MODE), 1, NULL))
    AS count
    FROM articles;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/202002/662544-20200225232918196-1692789236.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一种做了一些额外的工作（按相关性对结果进行排序），但也能使用索引进行查询。&lt;br/&gt;第二种执行了全表扫描，如果搜索项出现在大多数行中，可能比索引查询更快&lt;br/&gt;匹配少数行，第一种快，匹配大多数行，第二种快&lt;/p&gt;
&lt;p&gt;下面演示如何检索相关性，但不会进行排序（因为不包含&lt;code&gt;WHERE&lt;/code&gt;和&lt;code&gt;ORDER BY&lt;/code&gt;）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT id, MATCH (title,body)
     AGAINST ('Tutorial' IN NATURAL LANGUAGE MODE) AS score
    FROM articles;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/202002/662544-20200225233008802-1850852737.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面的示例更复杂，返回倒序后的相关性值，分别在SELECT和WHERE语句中使用了MATCH，但是不会导致额外的开销，因为mysql优化器注意到两次MATCH是相同的，只会使用一次全文搜索&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT id, body, MATCH (title,body) AGAINST
    ('Security implications of running MySQL as root'
    IN NATURAL LANGUAGE MODE) AS score
    FROM articles WHERE MATCH (title,body) AGAINST
    ('Security implications of running MySQL as root'
    IN NATURAL LANGUAGE MODE);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/202002/662544-20200225233400067-581184868.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;包含在(&quot;&quot;)中字符中的会被分解为单词，然后在全文索引中进行搜索，简单的说，就是进行OR查询。&lt;/p&gt;

&lt;p&gt;使用布尔模式需要指定&lt;code&gt;IN BOOLEAN MODE&lt;/code&gt;，不会自动根据相关性排序，一些字符具有特殊的含义，例如可以通过+或-表示一个单词必须存在或不存在。&lt;br/&gt;下面的sql语句代表查询必须 包含MySQL但不包含YourSQL&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT * FROM articles WHERE MATCH (title,body)
    AGAINST ('+MySQL -YourSQL' IN BOOLEAN MODE);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/202002/662544-20200225233506239-97226382.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;语法&quot;&gt;语法&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;+&lt;/code&gt;&lt;br/&gt;必须出现&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-&lt;/code&gt;&lt;br/&gt;必须不出现。&lt;br/&gt;注意：这个操作符是用来排除其他操作符的结果，如果只指定这个，将什么都不返回&lt;/li&gt;
&lt;li&gt;无符号&lt;br/&gt;默认情况，代表或，自动分词搜索。和没有指定&lt;code&gt;IN BOOLEAN MODE&lt;/code&gt;的结果一样&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@distance&lt;/code&gt;&lt;br/&gt;用来测试两个或两个以上的单词是否都在一个指定的距离内，在@距离前指定双引号中的搜索词，例如&lt;code&gt;MATCH(col1) AGAINST('&quot;word1 word2 word3&quot; @8' IN BOOLEAN MODE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;br/&gt;提高该条匹配数据的权重值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;br/&gt;降低该条匹配数据的权重值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;()&lt;/code&gt;&lt;br/&gt;相当于表达式分组，和我们数学中的表达式一个道理&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~&lt;/code&gt;&lt;br/&gt;将其相关性由正转负，表示拥有该字会降低相关性，例如&lt;code&gt;+apple ~macintosh&lt;/code&gt; 先匹配apple，但如果同时包含macintosh，排名会靠后&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;&lt;br/&gt;通配符，只能在字符串后面使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&quot;&lt;/code&gt;&lt;br/&gt;完全匹配，被双引号包起来的单词必须整个被匹配&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;示例&quot;&gt;示例&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;apple banana&lt;/code&gt;&lt;br/&gt;包含apple或banana其中一个&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+apple +juice&lt;/code&gt;&lt;br/&gt;必须同时包含apple和juice&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+apple macintosh&lt;/code&gt;&lt;br/&gt;包含apple，但是如果同时包含macintosh会给更高的排序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+apple -macintosh&lt;/code&gt;&lt;br/&gt;包信apple但是不包含macintosh&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+apple ~macintosh&lt;/code&gt;&lt;br/&gt;包含apple，如果同时包含macintosh降低权重&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+apple +(&amp;gt;turnover &amp;lt;strudel)&lt;/code&gt;&lt;br/&gt;1.包含apple和turnover，或，包含apple和strudel&lt;br/&gt;2.包含apple和turnover权重高于包含apple和strudel的记录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apple*&lt;/code&gt;&lt;br/&gt;包含apple单词的行， “apple”, “apples”, “applesauce”, “applet”都会被匹配到&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&quot;some words&quot;&lt;/code&gt;&lt;br/&gt;完全匹配·some words·的行，例如 “some words of wisdom”能匹配但“some noise words”匹配不到&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当搜索短语很短时非常有用，例如搜索database可能意味着MySQL、Oracle、DB2、RDBMS都要被匹配到，这就是这个模式能做的。&lt;br/&gt;添加&lt;code&gt;WITH QUERY EXPANSION&lt;/code&gt;或 &lt;code&gt;IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION&lt;/code&gt;启用，它会执行两次检索，第一次使用给定短语检索，第二次是结合第一次相关性比较高的行进行检索。&lt;br/&gt;例如下面的例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 自然语言模式
SELECT * FROM articles
     WHERE MATCH (title,body)
    AGAINST ('database' IN NATURAL LANGUAGE MODE);

# 扩展模式
SELECT * FROM articles
    WHERE MATCH (title,body)
    AGAINST ('database' WITH QUERY EXPANSION);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/202002/662544-20200225233843406-925720205.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到第二条语句找到了包含MySQL的行，即使该行不包含database，但是因为在第一次的搜索中搜索引擎判断MySQL和database的相关性比较高，所以在执第二次搜索的时候返回了。&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;只能在类型为CHAR、VARCHAR或者TEXT的字段上创建全文索引2.&lt;/li&gt;
&lt;li&gt;MATCH (字段) AGAINST (关键词)，必须和创建时的字段一起，例如MATCH (light,weight,baby)使用的字段名与全文索引muscle(light,weight,baby)定义的字段名一致。如果只对单个字段查询，需要分别创建全文索引&lt;/li&gt;
&lt;li&gt;全文索引是以词为基础的，&lt;code&gt;innodb_ft_min_token_size&lt;/code&gt;和&lt;code&gt;innodb_ft_max_token_size&lt;/code&gt;用来设置单词的最大和最小长度，不在这个长度区间的将忽略。&lt;/li&gt;
&lt;li&gt;在停用词&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/fulltext-stopwords.html&quot;&gt;stopwords&lt;/a&gt;中的将被忽略&lt;/li&gt;
&lt;li&gt;如果要导入大量数据，先导入数据再建全文索引，比先建全文索引再导入数据的方式快很多。&lt;/li&gt;
&lt;li&gt;在MySQL 5.7.6之前，全文索引只支持英文全文索引，不支持中文全文索引，MySQL 5.7.6后内置了ngram全文解析器，支持中文、日文、韩文分词。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 26 Feb 2020 00:47:00 +0000</pubDate>
<dc:creator>雪山飞猪</dc:creator>
<og:description>[toc] 一、为什么要用全文索引 我们在用一个东西前，得知道为什么要用它，使用全文索引无非有以下原因 1. like查询太慢、json字段查询太慢（车太慢了） 2. 没时间引入ElasticSear</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenqionghe/p/12364524.html</dc:identifier>
</item>
<item>
<title>OptaPlanner 7.32.0.Final版本彩蛋 - SolverManager之批量求解 - kentzhang</title>
<link>http://www.cnblogs.com/kentzhang/p/12364917.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kentzhang/p/12364917.html</guid>
<description>&lt;p&gt;上一篇介绍了OptaPlanner 7.32.0.Final版本中的SolverManager接口可以实现异步求解功能。本篇将继续介绍SolverManager的另一大特性 - 批量求解。&lt;/p&gt;
&lt;h2&gt;适用场景&lt;/h2&gt;
&lt;p&gt;在日常的规划系统中，求解一个问题，绝大多数情况下，容许运行的时间较有限，特别是在实时性较高的场景中，可让引擎运算时间不多。因此，这种情况下，会在启动了规划运算后，稍等片刻，即需要从求解程序中获取结果。但有些情况下，当我们遇到问题规模较大时，引擎无法在较短时间内找到相对最优解；甚至某些情况下，没有足够长的运行时间，可行解都可能无法找到。至于原因，可以参考我前面关于OptaPlanner入门文章中关于NPC, NP-Hard问题规模的说明。&lt;/p&gt;
&lt;p&gt;因此，在一些规模大、时间要求不高的场景下，我们可以让引擎在空余时间自动运算。例如通过定时作业的方式，在非工作时间（例如晚间、节假日等）启动引擎对大多个规模的问题进行规划运算；第二天上班的时候，就可获得运算结果。在发布SolverManager之前，我们也完全可以针对不同的场景，设计相应的定时作业程序，让引擎运算自动运行。当然，这种方法与异步规划的问题一样，需要一定的系统设计经验才能把架构设计完美。而7.32.0.Final版本提供的SolverManager接口，则提供一种更简便的方法来实现些需求。&lt;/p&gt;
&lt;h2&gt;SolverManager批量规划特性&lt;/h2&gt;
&lt;p&gt;详细一下SolverManager接口，你应该会发现，与Solver对象的solve方法不同，使用SolverManager的sovle方法对一个问题进行求解时，除了把问题对象作为参数传入solve方法外，还需要传入一个problemID作为参数。其实对于这个参数很好理解，因为SolverManager可以同时对多个问题进行解，必须存在一种方法来识别不同的问题，规划完成后，调用方也需要通过指定的识别号，来获取相应的方案。SolverManager同时对多个问题进行求解时，对问题个数有何要求？它的求解行为是怎么样的呢？&lt;/p&gt;
&lt;h2&gt;SolverManager批量求解的行为&lt;/h2&gt;
&lt;h2&gt;可同时求解多少个问题？&lt;/h2&gt;
&lt;p&gt;其实SolverManager不仅可以实现批量求解问题，而且可以实现同时对多 问题并行求解。通过设置SolverManager的parallelSolverCount属性，可以设置引擎在批量运算时，可以并行求解的问题数。即当SolverManger启动求解运算时，会将parallelSolverCount设定的数量的问题载入运算空间并行求解。通常parallelSolverCount值可以根据CPU、内存等计算机资源的情况，及问题的复杂度而推算。若无法判断此数量，也可以将parallelSolverCount设置为AUTO，引擎会根据具体情况，自动确定并行运算问题的数量，通常情况下，并行数是CPU核心数量的一半。&lt;/p&gt;
&lt;p&gt;值得注意的是，此处的多个问题并行运算，与之前的求解过程多线程运算（Multithreaded incremental solving）是两个概念。多线程并行运算，指的是引擎在求解一个问题时，会将不同的可能解的子集分成多个线程同时计算（主要是计算约束分数和执行启发式算法）。而SolverManager的批量求解过程中，parallelSolverCount属性设定的，是引擎在面对多个问题时，同时求解的问题个数。大家可以设想，如果把Multithreaded incremental solving也启动起来，令引擎在对一个问题求解时可使用多个CPU核心，同时对多个问题并行求解。这种情况涉及的问题就没那么简单。因此，除非你对问题的复杂程度，CPU的核心和运算能力非常清晰，否则上述两个功能，还是设置为自动更好，引擎会根据计算资源运算时的工况，动态地自动确定并行求解的问题个数，及每个问题求解过程中应启动的线程个数。经历过单CPU多线程编程的朋友应该知道，多线程可以提高资源利用率，但有时候线程数量控制得不好，性能上却是起反效果的，最简单的是CPU的线程切换会消耗一定资源的。&lt;/p&gt;
&lt;h2&gt;批量求解的作用&lt;/h2&gt;
&lt;p&gt;在一些不太需要实时规划，规划求解不需要太频繁，运算需时较长的情况，批量求解就可以发挥较好作用。例如需要做一些季度或年度的大型供应链计划，因规划实休数量较大，问题空间可能非常巨大，需要花费相当长的时间才能得行相对最优解，甚至只能是可行解。可通过批量求解的方式，让引擎在空余时间（例如晚上、非工作日）进行运算，从而提高服务器资源的利用率。&lt;/p&gt;
&lt;h2&gt;基本用法&lt;/h2&gt;
&lt;p&gt;以下例子是OptaPlanner用户指南的例子，大家先作参考，目前还没有时间去研究SolverManager在示例程序中的代码，暂时也不知道官方示例中是否已经有SolverManager相关代码；若没有，稍后的时候我自己试用一下这些功能，再写一篇东西出来分享给大家。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;原创不易，如果觉得文章对你有帮助，欢迎点赞、评论。文章有疏漏之处，欢迎批评指正。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本系列文章在公众号不定时连载，请关注公众号（让APS成为可能）及时接收,二维码：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//weixin.qq.com/r/WjtFXSvE2HanrW8_925I&quot; data-cke-saved-href=&quot;https://link.zhihu.com/?target=http%3A//weixin.qq.com/r/WjtFXSvE2HanrW8_925I&quot;&gt;http://weixin.qq.com/r/WjtFXSvE2HanrW8_925I&lt;/a&gt; (二维码自动识别)&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;如需了解更多关于OptaPlanner的应用，请发电邮致：&lt;a href=&quot;mailto:kentbill@gmail.com&quot; data-cke-saved-href=&quot;mailto:kentbill@gmail.com&quot;&gt;kentbill@gmail.com&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;或到讨论组发表你的意见：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//groups.google.com/forum/%23%21forum/optaplanner-cn&quot; data-cke-saved-href=&quot;https://link.zhihu.com/?target=https%3A//groups.google.com/forum/%23%21forum/optaplanner-cn&quot;&gt;https://groups.google.com/forum/#!forum/optaplanner-cn&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;若有需要可添加本人微信（13631823503）或QQ(12977379)实时沟通，但因本人日常工作繁忙，通过微信,QQ等工具可能无法深入沟通，较复杂的问题，建议以邮件或讨论组方式提出。(讨论组属于google邮件列表，国内网络可能较难访问，需自行解决)&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 25 Feb 2020 17:12:00 +0000</pubDate>
<dc:creator>kentzhang</dc:creator>
<og:description>上一篇介绍了OptaPlanner 7.32.0.Final版本中的SolverManager接口可以实现异步求解功能。本篇将继续介绍SolverManager的另一大特性 - 批量求解。 适用场景</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kentzhang/p/12364917.html</dc:identifier>
</item>
<item>
<title>十天学会CS之操作系统——进程管理01 - WarrenRyan</title>
<link>http://www.cnblogs.com/WarrenRyan/p/12364646.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/WarrenRyan/p/12364646.html</guid>
<description>&lt;h2 id=&quot;进程的概念&quot;&gt;进程的概念&lt;/h2&gt;
&lt;p&gt;进程是计算机中一个非常重要的概念，在整个计算机发展历史中，操作系统中程序运行机制的演变按顺序大致可以分为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;单道程序：通常是指每一次将一个或者一批程序（一个作业）从磁盘加载进内存，CPU必须等待I/O完成后才可以进行执行，CPU利用率低。&lt;/li&gt;
&lt;li&gt;多道程序：讲多个作业调入内存后自动处理，但是单道程序和多道程序均无交互性，可控性差&lt;/li&gt;
&lt;li&gt;进程：程序+PCB(状态周期描述)+数据集&lt;/li&gt;
&lt;li&gt;线程&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;单道----多道系统&quot;&gt;单道 --&amp;gt; 多道系统&lt;/h3&gt;
&lt;p&gt;从单道程序演化为多道程序就是CPU的高速与I/O的低速有着显著矛盾，因此引入了多道程序作为解决。举一个例子，在单道程序中，倘若I/O没有完成，那么CPU就会一直处于空闲状态。但是在多道程序中，当某程序在占用CPU的时候，其余程序可以开始进行I/O请求，互不干扰，这样就减少了在I/O中CPU的空闲。当某个程序释放CPU后，下一程序继续占用CPU。&lt;/p&gt;
&lt;p&gt;在多道程序中，经常会有这种情况，例如某程序需要监测输入值，那么，该程序就会委托I/O系统去取值，那么在取值完成前，该程序并不需要占用CPU，那么程序会由于I/O阻塞主动放弃CPU，并且进入执行队列尾部，此时CPU会按出队列的顺序依次分配。&lt;/p&gt;
&lt;p&gt;多道程序的状态：&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/WarrenRyan/1643641/o_200225152507QQ20200225-232414@2x.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;多道程序的调度&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/WarrenRyan/1643641/o_200225152518QQ20200225-232426@2x.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;多道程序----进程&quot;&gt;多道程序 --&amp;gt; 进程&lt;/h3&gt;
&lt;p&gt;进程就是在程序中加入一些描述程序状态的块（PCB)&lt;/p&gt;
&lt;p&gt;从多道程序演化为进程的过程中是通过提高&lt;strong&gt;并发性&lt;/strong&gt;，从而进一步的提高CPU的利用率。事实上也就是在多道程序死板的调度机制中灵活的进行控制程序运行的顺序等。实现的功能便是PCB的监控。&lt;/p&gt;
&lt;p&gt;进程的状态：&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/WarrenRyan/1643641/o_200225154932QQ20200225-234901@2x.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进程的调度：&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/WarrenRyan/1643641/o_200225152449QQ20200225-232341@2x.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;进程----线程&quot;&gt;进程 --&amp;gt; 线程&lt;/h3&gt;
&lt;p&gt;在进程之下，我们引入了线程。在说线程之前，我们引入那么一个问题，假定你制作了一个即时通讯的程序，如果你只是用一个进程去控制程序运行，会发生什么？事实上这里发生的事情你有时候可以在一些小厂商做出的低劣游戏中发现这一问题。我们在有些制作不好、历史久远或者代码质量差的游戏中，经常能发现，一旦网卡了，整个游戏甚至都会卡顿甚至无响应，游戏的渲染也受到了很大的影响。有时候是因为网络一直在尝试发包导致，但是更多时候是因为进程调度问题。可是为什么网络是基于外部的，却可以影响内部的引擎渲染之类的功能呢？原因就是我们之前讲过，请求网络是一个明显的I/O过程，假设网络不好，那么我们的程序一直处于I/O阻塞的状态下，从而放弃CPU，那么我们渲染的代码也会迟迟得不到运行。会到我们之前的问题，假设你只是用一个进程去制作了即时通讯软件，一旦网络丢包之类的网络故障发生时，你的程序很容易卡顿。&lt;/p&gt;
&lt;p&gt;说了那么多，我们应该如何去解决这个问题？很自然的我们会想到使用多进程去制作一个软件，那么其中一个进程发生阻塞的时候，我们其余的进程会继续占用CPU，则整体运行并不会受太大影响。但是这种方法需要占用大量的时空，因为进程的调度是依赖PCB以及PCB的监控程序，进程切换过程中，上下文切换也会导致PCB状态切换，需要花费大量的时间进行查询、修改等操作，并且内存栈的使用也会过于频繁导致空间消耗，并且在操作系统中，PCB的数量是有限的，因此使用多进程并不是一个号的方法。&lt;/p&gt;
&lt;p&gt;这里我们就引出多线程的方法，&lt;strong&gt;进程就成为了线程的一个容器，且进程和线程可以同时存在&lt;/strong&gt;，线程几乎不占用多少空间，整体也比进程小的多，那么对线程的调度开销就会远比进程小得多。进程的数量也减少了，那么整体系统的压力也小了。&lt;/p&gt;
&lt;h2 id=&quot;进程和程序的区别&quot;&gt;进程和程序的区别&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;程序是一段代码编译后的产物，在执行过程中被拷贝至内存，通常是静态不变的，进程在运行过程中是会发生状态转变，通常认为是动态的。进程是对程序一次执行的过程。&lt;/li&gt;
&lt;li&gt;程序和进程是多对多关系，例如同时执行两个一样的程序和操作系统的GUI绘图渲染与各个可视化程序的关系。你可以在任务管理器中发现这些关系&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;进程的特征&quot;&gt;进程的特征&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;并发性：与OS的并发一致&lt;/li&gt;
&lt;li&gt;异步性：与OS异步一致&lt;/li&gt;
&lt;li&gt;动态性：进程在运行过程中是会发生状态转变，通常认为是动态的。&lt;/li&gt;
&lt;li&gt;结构性：使用了PCB组成&lt;/li&gt;
&lt;li&gt;独立性：在资源分配过程中，各个进程是独立分配。例如各个进程在内存中的位置都是独立的。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;进程的组成&quot;&gt;进程的组成&lt;/h2&gt;
&lt;p&gt;通常我们只考虑为PCB+程序或PCB+指令段+数据段。这里涉及到的指令段和数据段是什么呢？&lt;/p&gt;
&lt;p&gt;指令段就是具体的操作逻辑，而数据段就是存储的具体数据值，他们通常都存储在栈上。例如有一段代码：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public int Add()
{
    return 3+4;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码在进程中会存储函数指针，也就是程序的具体内存位置；3和4将会作为数据段存储在独立的堆栈中，而 ‘+’会存储在指令段中。&lt;/p&gt;
&lt;h3 id=&quot;pcb的组成&quot;&gt;PCB的组成&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;PID：进程的唯一标识&lt;/li&gt;
&lt;li&gt;状态：进程五个状态中的一种&lt;/li&gt;
&lt;li&gt;优先级：用于控制进程的执行顺序&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;指令段的组成&quot;&gt;指令段的组成&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;运行地址：指程序代码在内存中的位置&lt;/li&gt;
&lt;li&gt;外存地址：程序在存储设备上中的位置&lt;/li&gt;
&lt;li&gt;代码段指针：程序指令段在内存中的具体位置&lt;/li&gt;
&lt;li&gt;进入内存时间：进入时间&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;数据段组成&quot;&gt;数据段组成&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;堆栈指针：用于存储数据的地址&lt;/li&gt;
&lt;li&gt;数据段指针：数据段代码的地址&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;进程的组成&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/WarrenRyan/1643641/o_2002251517296F33B270-9B6B-4410-9ADB-7F9C32CC1BE3.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;进程运行分析&quot;&gt;进程运行分析&lt;/h2&gt;
&lt;p&gt;对于一个进程或程序需要运行，以下三个东西是必不可少的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PCB&lt;/li&gt;
&lt;li&gt;内存&lt;/li&gt;
&lt;li&gt;CPU&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;进程的状态：&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/WarrenRyan/1643641/o_200225154932QQ20200225-234901@2x.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于新建--&amp;gt;就绪过程，进程会向操作系统申请内存和PCB，同时将进程排入队列使得这个非常的简单。&lt;/li&gt;
&lt;li&gt;就绪--&amp;gt;运行过程，操作系统需要向进程分配CPU资源使得程序运转。反过来则是因为某些原因使得进程不再占用CPU，通常是时间片用完。&lt;/li&gt;
&lt;li&gt;运行--&amp;gt;阻塞过程，通常是有了一个I/O请求导致了进程的阻塞中断。&lt;/li&gt;
&lt;li&gt;阻塞--&amp;gt;就绪过程是I/O完成后重新唤起进程，使进程重新进入就绪队列&lt;/li&gt;
&lt;li&gt;运行--&amp;gt;完成则是归还内存并删除PCB。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在状态转变的时候，通常就是要实施以下三步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分配（申请）内存或CPU&lt;/li&gt;
&lt;li&gt;回收&lt;/li&gt;
&lt;li&gt;修改PCB&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果我的文章帮助了你，请给我一个三连和star。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/StevenEco/.NetCoreGuide&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://space.bilibili.com/33311288&quot;&gt;BiliBili主页&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.tity.xyz&quot;&gt;WarrenRyan'sBlog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cnblogs.com/warrenryan&quot;&gt;博客园&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 25 Feb 2020 15:32:00 +0000</pubDate>
<dc:creator>WarrenRyan</dc:creator>
<og:description>进程管理01 进程的概念 进程是计算机中一个非常重要的概念，在整个计算机发展历史中，操作系统中程序运行机制的演变按顺序大致可以分为： 1. 单道程序：通常是指每一次将一个或者一批程序（一个作业）从磁盘</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/WarrenRyan/p/12364646.html</dc:identifier>
</item>
<item>
<title>面试官让我手写一个生产者消费者模式 - 烟雨星空</title>
<link>http://www.cnblogs.com/starry-skys/p/12364587.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/starry-skys/p/12364587.html</guid>
<description>&lt;p&gt;不知道你是否遇到过面试官让你手写生产者消费者代码。别说，前段时间有小伙伴还真的遇到了这种情况。当时是一脸懵逼。&lt;/p&gt;
&lt;p&gt;但是，俗话说，从哪里跌倒就要从哪里爬起来。既然这次被问到了，那就回去好好研究一下，争取下一次不再被虐呗。&lt;/p&gt;
&lt;p&gt;于是，今天我决定手敲一个生产者消费者模式压压惊。（因为我也不想以后被面试官血虐啊）&lt;/p&gt;
&lt;p&gt;生产者消费者模式，其实很简单。无非就是生产者不停的生产数据，消费者不停的消费数据。（这不废话吗，字面意思我也知道啊）&lt;/p&gt;
&lt;p&gt;咳咳。其实，我们可以拿水池来举例。&lt;/p&gt;
&lt;p&gt;比如，现在要用多个注水管往水池里边注水，那这些注水管就认为是生产者。从水池里边抽水的抽水管就是消费者。水池本身就是一个缓冲区，用于生产者消费者之间的通讯。&lt;/p&gt;
&lt;p&gt;好的，跟着我的思路。&lt;/p&gt;
&lt;p&gt;既然生产者是生产数据的，那总得定义一个数据类吧（Data）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Data {
    private int id;
    private int num;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public int getNum() {
        return num;
    }

    public void setNum(int num) {
        this.num = num;
    }

    public Data(int id, int num) {
        this.id = id;
        this.num = num;
    }

    public Data() {

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上数据，假设注水管每次注水的id和注水容量num(单位是升)都是递增的。并且，单次出水管的出水量和注水管的注水量是一一对应的。&lt;/p&gt;
&lt;p&gt;生产者的类Producer和消费者类Consumer内部都需要维护一个阻塞队列，来存储缓冲区的数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Producer implements Runnable{
    //共享阻塞队列
    private BlockingDeque&amp;lt;Data&amp;gt; queue;
    //是否还在运行
    private volatile boolean isRunning = true;
    //id生成器
    private static AtomicInteger count = new AtomicInteger();
    //生成随机数
    private static Random random = new Random();

    public Producer(BlockingDeque&amp;lt;Data&amp;gt; queue){
        this.queue = queue;
    }

    @Override
    public void run() {
        try {
            while(isRunning){
                //模拟注水耗时
                Thread.sleep(random.nextInt(1000));
                int num = count.incrementAndGet();
                Data data = new Data(num, num);
                System.out.println(&quot;当前&amp;gt;&amp;gt;注水管:&quot;+Thread.currentThread().getName()+&quot;注水容量(L):&quot;+num);
                if(!queue.offer(data,2, TimeUnit.SECONDS)){
                    System.out.println(&quot;注水失败...&quot;);
                }
            }
        }catch (Exception e){
            e.printStackTrace();
        }
    }

    public void stop(){
        isRunning = false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;消费者：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Consumer implements Runnable{

    private BlockingDeque&amp;lt;Data&amp;gt; queue ;

    private static Random random = new Random();

    public Consumer(BlockingDeque&amp;lt;Data&amp;gt; queue){
        this.queue = queue;
    }

    @Override
    public void run() {
        while (true){
            try {
                Data data = queue.take();
                //模拟抽水耗时
                Thread.sleep(random.nextInt(1000));
                if(data != null){
                    System.out.println(&quot;当前&amp;lt;&amp;lt;抽水管:&quot;+Thread.currentThread().getName()+&quot;,抽取水容量(L):&quot;+data.getNum());
                }
            }catch (Exception e){
                e.printStackTrace();
            }

        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类，假设有三个注水管和三个出水管（即六个线程）同时运行。等一定时间后，所有注水管停止注水，则当水池空（阻塞队列为空）的时候，出水管也将不再出水。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class TestProC {
    public static void main(String[] args) throws InterruptedException {

        BlockingDeque&amp;lt;Data&amp;gt; queue = new LinkedBlockingDeque&amp;lt;&amp;gt;(10);

        Producer producer1 = new Producer(queue);
        Producer producer2 = new Producer(queue);
        Producer producer3 = new Producer(queue);

        Consumer consumer1 = new Consumer(queue);
        Consumer consumer2 = new Consumer(queue);
        Consumer consumer3 = new Consumer(queue);

        ExecutorService service = Executors.newCachedThreadPool();
        service.execute(producer1);
        service.execute(producer2);
        service.execute(producer3);
        service.execute(consumer1);
        service.execute(consumer2);
        service.execute(consumer3);

        Thread.sleep(3000);
        producer1.stop();
        producer2.stop();
        producer3.stop();

        Thread.sleep(1000);
        service.shutdown();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1714084/202002/1714084-20200225231745330-1154893248.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到最后一次注水20L的时候，所有注水管都停止注水了，但此时水池还没空。于是，所有出水管继续消费水资源，直到最后20L也被消费完。&lt;/p&gt;
&lt;p&gt;以上，就是一个典型的生产者消费者模式。&lt;/p&gt;
&lt;p&gt;可以看到，这种模式有很多优点：&lt;/p&gt;
&lt;p&gt;1）可以解耦消费者和生产者，因为它们是两个不同的类，互相之间不会产生影响。&lt;/p&gt;
&lt;p&gt;2）支持并发。生产者只管生产数据就行了，生产完直接把数据丢到缓冲区，而不需要等消费者消费完数据才可以生产下一个数据。否则会造成阻塞，从而影响效率。&lt;/p&gt;
&lt;p&gt;3）允许生产者和消费者有不同的处理速度。如，当生产者生产数据比较快的时候，会把消费者还没来得及处理的数据先放到缓冲区。等有空闲的消费者了，再去缓冲区拿去数据。&lt;/p&gt;
&lt;p&gt;另外，以上的缓冲区，我们一般会使用阻塞队列。就像上边用的LinkedBlockingDeque。&lt;/p&gt;
&lt;p&gt;这样，当队列满的时候，会阻塞生产者继续往队列添加数据，直到有消费者来消费了队列中的数据。当队列空的时候，也会阻塞消费者从队列获取数据，直到有生产者把数据放入到队列中。&lt;/p&gt;
&lt;p&gt;阻塞队列最好使用有界队列（代码中指定的容量为10）。因为，如果生产者的速度远远大于消费者时，就会有可能造成队列的元素一直增加，直到内存耗尽。当然，这也需要看实际的业务情况。如果能保证生产者的数量在可控范围内，不会给内存造成压力，用无界队列，也未尝不可。&lt;/p&gt;
</description>
<pubDate>Tue, 25 Feb 2020 15:18:00 +0000</pubDate>
<dc:creator>烟雨星空</dc:creator>
<og:description>不知道你是否遇到过面试官让你手写生产者消费者代码。别说，前段时间有小伙伴还真的遇到了这种情况。当时是一脸懵逼。 但是，俗话说，从哪里跌倒就要从哪里爬起来。既然这次被问到了，那就回去好好研究一下，争取下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/starry-skys/p/12364587.html</dc:identifier>
</item>
<item>
<title>AVR单片机教程——示波器 - jerry_fuyi</title>
<link>http://www.cnblogs.com/jerry-fuyi/p/12306817.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jerry-fuyi/p/12306817.html</guid>
<description>&lt;p&gt;本文隶属于&lt;a href=&quot;https://www.cnblogs.com/jerry-fuyi/p/avr_tutorial.html&quot; target=&quot;_blank&quot;&gt;AVR单片机教程&lt;/a&gt;系列。&lt;/p&gt;

&lt;p&gt;在用DAC做了一个稍大的项目之后，我们来拿ADC开开刀。在本讲中，我们将了解0.96寸OLED屏，移植著名的U8g2库到我们的开发板上，学习在屏幕上画直线的算法，编写一个示波器程序，使用EEPROM加入人性化功能，最后利用示波器观察555定时器、放大电路、波形变换电路的各种波形。&lt;/p&gt;
&lt;h3 id=&quot;oled屏&quot;&gt;OLED屏&lt;/h3&gt;
&lt;p&gt;我们使用的是0.96寸OLED屏，它由128*64个像素点构成，上16行为蓝色，下48行为黄色，两部分之间有大约两像素的空隙。虽然有两种颜色，但每个像素点都只能发出一种颜色的光，因此这块OLED屏算作单色屏。&lt;/p&gt;
&lt;p&gt;可以插在开发板上的是显示屏模块，它由裸屏和PCB等组成，裸屏通过30 pin的排线焊接在PCB的反面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1734552/202002/1734552-20200214115948256-1383826297.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在裸屏的内部有一块控制与驱动芯片，型号为SSD1315，与SSD1306兼容，它是外部与像素点之间的桥梁。SSD1315有200多个引脚，其中128个segment和64个common以动态扫描的方式驱动每一个像素点，这就是它为什么必须做在裸屏的内部。除了这些以外，它还有许多电源和控制引脚：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;VDD&lt;/code&gt;是控制逻辑的供电，范围为1.65V到3.5V；&lt;code&gt;VCC&lt;/code&gt;是OLED面板驱动电压，范围为7.5V到16.5V；&lt;code&gt;VBAT&lt;/code&gt;是内部电荷泵的供电，范围为3.0V到4.5V，&lt;code&gt;VBAT&lt;/code&gt;经电荷泵升压后提供给&lt;code&gt;VCC&lt;/code&gt;，此时&lt;code&gt;VCC&lt;/code&gt;需要连接电容到地；电荷泵需要两个外部电容，连接在&lt;code&gt;C1P&lt;/code&gt;和&lt;code&gt;C1N&lt;/code&gt;、&lt;code&gt;C2P&lt;/code&gt;和&lt;code&gt;C2N&lt;/code&gt;之间；&lt;code&gt;VCOMH&lt;/code&gt;是一个内部电压，需要连接电容到地；&lt;code&gt;VSS&lt;/code&gt;、&lt;code&gt;VLSS&lt;/code&gt;、&lt;code&gt;BGGND&lt;/code&gt;、&lt;code&gt;LS&lt;/code&gt;都接地；&lt;code&gt;IREF&lt;/code&gt;用于控制参考电压。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;BS[2:0]&lt;/code&gt;用于选择接口模式，支持4线SPI、3线SPI、I²C、8位8080和6800；&lt;code&gt;E(RD)&lt;/code&gt;和&lt;code&gt;R/W(WR)&lt;/code&gt;在并行模式下使用；&lt;code&gt;D[7:0]&lt;/code&gt;为数据，在SPI模式下，&lt;code&gt;D0&lt;/code&gt;是时钟信号，&lt;code&gt;D1&lt;/code&gt;是输入数据信号，&lt;code&gt;D2&lt;/code&gt;连接&lt;code&gt;D1&lt;/code&gt;或地；在I²C模式下，&lt;code&gt;D0&lt;/code&gt;是时钟信号，&lt;code&gt;D1&lt;/code&gt;和&lt;code&gt;D2&lt;/code&gt;一起是数据信号；&lt;code&gt;RES&lt;/code&gt;是复位信号；&lt;code&gt;CS&lt;/code&gt;是片选信号；&lt;code&gt;D/C&lt;/code&gt;用于指定输入是数据还是指令，在I²C模式下为地址选择，在3线SPI模式下保持低电平；&lt;code&gt;FR&lt;/code&gt;、&lt;code&gt;CL&lt;/code&gt;、&lt;code&gt;CLS&lt;/code&gt;都是时钟信号。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;看起来很复杂，但事实上有些信号根本不用管，因为裸屏只有30个引脚，去掉了&lt;code&gt;BS2&lt;/code&gt;、&lt;code&gt;E(RD)&lt;/code&gt;、&lt;code&gt;R/W(WR)&lt;/code&gt;、&lt;code&gt;D[7:3]&lt;/code&gt;、&lt;code&gt;FR&lt;/code&gt;、&lt;code&gt;CL&lt;/code&gt;、&lt;code&gt;CLS&lt;/code&gt;，这些都是不常用的（除了&lt;code&gt;FR&lt;/code&gt;帧同步信号，我觉得有点用）。剩下的你也许需要学，但不是现在，而是在你的项目需要用裸屏的时候，因为那块蓝色的PCB把这些都处理好了，只留下了7个引脚：&lt;code&gt;GND&lt;/code&gt;、&lt;code&gt;VCC&lt;/code&gt;、&lt;code&gt;D0&lt;/code&gt;、&lt;code&gt;D1&lt;/code&gt;、&lt;code&gt;RES&lt;/code&gt;、&lt;code&gt;DC&lt;/code&gt;、&lt;code&gt;CS&lt;/code&gt;。可用的通信模式只有4线SPI、3线SPI和I²C，但已经相当丰富了，可以通过模块背面的电阻来选择，出厂时是4线SPI，也就是我们将要使用的模式。有的模块只支持I²C模式，也就只需要4个引脚了。&lt;/p&gt;
&lt;p&gt;在4线SPI模式下，&lt;code&gt;D0&lt;/code&gt;连接单片机USART1的&lt;code&gt;XCK1&lt;/code&gt;，&lt;code&gt;D1&lt;/code&gt;连接&lt;code&gt;TXD1&lt;/code&gt;，&lt;code&gt;CS&lt;/code&gt;连接&lt;code&gt;PB2&lt;/code&gt;，这些是标准SPI的信号；&lt;code&gt;RES&lt;/code&gt;连接&lt;code&gt;PB0&lt;/code&gt;，&lt;code&gt;D/C&lt;/code&gt;连接&lt;code&gt;PB1&lt;/code&gt;。芯片在时钟上升沿采样数据信号，SPI模式0或3都可以使用。接下来我们来看总线上的数据。&lt;/p&gt;
&lt;p&gt;当&lt;code&gt;D/C&lt;/code&gt;为低时，总线上传输的是控制指令；当&lt;code&gt;D/C&lt;/code&gt;为高时，总线上传输的是显示数据。64行被分为8页，芯片内部有1024字节的显存，每一字节对应一页中的一列，也就是纵向8个像素：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1734552/202002/1734552-20200214115958585-2051404507.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显存支持页面、水平、垂直三种寻址模式，伴随有一个指针，每写入一字节数据，指针就以某种形式增长，类似于我们在C中写的&lt;code&gt;*ptr++&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1734552/202002/1734552-20200214120005541-1952595201.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;芯片支持很多指令，它们的长度由第一个字节决定，有各自的格式，大致可以分为以下几类：&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;显存：寻址模式、行列地址、页面地址；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;显示：起始行、显示行数、对比度、各种remap、全亮、反转、睡眠、偏移；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;电源：&lt;code&gt;IREF&lt;/code&gt;电流大小、&lt;code&gt;VCOMH&lt;/code&gt;电压阈值、电荷泵开关；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;时钟：时钟频率、时钟分频、预充电周期；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;滚动：水平滚动、水平垂直滚动、滚动区域、启用禁用滚动；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;高级：淡化、闪烁、放大。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对照着datasheet，我们来写几个指令，让屏幕亮起来。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;stdarg.h&amp;gt;
#include &amp;lt;avr/io.h&amp;gt;
#include &amp;lt;ee2/bit.h&amp;gt;

void spi_init()
{
    UCSR1B =    1 &amp;lt;&amp;lt; TXEN1;
    UCSR1C = 0b11 &amp;lt;&amp;lt; UMSEL10
#define              UDORD1 2
           |    0 &amp;lt;&amp;lt; UDORD1
#define              UCPHA1 1
           |    0 &amp;lt;&amp;lt; UCPHA1
           |    0 &amp;lt;&amp;lt; UCPOL1;
    set_bit(DDRD, 3);
    set_bit(DDRD, 4);
}

void spi_send(uint8_t _data)
{
    UDR1 = _data;
    while (!read_bit(UCSR1A, TXC1))
        ;
    set_bit(UCSR1A, TXC1);
}

void oled_init()
{
    spi_init();
    set_bit(DDRB, 0);  // RES
    set_bit(DDRB, 1);  // DC
    set_bit(DDRB, 2);  // CS
    set_bit(PORTB, 2); // CS  high
    set_bit(PORTB, 0); // RES high
}

void oled_control(uint8_t _size, ...)
{
    reset_bit(PORTB, 1); // DC low
    reset_bit(PORTB, 2); // CS low
    va_list args;
    va_start(args, _size);
    for (uint8_t i = 0; i != _size; ++i)
        spi_send(va_arg(args, int));
    va_end(args);
    set_bit(PORTB, 2);   // CS high
}

void oled_data(uint16_t _size, const uint8_t* _data)
{
    set_bit(PORTB, 1);   // DC high
    reset_bit(PORTB, 2); // CS low
    for (const uint8_t* end = _data + _size; _data != end; ++_data)
        spi_send(*_data);
    set_bit(PORTB, 2);   // CS high
}

int main(void)
{
    oled_init();
    oled_control(2, 0x8D, 0x95); // enable charge pump
    oled_control(1, 0xA1);       // segment remap
    oled_control(1, 0xC8);       // common remap
    oled_control(1, 0xAF);       // display on
    uint8_t data[128];
    for (uint8_t i = 0; i != 128; ++i)
        data[i] = i;
    for (uint8_t i = 0; i != 8; ++i)
    {
        oled_control(1, 0xB0 + i);
        oled_data(128, data);
    }
    while (1)
        ;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先来看指令：&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;0x8D, 0x95&lt;/code&gt;启用内置电荷泵，将输出电压设置为9.0V；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;0xA1&lt;/code&gt;和&lt;code&gt;0xC8&lt;/code&gt;分别设置segment和common的remap，因为另一份datasheet中指明，显示屏的第一行连接&lt;code&gt;Common 62&lt;/code&gt;，第一列连接&lt;code&gt;Segment 127&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1734552/202002/1734552-20200214120012231-1004328999.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;0xAF&lt;/code&gt;开启显示，显示是默认关闭的，需要手动开启；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;0xB0&lt;/code&gt;到&lt;code&gt;0xB7&lt;/code&gt;设置页面寻址模式下的页面地址，这是默认的寻址模式，我们在循环中先设置地址，再发送128字节的数据，内容是&lt;code&gt;0&lt;/code&gt;到&lt;code&gt;127&lt;/code&gt;，循环8次，把每一页都填满。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;画出的是一个美丽的分形图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1734552/202002/1734552-20200214120023351-1476431738.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再来看&lt;code&gt;oled_control&lt;/code&gt;这个函数。参数列表的最后是&lt;code&gt;...&lt;/code&gt;，表示可变参数。在函数调用时，匹配到&lt;code&gt;...&lt;/code&gt;的参数需要用&lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt;中的工具取用：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;va_list&lt;/code&gt;是一个类型，创建一个这个类型的变量，表示可变参数列表；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;va_start&lt;/code&gt;是一个宏，第一个参数为&lt;code&gt;va_list&lt;/code&gt;变量，第二个为可变参数的数量；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;va_arg&lt;/code&gt;取出可变参数列表中的下一个变量，类型由第二个参数指定；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;va_end&lt;/code&gt;在使用完可变参数后做一些清理工作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;需要提醒的是，编译器无法检查标称的参数数量和类型与实际的是否符合。&lt;/p&gt;
&lt;h3 id=&quot;移植u8g2库&quot;&gt;移植U8g2库&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/olikraus/u8g2&quot; target=&quot;_blank&quot;&gt;U8g2&lt;/a&gt;是一个著名的单色显示屏驱动与图形库。“U”是universal，支持众多显示驱动芯片；“8”是8-bit，单片机与芯片以字节为单位通信；“g”是graphics，有绘制各种图形的函数；“2”是第二代。&lt;/p&gt;
&lt;p&gt;文首的资料中包含了U8g2仓库的全部资料，下载于2020年2月9日，你也可以从GitHub上下载。C源代码在文件夹&lt;code&gt;csrc&lt;/code&gt;中，包含头文件与实现。为了在我们的项目中包含这些文件，我们在Atmel Studio的Solution Explorer中对项目右键，点击Add→New Folder，命名为“u8g2”，然后右键它并点击Add→Existing Item，选择&lt;code&gt;csrc&lt;/code&gt;中的文件，它们就会被拷贝到项目目录下，在代码中可以通过`#include &amp;lt;u8g2/u8g2.h&amp;gt;引用头文件。&lt;/p&gt;
&lt;p&gt;U8g2的使用很简单，&lt;a href=&quot;https://github.com/olikraus/u8g2/wiki/u8g2setupc&quot; target=&quot;_blank&quot;&gt;Wiki&lt;/a&gt;告诉我们，要首先创建&lt;code&gt;u8g2_t&lt;/code&gt;类型的对象，随后每个函数的第一个参数都是它的指针。先根据显示屏的芯片型号选择合适的设置函数，初始化后就有那么多&lt;a href=&quot;https://github.com/olikraus/u8g2/wiki/u8g2reference&quot; target=&quot;_blank&quot;&gt;函数&lt;/a&gt;可以使用了。&lt;/p&gt;
&lt;p&gt;U8g2没有提供SSD1315的驱动，但由于SSD1315与SSD1306兼容，我们可以选择&lt;code&gt;u8g2_Setup_ssd1306_128x64_noname_f&lt;/code&gt;函数。后缀为&lt;code&gt;_f&lt;/code&gt;的函数在RAM中设置了整个缓存，共&lt;code&gt;128 * 64 / 8 = 1KB&lt;/code&gt;，这样用起来比较方便。&lt;/p&gt;
&lt;p&gt;移植的核心就在于初始化时注册的两个回调函数。根据&lt;a href=&quot;https://github.com/olikraus/u8g2/wiki/Porting-to-new-MCU-platform&quot; target=&quot;_blank&quot;&gt;Wiki&lt;/a&gt;，我们要提供的两个函数的模板为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;uint8_t u8x8_comm_callback(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    switch (msg)
    {
    case U8X8_MSG_BYTE_INIT:
        break;
    case U8X8_MSG_BYTE_SET_DC:
        break;
    case U8X8_MSG_BYTE_START_TRANSFER:
        break;
    case U8X8_MSG_BYTE_SEND:
        break;
    case U8X8_MSG_BYTE_END_TRANSFER:
        break;
    default:
        return 0;
    }
    return 1;
}

uint8_t u8x8_gpio_delay_callback(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    switch (msg)
    {
    case U8X8_MSG_GPIO_AND_DELAY_INIT:
        break;
    case U8X8_MSG_DELAY_NANO:
        break;
    case U8X8_MSG_DELAY_100NANO:
        break;
    case U8X8_MSG_DELAY_10MICRO:
        break;
    case U8X8_MSG_DELAY_MILLI:
        break;
    case U8X8_MSG_GPIO_CS:
        break;
    case U8X8_MSG_GPIO_DC:
        break;
    case U8X8_MSG_GPIO_RESET:
        break;
    default:
        return 0;
    }
    return 1;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们来一一填写其中的语句：&lt;/p&gt;
&lt;ul readability=&quot;27&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;code&gt;U8X8_MSG_GPIO_AND_DELAY_INIT&lt;/code&gt;，初始化GPIO与延时；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;set_bit(DDRB, 0);
set_bit(DDRB, 1);
set_bit(DDRB, 2);&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;U8X8_MSG_DELAY_NANO&lt;/code&gt;，延时若干纳秒，不超过100ns，由于CPU周期是40ns，函数调用的时间已经超过了100ns，因此什么都不做；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;U8X8_MSG_DELAY_100NANO&lt;/code&gt;，延时几百纳秒，使用`&amp;lt;util/delay.h&amp;gt;提供的工具，延时精确到微秒，微秒数为参数除以10，由于除以10很慢，改为除以8；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#define __DELAY_BACKWARD_COMPATIBLE__
#define F_CPU 25000000UL
#include &amp;lt;util/delay.h&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    _delay_us(arg_int &amp;gt;&amp;gt; 3);&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;U8X8_MSG_DELAY_10MICRO&lt;/code&gt;，延时几十微秒，同样使用&lt;code&gt;_delay_us&lt;/code&gt;；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    _delay_us(arg_int * 10);&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;code&gt;U8X8_MSG_GPIO_CS&lt;/code&gt;、&lt;code&gt;U8X8_MSG_GPIO_DC&lt;/code&gt;、&lt;code&gt;U8X8_MSG_BYTE_INIT&lt;/code&gt;，分别设置&lt;code&gt;CS&lt;/code&gt;、&lt;code&gt;D/C&lt;/code&gt;、&lt;code&gt;RES&lt;/code&gt;引脚电平，值为&lt;code&gt;arg_int&lt;/code&gt;；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;case U8X8_MSG_GPIO_CS:
    cond_bit(arg_int, PORTB, 2);
    break;
case U8X8_MSG_GPIO_DC:
    cond_bit(arg_int, PORTB, 1);
    break;
case U8X8_MSG_GPIO_RESET:
    cond_bit(arg_int, PORTB, 0);
    break;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上是第二个函数；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;code&gt;U8X8_MSG_BYTE_INIT&lt;/code&gt;，通信的初始化，照搬&lt;code&gt;spi_init&lt;/code&gt;函数就可以了；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    UCSR1B =    1 &amp;lt;&amp;lt; TXEN1;
    UCSR1C = 0b11 &amp;lt;&amp;lt; UMSEL10
#define              UDORD1 2
           |    0 &amp;lt;&amp;lt; UDORD1
#define              UCPHA1 1
           |    0 &amp;lt;&amp;lt; UCPHA1
           |    0 &amp;lt;&amp;lt; UCPOL1;
    set_bit(DDRD, 3);
    set_bit(DDRD, 4);&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;code&gt;U8X8_MSG_BYTE_SET_DC&lt;/code&gt;，设置&lt;code&gt;D/C&lt;/code&gt;引脚的电平，这在上面已经写过了，可以通过&lt;code&gt;u8x8_gpio_SetDC&lt;/code&gt;来转发；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    u8x8_gpio_SetDC(u8x8, arg_int);&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;U8X8_MSG_BYTE_START_TRANSFER&lt;/code&gt;、&lt;code&gt;U8X8_MSG_BYTE_END_TRANSFER&lt;/code&gt;，开始传输和结束传输，即拉低和拉高&lt;code&gt;CS&lt;/code&gt;电平；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;case U8X8_MSG_BYTE_START_TRANSFER:
    u8x8_gpio_SetCS(u8x8, 0);
    break;
case U8X8_MSG_BYTE_END_TRANSFER:
    u8x8_gpio_SetCS(u8x8, 1);
    break;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;U8X8_MSG_BYTE_SEND&lt;/code&gt;，发送数据，内容在&lt;code&gt;arg_ptr&lt;/code&gt;中，大小为&lt;code&gt;arg_int&lt;/code&gt;字节；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    for (const uint8_t* ptr = arg_ptr, *end = ptr + arg_int;
        ptr != end; ++ptr)
    {
        UDR1 = *ptr;
        while (!read_bit(UCSR1A, TXC1))
            ;
        set_bit(UCSR1A, TXC1);
        UDR1;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们再来细品一下回调这个概念。&lt;/p&gt;
&lt;p&gt;但是回调是有一定代价的，原本可以调用确定的函数，或者直接内联，现在需要使用函数指针了。众所周知，指令也是数据，存储在flash中；函数是指令序列，它的第一个指令的地址就是函数指针的值。CPU中有一个特殊的寄存器，叫程序计数器（Program Counter，PC），它保存着CPU要执行的指令的地址；函数指针是变量，保存在寄存器中，用函数指针调用函数本质上是把寄存器的内容加载进PC中。&lt;/p&gt;
&lt;p&gt;现代CPU都是多级流水线的，CPU在执行一条指令的同时，取指部件会将待执行的指令从flash中取出，这是因为flash的读取往往比CPU慢。但是，遇到从寄存器加载PC的指令时，取指部件不知道下一条指令的位置，必须等待CPU译码、执行后，才能根据PC去取指令，需要额外消耗几个CPU周期。好在这个消耗不大，并且CPU已经足够快，我们很少考虑函数指针与回调带来的overhead。事实上C++的虚函数就是用函数指针实现的，而C++是以运行时效率著称的编程语言。&lt;/p&gt;
&lt;p&gt;然后我们就可以开心地画图了！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;avr/io.h&amp;gt;
#include &amp;lt;avr/interrupt.h&amp;gt;
#define __DELAY_BACKWARD_COMPATIBLE__
#define F_CPU 25000000UL
#include &amp;lt;util/delay.h&amp;gt;
#include &amp;lt;ee2/bit.h&amp;gt;
#include &quot;u8g2/u8g2.h&quot;

static u8g2_t u8g2;

static uint8_t u8x8_comm_callback(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr);
static uint8_t u8x8_gpio_delay_callback(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr);

int main(void)
{
    u8g2_Setup_ssd1306_128x64_noname_f(&amp;amp;u8g2, U8G2_R0, u8x8_comm_callback, u8x8_gpio_delay_callback);
    u8g2_InitDisplay(&amp;amp;u8g2);
    u8g2_SetPowerSave(&amp;amp;u8g2, 0);
    u8g2_SetFont(&amp;amp;u8g2, u8g2_font_10x20_mr);
    u8g2_DrawStr(&amp;amp;u8g2, 0, 15, &quot;AVR tutorial&quot;);
    u8g2_DrawStr(&amp;amp;u8g2, 0, 31, &quot;by Jerry Fu&quot;);
    u8g2_SendBuffer(&amp;amp;u8g2);
    while (1)
        ;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;u8g2_Setup_ssd1306_128x64_noname_f&lt;/code&gt;进行一些本机的初始化；&lt;code&gt;u8g2_InitDisplay&lt;/code&gt;给芯片发送初始化序列，就是&lt;code&gt;0x8D, 0x95&lt;/code&gt;之类的；&lt;code&gt;u8g2_SetPowerSave&lt;/code&gt;关闭显示屏睡眠，也就是开启显示，这些指令都是在函数调用时就发送的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;u8g2_SetFont&lt;/code&gt;设置画字符的字体，&lt;code&gt;u8g2_font_10x20_mr&lt;/code&gt;是一种16像素高的字体；&lt;code&gt;u8g2_DrawStr&lt;/code&gt;在缓存中画字符串，两个数字分别是横纵坐标，在计算机屏幕上y轴是向下的；&lt;code&gt;u8g2_SendBuffer&lt;/code&gt;更新显示屏显示，调用后显示屏上就会出现文字了。一定要注意，所有&lt;code&gt;u8g2_Draw*&lt;/code&gt;函数都是在缓存中绘图，要调用&lt;code&gt;u8g2_SendBuffer&lt;/code&gt;才会显示。&lt;/p&gt;
&lt;p&gt;picture&lt;/p&gt;
&lt;p&gt;回调的另一个好处是方便插入中间层。比如，我想知道U8g2向OLED屏发送了什么指令，只需简单地修改回调函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static uint8_t u8x8_comm_callback(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    static bool control;
    switch (msg)
    {
    // ...
    case U8X8_MSG_BYTE_SET_DC:
        control = !arg_int;
        u8x8_gpio_SetDC(u8x8, arg_int);
        break;
    case U8X8_MSG_BYTE_SEND:
        for (const uint8_t* ptr = arg_ptr, *end = ptr + arg_int;
            ptr != end; ++ptr)
        {
            if (control)
            {
                uart_set_align(ALIGN_RIGHT, 2, '0');
                uart_print_hex(*ptr);
                uart_print_char(' ');
            }
            UDR1 = *ptr;
            while (!read_bit(UCSR1A, TXC1))
                ;
            set_bit(UCSR1A, TXC1);
            UDR1;
        }
        break;
    case U8X8_MSG_BYTE_END_TRANSFER:
        if (control)
            uart_print_line();
        u8x8_gpio_SetCS(u8x8, 1);
        break;
    }
    return 1;
}

static uint8_t u8x8_gpio_delay_callback(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    switch (msg)
    {
    // ...
    case U8X8_MSG_GPIO_RESET:
        if (!arg_int)
            uart_print_string(&quot;reset\n&quot;);
        cond_bit(arg_int, PORTB, 0);
        break;
    }
    return 1;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在&lt;code&gt;main&lt;/code&gt;中加入&lt;code&gt;uart_init(UART_TX_256, 384);&lt;/code&gt;。串口收到以下信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;reset
AE D5 80 A8 3F D3 00 40 8D 14 20 00 A1 C8 DA 12 81 CF D9 F1 DB 40 2E A4 A6 
AF 
40 10 00 B0 40 10 00 B1 40 10 00 B2 40 10 00 B3 40 10 00 B4 40 10 00 B5 40 10 00 B6 40 10 00 B7 &lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;9.820819112628&quot;&gt;&lt;li readability=&quot;12.660447761194&quot;&gt;
&lt;p&gt;第一行是&lt;code&gt;u8g2_InitDisplay&lt;/code&gt;发送的指令：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0xAE&lt;/code&gt;关闭显示屏；&lt;code&gt;0xD5, 0x80&lt;/code&gt;设置时钟频率最高，分频系数为1，也就是显示频率最高；&lt;code&gt;0xA8, 0x3F&lt;/code&gt;设置复用比为64，显示64行；&lt;code&gt;0xD3, 0x00&lt;/code&gt;设置纵向显示偏移为0；&lt;code&gt;0x40&lt;/code&gt;设置显示从第0行开始；&lt;code&gt;0x8D, 0x14&lt;/code&gt;启用电荷泵，电压7.5V；&lt;code&gt;0x20, 0x00&lt;/code&gt;使用水平寻址模式，但库的作者误认为是页面寻址模式；&lt;code&gt;0xA1&lt;/code&gt;设置segment remap；&lt;code&gt;0xC8&lt;/code&gt;设置common remap；&lt;code&gt;0xDA, 0x12&lt;/code&gt;设置交错common模式；&lt;code&gt;0x81, 0xCF&lt;/code&gt;设置对比度为&lt;code&gt;0xCF&lt;/code&gt;；&lt;code&gt;0xD9, 0xF1&lt;/code&gt;设置预充电周期，放电阶段时间最短，充电阶段时间最长；&lt;code&gt;0xDB, 0x40&lt;/code&gt;设置&lt;code&gt;VCOMH&lt;/code&gt;电压，亮度与之正相关，但&lt;code&gt;0x40&lt;/code&gt;是一个无效值，这个错误可以追溯到&lt;a href=&quot;https://github.com/adafruit/Adafruit_SSD1306/issues/42&quot; target=&quot;_blank&quot;&gt;Adafruit的SSD1306库&lt;/a&gt;中；&lt;code&gt;0x2E&lt;/code&gt;禁用滚动；&lt;code&gt;0xA4&lt;/code&gt;设置显示内容跟随RAM；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;第二行是&lt;code&gt;u8g2_SetPowerSave&lt;/code&gt;发送的指令：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0xA6&lt;/code&gt;设置显示不反转；&lt;code&gt;0xAF&lt;/code&gt;开启显示屏，初始化结束；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;第三行是&lt;code&gt;u8g2_SendBuffer&lt;/code&gt;发送的指令：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0x40&lt;/code&gt;设置起始行为第0行；&lt;code&gt;0x10&lt;/code&gt;和&lt;code&gt;0x00&lt;/code&gt;设置起始列为第0列；&lt;code&gt;0xB*&lt;/code&gt;设置页面地址为0到7；但是在水平寻址模式下，后3个指令都是没有用的，不信你自己写一个试试。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们后面还会用到几个函数，这里简要介绍一下：&lt;/p&gt;
&lt;h3 id=&quot;bresenham直线算法&quot;&gt;Bresenham直线算法&lt;/h3&gt;
&lt;p&gt;给定两个点，如何画一条线段？&lt;/p&gt;
&lt;p&gt;用尺画呗，还能怎么画？&lt;/p&gt;
&lt;p&gt;但是，第一，计算机没有尺；第二，计算机的屏幕是由像素点组成的，画一条两点之间的线段，实际上是在寻找与理论位置最接近的像素点的集合。我们将要学习的Bresenham算法是解决这个问题的一个经典并且高效的算法，它只涉及整数运算，无需除法，就可以在与两点之间距离成线性关系的时间内，使用常数大小的内存，计算出需要绘制的点的坐标。&lt;/p&gt;
&lt;p&gt;这个算法的输入是4个整数&lt;span class=&quot;math inline&quot;&gt;\(x_1\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(y_1\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(x_2\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(y_2\)&lt;/span&gt;表示2个坐标，输出是一系列坐标，每计算出一个就绘制它，不存储到数组中。为了方便理解，我们先假设&lt;span class=&quot;math inline&quot;&gt;\(x_1 &amp;lt; x_2\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(0 \leq k = \frac {y_2 - y_1} {x_2 - x_1} \leq 1\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;我们把像素视为格点，每个像素点都可以用唯一的坐标表示。由于&lt;span class=&quot;math inline&quot;&gt;\(0 \leq k \leq 1\)&lt;/span&gt;，每一列都只会有一个像素点是所求直线的一部分。为了求横坐标为&lt;span class=&quot;math inline&quot;&gt;\(x_0\)&lt;/span&gt;的一列上的这个点，我们应该计算&lt;span class=&quot;math inline&quot;&gt;\((x_1, y_1)\)&lt;/span&gt;与&lt;span class=&quot;math inline&quot;&gt;\((x_2, y_2)\)&lt;/span&gt;这两点所确定的直线与直线&lt;span class=&quot;math inline&quot;&gt;\(x = x_0\)&lt;/span&gt;的交点，然后把交点的纵坐标取整，作为格点也就是要绘制的像素点的纵坐标。&lt;/p&gt;
&lt;p&gt;对于两个相差&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;的横坐标，对应精确纵坐标相差&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;，取整后相差&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;或&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;。Bresenham算法就是通过判断这个差值是&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;还是&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;来计算的。我们遍历从&lt;span class=&quot;math inline&quot;&gt;\(x_1\)&lt;/span&gt;到&lt;span class=&quot;math inline&quot;&gt;\(x_2\)&lt;/span&gt;的&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;，维护两个变量：&lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;，表示当前绘制到的纵坐标，初始值为&lt;span class=&quot;math inline&quot;&gt;\(y_1\)&lt;/span&gt;；&lt;span class=&quot;math inline&quot;&gt;\(e\)&lt;/span&gt;，表示误差，如果把&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;对应的纵坐标确定为&lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;，理论值比实际值大了多少，初始值为&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;每加&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;，如果&lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;不变，根据我们上面的分析，&lt;span class=&quot;math inline&quot;&gt;\(e\)&lt;/span&gt;就会增加&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;。当&lt;span class=&quot;math inline&quot;&gt;\(-0.5 \leq e \le 0.5\)&lt;/span&gt;时，我们无法找到更精确的&lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;，因此&lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;不变；当&lt;span class=&quot;math inline&quot;&gt;\(e \geq 0.5\)&lt;/span&gt;时，把&lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;加上&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;会得到更精确的坐标，那么实际值加上&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;以后，误差也就要减去&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;我们用&lt;code&gt;pixel(x, y)&lt;/code&gt;表示绘制&lt;span class=&quot;math inline&quot;&gt;\((x, y)\)&lt;/span&gt;这个像素点。以上算法可以用C代码描述：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;double e = 0;
for (int x = x1, y = y1; x &amp;lt;= x2; ++x)
{
    if (e &amp;gt;= 0.5)
    {
        ++y;
        e -= 1;
    }
    pixel(x, y);
    e += k;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是这样涉及到浮点数了。我们注意到，&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;是一个有理数，可以通过把所有与&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;相关的数都乘上&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;的分母来把它化为整数。&lt;span class=&quot;math inline&quot;&gt;\(e\)&lt;/span&gt;初始值为0，运算都是加上&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;或减去&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;，乘上&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;的分母后就是整数了。&lt;span class=&quot;math inline&quot;&gt;\(0.5\)&lt;/span&gt;乘&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;的分母未必是整数，但是取整至多相差&lt;span class=&quot;math inline&quot;&gt;\(0.5\)&lt;/span&gt;，也当作整数来处理。与&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;比较比与变量比较更快一些，因此我们把&lt;span class=&quot;math inline&quot;&gt;\(e\)&lt;/span&gt;的初值设为&lt;span class=&quot;math inline&quot;&gt;\(-0.5\)&lt;/span&gt;乘&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;的分母，然后与&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;比较。这样线性处理后的&lt;span class=&quot;math inline&quot;&gt;\(e\)&lt;/span&gt;在以下代码中用&lt;span class=&quot;math inline&quot;&gt;\(er\)&lt;/span&gt;表示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int er = (x1 - x2) &amp;gt;&amp;gt; 1;
for (int x = x1, y = y1; x &amp;lt;= x2; ++x)
{
    if (er &amp;gt;= 0)
    {
        ++y;
        er -= x2 - x1;
    }
    pixel(x, y);
    er += y2 - y1;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么如何把所有的情况化归到符合简化条件的呢？我们结合U8g2的源码来看：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void u8g2_DrawLine(u8g2_t *u8g2, u8g2_uint_t x1, u8g2_uint_t y1, u8g2_uint_t x2, u8g2_uint_t y2)
{
    // part 1
    u8g2_uint_t tmp;
    u8g2_uint_t x,y;
    u8g2_uint_t dx, dy;
    u8g2_int_t err;
    u8g2_int_t ystep;
    uint8_t swapxy = 0;
    /* no intersection check at the moment, should be added... */
    
    // part 2
    if ( x1 &amp;gt; x2 ) dx = x1-x2; else dx = x2-x1;
    if ( y1 &amp;gt; y2 ) dy = y1-y2; else dy = y2-y1;
    if ( dy &amp;gt; dx ) 
    {
        swapxy = 1;
        tmp = dx; dx =dy; dy = tmp;
        tmp = x1; x1 =y1; y1 = tmp;
        tmp = x2; x2 =y2; y2 = tmp;
    }
    
    // part 3
    if ( x1 &amp;gt; x2 ) 
    {
        tmp = x1; x1 =x2; x2 = tmp;
        tmp = y1; y1 =y2; y2 = tmp;
    }
    
    // part 4
    err = dx &amp;gt;&amp;gt; 1;
    if ( y2 &amp;gt; y1 ) ystep = 1; else ystep = -1;
    y = y1;
#ifndef  U8G2_16BIT
    if ( x2 == 255 )
        x2--;
#else
    if ( x2 == 0xffff )
        x2--;
#endif
    
    // part 5
    for( x = x1; x &amp;lt;= x2; x++ )
    {
        if ( swapxy == 0 ) 
            u8g2_DrawPixel(u8g2, x, y); 
        else 
            u8g2_DrawPixel(u8g2, y, x); 
        err -= (uint8_t)dy;
        if ( err &amp;lt; 0 ) 
        {
        y += (u8g2_uint_t)ystep;
        err += (u8g2_uint_t)dx;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;7&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;第一部分是变量定义，intersection那一句注释的意思是，没有检查直线是否需要绘制（U8g2允许设置部分缓存，每次绘制画面的一部分并发送，多次绘制同样的画面，以时间换空间；如果直线不在当前绘制的画面中，后面的计算就不需要了，可以节省时间；这个函数没有做这样的检查）；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;第二部分先计算&lt;span class=&quot;math inline&quot;&gt;\(dx = |x_1 - x_2|, dy = |y_1 - y_2|\)&lt;/span&gt;，然后交换横纵坐标以保证斜率的绝对值不超过&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第三部分判断&lt;span class=&quot;math inline&quot;&gt;\(x_1\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(x_2\)&lt;/span&gt;的大小关系，交换两点坐标使&lt;span class=&quot;math inline&quot;&gt;\(x_1 \leq x_2\)&lt;/span&gt;，这是为了使后面的&lt;code&gt;for&lt;/code&gt;循环有效；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第四部分初始化Bresenham算法需要使用的变量，&lt;code&gt;err&lt;/code&gt;与之前代码中的&lt;code&gt;er&lt;/code&gt;是相反数的关系；&lt;code&gt;ystep&lt;/code&gt;是&lt;code&gt;y&lt;/code&gt;变化的方向；检查&lt;code&gt;x2 == 255&lt;/code&gt;是为了防止后面出现死循环；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;第五部分就是Bresenham算法了，根据&lt;code&gt;swapxy&lt;/code&gt;判断横纵坐标是否需要对换；&lt;code&gt;err &amp;lt; 0&lt;/code&gt;没有等号，这只不过是一个&lt;span class=&quot;math inline&quot;&gt;\(0.5\)&lt;/span&gt;向上进还是向下舍的问题；当&lt;code&gt;ystep&lt;/code&gt;为&lt;code&gt;-1&lt;/code&gt;时，由于&lt;code&gt;dx&lt;/code&gt;和&lt;code&gt;dy&lt;/code&gt;都是取了绝对值的，计算起来与&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;取相反数的对应情况没有区别，不过是&lt;code&gt;y&lt;/code&gt;变化的方向反了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;示波器&quot;&gt;示波器&lt;/h3&gt;
&lt;p&gt;示波器是显示电压波形的仪器。它未必比万用表精确，但能反映出电压随时间变化的情况。我们来制作一个示波器，它有两个通道，采样间隔从10μs到10ms可调，带有自适应功能，即把波形平移放大到便于观测。两个按键用于调整时间间隔，两个开分别用于暂停显示和开启第二通道。这些功能对我们学习模拟电路有帮助。&lt;/p&gt;
&lt;p&gt;这么多功能也许有点复杂，我们先从最简单的开始做起，这个版本没有任何花里胡哨的玩意儿，只有一个128*48的波形显示区域，采样率也固定在1kHz，别的什么都没有。&lt;/p&gt;
&lt;p&gt;程序的基本思路是，在1ms的定时器中断中记录ADC读到的8位数据（显示屏的垂直分辨率还不到6位，没有必要读10位数据），每当读取到的数据量能填满显示屏时，也就是采样了128次时，处理数据并更新显示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &quot;u8g2/u8g2.h&quot;
#define __DELAY_BACKWARD_COMPATIBLE__
#define F_CPU 25000000UL
#include &amp;lt;util/delay.h&amp;gt;
#include &amp;lt;ee2/bit.h&amp;gt;
#include &amp;lt;ee2/adc.h&amp;gt;
#include &amp;lt;ee2/timer.h&amp;gt;

static uint8_t u8x8_comm_callback(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr);
static uint8_t u8x8_gpio_delay_callback(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr);
static u8g2_t u8g2;

uint8_t map(uint8_t _value)
{
    return 63 - ((_value * 3) &amp;gt;&amp;gt; 4);
}

void timer()
{
    static uint8_t phase = 0;
    static uint8_t waveform[128];
    waveform[phase++] = adc_read(ADC_0);
    if (phase == 128)
    {
        phase = 0;
        u8g2_SetDrawColor(&amp;amp;u8g2, 0);
        u8g2_DrawBox(&amp;amp;u8g2, 0, 16, 128, 48);
        u8g2_SetDrawColor(&amp;amp;u8g2, 1);
        for (uint8_t i = 1; i != 128; ++i)
            u8g2_DrawLine(&amp;amp;u8g2, i - 1, map(waveform[i - 1]),
                                 i    , map(waveform[i    ]));
        u8g2_UpdateDisplayArea(&amp;amp;u8g2, 0, 2, 16, 6);
    }
}

int main()
{
    u8g2_Setup_ssd1306_128x64_noname_f(&amp;amp;u8g2, U8G2_R0, u8x8_comm_callback, u8x8_gpio_delay_callback);
    u8g2_InitDisplay(&amp;amp;u8g2);
    u8g2_SetPowerSave(&amp;amp;u8g2, 0);
    u8g2_SendBuffer(&amp;amp;u8g2);
    adc_init();
    timer_init();
    timer_register(timer);
    while (1)
        ;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;map&lt;/code&gt;函数把&lt;code&gt;0&lt;/code&gt;到&lt;code&gt;255&lt;/code&gt;的整数映射到&lt;code&gt;63&lt;/code&gt;到&lt;code&gt;16&lt;/code&gt;的整数，把ADC读到的8位数据转换为显示屏上的y坐标。在更新显示的过程中，程序先清除上一次绘制的波形，然后在每相邻两个ADC数据对应的点之间画上直线，连起来称为波形，最后更新波形区域的显示。就是这么简单粗暴，不加任何修饰，是不是很简单呢？&lt;/p&gt;
&lt;p&gt;然后我们来加入花里胡哨的功能：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;p&gt;可调的采样率；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;暂停功能；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可选的双通道；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可选的自适应。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这些问题背后有一个共同的时间控制问题，我们先来解决。与上一篇一样，我们把定时器中断的代码移动到&lt;code&gt;main&lt;/code&gt;函数中，检测定时器寄存器的标志位来控制时间。ADC的读取间隔是10μs到10ms，都是10μs的倍数，考虑双通道，取定时器的周期为5μs，设置一个软件的分频系数与计数器变量，每若干个周期进行一次ADC转换。按键与开关的读取间隔与往常一样取1ms，用同样的方法使得每200个主循环周期执行一次读取。更新显示是很耗时的，最好在那个周期中把定时器重置，让它重新开始计时。&lt;/p&gt;
&lt;p&gt;ADC的时钟是CPU时钟分频得到的，从触发一次读取到获得结果需要13个ADC时钟周期，相比10μs而言是不可忽略的时间，而&lt;code&gt;adc_read&lt;/code&gt;函数会等待这段时间然后返回结果，这在ADC采样间隔短的时候会造成时间无法得到控制。为此，与上一篇中给DAC发送数据类似地，我们在循环中读取上一次ADC转换结果并触发一次转换，不去等待它而是在下一次循环中自然地获得其结果。在双通道模式下，要注意转换结果对应的通道是上一次选择的。&lt;/p&gt;
&lt;p&gt;ADC时钟的分频系数与ADC的精度是需要权衡的，为了获得尽量精确的结果，我们根据采样间隔来设置分频系数：单通道10μs和双通道20μs，分频系数取16；双通道10μs应取分频系数为8，但这样的话两个通道会严重相互干扰，故放弃这种模式（在这种模式下，显示的波形是未定义的）；其余都取32，8位精度下32分频足够了。&lt;/p&gt;
&lt;p&gt;实现自适应功能需要放大波形，放大的方法当然不是转换为坐标以后做图像变换，而是放大原始数据然后转换为坐标。具体来讲，是用一次函数&lt;span class=&quot;math inline&quot;&gt;\(y = k x + b\)&lt;/span&gt;进行映射，在此之前先遍历数据，计算出合适的&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt;。与此相关的还有数据到y坐标的映射，比起先前的版本需要多考虑双通道的情况。&lt;/p&gt;
&lt;p&gt;最后，暂停功能无比简单，只需要设置一个暂停标志，当它为&lt;code&gt;true&lt;/code&gt;的时候才进行采样、转换、显示等工作就可以了。以及，以上各个选项都要在屏幕的黄色区域显示。&lt;/p&gt;
&lt;p&gt;写到这里，我觉得你应该先自己试着写写这个程序，然后再往下看。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;avr/io.h&amp;gt;
#include &quot;u8g2/u8g2.h&quot;
#define __DELAY_BACKWARD_COMPATIBLE__
#define F_CPU 25000000UL
#include &amp;lt;util/delay.h&amp;gt;
#include &amp;lt;ee2/bit.h&amp;gt;
#include &amp;lt;ee2/button.h&amp;gt;
#include &amp;lt;ee2/switch.h&amp;gt;

#define PERIOD_MAX 9

uint16_t factor;
uint8_t period;
bool second;
bool pause;
bool adjust;

void init();

void timer_clear();
void timer_wait();

uint8_t adc_get(uint8_t* _channel);

void oled_waveform(uint8_t _data[][128]);
void oled_voltage(uint8_t _vdc, uint8_t _vpp);

void convert_adjust(uint8_t* _data, uint8_t* _result);
void convert_voltage(char* _string, uint8_t _value);

void set_period(uint8_t _period);
void set_second(bool _enable);
void set_adjust(bool _enable);
void set_pause(bool _enable);

int main()
{
    init();
    uint8_t waveform[2][128];
    uint8_t peripheral = 1;
    uint16_t counter = 1;
    uint8_t phase = 0;
    set_period(0);
    set_second(switch_status(SWITCH_0));
    set_adjust(switch_status(SWITCH_1));
    set_pause(false);
    while (1)
    {
        if (!--peripheral)
        {
            peripheral = 200;
            if (button_pressed(BUTTON_0))
            {
                if (period == PERIOD_MAX)
                    set_period(0);
                else
                    set_period(period + 1);
            }
            if (button_pressed(BUTTON_1))
                set_pause(!pause);
            if (switch_changed(SWITCH_0))
                set_second(switch_status(SWITCH_0));
            if (switch_changed(SWITCH_1))
                set_adjust(switch_status(SWITCH_1));
        }
        if (!pause &amp;amp;&amp;amp; !--counter)
        {
            counter = factor;
            if (second)
            {
                uint8_t ch;
                uint8_t adc = adc_get(&amp;amp;ch);
                waveform[ch][phase &amp;gt;&amp;gt; 1] = adc;
            }
            else
                waveform[0][phase] = adc_get(NULL);
            ++phase;
            if ((!second &amp;amp;&amp;amp; phase == 128) || (second &amp;amp;&amp;amp; phase == 0))
            {
                phase = 0;
                uint8_t vol[2];
                convert_adjust(waveform[0], vol);
                if (second)
                    convert_adjust(waveform[1], vol);
                oled_waveform(waveform);
                oled_voltage(vol[0], vol[1]);
                timer_clear();
            }
        }
        timer_wait();
    }
}

void timer_init()
{
    TCCR1A =  0b00 &amp;lt;&amp;lt; WGM10; // CTC mode
    TCCR1B =  0b01 &amp;lt;&amp;lt; WGM12  // CTC mode
           | 0b001 &amp;lt;&amp;lt; CS10;  // no prescaling
    OCR1A  = 124;            // 5us
}

void timer_period()
{
    static const uint16_t factors[PERIOD_MAX + 1] = {
        1, 2, 5, 10, 20, 50, 100, 200, 500, 1000
    };
    if (second)
        factor = factors[period];
    else
        factor = factors[period] &amp;lt;&amp;lt; 1;
}

void timer_second()
{
    timer_period();
}

void timer_clear()
{
    TCNT1 = 0;
    set_bit(TIFR1, OCF1A);
    adc_get(NULL);
}

void timer_wait()
{
    while (!read_bit(TIFR1, OCF1A))
        ;
    set_bit(TIFR1, OCF1A);
}

uint8_t adc_count = 1;
uint8_t adc_channel = 0;

void adc_clock(uint8_t _prescaler)
{
    ADCSRA = (ADCSRA &amp;amp; ~(0b111 &amp;lt;&amp;lt; ADPS0)) | _prescaler;
}

void adc_init()
{
    ADMUX  =    0b01 &amp;lt;&amp;lt; REFS0
           |       1 &amp;lt;&amp;lt; ADLAR
           | 0b00000 &amp;lt;&amp;lt; MUX0;
    ADCSRA =       1 &amp;lt;&amp;lt; ADEN;
}

void adc_period()
{
    if ((!second &amp;amp;&amp;amp; period &amp;lt;= 0) || (second &amp;amp;&amp;amp; period &amp;lt;= 1)) // single 10us or dual 20us
        adc_clock(0b100);                                    // divide by 16
    else
        adc_clock(0b101);                                    // divide by 32
}

void adc_second()
{
    adc_count = second ? 2 : 1;
    adc_period();
}

uint8_t adc_get(uint8_t* _channel)
{
    set_bit(ADCSRA, ADIF);
    if (_channel)
        *_channel = adc_channel;
    if (++adc_channel &amp;gt;= adc_count)
        adc_channel = 0;
    ADMUX = 0b01 &amp;lt;&amp;lt; REFS0 | 1 &amp;lt;&amp;lt; ADLAR | adc_channel &amp;lt;&amp;lt; MUX0;
    set_bit(ADCSRA, ADSC);
    return ADCH;
}

u8g2_t u8g2;

uint8_t u8x8_comm_callback(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    switch (msg)
    {
    case U8X8_MSG_BYTE_INIT:
        UCSR1B =    1 &amp;lt;&amp;lt; RXEN1
               |    1 &amp;lt;&amp;lt; TXEN1;
        UCSR1C = 0b11 &amp;lt;&amp;lt; UMSEL10
#define                  UDORD1 2
               |    0 &amp;lt;&amp;lt; UDORD1
#define                  UCPHA1 1
               |    0 &amp;lt;&amp;lt; UCPHA1
               |    0 &amp;lt;&amp;lt; UCPOL1;
        set_bit(DDRD, 3);
        set_bit(DDRD, 4);
        UBRR1 = 10;
        break;
    case U8X8_MSG_BYTE_SET_DC:
        u8x8_gpio_SetDC(u8x8, arg_int);
        break;
    case U8X8_MSG_BYTE_START_TRANSFER:
        u8x8_gpio_SetCS(u8x8, 0);
        break;
    case U8X8_MSG_BYTE_SEND:
        for (const uint8_t* ptr = arg_ptr, *end = ptr + arg_int;
            ptr != end; ++ptr)
        {
            UDR1 = *ptr;
            while (!read_bit(UCSR1A, TXC1))
                ;
            set_bit(UCSR1A, TXC1);
            UDR1;
        }
        break;
    case U8X8_MSG_BYTE_END_TRANSFER:
        u8x8_gpio_SetCS(u8x8, 1);
        break;
    default:
        return 0;
    }
    return 1;
}

uint8_t u8x8_gpio_delay_callback(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    switch (msg)
    {
    case U8X8_MSG_GPIO_AND_DELAY_INIT:
        set_bit(DDRB, 0);
        set_bit(DDRB, 1);
        set_bit(DDRB, 2);
        break;
    case U8X8_MSG_DELAY_NANO:
        break;
    case U8X8_MSG_DELAY_100NANO:
        _delay_us(arg_int &amp;gt;&amp;gt; 3);
        break;
    case U8X8_MSG_DELAY_10MICRO:
        _delay_us(arg_int * 10);
        break;
    case U8X8_MSG_DELAY_MILLI:
        _delay_ms(arg_int);
        break;
    case U8X8_MSG_GPIO_CS:
        cond_bit(arg_int, PORTB, 2);
        break;
    case U8X8_MSG_GPIO_DC:
        cond_bit(arg_int, PORTB, 1);
        break;
    case U8X8_MSG_GPIO_RESET:
        cond_bit(arg_int, PORTB, 0);
        break;
    default:
        return 0;
    }
    return 1;
}

void clear_area(uint8_t x, uint8_t y, uint8_t w, uint8_t h)
{
    u8g2_SetDrawColor(&amp;amp;u8g2, 0);
    u8g2_DrawBox(&amp;amp;u8g2, x, y, w, h);
    u8g2_SetDrawColor(&amp;amp;u8g2, 1);
}

void oled_init()
{
    u8g2_Setup_ssd1306_128x64_noname_f(&amp;amp;u8g2, U8G2_R0, u8x8_comm_callback, u8x8_gpio_delay_callback);
    u8g2_InitDisplay(&amp;amp;u8g2);
    u8g2_SetPowerSave(&amp;amp;u8g2, 0);
    u8g2_SendBuffer(&amp;amp;u8g2);
    u8g2_SetFont(&amp;amp;u8g2, u8g2_font_5x7_mr);
    u8g2_SetFontPosTop(&amp;amp;u8g2);
}

void oled_period()
{
    static const char* const strings[PERIOD_MAX + 1] = {
        &quot;10us &quot;, &quot;20us &quot;, &quot;50us &quot;,
        &quot;100us&quot;, &quot;200us&quot;, &quot;500us&quot;,
        &quot;1ms  &quot;, &quot;2ms  &quot;, &quot;5ms  &quot;,
        &quot;10ms &quot;,
    };
    u8g2_DrawStr(&amp;amp;u8g2, 0, 8, strings[period]);
    u8g2_UpdateDisplayArea(&amp;amp;u8g2, 0, 1, 4, 1);
}

void oled_second()
{
    u8g2_DrawStr(&amp;amp;u8g2, 0, 0, second ? &quot;2&quot; : &quot;1&quot;);
    u8g2_UpdateDisplayArea(&amp;amp;u8g2, 0, 0, 1, 1);
}

void oled_adjust()
{
    u8g2_DrawStr(&amp;amp;u8g2, 8, 0, adjust ? &quot;A&quot; : &quot; &quot;);
    u8g2_UpdateDisplayArea(&amp;amp;u8g2, 1, 0, 1, 1);
}

void oled_pause()
{
    static const uint8_t xbm[2][8] = {
        {0b00000000, 0b00000000, 0b00000010, 0b00000110, 0b00001110, 0b00000110, 0b00000010, 0b00000000}, // playing
        {0b00000000, 0b00000000, 0b00001010, 0b00001010, 0b00001010, 0b00001010, 0b00001010, 0b00000000}, // paused
    };
    u8g2_DrawXBM(&amp;amp;u8g2, 16, 0, 4, 8, xbm[pause]);
    u8g2_UpdateDisplayArea(&amp;amp;u8g2, 2, 0, 1, 1);
}

void oled_waveform(uint8_t _data[][128])
{
    clear_area(0, 16, 128, 48);
    uint8_t count = 1;
    uint8_t shift = 4;
    uint8_t base[2] = {63};
    if (second)
    {
        count = 2;
        shift = 5;
        base[0] = 39;
        base[1] = 63;
    }
    for (uint8_t c = 0; c != count; ++c)
    {
        for (uint8_t x = 0; x != 128; ++x)
            _data[c][x] = base[c] - ((_data[c][x] * 3) &amp;gt;&amp;gt; shift);
        for (uint8_t x = 1; x != 128; ++x)
            u8g2_DrawLine(&amp;amp;u8g2, x - 1, _data[c][x - 1], x, _data[c][x]);
    }
    u8g2_UpdateDisplayArea(&amp;amp;u8g2, 0, 2, 16, 6);
}

void oled_voltage(uint8_t _vdc, uint8_t _vpp)
{
    if (!second &amp;amp;&amp;amp; adjust)
    {
        static char strings[2][10] = {&quot;Vdc=&quot;, &quot;Vpp=&quot;};
        convert_voltage(strings[0] + 4, _vdc);
        u8g2_DrawStr(&amp;amp;u8g2, 83, 0, strings[0]);
        convert_voltage(strings[1] + 4, _vpp);
        u8g2_DrawStr(&amp;amp;u8g2, 83, 8, strings[1]);
    }
    else
        clear_area(83, 0, 45, 16);
    u8g2_UpdateDisplayArea(&amp;amp;u8g2, 10, 0, 6, 2);
}

void convert_adjust(uint8_t* _data, uint8_t* _result)
{
    if (!adjust)
        return;
    uint16_t sum = 0;
    uint8_t min = 255, max = 0;
    for (uint8_t x = 0; x != 128; ++x)
    {
        sum += _data[x];
        if (_data[x] &amp;lt; min)
            min = _data[x];
        if (_data[x] &amp;gt; max)
            max = _data[x];
    }
    _result[0] = (sum + 64) &amp;gt;&amp;gt; 7;
    uint8_t pp = _result[1] = max - min;
    uint8_t k = pp ? 255 / pp : 1;
    int16_t b = ((255 - k * pp) &amp;gt;&amp;gt; 1) - min * k;
    for (uint8_t x = 0; x != 128; ++x)
        _data[x] = k * _data[x] + b;
}

void convert_voltage(char* _string, uint8_t _value)
{
    uint16_t mv10 = (_value * 125 + 32) &amp;gt;&amp;gt; 6;
    _string[3] = mv10 % 10 + '0';
    mv10 /= 10;
    _string[2] = mv10 % 10 + '0';
    mv10 /= 10;
    _string[0] = mv10 + '0';
    _string[1] = '.';
    _string[4] = 'V';
    _string[5] = '\0';
}

void init()
{
    button_init(PIN_NULL, PIN_NULL);
    switch_init(PIN_NULL, PIN_NULL);
    adc_init();
    timer_init();
    oled_init();
}

void set_period(uint8_t _period)
{
    period = _period;
    adc_period();
    timer_period();
    oled_period();
    timer_clear();
}

void set_second(bool _enable)
{
    second = _enable;
    adc_second();
    timer_second();
    oled_second();
    timer_clear();
}

void set_adjust(bool _enable)
{
    adjust = _enable;
    oled_adjust();
    timer_clear();
}

void set_pause(bool _enable)
{
    pause = _enable;
    oled_pause();
    timer_clear();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可以先开个定时器观察PWM波，或者翻到下面搭电路观察波形，还可以把自己的手作为输入试试。&lt;/p&gt;
&lt;h3 id=&quot;eeprom&quot;&gt;EEPROM&lt;/h3&gt;
&lt;p&gt;采样率和双通道这两个参数有本质上的不同：双通道是否开启只取决于当时开关是拨到上还是拨到下，而采样率却是按键按下的次数累积决定的。因此在复位时，双通道功能的开关会保持，而采样率会重置。如果我们正在用50μs档观察波形，不小心碰到了下载器导致断电复位，我们得按两次按键才能恢复到50μs的选项；如果是10ms就更糟糕了。我们希望单片机能够记住我们的选项，这就需要用到一种复位断电都不会丢失数据的存储器——EEPROM。&lt;/p&gt;
&lt;p&gt;那为啥不用同样属于非易失性存储的flash呢？因为flash必须以块为单位擦除，而EEPROM可以以字节为单位，这就使得EEPROM更适合于存储示波器参数这样的小数据。另外，我们需要时刻注意，EEPROM的寿命是有限的，只有10万次耐久，相比之下flash只有1万次，而SRAM没有限制。&lt;/p&gt;
&lt;p&gt;ATmega324PA提供了1024字节的EEPROM。AVR的EEPROM是比较容易使用的，只需4个寄存器：&lt;code&gt;EEARH&lt;/code&gt;和&lt;code&gt;EEARL&lt;/code&gt;，地址寄存器；&lt;code&gt;EEDR&lt;/code&gt;，数据寄存器；&lt;code&gt;EECR&lt;/code&gt;，控制寄存器。对EEPROM的操作共有3种：读取、擦除和写入。AVR还提供了擦除和写入原子地合并在一起这种操作。&lt;/p&gt;
&lt;p&gt;你也许会疑惑，擦除和写入是什么关系呢？写入默认值不就可以擦除，为什么要多此一举呢？这是因为，EEPROM在出厂时所有位都是1，写入只能把位从1变成0，而只有擦除操作才能把位从0变成1，而且必须一个字节的8位一起。换句话说，我们平时讲的写入操作，到EEPROM这里相当于擦除加写入，这也是第4种操作的意义所在。&lt;/p&gt;
&lt;p&gt;对照着数据手册，我们可以写几个函数，完成EEPROM的读取、擦除和写入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void eeprom_wait()
{
    while (EECR &amp;amp; 1 &amp;lt;&amp;lt; EEPE)
        ;
}

uint8_t eeprom_read(uint16_t _address)
{
    eeprom_wait();
    EEAR = _address;
    EECR |= 1 &amp;lt;&amp;lt; EERE;
    return EEDR;
}

void eeprom_erase(uint16_t _address)
{
    eeprom_wait();
    EEAR = _address;
    EECR = 0b01 &amp;lt;&amp;lt; EEPM0 | 1 &amp;lt;&amp;lt; EEMPE;
    EECR |= 1 &amp;lt;&amp;lt; EEPE;
}

void eeprom_write_only(uint16_t _address, uint8_t _value)
{
    eeprom_wait();
    EEAR = _address;
    EEDR = _value;
    EECR = 0b10 &amp;lt;&amp;lt; EEPM0 | 1 &amp;lt;&amp;lt; EEMPE;
    EECR |= 1 &amp;lt;&amp;lt; EEPE;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;EEPROM的读取是很快的，只需要几个CPU周期，写入和擦除则慢得多，各需要1.8ms，合并起来的操作需要3.4ms。上面的函数在第一次擦写的时候无需等待，但实际擦写完成是在1.8ms以后。如果调用时前一次擦写没有完成，函数会一直等待直到操作完成，然后执行当前擦写。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nongnu.org/avr-libc/user-manual/group__avr__eeprom.html&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;&amp;lt;avr/eeprom.h&amp;gt;&lt;/code&gt;&lt;/a&gt;提供了EEPROM的相关工具。函数名带有&lt;code&gt;write&lt;/code&gt;的函数实际执行的是擦写操作；&lt;code&gt;update&lt;/code&gt;的函数在擦写之前会检查内容是否需要修改，这样可以减少擦写次数。&lt;/p&gt;
&lt;p&gt;但是这样仍不完美。EEPROM的10万次耐久指的是擦除和写入都不能超过10万次，在有些情况下我们可以避免擦除或写入或两者兼有，对EEPROM友善的同时减少了时间开销。比如，当原来的数据是&lt;code&gt;0b00001111&lt;/code&gt;，要变成&lt;code&gt;0b00001100&lt;/code&gt;时，就没有必要擦除，因为没有一位原来是0而需要变成1。&lt;/p&gt;
&lt;p&gt;所以这个改进版的写入函数需要先读取原数据，再检查是否需要擦除以及是否需要写入，最后根据检查的结果来执行相应的EEPROM操作。具体检查是否需要擦除的方法是，假设原数据为&lt;code&gt;old&lt;/code&gt;，新数据为&lt;code&gt;new&lt;/code&gt;，逐位检查&lt;code&gt;old&lt;/code&gt;和&lt;code&gt;new&lt;/code&gt;中对应的位，如果存在&lt;code&gt;old&lt;/code&gt;中的一位为&lt;code&gt;0&lt;/code&gt;而&lt;code&gt;new&lt;/code&gt;中的对应位为&lt;code&gt;1&lt;/code&gt;，则需要擦除；检查是否需要写入的方法是，如果存在可能被擦除以后的字节中的一位为&lt;code&gt;1&lt;/code&gt;而&lt;code&gt;new&lt;/code&gt;中的对应位为&lt;code&gt;0&lt;/code&gt;，则需要写入。所以我们需要写两个循环，每个循环体执行8遍。&lt;/p&gt;
&lt;p&gt;但是直觉告诉我，下面的代码能起到相同的作用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void eeprom_write(uint16_t _address, uint8_t _value)
{
    uint8_t original = eeprom_read(_address);
    bool need_erase = ~original &amp;amp; _value;
    uint8_t after_erase = need_erase ? 0xFF : original;
    bool need_write = after_erase != _value;
    if (!need_erase &amp;amp;&amp;amp; !need_write)
        return;
    eeprom_wait();
    EEAR = _address;
    EEDR = _value;
    EECR = !need_erase &amp;lt;&amp;lt; EEPM1
         | !need_write &amp;lt;&amp;lt; EEPM0
         |           1 &amp;lt;&amp;lt; EEMPE;
    EECR |= 1 &amp;lt;&amp;lt; EEPE;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是这样依然不完美。如果我们只需要一个字节，就像这个示波器程序那样，用一个固定字节存储这个参数，可以修改10万次。但是EEPROM共有1024字节，剩下的1023字节呢？没错，我们可以用完一个字节的耐久后用下一个字节，直到全部用完，这样就可以修改1亿次，当传家宝都没问题。问题在于没有办法检测一个字节的耐久是否耗尽。那我们是否可以再设置一个字节来记录写入了多少次？然后还得考虑这个字节的耐久，以及如何检测耐久耗尽以后的错误……&lt;/p&gt;
&lt;p&gt;别把自己绕进去，一份来自Atmel官方的application note，&lt;a href=&quot;https://www.microchip.com//wwwAppNotes/AppNotes.aspx?appnote=en592140&quot; target=&quot;_blank&quot;&gt;AVR101&lt;/a&gt;，介绍了一种充分利用EEPROM空间换取耐久度的方法。&lt;/p&gt;
&lt;p&gt;眼看着这篇是写不完了，为了不断更先发出来，以后再补完。&lt;/p&gt;
&lt;p&gt;最后恭喜我寒假里一个任务都没有完成。下一篇遥遥无期。&lt;/p&gt;
</description>
<pubDate>Tue, 25 Feb 2020 15:13:00 +0000</pubDate>
<dc:creator>jerry_fuyi</dc:creator>
<og:description>本文隶属于AVR单片机教程系列。 在用DAC做了一个稍大的项目之后，我们来拿ADC开开刀。在本讲中，我们将了解0.96寸OLED屏，移植著名的U8g2库到我们的开发板上，学习在屏幕上画直线的算法，编写</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jerry-fuyi/p/12306817.html</dc:identifier>
</item>
<item>
<title>drf token刷新配置、认证组件(使用)、权限组件(使用)、频率组件(使用)、异常组件(使用) - 辜老板</title>
<link>http://www.cnblogs.com/guyouyin123/p/12364111.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guyouyin123/p/12364111.html</guid>
<description>&lt;p&gt;&lt;strong&gt;实现用户中心信息自查，不带主键的get请求，走单查逻辑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;urls.py&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 用路由组件配置，形成的映射关系是 /user/center/ =&amp;gt; list  |  user/center/(pk)/ =&amp;gt; retrieve
# router.register('user/center', views.UserCenterViewSet, 'center')

urlpatterns = [
    # ...
    # /user/center/ =&amp;gt; 单查，不能走路由组件，只能自定义配置映射关系
    url('^user/center/$', views.UserCenterViewSet.as_view({'get': 'user_center'})),
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;views.py&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
class UserCenterViewSet(GenericViewSet):
    permission_classes = [IsAuthenticated, ]
    queryset = models.User.objects.filter(is_active=True).all()
    serializer_class = serializers.UserCenterSerializer

    def user_center(self, request, *args, **kwargs):
        # request.user就是前台带token，在经过认证组件解析出来的，
        # 再经过权限组件IsAuthenticated的校验，所以request.user一定有值，就是当前登录用户
        serializer = self.get_serializer(request.user)
        return Response(serializer.data)&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;drf-jwt直接提供刷新功能&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&quot;&quot;&quot;
1）运用在像12306这样极少数安全性要求高的网站
2）第一个token由登录签发
3）之后的所有正常逻辑，都需要发送两次请求，第一次是刷新token的请求，第二次是正常逻辑的请求
&quot;&quot;&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;settings.py&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import datetime

JWT_AUTH = {
    # 配置过期时间
    'JWT_EXPIRATION_DELTA': datetime.timedelta(minutes=5),

    # 是否可刷新
    'JWT_ALLOW_REFRESH': True,
    # 刷新过期时间
    'JWT_REFRESH_EXPIRATION_DELTA': datetime.timedelta(days=7),
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;urls.py&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from rest_framework_jwt.views import ObtainJSONWebToken, RefreshJSONWebToken
urlpatterns = [
    url('^login/$', ObtainJSONWebToken.as_view()),  # 登录签发token接口
    url('^refresh/$', RefreshJSONWebToken.as_view()),  # 刷新toekn接口
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Postman&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 接口：/api/refresh/
# 方法：post
# 数据：{&quot;token&quot;: &quot;登录签发的token&quot;}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;注意：登录是post请求&lt;/p&gt;
&lt;h2 id=&quot;urls.py-路由&quot;&gt;1、urls.py 路由&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 自定义登录（重点）：post请求 =&amp;gt; 查操作(签发token返回给前台) - 自定义路由映射
url('^user/login/$', views.LoginViewSet.as_view({'post': 'login'})),&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;views.py-视图&quot;&gt;2、views.py 视图&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 重点：自定义login，完成多方式登录
from rest_framework.viewsets import ViewSet
from rest_framework.response import Response
class LoginViewSet(ViewSet):
    # 登录接口，要取消所有的认证与权限规则，也就是要做局部禁用操作（空配置）
    authentication_classes = []
    permission_classes = []

    # 需要和mixins结合使用，继承GenericViewSet，不需要则继承ViewSet
    # 为什么继承视图集，不去继承工具视图或视图基类，因为视图集可以自定义路由映射：
    #       可以做到get映射get，get映射list，还可以做到自定义（灵活）
    def login(self, request, *args, **kwargs):
        serializer = serializers.LoginSerializer(data=request.data, context={'request': request})  # 自定义序列化
        serializer.is_valid(raise_exception=True)  # 序列化校验
        token = serializer.context.get('token')  # 获取token
        return Response({&quot;token&quot;: token})&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;serializers.py-序列化&quot;&gt;3、serializers.py 序列化&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from rest_framework_jwt.serializers import jwt_payload_handler, jwt_encode_handler

# 重点：自定义login，完成多方式登录
class LoginSerializer(serializers.ModelSerializer):
    # 登录请求，走的是post方法，默认post方法完成的是create入库校验，所以唯一约束的字段，会进行数据库唯一校验，导致逻辑相悖
    # 需要覆盖系统字段，自定义校验规则，就可以避免完成多余的不必要校验，如唯一字段校验
    username = serializers.CharField()
    class Meta:
        model = models.User
        # 结合前台登录布局：采用账号密码登录，或手机密码登录，布局一致，所以不管账号还是手机号，都用username字段提交的
        fields = ('username', 'password')

    def validate(self, attrs):
        # 在全局钩子中，才能提供提供的所需数据，整体校验得到user
        # 再就可以调用签发token算法(drf-jwt框架提供的)，将user信息转换为token
        # 将token存放到context属性中，传给外键视图类使用
        user = self._get_user(attrs)
        payload = jwt_payload_handler(user)  # 内部提供的方法，生成tokrn
        token = jwt_encode_handler(payload)  # 内部提供的方法,生成token
        self.context['token'] = token       # 吧token放进context中，方便取
        return attrs

    # 多方式登录
    def _get_user(self, attrs):
        username = attrs.get('username')
        password = attrs.get('password')
        import re
        if re.match(r'^1[3-9][0-9]{9}$', username):
            # 手机登录
            user = models.User.objects.filter(mobile=username, is_active=True).first()
        elif re.match(r'^.+@.+$', username):
            # 邮箱登录
            user = models.User.objects.filter(email=username, is_active=True).first()
        else:
            # 账号登录
            user = models.User.objects.filter(username=username, is_active=True).first()
        if user and user.check_password(password):
            return user

        raise ValidationError({'user': 'user error'})&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;models.py-表&quot;&gt;4、models.py 表&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from django.contrib.auth.models import AbstractUser
from django.db import models


class User(AbstractUser):  # settings.py中要配置
    mobile = models.CharField(max_length=11, unique=True, verbose_name='移动电话')
    icon = models.ImageField(upload_to='icon', default='icon/default.png', verbose_name='头像')

    class Meta:
        db_table = 'o_user'
        verbose_name_plural = '用户表'

    def __str__(self):
        return self.username


class Book(models.Model):
    name = models.CharField(max_length=64, verbose_name='书名')

    class Meta:
        db_table = 'o_book'
        verbose_name_plural = '书表'

    def __str__(self):
        return self.name


class Car(models.Model):
    name = models.CharField(max_length=64, verbose_name='车名')

    class Meta:
        db_table = 'o_car'
        verbose_name_plural = '车表'

    def __str__(self):
        return self.name

&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;数据准备&quot;&gt;数据准备&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&quot;&quot;&quot;
1）User表创建两条数据
2）Group分组表创建一条数据，name叫vip
3）操作User和Group的关系表，让1号用户属于1号vip组
&quot;&quot;&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;permissions.py-自定义权限&quot;&gt;1、permissions.py 自定义权限&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from rest_framework.permissions import BasePermission

from django.contrib.auth.models import Group
class IsVipUser(BasePermission):
    def has_permission(self, request, view):
        if request.user and request.user.is_authenticated:  # 必须是合法用户
            try:
                vip_group = Group.objects.get(name='vip')
                if vip_group in request.user.groups.all():  # 用户可能不属于任何分组
                    return True  # 必须是vip分组用户
            except:
                pass

        return False&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;views.py-权限视图&quot;&gt;2、views.py 权限视图&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from .permissions import IsVipUser
class CarViewSet(ModelViewSet):
    permission_classes = [IsVipUser] # 自定义校验

    queryset = models.Car.objects.all()
    serializer_class = serializers.CarSerializer&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;serializers.py-序列化-1&quot;&gt;3、serializers.py 序列化&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class CarSerializer(serializers.ModelSerializer):
    class Meta:
        model = models.Car
        fields = ('name', )&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;urls.py-自定义路由&quot;&gt;4、urls.py 自定义路由&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;router.register('cars', views.CarViewSet, 'car')&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;setting.py-权限配置&quot;&gt;5、setting.py 权限配置&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;from rest_framework import settings&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# drf配置（把配置放在最下方）
REST_FRAMEWORK = {
    # 自定义三大认证配置类们
    'DEFAULT_AUTHENTICATION_CLASSES':['rest_framework_jwt.authentication.JSONWebTokenAuthentication'], # 认证
    # 'DEFAULT_PERMISSION_CLASSES': [],         # 权限
    # 'DEFAULT_THROTTLE_CLASSES': [],           # 频率
  }  &lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;频率限制源码分析&quot;&gt;频率限制源码分析&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1736414/202002/1736414-20200225180757706-2068368547.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1736414/202002/1736414-20200225181012616-1713500139.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;重点&quot;&gt;重点&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&quot;&quot;&quot;
1）如何自定义频率类
2）频率校验的规则
3）自定义频率类是最常见的：短信接口一分钟只能发生一条短信
&quot;&quot;&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;系统频率类&quot;&gt;系统频率类&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#1）UserRateThrottle: 限制所有用户访问频率
#2）AnonRateThrottle：只限制匿名用户访问频率&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自定义频率类&quot;&gt;自定义频率类&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from rest_framework.throttling import SimpleRateThrottle
&quot;&quot;&quot;
1）自定义类继承SimpleRateThrottle
2）设置类实现scope，值就是一个字符串，与settings中的DEFAULT_THROTTLE_RATES进行对应
    DEFAULT_THROTTLE_RATES就是设置scope绑定的类的频率规则：1/min 就代表一分钟只能访问一次
3）重写 get_cache_key(self, request, view) 方法，指定限制条件
    不满足限制条件，返回None：代表对这类请求不进行频率限制
    满足限制条件，返回一个字符串(是动态的)：代表对这类请求进行频率限制
        短信频率限制类，返回 &quot;throttling_%(mobile)s&quot; % {&quot;mobile&quot;: 实际请求来的电话}
&quot;&quot;&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;throttles.py-自定义频率和请求方式限制&quot;&gt;1、throttles.py 自定义频率，和请求方式限制&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from rest_framework.throttling import SimpleRateThrottle
# 只限制查接口的频率，不限制增删改的频率
class MethodRateThrottle(SimpleRateThrottle):
    scope = 'method'    # 系统的配置就放在配置文件中
    def get_cache_key(self, request, view):
        # 只有对get请求进行频率限制
        if request.method.lower() not in ('get', 'head', 'option'):
            return None

        # 区别不同的访问用户，之间的限制是不冲突的
        if request.user.is_authenticated:
            ident = request.user.pk
        else:
            # get_ident是BaseThrottle提供的方法，会根据请求头，区别匿名用户，
            # 保证不同客户端的请求都是代表一个独立的匿名用户
            ident = self.get_ident(request)
        return self.cache_format % {'scope': self.scope, 'ident': ident}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;settings.py-频率配置&quot;&gt;2、settings.py 频率配置&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;REST_FRAMEWORK = {
    #  ...
    # 频率规则配置
    'DEFAULT_THROTTLE_RATES': {
        # 只能设置 s，m，h，d，且只需要第一个字母匹配就ok，m = min = maaa 就代表分钟
        'user': '3/min',  # 配合drf提供的 UserRateThrottle 使用，限制所有用户访问频率
        'anon': '3/min',  # 配合drf提供的 AnonRateThrottle 使用，只限制匿名用户访问频率
        'method': '3/min', # 限制请求方式频率
    },
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;views.py-频率视图&quot;&gt;3、views.py 频率视图&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from .permissions import IsVipUser
from .throttles import MethodRateThrottle
class CarViewSet(ModelViewSet):
    permission_classes = [IsVipUser]    # 自定义是否是VIP校验
    throttle_classes = [MethodRateThrottle] # 自定义频率限制
    
    queryset = models.Car.objects.all()
    serializer_class = serializers.CarSerializer&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;exception.py-处理后端异常&quot;&gt;exception.py 处理后端异常&lt;/h2&gt;
&lt;p&gt;主要：后端异常之后一定要添加日志记录。配合日志一起使用&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from rest_framework.views import exception_handler as drf_exception_handler
from rest_framework.response import Response
def exception_handler(exc, context):
    # 只处理客户端异常，不处理服务器异常，
    # 如果是客户端异常，response就是可以直接返回给前台的Response对象
    response = drf_exception_handler(exc, context)

    if response is None:
        # 没有处理的服务器异常，处理一下
        # 其实给前台返回 服务器异常 几个字就行了
        # 那我们处理异常模块的目的是 不管任何错误，都有必要进行日志记录（线上项目只能通过记录的日志查看出现过的错误）
        response = Response({'detail': '%s' % exc})

    # 需要结合日志模块进行日志记录的：项目中讲
    return response&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;settings.py-异常配置&quot;&gt;settings.py 异常配置&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;REST_FRAMEWORK = {
    # ...
    # 异常模块
    # 'EXCEPTION_HANDLER': 'rest_framework.views.exception_handler',  # 原来的，只处理客户端异常
    'EXCEPTION_HANDLER': 'api.exception.exception_handler',
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 25 Feb 2020 14:05:00 +0000</pubDate>
<dc:creator>辜老板</dc:creator>
<og:description>[TOC] 一、特殊路由映射的请求 实现用户中心信息自查，不带主键的get请求，走单查逻辑 urls.py views.py 二、token刷新机制配置（了解） drf jwt直接提供刷新功能 set</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/guyouyin123/p/12364111.html</dc:identifier>
</item>
<item>
<title>为什么你精通CRUD，却搞不懂数据库的基本原理？ - 黄小斜</title>
<link>http://www.cnblogs.com/xll1025/p/12364086.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xll1025/p/12364086.html</guid>
<description>&lt;h2 id=&quot;原创声明&quot;&gt;原创声明&lt;/h2&gt;
&lt;p&gt;本文作者：黄小斜&lt;/p&gt;
&lt;p&gt;转载请务必在文章开头注明出处和作者。&lt;/p&gt;
&lt;h2 id=&quot;本文思维导图&quot;&gt;本文思维导图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1092007/202002/1092007-20200225220028948-2054882980.png&quot;/&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; title=&quot;点击并拖拽以移动&quot;/&gt;​&lt;/p&gt;
&lt;h2 id=&quot;数据库和关系型数据库&quot;&gt;数据库和关系型数据库&lt;/h2&gt;
&lt;p&gt;作为一个程序员，不了解数据库怎么能行，那么数据库到底是个啥呢，作为一个Java工程师，平时和数据库打交道着实不少，所谓的CRUD其实就是对数据库进行增删改查的操作。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;根据百度百科的介绍，数据库是“按照数据结构来组织、存储和管理数据的仓库”。是一个长期存储在计算机内的、有组织的、有共享的、统一管理的数据集合。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;数据库是以一定方式储存在一起、能与多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合，可视为电子化的文件柜——存储电子文件的处所，用户可以对文件中的数据进行新增、查询、更新、删除等操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是不是没听懂，好吧，简单来说，像MySQL这样的数据库，就是用于存储结构化数据的，比如一个学生的信息数据，一个商品的数据，或者是一个学生购买商品的消费数据。&lt;/p&gt;
&lt;p&gt;联想到平时我们经常使用的Excel，其实和数据库挺像的，数据库其实就是一个表格，里面有很多的数据类型，比如字符串，比如数字，再比如长文本等等。&lt;/p&gt;
&lt;p&gt;而这类数据库也叫关系型数据库，典型代表就是MySQL。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;再看看百度百科的介绍，关系型数据库，是指采用了关系模型来组织数据的数据库，其以行和列的形式存储数据，以便于用户理解，关系型数据库这一系列的行和列被称为表，一组表组成了数据库。用户通过查询来检索数据库中的数据，而查询是一个用于限定数据库中某些区域的执行代码。关系模型可以简单理解为二维表格模型，而一个关系型数据库就是由二维表及其之间的关系组成的一个数据组织。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;除了关系型数据库之外，近些年来还有很多nosql（not only sql）数据库在兴起，比如MongoDB，以及图数据库、列式数据库等等，这些数据库对于新手程序员来说用的并不多，所以本文我们只讨论关于关系型数据库的内容。&lt;/p&gt;
&lt;p&gt;关系型数据库是我们程序员平时用的最多，也最简单易上手的数据库类型，所以，学习数据库一般也从MySQL这类关系型数据库入手，一来它简单好学，二来它是免费的。&lt;/p&gt;
&lt;h2 id=&quot;我的数据库学习历程&quot;&gt;我的数据库学习历程&lt;/h2&gt;
&lt;p&gt;我第一次听说“数据库”这个词还是在大学的时候，那时候正值大家找工作，有一个同学和我们分享自己的求职经验，据他所说，每个公司都会考察你的数据库知识，学好了数据库，面试什么公司都不怕。&lt;/p&gt;
&lt;p&gt;当时我还觉得挺玄乎的，不过我们学校确实没来什么大公司，我对此半信半疑，至于到底是不是这样，后来也就没再追究了。&lt;/p&gt;
&lt;p&gt;第二次接触数据库，是在学习Java的时候，记得当初自己跟着一个小教程，下载安装了MySQL，然后从网上下载了demo代码，用当时先进的开发工具eclipse跑通了别人家的代码，其实就是增删改查。&lt;/p&gt;
&lt;p&gt;只不过当时对这些东西也没啥概念，后来又下载了一个db的可视化工具，可以更方便地了解自己的数据库里到底都有啥。&lt;/p&gt;
&lt;p&gt;再到后来，我开始慢慢接触项目实战，使用数据库的时间也越来越长，自以为对于数据库的理解还算可以，直到我真正地接触了数据库相关的面试题，才让我发现自己对于数据库的理解是多么的肤浅。&lt;/p&gt;
&lt;p&gt;那个时候，我只懂写一些简单的crud，甚至连内外连接、group by和count等一些简单的sql用法都不了解，除此之外，我对于数据库的一些原理性内容几乎也是一窍不通的，比如数据库的索引、事务、锁机制，我统统不知道，更别谈如何回答相关的面试题了。&lt;/p&gt;
&lt;p&gt;于是，我开始意识到学习数据库原理是多么重要的一件事情，我开始看数据库方面的书籍，从最基础的数据库教材，再到MySQL的原理性内容，再到mybatis这类orm框架的实现，我都逐渐地开始学习和了解，直到我能够对大部分的数据库面试题都较好地掌握。&lt;/p&gt;
&lt;p&gt;而现在，我在一个每天要处理海量数据的公司里工作，对于数据方面的学习已经不仅仅停留在数据库了，我还要接触数据仓库、分布式数据库以及各种大数据的应用场景，学习数据知识的道路看来短时间内是走不完了。&lt;/p&gt;
&lt;h2 id=&quot;学习数据库先从sql入手&quot;&gt;学习数据库，先从SQL入手&lt;/h2&gt;
&lt;p&gt;说到MySQL，就不得不谈谈SQL了，sql，按照百科的说法是这样的&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;结构化查询语言(Structured Query Language)简称SQL，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于不同的数据库，sql的写法可能有一些差异，但是大致都是相同的，就拿MySQL来说，平时我们用到最多的就是select、update、delete和insert了，这类操作统称为数据操纵语言DML（Data Manipulation Language），用户通过它可以实现对数据库的基本操作。&lt;/p&gt;
&lt;p&gt;当然还有操作数据库和表的一些ddl，数据库模式定义语言DDL(Data Definition Language)，是用于描述数据库中要存储的现实世界实体的语言。 简单来说，ddl其实就是用来执行建表，删表，更改表结构等操作的&lt;/p&gt;
&lt;p&gt;以前我的sql写的并不多，毕竟简单的增删改查并不需要多复杂的sql技巧，最多就是做一下表连接。&lt;/p&gt;
&lt;p&gt;再到后来，我开始做一些项目，接触了ORM的一些框架，比如hibernate和mybatis，这些框架甚至可以让你完全不写sql，只要调用一些增删改查的API即可，这让我很长一段时间都忽略了SQL的重要性。&lt;/p&gt;
&lt;p&gt;其实学习sql最复杂的地方并不是一些高级用法，而是在于实际场景中的应用和优化。两条sql，可能因为简单的差异就会有很大的性能差距，差异点可能是，比如有没有走到索引，是否是全表扫描，又或者走到了哪个索引，而这样的性能分析只有在实际的场景里才有意义。&lt;/p&gt;
&lt;p&gt;当然了，对于新手来说，学习sql的语法是放在第一位的，然后才能逐渐过渡到会使用，会优化，会分析。&lt;/p&gt;
&lt;h2 id=&quot;关于数据库的那些面试题&quot;&gt;关于数据库的那些面试题&lt;/h2&gt;
&lt;p&gt;想要真正学好数据库，搞定面试题中的相关问题，那你就必须要搞懂数据库的基本原理。&lt;/p&gt;
&lt;p&gt;如果你不相信，那我随便举几个面试题常见的题型，比如”数据库事务的ACID是什么意思”、“数据库中有哪些锁”、“数据库的索引用的是什么数据结构”&lt;/p&gt;
&lt;p&gt;上面几道题算是简易版的，在平常的面试中也经常能够看到，就算你只是背一背答案，可能也多少能答对一些，那么如果再进一步，考察一下数据库的原理性知识，恐怕就没这么简单了。&lt;/p&gt;
&lt;p&gt;举个栗子“数据库事务的ACID是如何实现的”，“数据库中有哪些锁，分别是如何实现的，如何使用”、“数据库中的索引是如何实现的，何时命中索引，何时不能，为什么“&lt;/p&gt;
&lt;p&gt;是不是感觉难度一下子就上来了。毕竟深入到原理性的东西，懂的人就越来越少了。除此之外，还有很多进阶的面试题，更多时候会结合实际场景来考察。&lt;/p&gt;
&lt;p&gt;比如考察你对MySQL存储引擎innodb的理解，对于sql优化的理解 ，以及对于分布式场景下数据库能力的应用，比如分布式锁，分布式事务，以及分库分表的一些问题。&lt;/p&gt;
&lt;p&gt;知道了面试题大概都考啥之后，接下来我们要做的就是找到症结所在，然后一一击破&lt;/p&gt;
&lt;h2 id=&quot;数据库基本原理&quot;&gt;数据库基本原理&lt;/h2&gt;
&lt;p&gt;学习数据库，你需要先打好基础，数据库原理是计算机科班的一门必修课，非科班的我选择的是自学，我当时也是拿着那本大学教材《数据库系统概论》来自学的。&lt;/p&gt;
&lt;p&gt;教材这种东西，肯定还是偏理论的一点，我们要了解的内容主要包含几个方面&lt;/p&gt;
&lt;p&gt;1、数据库模型有哪些：包括层次模型、网状模型和关系模型，我们所用的关系型数据库就是基于关系模型实现的。&lt;/p&gt;
&lt;p&gt;2、关系数据库的基础和sql：了解关系数据库的基本概念，了解sql的基本使用方法，至少CRUD和一些常见用法要搞懂&lt;/p&gt;
&lt;p&gt;3、数据库的安全性和完整性，这两部分内容其实理论的东西比较枯燥，实际上对应到实际场景中，安全性就是要保护数据的安全，包括权限控制和数据备份，而完整性则是通过一些约定和规范来限制数据库的存储内容，比如我们可以用主键、唯一键、非空等要求来限制字段的取值。&lt;/p&gt;
&lt;p&gt;4、关系数据理论 这部分内容很有意思，也比较复杂，讲到了数据库的范式理论，从一范式到四范式，各有各的用法和要求，某互联网公司“第四范式”就是用这个概念来命名的。&lt;/p&gt;
&lt;p&gt;5、事务和锁 最后一部分内容，就是数据库的两个重要组成部分，事务和锁，事务可以保证一组数据库操作的ACID特性，非常适用于需要数据一致性的场景，而数据库的锁不但是实现事务的基础，还可以灵活地适用于不同的数据库应用场景，我们还可以通过sql语句来完成加锁和释放，对于并发场景尤其管用。&lt;/p&gt;
&lt;h2 id=&quot;mysql的实现原理&quot;&gt;MySQL的实现原理&lt;/h2&gt;
&lt;p&gt;学习完了数据库基础之后，接下来就该学习MySQL了，毕竟很多时候我们的数据库应用就是MySQL。&lt;/p&gt;
&lt;p&gt;其实MySQL里的很多知识点和我们上面提到的数据库基础大同小异，而回到MySQL的实现层，我们就得来看看MySQL的存储引擎了。&lt;/p&gt;
&lt;p&gt;MySQL的存储引擎分为innodb和myisam，相信大家对于这两个引擎区别的面试题看了也不少，比如innodb支持事务，支持行级锁，而myisam不支持。&lt;/p&gt;
&lt;p&gt;由于现在innodb基本上是主流，所以我们讨论MySQL的时候基本上就是在讨论innodb。对于MySQL的实现原理，我认为大概有这么一些内容需要我们去学习。&lt;/p&gt;
&lt;p&gt;首先，我们了解MySQL里有哪些数据类型，一般的用法如何，然后，尝试用MySQL去跑一些sql语句，建库建表，加索引加主键，总之，这些实践能帮助你更好地学习上述内容。&lt;/p&gt;
&lt;p&gt;想要更好地了解MySQL的原理，我们就必须要了解MySQL的整体架构，一般来说，MySQL从上到下可以分为这么几层&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1092007/202002/1092007-20200225220038803-1054344244.jpg&quot; alt=&quot;image&quot;/&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; title=&quot;点击并拖拽以移动&quot;/&gt;​&lt;/p&gt;
&lt;h3 id=&quot;客户端&quot;&gt;客户端&lt;/h3&gt;
&lt;p&gt;也就是我们经常用的可视化工具，比如Navicat for MySQL&lt;/p&gt;
&lt;h3 id=&quot;服务端&quot;&gt;服务端&lt;/h3&gt;
&lt;p&gt;就是我们安装的MySQL程序，其实打开它它就是一个MySQL的服务端进程&lt;/p&gt;
&lt;h3 id=&quot;sql执行层&quot;&gt;sql执行层&lt;/h3&gt;
&lt;p&gt;sql执行层主要负责解析执行sql，里面包含了很多复杂的组成部分，比如解释器，分析器，优化器等等，执行层会生成一个sql的执行计划，这个计划也经常是我们分析sql性能的一个重要参考内容&lt;/p&gt;
&lt;h3 id=&quot;存储引擎层&quot;&gt;存储引擎层&lt;/h3&gt;
&lt;p&gt;存储引擎层是innodb了，比如数据要如组织和存放，索引要如何建立和管理等等，加锁怎么加，事务如何实现，都是这一层要考虑的内容。&lt;/p&gt;
&lt;h3 id=&quot;文件系统层&quot;&gt;文件系统层&lt;/h3&gt;
&lt;p&gt;存储引擎的下一层就是文件系统了，数据库的数据如何和文件系统进行交互，就是这一层要做的事情了。&lt;/p&gt;
&lt;h3 id=&quot;索引&quot;&gt;索引&lt;/h3&gt;
&lt;p&gt;不得不说，索引绝对是数据库中最经常考察，考点也最多的内容了。&lt;/p&gt;
&lt;p&gt;比如给你一条sql，那么它能否命中索引，能命中哪些索引，如果想要命中某个索引，你应该如何修改，这种问题面试时是不是经常看到，变来变去这么多题型，其实面试官就是想考察你对于索引的理解。&lt;/p&gt;
&lt;p&gt;还有就是，索引的数据结构，一样是非常热门的考点之一，索引其实是基于B+树来实现的，不知道b+树是啥，请回去看数据结构。&lt;/p&gt;
&lt;p&gt;简单来说，它是一种多路搜索树，致力于更短的时间来完成数据检索，因为它的高度比二叉树要低，而比起普通的b树，它的非叶节点只起索引作用，而叶子节点是顺序串联的，所以非常适合做搜索树。&lt;/p&gt;
&lt;p&gt;如果你理解了这一点，那么面对此类面试题就可以更加从容一些，面试官其实就是想知道你对b+树的了解到了什么样的程度而已。&lt;/p&gt;
&lt;h3 id=&quot;事务和锁&quot;&gt;事务和锁&lt;/h3&gt;
&lt;p&gt;除了索引之外，数据库中最复杂的内容可能就是事务和锁了。&lt;/p&gt;
&lt;p&gt;就拿事务的ACID特性来说，你需要了解每个大写字母背后的实现原理，比如原子性是如何实现的，一致性是如何保证的，背后的原理是什么。&lt;/p&gt;
&lt;p&gt;我们平时常用的事务可能就是spring里的事务模板，在事务里执行的同库数据库操作，要么都成功，要么都失败，这就是原子性。&lt;/p&gt;
&lt;p&gt;两个事务之间互不影响，这就是隔离性，当然了，这里又涉及到了事务隔离级别。&lt;/p&gt;
&lt;p&gt;事务隔离级别包括读未提交，读已提交，可重复读和序列化，每个事务隔离级别都适用于某种数据库读写场景，很多时候，我们都需要搞懂隔离级别背后的原理，才能更好地适用它。&lt;/p&gt;
&lt;p&gt;MySQL里默认使用可重复读的隔离级别，这个级别基本上可以保证我们的事务按照预期执行，在MySQL中，这个事务隔离级别甚至可以解决幻读的问题。&lt;/p&gt;
&lt;p&gt;在MySQL的事务背后，其实有一个隐藏的boss，那就是数据库的锁，很多事务的隔离级别都是通过锁来实现的，比如可重复读只要加行锁就可以实现了，而幻读则需要加上间隙锁next-key lock来实现。&lt;/p&gt;
&lt;p&gt;行级锁和表级锁是MySQL中的两种锁，表级锁顾名思义，会直接锁表，一次只有一个事务能够访问，而行级锁其实锁的也并非是一行，在MySQL中，这个锁加在索引上，而这个索引对应的数据往往不止一行，所以这个行级锁只是理论意义上的&quot;行级锁&quot;&lt;/p&gt;
&lt;p&gt;说了这么多，要理解MySQL的事务和锁，还是要多看看相关的书籍和文章，理解其内部的实现原理，知其然也要知其所以然。&lt;/p&gt;
&lt;p&gt;下面又到了我们熟悉的资源推荐环节&lt;/p&gt;
&lt;h2 id=&quot;推荐资源&quot;&gt;推荐资源&lt;/h2&gt;
&lt;h3 id=&quot;书籍&quot;&gt;书籍&lt;/h3&gt;
&lt;p&gt;数据库&lt;/p&gt;
&lt;p&gt;0 《数据库系统概论》&lt;/p&gt;
&lt;p&gt;数据库原理应该是教材吧，这本书作为数据库入门来说还是可以的，毕竟不是专门做DB的，看大厚书用处不大，这本书把数据库的基本概念都讲完了。&lt;/p&gt;
&lt;p&gt;1 sql必知必会&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1092007/202002/1092007-20200225220039333-1180512167.jpg&quot;/&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; title=&quot;点击并拖拽以移动&quot;/&gt;​&lt;img src=&quot;https://img2018.cnblogs.com/blog/1092007/202002/1092007-20200225220039532-919652458.gif&quot;/&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; title=&quot;点击并拖拽以移动&quot;/&gt;​​&lt;/p&gt;
&lt;p&gt;这本书主要是讲解sql语句怎么写，毕竟数据库最重要的一点就是要熟练地使用sql语句，当然这本书也可以当做工具书来使用。&lt;/p&gt;
&lt;p&gt;2 深入浅出MySQL&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1092007/202002/1092007-20200225220039705-1727339610.jpg&quot;/&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; title=&quot;点击并拖拽以移动&quot;/&gt;​&lt;img src=&quot;https://img2018.cnblogs.com/blog/1092007/202002/1092007-20200225220039532-919652458.gif&quot;/&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; title=&quot;点击并拖拽以移动&quot;/&gt;​​&lt;/p&gt;
&lt;p&gt;这本书适合作为MySQL的学习书籍，当你有了一定的MySQL使用经验后，可以看看它，该书从数据库的基础、开发、优化、管理维护和架构5个方面对MySQL进行了详细的介绍，讲的不算特别深，但是足够我们使用了。这本书我也只看了一部分。&lt;/p&gt;
&lt;p&gt;3 MySQL技术内幕：innodb存储引擎&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1092007/202002/1092007-20200225220040010-5906030.jpg&quot;/&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; title=&quot;点击并拖拽以移动&quot;/&gt;​&lt;img src=&quot;https://img2018.cnblogs.com/blog/1092007/202002/1092007-20200225220040174-2049605305.gif&quot;/&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; title=&quot;点击并拖拽以移动&quot;/&gt;​​&lt;/p&gt;
&lt;p&gt;看完上面那本书以后，对MySQL算是比较熟悉了，不过对于面试中常考的innodb引擎，还是推荐一下这本书把，专门讲解了innodb存储引擎的相关内容。我还没有细看，但是内容足够你学好innodb了。&lt;/p&gt;
&lt;p&gt;4 高性能Mysql&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1092007/202002/1092007-20200225220040796-2047238872.jpg&quot;/&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; title=&quot;点击并拖拽以移动&quot;/&gt;​&lt;img src=&quot;https://img2018.cnblogs.com/blog/1092007/202002/1092007-20200225220039532-919652458.gif&quot;/&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; title=&quot;点击并拖拽以移动&quot;/&gt;​​&lt;/p&gt;
&lt;p&gt;这本书可以说是很厚了，更适合DBA拜读，讲的太详细了，打扰了。&lt;/p&gt;
&lt;h2 id=&quot;微信公众号程序员黄小斜&quot;&gt;微信公众号【程序员黄小斜】&lt;/h2&gt;
&lt;p&gt;致力于让自学编程这件事变得更简单，授人以鱼也要授人以渔。作者自学编程转行互联网，目前是阿里巴巴Java工程师，专注于分享程序员前沿技术干货和编程学习心得，期待你的关注，和我们一起进步！ &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文中所提到的电子书都可以免费领取，在我的公众号后台回复“计算机网络”即可领取对应的下载地址。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1092007/202002/1092007-20200225220041686-1194757553.png&quot;/&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; title=&quot;点击并拖拽以移动&quot;/&gt;​&lt;/p&gt;
</description>
<pubDate>Tue, 25 Feb 2020 14:01:00 +0000</pubDate>
<dc:creator>黄小斜</dc:creator>
<og:description>原创声明 本文作者：黄小斜 转载请务必在文章开头注明出处和作者。 本文思维导图 ​ 数据库和关系型数据库 作为一个程序员，不了解数据库怎么能行，那么数据库到底是个啥呢，作为一个Java工程师，平时和数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xll1025/p/12364086.html</dc:identifier>
</item>
<item>
<title>对象级别锁 vs 类级别锁（Java） - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/12363526.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/12363526.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;对于多线程（并发）和Spring Boot这两块在同步进行学习中，在看到使用synchronized关键字使操作同步时，看到和C#中不一样的东西，所以这里呢，就深入学习了下，若有错误之处，还望指正。&lt;/p&gt;
&lt;h2&gt;对象级别锁 vs 类级别锁&lt;/h2&gt;
&lt;p&gt;我们知道由于并发会导致线程不安全的问题，此时我们手段之一采取线程同步，也就是说使得所有并发线程在执行中保持同步的过程，当方法声明为同步时，传递到同步块中的对象称之为监视器或锁定对象，如果有另外一个线程也在执行该同步方法，那么该线程将被阻塞，直到线程释放该监视器或锁定对象。我们&lt;span&gt;在类中已定义的方法或块上使用synchronized关键字，同时synchronized&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;关键字不能与类定义中的变量或属性一起使用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;对象级别锁&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;所谓的对象级别锁，也就是针对非静态方法执行同步块锁定，那么同步块中的监视器或锁定对象则是基于对象实例，有如下三种形式&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; LockMethod() {
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;&lt;span&gt; LockMethod() {
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
        {
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object lock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; LockMethod() {
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (lock) {
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;类级别锁&lt;/h3&gt;
&lt;p&gt;若在同步方法中存在静态数据，为保持静态数据线程安全，我们则需使用类级别锁，这意味着，如果在运行时有多个实例的Test，则一次只能在一个实例中的一个线程上执行一个线程LockMethod()，而所有其他实例将被其他线程锁定。针对类级别锁，那么同步块中监视器或锁定对象有如下三种形式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; LockMethod() {
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; LockMethod() {
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (Test.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
        {
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object lock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; LockMethod() {
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (lock) {
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里我主要是看到了上述第二种形式中所使用的锁定对象，由于java和C#语法大多相似，但是这在C#中找不到可对比的东西，我不明白这到底是什么个意思，所以就深入看了些，本以为可以直接查看源码，然而并没有任何反应，看来就是Java中天然存在的了，我去打印发现和获取实例的类名的结果是一样的，我们将这种情况翻译为className.class，这到底是什么意思呢？为何上述第二种形式就是类级别锁定从而保证线程安全了呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
System.out.println(Test.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.toString());
System.out.println(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Test().getClass());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/589642/202002/589642-20200225213131911-1560439972.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;于是乎我想到看一下所购买的《深入理解Java虚拟机》中对于类加载原理的解释，结果发现：&lt;span&gt;在类加载时机的第一阶段也就是加载阶段，虚拟机会完成3件事情，其中最后一件事情则是在内存中生成一个对应类的java.lang.Class对象，作为方法区这个类的各种数据的入口。换句话说，每个类在JVM中有且只会有唯一的一个java.lang.Class对象实例，所以我大胆猜测className.class就是获取java.lang.Class对象唯一实例的引用，如此一来就保证始终只有一个线程能够进入同步块。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;本节我们通过对关键字synchronized实现线程同步做了详细了解，其实并不难，这里我想表达的是看到和C#中不一样的东西，也就是className.class具体是什么意思，同时在用java实现单例模式中也有这种情况，所以详细学习了下，也做个备忘录，可能对大部分学java的童鞋而言确实很简单，我还是处于初级阶段，也是在一步步深入的学习。&lt;/p&gt;
</description>
<pubDate>Tue, 25 Feb 2020 13:54:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<og:description>前言 对于多线程（并发）和Spring Boot这两块在同步进行学习中，在看到使用synchronized关键字使操作同步时，看到和C#中不一样的东西，所以这里呢，就深入学习了下，若有错误之处，还望指</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CreateMyself/p/12363526.html</dc:identifier>
</item>
<item>
<title>《程序员的办公室日常》第一回 相识 - 程序员姜小白</title>
<link>http://www.cnblogs.com/jpcflyer/p/12363642.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jpcflyer/p/12363642.html</guid>
<description>&lt;section&gt;&lt;span&gt;今天阿中像平常一样，又是最后一个进了办公室。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这要是在以前，腼腆的阿中肯定会像是小学生犯了错一样，满脸羞红的悄悄溜进办公室，生怕弄出一点动静而被其它同事发现。但现在不一样了，现在阿中已经在这家大企业度过了8年的时光，虽然现在不是什么领导，但他的资历辈分却比很多领导都要大，所以领导平时也会很给这个老同事面子，包括经常迟到这件事&lt;/span&gt;&lt;span&gt;。。。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“哎，你们听说了没有？”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“什么啊？”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“今天咱们部门入职的妹子里面有位大美女！”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;同事这么一说，整个办公室瞬间开始吵杂了起来。阿中的部门是这家国企中的 IT技术部门，向来一直是男多女少，而且程序员的形象，大家也都懂的，能简洁就简洁，平时爱好代码胜过于爱自己的妆容。包括部门里面的少数女生程序员，本身没有化妆的爱好，加上整天被4K液晶电脑屏幕散发出的光束侵蚀着，导致部门中大家向来一直是哥们兄弟相称。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;阿中听到有美女一来，也心动了一下，毕竟自己已经过了30岁的生日了，但至今还是单身。家里也没少为他的事儿操心，而阿中却一副无所谓的样子，整天把时间用在学习各种技术资料和敲代码身上，似乎还没有意识到自己已经慢慢成为一名中年油腻男的现实。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“有照片没有啊？”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“一会儿来部门的时候不就能见到了呀！！”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;听到没有照片，阿中也不想再参考讨论这个话题，又将精力收回到了自己的电脑屏幕上。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“怎么咱们公司也要搞中台了啊，现在有人能讲清楚中台是个什么东西吗？”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;阿中一边吐槽着公司乱跟潮流，一边也感叹自己是不是老了，可能跟不上现在的时代了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“阿中啊，你得赶紧研究一下相关的中台概念。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;阿中回头一看，是领导阿信过来了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“上面领导对咱们搞技术中台也很重视，我准备让你来牵头成立一支队伍，负责规划咱们的中台方案，两个星期后，要跟大领导做一个中台技术方案的汇报。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;阿中低声恩了一声，说完，阿信领导就走了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;阿中心里是不愿意，但毕竟是自己的领导，还是要给面子的。一边喝着水，一边想着如何入手。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“先度娘一下吧。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;中台其实是为前台而生的平台，它存在的唯一目的就是更好的服务前台规模化创新，进而更好的服务用户，使企业真正做到自身能力与用户需求的持续对接&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“这是什么乱七八糟的理论，跟没说一样，看看有没有干货”。阿中一边想，一边继续搜索着。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;中台通常可以分为三个层面： 业务中台，数据中台和技术中台。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;业务中台，业务服务将业务的公共需求组合成服务，比如电商公司，客户，商品，物流，支付就是公共需要，比如汽车制造商，用户，车辆，订单，交付都是公共需求。将这些公共业务组合成统一的业务服务，供各个业务单元使用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据中台，数据服务数据时代，业务中越来越依赖于数据，包含：数据的收集，数据处理，数据算法和分析，报表，以及数据的治理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;技术中台，基础服务通常是底层的服务，面向技术。这些底层技术包括：安全认证，权限管理，流程引擎，门户，消息，通知等等。这些组件通常与业务关联度不大，属于每个应用都需要使用的功能。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img src=&quot;https://www.135editor.com/js/ueditor/themes/default/images/spacer.gif&quot; data-ratio=&quot;1&quot; word_img=&quot;file:///C:/Users/jiang/AppData/Local/Temp/enhtmlclip/Image.jpg&quot;/&gt;&lt;img src=&quot;https://bdn.135editor.com/files/users/633/6332262/202002/5bEyAUMD_EmOG.png&quot; data-ratio=&quot;1&quot; alt=&quot;image.png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“嗯，这个就有点意思了”，阿中继续思考着，“那应该如何来建设中台呢？”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;中台从整体规划到落地交付的过程可以划分成四个不同的阶段，包含了两次发散与收敛的过程，也称之为D4。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第一个阶段是 Discovery，帮助我们在中台规划前先建立全局视野。在这个过程中我们以企业愿景和战略为输入，结合行业趋势、竞争对手分析、用户客群分析 、业务现状分析、IT 资产盘点，全方位多角度地理解企业的战略市场环境以及业务及 IT 全貌，帮助我们做出最正确的判断。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第二个阶段是Define，帮助我们基于之前 Discovery 发散的各维度信息进行收敛与分析， 对于中台的架构进行定义。通过对跨业务线的业务梳理进行重合度分析，并结合领域分析对业务表象之后的企业核心问题域做进一步展开和重合度分析，一起来收敛推导基于中台的企业架构设计。并基于多维度的打分，形成具体的实施路径规划，说白了就是先做什么后做什么。这里需要注意一点，此时收敛的是仍是企业架构层面，像业务中台、数据中台这种级别的产品，可能只是实施路径中的一个项目，在这个阶段也可以回答那个我们关心的问题，我们到底需不需要中台，需要哪些中台？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第三个阶段是Design，帮助我们针对实施路径中的某一个产品，例如业务中台，做详细的设计，包括产品级的业务需求分析、功能及架构设计、实施计划等。例如对于业务中台产品，在 Design 阶段我们需要回答产品的愿景、边界、产品形态、技术架构、交付计划、成本预估等等，这个过程就是一个标准的产品设计过程，只不过在中台项目中大多是针对中台类的产品而已。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第四个阶段是Delivery，这个时候我们就可以针对一个设计好的中台，开始具体的交付过程，我们采用的是敏捷结合精益软件开发的方式，用快速迭代和基于反馈的调整，最大程度地弥补由中台建设本身的复杂度带来的设计偏差和其他的交付问题，并且注重架构的治理与守护，减少实现与设计的偏离。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img src=&quot;https://www.135editor.com/js/ueditor/themes/default/images/spacer.gif&quot; data-ratio=&quot;1&quot; word_img=&quot;file:///C:/Users/jiang/AppData/Local/Temp/enhtmlclip/Image(1).jpg&quot;/&gt;&lt;img src=&quot;https://bdn.135editor.com/files/users/633/6332262/202002/q3R2DkfR_YI4B.png&quot; data-ratio=&quot;1&quot; alt=&quot;image.png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“这个讲的不错，我得深入看看”。阿中继续盯着屏幕，突然听到了一阵脚步声。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“下面请大家欢迎我们部门新同事李斯斯，斯斯给大家做个自我介绍吧。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;原来是阿信带着新同事过来了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“大家好，我叫李斯斯，毕业于......“&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;说完大家热烈鼓掌一翻，”确实是美女啊“，部门里男程序员们都在极力地用自己的鼓掌掩饰着某种猥琐的笑容。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;”好了，以后斯斯就是咱们技术部门了，新同事刚来，需要有个学习的过程，阿中，以后斯斯就是你的徒弟了，多抽时间带一带新同事。“&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;”好“。阿中低声应了一声。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;欲知后事如何，请关注微信公众号“程序员姜小白”，获取精彩内容，每日都会更新。&lt;/p&gt;

&lt;section class=&quot;_135editor&quot; data-role=&quot;paragraph&quot;&gt;
&lt;/section&gt;</description>
<pubDate>Tue, 25 Feb 2020 12:37:00 +0000</pubDate>
<dc:creator>程序员姜小白</dc:creator>
<og:description>今天阿中像平常一样，又是最后一个进了办公室。这要是在以前，腼腆的阿中肯定会像是小学生犯了错一样，满脸羞红的悄悄溜进办公室，生怕弄出一点动静而被其它同事发现。但现在不一样了，现在阿中已经在这家大企业度过</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jpcflyer/p/12363642.html</dc:identifier>
</item>
</channel>
</rss>