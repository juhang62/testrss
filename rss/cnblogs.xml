<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>关于链接的一些总结 - 一盏淡酒、醉了夕阳</title>
<link>http://www.cnblogs.com/helloworldcode/p/10323657.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/helloworldcode/p/10323657.html</guid>
<description>&lt;h2&gt;1.程序的编译过程&lt;/h2&gt;
&lt;p&gt; 　　假设现在有如下两个c程序文件，sum.c内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
int sum(int *a, int n){
        int i, s = 0;
        for( i = 0; i &amp;lt; n ; i++){
                s += a[i];
        }
        return s;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　主程序main.c的内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
int sum(int *a,int n);

int array[2]  = {1, 2};

int main(){
        int val = sum(array,2 );
        return val;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在linux上执行如下语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
gcc -Og -o prog main.c sum.c
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以main.c为例，程序首先调用C预处理器，将main.c翻译成一个Ascii码的中间件，mian.i，接下来将main.i翻译成一个汇编语言文件main.s，然后调用汇编器将main.s翻译可重定位的目标文件main.o，同理会生成相应的sum.o文件。最后，运行链接器程序ld，将main.o和sum.o以及一些必要的文件组合起来，创建一个可执行文件prog。&lt;/p&gt;
&lt;p&gt;　　在构造可执行文件的时候，链接器要完成两个任务：&lt;/p&gt;
&lt;p&gt;　　1、符号解析，符号解析的目的是将每个全局符号引用与符号定义关联起来，即可重定位的目标文件定义了符号，而可执行的目标文件引用符号，将两者的符号相互绑定，这里的符号对应一个函数、一个全局变量、或者一个静态变量。&lt;/p&gt;
&lt;p&gt;　　2、重定位，编译器和汇编器生成从0开始的的代码和数据节，链接器将符号定义和内存的位置关联起来来重定位代码和数据节，然后修改所有这些对符号的引用，使得它们指向内存的位置。&lt;/p&gt;
&lt;h2&gt;2.一些基础知识&lt;/h2&gt;
&lt;p&gt;　　目标文件有三种类型：&lt;/p&gt;
&lt;p&gt;　　　　可重定位的目标文件：包含二进制数据和代码，其形式可以在编译时与其他可重定位合并起来，创建一个可执行的目标文件&lt;/p&gt;
&lt;p&gt;　　　　可执行的目标文件：包含二进制和代码，可以直接复制到内存并执行&lt;/p&gt;
&lt;p&gt;　　　　共享目标文件：一类特殊的可重定位目标文件，可以在加载或者运行时被动态的加载到内存执行。&lt;/p&gt;
&lt;p&gt;　　一个典型的ELF（可执行、可链接格式）的可重定位目标文件包含几个重要的部分，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1047362/201901/1047362-20190126151829806-1446227218.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　.text 已编译程序的机器代码&lt;/p&gt;
&lt;p&gt;　　.data 已初始化的全局和静态C变量，局部C变量的值保存在栈中。&lt;/p&gt;
&lt;p&gt;　　.bss 未初始化的全局和静态C变量，以及所有被初始化为0的静态或全局变量。&lt;/p&gt;
&lt;p&gt;　　.sysmtab 一个符号表，存放程序中定义和引用的函数以及全局或静态变量，不包含局部变量的信息。&lt;/p&gt;

&lt;p&gt;对重定位的理解，在重定位，有两个步骤。&lt;/p&gt;
&lt;p&gt;　　首先重定位节和符号定义，链接器将不同目标文件所有相同类型的节合并到同一个新的聚合节中，例如，来自所有输入模块的.data节会被合并到同一个节中。然后链接器将运行时内存的地址赋给新的聚合节，赋给输入模块中定义的那个节和其中定义的每个符号。此时，程序中的每条指令和全局变量都有一个唯一的运行时内存了。&lt;/p&gt;
&lt;p&gt;　　其次是重定位符号的引用，修改数据节和代码节中符号的引用，使得他们指向正确的运行时内存地址。&lt;/p&gt;

&lt;p&gt;处理目标文件的一些工具，如下：&lt;/p&gt;
&lt;p&gt;AR ：创建静态库，插入、删除、列出和提取成员。&lt;/p&gt;
&lt;p&gt;NM ：列出一个目标文件的符号表中定义的符号。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1047362/201901/1047362-20190126155133936-492865114.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1047362/201901/1047362-20190126155241474-77937923.png&quot; alt=&quot;&quot; width=&quot;551&quot; height=&quot;370&quot;/&gt;&lt;/p&gt;

&lt;p&gt;收藏：&lt;a href=&quot;https://wdxtub.com/2016/04/16/thin-csapp-4/&quot; target=&quot;_blank&quot;&gt;不周山之读薄 CSAPP&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考：《深入理解计算机系统》&lt;/p&gt;
</description>
<pubDate>Sat, 26 Jan 2019 07:52:00 +0000</pubDate>
<dc:creator>一盏淡酒、醉了夕阳</dc:creator>
<og:description>1.程序的编译过程 假设现在有如下两个c程序文件，sum.c内容如下： 主程序main.c的内容如下： 在linux上执行如下语句： 以main.c为例，程序首先调用C预处理器，将main.c翻译成一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/helloworldcode/p/10323657.html</dc:identifier>
</item>
<item>
<title>我的2018年--本命的一年 - 请叫我大苏</title>
<link>http://www.cnblogs.com/dasusu/p/10323640.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dasusu/p/10323640.html</guid>
<description>&lt;p&gt;马上要过年了，年底是稍微忙了点，趁着昨天刚过完年会，这周末抽空写写 2018 的总结。&lt;/p&gt;

&lt;p&gt;2018 年是我的本命年，都说本命年是比较衰的一年，我反而觉得 18 年是我运气很好的一年，不管是工作上还是生活上。那么，就开始来慢慢的回忆下吧~&lt;/p&gt;
&lt;p&gt;首先，先来看下去年写的 17 年的总结：&lt;/p&gt;
&lt;blockquote readability=&quot;37&quot;&gt;
&lt;p&gt;3 月 4 月偷偷离校满怀憧憬的跑去公司实习；&lt;/p&gt;
&lt;p&gt;5 月 6 月回校做毕设、写论文，享受最后的校园时光，同时喜欢上了每天跑 3 公里，因为有着一个腹肌梦；&lt;/p&gt;
&lt;p&gt;6 月底找了个基友，啥准备也没有就来了趟毕业旅行，跑到了人生中离开家最远的一次，爬了山，看了水，满足；&lt;/p&gt;
&lt;p&gt;7 月作为职场小菜鸟步入公司，开始打怪升级，同时找了几个同学一起合租，开始学做菜，每天一下班就想着赶回去练手做菜；&lt;/p&gt;
&lt;p&gt;8 月用第一次工资给老爸、老妈换了部手机，当然，找老姐资助了点，但功劳都是我的，哈哈哈；&lt;/p&gt;
&lt;p&gt;9 月用剩余的工资给自己买了很多健身器材，开始了自己的健身梦；&lt;/p&gt;
&lt;p&gt;10 月发现自己还是职场小菜鸟，经验条太长升级太慢，决定做做支线任务，每月至少写篇技术博客；&lt;/p&gt;
&lt;p&gt;10 月底写了第一篇源码分析博客，投给了郭神，过了！成就感瞬间充满，开心，又更有动力了；&lt;/p&gt;
&lt;p&gt;11 月发现小腹肌有了雏形，开心，工作也开始适应了，虽然还是小菜鸟，但多少可以为公司做点贡献了；&lt;/p&gt;
&lt;p&gt;11 月 12 月事情开始多了，做菜的事也放一边了，锻炼也放一边了，给自己找了个借口：天冷；&lt;/p&gt;
&lt;p&gt;12 月底想要总结一下，发现这一年来，喜欢的事很多，尝试的事也很多，但更多的都是没能坚持下去；&lt;/p&gt;
&lt;p&gt;18 年给自己说了句话：锻炼的事得重新拿起来，不能放，博客的事也不能放，得坚持；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为 17 年刚刚结束学生时代，正式进入职场，一切都是那么的新奇，对未来也都怀着大大的憧憬，也给自己的 18 年立了几个 flag：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;坚持写博客&lt;/li&gt;
&lt;li&gt;坚持健身&lt;/li&gt;
&lt;li&gt;学做菜、学游泳、学会玩&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;emmm，19 年也还是这几个 flag，因为 18 年没能将这些事坚持下去，可能坚持得比较好的就是写博客了。&lt;/p&gt;
&lt;p&gt;下面想从工作上、兴趣上、生活上、以及 18 年的遗憾这几点来回忆我的 2018：&lt;/p&gt;

&lt;p&gt;17 年下半年还可以说自己是刚毕业的小雏鸟，那么 18 年也就是雏鸟不得不长大的一年了。&lt;/p&gt;
&lt;p&gt;17 年时，一直是有个师傅带着我做项目，当时有不懂的、做不完的都有师傅顶着，所以工作上并没有太大的压力或者紧迫感。&lt;/p&gt;
&lt;p&gt;但 18 年时，师傅由于职业规划内部转岗了，我不得不将师傅负责的项目都接下来，这时候也才算是正在体验到工作的压力吧。&lt;/p&gt;
&lt;h3 id=&quot;第一次独立设计&quot;&gt;第一次独立设计&lt;/h3&gt;
&lt;p&gt;在初期，也就是 2 月 3 月，这时候也还好，因为师傅负责的项目还有另外一个同事协作开发，所以虽然师傅走了，但产品的需求迭代、线上 bug 排查等也都还是由另一位同事主导，我则仍旧倾向于协作打下手。&lt;/p&gt;
&lt;p&gt;但相比于 17 年刚进来时的改改 bug，改改模块的小功能而言，这个时候，我开始参与独立模块的设计与开发了。&lt;/p&gt;
&lt;p&gt;记得比较清楚的是，某个大迭代中，有一个全新的功能模块，leader 信任我，交给我来做。当时还是有点担心的，因为那时我还并不清楚这个功能该如何实现，所以很担心自己做不出来。&lt;/p&gt;
&lt;p&gt;但毕竟已经毕业半年了，也不能再老是让人罩着了，所以咬咬牙，自己去摸索，查资料、看源码、参考、借鉴别人的实现思路，然后跟老大汇报，老大也给出了一些建议，最后确定了实现方案后就开始写代码了。&lt;/p&gt;
&lt;p&gt;做了有两周左右，做出来后是特别开心的，但还是很担心会不会有哪些没注意到的问题，所以提测时跟测试小姐姐解释我的各种实现原理，哈哈哈，可怜测试的小姐姐硬是被我强制灌输了这么多原理性知识。&lt;/p&gt;
&lt;p&gt;后来，在提测阶段，leader review 了我写的所有代码，然后整理出了一份 word 文档记录了她对我写的代码的各种建议。&lt;/p&gt;
&lt;p&gt;蛮感激 leader 的，没有直说我写的代码烂，而是耐心的跟我说，如果这样设计、这样写会不会更好，我这么写是不是会有一些问题之类的，然后在 leader 建议下，我对代码做了改进，这个过程是真的学到了特别多。&lt;/p&gt;
&lt;p&gt;尤其是，写代码时，设计时，应该考虑哪些方面，以前根本没有想过这些，所以那时就觉得同事都好厉害，我也好幸运。&lt;/p&gt;
&lt;h3 id=&quot;第一次深入源码底层&quot;&gt;第一次深入源码底层&lt;/h3&gt;
&lt;p&gt;因为之前自己独立设计、负责的功能模块，突然被测出一个很严重的问题，因为这个功能重点就是动画，但在某个场景下，动画会特别卡顿，所以被要求必须解决这个问题。&lt;/p&gt;
&lt;p&gt;但是，对这个问题，我懵了，束手无策了，因为，这个现象是只有在特定设备、特定渠道中才出现的问题，也就是在其他设备都很正常，偏偏特定设备上出问题。&lt;/p&gt;
&lt;p&gt;从代码上根本看不出任何问题，而且在我自己的测试设备上也完全正常，为了定位具体原因，做了很多种猜想，也做了很多测试，但都得不到结果。&lt;/p&gt;
&lt;p&gt;在我一筹莫展时，老大来帮我了，他先理清了我实现的原理，后来就带着我去深入 Andorid 的动画还有屏幕刷新的底层源码，从源码上来排查、定位问题。&lt;/p&gt;
&lt;p&gt;也就是在这个时候，我学会了碰到疑难问题时，该如何从源码着手；学会了排查一个问题的能力；也学会了很多 Android Studio 的使用技巧，比如 Method Tracing 图的分析。&lt;/p&gt;
&lt;p&gt;在这个过程，我也学到了很多 Android 的源码实现原理，能力上也增长了很多，过后，我也将老大带着我深入源码梳理的这些知识写到博客上，也就是这篇：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/dasusu/p/8311324.html&quot;&gt;Android 屏幕刷新机制&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇投稿给了郭神的公众号，后来还被鸿神赞赏并转发朋友圈了，加上我发布到博客园和简书上，总的阅读量有小几万，我觉得干货还是有的。&lt;/p&gt;
&lt;p&gt;因为写了这篇源码梳理的文章，也引起了我写源码分析博客的兴趣，后续也在动画方面陆续写了几篇，也都投给了郭神的公众号。&lt;/p&gt;
&lt;p&gt;说回正事，因为有老大带着，最后定位到了问题后，也就有了相应的解决方案。然后，老大还让我把这次排查这个问题的过程，还有相关知识梳理出来，找个时间给大伙分享一下。&lt;/p&gt;
&lt;p&gt;也是因为这个经历，培养了我解决问题的思路和能力。也开启了我们小组的分享、学习氛围。&lt;/p&gt;
&lt;p&gt;现在每次碰到疑难问题，第一个想的就是定位，如何定位只是手段，可以利用搜索引擎，可以自己去研究原理，但只要能定位，那么也就能有相应的解决方案，所以一个问题，难的不是如何去解决，难的是是否能够准确定位。&lt;/p&gt;
&lt;p&gt;现在，如果我碰到疑难问题，自己解决不了，我也只是会让同事帮忙看看，他觉得问题的根源可能会是在哪，而不是直接寻求解决方案，因为我知道，难点在于定位，这样麻烦同事，也不会占用他太多时间和精力。&lt;/p&gt;
&lt;p&gt;同样的，如果有新人来请教我，我也不会直接给出解决方案，也不会直接跟他说问题根源在哪，而是尝试引导他，如何去定位到这个问题的根源，因为老大就是这么带我过来的，我自己觉得这样的方式会比直接帮他处理更有效。&lt;/p&gt;
&lt;p&gt;当然，后面也仍旧碰到过很多很奇葩的疑难问题，这种时候，我已经能够独立去深入源码排查、定位、分析问题了，可以让老大放心的把任务交给我了，比如：&lt;/p&gt;
&lt;p&gt;碰到过 so 文件加载异常的奇葩问题，在深入源码后，总结出了这篇：&lt;a href=&quot;https://www.cnblogs.com/dasusu/p/9810673.html&quot;&gt;Android 的 so 文件加载机制&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;碰到过 ftp 文件上传的超时处理的奇怪现象，也深入源码梳理出了这篇：&lt;a href=&quot;https://www.cnblogs.com/dasusu/p/10006899.html&quot;&gt;记录 FTPClient 超时处理的相关问题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;还有 ReyclerView 的优化问题，当然也梳理出了这篇满满干货的文章：&lt;a href=&quot;https://www.cnblogs.com/dasusu/p/7746946.html&quot;&gt;基于场景解析RecyclerView的回收复用机制原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当然，因为最初是独立负责动画模块，这方面问题是最多的，也梳理了很多动画源码相关的文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/dasusu/p/8287822.html&quot;&gt;View 动画 Animation 运行原理解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/dasusu/p/8595422.html&quot;&gt;属性动画 ValueAnimator 运行原理全解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/dasusu/p/8647702.html&quot;&gt;【Android】你知道还可以通过 View.animate() 来实现动画么&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;第一次主导项目迭代&quot;&gt;第一次主导项目迭代&lt;/h3&gt;
&lt;p&gt;之前说过，因为师傅内部转岗了，师傅的项目都交给另一个同事负责，后来这个同事也跳槽了，接触过这些项目的除了老大，就是师傅的徒弟我了，我不得不接下来。&lt;/p&gt;
&lt;p&gt;而凑巧，其中一个项目又刚好有一次为期一个月左右的大迭代，对项目最熟悉的也就是我了，能做的也就只有我了。&lt;/p&gt;
&lt;p&gt;而老大担心我自己一个人没办法做完，他参与到这个迭代中来帮我，另外又叫了一个对这个项目完全不熟悉的同事也来帮忙。&lt;/p&gt;
&lt;p&gt;现在想想，特别感激老大，因为老大原本是没必要参与迭代开发的，也感激另一个同事，临时被抽调来帮忙开发一个自己完全就不熟的项目。&lt;/p&gt;
&lt;p&gt;在这个月里，我天天加班，天天十点、十一点才回去，睡觉都在想该如何设计，周末被老妈强制叫回家时都将电脑带回去。&lt;/p&gt;
&lt;p&gt;但尽管这样，开发还是延期了，没能按时完成，因为这次的改动特别大，需求特别多，而当初虽然跟着师傅的时候有接触这个项目，但最多也就是改改小 bug，做做小功能，也没花时间去梳理过整个项目，所以其实，说句难听的，虽然我是最熟悉这个项目的，但也就那样。&lt;/p&gt;
&lt;p&gt;正是因为这次经历，让我明白了作为一个项目的主要负责人所要承担起的责任，该如何对待你的项目。以前有师傅带着，碰到我解决不了的问题时，就是丢给师傅，抱着的就是这种心态。&lt;/p&gt;
&lt;p&gt;但现在不行了，这个项目是你负责的，你解决不了，也没人可以让你丢了，你必须得解决，不得不解决。作为项目主要负责人和师傅的徒弟，对待同个项目是完全两种不一样的态度，观念。&lt;/p&gt;
&lt;p&gt;也正是因为这次经历，让我养成了很多好习惯，作为一个项目的主要负责人，这个项目就像你的孩子一样，你需要去了解他的一切。&lt;/p&gt;
&lt;p&gt;所以，现在，每次有同事提交代码时，我都会习惯性的过一下他提交的代码，一来了解这次提交了什么、改动了什么；二来，学习同事的设计。&lt;/p&gt;
&lt;p&gt;而且，现在对于一个项目而言，如果时间允许，我不会再局限于自己负责的模块了，或多或少也会去了解其他模块的代码。&lt;/p&gt;
&lt;p&gt;最后，也因为这一两个月的付出，老大帮我争取到了当季度的部门之星，特别开心，更有成就感也更有动力了。&lt;/p&gt;
&lt;h3 id=&quot;第一次写专利&quot;&gt;第一次写专利&lt;/h3&gt;
&lt;p&gt;因为部门有着一个专利指标，在 18 年后半年事情不是特别忙的时候，我们老大每周特意抽出一个下午的时间，来给我们讲如何写专利，如何挖掘专利，项目中哪些点可以去挖掘、可以去写。&lt;/p&gt;
&lt;p&gt;可能因为我大学时比较喜欢瞎写东西，我的文笔表达还算可以，老大将他的很多想法都跟我说，让我来执笔写。&lt;/p&gt;
&lt;p&gt;没让老大失望的是，基本上老大的想法，我都能很好的描述出来，写出来，一年下来跟老大合作得很愉快，我们两一起完成了多篇专利的输出，完美完成并超出预定的指标。&lt;/p&gt;
&lt;p&gt;也因此，我们小组被称为部门里的土豪组，因为我们将专利的一半奖金拿来当做小组经费，然后每周下午茶，经常出去嗨皮、玩桌游啦、密室逃脱啦、剧情杀啦等等。&lt;/p&gt;
&lt;p&gt;年底，我也因此有幸获评到了公司的年度杰出个人专利奖。感谢老大~&lt;/p&gt;
&lt;h3 id=&quot;第一次讲课&quot;&gt;第一次讲课&lt;/h3&gt;
&lt;p&gt;18 年后半年，事情不是特别忙，老大为此安排了每周的分享会，想要以为来扩展大伙的技术栈。&lt;/p&gt;
&lt;p&gt;为了产品线的后续需要，老大带头学习前端、带我们入门，后来可能是想锻炼我们，又让我们小组内的成员也来分享自己的学习成果。&lt;/p&gt;
&lt;p&gt;而我学习时习惯记笔记，曾经学 Android 期间记了两三百页的笔记，这次学习前端，同样记了一大堆笔记。&lt;/p&gt;
&lt;p&gt;然后老大让我来给大伙上课，带领大伙入门前端。&lt;/p&gt;
&lt;p&gt;从这个时候开始，我们小组基本上每周都会有一次分享会，有时是由我来分享，如果事情太多忙不过来，那么就由另一个同事来分享，或者老大亲自分享来给大伙上课。&lt;/p&gt;
&lt;p&gt;如果事情很多，可能一个月就一次，不多时就保持一周一次，总之就是持续不断的分享会。&lt;/p&gt;
&lt;p&gt;而我会将每次分享的课程知识点都当做笔记记录下来，记录在一份 word 文档中，截止目前，已经有三百多页了，内容涉及 HTML，CSS，JavaScript，TypeScript 等等，有些是基础的概念知识，但也有很多涉及原理性知识。&lt;/p&gt;
&lt;p&gt;后来，抽了时间，将部分内容梳理到博客上，写成一个系列：&lt;a href=&quot;https://www.cnblogs.com/dasusu/category/1330072.html&quot;&gt;前端入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个系列，目前已经发表了 25 篇博客了。&lt;/p&gt;
&lt;p&gt;年底时，也因为我们小组的持续不断的分享会，我和老大两人都被评选为年度优秀讲师。&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;我觉得我在工作上，一直都很幸运。&lt;/p&gt;
&lt;p&gt;首先是毕业时，可以直接从事我所感兴趣的 Android 开发，然后所在的小组，同事人都很好，教了我很多东西。&lt;/p&gt;
&lt;p&gt;有人教我该如何设计代码，该如何去思考，如何去写代码、改代码；&lt;/p&gt;
&lt;p&gt;有人教我遇到疑难问题时，如何去排查定位、如何去阅读源码；&lt;/p&gt;
&lt;p&gt;我的老大，人也特别好，带着我成长了很多。&lt;/p&gt;
&lt;p&gt;大学时，就有想过，等自己在 Android 方面学精了，想试着去扩展自己的技术栈，学学前端，学学后台。很幸运的是，由于产品线调整，在公司内就可以有这样的机会。&lt;/p&gt;
&lt;p&gt;虽然目前我的 Android 并不是特别牛逼，但两个方向我都会持续花时间去学习，总之，干着开心，比什么都好。&lt;/p&gt;

&lt;p&gt;我兴趣其实不多，就喜欢写写博客，投稿给大神，然后看着大伙的评论，暗暗自喜；&lt;/p&gt;
&lt;p&gt;或者健健身，看着那逐渐成型的小腹肌，深深自恋，虽然因为喜欢喝点小酒，有了点小肚子；&lt;/p&gt;
&lt;p&gt;或者阳台上，晒着太阳看书，我特别喜欢看东野圭吾的小说，巨喜欢；&lt;/p&gt;
&lt;p&gt;再或者，叫上两三好友，出去吃大餐，厦门有家蛙小侠的店，巨好吃，我是他家的忠实粉丝；&lt;/p&gt;
&lt;p&gt;再或者，约上四五好友，买好食材，去他家，我们自己下厨；&lt;/p&gt;
&lt;p&gt;再或者，去溜冰？我是很喜欢溜冰，但我朋友都不喜欢，我又不喜欢自己一个人去，所以虽然喜欢，但 18 年就去了一次；&lt;/p&gt;
&lt;p&gt;还有，学游泳，因为听说游泳是最好的健身方式，但一直没机会；&lt;/p&gt;
&lt;p&gt;然后，没了。&lt;/p&gt;
&lt;p&gt;哦，还有，喝点小酒，我不喜欢喝啤酒，因为它让我有了小肚子，也不喜欢喝红酒，因为涩，我就喜欢白酒，钟爱小糊涂神，而且我不爱喝多，就单纯喜欢喝点儿，然后跟朋友吹吹牛逼，聊聊天。&lt;/p&gt;
&lt;p&gt;想想我的 18 年，健身坚持到 4 月份左右吧，后面搬家了，搬到民房去，就不想健身了，所以就荒废到现在，因为又搬家了，搬到挺不错的环境，现在 19 年又恢复我的健身了。&lt;/p&gt;
&lt;p&gt;然后是做菜，刚毕业时特别想做菜，特别想学，也做了差不多八九个月吧，18 年就渐渐懒了，尤其搬家后就更没做过了，19 年，几个小伙伴又搬到一起了，希望可以继续捡起来。&lt;/p&gt;
&lt;p&gt;最后讲讲博客，18 年我唯一能拿得出来的应该就是博客了，我大概从大四开始写，上学期间写得不多，毕业后到现在，不知不觉中，已经写了 100 来篇博客了。&lt;/p&gt;
&lt;p&gt;当然，里面并不是全部都是技术博客，有些是我发牢骚，瞎扯的，就像这篇一样。&lt;/p&gt;
&lt;p&gt;但技术博客还是占大头，这是让我蛮有成就感的一件事。&lt;/p&gt;
&lt;p&gt;18 年大概写了五十几篇吧，我没细数，一般是当我事情不忙时，抽空在晚上或周末写的，事情忙时，可能就顾不上了，所以有些文章会间隔一两个月。&lt;/p&gt;
&lt;p&gt;平均下来，每两三周一篇吧，质量上我觉得应该还可以把。&lt;/p&gt;
&lt;p&gt;这些博客里，我投给了郭神很多篇，都过了，很开心，也投稿给鸿神过，现在鸿神貌似记得大苏这号人了，哈哈哈，我不清楚，也许有点映像吧，因为加了鸿神微信后，我就经常隔断时间偷偷去鸿神网站打赏，好让他记住我，哈哈哈，我是个心机 boy。&lt;/p&gt;
&lt;p&gt;最后，我觉得 18 年，我转变最多的是，我对于知识付费的观念。&lt;/p&gt;
&lt;p&gt;因为我接入了帅张和主席的星球，主席（任玉刚）的星球是想学点技术，而帅张的星球是想提高认知。因为帅张说过，同一个层次的圈子里，认知都差不了多少，那么是没有人会来给你讲一些你不知道，或者你这个层次无法理解的观念的，也无法给你一个准确的建议的。&lt;/p&gt;
&lt;p&gt;加入帅张星球后，帅张经常在星球里会给我们讲很多事，给很多人的选择提建议，在星球里还是收获蛮多的吧，至少我现在不排斥知识付费了，看见好的文章就会想打赏，因为我觉得这篇文章教会了我一些，那么自然又打赏它的理由；&lt;/p&gt;
&lt;p&gt;也懂得了要延迟满足的思想，也学会了要投资给自己，投资自己是一件不会吃亏的事，所以现在舍得给自己花钱了。&lt;/p&gt;

&lt;p&gt;18 年生活没有 17 年精彩、有趣。&lt;/p&gt;
&lt;p&gt;因为 17 年刚毕业，几个小伙子合租了套房，天天聚一起、研究做菜、开开黑，比较热闹；&lt;/p&gt;
&lt;p&gt;18 年因为房子到期，大伙各自搬走了，我嫌原本地方离公司太远，来回麻烦，搬到了离公司走路就十几分钟的民房中。&lt;/p&gt;
&lt;p&gt;因为是民房，环境自然不怎么好，而宿舍我基本也就晚上回去睡觉用而已，大部分时间都待在公司里，也因为这样，除了博客外，其他的都没有时间、也没有场所去坚持下去了。&lt;/p&gt;
&lt;p&gt;所以，好久没自己做菜了，怀念我的糖糖排骨（因为我讨厌醋，做糖醋排骨时故意不加醋），怀念西瓜的招牌碎鸡腿，怀念飞哥的炒豆角，怀念兴姐的蛋糕。&lt;/p&gt;
&lt;p&gt;17 年健身了半年，18 年因为搬家后，就荒废掉了，然后又天天待公司，又离公司近，根本没啥运动。是的，我现在已经胖了一圈了。&lt;/p&gt;
&lt;p&gt;所以，19 年，我要减肥，减肥！&lt;/p&gt;
&lt;p&gt;虽然 18 年，几个小伙伴并没有住在一起了，不过我们还是经常在周末会聚在一起。因为有两个小伙伴是去住的比较豪华，大空间的单间公寓。&lt;/p&gt;
&lt;p&gt;所以，周末时，尤其是冬天时，我跟飞哥会去沃尔玛，买上一车的火锅料，然后去西瓜和兴姐的住所，一起吃火锅，吃完一起五黑。&lt;/p&gt;
&lt;p&gt;虽然来回很累，要做好久的公交。&lt;/p&gt;
&lt;p&gt;但现在， 19 年，我们几个小伙伴又住到一起去了，虽然不是合租，但都在同一个小区里，同一栋楼的不同楼层里，又可以一起玩耍了。&lt;/p&gt;
&lt;p&gt;这次搬家，新的环境还不错，四十几平大房间，还有个阳台，所以我自己买了沙发，买了电视，买了书架，就为了回去后可以躺着看电视，阳台晒着太阳看书。&lt;/p&gt;
&lt;p&gt;19 年，我要开始我的养老的、惬意的生活~&lt;/p&gt;

&lt;p&gt;18 年有很多遗憾，遗憾很多事没能坚持下去，遗憾我胖了。&lt;/p&gt;
&lt;p&gt;最遗憾的是，女神有主了。&lt;/p&gt;
&lt;p&gt;哎，其实，18 年我基本把所有的时间都花在公司里了，是的，所以活该我单身。&lt;/p&gt;
&lt;p&gt;19 年想多花点时间给自己了，我想遇到她了，不然过年都不知道该怎么回家，我觉得我要扛不住我爸妈的催了。&lt;/p&gt;

&lt;p&gt;19 年，我还想立很多 flag，还想做很多事，但我不想一个人做。&lt;/p&gt;
&lt;p&gt;想带着她，来次随性的旅行，走走停停、看看人群、看看风景、吹吹海风~&lt;/p&gt;
&lt;p&gt;想带着她，去厦门吃遍美食广场，胖就胖了，反正那时已经有她了~&lt;/p&gt;
&lt;p&gt;想带着她，到处走，她来拍照，我来带她~&lt;/p&gt;
&lt;p&gt;想买一堆小说，如果她喜欢，阳台晒着太阳看书，惬意~&lt;/p&gt;
&lt;p&gt;希望，这不是个梦&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;大家好，我是 dasu，欢迎关注我的公众号（dasuAndroidTv），除了不定时分享一些原创的技术文章外，有时间还会文艺文艺下，写些小感触，欢迎关注哈~&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-d7190704b160d280.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dasuAndroidTv2.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 26 Jan 2019 07:44:00 +0000</pubDate>
<dc:creator>请叫我大苏</dc:creator>
<og:description>马上要过年了，年底是稍微忙了点，趁着昨天刚过完年会，这周末抽空写写 2018 的总结。 本命年 2018 年是我的本命年，都说本命年是比较衰的一年，我反而觉得 18 年是我运气很好的一年，不管是工作上</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dasusu/p/10323640.html</dc:identifier>
</item>
<item>
<title>pymysql 解决 sql 注入问题 - 暮良文王</title>
<link>http://www.cnblogs.com/liangmingshen/p/10323535.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liangmingshen/p/10323535.html</guid>
<description>&lt;p&gt;&lt;span&gt;SQL 注入是非常常见的一种网络攻击方式，主要是通过参数来让 mysql 执行 sql 语句时进行预期之外的操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;即：因为传入的参数改变SQL的语义，变成了其他命令，从而操作了数据库。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;产生原因：SQL语句使用了动态拼接的方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如，下面这段代码通过获取用户信息来校验用户权限：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pymysql

sql &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;SELECT count(*) as count FROM user WHERE id = &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + str(input[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]) + &lt;span&gt;'&lt;/span&gt;&lt;span&gt; AND password = &quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + input[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
cursor &lt;/span&gt;=&lt;span&gt; dbclient.cursor(pymysql.cursors.DictCursor)
cursor.execute(sql)
count &lt;/span&gt;=&lt;span&gt; cursor.fetchone()
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; count &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; None &lt;span&gt;and&lt;/span&gt; count[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;count&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] &amp;gt;&lt;span&gt; 0:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;登陆成功&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;但是，如果传入参数是：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&lt;span&gt;input['id'] = '2 or 1=1'
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;你会发现，用户能够直接登录到系统中，因为&lt;strong&gt;原本 sql 语句的判断条件被 or 短路成为了永远正确的语句&lt;/strong&gt;。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这里仅仅是举一个例子，事实上，sql 注入的方式还有很多种，这里不深入介绍了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;总之，只要是通过用户输入数据来拼接 sql 语句，就必须在第一时间考虑如何避免 SQL 注入问题。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;那么，如何防止 SQL 注入呢？&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;pymysql 的&lt;span&gt; execute 支持参数化 sql&lt;/span&gt;，&lt;span&gt;通过占位符 %s 配合参数就可以实现 sql 注入问题的避免。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pymysql

sql &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;SELECT count(*) as count FROM user WHERE id = %s AND password = %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
valus &lt;/span&gt;= [input[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], input[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]]
cursor &lt;/span&gt;=&lt;span&gt; dbclient.cursor(pymysql.cursors.DictCursor)
cursor.execute(sql, values)
count &lt;/span&gt;=&lt;span&gt; cursor.fetchone()
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; count &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; None &lt;span&gt;and&lt;/span&gt; count[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;count&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] &amp;gt;&lt;span&gt; 0:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;登陆成功&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;这样参数化的方式，让 mysql 通过预处理的方式避免了 sql 注入的存在。&lt;br/&gt;需要注意的是，不要因为参数是其他类型而换掉 %s，&lt;span&gt;pymysql 的占位符并不是 python 的通用占位符。&lt;/span&gt;&lt;br/&gt;同时，也不要因为参数是 string 就在 %s 两边加引号，mysql 会自动去处理。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;数据库存储过程是 mysql 的一种高级用法，但是一般来说，并不建议使用数据库的存储过程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;主要原因是：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt; 存储过程的语法与普通 SQL 语句语法相差太大，增加维护成本&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt; 存储过程在各数据库间不通用且差别较大，给数据库的移植和扩展带来困难&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt; 编写困难，数据库脚本语言使用起来还是很不方便的，包括很多数据结构的缺失，让很多事情做起来很困难&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt; 调试困难，虽然有一些功能强大的 IDE 提供了数据库存储过程的调试功能，但是通常你需要同时在数据库层面上和业务中同时进行调试，两处调试极为不便&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt; 业务耦合，编写存储过程通常是需要在其中放入部分业务逻辑，这使得业务分散在数据层，业务层与数据层的耦合对于项目维护和扩展都会带来极大地不便。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;但是，虽然不建议使用存储过程，但是毕竟可以依赖他&lt;strong&gt;&lt;em&gt;实现各种跨语言的 sql 注入预防&lt;/em&gt;&lt;/strong&gt;，在复杂的场景下还是有其使用价值的。（以后需要用再去详细学，这里&lt;em&gt;&lt;span&gt;只作简单介绍&lt;/span&gt;&lt;/em&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3.1. 存储过程编写&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;delimiter \DROP PROCEDURE IF EXISTS proc_sql \CREATE PROCEDURE proc_sql (
    &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; nid1 INT,
    &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; nid2 INT,
    &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; callsql VARCHAR(255&lt;span&gt;)
)
BEGIN
    set @nid1 &lt;/span&gt;=&lt;span&gt; nid1;
    set @nid2 &lt;/span&gt;=&lt;span&gt; nid2;
    set @callsql &lt;/span&gt;=&lt;span&gt; callsql;
    PREPARE myprod FROM @callsql;
    &lt;/span&gt;--   PREPARE prod FROM &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from tb2 where nid&amp;gt;? and nid&amp;lt;?&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;  传入的值为字符串，？为占位符
    &lt;/span&gt;--&lt;span&gt;   用@p1，和@p2填充占位符
    EXECUTE myprod USING @nid1,@nid2;
    DEALLOCATE prepare myprod;

END\delimiter ;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;3.2. pymsql 中调用&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pymysql

cursor &lt;/span&gt;=&lt;span&gt; conn.cursor()
mysql&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SELECT * FROM user where nid &amp;gt; ? and nid &amp;lt; ?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
cursor.callproc(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proc_sql&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, args=(11, 15&lt;span&gt;, mysql))
rows &lt;/span&gt;=&lt;span&gt; cursor.fetchall()
conn.commit()&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 26 Jan 2019 07:15:00 +0000</pubDate>
<dc:creator>暮良文王</dc:creator>
<og:description>1. SQL 注入 SQL 注入是非常常见的一种网络攻击方式，主要是通过参数来让 mysql 执行 sql 语句时进行预期之外的操</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liangmingshen/p/10323535.html</dc:identifier>
</item>
<item>
<title>『玩具装箱TOY 斜率优化DP』 - Parsnip</title>
<link>http://www.cnblogs.com/Parsnip/p/10323508.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Parsnip/p/10323508.html</guid>
<description>&lt;p&gt;&lt;span&gt;&amp;lt;更新提示&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;第一次更新&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&amp;lt;正文&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;玩具装箱toyhnoi2008&quot;&gt;&lt;span&gt;玩具装箱TOY(HNOI2008)&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;description&quot;&gt;&lt;span&gt;Description&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;P教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。P教授有编号为 &lt;span class=&quot;math inline&quot;&gt;\(1. . .N\)&lt;/span&gt; 的 &lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt; 件玩具，第 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 件玩具经过压缩后变成一维长度为 &lt;span class=&quot;math inline&quot;&gt;\(C_i\)&lt;/span&gt;​ .为了方便整理，&lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt;教授要求在一个一维容器中的玩具编号是连续的。同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物，形式地说如果将第 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 件玩具到第 &lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt; 个玩具放到一个容器中，那么容器的长度将为 &lt;span class=&quot;math inline&quot;&gt;\(x=j-i+\sum_{k=i}^jC_k\)&lt;/span&gt;​ 制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; ,其制作费用为 &lt;span class=&quot;math inline&quot;&gt;\((x-L)^2\)&lt;/span&gt; .其中 &lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt; 是一个常量。&lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt;教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过 &lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt; 。但他希望费用最小.&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;input-format&quot;&gt;&lt;span&gt;Input Format&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;第一行输入两个整数&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt;.接下来N行输入&lt;span class=&quot;math inline&quot;&gt;\(C_i\)&lt;/span&gt;.&lt;span class=&quot;math inline&quot;&gt;\(1&amp;lt;=N&amp;lt;=50000,1&amp;lt;=L,C_i&amp;lt;=10^7\)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;output-format&quot;&gt;&lt;span&gt;Output Format&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;输出最小费用&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;sample-input&quot;&gt;&lt;span&gt;Sample Input&lt;/span&gt;&lt;/h3&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code&gt;5 4
3
4
2
1
4&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;sample-output&quot;&gt;&lt;span&gt;Sample Output&lt;/span&gt;&lt;/h3&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code&gt;1&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;解析&quot;&gt;&lt;span&gt;解析&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;简单分析题目大意：给定一个数列，可以将其分为若干个连续的子段，将区间&lt;span class=&quot;math inline&quot;&gt;\([i,j]\)&lt;/span&gt;分为一段的花费为&lt;span class=&quot;math inline&quot;&gt;\((j-i+\sum_{k=i}^jC_k-L)^2\)&lt;/span&gt;，求最小划分总花费。&lt;br/&gt;由于没有需要划分多少段的限制，可以直接简单地设置状态：f[i]代表完成了前i个数的划分的最小花费和。&lt;br/&gt;区间的花费是利用前缀和可以O(1)求解的，那么状态转移方程就是&lt;span class=&quot;math display&quot;&gt;\[f_i=min\{f_j+(i-(j+1)+sum_i-sum_j-L)^2\}\]&lt;/span&gt;&lt;br/&gt;暴力思路：&lt;span class=&quot;math inline&quot;&gt;\(O(n^2)\)&lt;/span&gt;枚举&lt;span class=&quot;math inline&quot;&gt;\(i,j\)&lt;/span&gt;求解。&lt;br/&gt;但是&lt;span class=&quot;math inline&quot;&gt;\(50000\)&lt;/span&gt;的数据&lt;span class=&quot;math inline&quot;&gt;\(O(n^2)\)&lt;/span&gt;肯定不行啊，我们考虑优化这个dp。&lt;br/&gt;先化简括号内花费内容：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ (i-(j+1)+sum_i-sum_j-L)^2 \\=(i-j-1+sum_i-sum_j-L)^2 \\=((i+sum_i)+(-L-1-j-sum_j))^2 \\设a_k=(k+sum_k),b_k=(a_k+L+1) \\=(a_i-b_j)^2 \]&lt;/span&gt;&lt;br/&gt;代回原式：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ f_i=min\{f_j+(a_i-b_j)^2\} \]&lt;/span&gt;&lt;br/&gt;假设我们已经找到了最优的&lt;span class=&quot;math inline&quot;&gt;\(f_j\)&lt;/span&gt;，那么：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ f_i=f_j+(a_i-b_j)^2 \\⇒f_i=f_j+a_i^2-2a_ib_j+b_j^2 \\⇒f_j+b_j^2=2a_ib_j+(f_i-a_i^2) \]&lt;/span&gt;&lt;br/&gt;(将只与i有关的项和只与j有关的项分别整理)&lt;br/&gt;这个时候我们发现式子中有一项是即和&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;有关有和&lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt;有关的，然后就可以做一些神奇的优化了。&lt;br/&gt;我们视&lt;span class=&quot;math inline&quot;&gt;\(f_j+b_j^2\)&lt;/span&gt;为&lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(b_j\)&lt;/span&gt;为&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(2a_i\)&lt;/span&gt;为&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\((f_i+a_i^2)\)&lt;/span&gt;为&lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt;，那么我们就可以把它当做一个一次函数的的表达式&lt;span class=&quot;math inline&quot;&gt;\(y=kx+b\)&lt;/span&gt;。而且这个一次函数需满足：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;1.过定点&lt;span class=&quot;math inline&quot;&gt;\((b_j,f_j+b_j^2)\)&lt;/span&gt;，由于这个点只和&lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt;有关，称其为&lt;span class=&quot;math inline&quot;&gt;\(P_j\)&lt;/span&gt;&lt;br/&gt;2.其斜率为&lt;span class=&quot;math inline&quot;&gt;\(2a_i\)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;这时候，我们需要重新定义&lt;span class=&quot;math inline&quot;&gt;\(f_i\)&lt;/span&gt;的含义：&lt;strong&gt;满足两个要求的一次函数的截距&lt;span class=&quot;math inline&quot;&gt;\((b)\)&lt;/span&gt;加上&lt;span class=&quot;math inline&quot;&gt;\(a_i^2\)&lt;/span&gt;&lt;/strong&gt;。&lt;br/&gt;由于&lt;span class=&quot;math inline&quot;&gt;\(a_i^2\)&lt;/span&gt;的值是确定的，我们需要求最小的&lt;span class=&quot;math inline&quot;&gt;\(f_i\)&lt;/span&gt;，即求做小的一次函数的截距。&lt;br/&gt;我们将满足斜率为&lt;span class=&quot;math inline&quot;&gt;\(2a_i\)&lt;/span&gt;的直线以及点&lt;span class=&quot;math inline&quot;&gt;\(P_1,P_2,...,P_j\)&lt;/span&gt;描述在图中:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://i.loli.net/2019/01/26/5c4befee945a9.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;直线自下向上移动，只要它过任何一个点&lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt;，它就成为了符合要求的直线。&lt;br/&gt;我们要求截距最小，显然，当它自下向上移动过的第一个点&lt;span class=&quot;math inline&quot;&gt;\(P_j\)&lt;/span&gt;时，截距最小。如图，此时能取得截距最小的点是&lt;span class=&quot;math inline&quot;&gt;\(P_2\)&lt;/span&gt;。那么由上可知，&lt;span class=&quot;math inline&quot;&gt;\(j=2\)&lt;/span&gt;时，一次函数的截距最小，更新得到的&lt;span class=&quot;math inline&quot;&gt;\(f_i\)&lt;/span&gt;也是最小的。&lt;br/&gt;所以，我们的目标就转变为了找到一次函数能够第一个“碰到”的点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://i.loli.net/2019/01/26/5c4bf36061d9b.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;观察上图，我们将最有可能与直线先“碰到”的点(最外围的点)两两相连，发现：&lt;strong&gt;它们近似的构成了一个下凸壳的形状，两两相连的线段所在的直线的斜率依次递增&lt;/strong&gt;。&lt;br/&gt;此时我们发现了一个很好的性质，我们的目标直线第一个过的点最优点&lt;span class=&quot;math inline&quot;&gt;\(P_j\)&lt;/span&gt;满足：&lt;strong&gt;&lt;span class=&quot;math inline&quot;&gt;\(P_j,P_{j+1}\)&lt;/span&gt;所在直线是斜率大于目标直线斜率的第一条直线&lt;/strong&gt;。(&lt;span class=&quot;math inline&quot;&gt;\(P_2,P_3\)&lt;/span&gt;构成的直线的斜率大于图中直线的斜率，但&lt;span class=&quot;math inline&quot;&gt;\(P_1,P_2\)&lt;/span&gt;构成的直线的斜率小于图中直线的斜率，所以&lt;span class=&quot;math inline&quot;&gt;\(P_2\)&lt;/span&gt;为最优点)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么这就成为了我们的突破口了：由于构成下凸壳直线满足斜率单调递增，我们用单调队列维护这些&lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt;点。由于随着i的增加，&lt;span class=&quot;math inline&quot;&gt;\(a_i\)&lt;/span&gt;也是单调递增的，这就应和了单调队列的操作。&lt;br/&gt;对于每一个&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;，我们让斜率小于&lt;span class=&quot;math inline&quot;&gt;\(2a_i\)&lt;/span&gt;的单调队列中的直线所对应的点出队(它小于当前的&lt;span class=&quot;math inline&quot;&gt;\(2a_i\)&lt;/span&gt;，由于&lt;span class=&quot;math inline&quot;&gt;\(a_i\)&lt;/span&gt;单调递增，它也一定小于以后的&lt;span class=&quot;math inline&quot;&gt;\(2a_i\)&lt;/span&gt;，所以这些点将会是一直无用的，可以直接出队)，直到找到第一条斜率大于&lt;span class=&quot;math inline&quot;&gt;\(2a_i\)&lt;/span&gt;的直线，此时，队头的点的编号j即为最优决策。我们直接利用该决策转移。&lt;br/&gt;完成转移以后，新的点&lt;span class=&quot;math inline&quot;&gt;\(P_i\)&lt;/span&gt;也需要加入队列里，此时，我们还要维护一个操作：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://i.loli.net/2019/01/26/5c4bfbda2c068.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当&lt;span class=&quot;math inline&quot;&gt;\(P_i\)&lt;/span&gt;(图中的&lt;span class=&quot;math inline&quot;&gt;\(P_7\)&lt;/span&gt;)加入后，我们发现，原来的&lt;span class=&quot;math inline&quot;&gt;\(P_4,P_3\)&lt;/span&gt;构成的直线的斜率大于&lt;span class=&quot;math inline&quot;&gt;\(P_3\)&lt;/span&gt;和新的&lt;span class=&quot;math inline&quot;&gt;\(P_4\)&lt;/span&gt;构成的斜率，这样，&lt;span class=&quot;math inline&quot;&gt;\(P_4\)&lt;/span&gt;就到了内部，新的下凸壳由&lt;span class=&quot;math inline&quot;&gt;\(P_1,P_2,P_3,P_7\)&lt;/span&gt;构成，我们需要让&lt;span class=&quot;math inline&quot;&gt;\(P_4\)&lt;/span&gt;出队。&lt;br/&gt;即当&lt;span class=&quot;math inline&quot;&gt;\(slope(q[tail],q[tail-1])&amp;gt;slope(q[tail-1],i)\)&lt;/span&gt;(&lt;span class=&quot;math inline&quot;&gt;\(solpe\)&lt;/span&gt;代表斜率函数)时，队尾出队。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;事实上，我们在不断维护一个下凸壳的形状，由于单调队列一共会进出至多N个点，所以，这样实现转移的时间复杂度是&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;的，我们将此种优化方法称为斜率优化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;math inline&quot;&gt;\(Code:\)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;span&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N=50000+80;
long long f[N],q[N],sum[N],toy[N],n,L,head,tail;
inline long long a(long long k){return sum[k]+k;}
inline long long b(long long k){return a(k)+L+1;}
inline long long x(long long k){return b(k);}
inline long long y(long long k){return f[k]+b(k)*b(k);}
inline double slope(long long p,long long q){return ((y(p)-y(q))*1.0)/((x(p)-x(q))*1.0);}
int main(void)
{
    freopen(&quot;toy.in&quot;,&quot;r&quot;,stdin);
    freopen(&quot;toy.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%lld%lld&quot;,&amp;amp;n,&amp;amp;L);
    for(int i=1;i&amp;lt;=n;i++)
    {
        scanf(&quot;%lld&quot;,&amp;amp;toy[i]);
        sum[i]=sum[i-1]+toy[i];
    }
    for(int i=1;i&amp;lt;=n;i++)
    {
        while(head&amp;lt;tail&amp;amp;&amp;amp;slope(q[head],q[head+1])&amp;lt;2*a(i))head++;
        f[i]=f[q[head]]+(a(i)-b(q[head]))*(a(i)-b(q[head]));
        while(head&amp;lt;tail&amp;amp;&amp;amp;slope(q[tail],q[tail-1])&amp;gt;slope(q[tail-1],i))tail--;
        q[++tail]=i;
    }
    printf(&quot;%lld\n&quot;,f[n]);
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&amp;lt;后记&amp;gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 26 Jan 2019 07:05:00 +0000</pubDate>
<dc:creator>Parsnip</dc:creator>
<og:description>玩具装箱TOY(HNOI2008) Description P教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Parsnip/p/10323508.html</dc:identifier>
</item>
<item>
<title>如何开发中后台项目 - wolfSoul</title>
<link>http://www.cnblogs.com/yuqing6/p/10323454.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuqing6/p/10323454.html</guid>
<description>&lt;p&gt;工作中的你，是不是手上做着后台系统项目，应对着做不完的需求，觉得做后台系统是个没有技术含量的活，技术没法提升，这么想或许你就错了，如果能做以到以下几点，不仅可以提高你的开发效率，还能让你在组件抽象能力，项目架构能力等方面有很大提高，更能帮助你站在一个全局的高度思考问题，废话不多说，我们看看到底应该怎样做中后台项目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一. 通用组件库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，如果团队的中后台项目不止一个，那么多个项目中一定有很多相同或相似的交互和功能，于是乎，搭建一个属于自己团队的组件库就显得很有必要了。&lt;/p&gt;
&lt;p&gt;以一个VUE项目为例，我们开发一个项目，其实就是在开发一个个的组件。而这些组件可以如下这样分类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2FMs2Kmmepgb0PRGaVwQcu2TsMxOxibSCqibARupicC67Z03ee5zJOhlvoMsOJSNwVQHqdia2MyaDGL8LnNAcvia8fw/640?wx_fmt=png&quot; alt=&quot;&quot; data-backh=&quot;202&quot; data-backw=&quot;556&quot; data-before-oversubscription-url=&quot;https://mmbiz.qpic.cn/mmbiz_png/2FMs2Kmmepgb0PRGaVwQcu2TsMxOxibSCqibARupicC67Z03ee5zJOhlvoMsOJSNwVQHqdia2MyaDGL8LnNAcvia8fw/0?wx_fmt=png&quot; data-copyright=&quot;0&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;556&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;216&quot; data-ratio=&quot;0.36270491803278687&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;976&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先，非通用的组件，在各自的项目中去完成。&lt;/p&gt;
&lt;p&gt;而通用组件，可以根据是否包含业务，分为强业务的组件和无业务组件。&lt;/p&gt;
&lt;p&gt;其中非业务组件，已经有很多优秀的开源库，像element，iView，我们可以拿来直接使用。有时候开源的组件无法满足我们的需要，就需要自己造轮子。&lt;/p&gt;
&lt;p&gt;其中强业务组件又可以按照是否将与服务端的数据交互部分封装在组件内部，分为纯前端组件和通用服务组件。比如获取省市区，就可以封装成通用服务组件，不需要每个项目再去重复开发，前后端同学都能节省时间。&lt;/p&gt;
&lt;p&gt;哪些是需要抽象出组件的呢？这需要在工作中去发现和挖掘，当评审完一个需求时，要思考是否有之前做过的相同的形态或交互，是否有可以通用的部分能够抽像，这样思考久了，就能合理快速的对一个复杂项目进行模块划分。在中后台系统中，能够抽离出来通用的组件有很多，下面以一个最常见的列表页来分析下。&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2FMs2Kmmepgb0PRGaVwQcu2TsMxOxibSCHvGPH3SIVX3JpibnnO6cykRicqAnQfFdf8FZzUH03IDic6XRAukhVYRgw/640?wx_fmt=png&quot; alt=&quot;&quot; data-backh=&quot;427&quot; data-backw=&quot;556&quot; data-before-oversubscription-url=&quot;https://mmbiz.qpic.cn/mmbiz_png/2FMs2Kmmepgb0PRGaVwQcu2TsMxOxibSCHvGPH3SIVX3JpibnnO6cykRicqAnQfFdf8FZzUH03IDic6XRAukhVYRgw/0?wx_fmt=png&quot; data-copyright=&quot;0&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;556&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;290&quot; data-ratio=&quot;0.7672619047619048&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1680&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        可以先思考几分钟再继续阅读下面内容，如果你来开发，会抽象出哪些组件。&lt;/p&gt;
&lt;p&gt;下面把页面分为3部分（以下开源库以element ui为例）&lt;/p&gt;
&lt;p&gt;第一部分：查询表单部分&lt;/p&gt;
&lt;p&gt;开源库提供的组件：Input 输入框，Button 按钮 ， Select 选择器， DateTimePicker日期时间选择器。&lt;/p&gt;
&lt;p&gt;需要开发的组件&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;区间查询，我们可以抽象出一个无业务通用组件 Range&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;城市选择，可以将和服务端的数据交互封装到组件内，抽象出一个通用服务组件 CitySelect，供所有项目直接使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打印组件 Print&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;将整个查询表单部分抽象成组件 Search，组件支持更多查询交互，重置交互，具体查询条件可以通过slot传入。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第二部分: 表格&lt;/p&gt;
&lt;p&gt;开源库提供的组件：Table 表格&lt;/p&gt;
&lt;p&gt;需要开发的组件&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;脱敏操作，点击查看显示明文，可以抽象出通用服务组件 Encrypt。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;查看更多的交互可以抽象出组件 MoreOption&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第三部分：分页&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;-1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;分页组件 Pagnination, 开源组件库提供。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;除了这些，还可以把上面三部分看成一个整体，来抽象出一个页面级别的组件，这个组件由3个组件组合而成： Search 查询，Table 表格，分页 Pagination组成，可以通过配置来控制是否需要查询和分页，来适应更多的业务场景。&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2FMs2Kmmepgb0PRGaVwQcu2TsMxOxibSCxj7llBptmibe0xY9VibtgB0e777USIVmvvDeRRoGAHD7ySaxFbia4vL6A/640?wx_fmt=png&quot; alt=&quot;&quot; data-backh=&quot;476&quot; data-backw=&quot;556&quot; data-before-oversubscription-url=&quot;https://mmbiz.qpic.cn/mmbiz_png/2FMs2Kmmepgb0PRGaVwQcu2TsMxOxibSCxj7llBptmibe0xY9VibtgB0e777USIVmvvDeRRoGAHD7ySaxFbia4vL6A/0?wx_fmt=png&quot; data-copyright=&quot;0&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;556&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;434&quot; data-ratio=&quot;0.8553571428571428&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1120&quot;/&gt;&lt;/p&gt;
&lt;p&gt;列表页组件分析（绿色框为要抽象的组件）&lt;/p&gt;
&lt;p&gt;有了这些组件，开发效率一定会大幅提升！&lt;/p&gt;
&lt;p&gt;有了组件还不够，我们还需要添加通用的工具和方法到组件库中，比如埋点上报，获取url中参数等方法，这些都能够复用，不需要每个项目中重复实现。&lt;/p&gt;
&lt;p&gt;要开发一个组件库，还有很多事要考虑，如何设计目录结构，怎么做好工程化，设计开发以及review代码的机制，版本更新机制，如何开发出优秀的组件，这些将在后续推送的文章中详细介绍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二.通用ui规范&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了达到可以定制主题的目的，组件样式不能使用scoped，最好作为一个独立的项目维护，可以通过gulp或webpack进行独立编译，和组件代码的编译分离开。为了样式不互相污染，可以采用css的BEM规范。&lt;/p&gt;
&lt;p&gt;可以使用 sass，less 创建一系列变量，作为样式的基础，在组件开发时，严格使用这些变量进行开发，由于组件库是依赖开源库为基础进行二次开发的，可以直接使用组件库的定义的变量，不满足时再进行补充。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2FMs2Kmmepgb0PRGaVwQcu2TsMxOxibSCIId3icI5DeSaC2607uSziaibccRzgFpUxtbhH54Jw3UCYKKeAqZCXCquA/640?wx_fmt=png&quot; alt=&quot;&quot; data-backh=&quot;559&quot; data-backw=&quot;556&quot; data-before-oversubscription-url=&quot;https://mmbiz.qpic.cn/mmbiz_png/2FMs2Kmmepgb0PRGaVwQcu2TsMxOxibSCIId3icI5DeSaC2607uSziaibccRzgFpUxtbhH54Jw3UCYKKeAqZCXCquA/0?wx_fmt=png&quot; data-copyright=&quot;0&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;556&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;381&quot; data-ratio=&quot;1.004968944099379&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1610&quot;/&gt;&lt;/p&gt;
&lt;p&gt;element ui定义的部分变量&lt;/p&gt;
&lt;p&gt;需要定制主题时，只需改变变量值，重新编译代码即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三.构建脚手架&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;来了新项目你是怎么做的呢？ 自己搭建重新设计目录结构？复制老项目删除业务代码？如果是后者还好，至少能保证统一的技术方案。如果有一个自己的脚手架，只需一个命令，就能轻松创建项目初始化文件，这样变得优雅了很多。&lt;/p&gt;
&lt;p&gt;使用脚手架有什么优点呢？首先项目通过命令直接生成，更优雅， 其次初始化的项目相同，保证了多项目的技术方案统一，便于维护。&lt;/p&gt;
&lt;p&gt;搭建的脚手架可以基于现有的脚手架进行拓展，比如，使用vue可以基于vue-cli初始化的内容去进一步拓展。下面看看脚手架需要包含哪些内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.引入自己搭建的组件库&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;最大程度的复用代码，通过现有组件实现快速开发&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;新的交互形态，直接抽象出来扩充到组件库，所有项目复用&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;2.使用自己的一套统一样式&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;样式问题集中管理，改一次，所有项目受益&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可以定制不同的主题&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;3.使用统一的mock方案&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;前端项目运行不需要依赖后端服务&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;开发时，直接使用mock数据进行调试，减少后期和后端的联调时间&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;4.统一编码规范和风格&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有项目使用一套eslint规范，可以编写一套自己团队的规范，也可以基于社区里主流的规范去调整，使它更适合你的团队，现在主流的规范有Airbnb，Standard，Google几种。&lt;/p&gt;
&lt;p&gt;建一个团队内部规范的npm项目，所有的项目安装这个npm包，保证团队代码规范统一。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.脚手架集成登录，权限配置，路由配置，vuex，AJAX请求封装，不同环境配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把这些内容直接集成到脚手架中，这样就可以最快速度进行开发。具体怎么搭建脚手架将在后面文章中推出......&lt;/p&gt;
&lt;p&gt;时刻前端新鲜技术推送,定期前端精品文章分享，欢迎关注公众号前端小苑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2FMs2KmmepgTevuu5gGWqiax3ymEGHHX3CtW1oVVOjBRKrSkKM8rhtXMgNtyjE13tJkRULPOIR2xc5kZlDuy90Q/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;386&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 26 Jan 2019 06:54:00 +0000</pubDate>
<dc:creator>wolfSoul</dc:creator>
<og:description>工作中的你，是不是手上做着后台系统项目，应对着做不完的需求，觉得做后台系统是个没有技术含量的活，技术没法提升，这么想或许你就错了，如果能做以到以下几点，不仅可以提高你的开发效率，还能让你在组件抽象能力</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuqing6/p/10323454.html</dc:identifier>
</item>
<item>
<title>Redis系列文章总结：ASP.Net Core 中如何借助CSRedis实现一个安全高效的分布式锁 - 菠萝吹雪—Code</title>
<link>http://www.cnblogs.com/runningsmallguo/p/10322315.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/runningsmallguo/p/10322315.html</guid>
<description>&lt;p&gt;引言：最近回头看了看之前和同事一起开发的.Net Core 2.1的项目，其中在多处用到Redis实现的分布式锁，虽然在OnResultExecuting方法中做了防止死锁的处理，但在某些场景下还是会发生死锁的问题，下面我只展示部分代码：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190125233500040-449695634.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;p&gt;（1）这里setnx设置的值“1”，我想问，你最后del的这个值一定是你自己创建的吗？&lt;/p&gt;
&lt;p&gt;（2）图中标注的步骤1和步骤2不是原子操作，会有死锁的概率吗？&lt;/p&gt;
&lt;p&gt;大家可以思考一下先，下面让我们带着这两个问题往下看，下面介绍一下使用Redis实现分布式锁常用的几个命令。&lt;/p&gt;


&lt;p&gt;► Setnx&lt;/p&gt;
&lt;p&gt;命令：SETNX key value&lt;br/&gt;说明：将 key 的值设为 value ，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作。SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。&lt;br/&gt;时间复杂度：O(1)&lt;br/&gt;返回值：设置成功，返回1 ； 设置失败，返回 0&lt;/p&gt;
&lt;p&gt;► Getset&lt;/p&gt;
&lt;p&gt;命令：GETSET key value&lt;br/&gt;说明：将给定 key 的值设为 value ，并返回 key 的旧值(old value)。当 key 存在但不是字符串类型时，返回一个错误。&lt;br/&gt;时间复杂度：O(1)&lt;br/&gt;返回值：返回给定 key 的旧值; 当 key 没有旧值时，也即是， key 不存在时，返回 nil 。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;► Expire&lt;/p&gt;
&lt;p&gt;命令：EXPIRE key seconds&lt;br/&gt;说明：为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除。&lt;br/&gt;时间复杂度：O(1)&lt;br/&gt;返回值：设置成功返回 1 ；当 key 不存在或者不能为 key 设置生存时间时(比如在低于 2.1.3 版本的 Redis 中你尝试更新 key 的生存时间)，返回 0 。&lt;/p&gt;
&lt;p&gt;► Del&lt;/p&gt;
&lt;p&gt;命令：DEL key [key ...]&lt;br/&gt;说明：删除给定的一个或多个 key 。不存在的 key 会被忽略。&lt;br/&gt;时间复杂度：O(N); N 为被删除的 key 的数量。&lt;br/&gt;删除单个字符串类型的 key ，时间复杂度为O(1)。&lt;br/&gt;删除单个列表、集合、有序集合或哈希表类型的 key ，时间复杂度为O(M)， M 为以上数据结构内的元素数量。&lt;/p&gt;&lt;p&gt;返回值：被删除 key 的数量。&lt;/p&gt;
&lt;p&gt;好了，命令熟悉之后，下面我们就开始一步一步实现分布式锁。&lt;/p&gt;


&lt;p&gt;对于上面的setnx设置的默认值1，我们采用时间戳来防止问题一，下面先让我们来看下想当然写法流程图。&lt;/p&gt;
&lt;p&gt;流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190125235531367-2125406243.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;C#代码实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; lockTimeout = &lt;span&gt;5000&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;单位是毫秒&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; currentTime = DateTime.Now.ToUnixTime(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (SetNx(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lockkey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, currentTime+ lockTimeout,lockTimeout&lt;span&gt;))
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO:一些业务逻辑代码
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;.....
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;.....
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最后释放锁&lt;/span&gt;
                Remove(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lockkey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;没有获得分布式锁&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            Console.ReadKey();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; SetNx(&lt;span&gt;string&lt;/span&gt; key,&lt;span&gt;long&lt;/span&gt; time ,&lt;span&gt;double&lt;/span&gt;&lt;span&gt; expireMS)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (redisClient.SetNx(key, time))
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (expireMS &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    redisClient.Expire(key, TimeSpan.FromMilliseconds(expireMS));
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Remove(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; redisClient.Del(key) &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码中value的值我们使用时间戳，不是一个固定的值了，至少能保证你删除的key确实是你自己的，所以，建议大家在设value的值时，不要设置一个固定的值，最好是随机的。但是这样写虽然解决了问题一，但是这种写法还是存在一定的风险，虽然Redis是单线程的并且setnx、expire是原子操作，但是先setnx再expire就不是原子操作了！！！我们要考虑多线程环境和容器部署时多实例环境等等，那这样的写法就会出现问题。&lt;/p&gt;
&lt;p&gt;比如：现在有A、B两台服务器在跑这个应用，当A台应用跑到：setnx成功但是还没有设置过期时间的时候，突然重启服务，这个时候在分布式环境中就会发生死锁的问题，因为你没有设置过期时间。&lt;/p&gt;
&lt;p&gt;下面我们通过调试来展示死锁的场景：&lt;/p&gt;
&lt;p&gt;A应用：在执行到setnx成功但是在执行expire之前宕机了，此时的Redis已经有数据了，但是没有过期时间&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190126130006485-1912216083.png&quot; alt=&quot;&quot; width=&quot;1053&quot; height=&quot;170&quot;/&gt;&lt;/p&gt;

&lt;p&gt;B应用：运行正常&lt;/p&gt;
&lt;p&gt;但是B应用就会一直获取不到锁，导致死锁。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190126125237254-1640110333.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以上面在获取锁的逻辑还是有问题的，为了解决这个问题，我们采用下面的方式来处理。&lt;/p&gt;



&lt;p&gt;流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190126002320245-1848935260.png&quot; alt=&quot;&quot; width=&quot;720&quot; height=&quot;467&quot;/&gt;&lt;/p&gt;
&lt;p&gt;C#代码实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RedisLockV2()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; lockTimeout = &lt;span&gt;5000&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;单位是毫秒&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; currentTime = DateTime.Now.ToUnixTime(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (SetNxV2(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lockkey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,DateTime.Now.ToUnixTime(&lt;span&gt;true&lt;/span&gt;)+&lt;span&gt;lockTimeout))
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置过期时间&lt;/span&gt;
                redisClient.Expire(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lockkey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, TimeSpan.FromMilliseconds(&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;));
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO:一些业务逻辑代码&lt;/span&gt;
&lt;span&gt;                
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;处理业务ing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                Thread.Sleep(&lt;/span&gt;&lt;span&gt;100000&lt;/span&gt;&lt;span&gt;);

                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;处理业务ed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最后释放锁&lt;/span&gt;
                Remove(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lockkey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;未获取到锁，继续判断，判断时间戳看看是否可以重置并获取锁&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; lockValue = redisClient.Get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lockkey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; time = DateTime.Now.ToUnixTime(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(lockValue) &amp;amp;&amp;amp;  time&amp;gt;&lt;span&gt; lockValue.ToInt64())
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;再次用当前时间戳getset
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回固定key的旧值，旧值判断是否可以获取锁&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; getsetResult = redisClient.GetSet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lockkey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, time);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (getsetResult == &lt;span&gt;null&lt;/span&gt; || (getsetResult != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; getsetResult ==&lt;span&gt; lockValue))
                    {
                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;获取到Redis锁了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;真正获取到锁&lt;/span&gt;
                        redisClient.Expire(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lockkey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, TimeSpan.FromMilliseconds(&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;));
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO:一些业务逻辑代码
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;.....
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;.....&lt;/span&gt;
                        Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;处理业务&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最后释放锁&lt;/span&gt;
                        Remove(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lockkey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;没有获取到锁&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }

                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;没有获取到锁&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                }
            }
            
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 现在，Redis中的情况如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190126134243785-1385442211.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们运行上面的代码，结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190126134227280-1790314348.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 副本.exe中添加一行代码。来模拟这种场景：有A、B两台服务器在跑这个应用，当A台应用跑到：setnx成功但是还没有设置过期时间的时候，突然重启服务，这个时候在分布式环境中就会发生死锁的问题，因为你没有设置过期时间&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190126135553354-901823836.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们先执行Lottery.ThriftRpc - 副本.exe，等Redis里面有值了，并且这个key是没有过期时间，再关闭掉该程序：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190126135809061-219227056.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后，再执行Lottery.ThriftRpc.exe&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190126135944717-1038887044.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190126140012264-1892852940.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看，我们是不是解决了该问题，至于过期时间设置为多少要结合你的具体业务处理时间来计算出一个合理的值，好了，聊到这里关于Redis的分布式锁就讲完了，希望对你有帮助，谢谢。&lt;/p&gt;



&lt;p&gt; 上面的示例中Redis的组件用的是CSRedisCore，这里只是自己的一点体会，如果你有更好的办法，可以在评论区讨论，关于Redis的理论讲解有太多的文章了，大家可以参考，关于Redis的文章我只总结工作中遇到的一些问题，关于文章中的源码，我就不提供了，太简单了。后面我会不定期分享一些Redis的问题，希望大家多多支持。&lt;/p&gt;


&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;作者：郭峥&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;出处：http://www.cnblogs.com/runningsmallguo/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 26 Jan 2019 06:24:00 +0000</pubDate>
<dc:creator>菠萝吹雪—Code</dc:creator>
<og:description>引言：最近回头看了看之前和同事一起开发的.Net Core 2.1的项目，其中在多处用到Redis实现的分布式锁，虽然在OnResultExecuting方法中做了防止死锁的处理，但在某些场景下还是会</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/runningsmallguo/p/10322315.html</dc:identifier>
</item>
<item>
<title>年年总结-2018 - 神牛003</title>
<link>http://www.cnblogs.com/wangrudong003/p/10323220.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangrudong003/p/10323220.html</guid>
<description>&lt;p&gt;&amp;#13;
                                    &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;×&lt;/span&gt;&lt;span class=&quot;sr-only&quot;&gt;Close&lt;/span&gt;&lt;/button&gt;&amp;#13;
                                    &lt;h4 class=&quot;modal-title&quot;&gt;&amp;#13;
                                        请完成人机识别验证&amp;#13;
                                    &lt;/h4&gt;&amp;#13;
                                &lt;/p&gt;
                                &lt;div class=&quot;modal-body&quot; readability=&quot;33&quot;&gt;
                                    
                                    &lt;p&gt;&amp;#13;
                                        &lt;span id=&quot;geetestLoading&quot;&gt; 验证码组件加载中,请稍后...&lt;/span&gt;&amp;#13;
                                    &lt;/p&gt;
                                &lt;/div&gt;
                            </description>
<pubDate>Sat, 26 Jan 2019 06:11:00 +0000</pubDate>
<dc:creator>神牛003</dc:creator>
<dc:format>text/html</dc:format>
<dc:identifier>https://passport.cnblogs.com/user/signin?ReturnUrl=https%3A%2F%2Fwww.cnblogs.com%2Fwangrudong003%2Fp%2F10323220.html&amp;AspxAutoDetectCookieSupport=1</dc:identifier>
</item>
<item>
<title>如何为 .NET Core CLI 启用 TAB 自动补全功能 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/enable-tab-autocomplete-for-dotnet-cli.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/enable-tab-autocomplete-for-dotnet-cli.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;在 Linux 下经常可以发现有些目录/文件名，以及有些工具可以命令输入几个字母之后按 TAB 自动补全，最近发现其实 dotnet cli 也可以，从.NET Core 2.0 SDK 开始，NET Core CLI 支持 tab 自动补全。你如果已经装了 dotnet Core Sdk，但是不知道版本，可以在命令行中输入 &lt;code&gt;dotnet --info&lt;/code&gt; 来查看版本信息。&lt;/p&gt;
&lt;h2 id=&quot;使用示例&quot;&gt;使用示例&lt;/h2&gt;
&lt;p&gt;下面是 tab 自动补全提供的一些示例：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;dotnet a⇥&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;dotnet add&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;add&lt;/code&gt; 是第一项子命令，按字母排序。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;dotnet add p⇥&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;dotnet add --help&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Tab 自动补全匹配子字符串，&lt;code&gt;--help&lt;/code&gt; 首先按字母顺序排列。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;dotnet add p⇥⇥&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;dotnet add package&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;第二次按 Tab 将显示下一条建议。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;&lt;code&gt;dotnet add package Microsoft⇥&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;dotnet add package Microsoft.ApplicationInsights.Web&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;结果按字母顺序返回。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;&lt;code&gt;dotnet remove reference ⇥&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;dotnet remove reference ..\..\src\OmniSharp.DotNet\OmniSharp.DotNet.csproj&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Tab 自动补全是可识别的项目文件。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;启动-tab-自动补全功能&quot;&gt;启动 TAB 自动补全功能&lt;/h2&gt;
&lt;h3 id=&quot;powershell&quot;&gt;Powershell&lt;/h3&gt;
&lt;p&gt;要将 tab 自动补全添加到适用于 .NET Core CLI 的 PowerShell，请创建或编辑存储在变量 &lt;code&gt;$PROFILE&lt;/code&gt; 中的配置文件。 有关详细信息，请参阅&lt;a href=&quot;http://www.cnblogs.com/powershell/module/microsoft.powershell.core/about/about_profiles?view=powershell-6#how-to-create-a-profile&quot;&gt;如何创建配置文件&lt;/a&gt;和&lt;a href=&quot;http://www.cnblogs.com/powershell/module/microsoft.powershell.core/about/about_profiles?view=powershell-6#profiles-and-execution-policy&quot;&gt;配置文件和执行策略&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在 Powershell 中执行 &lt;code&gt;notepad $profile&lt;/code&gt; 命令，会打开 &lt;code&gt;$profile&lt;/code&gt; 配置文件，如果不能保存请尝试用管理员模式的powershell中执行。&lt;/p&gt;
&lt;p&gt;将以下代码添加到配置文件中：&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;# PowerShell parameter completion shim for the dotnet CLI 
Register-ArgumentCompleter -Native -CommandName dotnet -ScriptBlock {
     param($commandName, $wordToComplete, $cursorPosition)
         dotnet complete --position $cursorPosition &quot;$wordToComplete&quot; | ForEach-Object {
            [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
         }
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想看 &lt;code&gt;$profile&lt;/code&gt; 配置文件，可以打开 &lt;code&gt;%USERPROFILE%\Documents\WindowsPowerShell&lt;/code&gt; 目录，&lt;br/&gt;在这个目录下会有一个 &lt;code&gt;Microsoft.PowerShellISE_profile.ps1&lt;/code&gt; 的文件，这就是上面的配置文件&lt;/p&gt;
&lt;h3 id=&quot;bash&quot;&gt;Bash&lt;/h3&gt;
&lt;p&gt;要将 tab 自动补全添加到适用于 .NET Core CLI 的 bash shell，请将以下代码添加到 &lt;code&gt;.bashrc&lt;/code&gt; 文件：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;vi ~/.bashrc&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# bash parameter completion for the dotnet CLI

_dotnet_bash_complete()
{
  local word=${COMP_WORDS[COMP_CWORD]}

  local completions
  completions=&quot;$(dotnet complete --position &quot;${COMP_POINT}&quot; &quot;${COMP_LINE}&quot;)&quot;

  COMPREPLY=( $(compgen -W &quot;$completions&quot; -- &quot;$word&quot;) )
}

complete -f -F _dotnet_bash_complete dotnet&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用一下&quot;&gt;使用一下&lt;/h2&gt;
&lt;p&gt;实际使用的效果就如上面的示例一般，如输入一个 &lt;code&gt;dotnet a&lt;/code&gt;，然后按一下 TAB 键，命令就会自动补充为 &lt;code&gt;dotnet add&lt;/code&gt; ，其他的命令就自己去尝试一下吧~~&lt;/p&gt;
&lt;p&gt;如此好用的功能还不快快启用~&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Sat, 26 Jan 2019 05:54:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>在 Linux 下经常可以发现有些目录/文件名，以及有些工具可以命令输入几个字母之后按 TAB 自动补全，最近发现其实 dotnet cli 也可以，从.NET Core 2.0 SDK 开始，NET</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/weihanli/p/enable-tab-autocomplete-for-dotnet-cli.html</dc:identifier>
</item>
<item>
<title>.NET IdentityServer4实战-开篇介绍与规划 - 张子浩</title>
<link>http://www.cnblogs.com/ZaraNet/p/10323105.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZaraNet/p/10323105.html</guid>
<description>&lt;h2&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201901/1366751-20190126122840611-257928954.png&quot; alt=&quot;&quot;/&gt;&lt;/h2&gt;
&lt;h2&gt;一.开篇寄语&lt;/h2&gt;
&lt;p&gt;　　由于假期的无聊，我决定了一个非常有挑战性的活动，也就是在年假给大家带来一个基于OAuth 2.0的身份授权框架，它就是 &lt;span class=&quot;cnblogs_code&quot;&gt;IdentityServer4&lt;/span&gt; ，如果没有意外的话，一定可以顺利的写完的，如果两天写一篇的话！如果觉得期待的话，可以点个收藏，当然如果由于太忙还是怎样耽误了写作效率，请多担待（我觉得我精力是足够的！）那么废话少说，下面我来介绍一下IdentityServer4是个啥？&lt;/p&gt;
&lt;h2&gt;二.IdentityServer4介绍&lt;/h2&gt;
&lt;p&gt;　　IdentityServer4是ASP.NET Core 2的OpenID Connect和OAuth 2.0框架，可以做的功能有SSO（单点登陆）、Api 控制、身份认证服务等。它是一个开源的项目，最重要的是IdentityServer可以由你自己定制来适应你的解决方案！这非常的友好。为什么要有它，在现在杂七杂八的的框架和语言来说，是配一套完美的应用是非常困难，每个模块由很难统一，所以IdentityServer4就给我们带来了糖果。&lt;/p&gt;
&lt;h2&gt;三.大体内容&lt;/h2&gt;
&lt;p&gt; 基于IdentityServer4进行统一认证单点登陆、Api 身份验证、授权服务、EntityFramework的配置的支持、登录注销等。&lt;/p&gt;
&lt;h2&gt;四.文章&lt;/h2&gt;
&lt;p&gt;（更新中）&lt;/p&gt;
&lt;h2&gt;五.为什么要用它&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://docs.identityserver.io/en/latest/_images/appArch.png&quot; alt=&quot;../_images/appArch.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　大多数的应用都如上所示，基本上都是通过客户端对API进行请求（浏览器、Web程序、本机应用程序）等。当你的项目到了一定得范围和大小之后，就有可能去使用&lt;a href=&quot;https://www.cnblogs.com/GreenLeaves/category/1333563.html&quot; target=&quot;_blank&quot;&gt;Nginx&lt;/a&gt;,这个时候,也必须考虑站点的安全性,因为不能让你的核心业务信任外界任何的调用.当然还有的时候，我们的拥有自己的一套API,为自己服务进行使用，我们不想让别人来调用我们的，这个时候也可以进行使用。&lt;/p&gt;
&lt;p&gt;　　如果使用了IdentityServer4来保护我们的API,项目的层级就变成了这样。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201901/1366751-20190126124136719-960615150.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　例如博客园的一个功能，如果你没有登录那就只能访问博客园公共部分，如果你登录了，你就可以肆意翱翔，当然这个栗子不是很恰当。。&lt;/p&gt;
&lt;h2&gt;六.概念&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201901/1366751-20190126124619438-453525888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　 &lt;span class=&quot;cnblogs_code&quot;&gt;OpenID&lt;/span&gt; ：它何我们的身份证一样，你干什么事情都需要身份，那么XXX想要知道你有没有问题，就要去查询下你这个ID有没有毛病，有毛病就go away，没毛病就喊老铁。&lt;/p&gt;
&lt;p&gt;　　 &lt;span class=&quot;cnblogs_code&quot;&gt;OAuth &lt;span&gt;2.0&lt;/span&gt;&lt;/span&gt; ：OAUTH协议为用户资源的授权提供了一个安全的、开放而又简易的标准。与以往的授权方式不同之处是OAUTH的授权不会使第三方触及到用户的帐号信息（如用户名与密码），即第三方无需使用用户的用户名与密码就可以申请获得该用户资源的授权，因此OAUTH是安全的。&lt;/p&gt;
&lt;p&gt;　　  &lt;span class=&quot;cnblogs_code&quot;&gt;OpenId Connect&lt;/span&gt; ：emmm,例如呢你的网站接入了QQ的第三方登录，它是被大多程序员叫做身份层，这个大体的协议叫做&lt;strong&gt;OIDC。&lt;/strong&gt;OpenID是&lt;em&gt;Authentication&lt;/em&gt;，即认证，对用户的身份进行认证，判断其身份是否有效，也就是让网站知道 “你是你所声称的那个用户”；&lt;/p&gt;

&lt;hr/&gt;&lt;h2&gt; 七.结语&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;关于IdentityServer4的项目地址：https://github.com/IdentityServer，官方网站：http://docs.identityserver.io/en/latest/index.html。我是用的IDE是VS2019,当然你用17也可以，如果你用其他版本的，我劝你另寻他处：）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　尽情期待。&lt;/p&gt;

</description>
<pubDate>Sat, 26 Jan 2019 05:00:00 +0000</pubDate>
<dc:creator>张子浩</dc:creator>
<og:description>一.开篇寄语 由于假期的无聊，我决定了一个非常有挑战性的活动，也就是在年假给大家带来一个基于OAuth 2.0的身份授权框架，它就是 IdentityServer4 ，如果没有意外</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZaraNet/p/10323105.html</dc:identifier>
</item>
<item>
<title>zookeeper 实现分布式锁安全用法 - 王清培</title>
<link>http://www.cnblogs.com/wangiqngpei557/p/10323149.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangiqngpei557/p/10323149.html</guid>
<description>&lt;p&gt;标签： zookeeper sessionExpire connectionLoss 分布式锁&lt;/p&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;背景&lt;/li&gt;
&lt;li&gt;ConnectionLoss 链接丢失&lt;/li&gt;
&lt;li&gt;SessionExpired 会话过期&lt;/li&gt;
&lt;li&gt;绕开 zookeeper broker 进行状态通知&lt;/li&gt;
&lt;li&gt;leader 选举与zkNode 断开&lt;/li&gt;
&lt;li&gt;做好幂等&lt;/li&gt;
&lt;li&gt;静态扩容、动态扩容&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分布式锁现在用的越来越多，通常用来协调多个并发任务。在一般的应用场景中存在一定的不安全用法，不安全用法会带来多个master在并行执行，业务或数据可能存在重复计算带来的副作用，在没有拿到lock的情况下扮演者master等诸如此类。&lt;/p&gt;
&lt;p&gt;要想准确的拿到分布式锁，并且准确的捕获在分布式情况下锁的动态转移状态，需要处理网络变化带来的连锁反应。比如常见的 session expire、connectionLoss，在设置lock状态的时候我们如何保证准确拿到lock。&lt;/p&gt;
&lt;p&gt;在设计任务的时候我们需要具有 stop point 的策略，这个策略是用来在感知到lock丢失后能够交付执行权的机制。但是是否需要这么严肃的处理这个问题还取决于业务场景，比如下游的任务已经做好幂等也无所谓重复计算。 但是在有些情况下确实需要严肃精准控制。&lt;/p&gt;

&lt;p&gt;先说第一个场景，connectionLoss事件，此事件表示提交的commit有可能执行成功也有可能执行失败，成功是指在zookeeper broker 中执行成功但是返回的时候tcp断开了，导致未能拿到返回的状态。失败是指根本就没有提交到zookeper broker中链接就断开了。&lt;/p&gt;
&lt;p&gt;所以在我们获取lock的时候需要做 connectionLoss 事件处理，我们看个例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected void runForMaster() {

        logger.info(&quot;master:run for master.&quot;);

        AsyncCallback.StringCallback createCallback =
                (rc, path, ctx, name) -&amp;gt; {
                    switch (KeeperException.Code.get(rc)) {
                        case CONNECTIONLOSS:
                            checkMaster();//链接失效检查znode设置是否成功
                            return;
                        case OK:
                            isLeader = true;
                            logger.info(&quot;master:I'm the leader serverId:&quot; + serverId);
                            addMasterWatcher();//监控 master znode
                            this.takeLeadership();//执行leader权利
                            break;
                        case NODEEXISTS:
                            isLeader = false;
                            String serverId = this.getMasterServerId();
                            this.takeBackup(serverId);
                            break;

                    }
                };

        zk.create(rootPath + &quot;/master&quot;, serverId.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,
                CreateMode.EPHEMERAL, createCallback, null);//创建master节点
    }

    /**
     * check master 循环检查
     */
    private void checkMaster() {

        AsyncCallback.DataCallback masterCheckCallback =
                (rc, path, ctx, data[], stat) -&amp;gt; {
                    switch (KeeperException.Code.get(rc)) {
                        case CONNECTIONLOSS:
                            checkMaster();
                            return;
                        case NONODE:
                            runForMaster();
                            return;
                        default: {
                            String serverId = this.getMasterServerId();
                            isLeader = serverId.equals(this.serverId);
                            if (BooleanUtils.isNotTrue(isLeader)) {
                                this.takeBackup(serverId);
                            } else {
                                this.takeLeadership();
                            }
                        }

                        return;
                    }
                };

        zk.getData(masterZnode, false, masterCheckCallback, null);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的master表示具有执行权，只有成功拿到master 角色才能履行master权利。&lt;/p&gt;
&lt;p&gt;runForMaster 方法一旦发现有connectionLoss就发起checkMaster进行检查，同时checkMaster方法中也进行connectinLoss检查，直到拿到明确的状态为止。在此时有可能有另外的节点获取到了master角色，那么当前节点就做好backup等待机会。&lt;/p&gt;
&lt;p&gt;我们需要捕获zookeeper所有的状态变化，要知道master什么时候失效做好申请准备，当自己是master时候会话失效需要释放master权利。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
     * 监控 master znode 做 master/slave 切换
     */
    private void addMasterWatcher() {

        AsyncCallback.StatCallback addMasterWatcher = (rc, path, ctx, stat) -&amp;gt; {
            switch (KeeperException.Code.get(rc)) {
                case CONNECTIONLOSS:
                    addMasterWatcher();
                    break;
                case OK:
                    if (stat == null) {
                        runForMaster();//master 已经不存在
                    } else {
                        logger.info(&quot;master:watcher master znode ok.&quot;);
                    }
                    break;
                case NONODE:
                    logger.info(&quot;master:master znode delete.&quot;);
                    runForMaster();
                    break;
            }
        };

        zk.exists(masterZnode, MasterExistsWatcher, addMasterWatcher, null);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过zookeeper watcher 机制来进行状态监听，保持与网络、zookeeper状态变化联动。&lt;/p&gt;

&lt;p&gt;我们在来看第二个问题，第一个问题是获取lock的时候如何保证一定可以准确拿到状态，这里状态是指master角色或者backup角色。&lt;/p&gt;
&lt;p&gt;当我们成功与zookeeper broker建立链接，成功获取到master角色并且正在履行master义务时突然zookeeper通知session过期，SessionExpired事件表示zookeeper将会删除所有当前会话创建的临时znode，也就意味这master znode将会被其他会话创建。&lt;/p&gt;
&lt;p&gt;此时我们需要将自己的master 权利交出去，也就是我们必须放下目前手上执行的任务，这个停止的状态必须能够反应到全局。此时最容易出现到问题就是，我们已经不是master了但是还在偷偷到执行master权利，通过dashboard会看到很奇怪的问题，不是master的服务器还在执行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;case SESSIONEXPIRED:
    //执行 stop point 通知
    this.stopPoint();
    break;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以这里需要我们在设计任务时有stop point 策略，类似jvm的safe point，随时响应全局停止。&lt;/p&gt;

&lt;p&gt;还有一种常见的使用方式是绕开zookeeper 来做状态通知。&lt;/p&gt;
&lt;p&gt;我们都知道zookeeper cluster 是由多台实例组成，每个实例都在全国甚至全球的不同地方，leader到这些节点之间都有很大的同步延迟差异，zookeeper内部采用法定人数的两阶段提交的方式来完成一次commit。&lt;/p&gt;
&lt;p&gt;比如有7个实例构成一套zookeeper cluster ，当一次client 写入 commit只需要集群中有超过半数完成写入就算这次commit提交成功了。但是cleint得到这个提交成功的响应之后立马执行接下来的任务，这个任务可能是读取某个znode下的所有状态数据，此时有可能无法读取到这个状态。&lt;/p&gt;
&lt;p&gt;如果是分布式锁的话很有可能是锁在zk集群中的转移无法和client集群保持一直。所以只要是基于zookeeper做集群调度就要完全原来zookeeper来做状态通知，不可以绕开zookeeper来自行调度。&lt;/p&gt;

&lt;p&gt;zookeeper leader 是所有状态变更的串行化器，add、update、delete都需要leader来处理，然后传播给所有follower、observer节点。&lt;/p&gt;
&lt;p&gt;所有的session是保存在leader中的，所有的watcher是保存在client链接的zookeper node中的，这里两个场景都会导致状态迁移的通知不准时。&lt;/p&gt;
&lt;p&gt;如果zookeeper是由多数据中心构成的一套集群，存在异地同步延迟的问题，leader是肯定会放在写入的数据中心中，同时zid应该是最大的，甚至是一组高zid的机器都在写入的数据中心中，这样保证leader宕机也不会轻易导致leader选举到其他数据中心。&lt;/p&gt;
&lt;p&gt;但是follower、observer都会有client在使用，也会有在这些节点进行协调的分布式集群。&lt;/p&gt;
&lt;p&gt;先说leader选举导致异地节点延迟感知问题，比如当前 zookeeper cluster 有7台机器构成：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dataCenter shanghai：zid=100、zid=80、zid=50
dataCenter beijing： zid=10、zid=20
dataCenter shenzhen：zid=30、zid=40&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于网络问题集群发生leader选举，zid=100暂时脱离集群，zid=80成为leader，这里不考虑日志新旧问题，优先使用zid进行选举。&lt;/p&gt;
&lt;p&gt;由于集群中所有的session是保存在原来zid=100的机器中的，新leader没有任何session信息，所以将导致所有session丢失。&lt;/p&gt;
&lt;p&gt;session的保持时间是取决于我们设置的sessinoTimeout时间来的，client通过ping来将心跳传播到所链接的zkNode，这个zkNode可能是任意角色的node，然后zkNode在与zkleaderNode进行心跳来保持会话，同时zkNode也会通过ping来保持会话超时时间。&lt;/p&gt;
&lt;p&gt;此时当原有当client在重新链接上zkNode时会被告知sessionExpired。sessionExpired 是由zkNode通知出来的，当会话丢失或者过期，client在去尝试链接zkNode时候会被zkNode告知会话过期。&lt;/p&gt;
&lt;p&gt;如果client只捕获了sessionExpired显然会出现多个master运行情况，因为当你与zkNode断开到时候，当时还没有收到sessionExpired事件时，已经有另外client成功创建master拿到权利。&lt;/p&gt;
&lt;p&gt;这种情况在zkNode出现脱离集群当时候也会出现，当zkNode断开之后也会出现sessionExpired延迟通知问题。所有的watcher都是需要在新的zkNode上创建才会收到新的事件。&lt;/p&gt;

&lt;p&gt;在极端情况下静态扩容可能会导致zookeeper集群出现严重的数据不一致问题，比如现有集群：A、B、C，现在需要进行静态扩容，停止ABC实例，拉入DE实例，此时如果C实例是ABC中最滞后的实例，如果AB启动的速度没有C快就会导致CDE组成新的集群，新的纪元号会覆盖原来的AB日志。当然现在基本上不会接受静态扩容，基本上都是动态扩容。&lt;/p&gt;
&lt;p&gt;动态扩容在极端情况下也会出现类似问题，比如现在有三个机房，1、2、3，1机房方leader zid=200、100，2机房zid=80、50，3机房zid=40，假设上次的commit是在zid=200、100、50之间提交的，此时机房1出现断网，2机房zid=80、50与3机房zid=40开始组成新的集群，新的纪元在zid=50上产生。&lt;/p&gt;

&lt;p&gt;在使用zookeeper来实现分布式锁或者集群调度的时候会出现很多分布式下的问题，为了保证这些问题的出现不会带来业务系统或者业务数据的不一致，我们还是在这些任务上做好幂等性考虑。&lt;/p&gt;
&lt;p&gt;比如进行数据的计算，做个时间检查，版本检查之类的。如果本身是基于zookeeper实现的一套独立的分布式系统需要的工作会更多点。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;作者：王清培 （沪江集团资深架构师）&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 26 Jan 2019 04:51:00 +0000</pubDate>
<dc:creator>王清培</dc:creator>
<og:description>zookeeper 实现分布式锁安全用法 标签： zookeeper sessionExpire connectionLoss 分布式锁 背景 ConnectionLoss 链接丢失 SessionE</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangiqngpei557/p/10323149.html</dc:identifier>
</item>
</channel>
</rss>