<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Go Web 编程之 数据库 - darjun</title>
<link>http://www.cnblogs.com/darjun/p/12227824.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/darjun/p/12227824.html</guid>
<description>&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;数据库用来存储数据。只要不是玩具项目，每个项目都需要用到数据库。现在用的最多的还是 MySQL，&lt;a href=&quot;https://www.postgresql.org/&quot;&gt;PostgreSQL&lt;/a&gt;的使用也在快速增长中。&lt;br/&gt;在 Web 开发中，数据库也是必须的。本文将介绍如何在 Go 语言中操作数据库，基于 MySQL。本文假定大家已经掌握了数据库和 MySQL 的基础知识。&lt;br/&gt;关于 MySQL 有一个非常详细的免费教程我放在&lt;a href=&quot;https://www.cnblogs.com/darjun/p/12227824.html#参考&quot;&gt;参考&lt;/a&gt;中了，需要的自取。&lt;/p&gt;
&lt;p&gt;Go 语言标准库&lt;code&gt;database/sql&lt;/code&gt;只是提供了一组查询和操作数据库的接口，没有提供任何实现。在 Go 中操作数据库只能使用第三方库。&lt;br/&gt;各种类型的数据库都有对应的第三方库。Go 中支持 MySQL 的驱动中最常见的是&lt;a href=&quot;https://github.com/go-sql-driver/mysql&quot;&gt;go-sql-driver/mysql&lt;/a&gt;。&lt;br/&gt;该库支持&lt;code&gt;database/sql&lt;/code&gt;，全部采用 go 实现。&lt;/p&gt;
&lt;h2 id=&quot;数据库操作&quot;&gt;数据库操作&lt;/h2&gt;
&lt;h3 id=&quot;准备工作&quot;&gt;准备工作&lt;/h3&gt;
&lt;p&gt;创建一个数据库&lt;code&gt;department&lt;/code&gt;，表示公司中的某个部门。&lt;br/&gt;在该库中创建两张表&lt;code&gt;employees&lt;/code&gt;和&lt;code&gt;teams&lt;/code&gt;。&lt;code&gt;employees&lt;/code&gt;记录员工信息，&lt;code&gt;teams&lt;/code&gt;记录小组信息。&lt;br/&gt;每个员工都属于一个小组，每个小组都有若干名员工。&lt;/p&gt;
&lt;pre class=&quot;department.sql&quot;&gt;
&lt;code&gt;SET NAMES utf8mb4;

CREATE DATABASE IF NOT EXISTS `department`
CHARACTER SET utf8mb4
COLLATE utf8mb4_general_ci;

USE `department`;

CREATE TABLE IF NOT EXISTS `employees` (
  `id` INT(11) AUTO_INCREMENT PRIMARY KEY,
  `name` VARCHAR(255) NOT NULL DEFAULT '',
  `age` INT(11) NOT NULL DEFAULT 0,
  `salary` INT(11) NOT NULL DEFAULT 0,
  `team_id` INT(11) NOT NULL DEFAULT 0
) ENGINE=InnoDB;

CREATE TABLE IF NOT EXISTS `teams` (
  `id` INT(11) AUTO_INCREMENT PRIMARY KEY,
  `name` VARCHAR(255) NOT NULL DEFAULT ''
) ENGINE=InnoDB;

INSERT INTO `teams`(`name`)
VALUES
  ('策划'),
  ('开发'),
  ('运营'),
  ('运维');

INSERT INTO `employees`(`name`, `age`, `salary`, `team_id`)
VALUES
  ('张三', 28, 1200, 1),
  ('李四', 38, 4000, 1),
  ('王五', 36, 3500, 1),
  ('赵六', 31, 3100, 2),
  ('田七', 29, 2900, 2),
  ('吴八', 27, 1500, 3),
  ('朱九', 26, 1600, 3),
  ('钱十', 27, 1800, 3),
  ('陶十一', 28, 1900, 4),
  ('汪十二', 25, 2000, 4),
  ('剑十三', 24, 30000, 4);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;插入一些测试数据。将这个&lt;code&gt;department.sql&lt;/code&gt;文件保存到某个目录，然后在该目录打开命令行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ mysql -u root -p
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入密码连接到数据库，然后输入以下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; source department.sql
Query OK, 0 rows affected (0.00 sec)

Query OK, 2 rows affected (0.02 sec)

Query OK, 1 row affected (0.00 sec)

Database changed
Query OK, 0 rows affected, 4 warnings (0.02 sec)

Query OK, 0 rows affected, 1 warning (0.02 sec)

Query OK, 4 rows affected (0.01 sec)
Records: 4  Duplicates: 0  Warnings: 0

Query OK, 11 rows affected (0.00 sec)
Records: 11  Duplicates: 0  Warnings: 0

mysql&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样数据库和表就创建好了。&lt;/p&gt;
&lt;h3 id=&quot;连接数据库&quot;&gt;连接数据库&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;go-sql-driver/mysql&lt;/code&gt;是第三方库，需要安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ go get github.com/go-sql-driver/mysql&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import (
  &quot;database/sql&quot;
  &quot;log&quot;

  _ &quot;github.com/go-sql-driver/mysql&quot;
)

func main() {
  db, err := sql.Open(&quot;mysql&quot;, &quot;root:12345@tcp(127.0.0.1:3306)/department&quot;)
  if err != nil {
    log.Fatal(&quot;connect database failed: &quot;, err)
  }
  defer db.Close()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们操作数据库并不是直接使用&lt;code&gt;mysql&lt;/code&gt;库，而是通过&lt;code&gt;database/sql&lt;/code&gt;的接口。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;import _ &quot;github.com/go-sql-driver/mysql&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码导入&lt;code&gt;mysql&lt;/code&gt;，但并不直接使用，而是利用导入的副作用执行&lt;code&gt;mysql&lt;/code&gt;库的&lt;code&gt;init&lt;/code&gt;函数，将&lt;code&gt;mysql&lt;/code&gt;驱动注册到&lt;code&gt;database/sql&lt;/code&gt;中：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;// go-sql-driver/mysql/driver.go
func init() {
  sql.Register(&quot;mysql&quot;, &amp;amp;MySQLDriver{})
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在程序中使用&lt;code&gt;sql.Open&lt;/code&gt;创建一个&lt;code&gt;sql.DB&lt;/code&gt;结构，参数一即为&lt;code&gt;mysql&lt;/code&gt;库注册的名字，参数二实际上就是指定数据库连接信息的。&lt;br/&gt;每个数据库接受的连接信息是不同的。对于 MySQL 来说，连接信息实际上是一个 DSN （Data Source Name）。DSN 的一般格式为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[username[:password]@][protocol[(address)]]/dbname[?param1=value1&amp;amp;...&amp;amp;paramN=valueN]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例中使用的就是一个 DSN，指定用户名为&lt;code&gt;root&lt;/code&gt;，密码为&lt;code&gt;12345&lt;/code&gt;，&lt;br/&gt;通过 tcp 协议连接到 ip 为&lt;code&gt;127.0.0.1&lt;/code&gt;，端口为 3306 的 MySQL 的&lt;code&gt;department&lt;/code&gt;数据库上。&lt;/p&gt;
&lt;p&gt;在使用完成后，需要调用&lt;code&gt;db.Close&lt;/code&gt;关闭&lt;code&gt;sql.DB&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需要特别注意的是，&lt;code&gt;sql.Open&lt;/code&gt;并不会建立到数据库的连接，它也不会检测驱动的连接参数。它仅仅创建了一个数据库抽象层给后面使用。&lt;br/&gt;到数据库的连接实际上会在需要的时候惰性地创建。&lt;/strong&gt;所以，我们使用一个非法的用户名或密码，连接一个主机上不存在的库，&lt;code&gt;sql.Open&lt;/code&gt;也不会报错。&lt;br/&gt;将上面的 DSN 改为&lt;code&gt;user:password@tcp(127.0.0.1:6666)/not_exist_department&lt;/code&gt;，运行程序，没有报错。&lt;/p&gt;
&lt;p&gt;如果想要检测数据库是否可访问，可以使用&lt;code&gt;db.Ping()&lt;/code&gt;函数：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;err = db.Ping()
if err != nil {
  log.Fatal(&quot;ping failed: &quot;, err)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时连接&lt;code&gt;not_exist_department&lt;/code&gt;会报错：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2020/01/20 22:16:12 ping failed: Error 1049: Unknown database 'not_exist_department'
exit status 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;sql.DB&lt;/code&gt;对象一般作为某种形式的全局变量长期存活。不要频繁打开、关闭该对象。这对性能会有非常大的影响。&lt;/p&gt;
&lt;h3 id=&quot;查询&quot;&gt;查询&lt;/h3&gt;
&lt;p&gt;先看一个简单示例：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import (
  &quot;database/sql&quot;
  &quot;log&quot;

  _ &quot;github.com/go-sql-driver/mysql&quot;
)

func main() {
  db, err := sql.Open(&quot;mysql&quot;, &quot;root:12345@tcp(127.0.0.1:3306)/department&quot;)
  if err != nil {
    log.Fatal(&quot;open database failed: &quot;, err)
  }
  defer db.Close()

  var id int
  var name string
  var age int
  var salary int
  var teamId int

  rows, err := db.Query(&quot;select id, name, age, salary, team_id from employees where id = ?&quot;, 1)
  if err != nil {
    log.Fatal(&quot;query failed: &quot;, err)
  }
  defer rows.Close()

  for rows.Next() {
    err := rows.Scan(&amp;amp;id, &amp;amp;name, &amp;amp;age, &amp;amp;salary, &amp;amp;teamId)
    if err != nil {
      log.Fatal(&quot;scan failed: &quot;, err)
    }
    log.Printf(&quot;id: %d name:%s age:%d salary:%d teamId:%d\n&quot;, id, name, age, salary, teamId)
  }

  err = rows.Err()
  if err != nil {
    log.Fatal(err)
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序，输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2020/01/20 22:27:21 id: 1 name:张三 age:28 salary:1200 teamId:1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面程序中，我们看到一个查询操作的基本流程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用&lt;code&gt;db.Query()&lt;/code&gt;查询数据库；&lt;/li&gt;
&lt;li&gt;在循环中遍历返回的行，&lt;code&gt;rows.Scan()&lt;/code&gt;读取各列的值，&lt;code&gt;rows.Next()&lt;/code&gt;将“指针”移动到下一行；&lt;/li&gt;
&lt;li&gt;遍历完所有行时，&lt;code&gt;rows.Next()&lt;/code&gt;将返回 false，循环退出。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;数据库操作可能会遇到各种各样的错误，所以错误处理很重要。例如，在循环中调用&lt;code&gt;rows.Scan&lt;/code&gt;可能产生错误。&lt;/p&gt;
&lt;p&gt;遍历结束后，一定要关闭&lt;code&gt;rows&lt;/code&gt;。因为它持有连接的指针，不关闭会造成资源泄露。&lt;code&gt;rows.Next()&lt;/code&gt;遇到最后一行时会返回一个 EOF 错误，并关闭连接。&lt;br/&gt;另外，如果&lt;code&gt;rows.Next()&lt;/code&gt;由于产生错误返回 false，&lt;code&gt;rows&lt;/code&gt;也会自动关闭。其它情况下，如果提前退出循环，可能会忘记关闭&lt;code&gt;rows&lt;/code&gt;。&lt;br/&gt;所以一般使用&lt;code&gt;defer rows.Close()&lt;/code&gt;确保正常关闭。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tips:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;调用&lt;code&gt;Scan&lt;/code&gt;方法时，其内部会根据传入的参数类型执行相应的数据类型转换。利用这个特性可以简化代码。&lt;br/&gt;例如，MySQL 中某一列是&lt;code&gt;VARCHAR/CHAR&lt;/code&gt;或类似的文本类型，但是我们知道它保存的是一个整数。&lt;br/&gt;那么就可以传入一个&lt;code&gt;int&lt;/code&gt;类型的变量，&lt;code&gt;Scan&lt;/code&gt;内部会帮助我们将字符串转为&lt;code&gt;int&lt;/code&gt;。免除了我们手动调用&lt;code&gt;strconv&lt;/code&gt;相关方法的麻烦。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;database/sql&lt;/code&gt;中函数的命名特别讲究：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Query*&lt;/code&gt;这种以&lt;code&gt;Query&lt;/code&gt;开头的函数，肯定返回若干行（可能为 0）数据；&lt;/li&gt;
&lt;li&gt;不返回行数据的语句，不能使用&lt;code&gt;Query*&lt;/code&gt;函数，应该使用&lt;code&gt;Exec&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;prepare&quot;&gt;Prepare&lt;/h4&gt;
&lt;p&gt;当我们需要多次执行同一条语句时，最好的做法是先创建一个&lt;code&gt;PreparedStatement&lt;/code&gt;。这个&lt;code&gt;PreparedStatement&lt;/code&gt;可以包含参数占位符，后续执行时再提供参数。&lt;/p&gt;
&lt;p&gt;每种数据库都有自己参数占位符，MySQL 使用的是&lt;code&gt;?&lt;/code&gt;。使用参数占位符有一个明显的好处：能避免&lt;strong&gt;SQL 注入攻击&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;需要执行 SQL 时，传入参数调用&lt;code&gt;PreparedStatement&lt;/code&gt;的&lt;code&gt;Query&lt;/code&gt;方法即可：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func main() {
  db, err := sql.Open(&quot;mysql&quot;, &quot;root:12345@tcp(127.0.0.1:3306)/department&quot;)
  if err != nil {
    log.Fatal(&quot;open failed: &quot;, err)
  }
  defer db.Close()

  stmt, err := db.Prepare(&quot;select id, name, age, salary from employees where id = ?&quot;)
  if err != nil {
    log.Fatal(&quot;prepare failed: &quot;, err)
  }
  defer stmt.Close()

  rows, err := stmt.Query(2)
  if err != nil {
    log.Fatal(&quot;query failed: &quot;, err)
  }
  defer rows.Close()

  var (
    id int
    name string
    age int
    salary int
  )
  for rows.Next() {
    err := rows.Scan(&amp;amp;id, &amp;amp;name, &amp;amp;age, &amp;amp;salary)
    if err != nil {
      log.Fatal(&quot;scan failed: &quot;, err)
    }
    log.Printf(&quot;id:%d name:%s age:%d salary:%d\n&quot;, id, name, age, salary)
  }

  err = rows.Err()
  if err != nil {
    log.Fatal(err)
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，在&lt;code&gt;db.Query()&lt;/code&gt;函数内部，会先创建一个&lt;code&gt;PreparedStatement&lt;/code&gt;，执行它，然后关闭。这会与数据库产生 3 次通信。所以尽量先创建&lt;code&gt;PreparedStatement&lt;/code&gt;，再使用。&lt;/p&gt;
&lt;h4 id=&quot;单行查询&quot;&gt;单行查询&lt;/h4&gt;
&lt;p&gt;如果查询最多只返回一行数据，我们不用写循环处理，使用&lt;code&gt;QueryRow&lt;/code&gt;可以简化代码编写。&lt;/p&gt;
&lt;p&gt;直接调用&lt;code&gt;db.QueryRow&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;var name string
err = db.QueryRow(&quot;select name from employees where id = ?&quot;, 1).Scan(&amp;amp;name)
if err != nil {
  log.Fatal(err)
}
fmt.Println(name)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以在&lt;code&gt;PreparedStatement&lt;/code&gt;上调用&lt;code&gt;QueryRow&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;stmt, err := db.Prepare(&quot;select name from employees where id = ?&quot;).Scan(&amp;amp;name)
if err != nil {
  log.Fatal(err)
}
defer stmt.Close()
var name string
err = stmt.QueryRow(1).Scan(&amp;amp;name)
if err != nil {
  log.Fatal(err)
}
fmt.Println(name)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意，&lt;code&gt;QueryRow&lt;/code&gt;遇到的错误会延迟到调用&lt;code&gt;Scan&lt;/code&gt;时才返回。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;插入修改删除&quot;&gt;插入/修改/删除&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;INSERT/UPDATE/DELETE&lt;/code&gt;这些操作，由于都不返回行，应该使用&lt;code&gt;Exec&lt;/code&gt;函数。建议先创建&lt;code&gt;PreparedStatement&lt;/code&gt;再执行。&lt;/p&gt;
&lt;p&gt;现在“策划组”新加入了一名员工：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func main() {
  db, err := sql.Open(&quot;mysql&quot;, &quot;root:12345@tcp(127.0.0.1:3306)/department&quot;)
  if err != nil {
    log.Fatal(&quot;open failed: &quot;, err)
  }
  defer db.Close()

  stmt, err := db.Prepare(&quot;INSERT INTO employees(name, age, salary, team_id) VALUES(?,?,?,?)&quot;)
  if err != nil {
    log.Fatal(&quot;prepare failed: &quot;, err)
  }
  defer stmt.Close()

  res, err := stmt.Exec(&quot;柳十四&quot;, 32, 5000, 1)
  if err != nil {
    log.Fatal(&quot;exec failed: &quot;, err)
  }
  lastId, err := res.LastInsertId()
  if err != nil {
    log.Fatal(&quot;fetch last insert id failed: &quot;, err)
  }
  rowCnt, err := res.RowsAffected()
  if err != nil {
    log.Fatal(&quot;fetch rows affected failed: &quot;, err)
  }
  log.Printf(&quot;ID = %d, affected = %d\n&quot;, lastId, rowCnt)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Exec&lt;/code&gt;方法返回一个&lt;code&gt;sql.Result&lt;/code&gt;接口类型的值：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;// src/database/sql/sql.go
type Result interface {
  LastInsertId() (int64, error)
  RowsAffected() (int64, error)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有些表设置了自增的 id，插入时不需要设置 id，数据库会自动生成一个返回。&lt;code&gt;LastInsertId()&lt;/code&gt;返回插入时生成的 id。&lt;br/&gt;&lt;code&gt;RowsAffected()&lt;/code&gt;返回受影响的行数。&lt;/p&gt;
&lt;p&gt;运行程序，输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2020/01/21 07:20:26 ID = 12, affected = 1&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;事务&quot;&gt;事务&lt;/h3&gt;
&lt;p&gt;在 Go 中，事务本质上是一个对象，它持有一个到数据库的连接。通过该对象执行我们上面介绍的方法时，&lt;br/&gt;都会使用这个相同的连接。调用&lt;code&gt;db.Begin()&lt;/code&gt;创建一个事务对象，然后在该对象上执行上面的方法，&lt;br/&gt;最后成功调用&lt;code&gt;Commit()&lt;/code&gt;，失败调用&lt;code&gt;Rollback()&lt;/code&gt;关闭事务。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func main() {
  db, err := sql.Open(&quot;mysql&quot;, &quot;root:12345@tcp(127.0.0.1:3306)/department&quot;)
  if err != nil {
    log.Fatal(&quot;open failed: &quot;, err)
  }
  defer db.Close()

  tx, err := db.Begin()
  if err != nil {
    log.Fatal(&quot;begin failed: &quot;, err)
  }
  defer tx.Rollback()


  stmt, err := tx.Prepare(&quot;UPDATE employees SET team_id=? WHERE id=?&quot;)
  if err != nil {
    log.Fatal(&quot;prepare failed: &quot;, err)
  }
  defer stmt.Close()

  _, err = stmt.Exec(2, 1)
  if err != nil {
    log.Fatal(&quot;exec failed: &quot;, err)
  }

  tx.Commit()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，在事务内部不能再直接调用&lt;code&gt;db&lt;/code&gt;的方法了，因为&lt;code&gt;db&lt;/code&gt;使用的是与事务不同的连接，可能会导致执行结果的不一致。&lt;/p&gt;
&lt;h3 id=&quot;错误处理&quot;&gt;错误处理&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;database/sql&lt;/code&gt;中几乎所有的操作最后一个返回值都是一个&lt;code&gt;error&lt;/code&gt;类型。数据库会出现各种各样的错误，我们应该时刻检查是否出现了错误。下面介绍几种特殊情况产生的错误。&lt;/p&gt;
&lt;h4 id=&quot;遍历结果集&quot;&gt;遍历结果集&lt;/h4&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;for rows.Next() {
  // ...
}

if err = rows.Err(); err != nil {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;`&lt;code&gt;rows.Err()&lt;/code&gt;返回的错误可能是&lt;code&gt;rows.Next()&lt;/code&gt;循环中的多种错误。循环可能由于某些原因提前退出了。我们应该检测循环是否正常退出。&lt;br/&gt;异常退出时，&lt;code&gt;database/sql&lt;/code&gt;会自动调用&lt;code&gt;rows.Close()&lt;/code&gt;。提前退出时，我们需要手动调用&lt;code&gt;rows.Close()&lt;/code&gt;。&lt;strong&gt;可以多次调用&lt;code&gt;rows.Close()&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;关闭结果集&quot;&gt;关闭结果集&lt;/h4&gt;
&lt;p&gt;实际上，&lt;code&gt;rows.Close()&lt;/code&gt;也返回一个错误。但是，对于这个错误，我们能做的事情比较有限。通常就是记录日志。&lt;br/&gt;如果不需要记录日志，通常会忽略这个错误。&lt;/p&gt;
&lt;h4 id=&quot;queryrow&quot;&gt;QueryRow&lt;/h4&gt;
&lt;p&gt;考虑下面的代码：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;var name string
err = db.QueryRow(&quot;SELECT name FROM employees WHERE id = ?&quot;, 1).Scan(&amp;amp;name)
if err != nil {
  log.Fatal(err)
}
fmt.Println(name)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果没有&lt;code&gt;id = 1&lt;/code&gt;的员工，&lt;code&gt;Scan()&lt;/code&gt;要如何处理？&lt;/p&gt;
&lt;p&gt;Go 定义了一个特殊的错误常量，&lt;code&gt;sql.ErrNoRows&lt;/code&gt;。如果没有符合要求的行，&lt;code&gt;QueryRow&lt;/code&gt;将返回这个错误。&lt;br/&gt;这个错误在大多数情况下需要特殊处理，因为没有结果在应用层通常不认为是错误。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;var name string
err = db.QueryRow(&quot;SELECT name FROM employees WHERE id = ?&quot;, 1).Scan(&amp;amp;name)
if err != nil {
  if err == sql.ErrNoRows {
  } else {
    log.Fatal(err)
  }
}
fmt.Println(name)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那为什么&lt;code&gt;QueryRow&lt;/code&gt;在没有符合要求的行时返回一个错误？&lt;/p&gt;
&lt;p&gt;因为要区分是否返回了行，如果返回空结果集，由于&lt;code&gt;Scan()&lt;/code&gt;不会做任何时间，我们就不能区分&lt;code&gt;name&lt;/code&gt;读取到了空字符串，还是初始值。&lt;/p&gt;
&lt;h4 id=&quot;特定的数据库错误&quot;&gt;特定的数据库错误&lt;/h4&gt;
&lt;p&gt;为了辨别发生了何种错误，有一种做法是检查错误描述中是否有特定的文本：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;rows, err := db.Query(&quot;SELECT someval FROM sometable&quot;)
if err != nil {
  if strings.Contains(err.Error(), &quot;Access denied&quot;) {
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是不推荐这种做法，因为不同的数据库版本，这些描述不一定能保持一致。&lt;/p&gt;
&lt;p&gt;比较好的做法是将错误转成特定数据库驱动的错误，然后比较错误码：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;if driverErr, ok := err.(*mysql.MySQLError); ok {
  if driverErr.Number == 1045 {
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不同驱动间判断方法可能不同。另外，直接写数字&lt;code&gt;1045&lt;/code&gt;也不太好，VividCortex 整理了 MySQL 错误码，GitHub 仓库为&lt;a href=&quot;https://github.com/VividCortex/mysqlerr&quot;&gt;mysqlerr&lt;/a&gt;。使用库后续便于修改：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;if driverErr, ok := err.(*mysql.MySQLError); ok {
  if driverErr.Number == mysqlerr.ER_ACCESS_DENIED_ERROR {
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;处理未知列&quot;&gt;处理未知列&lt;/h3&gt;
&lt;p&gt;有时候，可能我们不能确定查询返回多少列。但是&lt;code&gt;Scan()&lt;/code&gt;要求传入正确数量的参数。为此，我们可以先使用&lt;code&gt;rows.Columns()&lt;/code&gt;返回所有列名，然后创建同样大小的字符串指针切片传给&lt;code&gt;Scan()&lt;/code&gt;函数：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func main() {
  db, err := sql.Open(&quot;mysql&quot;, &quot;root:12345@tcp(127.0.0.1:3306)/department&quot;)
  if err != nil {
    log.Fatal(&quot;open failed: &quot;, err)
  }
  defer db.Close()

  stmt, err := db.Prepare(&quot;SELECT * FROM employees&quot;)
  if err != nil {
    log.Fatal(&quot;prepare failed: &quot;, err)
  }
  defer stmt.Close()

  rows, err := stmt.Query()
  if err != nil {
    log.Fatal(&quot;exec failed: &quot;, err)
  }
  defer rows.Close()

  cols, err := rows.Columns()
  if err != nil {
    log.Fatal(&quot;columns failed: &quot;, err)
  }

  data := make([]interface{}, len(cols), len(cols))
  for i := range data {
    data[i] = new(string)
  }

  for rows.Next() {
    err = rows.Scan(data...)
    if err != nil {
      log.Fatal(&quot;scan failed: &quot;, err)
    }

    for i := 0; i &amp;lt; len(cols); i++ {
      fmt.Printf(&quot;%s: %s &quot;, cols[i], *(data[i].(*string)))
    }
    fmt.Println()
  }

  if err = rows.Err(); err != nil {
    log.Fatal(err)
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;id: 1 name: 张三 age: 28 salary: 1200 team_id: 2 
id: 2 name: 李四 age: 38 salary: 4000 team_id: 1
id: 3 name: 王五 age: 36 salary: 3500 team_id: 1
id: 4 name: 赵六 age: 31 salary: 3100 team_id: 2
id: 5 name: 田七 age: 29 salary: 2900 team_id: 2 
id: 6 name: 吴八 age: 27 salary: 1500 team_id: 3
id: 7 name: 朱九 age: 26 salary: 1600 team_id: 3
id: 8 name: 钱十 age: 27 salary: 1800 team_id: 3
id: 9 name: 陶十一 age: 28 salary: 1900 team_id: 4
id: 10 name: 汪十二 age: 25 salary: 2000 team_id: 4
id: 11 name: 剑十三 age: 24 salary: 30000 team_id: 4
id: 12 name: 柳十四 age: 32 salary: 5000 team_id: 1&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;连接池&quot;&gt;连接池&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;database/sql&lt;/code&gt;实现了一个基本的连接池。连接池有一些有趣的特性，了解一下，避免踩坑：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对同一个数据库连续执行两个语句，这两个语句可能在不同的数据库连接上进行的。结果可能让人误解。例如先&lt;code&gt;LOCK TABLES&lt;/code&gt;，然后执行&lt;code&gt;INSERT&lt;/code&gt;可能会阻塞；&lt;/li&gt;
&lt;li&gt;需要新的连接且池中没有空闲连接时，创建一个新连接；&lt;/li&gt;
&lt;li&gt;默认，连接数没有限制。如果同时执行很多操作，可能会同时创建很多连接。数据库可能出现&lt;code&gt;too many connections&lt;/code&gt;错误；&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;db.SetMaxIdleConns(N)&lt;/code&gt;限制池中最大空闲连接数；&lt;code&gt;db.SetMaxOpenConns(N)&lt;/code&gt;限制所有打开的连接数；&lt;/li&gt;
&lt;li&gt;一个连接很长时间不使用可能会出现问题，如果遇到连接超时，可以试试将最大空闲连接数设置为 0；&lt;/li&gt;
&lt;li&gt;重用长时间存活的连接可能会导致网络问题，可以调用&lt;code&gt;db.SetConnMaxLifeTime(duration)&lt;/code&gt;设置连接最大存活时间。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文介绍了如何在 Go 中查询和修改数据库，主要是&lt;code&gt;database/sql&lt;/code&gt;和&lt;code&gt;go-sql-driver/mysql&lt;/code&gt;库的用法。&lt;code&gt;database/sql&lt;/code&gt;的接口并不复杂，但是很多细节需要注意。一不留神可能就有资源泄露。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.mysqltutorial.org/&quot;&gt;MySQL 教程&lt;/a&gt;，非常详细的教程&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://go-database-sql.org/&quot;&gt;Go database/sql 教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/05.0.md&quot;&gt;Build Web Application with Golang&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;我&quot;&gt;我&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://darjun.github.io&quot;&gt;我的博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎关注我的微信公众号【GoUpUp】，共同学习，一起进步~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1919725/202001/1919725-20200122062630989-595843453.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;4.1509433962264&quot;&gt;
&lt;p&gt;本文由博客一文多发平台 &lt;a href=&quot;https://openwrite.cn?from=article_bottom&quot;&gt;OpenWrite&lt;/a&gt; 发布！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 21 Jan 2020 22:27:00 +0000</pubDate>
<dc:creator>darjun</dc:creator>
<og:description>概述 数据库用来存储数据。只要不是玩具项目，每个项目都需要用到数据库。现在用的最多的还是 MySQL， &amp;quot;PostgreSQL&amp;quot; 的使用也在快速增长中。 在 Web 开发中，数据库</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/darjun/p/12227824.html</dc:identifier>
</item>
<item>
<title>重学数据结构 --- 分类+稀疏数组 - 老衲法号666</title>
<link>http://www.cnblogs.com/huaiangg/p/12227639.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huaiangg/p/12227639.html</guid>
<description>&lt;h2 id=&quot;数据结构两大类&quot;&gt;1. 数据结构两大类&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;线性结构&lt;/strong&gt;和&lt;strong&gt;非线性结构&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;线性结构&quot;&gt;1) 线性结构&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;线性结构是最常见的数据结构，特点是元素间存在一对一的线性关系。&lt;/li&gt;
&lt;li&gt;线性结构又分两种，一种是顺序存储（称为顺序表），另外一种是链式存储（称为链表）。顺序表中的存储元素的连续的。链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息。&lt;/li&gt;
&lt;li&gt;常见的线性结构有：数组、队列、链表和栈（这里只是讲个大概，具体内容后面的文章会展开阐述）。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;非线性结构&quot;&gt;2) 非线性结构&lt;/h3&gt;
&lt;p&gt;非线性结构就是结点元素可能存在多个直接前趋和多个直接后续（联想一下二叉树就懂了，但是非线性结构不仅仅只有二叉树）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;非线性结构包括：多维数组、广义表、树结构、图结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;稀疏数组sparse-array&quot;&gt;1. 稀疏数组(sparse array)&lt;/h2&gt;
&lt;h3 id=&quot;分析场景&quot;&gt;1) 分析场景&lt;/h3&gt;
&lt;p&gt;有这么一个场景，需要实现一个 10*10 的围棋的步数记录。那么最简单的就可以使用一个二维数组int[10][10]便可，但是在棋盘伊始，这个二维数组几乎没有意义的数据。假如能找到将这个二维数组压缩，只记录有用的数据的方法就好了。这时候稀疏数组就可以派上用场了。&lt;/p&gt;
&lt;h3 id=&quot;稀疏数组&quot;&gt;2) 稀疏数组&lt;/h3&gt;
&lt;p&gt;像上述棋盘，开始的时候，数据中记录的大部分元素为 0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。&lt;/p&gt;
&lt;h3 id=&quot;稀疏数组的处理方法是&quot;&gt;3) 稀疏数组的处理方法是：&lt;/h3&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li&gt;记录数组一共有几行几列，有多少个不同的值&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;把具有不同的元素的行列以及值记录在一个小规模的数组中，从而压缩小程序的规模。&lt;/p&gt;
&lt;h3 id=&quot;举个例子&quot;&gt;4) 举个例子：&lt;/h3&gt;
&lt;p&gt;假如有如下的 10*6的棋盘，用正整数表示落子顺序，使用稀疏数组压缩该棋盘则有右侧的表示。第 0 行，分别表示：行数，列数，总有多少个值。从第 1 行开始到最后，都表示行数，列数，数值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1865983/202001/1865983-20200122012126357-1159973057.png&quot; alt=&quot;稀疏数组&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如此一来，本来是 6&lt;em&gt;10 的数组就被压缩成 3&lt;/em&gt;7，大大节省了内存空间。&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;5) 代码实现&lt;/h3&gt;
&lt;h4 id=&quot;思路分析&quot;&gt;思路分析&lt;/h4&gt;
&lt;h5 id=&quot;二维数组转稀疏数组&quot;&gt;(1) 二维数组转稀疏数组&lt;/h5&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;遍历原始二维数组，得到有效数据的个数 sum&lt;/li&gt;
&lt;li&gt;创建稀疏数组 sparseArr[sum+1][3]&lt;/li&gt;
&lt;li&gt;把有效数据逐个填入稀疏数组 sparseArr 中&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;代码实现：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
* 二维数组转稀疏数组
* 
* @param arr 原数组
* @return 稀疏数组
*/
public int[][] reserveSparseArray(int[][] arr) {
    // 统计有效数据
    int sum = 0;
    // 遍历稀疏数组
    for (int[] is : arr) {
        for (int num : is) {
            if (num != 0) {
                sum++;
            }
        }
    }
    // 创建稀疏数组
    int[][] sparseArr = new int[sum + 1][3];
    sparseArr[0][0] = arr.length;
    sparseArr[0][1] = arr[0].length;
    sparseArr[0][2] = sum;
    for (int i = 0; i &amp;lt; arr.length; i++) {
        for (int j = 0; j &amp;lt; arr[i].length; j++) {
            if (arr[i][j] != 0) {
                sparseArr[sum][0] = i;
                sparseArr[sum][1] = j;
                sparseArr[sum][2] = arr[i][j];
                sum--;
            }
        }
    }
    return sparseArr;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;稀疏数组转原始数组&quot;&gt;(2) 稀疏数组转原始数组&lt;/h5&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;读取稀疏数组的第 1 行，取出第一 row、第二个数 col，创建二维数组 shessArr[row][col]&lt;/li&gt;
&lt;li&gt;遍历稀疏数组后面几行，把有效值填入原数组 chessArr&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;代码实现：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
* 稀疏数组转二位数组
* 
* @param sparseArr 稀疏数组
* @return 原数组
*/
public static int[][] reserveOriginalArray(int[][] sparseArr) {
    // 根据稀疏数组第一行创建原数组
    int[][] originalArr = new int[sparseArr[0][0]][sparseArr[0][1]];
    // 把稀疏数组的值放回到原数组中
    for (int i = 1; i &amp;lt; sparseArr.length; i++) {
        int row = sparseArr[i][0];
        int col = sparseArr[i][1];
        int value = sparseArr[i][2];
        originalArr[row][col] = value;
    }
    return originalArr;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;人若无名，专心练剑！&lt;br/&gt;喜欢的朋友可以留下你的赞！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 21 Jan 2020 17:21:00 +0000</pubDate>
<dc:creator>老衲法号666</dc:creator>
<og:description>一、数据结构的分类 1. 数据结构两大类 线性结构 和 非线性结构 1) 线性结构 线性结构是最常见的数据结构，特点是元素间存在一对一的线性关系。 线性结构又分两种，一种是顺序存储（称为顺序表），另外</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huaiangg/p/12227639.html</dc:identifier>
</item>
<item>
<title>机器学习-决策树 Decision Tree - HappyPuppy</title>
<link>http://www.cnblogs.com/tangxiaobo199181/p/12227543.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tangxiaobo199181/p/12227543.html</guid>
<description>&lt;p&gt;咱们正式进入了机器学习的模型的部分，虽然现在最火的的机器学习方面的库是Tensorflow, 但是这里还是先简单介绍一下另一个数据处理方面很火的库叫做sklearn。其实咱们在前面已经介绍了一点点sklearn，主要是在categorical data encoding那一块。其实sklearn在数据建模方面也是非常666的。一般常用的模型都可以用sklearn来做的。既然它都这么牛逼了，咱们为啥还要学TensorFlow呢？其实主要的原因有两个，一是因为Google在流量方面的强势推广，导致绝大部分的机器学习方面的应用都是用TensorFlow, 二是因为TensorFlow包括的常用库确实要更加多一点。所以导致现在TensorFlow直接火到爆。所以sklearn在模型方面的应用，咱们只在决策树这里讲一下，都免绝大部分的模型还是用TensorFlow来解释，毕竟它的市场更加大嘛。这里没有啥好坏之分的，他们的API都写的很清楚，无论选什么框架，大家自己起看看文档都可以的。这节内容主要分两部分，第一部分介绍决策树在sklearn中的应用，第二部分作为补充内容介绍决策树的原理（决策树的构建原理）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Decision Tree 在sklearn中的实现&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;决策树其实很简单，就是将一条数据中的每一个feature作为一个node，然后根据不同的条件分成不同的分支branch，每一个branch还有一个node，这个node可能还是feature也可能是leave（target）。具体一个决策树种有多少个node，有多少个leaves，咱们后面再说，这设计到了很多概率和信息熵方面的知识。咱们现在只需要知道一个大致的概念就是，决策树中的node是咱们的feature，leaves是咱们的target，branch是咱们的split conditions 就行了，具体其中的细节咱们暂时不需要了解，咱们这里的重点是如何用sklearn这个框架搭建出咱们的决策树模型。咱们这里先直接用一个代码示例来展示，然后再来解释他的过程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; sklearn.tree &lt;span&gt;import&lt;/span&gt;&lt;span&gt; DecisionTreeRegressor
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;1.Define&lt;/span&gt;
melb_model =&lt;span&gt; DecisionTreeRegressor()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;2. fit&lt;/span&gt;
&lt;span&gt;melb_model.fit(X,y)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;3. predict&lt;/span&gt;
melb_house_prediction =&lt;span&gt; melb_model.predict(X)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;4.Mean Absolute Error (MAE)&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; sklearn.metrics &lt;span&gt;import&lt;/span&gt;&lt;span&gt; mean_absolute_error
mean_absolute_error(y,melb_house_prediction)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面是一个最简单的用sklearn建模一个decision tree的实例了，其总共包括：实例化决策树，训练决策树，预测，和验证四个步骤。当然在实际中会有很多的细节部分需要处理，例如第一步实例化的过程有可能会有很多的参数需要调整，如max_depth, min_sample_split等等这些参数，这些都需要根据咱们后面的模型表现来不断的调整； 其次在验证阶段也是的，咱们得把咱们的数据集分割成training dataset和validation dataset, 这里面也包括了很多技术来分割和random的；具体这些细节，咱们在后面遇到了再说哈。对于绝大部分的决策树模型，咱们都可以用上面的4个步骤来创建。既然说到这里了，咱现在也就简单的数据分割的api也给大家展示一下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; sklearn.model_selection &lt;span&gt;import&lt;/span&gt;&lt;span&gt; train_test_split
train_X, validate_X, train_y, validate_y &lt;/span&gt;= train_test_split(X,y,random_state=0)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面是一个最简单的数据分割代码，默认是将（X，y）按照80%，20%比例分割，分别用于training和validation；当然啦，这里的分割比例也可以自行通过train_test_split函数的参数进行调节。random_state是当做random generator的seed，是将数据打乱后在分割。既然如何用sklearn建模决策树的内容讲了，咱们也顺带把random forest 随机森林模型在sklearn中如何建模的内容也说了把，毕竟random forest是基于decision tree的，而且random forest建模过程跟decision tree几乎是一模一样的，见下面代码展示如何创建random forest的，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; sklearn.model_selection &lt;span&gt;import&lt;/span&gt;&lt;span&gt; train_test_split
train_X, val_X, train_y, val_y &lt;/span&gt;= train_test_split(X, y, random_state = 1&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.ensemble &lt;span&gt;import&lt;/span&gt;&lt;span&gt; RandomForestRegressor
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;define&lt;/span&gt;
melb_model = RandomForestRegressor(random_state=1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;training&lt;/span&gt;
&lt;span&gt;melb_model.fit(train_X,train_y)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;prediction&lt;/span&gt;
predictions =&lt;span&gt; melb_model.predict(val_X)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;validation&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; sklearn.metrics &lt;span&gt;import&lt;/span&gt;&lt;span&gt; mean_absolute_error
mae &lt;/span&gt;= mean_absolute_error(val_y, predictions)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在解释上面的代码之前，咱们先来说说什么是random forest。大家想一想，既然前面咱们创建了一颗决策树，那咱们就自然而然的可以建造许多的决策树然后就可以创建一个森林啦，就叫做随机森林。用random forest预测的时候，咱们就把test data放进这个随机森林的每一颗树里面去预测，最后咱们取预测的平均值。就是怎么简单so easy。咱们现在就理解到这个程度就够了，实际的底层的创建原理，等咱们把decision tree的创建原理弄懂了以后大家就知道了。咱们看上面的代码，它跟decision tree只有几个小区别，第一个就是random forest是一个ensemble，相当于把许多小decision tree模型打包成了一个ensemble；第二个就是他的实例化名称是RandomForestRegressor。其他都差不多，大家在这里不需要死记硬背这些代码，关键要了解这里面的每一步有什么作用，为什么需要这些步骤就行了。再一个就是一定得对decision tree和random forest的结构从上层有一个大致的了解，对于他们的底层细节结构，咱们可以看看下面的一部分。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;决策树的创建原理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于在博客中画图不方便，我特地花了一张解释decision tree创建原理的一张图，然后这部分内容主要是围绕着这张图作为一个解释。这里面还涉及到一些数学计算和概率的一些内容。所以这幅图的信息量还是蛮大的。其实说白了，这里讲决策树的创建原理实际上就是解释如何每一步从n个features中选择一个特点的feature作为node，具体是根据一个什么指标来选择feature作为node的。好了废话不多说，直接上图啦&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1287224/202001/1287224-20200122002305352-1584453887.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 先来解释一下一个简单的概念，就是entropy, 中文咱们可以称作是信息熵。它是一种衡量信息量的值，具体这个值是怎么的计算的咱们可以看上面的图片，我上面的图片还配备了一个简单的数字实例给演示。在正式解释之前咱们先来问一问咱们自己一个最基本的问题，那就是decision tree到底是来干什么的？？？decision tree最本质的功能是根据feature的条件来最终分离出不同的信息（这里的信息咱们可以理解为target）。因而这里信息熵咱们可以理解为这一组数据可以被分辨（分离的）能力，信息熵越小，越容易被分辨，信息熵越大（1），就越难被分辨出来。Information Gain是父节点的信息熵跟他子节点信息熵之差， I（A）的值越大，则说明从这个节点获取的信息就越大，那么就选这个获取信息量越大的feature。这个过程就是决策树中选择feature的方法。如果上面的理解了，咱们也就顺理成章的理解了是如何构建decision tree和random forest的了，他们之间还有一个小区别是，decision tree每一个都要算每一个feature的Information Gain然后才来选择Information Gain最大的那个feature；而random forest创建它的每一颗tree的过程则是每一步都是随机选几个features来就算Information Gain,然后选最大的，从而确保了tree的多样性。&lt;/p&gt;
</description>
<pubDate>Tue, 21 Jan 2020 16:43:00 +0000</pubDate>
<dc:creator>HappyPuppy</dc:creator>
<og:description>咱们正式进入了机器学习的模型的部分，虽然现在最火的的机器学习方面的库是Tensorflow, 但是这里还是先简单介绍一下另一个数据处理方面很火的库叫做sklearn。其实咱们在前面已经介绍了一点点sk</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tangxiaobo199181/p/12227543.html</dc:identifier>
</item>
<item>
<title>Matplotlib从兴趣到实践 - Super~me</title>
<link>http://www.cnblogs.com/supershuai/p/12227461.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/supershuai/p/12227461.html</guid>
<description>&lt;p&gt;先看下Matplotlib实现的效果&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/989555/202001/989555-20200121235908788-1468442473.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是不是出现了也想敲一个的心动，那让我们一起来了解Matplotlib吧&lt;/p&gt;
&lt;h2 id=&quot;matplotlib安装&quot;&gt;Matplotlib安装&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.Windows系统安装Matplotlib&lt;/strong&gt;&lt;br/&gt;进入到cmd的命令界面，输入以下命令：&lt;br/&gt;&lt;code&gt;python -m pip install -U pip setuptools&lt;/code&gt;&lt;br/&gt;&lt;code&gt;python -m pip install matplotlibm&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.Linux系统安装Matplotlib&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Ubuntu: &lt;code&gt;sudo apt-get install python-matplotlib&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Redhat: &lt;code&gt;sudo yum install python-matplotlib&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Mac OSX 系统安装 Matplotlib&lt;/strong&gt;&lt;br/&gt;可以使用 pip 命令来安装：&lt;code&gt;sudo python -mpip install matplotlib&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;图文显示&quot;&gt;图文显示&lt;/h2&gt;
&lt;p&gt;首先我们需要下载中文包：&lt;a href=&quot;https://www.fontpalace.com/font-details/SimHei/&quot;&gt;ShiHei字体包&lt;/a&gt; 将下载的字体包放置到项目目录中&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/989555/202001/989555-20200121222715597-1515442572.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import matplotlib
import numpy as np
from matplotlib import pyplot as plt

zhfont1 = matplotlib.font_manager.FontProperties(fname=&quot;SimHei.ttf&quot;)
x=np.array([1,2,3,4,5,6,7,8])
y = 2 * x + 5
plt.title(&quot;我的 - 测试&quot;, fontproperties=zhfont1)

fontproperties 设置中文显示，fontsize 设置字体大小
plt.xlabel(&quot;x 轴&quot;, fontproperties=zhfont1)
plt.ylabel(&quot;y 轴&quot;, fontproperties=zhfont1)
plt.plot(x, y,&quot;-b&quot;)
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/989555/202001/989555-20200121211754436-66795423.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从执行结果来看不难分析出pil.xlable实现的是定义x轴的默认显示，ylabel定义的是y轴的显示 ，plot(x,y,'-b')中定义的是x y轴的数据以及显示的颜色和样式信息。&lt;br/&gt;其中具体的样式和颜色信息的设置参数如下&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;'-'&lt;/td&gt;
&lt;td&gt;实线样式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;'--'&lt;/td&gt;
&lt;td&gt;短横线样式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;'-.'&lt;/td&gt;
&lt;td&gt;点划线样式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;':'&lt;/td&gt;
&lt;td&gt;虚线样式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;'.'&lt;/td&gt;
&lt;td&gt;点标记&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;','&lt;/td&gt;
&lt;td&gt;像素标记&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;'o'&lt;/td&gt;
&lt;td&gt;圆标记&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;'v'&lt;/td&gt;
&lt;td&gt;倒三角标记&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;'^'&lt;/td&gt;
&lt;td&gt;正三角标记&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;'&amp;lt;'&lt;/td&gt;
&lt;td&gt;左三角标记&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;'&amp;gt;'&lt;/td&gt;
&lt;td&gt;右三角标记&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;'1'&lt;/td&gt;
&lt;td&gt;下箭头标记&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;'2'&lt;/td&gt;
&lt;td&gt;上箭头标记&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;'3'&lt;/td&gt;
&lt;td&gt;左箭头标记&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;'4'&lt;/td&gt;
&lt;td&gt;右箭头标记&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;'s'&lt;/td&gt;
&lt;td&gt;正方形标记&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;'p'&lt;/td&gt;
&lt;td&gt;五边形标记&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;'*'&lt;/td&gt;
&lt;td&gt;星形标记&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;'h'&lt;/td&gt;
&lt;td&gt;六边形标记 1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;'H'&lt;/td&gt;
&lt;td&gt;六边形标记 2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;'+'&lt;/td&gt;
&lt;td&gt;加号标记&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;'x'&lt;/td&gt;
&lt;td&gt;X 标记&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;'D'&lt;/td&gt;
&lt;td&gt;菱形标记&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;'d'&lt;/td&gt;
&lt;td&gt;窄菱形标记&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;'|'&lt;/td&gt;
&lt;td&gt;竖直线标记&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;'_'&lt;/td&gt;
&lt;td&gt;水平线标记&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;'b'&lt;/td&gt;
&lt;td&gt;蓝色&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;'g'&lt;/td&gt;
&lt;td&gt;绿色&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;'r'&lt;/td&gt;
&lt;td&gt;红色&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;'c'&lt;/td&gt;
&lt;td&gt;青色&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;'m'&lt;/td&gt;
&lt;td&gt;品红色&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;'y'&lt;/td&gt;
&lt;td&gt;黄色&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;'k'&lt;/td&gt;
&lt;td&gt;黑色&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;'w'&lt;/td&gt;
&lt;td&gt;白色&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;下面我们可以运用numpy的相关知识绘制各种图像&quot;&gt;下面我们可以运用Numpy的相关知识绘制各种图像&lt;/h2&gt;
&lt;p&gt;我们的目的重点不是编写各种的图像，而是了解绘图的原理，通过学习能够绘制根据自己需要的图像（学习matplotlib前建议要学习Numpy的知识）&lt;/p&gt;
&lt;h3 id=&quot;绘制正弦波&quot;&gt;绘制正弦波&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;#计算正弦曲线上点的 x 和 y 坐标
x = np.arange(0,  3  * np.pi,  0.1) 
y = np.sin(x)
plt.title(&quot;sine wave form&quot;)  
#使用 matplotlib 来绘制点
plt.plot(x, y) 
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/989555/202001/989555-20200121215101617-559904918.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该代码中 x是一个数组，它是借助numpy.arange()方法实现0-（3*圆周率）的范围内每间隔0.1生成一个点&lt;br/&gt;&lt;code&gt;y = np.sin(x)&lt;/code&gt;&lt;br/&gt;表示的是运用正弦函数生成与x轴点一 一对应的y轴的点，最后使用matplotlib的plot方法绘制出来相应的图像。&lt;/p&gt;
&lt;h3 id=&quot;绘制同一窗口中不同的图像&quot;&gt;绘制同一窗口中不同的图像&lt;/h3&gt;
&lt;p&gt;实现多个图像的绘制就要用的matplotlib的subplot（）函数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#aubplot参数解释 以下创建的是一个高度为2，宽度为1，的第1个图像
plt.subplot(2, 1, 1)
#将第一个图像绘制出来
plt.plot(x,y_sin)
plt.title('Sin')
#aubplot参数解释 以下创建的是一个高度为2，宽度为1，的第2个图像
plt.subplot(2, 1, 2)
#将第二个图像绘制出来
plt.plot(x,y_cos)
plt.title('Cos')
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/989555/202001/989555-20200121222938247-187394225.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;绘制条形图&quot;&gt;绘制条形图&lt;/h3&gt;
&lt;p&gt;绘制条形图需要用到matplotlib的bar()函数生成条形图，使用原来与上面的图像绘制一样，不同的是方法产生的效果&lt;br/&gt;可以通过以下代码来进一步加深图像绘制的印象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 条形图 bar
x = [5,8,10]
y = [12,16,6]
x2 = [6,9,11]
y2 = [6,15,7]
plt.bar(x, y, align='center')
plt.bar(x2, y2, color='y', align='center')
plt.title('条形图', fontproperties=zhfont1)
plt.ylabel('Y 轴', fontproperties=zhfont1)
plt.xlabel('X 轴', fontproperties=zhfont1)
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/989555/202001/989555-20200121223939266-1194094141.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;绘制直方图&quot;&gt;绘制直方图&lt;/h3&gt;
&lt;p&gt;hist()函数可以将将数据和bin参数作为参数，并且能够转化为直方图&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 直方图 plt()
a = np.array([21,99,1,46,88,77,15,24,11,61,66,67,68,30,41,55,18,31,90,26])
plt.hist(a, color='g', bins=[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100])
plt.title(&quot;histogram&quot;)
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/989555/202001/989555-20200121225404528-1101077462.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;扩展&quot;&gt;扩展&lt;/h2&gt;
&lt;p&gt;关于matplotlib绘图的常用配置说明&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 导入 matplotlib 的所有内容（nympy 可以用 np 这个名字来使用）
from pylab import *

# 创建一个 8 * 6 点（point）的图，并设置分辨率为 80
figure(figsize=(8,6), dpi=80)

# 创建一个新的 1 * 1 的子图，接下来的图样绘制在其中的第 1 块（也是唯一的一块）
subplot(1,1,1)

X = np.linspace(-np.pi, np.pi, 256,endpoint=True)
C,S = np.cos(X), np.sin(X)

# 绘制余弦曲线，使用蓝色的、连续的、宽度为 1 （像素）的线条
plot(X, C, color=&quot;blue&quot;, linewidth=1.0, linestyle=&quot;-&quot;)

# 绘制正弦曲线，使用绿色的、连续的、宽度为 1 （像素）的线条
plot(X, S, color=&quot;green&quot;, linewidth=1.0, linestyle=&quot;-&quot;)

# 设置横轴的上下限
xlim(-4.0,4.0)  /plt.xlim(X.min()*1.1, X.max()*1.1)

# 设置横轴记号
xticks(np.linspace(-4,4,9,endpoint=True))

# 设置纵轴的上下限
ylim(-1.0,1.0)

# 设置纵轴记号
yticks(np.linspace(-1,1,5,endpoint=True))

#添加图例 可以指定图例的位置
plt.legend(loc='upper left', frameon=False)

# 以分辨率 72 来保存图片
# savefig(&quot;exercice_2.png&quot;,dpi=72)

# 在屏幕上显示
show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是一个综合运用的实例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 绘制正弦波
# 计算正弦曲线上点的 x 和 y 坐标
x = np.linspace(-np.pi, np.pi, 256,endpoint=True)
y = np.sin(x)
C,S = np.cos(x), np.sin(x)
plt.title(&quot;sine wave form&quot;)
# 使用 matplotlib 来绘制点
plt.plot(x, C, color=&quot;blue&quot;, linewidth=2.5, linestyle=&quot;-&quot;, label=&quot;cosine&quot;)
plt.plot(x, S, color=&quot;red&quot;, linewidth=2.5, linestyle=&quot;-&quot;, label=&quot;sine&quot;)
#以下是对边界的设置
plt.xlim(x.min()*1.1, x.max()*1.1)
#以下是对x轴的记号设置
plt.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi],
           [r'$-\pi$', r'$-\pi/2$', r'$0$', r'$+\pi/2$', r'$+\pi$'])
#以下是对y轴的记号设置
plt.ylim(C.min()*1.1,C.max()*1.1)
plt.yticks([-1, +1],
           [r'$-1$', r'$+1$'])
#以下是对label图例位置进行设置
plt.legend(loc='upper left', frameon=False)
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/989555/202001/989555-20200121232501033-731390094.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面一个是使用matplotlib中的pie()函数实现的饼状图的实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;n = 20
Z = np.random.uniform(0,1,n)
plt.pie(Z) 
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/989555/202001/989555-20200121233229643-1030660802.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也可以用来实现一些3D的图像效果，下面是一个实现的实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from pylab import *
from mpl_toolkits.mplot3d import Axes3D

fig = figure()
ax = Axes3D(fig)
X = np.arange(-4, 4, 0.25)
Y = np.arange(-4, 4, 0.25)
X, Y = np.meshgrid(X, Y)
R = np.sqrt(X**2 + Y**2)
Z = np.sin(R)
ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap='hot')
plt.savefig('sample.png', bbox_inches=&quot;tight&quot;)
show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/989555/202001/989555-20200121235202587-831451293.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是不是&lt;/p&gt;
</description>
<pubDate>Tue, 21 Jan 2020 16:05:00 +0000</pubDate>
<dc:creator>Super~me</dc:creator>
<og:description>先看下Matplotlib实现的效果 是不是出现了也想敲一个的心动，那让我们一起来了解Matplotlib吧 Matplotlib安装 1.Windows系统安装Matplotlib 进入到cmd的命</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/supershuai/p/12227461.html</dc:identifier>
</item>
<item>
<title>搞定SpringBoot多数据源(3)：参数化变更源 - Mason技术记录</title>
<link>http://www.cnblogs.com/masonlee/p/12227360.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/masonlee/p/12227360.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://gitee.com/mianshenglee/datastorage/raw/master/md-photo/multi-datasource/2020-spring-festivel.jpg&quot; alt=&quot;2020鼠年大吉&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;春节将至，今天放假了，在此祝小伙伴们新春大吉，身体健康，思路清晰，永远无BUG！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;一句话概括：参数化变更源意思是根据参数动态添加数据源以及切换数据源，解决不确定数据源的问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;经过前面两篇文章对于 Spring Boot 处理多个数据库的策略讲解，相信大家已经对多数据源和动态数据源有了比较好的了解。如需回顾，请见：&lt;/p&gt;
&lt;p&gt;在前面文章中，留了一个思考题，无论是多套源还是动态数据源，相对来说还是固定的数据源（如一主一从，一主多从等），即在编码时已经确定的数据库数量，只是在具体使用哪一个时进行动态处理。如果数据源本身并不确定，或者说需要根据用户输入来连接数据库，这时，如何处理呢？可以想象现在我们有一个需求，需要对数据库进行连接管理，用户可以输入对应的数据库连接信息，然后可以查看数据库有哪些表。这就跟平时使用的数据库管理软件有点类似了，如 MySQL Workbench、Navicat、SQLyog，下图是SQLyog截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/mianshenglee/datastorage/raw/master/md-photo/multi-datasource/connect.png&quot; alt=&quot;SQLyog&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文基于前面的示例，添加一个功能，根据用户输入的数据库连接信息，连接数据库，并返回数据库的表信息。内容包括动态添加数据源、动态代理简化数据源操作等。&lt;/p&gt;
&lt;p&gt;本文所涉及到的&lt;a href=&quot;https://github.com/mianshenglee/my-example/tree/master/multi-datasource&quot;&gt;示例代码&lt;/a&gt;:&lt;code&gt;https://github.com/mianshenglee/my-example/tree/master/multi-datasource&lt;/code&gt;，读者可结合一起看。&lt;/p&gt;

&lt;h2 id=&quot;解决思路&quot;&gt;2.1 解决思路&lt;/h2&gt;
&lt;p&gt;Spring Boot 的动态数据源，本质上是把多个数据源存储在一个 Map 中，当需要使用某个数据源时，从 Map 中获取此数据源进行处理。在动态数据源处理时，通过继承抽象类 &lt;code&gt;AbstractRoutingDataSource&lt;/code&gt; 可实现此功能。既然是 Map ，如果有新的数据源，把新的数据源添加到此 Map 中就可以了。这就是整个解决思路。&lt;/p&gt;
&lt;p&gt;但是，查看 &lt;code&gt;AbstractRoutingDataSource&lt;/code&gt; 源码，可以发现，存放数据源的 Map &lt;code&gt;targetDataSources&lt;/code&gt; 是 private 的，而且并没有提供对此 Map 本身的操作，它提供的是两个关键操作：&lt;code&gt;setTargetDataSources&lt;/code&gt; 及 &lt;code&gt;afterPropertiesSet&lt;/code&gt; 。其中 &lt;code&gt;setTargetDataSources&lt;/code&gt; 设置整个 Map 目标数据源，&lt;code&gt;afterPropertiesSet&lt;/code&gt; 则是对 Map 目标数据源进行解析，形成最终使用的 &lt;code&gt;resolvedDataSources&lt;/code&gt;，可见以下源码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;this.resolvedDataSources = new HashMap(this.targetDataSources.size());
this.targetDataSources.forEach((key, value) -&amp;gt; {
    Object lookupKey = this.resolveSpecifiedLookupKey(key);
    DataSource dataSource = this.resolveSpecifiedDataSource(value);
    this.resolvedDataSources.put(lookupKey, dataSource);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此，为实现动态添加数据源到 Map 的功能，我们可以根据这两个关键操作进行处理。&lt;/p&gt;
&lt;h2 id=&quot;流程说明&quot;&gt;2.2 流程说明&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;用户输入数据库连接参数（包括IP、端口、驱动名、数据库名、用户名、密码）&lt;/li&gt;
&lt;li&gt;根据数据库连接参数创建数据源&lt;/li&gt;
&lt;li&gt;添加数据源到动态数据源中&lt;/li&gt;
&lt;li&gt;切换数据源&lt;/li&gt;
&lt;li&gt;操作数据库&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;说明，下面的操作基于之前文章的示例，基本的工程搭建及配置不再重复说明，有需要可参考文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;改造动态数据源&quot;&gt;3.1 改造动态数据源&lt;/h2&gt;
&lt;h3 id=&quot;动态数据源添加功能&quot;&gt;3.1.1 动态数据源添加功能&lt;/h3&gt;
&lt;p&gt;为了可以动态添加数据源到 Map ，我们需要对动态数据源进行改造。如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DynamicDataSource extends AbstractRoutingDataSource {
    private Map&amp;lt;Object, Object&amp;gt; backupTargetDataSources;

    /**
     * 自定义构造函数
     */
    public DynamicDataSource(DataSource defaultDataSource,Map&amp;lt;Object, Object&amp;gt; targetDataSource){
        backupTargetDataSources = targetDataSource;
        super.setDefaultTargetDataSource(defaultDataSource);
        super.setTargetDataSources(backupTargetDataSources);
        super.afterPropertiesSet();
    }

    /**
     * 添加新数据源
     */
    public void addDataSource(String key, DataSource dataSource){
        this.backupTargetDataSources.put(key,dataSource);
        super.setTargetDataSources(this.backupTargetDataSources);
        super.afterPropertiesSet();
    }

    @Override
    protected Object determineCurrentLookupKey() {
        return DynamicDataSourceContextHolder.getContextKey();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;添加了自定义的 &lt;code&gt;backupTargetDataSources&lt;/code&gt; 作为原 &lt;code&gt;targetDataSources&lt;/code&gt; 的拷贝&lt;/li&gt;
&lt;li&gt;自定义构造函数，把需要保存的目标数据源拷贝到自定义的 Map 中&lt;/li&gt;
&lt;li&gt;添加新数据源时，依然使用 &lt;code&gt;setTargetDataSources&lt;/code&gt; 及 &lt;code&gt;afterPropertiesSet&lt;/code&gt; 完成新数据源添加。&lt;/li&gt;
&lt;li&gt;注意：&lt;code&gt;afterPropertiesSet&lt;/code&gt; 的作用很重要，它负责解析成可用的目标数据源。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;动态数据源配置&quot;&gt;3.1.2 动态数据源配置&lt;/h3&gt;
&lt;p&gt;原来在创建动态数据源时，使用的是无参数构造函数，经过前面改造后，使用有参构造函数，如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Bean
@Primary
public DataSource dynamicDataSource() {
    Map&amp;lt;Object, Object&amp;gt; dataSourceMap = new HashMap&amp;lt;&amp;gt;(2);
    dataSourceMap.put(DataSourceConstants.DS_KEY_MASTER, masterDataSource());
    dataSourceMap.put(DataSourceConstants.DS_KEY_SLAVE, slaveDataSource());
    //有参构造函数
    return new DynamicDataSource(masterDataSource(), dataSourceMap);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;添加数据源工具类&quot;&gt;3.2 添加数据源工具类&lt;/h2&gt;
&lt;h3 id=&quot;spring-上下文工具类&quot;&gt;3.2.1 Spring 上下文工具类&lt;/h3&gt;
&lt;p&gt;在Spring Boot 使用过程中，经常会用到 Spring 的上下文，常见的就是从 Spring 的 IOC 中获取 bean 来进行操作。由于 Spring 使用的 IOC 基本上把 bean 都注入到容器中，因此需要 Spring 上下文来获取。我们在 context 包下添加 &lt;code&gt;SpringContextHolder&lt;/code&gt; ，如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
public class SpringContextHolder implements ApplicationContextAware {
    private static ApplicationContext applicationContext;
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        SpringContextHolder.applicationContext = applicationContext;
    }
    /**
     * 返回上下文
     */
    public static ApplicationContext getContext(){
        return SpringContextHolder.applicationContext;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 &lt;code&gt;getContext&lt;/code&gt; 就可以获取上下文，进而操作。&lt;/p&gt;
&lt;h3 id=&quot;数据源操作工具&quot;&gt;3.2.2 数据源操作工具&lt;/h3&gt;
&lt;p&gt;通过参数添加数据源，需要根据参数构造数据源，然后添加到前面说的 Map 中。如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DataSourceUtil {
    /**
     * 创建新的数据源，注意：此处只针对 MySQL 数据库
     */
    public static DataSource makeNewDataSource(DbInfo dbInfo){
        String url = &quot;jdbc:mysql://&quot;+dbInfo.getIp() + &quot;:&quot;+dbInfo.getPort()+&quot;/&quot;+dbInfo.getDbName()
                +&quot;?useSSL=false&amp;amp;serverTimezone=GMT%2B8&amp;amp;characterEncoding=UTF-8&quot;;
        String driveClassName = StringUtils.isEmpty(dbInfo.getDriveClassName())? &quot;com.mysql.cj.jdbc.Driver&quot;:dbInfo.getDriveClassName();
        return DataSourceBuilder.create().url(url)
                .driverClassName(driveClassName)
                .username(dbInfo.getUsername())
                .password(dbInfo.getPassword())
                .build();
    }

    /**
     * 添加数据源到动态源中
     */
    public static void addDataSourceToDynamic(String key, DataSource dataSource){
        DynamicDataSource dynamicDataSource = SpringContextHolder.getContext().getBean(DynamicDataSource.class);
        dynamicDataSource.addDataSource(key,dataSource);
    }

    /**
     * 根据数据库连接信息添加数据源到动态源中
     * @param key
     * @param dbInfo
     */
    public static void addDataSourceToDynamic(String key, DbInfo dbInfo){
        DataSource dataSource = makeNewDataSource(dbInfo);
        addDataSourceToDynamic(key,dataSource);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;通过 &lt;code&gt;DataSourceBuilder&lt;/code&gt; 及相应的参数来构造数据源，注意此处只针对 MySQL 作处理，其它数据库的话，对应的 url 及 DriveClassName 需作相应的变更。&lt;/li&gt;
&lt;li&gt;添加数据源时，通过 Spring 上下文获取动态数据源的 bean，然后添加。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;使用参数变更数据源&quot;&gt;3.3 使用参数变更数据源&lt;/h2&gt;
&lt;p&gt;前面两步已实现添加数据源，下面我们根据需求（根据用户输入的数据库连接信息，连接数据库，并返回数据库的表信息），看看如何使用它。&lt;/p&gt;
&lt;h3 id=&quot;添加查询数据库表信息的-mapper&quot;&gt;3.3.1 添加查询数据库表信息的 Mapper&lt;/h3&gt;
&lt;p&gt;通过 MySQL 的 &lt;code&gt;information_schema&lt;/code&gt; 可以获取表信息。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Repository
public interface TableMapper extends BaseMapper&amp;lt;TestUser&amp;gt; {
    /**
     * 查询表信息
     */
    @Select(&quot;select table_name, table_comment, create_time, update_time &quot; +
            &quot; from information_schema.tables &quot; +
            &quot; where table_schema = (select database())&quot;)
    List&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt; selectTableList();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;定义数据库连接信息对象&quot;&gt;3.3.2 定义数据库连接信息对象&lt;/h3&gt;
&lt;p&gt;把数据库连接信息通过一个类进行封装。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Data
public class DbInfo {
    private String ip;
    private String port;
    private String dbName;
    private String driveClassName;
    private String username;
    private String password;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;参数化变更源并查询表信息&quot;&gt;3.3.3 参数化变更源并查询表信息&lt;/h3&gt;
&lt;p&gt;在 controller 层，我们定义一个查询表信息的接口，根据传入的参数，连接数据源，返回表信息：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 根据数据库连接信息获取表信息
 */
@GetMapping(&quot;table&quot;)
public Object findWithDbInfo(DbInfo dbInfo) throws Exception {
    //数据源key
    String newDsKey = System.currentTimeMillis()+&quot;&quot;;
    //添加数据源
    DataSourceUtil.addDataSourceToDynamic(newDsKey,dbInfo);
    DynamicDataSourceContextHolder.setContextKey(newDsKey);
    //查询表信息
    List&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; tables = tableMapper.selectTableList();
    DynamicDataSourceContextHolder.removeContextKey();
    return ResponseResult.success(tables);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;访问地址 &lt;code&gt;http://localhost:8080/dd/table?ip=localhost&amp;amp;port=3310&amp;amp;dbName=mytest&amp;amp;username=root&amp;amp;password=111111&lt;/code&gt; ，对应数据库连接参数。&lt;/li&gt;
&lt;li&gt;此处数据源的 key 是无意义的，建议根据实际场景设置有意义的值&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;

&lt;p&gt;前面已经完成了参数化切换数据源功能，但还有一点就是有模板代码，如添加数据源、切换数据源、对此数据源进行CURD操作、释放数据源，如果每个地方都这样做，就很繁琐，这个时候，就需要用到动态代理了，可参数我之前的文章：&lt;a href=&quot;https://mp.weixin.qq.com/s/a3x_pKUryb_at_4Xk48IiQ&quot;&gt;java开发必学知识:动态代理&lt;/a&gt;。此处，使用 JDK 自带的动态代理，实现参数化变更数据源的功能，消除模板代码。&lt;/p&gt;
&lt;h2 id=&quot;添加-jdk-动态代理&quot;&gt;4.1 添加 JDK 动态代理&lt;/h2&gt;
&lt;p&gt;添加 proxy 包，添加 &lt;code&gt;JdkParamDsMethodProxy&lt;/code&gt; 类，实现 &lt;code&gt;InvocationHandler&lt;/code&gt; 接口，在 &lt;code&gt;invoke&lt;/code&gt; 中编写参数化切换数据源的逻辑即可。如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class JdkParamDsMethodProxy implements InvocationHandler {
    // 代理对象及相应参数
    private String dataSourceKey;
    private DbInfo dbInfo;
    private Object targetObject;
    public JdkParamDsMethodProxy(Object targetObject, String dataSourceKey, DbInfo dbInfo) {
        this.targetObject = targetObject;
        this.dataSourceKey = dataSourceKey;
        this.dbInfo = dbInfo;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //切换数据源
        DataSourceUtil.addDataSourceToDynamic(dataSourceKey, dbInfo);
        DynamicDataSourceContextHolder.setContextKey(dataSourceKey);
        //调用方法
        Object result = method.invoke(targetObject, args);
        DynamicDataSourceContextHolder.removeContextKey();
        return result;
    }

    /**
     * 创建代理
     */
    public static Object createProxyInstance(Object targetObject, String dataSourceKey, DbInfo dbInfo) throws Exception {
        return Proxy.newProxyInstance(targetObject.getClass().getClassLoader()
                , targetObject.getClass().getInterfaces(), new JdkParamDsMethodProxy(targetObject, dataSourceKey, dbInfo));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;代码中，需要使用的参数通过构造函数传入&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;Proxy.newProxyInstance&lt;/code&gt; 创建代理，在方法执行时( &lt;code&gt;invoke&lt;/code&gt; ) 进行数据源添加、切换、数据库操作、清除等&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;使用代理实现功能&quot;&gt;4.2 使用代理实现功能&lt;/h2&gt;
&lt;p&gt;有了代理，在添加和切换数据源时就可以擦除模板代码，前面的业务代码就变成：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@GetMapping(&quot;table&quot;)
    public Object findWithDbInfo(DbInfo dbInfo) throws Exception {
        //数据源key
        String newDsKey = System.currentTimeMillis()+&quot;&quot;;
        //使用代理切换数据源
        TableMapper tableMapperProxy = (TableMapper)JdkParamDsMethodProxy.createProxyInstance(tableMapper, newDsKey, dbInfo);
        List&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; tables = tableMapperProxy.selectTableList();
        return ResponseResult.success(tables);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过代理，代码就简洁多了。&lt;/p&gt;

&lt;p&gt;本文基于动态数据源，对参数化变更数据源及应用场景进行了说明，提出连接数据库，查询表信息的功能需求作为示例，实现根据参数构建数据源，动态添加数据源功能，对参数化变更数据源的使用进行讲解，最后使用动态代理简化操作。本篇文章偏重代码实现，小伙伴们可以新手实践来加深认知。&lt;/p&gt;
&lt;p&gt;本文配套的示例，&lt;a href=&quot;https://github.com/mianshenglee/my-example/tree/master/multi-datasource&quot;&gt;示例代码&lt;/a&gt;，有兴趣的可以运行示例来感受一下。&lt;/p&gt;


&lt;p&gt;我的公众号（搜索&lt;code&gt;Mason技术记录&lt;/code&gt;），获取更多技术记录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/mianshenglee/datastorage/raw/master/md-photo/myphoto/wx/wx-public.jpg&quot; alt=&quot;mason&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 21 Jan 2020 15:27:00 +0000</pubDate>
<dc:creator>Mason技术记录</dc:creator>
<og:description>参数化变更源意思是根据参数动态添加数据源以及切换数据源，解决不确定数据源的问题。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/masonlee/p/12227360.html</dc:identifier>
</item>
<item>
<title>MacOSX 安装 TensorFlow - 叉叉敌</title>
<link>http://www.cnblogs.com/ievjai/p/12227299.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ievjai/p/12227299.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;TensorFlow&lt;/code&gt;是一个端到端开源机器学习平台。它拥有一个包含各种工具、库和社区资源的全面灵活生态系统，可以让研究人员推动机器学习领域的先进技术的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;安装-anaconda&quot;&gt;安装 Anaconda&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;TensorFlow&lt;/code&gt; 安装的前提是系统安装了 Python 2.5 或更高版本，教程中的例子是以 Python 3.6（Anaconda 3 版）为基础设计的。为了安装 &lt;code&gt;TensorFlow&lt;/code&gt;，首先确保你已经安装了 Anaconda。可以从网址（&lt;a href=&quot;https://www.anaconda.com/distribution/#download-section%EF%BC%89%E4%B8%AD%E4%B8%8B%E8%BD%BD%E5%B9%B6%E5%AE%89%E8%A3%85%E9%80%82%E7%94%A8%E4%BA%8E&quot; class=&quot;uri&quot;&gt;https://www.anaconda.com/distribution/#download-section）中下载并安装适用于&lt;/a&gt; Windows/macOS 或 Linux 的 Anaconda。&lt;/p&gt;
&lt;blockquote readability=&quot;2.9558823529412&quot;&gt;
&lt;p&gt;这个是&lt;code&gt;macos&lt;/code&gt;的连接，一个是命令行的，一个是GUI的&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://repo.anaconda.com/archive/Anaconda3-2019.10-MacOSX-x86_64.sh&quot; class=&quot;uri&quot;&gt;https://repo.anaconda.com/archive/Anaconda3-2019.10-MacOSX-x86_64.sh&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://repo.anaconda.com/archive/Anaconda3-2019.10-MacOSX-x86_64.pkg&quot; class=&quot;uri&quot;&gt;https://repo.anaconda.com/archive/Anaconda3-2019.10-MacOSX-x86_64.pkg&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于安装 &lt;code&gt;anaconda&lt;/code&gt;， 可以参考官方的文档。&lt;/p&gt;

&lt;h2 id=&quot;配置-anaconda&quot;&gt;配置 Anaconda&lt;/h2&gt;
&lt;p&gt;执行这个命令&lt;code&gt;source ~/.bash_profile&lt;/code&gt;， 其实查看这个文件&lt;code&gt;.bash_profile&lt;/code&gt;，关键的信息&lt;code&gt;export PATH=&quot;/opt/anaconda3/bin:$PATH&quot;&lt;/code&gt;，就是配置anaconda的环境变量。&lt;br/&gt;然后执行&lt;code&gt;conda -V&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;(base) ➜ OpenSource conda -V&lt;br/&gt;conda 4.7.12&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;配置-pip-源&quot;&gt;配置 pip 源&lt;/h2&gt;
&lt;p&gt;这一步可以省略，但是配置为国内的源之后，速度快的飞起来。&lt;br/&gt;&lt;code&gt;sudo vi /Users/&lt;/code&gt;username&lt;code&gt;/Library/Application\ Support/pip/pip.conf&lt;/code&gt;，然后修改里面的内容为下面的源。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[global]
index-url = https://pypi.tuna.tsinghua.edu.cn/simple/
[install]
trusted-host=pypi.tuna.tsinghua.edu.cn&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;保存退出即可。&lt;/p&gt;
&lt;h2 id=&quot;安装-1&quot;&gt;安装&lt;/h2&gt;
&lt;p&gt;当前版本只支持 CPU&lt;/p&gt;
&lt;blockquote readability=&quot;2.7567567567568&quot;&gt;
&lt;p&gt;pip install &lt;a href=&quot;https://storage.googleapis.com/tensorflow/mac/tensorflow-0.5.0-py2-none-any.whl/&quot; class=&quot;uri&quot;&gt;https://storage.googleapis.com/tensorflow/mac/tensorflow-0.5.0-py2-none-any.whl\&lt;/a&gt;&lt;br/&gt;或者干脆直接用&lt;code&gt;pip install tensorflow&lt;/code&gt;一样的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这是第一个程序&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import tensorflow as tf

hello = tf.constant('Hello, TensorFlow!')
sess = tf.Session()
print(sess.run(hello))

# Hello, TensorFlow!&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如果你感兴趣可以关注公众号「chasays」- 程序员汇聚地&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/548630/202001/548630-20200121225800376-587826421.jpg&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 21 Jan 2020 14:58:00 +0000</pubDate>
<dc:creator>叉叉敌</dc:creator>
<og:description>是一个端到端开源机器学习平台。它拥有一个包含各种工具、库和社区资源的全面灵活生态系统，可以让研究人员推动机器学习领域的先进技术的。 准备 安装 Anaconda 安装的前提是系统安装了 Python</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ievjai/p/12227299.html</dc:identifier>
</item>
<item>
<title>Serilog高级玩法之用Serilog记录所选终结点附加属性 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/12227271.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/12227271.html</guid>
<description>&lt;p&gt;这是该系列的第二篇文章：&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/12215934.html&quot;&gt;在ASP.NET Core 3.0中使用Serilog.AspNetCore&lt;/a&gt;。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/12215934.html&quot;&gt;第1部分-使用Serilog RequestLogging来简化ASP.NET Core的日志输出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/12227271.html&quot;&gt;第2部分-用Serilog记录所选终结点的附加属性&lt;/a&gt;（本文）&lt;/li&gt;
&lt;li&gt;第3部分-使用Serilog.AspNetCore记录MVC属性[敬请期待]&lt;/li&gt;
&lt;li&gt;第4部分-从Serilog请求记录中排除运行状况检查端点[敬请期待]&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;1.8957345971564&quot;&gt;
&lt;p&gt;作者：依乐祝&lt;/p&gt;
&lt;p&gt;译文地址：&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/12227271.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yilezhu/p/12227271.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://andrewlock.net/using-serilog-aspnetcore-in-asp-net-core-3-logging-the-selected-endpoint-name-with-serilog/&quot; class=&quot;uri&quot;&gt;https://andrewlock.net/using-serilog-aspnetcore-in-asp-net-core-3-logging-the-selected-endpoint-name-with-serilog/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/12215934.html&quot;&gt;我的上一篇文章中，&lt;/a&gt;我描述了如何配置Serilog的RequestLogging中间件为每个请求创建“摘要”日志，以替换默认情况下从ASP.NET Core获取的10个或更多日志。&lt;/p&gt;
&lt;p&gt;在本文中，我将展示如何向Serilog的摘要请求日志中添加其他元数据，例如请求的主机名，响应的内容类型或从ASP.NET Core 3.0中使用的&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-3.0#endpoint-routing-differences-from-earlier-versions-of-routing&quot;&gt;终结点路由中间件&lt;/a&gt;所选择的端点名称。&lt;/p&gt;
&lt;h2 id=&quot;asp.net-core基础结构日志很详细但是默认情况下具有太多详细信息&quot;&gt;ASP.NET Core基础结构日志很详细，但是默认情况下具有太多详细信息&lt;/h2&gt;
&lt;p&gt;正如我在&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/12215934.html&quot;&gt;上一篇文章&lt;/a&gt;(&lt;a href=&quot;https://andrewlock.net/using-serilog-aspnetcore-in-asp-net-core-3-reducing-log-verbosity/)%E4%B8%AD%E6%89%80%E5%B1%95%E7%A4%BA%E7%9A%84%E9%82%A3%E6%A0%B7%EF%BC%8C%E5%9C%A8%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%AD%EF%BC%8CASP.NET&quot; class=&quot;uri&quot;&gt;https://andrewlock.net/using-serilog-aspnetcore-in-asp-net-core-3-reducing-log-verbosity/)中所展示的那样，在开发环境中，ASP.NET&lt;/a&gt; Core基础架构将为每一个RazorPage处理程序生成10条日志消息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/202001/1377250-20200121224233947-1823208809.png&quot; alt=&quot;不使用Serilog请求日志记录的许多基础结构日志的图像&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过安装了&lt;a href=&quot;https://github.com/serilog/serilog-aspnetcore&quot;&gt;Serilog.AspNetCore&lt;/a&gt;的 NuGet包后并引入&lt;code&gt;RequestLoggingMiddleware&lt;/code&gt;之后，可以将其精简为一条日志消息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/202001/1377250-20200121224233626-1998224368.png&quot; alt=&quot;Serilog的请求日志记录生成的摘要日志的图像&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.8392857142857&quot;&gt;
&lt;p&gt;本文中使用的所有日志图片均来自一款优秀的为结构化日志提供可视化界面的工具-&lt;a href=&quot;https://datalust.co/seq&quot;&gt;Seq&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;显然，原始的日志集更加冗长，并且其中大部分不是特别有用的信息。但是，如果您将原始的10条日志作为一个整体来看，则与Serilog摘要日志相比，它们确实会在结构日志模板中记录一些其他属性。&lt;/p&gt;
&lt;p&gt;由ASP.NET Core基础结构记录的而Serilog 未记录的扩展内容包括（下面这些还是英文的看着顺眼）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Host (&lt;code&gt;localhost:5001&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Scheme (&lt;code&gt;https&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Protocol (&lt;code&gt;HTTP/2&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;QueryString (&lt;code&gt;test=true&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;EndpointName (&lt;code&gt;/Index&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;HandlerName (&lt;code&gt;OnGet&lt;/code&gt;/&lt;code&gt;SerilogRequestLogging.Pages.IndexModel.OnGet&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;ActionId (&lt;code&gt;1fbc88fa-42db-424f-b32b-c2d0994463f1&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;ActionName (&lt;code&gt;/Index&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;RouteData (&lt;code&gt;{page = &quot;/Index&quot;}&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;ValidationState (&lt;code&gt;True&lt;/code&gt;/&lt;code&gt;False&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;ActionResult (&lt;code&gt;PageResult&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;ContentType (&lt;code&gt;text/html; charset=utf-8&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我认为如果要把上述属性中的其中一些包含在摘要日志消息中，将非常有用。例如，如果您的应用程序绑定到多个主机名，那么&lt;code&gt;Host&lt;/code&gt;绝对是重要的日志。&lt;code&gt;QueryString&lt;/code&gt;可能是另一个有用的字段。&lt;code&gt;EndpointName&lt;/code&gt;/ &lt;code&gt;HandlerName&lt;/code&gt;，&lt;code&gt;ActionId&lt;/code&gt;并且&lt;code&gt;ActionName&lt;/code&gt;似乎不那么重要，因为您应该能够推断出给定的请求路径，但是显式记录它们将帮助您更加方便的捕获错误，并使过滤针对特定操作的所有请求变得更加容易。&lt;/p&gt;
&lt;p&gt;概括地说，您可以将这些属性分为两类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;请求/响应&lt;/em&gt;特性：如&lt;code&gt;Host&lt;/code&gt;，&lt;code&gt;Scheme&lt;/code&gt;，&lt;code&gt;ContentType&lt;/code&gt;，&lt;code&gt;QueryString&lt;/code&gt;，&lt;code&gt;EndpointName&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;MVC / RazorPages相关&lt;/em&gt;的属性：如&lt;code&gt;HandlerName&lt;/code&gt;，&lt;code&gt;ActionId&lt;/code&gt;，&lt;code&gt;ActionResult&lt;/code&gt;等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在这篇文章中，我将展示如何添加这些类别中的第一种，即与请求/响应相关的属性，在下一篇文章中，我将展示如何添加基于MVC / RazorPages的属性。&lt;/p&gt;
&lt;h2 id=&quot;向serilog请求日志添加扩展数据&quot;&gt;向Serilog请求日志添加扩展数据&lt;/h2&gt;
&lt;p&gt;在上一篇&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/12215934.html&quot;&gt;文章中&lt;/a&gt;，我展示了如何将Serilog请求日志记录添加到您的应用程序中，因此在此不再赘述。现在，我假设您已经进行了设置，并且您拥有一个包含以下内容的&lt;code&gt;Startup.Configure&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    // ... Error handling/HTTPS middleware
    app.UseStaticFiles();

    app.UseSerilogRequestLogging(); // &amp;lt;-- Add this line

    app.UseRouting();
    app.UseAuthorization();
    app.UseEndpoints(endpoints =&amp;gt;
    {
        endpoints.MapRazorPages();
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该&lt;code&gt;UseSerilogRequestLogging()&lt;/code&gt;扩展方法将Serilog &lt;code&gt;RequestLoggingMiddleware&lt;/code&gt;添加到请求管道中。您还可以通过调用重载来&lt;a href=&quot;https://github.com/serilog/serilog-aspnetcore/blob/ffed9d231aefc3de7c13a03a570fb45c326632b0/src/Serilog.AspNetCore/AspNetCore/RequestLoggingOptions.cs&quot;&gt;配置&lt;code&gt;RequestLoggingOptions&lt;/code&gt;的实例&lt;/a&gt;。此类具有几个属性，可以让您自定义请求记录器如何生成日志语句：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class RequestLoggingOptions
{
    public string MessageTemplate { get; set; }
    public Func&amp;lt;HttpContext, double, Exception, LogEventLevel&amp;gt; GetLevel { get; set; }
    public Action&amp;lt;IDiagnosticContext, HttpContext&amp;gt; EnrichDiagnosticContext { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该&lt;code&gt;MessageTemplate&lt;/code&gt;属性控制将日志呈现为的字符串格式，&lt;code&gt;GetLevel&lt;/code&gt;允许您控制给定日志索要记录的级别，如 &lt;code&gt;Debug&lt;/code&gt;/ &lt;code&gt;Info&lt;/code&gt;/ &lt;code&gt;Warning&lt;/code&gt;等。这里我们所关心的是&lt;code&gt;EnrichDiagnosticContext&lt;/code&gt;属性。&lt;/p&gt;
&lt;p&gt;设置了该属性的&lt;code&gt;Action&amp;lt;&amp;gt;&lt;/code&gt;之后，在生成日志消息时它将被Serilog中间件调用并执行。它在日志写入&lt;em&gt;之前&lt;/em&gt;运行，这意味着它&lt;em&gt;在&lt;/em&gt;中间件管道执行&lt;em&gt;之后&lt;/em&gt;运行。例如，在下图中（&lt;a href=&quot;https://www.manning.com/books/asp-dot-net-core-in-action?a_aid=aspnetcore-in-action&amp;amp;a_bid=5b1b11eb&quot;&gt;取自我的书《 ASP.NET Core in Action》&lt;/a&gt;），当响应“回传”到中间件管道时，在第5步写入日志：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/202001/1377250-20200121224233246-783130160.png&quot; alt=&quot;中间件管道的示例&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在管道处理&lt;em&gt;之后&lt;/em&gt;写入日志这一事实意味着两件事：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们可以访问&lt;em&gt;Response的&lt;/em&gt;属性，例如状态码，经过的时间或内容类型&lt;/li&gt;
&lt;li&gt;我们可以访问在管道后面设置的中间件的&lt;em&gt;功能&lt;/em&gt;，例如，由&lt;code&gt;EndpointRoutingMiddleware&lt;/code&gt;（通过&lt;code&gt;UseRouting()&lt;/code&gt;添加的）设置的功能：&lt;code&gt;IEndpointFeature&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在下一部分中，我将提供一个帮助程序功能，该功能会将所有“缺少”属性添加到Serilog请求日志消息中。&lt;/p&gt;
&lt;h2 id=&quot;在idiagnosticcontext中设置扩展值&quot;&gt;在IDiagnosticContext中设置扩展值&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Serilog.AspNetCore&lt;/em&gt;会将接口&lt;code&gt;IDiagnosticContext&lt;/code&gt;作为单例添加到DI容器中，因此您可以从任何类中访问它。然后，您可以调用&lt;code&gt;Set()&lt;/code&gt;方法，将其他属性附加到请求日志消息中。&lt;/p&gt;
&lt;p&gt;例如，&lt;a href=&quot;https://github.com/serilog/serilog-aspnetcore#request-logging&quot;&gt;如文档所示&lt;/a&gt;，您可以从操作方法中添加任意值：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class HomeController : Controller
{
    readonly IDiagnosticContext _diagnosticContext;
    public HomeController(IDiagnosticContext diagnosticContext)
    {
        _diagnosticContext = diagnosticContext;
    }

    public IActionResult Index()
    {
        // The request completion event will carry this property
        _diagnosticContext.Set(&quot;CatalogLoadTime&quot;, 1423);
        return View();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，结果摘要日志将包含属性&lt;code&gt;CatalogLoadTime&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RequestLoggingOptions&lt;/code&gt;通过设置所提供&lt;code&gt;IDiagnosticContext&lt;/code&gt;实例的值，我们基本上使用完全相同的方法来定制中间件所使用的方法。下面的静态帮助器类从当前&lt;code&gt;HttpContext&lt;/code&gt;上下文检索值，并在值可用时对其进行设置。&lt;br/&gt;下面的静态helper类从当前HttpContext检索值，并在值可用时设置它们。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static class LogHelper 
{
    public static void EnrichFromRequest(IDiagnosticContext diagnosticContext, HttpContext httpContext)
    {
        var request = httpContext.Request;

        // Set all the common properties available for every request
        diagnosticContext.Set(&quot;Host&quot;, request.Host);
        diagnosticContext.Set(&quot;Protocol&quot;, request.Protocol);
        diagnosticContext.Set(&quot;Scheme&quot;, request.Scheme);

        // Only set it if available. You're not sending sensitive data in a querystring right?!
        if(request.QueryString.HasValue)
        {
            diagnosticContext.Set(&quot;QueryString&quot;, request.QueryString.Value);
        }

        // Set the content-type of the Response at this point
        diagnosticContext.Set(&quot;ContentType&quot;, httpContext.Response.ContentType);

        // Retrieve the IEndpointFeature selected for the request
        var endpoint = httpContext.GetEndpoint();
        if (endpoint is object) // endpoint != null
        {
            diagnosticContext.Set(&quot;EndpointName&quot;, endpoint.DisplayName);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的帮助器函数从“Request”，“Response”以及其他中间件（端点名称）设置的功能中检索值。您可以扩展它，以根据需要在请求中添加其他值。&lt;/p&gt;
&lt;p&gt;您可以在你的&lt;code&gt;Startup.Configure()&lt;/code&gt;方法中通过调用&lt;code&gt;UseSerilogRequestLogging&lt;/code&gt;的&lt;code&gt;EnrichDiagnosticContext&lt;/code&gt;属性，来注册上面的帮助类：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    // ... Other middleware

    app.UseSerilogRequestLogging(opts
        =&amp;gt; opts.EnrichDiagnosticContext = LogHelper.EnrichFromRequest);

    // ... Other middleware
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，当您发出请求时，您将看到添加到Serilog结构化日志中的所有其他属性：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/202001/1377250-20200121224232756-732181000.png&quot; alt=&quot;来自Seq的日志消息显示了其他属性&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只要您具有通过当前HttpContext可供中间件管道使用的值，就可以使用此方法。但是MVC的相关属性是个例外，它们是MVC中间件“内部”的特性，例如action 名称或RazorPage处理程序名称。在下一篇文章中，我将展示如何将它们添加到Serilog请求日志中。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;默认情况下，用Serilog的请求日志记录中间件替换ASP.NET Core基础结构日志记录时，与开发环境的默认日志记录配置相比，您会丢失一些信息。在本文中，我展示了如何通过自定义Serilog &lt;code&gt;RequestLoggingOptions&lt;/code&gt;来添加这些附加属性。&lt;/p&gt;
&lt;p&gt;这样的做法非常简单-您可以访问&lt;code&gt;HttpContext&lt;/code&gt;，因此你可以检索它包含的任何可用的值，并将它们设置为&lt;code&gt;IDiagnosticContext&lt;/code&gt;所提供的属性。这些属性将作为附加属性添加到Serilog生成的结构化日志中。在下一篇文章中，我将展示如何将MVC特定的属性值添加到请求日志中。敬请期待吧！&lt;/p&gt;
</description>
<pubDate>Tue, 21 Jan 2020 14:57:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>这是该系列的第二篇文章： &amp;quot;在ASP.NET Core 3.0中使用Serilog.AspNetCore&amp;quot; 。 1. &amp;quot;第1部分 使用Serilog RequestLog</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yilezhu/p/12227271.html</dc:identifier>
</item>
<item>
<title>CSS中设置元素的圆角矩形 - 微笑是最初的信仰</title>
<link>http://www.cnblogs.com/lq0001/p/12227252.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lq0001/p/12227252.html</guid>
<description>&lt;h2 id=&quot;圆角矩形介绍&quot;&gt;圆角矩形介绍&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;在&lt;code&gt;CSS&lt;/code&gt;中通过&lt;code&gt;border-radius&lt;/code&gt;属性可以实现元素的圆角矩形。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;border-radius&lt;/code&gt;属性值一共有&lt;code&gt;4&lt;/code&gt;个，左上、右上、左下、右下。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;border-radius&lt;/code&gt;属性值规则如下：第一个值为左上、第二个值为右上、第三个值为左下、第四个值为右下。&lt;/li&gt;
&lt;li&gt;假如&lt;code&gt;border-radius&lt;/code&gt;属性值都是一致的我可以设置一个属性值即可。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;圆角矩形实践&quot;&gt;圆角矩形实践&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;圆角矩形基本使用方式&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;圆角矩形&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
      div{
        width: 100px;
        height: 100px;
        border: 2px solid rebeccapurple;
        border-radius: 10px 20px 30px 40px;
      }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
   &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/202001/1781381-20200121223048104-15492953.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果我们的&lt;code&gt;border-radius&lt;/code&gt;属性值一致实践。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;圆角矩形&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
      div{
        width: 100px;
        height: 100px;
        border: 2px solid rebeccapurple;
        border-radius: 20px ;
      }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
   &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/202001/1781381-20200121223427090-2109404610.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果使用&lt;code&gt;border-radius&lt;/code&gt;属性值将元素设置为圆形呢。&lt;/li&gt;
&lt;li&gt;第一步：要设置的元素宽高度必须一致。&lt;/li&gt;
&lt;li&gt;第二步：使用&lt;code&gt;border-radius&lt;/code&gt;属性值必须是要设置的元素宽高度的一半。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;圆角矩形&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
      div{
        width: 100px;
        height: 100px;
        border: 2px solid rebeccapurple;
        border-radius: 50px ;
      }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
   &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/202001/1781381-20200121223437927-1368990653.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设置椭圆形实践&lt;/li&gt;
&lt;li&gt;实现椭圆形&lt;code&gt;border-radius&lt;/code&gt;属性值必须是元素的高度一半即可。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;圆角矩形&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
      div{
        width: 100px;
        height: 50px;
        border: 2px solid rebeccapurple;
        border-radius: 25px ;
      }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
   &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/202001/1781381-20200121223448184-820155646.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;设置半圆形&quot;&gt;设置半圆形&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;设置右半圆形&lt;code&gt;border-radius&lt;/code&gt;属性值左上、和右下为元素的宽度一致即可。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;圆角矩形&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
      div{
        width: 50px;
        height: 100px;
        border: 2px solid rebeccapurple;
        border-radius: 50px 0px 0px 50px ;
      }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
   &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/202001/1781381-20200121223500214-1590476562.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设置左半圆形&lt;code&gt;border-radius&lt;/code&gt;属性值右上、和左下为元素的宽度一致即可。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;圆角矩形&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
      div{
        width: 50px;
        height: 100px;
        border: 2px solid rebeccapurple;
        border-radius: 0px 50px 50px 0px ;
      }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
   &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/202001/1781381-20200121223509876-2047310066.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设置上半圆形&lt;code&gt;border-radius&lt;/code&gt;属性值左上、和右上为元素的高度一致即可。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;圆角矩形&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
      div{
        width: 100px;
        height: 50px;
        border: 2px solid rebeccapurple;
        border-radius: 50px 50px 0px 0px ;
      }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
   &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/202001/1781381-20200121223521036-1343475646.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设置下半圆形&lt;code&gt;border-radius&lt;/code&gt;属性值左下、和右下为元素的高度一致即可。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;圆角矩形&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
      div{
        width: 100px;
        height: 50px;
        border: 2px solid rebeccapurple;
        border-radius: 0px 0px 50px 50px ;
      }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
   &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/202001/1781381-20200121223531421-724269918.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 21 Jan 2020 14:36:00 +0000</pubDate>
<dc:creator>微笑是最初的信仰</dc:creator>
<og:description>圆角矩形介绍 在 中通过 属性可以实现元素的圆角矩形。 属性值一共有 个，左上、右上、左下、右下。 属性值规则如下：第一个值为左上、第二个值为右上、第三个值为左下、第四个值为右下。 假如 属性值都是一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lq0001/p/12227252.html</dc:identifier>
</item>
<item>
<title>Java 内存模型 - 以梦为码</title>
<link>http://www.cnblogs.com/volare/p/12227237.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/volare/p/12227237.html</guid>
<description>
&lt;h3&gt;&lt;span&gt;1、为什么要引入java内存模型&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　java是支持多线程的，但是其可见性，原子性，有序性是导致多线程bug的原因，所以引入java内存模型来解决这些问题。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;2、什么是java内存模型&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　java内存模型概括来说是&lt;span&gt;解决可见性和有序性的&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　1）可见性 - 缓存导致&lt;/p&gt;
&lt;p&gt;　　当创建线程时JVM会为其创建自己的内存存储自己的私有变量，但是所有的共享变量都存在于主存（共享区域）中，所有线程的操作都需要在自己的私有内存中操作，&lt;/p&gt;
&lt;p&gt;所以当线程访问共享变量时需要先将主存中变量copy到自己的工作内存，操作完后，写会主存。 —— 故缓存会导致可见性bug&lt;/p&gt;
&lt;p&gt;　　2)有序性 - 编译器优化&lt;/p&gt;
&lt;p&gt;　　当语句的执行顺序调整后 不会对结果造成影响时，编译器会进行优化，调整执行顺序。 —— 故会导致有序性bug&lt;/p&gt;
&lt;p&gt;　　例如：单例的double check问题，后续展开。&lt;/p&gt;
&lt;p&gt;而java内存模型从某种角度来说，提供了解决按需禁止缓存和编译优化的方法 。 包括 &lt;span&gt;volatile,synchronized 和 final关键字，以及happens-before原则&lt;/span&gt;。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;3、volatile关键字&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; volatile禁用缓存，保证执行的有序性，但不能保证原子性。相当于弱化的synchronied。&lt;/p&gt;
&lt;p&gt;可见性：&lt;/p&gt;
&lt;p&gt;　　1、volatile修饰的共享变量，在工作内修改后，会强制马上刷新到主存中。&lt;/p&gt;
&lt;p&gt;　　2、valatile修饰的共享变量，一旦被一个线程修改完刷新到主存，则其他工作内存中的此变量都失效，再读取主存中的变量。&lt;/p&gt;
&lt;p&gt;有序性：&lt;/p&gt;
&lt;p&gt;　　volatile关键字修饰的变量以及之前的语句不会在JVM优化期间进行重排序（重排序：是指没有数据依赖的语句进行排序。在单线程内没有问题，优化效率还保证了结果的一致性，但是会影响并发中程序的正确性）&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('5cca9c1f-c1b4-4ae2-b0cf-a87efe127548')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_5cca9c1f-c1b4-4ae2-b0cf-a87efe127548&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5cca9c1f-c1b4-4ae2-b0cf-a87efe127548&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('5cca9c1f-c1b4-4ae2-b0cf-a87efe127548',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5cca9c1f-c1b4-4ae2-b0cf-a87efe127548&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Singleton {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * volatile修饰Singleton实例，保证singleton初始化时保证有序性
     * instance = new Singleton();
     * 其实JVM内部已经转换为多条指令：
     * //1：分配对象的内存空间
     * memory = allocate();
     *  //2：初始化对象
     * ctorInstance(memory);
     * //3：设置instance指向刚分配的内存地址
     * instance = memory;
     * 但是经过重排序后如下：
     * //1：分配对象的内存空间
     * memory = allocate();
     * 3：设置instance指向刚分配的内存地址，此时对象还没被初始化
     * instance = memory;
     * //2：初始化对象
     * ctorInstance(memory);
     *
     * 假设没有volatile修饰。
     * 线程1先占有锁，执行new Singleton(), 在给instance = memory分配内存地址的时候，
     * 线程2进入判断语句singleton==null,引用地址不为null，
     * 则线程2返回一个初始化不完整的实例，系统会报错
     * ---------------------
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; Singleton singleton = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Singleton() {
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Singleton getSingleton() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (singleton == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (Singleton.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (singleton == &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
                    singleton = &lt;span&gt;new&lt;/span&gt; Singleton();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;
&lt;span&gt;                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; singleton;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;单例double check问题&lt;/span&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;4、volatile如何禁用缓存&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　这涉及到关键的happens-before原则。happens-before是指前一个操作的结果对后续是可见的。&lt;/p&gt;
&lt;p&gt;　　1）程序的顺序执行&lt;/p&gt;
&lt;p&gt;　　2）volatile变量禁用缓存规则，对后续该变量的查看是可见的&lt;/p&gt;
&lt;p&gt;　　 3）传递性。A对于B可见，B对于C可见则A对于C可见&lt;/p&gt;
&lt;p&gt;　　4）管程可见性。synchronized是管程的实现，前一个加锁的线程操作对后一个线程时可见的。 &lt;span&gt;synchronied解锁后会强刷主存，所以后一个线程是可见的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　 5）线程start();这条是关于线程启动的。它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作.&lt;/p&gt;


&lt;h3&gt;&lt;span&gt;5、final关键字&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;final 关键字则是告诉编译器它是不变的，可劲优化&lt;/p&gt;

&lt;p&gt;&lt;img id=&quot;uploading_image_15820&quot; src=&quot;https://common.cnblogs.com/images/loading.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 21 Jan 2020 14:30:00 +0000</pubDate>
<dc:creator>以梦为码</dc:creator>
<og:description>1、为什么要引入java内存模型 java是支持多线程的，但是其可见性，原子性，有序性是导致多线程bug的原因，所以引入java内存模型来解决这些问题。 2、什么是java内存模型 java内存模型概</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/volare/p/12227237.html</dc:identifier>
</item>
<item>
<title>Tesseract-OCR-v5.0中文识别,训练自定义字库,提高图片的识别效果 - 9点0频道</title>
<link>http://www.cnblogs.com/channel9/p/12227166.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/channel9/p/12227166.html</guid>
<description>&lt;p&gt;1，下载安装Tesseract-OCR 安装，链接地址&lt;a href=&quot;https://digi.bib.uni-mannheim.de/tesseract/&quot; data-cke-saved-href=&quot;https://digi.bib.uni-mannheim.de/tesseract/&quot;&gt;https://digi.bib.uni-mannheim.de/tesseract/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;17&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdnimg.cn/20200121160031940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;886&quot; height=&quot;740&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20200121160031940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20200121160031940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;886&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;740&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2，安装成功 tesseract -v&lt;/p&gt;
&lt;p&gt;注意：安装后，要添加系统环境变量&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;16&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdnimg.cn/20200121160158524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;810&quot; height=&quot;246&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20200121160158524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20200121160158524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;810&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;246&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3，cmd指定目录到 cd C:\Work\BlogsTest\TestPic，要识别图片的文件夹 识别：tesseract test.png result -l chi_sim&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;15&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdnimg.cn/20200121160719791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;651&quot; height=&quot;374&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20200121160719791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20200121160719791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;651&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;374&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;识别成功的效果，result.txt文件会自动生成&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;14&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdnimg.cn/20200121161018933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;972&quot; height=&quot;729&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20200121161018933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20200121161018933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;972&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;729&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;要注意：Tesseract-OCR的安装目录要包含识别中文的字符集chi_sim.traineddata，可以在GitHub下载&lt;a href=&quot;https://github.com/tesseract-ocr/tessdata&quot; data-cke-saved-href=&quot;https://github.com/tesseract-ocr/tessdata&quot;&gt;https://github.com/tesseract-ocr/tessdata&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;13&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdnimg.cn/20200121161315386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;712&quot; height=&quot;572&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20200121161315386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20200121161315386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;712&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;572&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4，可见第3步的识别效果不是很好，想到通过训练自定义字库,提高图片的识别效果&lt;/p&gt;
&lt;p&gt;（0）下载安装jTessBoxEditor，&lt;a href=&quot;https://sourceforge.net/projects/vietocr/files/jTessBoxEditor/&quot; data-cke-saved-href=&quot;https://sourceforge.net/projects/vietocr/files/jTessBoxEditor/&quot;&gt;https://sourceforge.net/projects/vietocr/files/jTessBoxEditor/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;12&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdnimg.cn/20200121164928592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;1037&quot; height=&quot;578&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20200121164928592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20200121164928592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;1037&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;578&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;注意要安装JavaRuntime&lt;/p&gt;
&lt;p&gt;（1）打开jTessBoxEditor，选择Tools-&amp;gt;Merge TIFF，进入训练样本所在文件夹，选中要参与训练的样本图片：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;11&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdnimg.cn/2020012116514842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;1166&quot; height=&quot;685&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/2020012116514842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/2020012116514842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;1166&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;685&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（2）点击 “打开” 后弹出保存对话框，选择保存在当前路径下，文件命名为 “qq66.test.exp0.tif” ，格式只有一种 “TIFF” 可选。&lt;/p&gt;
&lt;p&gt;tif文面命名格式[lang].[fontname].exp[num].tif&lt;br/&gt;lang是语言，fontname是字体，num为自定义数字。&lt;/p&gt;
&lt;p&gt;比如我们要训练自定义字库 qq66，字体名test，那么我们把图片文件命名为 qq66.test.exp0.tif&lt;/p&gt;
&lt;p&gt;（3）使用tesseract生成.box文件&lt;/p&gt;
&lt;p&gt;tesseract qq66.test.exp0.tif qq66.test.exp0 -l chi_sim &lt;strong&gt;--psm 6&lt;/strong&gt; batch.nochop makebox&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;10&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdnimg.cn/20200121165910378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;820&quot; height=&quot;295&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20200121165910378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20200121165910378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;820&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;295&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;注意：&lt;strong&gt;--psm&lt;/strong&gt;的语法，数字对应不同的 页面分割模式。&lt;/p&gt;
&lt;p&gt;（4）使用jTessBoxEditor矫正.box文件的错误&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;9&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdnimg.cn/20200121170236561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;937&quot; height=&quot;610&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20200121170236561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20200121170236561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;937&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;610&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;打开后矫正后，点击 save&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;8&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdnimg.cn/20200121170624512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;998&quot; height=&quot;646&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20200121170624512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20200121170624512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;998&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;646&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（5）生成font_properties文件：（该文件没有后缀名）&lt;/p&gt;
&lt;p&gt;执行命令，执行完之后，会在当前目录生成font_properties文件&lt;br/&gt;echo test 0 0 0 0 0 &amp;gt;font_properties&lt;/p&gt;
&lt;p&gt;也可以手工新建一个名为font_properties的文本文件，输入内容 “test 0 0 0 0 0” 表示字体test的粗体、倾斜等共计5个属性。这里的“test”必须与“qq66.test.exp0.box”中的“test”名称一致。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;（6）使用tesseract生成.tr训练文件&lt;/p&gt;
&lt;p&gt;执行下面命令，执行完之后，会在当前目录生成qq66.test.exp0.tr文件。&lt;/p&gt;
&lt;p&gt;tesseract qq66.test.exp0.tif qq66.test.exp0 nobatch box.train&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;7&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdnimg.cn/20200121171242287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;809&quot; height=&quot;645&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20200121171242287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20200121171242287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;809&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;645&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（7）生成字符集文件：&lt;/p&gt;
&lt;p&gt;执行下面命令：执行完之后会在当前目录生成一个名为“unicharset”的文件。&lt;/p&gt;
&lt;p&gt;unicharset_extractor qq66.test.exp0.box&lt;/p&gt;
&lt;p&gt;（8）生成shape文件：&lt;/p&gt;
&lt;p&gt;执行下面命令，执行完之后，会生成 shapetable 和 zwp.unicharset 两个文件。&lt;/p&gt;
&lt;p&gt;shapeclustering -F font_properties -U unicharset -O qq66.unicharset qq66.test.exp0.tr&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;6&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdnimg.cn/20200121171709871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;803&quot; height=&quot;229&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20200121171709871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20200121171709871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;803&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;229&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（8）生成聚字符特征文件&lt;/p&gt;
&lt;p&gt;执行下面命令，会生成 inttemp、pffmtable、shapetable和zwp.unicharset四个文件。&lt;/p&gt;
&lt;p&gt;mftraining -F font_properties -U unicharset -O qq66.unicharset qq66.test.exp0.tr&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;5&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdnimg.cn/20200121171931977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;801&quot; height=&quot;545&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20200121171931977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20200121171931977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;801&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;545&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（9）生成字符正常化特征文件&lt;/p&gt;
&lt;p&gt;执行下面命令，会生成 normproto 文件。&lt;/p&gt;
&lt;p&gt;cntraining qq66.test.exp0.tr&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;4&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdnimg.cn/20200121172058905.png&quot; alt=&quot;&quot; width=&quot;604&quot; height=&quot;183&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20200121172058905.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20200121172058905.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;604&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;183&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（10）文件重命名&lt;br/&gt;重新命名inttemp、pffmtable、shapetable和normproto这四个文件的名字为[lang].xxx。&lt;/p&gt;
&lt;p&gt;这里修改为qq66.inttemp、qq66.pffmtable、qq66.shapetable和qq66.normproto&lt;/p&gt;
&lt;p&gt;（11）合并训练文件&lt;br/&gt;执行下面命令，会生成qq66.traineddata文件。&lt;/p&gt;
&lt;p&gt;combine_tessdata qq66.&lt;br/&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;3&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdnimg.cn/20200121172516133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;573&quot; height=&quot;258&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20200121172516133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20200121172516133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;573&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;258&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最后文件目录&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;2&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdnimg.cn/20200121172632602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;801&quot; height=&quot;542&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20200121172632602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20200121172632602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;801&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;542&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5，用新生成的qq66.traineddata字符集，重新识别身份证&lt;/p&gt;
&lt;p&gt;6，可以同时选择多个不同的样本生成box文件&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;1&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdnimg.cn/20200121211105997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;1071&quot; height=&quot;725&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20200121211105997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20200121211105997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;1071&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;725&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;7，在原有训练数据的基础上，加入新的字符训练信息&lt;/p&gt;
&lt;p&gt;经研究找到实用合并方法（红色部分为示例，实际应为你自己生成的文件名）：&lt;/p&gt;
&lt;p&gt;在新的训练数据生成.box 和.tr文件后，&lt;/p&gt;
&lt;p&gt;生成字符集 unicharset_extractor add.font.exp0.box new.font.exp0.box&lt;/p&gt;
&lt;p&gt;合并训练数据(.tr)&lt;/p&gt;
&lt;p&gt;mftraining -F font_properties -U unicharset -O added.unicharset add.font.exp0.tr new.font.exp0.tr&lt;/p&gt;
&lt;p&gt;聚合所有的tr文件：&lt;/p&gt;
&lt;p&gt;cntraining add.font.exp0.tr new.font.exp0.tr &lt;/p&gt;
&lt;p&gt;8，设置图片分割模式&lt;/p&gt;
&lt;p&gt;Page segmentation modes:&lt;/p&gt;
&lt;p&gt;0 = Orientation and script detection (OSD) only.&lt;br/&gt;1 = Automatic page segmentation with OSD.&lt;br/&gt;2 = Automatic page segmentation, but no OSD, or OCR&lt;br/&gt;3 = Fully automatic page segmentation, but no OSD. (Default)&lt;br/&gt;4 = Assume a single column of text of variable sizes.&lt;br/&gt;5 = Assume a single uniform block of vertically aligned text.&lt;br/&gt;6 = Assume a single uniform block of text.&lt;br/&gt;7 = Treat the image as a single text line.&lt;br/&gt;8 = Treat the image as a single word.&lt;br/&gt;9 = Treat the image as a single word in a circle.&lt;br/&gt;10 = Treat the image as a single character.&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;tesseract test.png result  -l chi_sim -psm 7 nobatch&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;0&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdnimg.cn/20200121215039370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;409&quot; height=&quot;454&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20200121215039370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20200121215039370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbWluZ2Jsb2dz,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;409&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;454&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 21 Jan 2020 14:04:00 +0000</pubDate>
<dc:creator>9点0频道</dc:creator>
<og:description>1，下载安装Tesseract-OCR 安装，链接地址https://digi.bib.uni-mannheim.de/tesseract/ ​ 2，安装成功&amp;#160;tesseract -v 注意</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/channel9/p/12227166.html</dc:identifier>
</item>
</channel>
</rss>