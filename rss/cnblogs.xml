<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Contour 学习笔记（一）：使用 Contour 接管 Kubernetes 的南北流量 - 米开朗基杨</title>
<link>http://www.cnblogs.com/ryanyangcs/p/11432967.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ryanyangcs/p/11432967.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1737323/201908/1737323-20190830081812696-1612161920.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0.78947368421053&quot;&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://www.yangcs.net/posts/use-envoy-as-a-kubernetes-ingress/&quot;&gt;Contour 学习笔记（一）：使用 Contour 接管 Kubernetes 的南北流量&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Kubernetes 中运行大规模以 Web 为中心的工作负载，最关键的需求之一就是在 &lt;code&gt;L7&lt;/code&gt; 层实现高效流畅的入口流量管理。自从第一批 &lt;code&gt;Kubernetes Ingress Controller&lt;/code&gt; 开发完成以来，&lt;code&gt;Envoy&lt;/code&gt;（由 Matt Klein 和 Lyft 团队开发）已经成为云原生生态系统中的新生力量。Envoy 之所以受到支持，因为它是一个 CNCF 托管的项目，与整个容器圈和云原生架构有着天然的支持。&lt;/p&gt;
&lt;p&gt;容器公司 &lt;a href=&quot;https://heptio.com/&quot;&gt;Heptio&lt;/a&gt; 开源的项目 &lt;a href=&quot;https://github.com/heptio/contour&quot;&gt;Contour&lt;/a&gt; 使用 &lt;code&gt;Envoy&lt;/code&gt; 作为 Kubernetes 的 Ingress Controller 实现，为大家提供了一条新的 Kubernetes 外部负载均衡实现思路。&lt;/p&gt;
&lt;p&gt;据&lt;a href=&quot;https://blog.heptio.com/making-it-easy-to-use-envoy-as-a-kubernetes-load-balancer-dde82959f171&quot;&gt;官方博客&lt;/a&gt;介绍，&lt;code&gt;Heptio Contour&lt;/code&gt; 可以为用户提供以下好处：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一种简单的安装机制来快速部署和集成 Envoy。&lt;/li&gt;
&lt;li&gt;与 Kubernetes 对象模型的集成。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ingress&lt;/code&gt; 配置的动态更新，而无需重启底层负载均衡器。&lt;/li&gt;
&lt;li&gt;项目成熟后，将允许使用 Envoy 一些强大的功能，如熔断器、插件式的处理器链，以及可观测性和可调试性，可以非常方便地对接监控系统。&lt;/li&gt;
&lt;li&gt;IngressRoute 之间可以级联，用来做蓝绿部署非常方便。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们就来试用一下。&lt;/p&gt;
&lt;h2 id=&quot;安装步骤&quot;&gt;1. 安装步骤&lt;/h2&gt;
&lt;p&gt;Contour Ingress controller 由两个组件组成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Envoy&lt;/code&gt; : 提供高性能反向代理。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Contour&lt;/code&gt; : 充当 Envoy 的控制平面，为 Envoy 的路由配置提供统一的来源。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;官方文档提供了三种部署方法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过 &lt;code&gt;DaemonSet&lt;/code&gt; 来部署，每个节点上跑一个 Contour 实例（Contour 与 Envoy 在同一个 Pod 中）。&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;Deployment&lt;/code&gt; 来部署，总共跑两个 Contour 实例（Contour 与 Envoy 在同一个 Pod 中）。&lt;/li&gt;
&lt;li&gt;通过 Deployment 来部署 Contour，总共跑两个 Contour 实例；通过 DaemonSet 来部署 Envoy，每个节点上跑一个 Envoy 实例。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;经过老夫目测，第三种方案比较妙，这样可以让 Contour 和 Envoy 这两个组件解耦，可以分别按需对不同的组件进行扩展，具体的优势如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Envoy 以 Daemonset 的形式运行，具有很强的扩展性，后续可通过 &lt;code&gt;ipvs&lt;/code&gt; 和 &lt;code&gt;keepalived&lt;/code&gt; 等工具来实现其负载均衡和高可用。&lt;/li&gt;
&lt;li&gt;Envoy 运行的网络模式是 &lt;code&gt;hostNetwork&lt;/code&gt;，减少了额外的网络性能损耗。&lt;/li&gt;
&lt;li&gt;Contour 与 Envoy 之间通过双向认证的自签名证书进行通信，大大增强了安全性。&lt;/li&gt;
&lt;li&gt;升级 Contour 不需要重启 Envoy。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1737323/201908/1737323-20190830081813190-1670957741.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;听起来好像不错的样子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1737323/201908/1737323-20190830081815141-533619188.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们就采用第三种方案来部署，首先克隆官方仓库，进入 manifest 清单目录：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ git clone https://github.com/heptio/contour
$ cd contour/examples/ds-hostnet-split&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了便于查看 envoy 的配置，修改 &lt;code&gt;03-envoy.yaml&lt;/code&gt;，将 envoy 的 &lt;code&gt;admin-adress&lt;/code&gt; 设置为 0.0.0.0，并暴露 9001 端口：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;...省略...
initContainers:
- args:
  - bootstrap
  - --admin-address=0.0.0.0
  - /config/contour.json
...省略...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将 Envoy Service 的类型改为 &lt;code&gt;ClusterIP&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;$ cat 02-service-envoy.yaml
apiVersion: v1
kind: Service
metadata:
 name: envoy
 namespace: heptio-contour
 annotations:
   service.beta.kubernetes.io/aws-load-balancer-type: nlb
spec:
 externalTrafficPolicy: Local
 ports:
 - port: 80
   name: http
   protocol: TCP
 - port: 443
   name: https
   protocol: TCP
 selector:
   app: envoy
 type: ClusterIP&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;部署：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ kubectl apply ./&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看状态：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ kubectl -n heptio-contour get pod
NAME                       READY   STATUS      RESTARTS   AGE
contour-767fd99989-27qjw   0/1     Running     0          21s
contour-767fd99989-kcjxz   0/1     Running     0          21s
contour-certgen-29nqs      0/1     Completed   0          21s
envoy-cnzvm                0/1     Running     0          21s
envoy-lb8mm                0/1     Running     0          21s
envoy-qzmt4                0/1     Running     0          21s

$ kubectl -n heptio-contour get job
NAME              COMPLETIONS   DURATION   AGE
contour-certgen   1/1           2s         4m42s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;contour-certgen&lt;/code&gt; 是一个 Job，它会生成有效期为一年的 mTLS（双向认证）证书，并将其挂载到 Contour 和 Envoy 的容器中。如果你想自定义证书，可以参考&lt;a href=&quot;https://github.com/heptio/contour/blob/master/docs/grpc-tls-howto.md&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;5.71875&quot;&gt;
&lt;p&gt;如果你还没有部署 Kubernetes 集群怎么办？废话，当然是用 &lt;a href=&quot;https://www.yangcs.net/posts/sealos/&quot;&gt;sealos&lt;/a&gt; 啊！分分钟搞起一个高可用集群。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;ingress-测试&quot;&gt;2. Ingress 测试&lt;/h2&gt;
&lt;p&gt;安装结束后，我们就可以来测试 Ingress 了。在 &lt;code&gt;examples/example-workload&lt;/code&gt; 目录下包含一个示例应用，可以直接使用：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ kubectl apply -f examples/example-workload/kuard-ingressroute.yaml&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看创建好的资源：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ kubectl get po,svc,ingressroute -l app=kuard
NAME                         READY   STATUS    RESTARTS   AGE
pod/kuard-67789b8754-5c4w7   1/1     Running   0          63s
pod/kuard-67789b8754-fpdfb   1/1     Running   0          63s
pod/kuard-67789b8754-fx9bn   1/1     Running   0          63s

NAME            TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE
service/kuard   ClusterIP   10.97.46.79   &amp;lt;none&amp;gt;        80/TCP    63s

NAME                                    FQDN          TLS SECRET   FIRST ROUTE   STATUS   STATUS DESCRIPTION
ingressroute.contour.heptio.com/kuard   kuard.local                /             valid    valid IngressRoute&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将域名加入本地电脑的 hosts：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ echo &quot;$INGRESS_HOST kuard.local&quot; &amp;gt;&amp;gt; /etc/hosts&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;$INGRESS_HOST&lt;/code&gt; 是任意运行 Envoy 节点的 IP。&lt;/p&gt;
&lt;p&gt;现在我们就可以在浏览器中输入域名 &lt;code&gt;kuard.local&lt;/code&gt; 访问应用了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1737323/201908/1737323-20190830081820535-1448784607.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;contour-工作原理&quot;&gt;3. Contour 工作原理&lt;/h2&gt;
&lt;p&gt;Contour 同时支持 &lt;code&gt;Ingress&lt;/code&gt; 资源对象和 &lt;code&gt;IngressRoute&lt;/code&gt; 资源对象（通过 CRD 创建），这些对象都是为进入集群的请求提供路由规则的集合。这两个对象的结构和实现方式有所不同，但它们的核心意图是相同的，都是为进入集群的请求提供路由规则。如不作特殊说明，后面当我们描述 “Ingress” 时，它将同时适用于 &lt;code&gt;Ingress&lt;/code&gt; 和 &lt;code&gt;IngressRoute&lt;/code&gt; 对象。&lt;/p&gt;
&lt;p&gt;通常情况下，当 Envoy 配置了 &lt;code&gt;CDS&lt;/code&gt; 的 endpoint 时，它会定期轮询端点，然后将返回的 JSON 片段合并到其运行配置中。如果返回到 Envoy 的集群配置代表当前的 Ingress 对象的集合，则可以将 Contour 视为从 &lt;code&gt;Ingress&lt;/code&gt; 对象到 &lt;code&gt;Envoy&lt;/code&gt; 集群配置的转换器。随着 Ingress 对象的添加和删除，Envoy 会动态添加并删除相关配置，而无需不断重新加载配置。&lt;/p&gt;
&lt;p&gt;在实践中，将 Ingress 对象转换为 Envoy 配置更加微妙，需要将 Envoy 中的 xDS 配置（包括 &lt;code&gt;CDS&lt;/code&gt;，&lt;code&gt;EDS&lt;/code&gt; 和 &lt;code&gt;RDS&lt;/code&gt;）映射到 Kubernetes 中。Contour 至少需要观察 &lt;code&gt;Ingress&lt;/code&gt;、&lt;code&gt;Service&lt;/code&gt; 和 &lt;code&gt;Endpoint&lt;/code&gt; 这几个资源对象以构建这些服务的响应，它通过 &lt;code&gt;client-go&lt;/code&gt; 的 &lt;a href=&quot;https://www.kubernetes.org.cn/2693.html&quot;&gt;cache/informer&lt;/a&gt; 机制免费获得这些 &lt;code&gt;watchers&lt;/code&gt;。这些 watchers 提供添加，更新和删除对象的边缘触发通知，也可以通过 &lt;code&gt;watch API&lt;/code&gt; 在本地缓存缓存对象，以便后续查询。&lt;/p&gt;
&lt;p&gt;Contour 将收集到的这些对象处理为虚拟主机及其路由规则的&lt;strong&gt;有向非循环图&lt;/strong&gt;（DAG），这表明 Contour 将有权构建路由规则的顶级视图，并将群集中的相应服务和TLS秘钥连接在一起。一旦构建了这个新的数据结构，我们就可以轻松实现 &lt;code&gt;IngressRoute&lt;/code&gt; 对象的验证，授权和分发。改数据结构导出的 &lt;code&gt;png&lt;/code&gt; 图片如下图所示：&lt;/p&gt;
&lt;center&gt;![](https://img2018.cnblogs.com/blog/1737323/201908/1737323-20190830081821412-1339276196.jpg)&lt;/center&gt;
&lt;p&gt;Envoy API 调用和 Kubernetes API 资源之间的映射关系如下：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;CDS&lt;/strong&gt; : 集群发现服务。映射为 Kubernetes 中的 &lt;code&gt;Service&lt;/code&gt; 以及一部分 Ingress 对象的 &lt;code&gt;TLS&lt;/code&gt; 配置。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;EDS&lt;/strong&gt; : 服务发现服务。映射为 Kubernetes 中的 &lt;code&gt;Endpoint&lt;/code&gt;。Envoy 使用 EDS 自动获取 &lt;code&gt;Cluster&lt;/code&gt; 成员，这与 Endpoint 对象中包含的信息非常匹配。Envoy 使用 Contour 在 &lt;code&gt;EDS&lt;/code&gt; 响应中返回的名称查询 &lt;code&gt;EDS&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;RDS&lt;/strong&gt; : 路由发现服务。映射为 Kubernetes 中的 &lt;code&gt;Ingress&lt;/code&gt;。提供了虚拟主机名和前缀路由信息的 RDS 与 Ingress 匹配得更好。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;映射关系详情&quot;&gt;4. 映射关系详情&lt;/h2&gt;
&lt;h3 id=&quot;cds&quot;&gt;CDS&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;CDS&lt;/code&gt; 更像是 Kubernetes 中的 &lt;code&gt;Service&lt;/code&gt; 资源，因为 Service 是具体 &lt;code&gt;Endpoint&lt;/code&gt;（Pods）的抽象，Envoy Cluster 是指 Envoy 连接到的一组逻辑上相似的上游主机（参考下文的 RDS）。其中 &lt;code&gt;TLS&lt;/code&gt; 配置也是 CDS 的一部分，而 Kubernetes 中的 TLS 信息由 Ingress 提供，所以这部分之间的映射关系会有些复杂。&lt;/p&gt;
&lt;h3 id=&quot;eds&quot;&gt;EDS&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;EDS&lt;/code&gt; 更像是 Kubernetes 中的 &lt;code&gt;Endpoint&lt;/code&gt; 资源，这部分映射关系的实现最简单。Contour 将 Endpoint 的响应对象转换为 EDS 的 &lt;code&gt;{ address: [] }&lt;/code&gt; json 配置块。&lt;/p&gt;
&lt;h3 id=&quot;rds&quot;&gt;RDS&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;RDS&lt;/code&gt; 更像是 Kubernetes 中的 &lt;code&gt;Ingress&lt;/code&gt; 资源。RDS 将前缀，路径或正则表达式之一路由到 Envoy 群集。Envoy 集群的名称可以从 Ingress 的 &lt;code&gt;IngressSpec&lt;/code&gt; 的配置项中获取（比如：&lt;code&gt;namespace/serviceName_servicePort&lt;/code&gt;），因为这是一个选择器，它会匹配 Service 对象被转换后返回的 CDS 对象。&lt;/p&gt;
&lt;h2 id=&quot;contour-架构分析&quot;&gt;5. Contour 架构分析&lt;/h2&gt;
&lt;p&gt;Contour Ingress controller 由两个组件组成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Envoy&lt;/code&gt; : 提供高性能反向代理。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Contour&lt;/code&gt; : 充当 Envoy 的控制平面，为 Envoy 的路由配置提供统一的来源。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以本文的部署方式为例，在 Envoy 的 Pod 初始化期间，Contour 作为 &lt;code&gt;Init&lt;/code&gt; 容器运行，并将 bootstrap（初始化）配置写入一个 temporary volume。该 &lt;code&gt;Volume&lt;/code&gt; 被传递给 Envoy 容器并告诉 Envoy 将另一个 Deployment 中的 Contour 容器视为控制平面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1737323/201908/1737323-20190830081825471-1322826078.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;初始化完成后，Envoy 容器启动，检索 Contour 写入的 bootstrap 配置，并开始轮询 Contour 以热更新配置。如果控制平面无法访问，Envoy 将会进行优雅重试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1737323/201908/1737323-20190830081828415-2091491053.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Contour 相当于 Kubernetes API 的客户端。它监视 &lt;code&gt;Ingress&lt;/code&gt;，&lt;code&gt;Service&lt;/code&gt; 和 &lt;code&gt;Endpoint&lt;/code&gt; 对象，并通过将其对象缓存转换为相关的 &lt;code&gt;JSON&lt;/code&gt; 字段来充当其 Envoy 的控制平面。&lt;/p&gt;
&lt;p&gt;从 Kubernetes 到 Contour 的信息转换是通过 &lt;code&gt;SharedInformer&lt;/code&gt; 框架 watching API 来完成的；而从 Contour 到 Envoy 的信息转换是通过 Envoy 定期轮询来实现的。&lt;/p&gt;
&lt;h2 id=&quot;ingressroute-介绍&quot;&gt;6. IngressRoute 介绍&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/docs/concepts/services-networking/ingress/&quot;&gt;Ingress&lt;/a&gt; 对象从 Kubernetes 1.1 版本开始被引进，用来描述进入集群的请求的 HTTP 路由规则。但迄今为止 Ingress 对象还停留在 &lt;code&gt;beta&lt;/code&gt; 阶段，不同的 Ingress Controller 插件为了添加 HTTP 路由的额外属性，只能通过添加大量的 &lt;code&gt;annotation&lt;/code&gt; 来实现，而且每个插件的 annotation 都不一样，非常混乱。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IngressRoute&lt;/code&gt; CRD 的目标就是扩展 Ingress API 的功能，以便提供更丰富的用户体验以及解决原始设计中的缺点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目前 Contour 是唯一支持 IngressRoute CRD 的 Kubernetes Ingress Controller。&lt;/strong&gt;下面就来看看它与 Ingress 相比的优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;安全地支持多团队 Kubernetes 集群，能够限制哪些命名空间可以配置虚拟主机和 TLS 凭据。&lt;/li&gt;
&lt;li&gt;允许将路径或域名的路由配置分发给另一个命名空间。&lt;/li&gt;
&lt;li&gt;接受单个路由中的多个服务，并对它们之间的流量进行负载均衡。&lt;/li&gt;
&lt;li&gt;无需通过添加 &lt;code&gt;annotation&lt;/code&gt; 就可以定义服务权重和负载均衡策略。&lt;/li&gt;
&lt;li&gt;在创建时验证 IngressRoute 对象，并在创建后报告验证是否有效。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;从-ingress-到-ingressroute&quot;&gt;从 Ingress 到 IngressRoute&lt;/h3&gt;
&lt;p&gt;一个基本的 &lt;code&gt;Ingress&lt;/code&gt; 对象如下所示：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# ingress.yaml
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: basic
spec:
  rules:
  - host: foo-basic.bar.com
    http:
      paths:
      - backend:
          serviceName: s1
          servicePort: 80&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个 Ingress 对象名为 &lt;code&gt;basic&lt;/code&gt;，它将传入的 HTTP 流量路由到头文件中 &lt;code&gt;Host:&lt;/code&gt; 字段值为 &lt;code&gt;foo-basic.bar.com&lt;/code&gt; 且端口为 80 的 &lt;code&gt;s1&lt;/code&gt; 服务。该路由规则通过 &lt;code&gt;IngressRoute&lt;/code&gt; 来实现如下：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# ingressroute.yaml
apiVersion: contour.heptio.com/v1beta1
kind: IngressRoute
metadata:
  name: basic
spec:
  virtualhost:
    fqdn: foo-basic.bar.com
  routes:
    - match: /
      services:
        - name: s1
          port: 80&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应关系很简单，我就不再详细介绍了，更多功能配置可以参考官方仓库的文档：&lt;a href=&quot;https://github.com/heptio/contour/blob/master/docs/ingressroute.md&quot;&gt;IngressRoute&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;envoy-初始配置文件&quot;&gt;7. Envoy 初始配置文件&lt;/h2&gt;
&lt;p&gt;Contour 会根据启动参数和 K8S API Server 中的配置信息生成 Envoy 的初始配置文件，可以使用下面的命令将 Envoy Pod 中的配置文件导出来查看其中的内容：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ kubectl -n heptio-contour exec envoy-lb8mm -- cat /config/envoy.json &amp;gt; envoy.json&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打开网站 &lt;a href=&quot;https://www.bejson.com/jsonviewernew/&quot; class=&quot;uri&quot;&gt;https://www.bejson.com/jsonviewernew/&lt;/a&gt;，将配置文件内容复制粘贴进去，可以看到配置文件的结构如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1737323/201908/1737323-20190830081828628-449891238.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中各个配置节点的内容如下：&lt;/p&gt;
&lt;h3 id=&quot;dynamic_resources&quot;&gt;Dynamic_resources&lt;/h3&gt;
&lt;p&gt;配置动态资源,这里配置了 LDS 和 RDS 服务器。&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;&quot;dynamic_resources&quot;: {
  &quot;lds_config&quot;: {
    &quot;api_config_source&quot;: {
      &quot;api_type&quot;: &quot;GRPC&quot;,
      &quot;grpc_services&quot;: [
        {
          &quot;envoy_grpc&quot;: {
            &quot;cluster_name&quot;: &quot;contour&quot;
          }
        }
      ]
    }
  },
  &quot;cds_config&quot;: {
    &quot;api_config_source&quot;: {
      &quot;api_type&quot;: &quot;GRPC&quot;,
      &quot;grpc_services&quot;: [
        {
          &quot;envoy_grpc&quot;: {
            &quot;cluster_name&quot;: &quot;contour&quot;
          }
        }
      ]
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;static_resources&quot;&gt;Static_resources&lt;/h3&gt;
&lt;p&gt;配置静态资源，包括了 &lt;code&gt;contour&lt;/code&gt; 和 &lt;code&gt;service-stats&lt;/code&gt; 两个 cluster，其中 contour cluster 对应前面 dynamic_resources 中的 LDS 和 RDS 配置，指明了 Envoy 用于获取动态资源的服务器地址。&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;&quot;static_resources&quot;: {
  &quot;clusters&quot;: [
    {
      &quot;name&quot;: &quot;contour&quot;,
      &quot;alt_stat_name&quot;: &quot;heptio-contour_contour_8001&quot;,
      &quot;type&quot;: &quot;STRICT_DNS&quot;,
      &quot;connect_timeout&quot;: &quot;5s&quot;,
      &quot;load_assignment&quot;: {
        &quot;cluster_name&quot;: &quot;contour&quot;,
        &quot;endpoints&quot;: [
          {
            &quot;lb_endpoints&quot;: [
              {
                &quot;endpoint&quot;: {
                  &quot;address&quot;: {
                    &quot;socket_address&quot;: {
                      &quot;address&quot;: &quot;contour&quot;,
                      &quot;port_value&quot;: 8001
                    }
                  }
                }
              }
            ]
          }
        ]
      },
      &quot;circuit_breakers&quot;: {
        &quot;thresholds&quot;: [
          {
            &quot;priority&quot;: &quot;HIGH&quot;,
            &quot;max_connections&quot;: 100000,
            &quot;max_pending_requests&quot;: 100000,
            &quot;max_requests&quot;: 60000000,
            &quot;max_retries&quot;: 50
          },
          {
            &quot;max_connections&quot;: 100000,
            &quot;max_pending_requests&quot;: 100000,
            &quot;max_requests&quot;: 60000000,
            &quot;max_retries&quot;: 50
          }
        ]
      },
      &quot;tls_context&quot;: {
        &quot;common_tls_context&quot;: {
          &quot;tls_certificates&quot;: [
            {
              &quot;certificate_chain&quot;: {
                &quot;filename&quot;: &quot;/certs/tls.crt&quot;
              },
              &quot;private_key&quot;: {
                &quot;filename&quot;: &quot;/certs/tls.key&quot;
              }
            }
          ],
          &quot;validation_context&quot;: {
            &quot;trusted_ca&quot;: {
              &quot;filename&quot;: &quot;/ca/cacert.pem&quot;
            },
            &quot;verify_subject_alt_name&quot;: [
              &quot;contour&quot;
            ]
          }
        }
      },
      &quot;http2_protocol_options&quot;: {}
    },
    {
      &quot;name&quot;: &quot;service-stats&quot;,
      &quot;alt_stat_name&quot;: &quot;heptio-contour_service-stats_9001&quot;,
      &quot;type&quot;: &quot;LOGICAL_DNS&quot;,
      &quot;connect_timeout&quot;: &quot;0.250s&quot;,
      &quot;load_assignment&quot;: {
        &quot;cluster_name&quot;: &quot;service-stats&quot;,
        &quot;endpoints&quot;: [
          {
            &quot;lb_endpoints&quot;: [
              {
                &quot;endpoint&quot;: {
                  &quot;address&quot;: {
                    &quot;socket_address&quot;: {
                      &quot;address&quot;: &quot;0.0.0.0&quot;,
                      &quot;port_value&quot;: 9001
                    }
                  }
                }
              }
            ]
          }
        ]
      }
    }
  ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;admin&quot;&gt;Admin&lt;/h3&gt;
&lt;p&gt;配置 Envoy 的日志路径以及管理端口。&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;&quot;admin&quot;: {
  &quot;access_log_path&quot;: &quot;/dev/null&quot;,
  &quot;address&quot;: {
    &quot;socket_address&quot;: {
      &quot;address&quot;: &quot;0.0.0.0&quot;,
      &quot;port_value&quot;: 9001
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结合 Envoy 的初始化配置文件和第 5 节的分析，我们可以大致看到 Contour 通过 Envoy 来实现南北流量管理的基本原理。即控制平面将 xDS server 信息通过 &lt;code&gt;static resource&lt;/code&gt; 的方式配置到 Envoy 的初始化配置文件中，Envoy 启动后通过 xDS server 获取到 &lt;code&gt;dynamic resource&lt;/code&gt;，包括集群中的 service 信息及路由规则。&lt;/p&gt;
&lt;p&gt;Envoy 配置初始化流程：&lt;/p&gt;
&lt;p&gt;&lt;embed src=&quot;https://img2018.cnblogs.com/blog/1737323/201908/1737323-20190830081829060-663513515.svg+xml&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Envoy initContainer 根据启动参数和 K8S API Server 中的配置信息生成 Envoy 的初始配置文件 &lt;code&gt;envoy.json&lt;/code&gt;，该文件告诉 Envoy 从 &lt;code&gt;xDS server&lt;/code&gt; 中获取动态配置信息，并配置了 xDS server 的地址信息，即控制平面的 &lt;code&gt;Contour&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Envoy 使用配置文件 &lt;code&gt;envoy.json&lt;/code&gt; 启动。&lt;/li&gt;
&lt;li&gt;Envoy 根据获取到的动态配置启动 Listener，并根据 Listener 的配置，结合 Route 和 Cluster 对进入的流量进行处理。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;ingressroute-配置映射&quot;&gt;8. IngressRoute 配置映射&lt;/h2&gt;
&lt;p&gt;通过上节的分析我们知道，Envoy 中实际生效的配置是由初始化配置文件中的静态配置和从 Contour 获取的动态配置一起组成的，我们可以通过 Envoy 的管理接口来获取 Envoy 的完整配置，先打开 Envoy 的管理接口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1737323/201908/1737323-20190830081833769-686822703.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后点击 &lt;code&gt;config_dump&lt;/code&gt;，就能看到 Envoy 的完整配置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1737323/201908/1737323-20190830081837034-866843308.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们在第二节创建了一个 ingressroute，现在来看看它是怎么映射到 Envoy 的配置文件中的。你可以到 &lt;code&gt;config_dump&lt;/code&gt; 中查找相关配置，但还有更好的办法，我们可以通过 Contour 的命令行工具直接调用 Contour 的 xDS gRPC 接口来分别查看 Envoy 的 Listener、Route、Cluster 和 Endpoint 配置。&lt;/p&gt;
&lt;p&gt;Contour 总共有两个实例，通过选举来实现高可用，被选中的实例作为 &lt;code&gt;leader&lt;/code&gt; 来对外提供服务。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ kubectl -n heptio-contour get pod -l app=contour

NAME                       READY   STATUS    RESTARTS   AGE
contour-767fd99989-27qjw   1/1     Running   0          14h
contour-767fd99989-kcjxz   0/1     Running   0          14h&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看看哪个是 leader：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1737323/201908/1737323-20190830081839671-310501882.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到该实例不是 leader，我们到另一个实例中去查看 Envoy xDS 配置。&lt;/p&gt;
&lt;h3 id=&quot;listener&quot;&gt;Listener&lt;/h3&gt;
&lt;p&gt;Envoy 采用 listener 来接收并处理 &lt;code&gt;downstream&lt;/code&gt; 发过来的请求，listener 的处理逻辑是插件式的，可以通过配置不同的 filter 来插入不同的处理逻辑。Listener 可以绑定到 &lt;code&gt;IP Socket&lt;/code&gt; 或者 &lt;code&gt;Unix Domain Socket&lt;/code&gt; 上，也可以不绑定到一个具体的端口上，而是接收从其他 listener 转发来的数据。&lt;/p&gt;
&lt;p&gt;Listener 的配置可以通过下面的命令查看：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ kubectl -n heptio-contour exec -it contour-767fd99989-27qjw -- contour cli --cafile=/ca/cacert.pem --cert-file=/certs/tls.crt --key-file=/certs/tls.key lds&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1737323/201908/1737323-20190830081846808-602032242.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到 Listener 被绑定到了 80 端口上，同时通过 RDS 配置了一个路由规则 &lt;code&gt;ingress_http&lt;/code&gt;，在路由规则中再根据不同的请求目的地对请求进行处理。&lt;/p&gt;
&lt;h3 id=&quot;route&quot;&gt;Route&lt;/h3&gt;
&lt;p&gt;Route 用来配置 Envoy 的路由规则，根据 host 来对请求进行路由分发。&lt;/p&gt;
&lt;p&gt;Route 的配置可以通过下面的命令查看：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ kubectl -n heptio-contour exec -it contour-767fd99989-27qjw -- contour cli --cafile=/ca/cacert.pem --cert-file=/certs/tls.crt --key-file=/certs/tls.key rds&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1737323/201908/1737323-20190830081853812-1217273366.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面是 &lt;code&gt;ingress_http&lt;/code&gt; 的路由配置，对应了两个 &lt;code&gt;virtual host&lt;/code&gt;，其中一个是默认路由（图中省略），上面展示的是 kuard 的路由，对应到 Cluster &lt;code&gt;default/kuard/80/da39a3ee5e&lt;/code&gt;。其中 &lt;code&gt;domains: &quot;kuard.local:*&quot;&lt;/code&gt; 表示允许访问的域名为 kuard.local，端口可以是任意值。&lt;/p&gt;
&lt;h3 id=&quot;cluster&quot;&gt;Cluster&lt;/h3&gt;
&lt;p&gt;Cluster 是一个服务集群，Cluster 中包含一个到多个 endpoint，每个 endpoint 都可以提供服务，Envoy 根据负载均衡算法将请求发送到这些 endpoint 中。&lt;/p&gt;
&lt;p&gt;Cluster 的配置可以通过下面的命令查看：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ kubectl -n heptio-contour exec -it contour-767fd99989-27qjw -- contour cli --cafile=/ca/cacert.pem --cert-file=/certs/tls.crt --key-file=/certs/tls.key cds&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1737323/201908/1737323-20190830081859355-896835908.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cluster_name: &quot;contour&quot;&lt;/code&gt; 表示通过 xDS 接口从 contour 控制平面动态获取 Endpoint 信息。获取到的 Endpoint 是 &lt;code&gt;default/kuard&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;endpoint&quot;&gt;Endpoint&lt;/h3&gt;
&lt;p&gt;Endpoint 就对应到 Kubernetes 中的 &lt;code&gt;Endpoint&lt;/code&gt; 资源，对应的即是 Pod 的 &lt;code&gt;IP+Port&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Cluster 的配置可以通过下面的命令查看：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ kubectl -n heptio-contour exec -it contour-767fd99989-27qjw -- contour cli --cafile=/ca/cacert.pem --cert-file=/certs/tls.crt --key-file=/certs/tls.key eds|grep &quot;default/kuard&quot; -A 34 -B 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1737323/201908/1737323-20190830081906630-1115288474.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;验证一下：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ kubectl get ep -l app=kuard

NAME    ENDPOINTS                                                     AGE
kuard   100.118.117.18:8080,100.119.55.150:8080,100.91.147.204:8080   17h&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;对接监控&quot;&gt;9. 对接监控&lt;/h2&gt;
&lt;p&gt;Contour 和 Envoy 都暴露一些监控指标可以被 &lt;code&gt;Prometheus&lt;/code&gt; 抓取，官方也提供了 Prometheus 和 Grafana 的部署模板，但一般情况下我们都会有自己的监控系统，比如 &lt;a href=&quot;https://github.com/coreos/prometheus-operator&quot;&gt;prometheus-operator&lt;/a&gt;，只需要将官方的 Grafana 模板导入自己的 Grafana 中就可以了，后续会探讨详细步骤。&lt;/p&gt;
&lt;h3 id=&quot;envoy-metrics&quot;&gt;Envoy Metrics&lt;/h3&gt;
&lt;p&gt;Envoy 默认通过 admin 接口暴露监控指标，为了避免暴露 admin 接口，Contour 创建了一个静态 Listener，只将访问路径为 &lt;code&gt;/stats&lt;/code&gt; 的流量转发到 &lt;code&gt;service-stats&lt;/code&gt; Cluster，即 admin 接口，其他所有请求一律拒绝访问。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1737323/201908/1737323-20190830081911384-2139087484.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1737323/201908/1737323-20190830081913214-995865274.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本文只是为了方便查看，才将 admin 接口的 IP 改为 0.0.0.0，生产环境建议不要改，默认值为 &lt;code&gt;127.0.0.1&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以 Envoy 在 &lt;code&gt;8002&lt;/code&gt; 端口暴露监控指标，路径为 &lt;code&gt;/stats/prometheus&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;contour-metrics&quot;&gt;Contour Metrics&lt;/h3&gt;
&lt;p&gt;Contour 在 &lt;code&gt;8000&lt;/code&gt; 端口上暴露监控指标，路径为 &lt;code&gt;/metrics&lt;/code&gt;。包含以下监控指标：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;contour_ingressroute_total (gauge)&lt;/strong&gt; : IngressRoute 的总数量，包括状态为 &lt;code&gt;Valid / Invalid / Orphaned&lt;/code&gt; 的 IngressRoute。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;contour_ingressroute_orphaned_total (gauge)&lt;/strong&gt; : 状态为 &lt;code&gt;Orphaned&lt;/code&gt; 的 IngressRoute 数量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;contour_ingressroute_root_total (gauge)&lt;/strong&gt; : &lt;code&gt;Root&lt;/code&gt; IngressRoute 的数量（每个 vhost 只有一个 Root IngressRoute）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;contour_ingressroute_valid_total (gauge)&lt;/strong&gt; : 状态为 &lt;code&gt;Valid&lt;/code&gt; 的 IngressRoute 数量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;contour_ingressroute_invalid_total (gauge)&lt;/strong&gt; : 状态为 &lt;code&gt;Invalid&lt;/code&gt; 的 IngressRoute 数量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;contour_ingressroute_dagrebuild_timestamp (gauge)&lt;/code&gt; : 最近一次重建 DAG 的时间戳。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面就来教大家怎么将 Contour 接入 Prometheus-Operator，对 Prometheus-Operator 不熟的同学，推荐看一下张馆长的这篇文章：&lt;a href=&quot;https://www.servicemesher.com/blog/prometheus-operator-manual/&quot;&gt;全手动部署prometheus-operator监控Kubernetes集群遇到的坑&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;rbac-授权&quot;&gt;RBAC 授权&lt;/h3&gt;
&lt;p&gt;为了让 Prometheus 能够 &lt;code&gt;list&lt;/code&gt; 其他 namespace 中的 pod，我们需要赋予它相应的权限，首先进入 &lt;code&gt;kube-prometheus&lt;/code&gt; 项目的 manifests 目录：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ cd kube-prometheus/manifests

$ ll *SpecificNamespace*
4 -rw-r--r-- 1 root root  988 8月  27 05:22 prometheus-roleBindingSpecificNamespaces.yaml
4 -rw-r--r-- 1 root root 1078 8月  27 05:15 prometheus-roleSpecificNamespaces.yaml&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改 &lt;code&gt;prometheus-roleSpecificNamespaces.yaml&lt;/code&gt;，向其中添加如下的 Role：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;- apiVersion: rbac.authorization.k8s.io/v1
  kind: Role
  metadata:
    name: prometheus-k8s
    namespace: heptio-contour
  rules:
  - apiGroups:
    - &quot;&quot;
    resources:
    - services
    - endpoints
    - pods
    verbs:
    - get
    - list
    - watch&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改 &lt;code&gt;prometheus-roleBindingSpecificNamespaces.yaml&lt;/code&gt;，向其中添加如下的 RoleBinding：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;- apiVersion: rbac.authorization.k8s.io/v1
  kind: RoleBinding
  metadata:
    name: prometheus-k8s
    namespace: heptio-contour
  roleRef:
    apiGroup: rbac.authorization.k8s.io
    kind: Role
    name: prometheus-k8s
  subjects:
  - kind: ServiceAccount
    name: prometheus-k8s
    namespace: monitoring&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后创建相应的 &lt;code&gt;Role&lt;/code&gt; 和 &lt;code&gt;RoleBinding&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ kubectl apply -f prometheus-roleSpecificNamespaces.yaml
$ kubectl apply -f prometheus-roleBindingSpecificNamespaces.yaml&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;修改-contour-manifest-文件&quot;&gt;修改 Contour manifest 文件&lt;/h3&gt;
&lt;p&gt;Prometheus 监控的对象被叫做 &lt;code&gt;Target&lt;/code&gt;，Target 通过 Cluster 中的 &lt;code&gt;Endpoint&lt;/code&gt; 资源来定义，每个监控对象都有一个对应的 Endpoint。而 &lt;code&gt;ServiceMonitor&lt;/code&gt; 是 Target 的抽象，ServiceMonitor 通过标签来找到对应的 Endpoint，然后将相应的 Target 添加到 Prometheus 的监控列表中。&lt;/p&gt;
&lt;p&gt;默认情况下 Contour 的 Service 是没有打标签的，所以我们需要修改 yaml 文件，加上相应的标签。首先修改 Contour Deployment 的 yaml 文件：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# 03-contour.yaml
ports:
- containerPort: 8001
  name: xds
  protocol: TCP
- containerPort: 8000
  name: http-metrics # 将 name 改为 http-metrics
  protocol: TCP&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再修改 Contour Service 的 yaml 文件：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# 02-service-envoy.yaml
ports:
- port: 80
  name: http
  protocol: TCP
- port: 443
  name: https
  protocol: TCP
# 添加新端口
- port: 8002
  name: http-metrics
  protocol: TCP&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Envoy 类似，先修改 Envoy Deployment 的 yaml 文件：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# 03-envoy.yaml
ports:
- containerPort: 80
  hostPort: 80
  name: http
  protocol: TCP
- containerPort: 443
  hostPort: 443
  name: https
  protocol: TCP
# 添加新端口
- containerPort: 8002
  hostPort: 8002
  name: http-metrics
  protocol: TCP&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再修改 Envoy Service 的 yaml 文件：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# 02-service-envoy.yaml
ports:
- port: 80
  name: http
  protocol: TCP
- port: 443
  name: https
  protocol: TCP
# 添加新端口
- port: 8002
  name: http-metrics
  protocol: TCP&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后重新 apply 一下：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 在 contour/examples/ds-hostnet-split 目录下
$ kubectl apply -f ./&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建-servicemonitor&quot;&gt;创建 ServiceMonitor&lt;/h3&gt;
&lt;p&gt;接下来就是创建相应的 &lt;code&gt;ServiceMonitor&lt;/code&gt; 来抓取指标数据，没什么好说的，自己看 yaml 文件：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;$ cat prometheus-serviceMonitorContour.yaml

apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  labels:
    app: contour
  name: contour
  namespace: monitoring
spec:
  endpoints:
  - interval: 30s
    port: http-metrics
  jobLabel: app
  namespaceSelector:
    matchNames:
    - heptio-contour
  selector:
    matchLabels:
      app: contour
---
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  labels:
    app: envoy
  name: envoy
  namespace: monitoring
spec:
  endpoints:
  - interval: 30s
    path: /stats/prometheus
    port: http-metrics
  namespaceSelector:
    matchNames:
    - heptio-contour
  selector:
    matchLabels:
      app: envoy&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建-ingressroute&quot;&gt;创建 IngressRoute&lt;/h3&gt;
&lt;p&gt;为了查看 &lt;code&gt;Prometheus&lt;/code&gt; 和 &lt;code&gt;Grafana&lt;/code&gt; 的 Dashboard，我们需要为它们创建相应的 IngressRoute，yaml 文件内容如下：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# ingressroute-prometheus.yaml
apiVersion: contour.heptio.com/v1beta1
kind: IngressRoute
metadata:
  labels:
    app: grafana
  name: grafana
  namespace: monitoring
spec:
  virtualhost:
    fqdn: grafana.sealos.io
  routes:
    - match: /
      services:
        - name: grafana
          port: 3000
---
apiVersion: contour.heptio.com/v1beta1
kind: IngressRoute
metadata:
  labels:
    app: prometheus
  name: prometheus
  namespace: monitoring
spec:
  virtualhost:
    fqdn: prometheus.sealos.io
  routes:
    - match: /
      services:
        - name: prometheus-k8s
          port: 9090&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直接 apply：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ kubectl apply -f ingressroute-prometheus.yaml&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将域名写入本地电脑的 hosts 中：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ echo &quot;$INGRESS_HOST grafana.sealos.io&quot; &amp;gt;&amp;gt; /etc/hosts
$ echo &quot;$INGRESS_HOST prometheus.sealos.io&quot; &amp;gt;&amp;gt; /etc/hosts&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;$INGRESS_HOST&lt;/code&gt; 是任意运行 Envoy 节点的 IP。&lt;/p&gt;
&lt;p&gt;现在我们可以在浏览器中输入域名 &lt;code&gt;prometheus.sealos.io&lt;/code&gt; 来查看 Prometheus Target 状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1737323/201908/1737323-20190830081916180-312045884.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到这两个 Target 已经被抓取到了。&lt;/p&gt;
&lt;h3 id=&quot;导入-grafana-模板&quot;&gt;导入 Grafana 模板&lt;/h3&gt;
&lt;p&gt;前面提到 Contour 官方仓库中提供了 Grafana Dashboard 模板，现在我们要做的事就是把这个模板导入到自己的 Grafana 中。官方的 Grafana Dashboard 模板定义在 &lt;code&gt;contour/examples/grafana&lt;/code&gt; 目录下的 ConfigMap 文件中，可以先把它导出来：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 假设 contour 项目在你的 $HOME 目录
$ sed '/---/,$d' ~/contour/examples/grafana/02-grafana-configmap.yaml \
  sed 's/grafana-dashs/grafana-dashboard-contour/' \
  sed 's/contour-monitoring/monitoring/' \
  sed 's/kubernetes_pod_name/pod/g' \
  sed 's/ingress_http_update/update/g' \
  kubectl apply -f -
  
configmap/grafana-dashboard-contour created&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建了 &lt;code&gt;ConfigMap&lt;/code&gt; 后，还要再挂载到 Grafana 的 Dashboard 中，所以需要修改 Grafana Deployment 的 yaml 文件：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# ~/kube-prometheus/manifests/grafana-deployment.yaml
        volumeMounts:
        - mountPath: /var/lib/grafana
          name: grafana-storage
          readOnly: false
        ...省略...
        # 新增挂载
        - mountPath: /grafana-dashboard-definitions/0/contour
          name: grafana-dashboard-contour
          readOnly: false
        ...省略...
      volumes:
      - emptyDir: {}
        name: grafana-storage
      ...省略...
      # 新增 ConfigMap
      - configMap:
          name: grafana-dashboard-contour
        name: grafana-dashboard-contour&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重新 apply 一下：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ kubectl apply -f grafana-deployment.yaml&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在在浏览器中输入域名 &lt;code&gt;grafana.sealos.io&lt;/code&gt;，就可以看到 Contour 和 Envoy 的 Dashboard 了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1737323/201908/1737323-20190830081919141-1342653635.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1737323/201908/1737323-20190830081923873-1303277052.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对接监控到这里就结束了，剩下的大家可以自己去探索，总体来说难度还是稍微有点大，希望我的细心讲解能够帮助到你。&lt;/p&gt;
&lt;h2 id=&quot;微信公众号&quot;&gt;微信公众号&lt;/h2&gt;
&lt;p&gt;扫一扫下面的二维码关注微信公众号，在公众号中回复◉加群◉即可加入我们的云原生交流群，和孙宏亮、张馆长、阳明等大佬一起探讨云原生技术&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1737323/201908/1737323-20190830081931684-1840413347.gif&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 30 Aug 2019 00:20:00 +0000</pubDate>
<dc:creator>米开朗基杨</dc:creator>
<og:description>一种全新的 Ingress 实现方式——Envoy</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ryanyangcs/p/11432967.html</dc:identifier>
</item>
<item>
<title>使用coding和hexo快速搭建博客 - 风花雪月Zevs</title>
<link>http://www.cnblogs.com/zhsh666/p/11432965.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhsh666/p/11432965.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;欢迎访问我的个人博客皮皮猪：http://www.zhsh666.xyz&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;今天教大家怎么用hexo快速搭建自己的博客。我不是专业人士，不懂前端知识，所以我十分讨厌那些专业术语，讲了一大堆，对于技术小白来说，就像听天书一样，云里雾里的。所以下面的内容都是我自己的理解，语言很通俗，有可能说的不那么专业，还望专业人士勿喷。&lt;br/&gt;首先声明一点，刚开始搭建博客会比较麻烦，有很多东西大家可能以前没有听说过，不要怕，耐着性子一边看教程一边动手操作，你一定能够做出来的！好吧，废话不多说，现在开始！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;hexo&quot;&gt;hexo&lt;/h3&gt;
&lt;p&gt;hexo是一种博客框架，所谓框架，就是为了解决和处理一个复杂问题的结构，简单地说，用已经搭建好的框架来搭建博客，就不需要自己一砖一瓦地去构造了。&lt;/p&gt;
&lt;h3 id=&quot;git&quot;&gt;git&lt;/h3&gt;
&lt;p&gt;git是一种版本管理系统。当我们要开发一款软件时，软件有很多的功能需要完善，所以会出现很多版本，比如1.0,2.0等等，但是，当我们升级到高版本后，突然发现曾经的版本更好用，这时候该怎么办呢？那么git就是记录你们每次改版发生的改动，当你想要退回到某一个曾经的版本时，那么就用git直接回退到曾经的版本就可以了。这时候你可能会问，为什么你不把曾经的版本备份下来呢？这样不是更方便吗？想法很简单，但是一个软件有很多的版本，而且有些软件还很大，所以这样直接备份会占用很大空间，会浪费很多资源。而且，git会记录软件改版的详细信息，包括改版的时间，哪个文件发生了变化等等，所以用git管理开发十分方便，这也是未来的趋势。注意的是，git需要用命令行管理。&lt;/p&gt;
&lt;h3 id=&quot;github和coding&quot;&gt;GitHub和coding&lt;/h3&gt;
&lt;p&gt;这两个是线上的版本管理系统，你可以理解为线上的git，同时他们还有社区的性质。不同的是，GitHub是国外的，也可以说是世界的，因为有很多大牛在上面贡献自己的开源代码，包括Google，苹果，微软等等世界一流的工程师，在上面开发软件，会有更多的大牛给你提出意见，帮助你完成开发。而coding是中国的，相对来说名气更弱一些，但是访问速度快，还可以免费拥有私人仓库。所以，这篇教程我们使用coding pages部署博客。(注意：coding已被腾讯云收购)&lt;/p&gt;
&lt;h2 id=&quot;需要下载的东西&quot;&gt;需要下载的东西&lt;/h2&gt;
&lt;p&gt;1.git&lt;/p&gt;
&lt;p&gt;2.node.js&lt;/p&gt;
&lt;p&gt;3.notepad++&lt;/p&gt;
&lt;p&gt;4.hexo&lt;/p&gt;
&lt;p&gt;（这个需要用git命令行下载，没有安装包，需要在电脑的某一个盘里新建一个文件夹，名字可以随便取，比如hexo,用来存放你的博客代码，进入这个文件夹，右键，你会看到有git bash hexo的选项，点击，你就进入了git命令行，输入命令 npm install hexo-cli -g,稍等片刻，下面出现一堆英文，那证明已经下载完hexo了！）&lt;/p&gt;
&lt;p&gt;hexo的步骤不再重复，全在之前的博客里 &lt;a href=&quot;http://www.zhsh666.xyz/2019/08/14/GitHub-Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%8F%B2%E4%B8%8A%E6%9C%80%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/&quot;&gt;点这里跳转&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.weserv.nl/?url=https://pic.iqy.ink/2019/08/28/5d65c5c0351f7.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Step1:此时我们需要创建一个coding账号（注意codding已被腾讯云收购，&lt;a href=&quot;https://dev.tencent.com/login&quot;&gt;点击此处跳转&lt;/a&gt;），然后添加一个项目，项目名为你的coding账号名，例如我的账号名是Zevs6，所以我新建的项目为Zevs6，注意要在初始化项目那一项打勾&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.weserv.nl/?url=https://pic.iqy.ink/2019/08/28/5d65c6b89383f.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.weserv.nl/?url=https://pic.iqy.ink/2019/08/28/5d65c70a0687b.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Step2:进入项目 -&amp;gt; 设置 -&amp;gt; 部署公匙 -&amp;gt;新建部署公匙，给项目添加公匙SSH，ssh公匙获取方法和github一样直接在本地找到使用即可，在之前博客&lt;a href=&quot;http://www.zhsh666.xyz/2019/08/14/GitHub-Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%8F%B2%E4%B8%8A%E6%9C%80%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/&quot;&gt;点这里跳转&lt;/a&gt; 第四步有详细的介绍。公匙名称可以不填，但是授予推送权限选项必须打勾，这样你才有写权限&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.weserv.nl/?url=https://pic.iqy.ink/2019/08/28/5d65c9739350d.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;Step3: 在你的域名管理平台中（比如阿里云，腾讯云之类的），域名 -&amp;gt;管理-&amp;gt; 解析域名，增加一条CNAME信息，记录值为 &lt;a href=&quot;http://youruser.coding.me/&quot;&gt;youruser.coding.me&lt;/a&gt;（youruser为你的coding用户名）例如我的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.weserv.nl/?url=https://pic.iqy.ink/2019/08/28/5d65c792c4b72.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Step4:等到第三步的解析生效（最长十分钟），在coding中，项目 -&amp;gt; 代码 -&amp;gt; Pages服务中，一键部署Pages。在Pages的设置里，自定义自己的域名并绑定（域名前加www.前缀）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.weserv.nl/?url=https://pic.iqy.ink/2019/08/28/5d65c80a5be29.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Step5:在本地博客路径下，修改_config.yml下的deploy，改为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;deploy:
  type: git
  repo:
      coding: git@git.coding.net:yourname/yourname.git,master&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;格式一定要正确！！！不然会报错！！！&lt;/p&gt;
&lt;p&gt;Step6:&lt;/p&gt;
&lt;p&gt;​ 在本地博客路径下，执行命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hexo clean
hexo g
hexo d&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;hexo d 部署成功时会提示然您输入账号密码验证&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.weserv.nl/?url=https://pic.iqy.ink/2019/08/28/5d65cdaf5fa92.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 30 Aug 2019 00:19:00 +0000</pubDate>
<dc:creator>风花雪月Zevs</dc:creator>
<og:description>欢迎访问我的个人博客皮皮猪：http://www.zhsh666.xyz 今天教大家怎么用hexo快速搭建自己的博客。我不是专业人士，不懂前端知识，所以我十分讨厌那些专业术语，讲了一大堆，对于技术小白</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhsh666/p/11432965.html</dc:identifier>
</item>
<item>
<title>持续集成高级篇之Jekins参数传入与常见任务 - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11432953.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11432953.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/11204826.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有的童鞋可能已经发现,PipeLine项目与自由式项目相比,可配置的项少了很多,比如说环境变量定义,所有步骤完成后执行动作,拉git代码库等.其实这些功能并没有缺,而是配置的方式不一样了,以前是通过图形化界面配置,虽然直观简便,但是功能不能包罗万像,对于一些复杂的项目显得捉襟见肘,而Jenkins PipeLine使用代码配置功能更加强大.以后的章节中我们会介绍常用的配置如何通过PipeLine里的Groovy脚本来实现.&lt;/p&gt;
&lt;p&gt;前面讲参数化构建的时候已经讲到对于复杂的构建把一些重复的,常用的代码做成变量的重要性,这里讲解如何通过PipeLine方式定义项目级别的参数以及环境变量.&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;首先需要说明的是,节点级别和全局级别以及文件参数变量的配置在PipeLine里依然有效,读取的方式也一样,只是会有一些小坑,这里也会介绍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;PipeLine中可以定义变量和环境变量,下面分别介绍如何定义变量和环境变更.&lt;/p&gt;
&lt;h2 id=&quot;pipeline中定义变量&quot;&gt;PipeLine中定义变量&lt;/h2&gt;
&lt;p&gt;PipeLine中定义变量非常简单,只需要使用&lt;code&gt;def 变量名=变量值的形式即可&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;看如下PipeLine代码(大家自己创建项目)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;node {
    def hello=&quot;world&quot;
    stage(&quot;echo&quot;){
        bat &quot;echo $hello&quot;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上脚本中我们先是定义了一个名为&lt;code&gt;hello&lt;/code&gt;的变量,然后通过&lt;code&gt;$变量名&lt;/code&gt;方式获取到它,然后把它打印到控制台.&lt;/p&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;有些童鞋对以上代码可能有点懵圈,bat执行的字符串怎么能包含&lt;code&gt;$变量名&lt;/code&gt;这样的内容呢,bat不是只能解析&lt;code&gt;%变量名%&lt;/code&gt;类型的变量吗.实际上是&lt;code&gt;$变量名&lt;/code&gt;是groovy脚本插值语法,执行到这行文本的时候groovy就会去尝试解析&lt;code&gt;$变量名&lt;/code&gt;,对于本实例,groovy会解析&lt;code&gt;$hello&lt;/code&gt;,上面已经定义过,它的值是world,因此 groovy会把 &lt;code&gt;echo $hello&lt;/code&gt;先解析为'echo world'这样纯字符串,然后再传给bat执行.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;需要注意的是以上定义的变量并非环境变量,对于bat脚本,不能通过&lt;code&gt;%变量名%&lt;/code&gt;的形式被解析,因为环境变量中不存在这样一个环境变量名,因此bat无法解析它.当然对于定义的节点级别的或者全局的变量bat脚本仍然可以通过&lt;code&gt;%变量名%&lt;/code&gt;形式被解析.大家不要迷糊.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;pipeline中定义环境变量&quot;&gt;PipeLine中定义环境变量&lt;/h2&gt;
&lt;p&gt;上面定义变量的方式是定义了一个groovy变量,我们也说过它不能被传入到脚本内部被解析(比如bat 通过&lt;code&gt;%变量名%&lt;/code&gt;形式解析),它必须通过groovy脚本解析成普通字符串然后传给相应的脚本执行程序.实际上PipeLine中也提供了一种创建环境变量的方法.这里我们就介绍一下.&lt;/p&gt;
&lt;p&gt;我们还是通过一段demo来讲解&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;node {
    withEnv(['build=Production',
             'DB_ENGINE=sqlite']) {
        stage('Build') {
           bat &quot;echo $build&quot;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上通过&lt;code&gt;WithEnv&lt;/code&gt;来定义环境变量,值放在中括号里,大家注意写法是&lt;code&gt;&quot;变量名=变量值&quot;&lt;/code&gt;,也就是变量名和赋值都放在一个引号内(单引号和双引号都可以),而不是&lt;code&gt;&quot;变量名&quot;=&quot;变量值&quot;&lt;/code&gt;这种形式,一定要注意.&lt;/p&gt;
&lt;p&gt;bat命令里的解析方法是通过&lt;code&gt;$变量名&lt;/code&gt;形式,我们讲过,它是groovy的插件方式,通过这里我们可以看到,在PipeLine里,环境变量也被当作了普通变量(即可以通过&lt;code&gt;$变量名&lt;/code&gt;形式解析).当然我们说了这里定义的是环境变量,环境变量是可以传入脚本内部被解析的,我们把bat这段代码改为如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bat &quot;echo %build%&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制台仍然能够输出world.&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;对于powershell脚本可以通过&lt;code&gt;$env:变量名&lt;/code&gt;方式获取.但是对于powershell脚本有一个坑必须注意,那就是Powershell获取环境变量名使用&lt;code&gt;$&lt;/code&gt;开头,同时groovy脚本插值变量也是以&lt;code&gt;$&lt;/code&gt;开头,这就会导致Groovy会尝试解析 powershell的变量,这样显然无法获取正确结果.如何解决这一问题呢?答案是执行powershell脚本的时候使用&lt;code&gt;powershell '要执行的脚本'&lt;/code&gt;,也即把双引号改为单引号,如果双引号改单引号,则groovy不再进行插值计算.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;最佳实践&quot;&gt;最佳实践&lt;/h2&gt;
&lt;p&gt;1) 前面说过,groovy除了可以获取通过&lt;code&gt;def&lt;/code&gt;定义的变量外,也能够获取环境变量,因此建议使用&lt;code&gt;$变量名&lt;/code&gt;的方式获取变量的值,这样groovy会提交对它们进行插值计算,这样就弥补了不同脚本使用环境变量方法不一样的问题.同也不必考虑powrshell 引用变量会被插值计算,必须使用单引号包括脚本的问题,减少脑细胞消耗量.&lt;/p&gt;
&lt;p&gt;2) 通过以上我们可以看到PipeLine里即可以通过&lt;code&gt;def&lt;/code&gt;来定义变量,也可以通过&lt;code&gt;WithEnv&lt;/code&gt;来定义,实际使用中发现WithEnv更麻烦,所有使用到它的代码块都必须包含在withEnv代码块内,如果嵌套过深,代码可读性非常差.而&lt;code&gt;def&lt;/code&gt;即可以声明为全局的(这里说的全局是对整个当前脚本有效),也可以是块级的,并且不用花括号,可读性也更好.&lt;/p&gt;

&lt;h2 id=&quot;保证某一步骤最终一定执行&quot;&gt;保证某一步骤最终一定执行&lt;/h2&gt;
&lt;p&gt;我们知道PipeLine里可以书写Groovy脚本,脚本如果出错则代码将不会再继续往下走,我们如何保证不论如何最终都会执行某一步动作呢,比如说释放非托管资源,脚本出错时发出邮件通知等,这里其实处理办法非常简单,那就是使用groovy的try finally语法,把最终要执行的代码写在finally里,这对程序员来说应该非常容易理解.&lt;/p&gt;
&lt;h2 id=&quot;script代码块&quot;&gt;Script代码块&lt;/h2&gt;
&lt;p&gt;我们前面已经说过,可以在jenkins PipeLine里直接执行groovy脚本,如果仅仅是定义一个变量这样简单的动作无所谓,如果有大量的代码和业务逻辑掺杂在一块,则势必影响代码可读性.此时可以使用script代码块把要执行的大段groovy脚本包在里面&lt;/p&gt;
&lt;p&gt;如下图示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;node {
     def hello=&quot;world&quot;
    
    stage(&quot;echo&quot;){
        
           script{
                for(i=0;i&amp;lt;=3;i++){
                println(i)
            }
           }
       
        bat &quot;echo $version&quot;
    }
   
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上我们把循环语句放在代码块里,println可以把内容打印到Jenkins控制台.&lt;/p&gt;
&lt;h2 id=&quot;逻辑分支&quot;&gt;逻辑分支&lt;/h2&gt;
&lt;p&gt;这里仅仅是列出来希望引起大家的注意,在脚本式PipeLine里逻辑分支非常简单,只需要使用&lt;code&gt;if&lt;/code&gt;分支语句即可,熟悉groovy脚本的童鞋可以尽情发挥所掌握知识&lt;/p&gt;
&lt;h2 id=&quot;并行任务&quot;&gt;并行任务&lt;/h2&gt;
&lt;p&gt;在PipeLine里可以执行并行任务,充分利用并行任务在特定场景下将极大节约构建时间,提升构建效率.比如说我们的项目是一个模块非常多的项目,每个模块存在不同的仓库里,则我们在拉取项目进行编译的时候可以并行拉取这个库,把这些并行任务放在一个步骤里,完成后再执行下一步编译工作.&lt;/p&gt;
&lt;p&gt;请看下面示例代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;node{
    stage(&quot;poll source&quot;){
        parallel(
      a: {
        echo &quot;This is branch a&quot;
         },
      b: {
        echo &quot;This is branch b&quot;
         }
            )
    }
   stage(&quot;build&quot;){
       echo &quot;build successfully&quot;
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码在&lt;code&gt;poll source&lt;/code&gt;步骤里,我们通过parallel并行执行了&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;b&lt;/code&gt;两个任务.这样将极大节约代码拉取时间.&lt;/p&gt;
&lt;p&gt;我们保存项目后点击构建,构建完成后打开&lt;code&gt;BlueOcean&lt;/code&gt;视图,点击进入本次构建,就会看到如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201908/811801-20190830081024063-1591888287.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以从图形界面形象地看到&lt;code&gt;poll source&lt;/code&gt;步骤分为&lt;code&gt;a和b&lt;/code&gt;两个并行的任务.然后它们汇集到下一步.&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;使用并行任务时一定要梳理好构建的逻辑,否则将会出现意想不到的结果.如果以上&lt;code&gt;a b 和build&lt;/code&gt;并行执行,则将会导致构建失败,因为构建依赖于以上两个步骤都执行完成.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 30 Aug 2019 00:13:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' 有的童鞋可能已经发现,PipeLine项目与自由式项目相比,可配置的项少了很多,比如说环境变量定义,所有步骤完成后执行动作,拉git代码库等.其实这些功能并没有缺,而是配置的方式不一样了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11432953.html</dc:identifier>
</item>
<item>
<title>Java虚拟机详解（八）------虚拟机监控和分析工具（2）——可视化 - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/11415514.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/11415514.html</guid>
<description>&lt;p&gt;　　上篇博客我们介绍了&lt;a href=&quot;https://www.cnblogs.com/ysocean/p/11311667.html&quot; target=&quot;_blank&quot;&gt;虚拟机监控和分析命令行工具&lt;/a&gt;，由于其不够直观，不是很容易排查问题，那么本篇博客我们就来介绍几个可视化工具。&lt;/p&gt;
&lt;h3&gt;1、JConsole&lt;/h3&gt;
&lt;p&gt;　　JConsole（Java Monitoring and Management Console）是一款基于 JMX 的可视化监视和管理的工具。它管理部分的功能是针对 JMX MBean 进行管理，MBean 可以使用代码、中间件服务器的管理控制台或者所有符合 JMX 规范的软件进行访问。&lt;/p&gt;
&lt;p&gt;　　JMX(Java Management Extensions)是一个为应用程序植入管理功能的框架，一套标准的代理和服务；MBean就是一种规范的JavaBean，通过集成和实现一套标准的Bean接口。&lt;/p&gt;
&lt;h4&gt;①、启动 JConsole&lt;/h4&gt;
&lt;p&gt;　　这是我们JDK自带的监控工具，在JDK的安装目录bin下即可找到。&lt;/p&gt;
&lt;p&gt;　　如果配置过JDK环境变量，在CMD命令提示符中输入 jconsole 也可直接打开。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190827213057667-434262524.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这是一个可执行文件，直接双击即可打开。打开如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190827213155961-1658759711.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;②、监控界面介绍&lt;/h4&gt;
&lt;p&gt;　　JConsole 这个监控工具可以监控本地进程以及远程进程，我们这里以监控本地进程为例，来介绍具体的监控界面。&lt;/p&gt;
&lt;p&gt;　　点击本地进程下面的任意一栏，进入到监控界面。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1、监控概览&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190827214421083-733683653.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这个界面是我们建立本地连接后，进入的第一个页面。显示的是整个虚拟机主要运行数据的概览，包括“堆使用情况”、“线程”、“类”、“CPU占用率”等四项信息的曲线图，这些曲线图是后面“内存”、“线程”、“类”页签的信息汇总，下面会分别介绍这几个页签。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2、内存监控&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这个页签相当于上一篇博客介绍的jstat命令，不过这里是可视化的。用于监视虚拟机内存的一些变化趋势。&lt;/p&gt;
&lt;p&gt;　　监视区域如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190827221045164-337453861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3、线程监控&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这个页签相当于上篇博客介绍的可视化的jstat 命令。遇到线程停顿的时候可以使用这个页签进行监控分析。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190827222658985-781896705.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　另外，此页面左下角还有一个检测死锁的按钮，出现线程死锁后，点击此按钮，便会出现一个新的死锁页签。&lt;/p&gt;
&lt;p&gt;　　比如，对于如下这段死锁代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     @GetMapping(&quot;/test2&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test2() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         Object lock1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         Object lock2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt; Thread(()-&amp;gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (lock1){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                    e.printStackTrace();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (lock2){
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     System.out.println(&quot;线程1结束运行&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }).start();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt; Thread(()-&amp;gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (lock2){
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                     Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                    e.printStackTrace();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (lock1){
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                     System.out.println(&quot;线程2结束运行&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }).start();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里创建了两把锁，lock1,lock2，创建了两个线程，线程1获取到lock1后，说你给我lock2，我就释放lock1；而线程2获取到lock2后，说你给我lock1，我就释放lock2。两个线程谁也不释放，于是便造成了死锁现象。&lt;/p&gt;
&lt;p&gt;　　通过监控工具便可以检测到，如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190827223516790-1922036927.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;4、类监控&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190827224013490-1651850789.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;5、VM概要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　展示一些JVM信息。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190827224130133-918692655.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;③、配置Tomcat远程监控&lt;/h4&gt;
&lt;p&gt; 　　其实使用监控工具，我们很少对本地的程序进行监控，大多数情况都是对部署在远程Linux服务器上的程序进行监控，那么想要使用 JConsole这款工具进行远程监控，我们必须要进行一些配置。我们首先介绍对Tomcat的远程监控。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1、配置catalina.sh&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在该文件下加入如下配置信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
JAVA_OPTS=&quot;$JAVA_OPTS -Djava.rmi.server.hostname=192.168.146.200 -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　-Dcom.sun.management.jmxremote 表示开启远程连接。&lt;/p&gt;
&lt;p&gt;　　-Dcom.sun.management.jmxremote.port=9004 表示设置远程连接端口为1099&lt;/p&gt;
&lt;p&gt;　　-Dcom.sun.management.jmxremote.authenticate=false 表示不需要密码验证&lt;/p&gt;
&lt;p&gt;　　-Dcom.sun.management.jmxremote.ssl=fals 表示不需要开启ssl连接&lt;/p&gt;
&lt;p&gt;　　-Djava.net.preferIPv4Stack=true 表示只支持IPV4地址&lt;/p&gt;
&lt;p&gt;　　-Djava.rmi.server.hostname=192.168.146.200 表示监控的主机名为192.168.146.200&lt;/p&gt;
&lt;p&gt;　　添加位置如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190829074001162-1132842741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;2、建立连接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　通过上面的配置，启动Tomcat后，我们只需要在 JConsole 的远程连接界面，输入 192.168.146.200:9004 ，然后点击连接即可。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190828213823223-1260877022.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3、连接错误情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　如果无法连接，需要依次检测如下信息：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;①、配置的端口不能被占用，可以通过 netstat -tunlp|grep 1099 命令验证。&lt;/p&gt;
&lt;p&gt;　　②、防火墙开启对上面设置端口的信任&lt;/p&gt;
&lt;p&gt;　　③、通过 hostname -i 命令，如果打印的不是前面设置的ip地址，则需要通过 vim /etc/hosts 命令，将127.0.0.1 修改为本机IP地址。&lt;/p&gt;
&lt;h4&gt;④、配置远程jar包监控&lt;/h4&gt;
&lt;p&gt;　　启动jar包的命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
nohup java -Djava.rmi.server.hostname=192.168.146.200 -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1089 -Dcom.sun.management.jmxremote.authenticate=&lt;span&gt;false&lt;/span&gt; -Dcom.sun.management.jmxremote.ssl=&lt;span&gt;false&lt;/span&gt; -jar jvm-0.0.1-SNAPSHOT.jar &amp;amp;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　配置端口，ip地址，和远程监控Tomcat大体上是一样的，然后建立连接即可。&lt;/p&gt;
&lt;h3&gt; 2、JVisualVM&lt;/h3&gt;
&lt;p&gt;　　英文介绍为 All-in-One Java Troubleshooting Tool。听名字我们就知道这是一块功能很全，很强大的Java运行监视和故障处理工具，并且是官方主力发展的虚拟机故障处理工具，其性能分析比很多专业收费软件都不会逊色多少。&lt;/p&gt;
&lt;h4&gt;①、启动 JVisualVM&lt;/h4&gt;
&lt;p&gt;　　和前面介绍的JConsole工具一样，这也是 JDK 自带的一个工具，在安装目录bin下，可以直接双击启动。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190828225248185-19744372.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　打开界面如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190828225342040-1087511074.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;②、监控界面介绍&lt;/h4&gt;
&lt;p&gt;　　其实大体界面和JConsole差不多。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190828231322744-1919723573.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　抽样器可以对CPU，内存进行详细监控统计。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190828231505272-1409652465.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;③、插件机制&lt;/h4&gt;
&lt;p&gt;　　JVisualVM 比较强大的地方在与可以安装各种插件，提供各种不同的功能。&lt;/p&gt;
&lt;p&gt;　　点击上方菜单栏 工具---》插件：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190828231700619-1466911609.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后设置插件中心的地址：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190828231955376-31554328.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这个地址，我们可以到这个网址上去获取：&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://visualvm.github.io/pluginscenters.html&quot; target=&quot;_blank&quot;&gt;https://visualvm.github.io/pluginscenters.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　选择对应的插件地址时，要根据我们的JDK版本来选定。&lt;/p&gt;
&lt;p&gt;　　比如，我这边的JDK版本如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190828232144288-1383607983.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　那么选择的地址如下（152，介于131-221之间）：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190828232210598-144859154.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　设置好下载地址后，我们这边选择需要的插件，点击安装即可！比如比较常用的插件 Visual GC(用来查看GC日志)&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190828232336096-1858435117.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　安装完成之后，我们便可以在页签上看到这个新增的插件。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190829073409982-422961402.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;④、配置远程连接&lt;/h4&gt;
&lt;p&gt;　　不管是远程连接Tomcat还是jar包，都和介绍JConsole一模一样，详情请参考上面的配置。&lt;/p&gt;
&lt;h4&gt;⑤、使用文档&lt;/h4&gt;
&lt;p&gt;　　对于JVisualvm，官方有详细的中文文档说明，如下：&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://visualvm.github.io/documentation.html&quot;&gt;https://visualvm.github.io/documentation.html&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 29 Aug 2019 23:57:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<og:description>Java虚拟机详解（八）------虚拟机监控和分析工具（可视化）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ysocean/p/11415514.html</dc:identifier>
</item>
<item>
<title>周期性线程池与主要源码解析 - 小强的进阶之路</title>
<link>http://www.cnblogs.com/xiaoqiang-code/p/11432936.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoqiang-code/p/11432936.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;之前学习ThreadPool的使用以及源码剖析，并且从面试的角度去介绍知识点的解答。今天小强带来周期性线程池的使用和重点源码剖析。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;scheduledthreadpoolexecutor&quot;&gt;ScheduledThreadPoolExecutor&lt;/h2&gt;
&lt;p&gt;ScheduledThreadPoolExecutor：用来处理延时任务或定时任务&lt;br/&gt;定时线程池类的类结构图&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771943/201908/1771943-20190830075506206-369546059.jpg&quot; alt=&quot;定时线程池类的类结构图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ScheduledThreadPoolExecutor接收ScheduleFutureTask类型的任务，是线程池调度任务的最小单位。&lt;br/&gt;它采用DelayQueue存储等待的任务：&lt;br/&gt;1、DelayQueue内部封装成一个PriorityQueue，它会根据time的先后时间顺序，如果time相同则根绝sequenceNumber排序；&lt;br/&gt;2、DelayQueue是无界队列；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771943/201908/1771943-20190830075506407-688261148.jpg&quot; alt=&quot;周期性线程池任务执行简图&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;schedulefuturetask&quot;&gt;ScheduleFutureTask&lt;/h2&gt;
&lt;p&gt;接收的参数:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private final long sequenceNumber;//任务的序号
private long time;//任务开始的时间
private final long period;//任务执行的时间间隔&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;工作线程的的执行过程：&lt;br/&gt;工作线程会从DelayQueue取出已经到期的任务去执行；&lt;br/&gt;执行结束后重新设置任务的到期时间，再次放回DelayQueue；&lt;/p&gt;
&lt;p&gt;ScheduledThreadPoolExecutor会把待执行的任务放到工作队列DelayQueue中，DelayQueue封装了一个PriorityQueue，PriorityQueue会对队列中的ScheduledFutureTask进行排序，具体的排序算法实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public int compareTo(Delayed other) {
    if (other == this) // compare zero if same object
        return 0;
    if (other instanceof ScheduledFutureTask) {
        ScheduledFutureTask&amp;lt;?&amp;gt; x = (ScheduledFutureTask&amp;lt;?&amp;gt;)other;
        //首先按照time排序，time小的排到前面，time大的排到后面
        long diff = time - x.time;
        if (diff &amp;lt; 0)
            return -1;
        else if (diff &amp;gt; 0)
            return 1;
        //time相同，按照sequenceNumber排序;
        //sequenceNumber小的排在前面,sequenceNumber大的排在后面 
        else if (sequenceNumber &amp;lt; x.sequenceNumber)
            return -1;
        else
            return 1;
    }
    long diff = getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);
    return (diff &amp;lt; 0) ? -1 : (diff &amp;gt; 0) ? 1 : 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来看看ScheduledFutureTask的run方法实现， run方法是调度task的核心，task的执行实际上是run方法的执行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void run() {
    //是否是周期性的
    boolean periodic = isPeriodic();
    //线程池是shundown状态不支持处理新任务，直接取消任务
    if (!canRunInCurrentRunState(periodic))
        cancel(false);
    //如果不需要执行执行周期性任务，直接执行run方法结束
    else if (!periodic)
        ScheduledFutureTask.super.run();
    //如果需要周期性执行，则在执行任务完成后，设置下一次执行时间
    else if (ScheduledFutureTask.super.runAndReset()) {
        //设置下一次执行该任务的时间
        setNextRunTime();
        //重复执行该任务
        reExecutePeriodic(outerTask);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;run方法的执行步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、如果线程池是shundown状态不支持处理新任务，直接取消任务，否则步骤2；&lt;/li&gt;
&lt;li&gt;2、如果不是周期性任务，直接调用ScheduledFutureTask的run方法执行，会设置执行结果，然后直接返回，否则步骤3；&lt;/li&gt;
&lt;li&gt;3、如果是周期性任务，调用ScheduledFutureTask的runAndset方法执行，不会设置执行结果，然后直接返回，否则执行步骤4和步骤5；&lt;/li&gt;
&lt;li&gt;4、计算下一次执行该任务的时间；&lt;/li&gt;
&lt;li&gt;5、重复执行该任务；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来看下reExecutePeriodic方法的执行步骤：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void reExecutePeriodic(RunnableScheduledFuture&amp;lt;?&amp;gt; task) {
    if (canRunInCurrentRunState(true)) {
        super.getQueue().add(task);
        if (!canRunInCurrentRunState(true) &amp;amp;&amp;amp; remove(task))
            task.cancel(false);
        else
            ensurePrestart();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于已经执行过一次周期性任务，所以不会reject当前任务，同时传入的任务一定是周期性任务。&lt;/p&gt;
&lt;h2 id=&quot;周期性线程池任务的提交方式&quot;&gt;周期性线程池任务的提交方式&lt;/h2&gt;
&lt;p&gt;周期性有三种提交的方式：schedule、sceduleAtFixedRate、schedlueWithFixedDelay。下面从使用和源码两个方面进行说明，首先是如果提交任务：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pool.schedule(new Runnable() {
    @Override
    public void run() {
        System.out.println(&quot;延迟执行&quot;);
    }
},1, TimeUnit.SECONDS);

/**
 * 这个执行周期是固定，不管任务执行多长时间，每过3秒中就会产生一个新的任务
 */
pool.scheduleAtFixedRate(new Runnable() {
    @Override
    public void run() {
        //这个业务逻辑需要很长的时间，超过了3秒
        System.out.println(&quot;重复执行&quot;);
    }
},1,3,TimeUnit.SECONDS);

pool.shutdown();

/**
 * 假如run方法30min后执行完成，然后间隔3秒，再周期性执行下一个任务
 */
pool.scheduleWithFixedDelay(new Runnable() {
    @Override
    public void run() {
        //30min
        System.out.println(&quot;重复执行&quot;);
    }
},1,3,TimeUnit.SECONDS);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;知道了如何提交周期性任务，接下来源码是如何执行的，首先是schedule方法，该方法是指任务在指定延迟时间到达后触发，只会执行一次。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public ScheduledFuture&amp;lt;?&amp;gt; schedule(Runnable command,
                                   long delay,
                                   TimeUnit unit) {
    if (command == null || unit == null)
        throw new NullPointerException();
    //把任务封装成ScheduledFutureTask，之后调用decorateTask进行包装；
    //decorateTask方法是空方法，留给用户去实现的；
    RunnableScheduledFuture&amp;lt;?&amp;gt; t = decorateTask(command,
        new ScheduledFutureTask&amp;lt;Void&amp;gt;(command, null,
                                      triggerTime(delay, unit)));
    //包装好任务之后，进行任务的提交                                  
    delayedExecute(t);
    return t;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;任务提交方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void delayedExecute(RunnableScheduledFuture&amp;lt;?&amp;gt; task) {
    //如果线程池不是RUNNING状态，则使用拒绝策略把提交任务拒绝掉
    if (isShutdown())
        reject(task);
    else {
        //与ThreadPoolExecutor不同，这里直接把任务加入延迟队列
        super.getQueue().add(task);
        //如果当前状态无法执行任务，则取消
        if (isShutdown() &amp;amp;&amp;amp;
            !canRunInCurrentRunState(task.isPeriodic()) &amp;amp;&amp;amp;
            remove(task))
            task.cancel(false);
        else
        //和ThreadPoolExecutor不一样，corePoolSize没有达到会增加Worker;
        //增加Worker，确保提交的任务能够被执行
            ensurePrestart();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;还没关注我的公众号？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;扫文末二维码关注公众号【小强的进阶之路】可领取如下:&lt;/li&gt;
&lt;li&gt;学习资料： 1T视频教程：涵盖Javaweb前后端教学视频、机器学习/人工智能教学视频、Linux系统教程视频、雅思考试视频教程；&lt;/li&gt;
&lt;li&gt;100多本书：包含C/C++、Java、Python三门编程语言的经典必看图书、LeetCode题解大全；&lt;/li&gt;
&lt;li&gt;软件工具：几乎包括你在编程道路上的可能会用到的大部分软件；&lt;/li&gt;
&lt;li&gt;项目源码：20个JavaWeb项目源码。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771943/201908/1771943-20190830075507397-544358460.png&quot; alt=&quot;小强的进阶之路二维码&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 29 Aug 2019 23:55:00 +0000</pubDate>
<dc:creator>小强的进阶之路</dc:creator>
<og:description>之前学习ThreadPool的使用以及源码剖析，并且从面试的角度去介绍知识点的解答。今天小强带来周期性线程池的使用和重点源码剖析。 ScheduledThreadPoolExecutor Schedu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaoqiang-code/p/11432936.html</dc:identifier>
</item>
<item>
<title>Scala 系列（十）—— 函数 &amp; 闭包 &amp; 柯里化 - 黑白影</title>
<link>http://www.cnblogs.com/heibaiying/p/11432927.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/heibaiying/p/11432927.html</guid>
<description>&lt;h2 id=&quot;一函数&quot;&gt;一、函数&lt;/h2&gt;
&lt;h3 id=&quot;函数与方法&quot;&gt;1.1 函数与方法&lt;/h3&gt;
&lt;p&gt;Scala 中函数与方法的区别非常小，如果函数作为某个对象的成员，这样的函数被称为方法，否则就是一个正常的函数。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 定义方法
def multi1(x:Int) = {x * x}
// 定义函数
val multi2 = (x: Int) =&amp;gt; {x * x}

println(multi1(3)) //输出 9
println(multi2(3)) //输出 9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以使用 &lt;code&gt;def&lt;/code&gt; 定义函数：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;def multi3 = (x: Int) =&amp;gt; {x * x}
println(multi3(3))  //输出 9 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;multi2&lt;/code&gt; 和 &lt;code&gt;multi3&lt;/code&gt; 本质上没有区别，这是因为函数是一等公民，&lt;code&gt;val multi2 = (x: Int) =&amp;gt; {x * x}&lt;/code&gt; 这个语句相当于是使用 &lt;code&gt;def&lt;/code&gt; 预先定义了函数，之后赋值给变量 &lt;code&gt;multi2&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;函数类型&quot;&gt;1.2 函数类型&lt;/h3&gt;
&lt;p&gt;上面我们说过 &lt;code&gt;multi2&lt;/code&gt; 和 &lt;code&gt;multi3&lt;/code&gt; 本质上是一样的，那么作为函数它们是什么类型的？两者的类型实际上都是 &lt;code&gt;Int =&amp;gt; Int&lt;/code&gt;，前面一个 Int 代表输入参数类型，后面一个 Int 代表返回值类型。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;scala&amp;gt; val multi2 = (x: Int) =&amp;gt; {x * x}
multi2: Int =&amp;gt; Int = $$Lambda$1092/594363215@1dd1a777

scala&amp;gt; def multi3 = (x: Int) =&amp;gt; {x * x}
multi3: Int =&amp;gt; Int

// 如果有多个参数，则类型为：（参数类型，参数类型 ...）=&amp;gt;返回值类型
scala&amp;gt; val multi4 = (x: Int,name: String) =&amp;gt; {name + x * x }
multi4: (Int, String) =&amp;gt; String = $$Lambda$1093/1039732747@2eb4fe7&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;一等公民匿名函数&quot;&gt;1.3 一等公民&amp;amp;匿名函数&lt;/h3&gt;
&lt;p&gt;在 Scala 中函数是一等公民，这意味着不仅可以定义函数并调用它们，还可以将它们作为值进行传递：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import scala.math.ceil
object ScalaApp extends App {
  // 将函数 ceil 赋值给变量 fun,使用下划线 (_) 指明是 ceil 函数但不传递参数
  val fun = ceil _
  println(fun(2.3456))  //输出 3.0

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 Scala 中你不必给每一个函数都命名，如 &lt;code&gt;(x: Int) =&amp;gt; 3 * x&lt;/code&gt; 就是一个匿名函数：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;object ScalaApp extends App {
  // 1.匿名函数
  (x: Int) =&amp;gt; 3 * x
  // 2.具名函数
  val fun = (x: Int) =&amp;gt; 3 * x
  // 3.直接使用匿名函数
  val array01 = Array(1, 2, 3).map((x: Int) =&amp;gt; 3 * x)  
  // 4.使用占位符简写匿名函数
  val array02 = Array(1, 2, 3).map(_ * 3)
  // 5.使用具名函数
  val array03 = Array(1, 2, 3).map(fun)
  
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;特殊的函数表达式&quot;&gt;1.4 特殊的函数表达式&lt;/h3&gt;
&lt;h4 id=&quot;可变长度参数列表&quot;&gt;1. 可变长度参数列表&lt;/h4&gt;
&lt;p&gt;在 Java 中如果你想要传递可变长度的参数，需要使用 &lt;code&gt;String ...args&lt;/code&gt; 这种形式，Scala 中等效的表达为 &lt;code&gt;args: String*&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;object ScalaApp extends App {
  def echo(args: String*): Unit = {
    for (arg &amp;lt;- args) println(arg)
  }
  echo(&quot;spark&quot;,&quot;hadoop&quot;,&quot;flink&quot;)
}
// 输出
spark
hadoop
flink&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;传递具名参数&quot;&gt;2. 传递具名参数&lt;/h4&gt;
&lt;p&gt;向函数传递参数时候可以指定具体的参数名。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;object ScalaApp extends App {
  
  def detail(name: String, age: Int): Unit = println(name + &quot;:&quot; + age)
  
  // 1.按照参数定义的顺序传入
  detail(&quot;heibaiying&quot;, 12)
  // 2.传递参数的时候指定具体的名称,则不必遵循定义的顺序
  detail(age = 12, name = &quot;heibaiying&quot;)

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;默认值参数&quot;&gt;3. 默认值参数&lt;/h4&gt;
&lt;p&gt;在定义函数时，可以为参数指定默认值。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;object ScalaApp extends App {

  def detail(name: String, age: Int = 88): Unit = println(name + &quot;:&quot; + age)

  // 如果没有传递 age 值,则使用默认值
  detail(&quot;heibaiying&quot;)
  detail(&quot;heibaiying&quot;, 12)

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二闭包&quot;&gt;二、闭包&lt;/h2&gt;
&lt;h3 id=&quot;闭包的定义&quot;&gt;2.1 闭包的定义&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;var more = 10
// addMore 一个闭包函数:因为其捕获了自由变量 more 从而闭合了该函数字面量
val addMore = (x: Int) =&amp;gt; x + more&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上函数 &lt;code&gt;addMore&lt;/code&gt; 中有两个变量 x 和 more:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;x&lt;/strong&gt; : 是一个绑定变量 (bound variable)，因为其是该函数的入参，在函数的上下文中有明确的定义；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;more&lt;/strong&gt; : 是一个自由变量 (free variable)，因为函数字面量本生并没有给 more 赋予任何含义。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;按照定义：在创建函数时，如果需要捕获自由变量，那么包含指向被捕获变量的引用的函数就被称为闭包函数。&lt;/p&gt;
&lt;h3 id=&quot;修改自由变量&quot;&gt;2.2 修改自由变量&lt;/h3&gt;
&lt;p&gt;这里需要注意的是，闭包捕获的是变量本身，即是对变量本身的引用，这意味着：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;闭包外部对自由变量的修改，在闭包内部是可见的；&lt;/li&gt;
&lt;li&gt;闭包内部对自由变量的修改，在闭包外部也是可见的。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 声明 more 变量
scala&amp;gt; var more = 10
more: Int = 10

// more 变量必须已经被声明，否则下面的语句会报错
scala&amp;gt; val addMore = (x: Int) =&amp;gt; {x + more}
addMore: Int =&amp;gt; Int = $$Lambda$1076/1844473121@876c4f0

scala&amp;gt; addMore(10)
res7: Int = 20

// 注意这里是给 more 变量赋值，而不是重新声明 more 变量
scala&amp;gt; more=1000
more: Int = 1000

scala&amp;gt; addMore(10)
res8: Int = 1010&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;自由变量多副本&quot;&gt;2.3 自由变量多副本&lt;/h3&gt;
&lt;p&gt;自由变量可能随着程序的改变而改变，从而产生多个副本，但是闭包永远指向创建时候有效的那个变量副本。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 第一次声明 more 变量
scala&amp;gt; var more = 10
more: Int = 10

// 创建闭包函数
scala&amp;gt; val addMore10 = (x: Int) =&amp;gt; {x + more}
addMore10: Int =&amp;gt; Int = $$Lambda$1077/1144251618@1bdaa13c

// 调用闭包函数
scala&amp;gt; addMore10(9)
res9: Int = 19

// 重新声明 more 变量
scala&amp;gt; var more = 100
more: Int = 100

// 创建新的闭包函数
scala&amp;gt; val addMore100 = (x: Int) =&amp;gt; {x + more}
addMore100: Int =&amp;gt; Int = $$Lambda$1078/626955849@4d0be2ac

// 引用的是重新声明 more 变量
scala&amp;gt; addMore100(9)
res10: Int = 109

// 引用的还是第一次声明的 more 变量
scala&amp;gt; addMore10(9)
res11: Int = 19

// 对于全局而言 more 还是 100
scala&amp;gt; more
res12: Int = 100&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的示例可以看出重新声明 &lt;code&gt;more&lt;/code&gt; 后，全局的 &lt;code&gt;more&lt;/code&gt; 的值是 100，但是对于闭包函数 &lt;code&gt;addMore10&lt;/code&gt; 还是引用的是值为 10 的 &lt;code&gt;more&lt;/code&gt;，这是由虚拟机来实现的，虚拟机会保证 &lt;code&gt;more&lt;/code&gt; 变量在重新声明后，原来的被捕获的变量副本继续在堆上保持存活。&lt;/p&gt;
&lt;h2 id=&quot;三高阶函数&quot;&gt;三、高阶函数&lt;/h2&gt;
&lt;h3 id=&quot;使用函数作为参数&quot;&gt;3.1 使用函数作为参数&lt;/h3&gt;
&lt;p&gt;定义函数时候支持传入函数作为参数，此时新定义的函数被称为高阶函数。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;object ScalaApp extends App {

  // 1.定义函数
  def square = (x: Int) =&amp;gt; {
    x * x
  }

  // 2.定义高阶函数: 第一个参数是类型为 Int =&amp;gt; Int 的函数
  def multi(fun: Int =&amp;gt; Int, x: Int) = {
    fun(x) * 100
  }

  // 3.传入具名函数
  println(multi(square, 5)) // 输出 2500
    
  // 4.传入匿名函数
  println(multi(_ * 100, 5)) // 输出 50000

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;函数柯里化&quot;&gt;3.2 函数柯里化&lt;/h3&gt;
&lt;p&gt;我们上面定义的函数都只支持一个参数列表，而柯里化函数则支持多个参数列表。柯里化指的是将原来接受两个参数的函数变成接受一个参数的函数的过程。新的函数以原有第二个参数作为参数。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;object ScalaApp extends App {
  // 定义柯里化函数
  def curriedSum(x: Int)(y: Int) = x + y
  println(curriedSum(2)(3)) //输出 5
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里当你调用 curriedSum 时候，实际上是连着做了两次传统的函数调用，实际执行的柯里化过程如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一次调用接收一个名为 &lt;code&gt;x&lt;/code&gt; 的 Int 型参数，返回一个用于第二次调用的函数，假设 &lt;code&gt;x&lt;/code&gt; 为 2，则返回函数 &lt;code&gt;2+y&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;返回的函数接收参数 &lt;code&gt;y&lt;/code&gt;，并计算并返回值 &lt;code&gt;2+3&lt;/code&gt; 的值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;想要获得柯里化的中间返回的函数其实也比较简单：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;object ScalaApp extends App {
  // 定义柯里化函数
  def curriedSum(x: Int)(y: Int) = x + y
  println(curriedSum(2)(3)) //输出 5

  // 获取传入值为 10 返回的中间函数 10 + y
  val plus: Int =&amp;gt; Int = curriedSum(10)_
  println(plus(3)) //输出值 13
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;柯里化支持多个参数列表，多个参数按照从左到右的顺序依次执行柯里化操作：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;object ScalaApp extends App {
  // 定义柯里化函数
  def curriedSum(x: Int)(y: Int)(z: String) = x + y + z
  println(curriedSum(2)(3)(&quot;name&quot;)) // 输出 5name
  
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Martin Odersky . Scala 编程 (第 3 版)[M] . 电子工业出版社 . 2018-1-1&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;凯.S.霍斯特曼 . 快学 Scala(第 2 版)[M] . 电子工业出版社 . 2017-7&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;3.75&quot;&gt;
&lt;p&gt;&lt;strong&gt;更多大数据系列文章可以参见 GitHub 开源项目&lt;/strong&gt;： &lt;a href=&quot;https://github.com/heibaiying/BigData-Notes&quot;&gt;&lt;strong&gt;大数据入门指南&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 29 Aug 2019 23:30:00 +0000</pubDate>
<dc:creator>黑白影</dc:creator>
<og:description>一、函数 1.1 函数与方法 Scala 中函数与方法的区别非常小，如果函数作为某个对象的成员，这样的函数被称为方法，否则就是一个正常的函数。 也可以使用 定义函数： 和 本质上没有区别，这是因为函数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/heibaiying/p/11432927.html</dc:identifier>
</item>
<item>
<title>支持向量机 (三)： 优化方法与支持向量回归 - massquantity</title>
<link>http://www.cnblogs.com/massquantity/p/11419971.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/massquantity/p/11419971.html</guid>
<description>&lt;h3 id=&quot;拉格朗日乘子法---kkt条件---对偶问题&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/massquantity/p/10807311.html&quot;&gt;&lt;span&gt;拉格朗日乘子法 - KKT条件 - 对偶问题&lt;/span&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;支持向量机-一-线性可分类-svm&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/massquantity/p/10920043.html&quot;&gt;&lt;span&gt;支持向量机 (一)： 线性可分类 svm&lt;/span&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;支持向量机-二-软间隔-svm-与-核函数&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/massquantity/p/11110397.html&quot;&gt;&lt;span&gt;支持向量机 (二)： 软间隔 svm 与 核函数&lt;/span&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;支持向量机-三-优化方法与支持向量回归&quot;&gt;支持向量机 (三)： 优化方法与支持向量回归&lt;/h3&gt;

&lt;center&gt;

&lt;/center&gt;
&lt;hr/&gt;&lt;h2 id=&quot;一smo算法&quot;&gt;一、SMO算法&lt;/h2&gt;
&lt;p&gt;回顾 &lt;a href=&quot;https://www.cnblogs.com/massquantity/p/11110397.html&quot;&gt;&lt;span&gt;支持向量机 (二)&lt;/span&gt;&lt;/a&gt; 中 &lt;span class=&quot;math inline&quot;&gt;\((1.7)\)&lt;/span&gt; 式最后要求解的优化问题：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align} \max_\alpha &amp;amp;\;\; \sum\limits_{i=1}^m \alpha_i - \frac12 \sum\limits_{i=1}^m\sum\limits_{i=1}^m \alpha_i\alpha_jy_iy_j\boldsymbol{x}_i^{\top}\boldsymbol{x}_j \tag{1.1}\\[1ex] \text{s.t.} &amp;amp; \;\; \sum\limits_{i=1}^m \alpha_iy_i = 0 \tag{1.2} \\[1ex] &amp;amp; \;\; 0 \leqslant \alpha_i \leqslant C, \quad i = 1,2,\ldots m \tag{1.3} \end{align} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在求出满足条件的最优 &lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol{\alpha}\)&lt;/span&gt; 后，即可得 svm 模型的参数 &lt;span class=&quot;math inline&quot;&gt;\((\boldsymbol{w}, b)\)&lt;/span&gt; ，进而获得分离超平面。可以用通用的二次规划算法求解，该二次规划问题有 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 个变量 ( &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 为样本数)， &lt;span class=&quot;math inline&quot;&gt;\((m+1)\)&lt;/span&gt; 项约束，所以当样本容量 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 很大时，问题变得不可解，而本节介绍的 SMO（sequential minimal optimization）算法就是高效求解上述问题的算法之一。&lt;/p&gt;
&lt;p&gt;SMO 算法将原来非常大的二次规划问题分解成了一系列非常小的可解的二次规划问题。SMO 算法最诱人的地方在于，这些分解后小的二次规划问题 ，都是拥有解析解的，也就是说，求解这些小的二次规划优化问题不需要通过非常耗时的循环来得到问题的结果。由于不需要矩阵计算，使得 SMO 算法 在实际的数据集的测试中，其计算复杂度介于线性复杂度和二次复杂度之间。SMO 算法的计算复杂度和 svm 的模型也有关系，比如线性核 svm 计算速度较快。在实际测试中发现，如果训练样本是稀疏数据集，那么SMO 算法的效率会极其高。&lt;/p&gt;

&lt;p&gt;SMO算法的基本思路是：选择两个变量 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_1\)&lt;/span&gt;和 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_2\)&lt;/span&gt; ，固定其他所有 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_i(i =3\ldots m)\)&lt;/span&gt;，仅针对这两个变量构建二次规划问题，这样就比原来复杂的优化问题简化很多。由于有约束条件 &lt;span class=&quot;math inline&quot;&gt;\(\sum\limits_{i=1}^m \alpha_iy_i = 0\)&lt;/span&gt; ，固定了其他 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_i(i =3\ldots m)\)&lt;/span&gt; 后，可得 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_1 y_1 + \alpha_2 y_2 = - \sum\limits_{i=3}^m \alpha_iy_i\)&lt;/span&gt; 。所以 &lt;span class=&quot;math inline&quot;&gt;\(\alpha _1\)&lt;/span&gt; 确定后，&lt;span class=&quot;math inline&quot;&gt;\(\alpha _2\)&lt;/span&gt; 即可自动获得，则该小型二次规划问题中的两个变量会同时更新，接着再不断选取新的变量进行优化。&lt;/p&gt;
&lt;p&gt;如何在每一步选择合适的 &lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt; 进行优化？ SMO 采用启发式的变量选择方法：第 1 个变量 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_1\)&lt;/span&gt; ，一般选择训练样本中违反 KKT 条件最严重的样本点所对应的 &lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt; 。而第 2 个变量 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_2\)&lt;/span&gt; 则选取与 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_1\)&lt;/span&gt; 的样本点之间间隔最大的样本点对应的 &lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt; ，这样二者的更新往往会给目标函数带来更大的变化。这里的 KKT 条件具体指的是：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{aligned} \alpha_i=0 &amp;amp; \quad\Longleftrightarrow\quad y_if(\boldsymbol{x}_i) \ge 1\\ 0&amp;lt;\alpha_i&amp;lt;C &amp;amp; \quad\Longleftrightarrow\quad y_if(\boldsymbol{x}_i) = 1\\ \alpha_i=C &amp;amp; \quad\Longleftrightarrow\quad y_if(\boldsymbol{x}_i) \le 1 \end{aligned} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\(f(\boldsymbol{x}_i) = \boldsymbol{w}^\top \boldsymbol{x}_i + b = \sum\limits_{j=1}^m \alpha_jy_j \boldsymbol{x}_i^\top \boldsymbol{x}_j + b\)&lt;/span&gt; 。还有一点就是，由于 KKT 条件过于地严格，比如 &lt;span class=&quot;math inline&quot;&gt;\(y_if(\boldsymbol{x}_i) = 1\)&lt;/span&gt; ，这个条件一般很难达到，所以在检验 KKT 条件的时候，都是在一定的误差范围 $\epsilon $ 内检验 KKT 条件的， 即 &lt;span class=&quot;math inline&quot;&gt;\(|y_if(\boldsymbol{x}_i) - 1| &amp;lt; \epsilon\)&lt;/span&gt; 。&lt;/p&gt;

&lt;p&gt;在选择了合适的变量后，下面来看如何解 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_1\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_2\)&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;若不考虑约束项 &lt;span class=&quot;math inline&quot;&gt;\((1.2)\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\((1.3)\)&lt;/span&gt; ，由于固定了其他所有 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_i(i =3\ldots m)\)&lt;/span&gt; ，因此设 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_1 y_1 + \alpha_2 y_2 = - \sum\limits_{i=3}^m \alpha_iy_i = \zeta\)&lt;/span&gt; ，利用 &lt;span class=&quot;math inline&quot;&gt;\(y_i^2 = 1\)&lt;/span&gt; 两边同乘以 &lt;span class=&quot;math inline&quot;&gt;\(y_1\)&lt;/span&gt; ，则 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_1 = (\zeta - \alpha_2 y_2) y_1\)&lt;/span&gt; ，代入 &lt;span class=&quot;math inline&quot;&gt;\((1.1)\)&lt;/span&gt; 式并求导即可得最优的 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_2\)&lt;/span&gt; ，继而利用上式求得 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_1\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;然而由于约束项 &lt;span class=&quot;math inline&quot;&gt;\((1.3)\)&lt;/span&gt; 的存在，&lt;span class=&quot;math inline&quot;&gt;\(\alpha_1\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_2\)&lt;/span&gt; 必须位于 &lt;span class=&quot;math inline&quot;&gt;\([0, C] \times [0, C]\)&lt;/span&gt; 围成的矩形区域内； 且由于约束项 &lt;span class=&quot;math inline&quot;&gt;\((1.2)\)&lt;/span&gt; 的存在， &lt;span class=&quot;math inline&quot;&gt;\(\alpha_1 y_1 + \alpha_2 y_2 = - \sum\limits_{i=3}^m \alpha_iy_i = \zeta\)&lt;/span&gt; ，又由于 &lt;span class=&quot;math inline&quot;&gt;\(y_1\)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;\(y_2\)&lt;/span&gt; 只能取 &lt;span class=&quot;math inline&quot;&gt;\(+1\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(-1\)&lt;/span&gt; ，所以在第一种情况 —— &lt;span class=&quot;math inline&quot;&gt;\(y_1\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(y_2\)&lt;/span&gt; 异号时，&lt;span class=&quot;math inline&quot;&gt;\(\alpha_1\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_2\)&lt;/span&gt; 位于直线 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_1 - \alpha_2 = \zeta\)&lt;/span&gt; 上 (这里取 &lt;span class=&quot;math inline&quot;&gt;\(y_1 = 1, \;y_2 = -1\)&lt;/span&gt; ，反过来情况类似)，如下图：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/massquantity/Pictures/master/svm_4.png&quot; width=&quot;700px&quot;/&gt;&lt;/div&gt;

&lt;p&gt;这里采用迭代优化，假设上一轮迭代得到的最优解是 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_1^{\,old}\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_2^{\,old}\)&lt;/span&gt;，本轮迭代完成后的解为 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_1^{\,new}\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_2^{\,new}\)&lt;/span&gt;。由于要满足约束条件，&lt;span class=&quot;math inline&quot;&gt;\(\alpha_2^{\,new}\)&lt;/span&gt; 存在下界 &lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt; 和上界 &lt;span class=&quot;math inline&quot;&gt;\(H\)&lt;/span&gt; ，即： &lt;span class=&quot;math inline&quot;&gt;\(L \leqslant \alpha_2^{\,new} \leqslant H\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;假设要求 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_2\)&lt;/span&gt; 的最小值，从图中可以看到只有当 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_1 = 0\)&lt;/span&gt; 时，&lt;span class=&quot;math inline&quot;&gt;\(\alpha_2\)&lt;/span&gt; 可以在矩形区域内的直线 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_1 - \alpha_2 = \zeta\)&lt;/span&gt; 上取得最小值。此时 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_2^{\,new} = -\zeta = \alpha_2^{\,old} - \alpha_1^{\,old}\)&lt;/span&gt; ( 后面一个等式是因为 &lt;span class=&quot;math inline&quot;&gt;\(\zeta\)&lt;/span&gt; 是常数 ) ，从图中也显示红线和绿线与 &lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt; 轴都相交于 &lt;span class=&quot;math inline&quot;&gt;\((0, -\zeta)\)&lt;/span&gt; ，然而由于约束 &lt;span class=&quot;math inline&quot;&gt;\(0 \leqslant \alpha_2 \leqslant C\)&lt;/span&gt; 的存在，图中绿线的下端点只能取到 &lt;span class=&quot;math inline&quot;&gt;\((\zeta, 0)\)&lt;/span&gt; ，所以综合这两种情况 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_2\)&lt;/span&gt; 的下界 &lt;span class=&quot;math inline&quot;&gt;\(L = \max(0, \, -\zeta) = \max(0, \,\alpha_2^{\,old} - \alpha_1^{\,old})\)&lt;/span&gt; 。&lt;/p&gt;

&lt;p&gt;同理要求 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_2\)&lt;/span&gt; 的最大值，只有当 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_1 = C\)&lt;/span&gt; 时，&lt;span class=&quot;math inline&quot;&gt;\(\alpha_2\)&lt;/span&gt; 可以在矩形区域内的直线 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_1 - \alpha_2 = \zeta\)&lt;/span&gt; 上取得最大值。红线和绿线与 &lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt; 轴都相交于 &lt;span class=&quot;math inline&quot;&gt;\((C, C-\zeta)\)&lt;/span&gt; ，然而由于约束 &lt;span class=&quot;math inline&quot;&gt;\(0 \leqslant \alpha_2 \leqslant C\)&lt;/span&gt; 的存在，图中红线的上端点只能取到 &lt;span class=&quot;math inline&quot;&gt;\((C + \zeta, C)\)&lt;/span&gt; ，所以综合下来 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_2\)&lt;/span&gt; 的上界 &lt;span class=&quot;math inline&quot;&gt;\(H = \min(C, \, C - \zeta) = \min(C, \, C + \alpha_2^{\,old} - \alpha_1^{\,old})\)&lt;/span&gt; 。&lt;/p&gt;

&lt;p&gt;第二种情况 —— &lt;span class=&quot;math inline&quot;&gt;\(y_1\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(y_2\)&lt;/span&gt; 同号时，&lt;span class=&quot;math inline&quot;&gt;\(\alpha_1\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_2\)&lt;/span&gt; 位于直线 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_1 + \alpha_2 = \zeta\)&lt;/span&gt; 上 (这里取 &lt;span class=&quot;math inline&quot;&gt;\(y_1 = 1, \;y_2 = 1\)&lt;/span&gt; ，反过来情况类似)，如下图：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/massquantity/Pictures/master/svm_5.png&quot; width=&quot;700px&quot;/&gt;&lt;/div&gt;
&lt;p&gt;假设要求 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_2\)&lt;/span&gt; 的最小值，从图中可以看到只有当 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_1 = C\)&lt;/span&gt; 时，&lt;span class=&quot;math inline&quot;&gt;\(\alpha_2\)&lt;/span&gt; 可以在矩形区域内的直线 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_1 + \alpha_2 = \zeta\)&lt;/span&gt; 上取得最小值。此时 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_2^{\,new} = \zeta - C = \alpha_1^{\,old} + \alpha_2^{\,old} - C\)&lt;/span&gt; ，从图中也显示红线和绿线与 &lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt; 轴都相交于 &lt;span class=&quot;math inline&quot;&gt;\((C, \zeta - C)\)&lt;/span&gt; ，然而由于约束 &lt;span class=&quot;math inline&quot;&gt;\(0 \leqslant \alpha_2 \leqslant C\)&lt;/span&gt; 的存在，图中绿线的下端点只能取到 &lt;span class=&quot;math inline&quot;&gt;\((\zeta, 0)\)&lt;/span&gt; ，所以综合这两种情况 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_2\)&lt;/span&gt; 的下界 &lt;span class=&quot;math inline&quot;&gt;\(L = \max(0, \, \zeta - C) = \max(0, \, \alpha_1^{\,old} + \alpha_2^{\,old} - C)\)&lt;/span&gt; 。&lt;/p&gt;

&lt;p&gt;同理要求 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_2\)&lt;/span&gt; 的最大值，只有当 $\alpha_1 = &lt;span class=&quot;math inline&quot;&gt;\(0 时，\)&lt;/span&gt;\alpha_2$ 可以在矩形区域内的直线 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_1 + \alpha_2 = \zeta\)&lt;/span&gt; 上取得最大值。红线和绿线与 &lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt; 轴都相交于 &lt;span class=&quot;math inline&quot;&gt;\((0, \zeta)\)&lt;/span&gt; ，然而由于约束 &lt;span class=&quot;math inline&quot;&gt;\(0 \leqslant \alpha_2 \leqslant C\)&lt;/span&gt; 的存在，图中红线的上端点只能取到 &lt;span class=&quot;math inline&quot;&gt;\((\zeta-C, \, C)\)&lt;/span&gt; ，所以综合下来 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_2\)&lt;/span&gt; 的上界 &lt;span class=&quot;math inline&quot;&gt;\(H = \min(C, \, \zeta) = \min(C, \, \alpha_1^{\,old} + \alpha_2^{\,old})\)&lt;/span&gt; 。&lt;/p&gt;

&lt;p&gt;于是在 &lt;span class=&quot;math inline&quot;&gt;\(L \leqslant \alpha_2^{\,new} \leqslant H\)&lt;/span&gt; 的约束范围内求得 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_2^{\,new}\)&lt;/span&gt; 后，继而从 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_1 y_1 + \alpha_2 y_2 = - \sum\limits_{i=3}^m \alpha_iy_i = \zeta\)&lt;/span&gt; 中求得 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_1^{\,new}\)&lt;/span&gt; ，这样 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_1\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_2\)&lt;/span&gt; 就同时得到了更新。接下来不断选择变量进行优化，当所有 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_i\)&lt;/span&gt; 都满足 KKT 条件时，算法终止，求得了最优的 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_i , \;\; i = 1,2,\ldots m\)&lt;/span&gt; 。&lt;/p&gt;

&lt;h2 id=&quot;二hinge-loss-梯度下降&quot;&gt;二、Hinge Loss 梯度下降&lt;/h2&gt;
&lt;p&gt;svm 使用的损失函数为 hinge loss，即为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ L(y,f(x)) = max(0,1-yf(x)) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\text{hinge loss}\)&lt;/span&gt; 使得 &lt;span class=&quot;math inline&quot;&gt;\(yf(x)&amp;gt;1\)&lt;/span&gt; 的样本损失皆为 0，由此带来了稀疏解，使得 svm 仅通过少量的支持向量就能确定最终超平面。下面来看 hinge loss 是如何推导出来的，&lt;a href=&quot;https://www.cnblogs.com/massquantity/p/11110397.html&quot;&gt;&lt;span&gt;支持向量机 (二)&lt;/span&gt;&lt;/a&gt; 中 &lt;span class=&quot;math inline&quot;&gt;\((1.1)\)&lt;/span&gt; 式带软间隔的 svm 最后的优化问题为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align} \min\limits_{\boldsymbol{w}, b,\boldsymbol{\xi}} &amp;amp; \;\; \frac12 ||\boldsymbol{w}||^2 + C \,\sum\limits_{i=1}^m \xi_i \tag{1.4}\\[1ex] {\text { s.t. }} &amp;amp; \;\; y_{i}\left(\boldsymbol{w}^{\top} \boldsymbol{x}_{i}+b\right) \geq 1 - \xi_i, \quad i=1,2, \ldots, m \tag{1.5} \\[1ex] &amp;amp; \;\; \xi_i \geq 0, \quad i=1,2, \ldots m \tag{1.6} \end{align} \]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\((1.5)\)&lt;/span&gt; 式重新整理为 $ \xi_i \geqslant 1 - y_i(\boldsymbol{w}^\top\boldsymbol{x}_i + b)$ 。若 &lt;span class=&quot;math inline&quot;&gt;\(1 - y_i(\boldsymbol{w}^\top\boldsymbol{x}_i + b) &amp;lt; 0\)&lt;/span&gt; ，由于约束&lt;span class=&quot;math inline&quot;&gt;\((1.6)\)&lt;/span&gt; 的存在，则 &lt;span class=&quot;math inline&quot;&gt;\(\xi_i \geqslant 0\)&lt;/span&gt; ；若&lt;span class=&quot;math inline&quot;&gt;\(1 - y_i(\boldsymbol{w}^\top \boldsymbol{x}_i + b) \geqslant 0\)&lt;/span&gt; ，则依然为 $ \xi_i \geqslant 1 - y_i(\boldsymbol{w}^\top \boldsymbol{x}_i + b)$ 。所以&lt;span class=&quot;math inline&quot;&gt;\((1.5),\,(1.6)\)&lt;/span&gt; 式结合起来：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \xi_i \geqslant \max(0,\, 1 - y_i(\boldsymbol{w}^\top \boldsymbol{x}_i + b)) = \max(0,\, 1-y_if(x_i)) \]&lt;/span&gt;&lt;br/&gt;又由于 &lt;span class=&quot;math inline&quot;&gt;\((1.4)\)&lt;/span&gt; 式是最小化问题，所以取 &lt;span class=&quot;math inline&quot;&gt;\(\xi_i\)&lt;/span&gt; 的极小值，即令 &lt;span class=&quot;math inline&quot;&gt;\(\xi_i = \max(0,1-yf(x))\)&lt;/span&gt; 代入 &lt;span class=&quot;math inline&quot;&gt;\((1.4)\)&lt;/span&gt; 式，并令&lt;span class=&quot;math inline&quot;&gt;\(\lambda = \frac{1}{2C}\)&lt;/span&gt; ：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \min \left(C\sum\limits_{i=1}^m \max(0,\, 1-y_if(x_i)) + \frac12 ||\boldsymbol{w}||^2\right) \quad {\large \propto} \quad \min \left( \sum\limits_{i=1}^m \underbrace{\max(0,\, 1-y_if(x_i))}_{hinge \; loss} + \lambda ||\boldsymbol{w}||^2 \right) \]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;svm 中最常用的优化算法自然是上文中的 SMO 算法，不过有了损失函数后也可以直接优化。由于 hinge loss 在 &lt;span class=&quot;math inline&quot;&gt;\(y_i(\boldsymbol{w}^T\boldsymbol{x}_i + b) = 1\)&lt;/span&gt; 处不可导，因而无法直接使用梯度下降，不过可以通过求次梯度 (&lt;a href=&quot;https://en.wikipedia.org/wiki/Subderivative&quot;&gt;&lt;em&gt;subgradient&lt;/em&gt;&lt;/a&gt;) 来进行优化：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align*} \frac{\partial L}{\partial \boldsymbol w} &amp;amp;= \begin{cases} -y_i \cdot\boldsymbol x_i &amp;amp; \text{if} \;\; y_i(\boldsymbol{w}^\top\boldsymbol{x}_i + b) &amp;lt; 1 \\[1ex] 0 &amp;amp; \text{otherwise} \end{cases} \\[2ex] \frac{\partial{L}}{\partial b} &amp;amp;= \begin{cases} -y_i \quad &amp;amp; \quad\text{if} \;\; y_i(\boldsymbol{w}^\top\boldsymbol{x}_i + b) &amp;lt; 1 \\[1ex] 0 &amp;amp; \quad \text{otherwise} \end{cases} \\[2ex] \boldsymbol{w} &amp;amp;= \boldsymbol{w} - \eta \, \frac{\partial L}{\partial \boldsymbol{w}} \\ b &amp;amp;= b - \eta \, \frac{\partial L}{\partial b} \end{align*} \]&lt;/span&gt;&lt;/p&gt;

&lt;center&gt;

&lt;/center&gt;
&lt;hr/&gt;&lt;p&gt;前文主要叙述支持向量机用于分类问题，当然其也可用于回归问题。给定一组数据 &lt;span class=&quot;math inline&quot;&gt;\(\left\{\left(\boldsymbol{x}_{1}, y_{1}\right),\left(\boldsymbol{x}_{2}, y_{2}\right), \ldots,\left(\boldsymbol{x}_{m}, y_{m}\right)\right\}\)&lt;/span&gt; ，其中 &lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol{x}_i \in \mathbb{R}^d\)&lt;/span&gt; ，&lt;span class=&quot;math inline&quot;&gt;\(y_i \in \mathbb{R}\)&lt;/span&gt; ，回归问题希望学得一个模型 &lt;span class=&quot;math inline&quot;&gt;\(f(\boldsymbol{x}) = \boldsymbol{w}^\top \boldsymbol{x} + b\)&lt;/span&gt; ，使得 &lt;span class=&quot;math inline&quot;&gt;\(f(\boldsymbol{x})\)&lt;/span&gt; 与 &lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt; 尽可能接近 。传统的回归模型通常基于模型输出 &lt;span class=&quot;math inline&quot;&gt;\(f(\boldsymbol{x})\)&lt;/span&gt; 与真实输出 &lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt; 之间的差别来计算损失。当且仅当 &lt;span class=&quot;math inline&quot;&gt;\(f(\boldsymbol{x})\)&lt;/span&gt; 与 &lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt; 完全相同时，损失才为零。支持向量回归 ( Support Vector Regression，以下简称 &lt;span class=&quot;math inline&quot;&gt;\(\text{svr}\)&lt;/span&gt; ) 与之不同，它假设能容忍 &lt;span class=&quot;math inline&quot;&gt;\(f(\boldsymbol{x})\)&lt;/span&gt; 与 &lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt; 之间最多有 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt; 的偏差，即仅当 &lt;span class=&quot;math inline&quot;&gt;\(|f(\boldsymbol{x}) - y| &amp;gt; \epsilon\)&lt;/span&gt; 时，才计算损失。如下图所示，&lt;span class=&quot;math inline&quot;&gt;\(\text{svr}\)&lt;/span&gt; 相当于以 &lt;span class=&quot;math inline&quot;&gt;\(f(\boldsymbol{x})\)&lt;/span&gt; 为中心，构建了一个宽度为 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt; 的间隔带。若训练样本落在此间隔带内则被认为是预测正确的。&lt;/p&gt;
&lt;center&gt;

&lt;/center&gt;

&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\text{svr}\)&lt;/span&gt; 的损失函数由此被称为 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon - \text{insensitive error}\)&lt;/span&gt; ，形如 ：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ L(y,f(x)) = \begin{cases} 0 \;\;&amp;amp; \text{if}\;\; |y - f(x)| \leq \epsilon\\ |y - f(x)| - \epsilon \;\; &amp;amp; \text{otherwise} \end{cases} \tag{2.1} \]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;本质上我们希望所有的模型输出 &lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt; 都在 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt; 的间隔带内，因而与 &lt;a href=&quot;https://www.cnblogs.com/massquantity/p/10920043.html&quot;&gt;&lt;span&gt;支持向量机 (一)&lt;/span&gt;&lt;/a&gt; 中的 &lt;span class=&quot;math inline&quot;&gt;\((1.3)\)&lt;/span&gt; 式一样，我们可以定义 &lt;span class=&quot;math inline&quot;&gt;\(\text{svr}\)&lt;/span&gt; 的优化目标：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{aligned} &amp;amp; \min\limits_{\boldsymbol{w}, b}\frac12 ||\boldsymbol{w}||^2 \\[1ex] &amp;amp; {\text { s.t. }} \;\; |y_{i} - \boldsymbol{w}^{\top} \boldsymbol{x}_{i} - b| \leq \epsilon , \quad i=1,2, \ldots, m \end{aligned} \tag{2.2} \]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;同样类似于 &lt;a href=&quot;https://www.cnblogs.com/massquantity/p/11110397.html&quot;&gt;&lt;span&gt;支持向量机 (二)&lt;/span&gt;&lt;/a&gt; 中的 &lt;span class=&quot;math inline&quot;&gt;\((1.1)\)&lt;/span&gt; 式，可以为&lt;strong&gt;每个样本点&lt;/strong&gt;引入松弛变量 &lt;span class=&quot;math inline&quot;&gt;\(\xi &amp;gt; 0\)&lt;/span&gt;，即允许一部分样本落到间隔带外，使得模型更加 robust 。由于这里用的是绝对值，实际上是两个不等式，也就是说两边都需要松弛变量，我们定义为 &lt;span class=&quot;math inline&quot;&gt;\(\xi_i^{\lor}, \xi_i^{\land}\)&lt;/span&gt; ，于是优化目标变为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align*} \min\limits_{\boldsymbol{w}, b,\boldsymbol{\xi^\lor},\boldsymbol{\xi^\land}}\;\; &amp;amp;\frac{1}{2}||\boldsymbol{w}||^2 + C\sum\limits_{i=1}^{m}(\xi_i^{\lor}+ \xi_i^{\land}) \\[1ex] \text{s.t.} \;\; &amp;amp;-\epsilon - \xi_i^{\lor} \leq y_i - \boldsymbol{w}^\top \boldsymbol{x}_i -b \leq \epsilon + \xi_i^{\land} \\[1ex] &amp;amp; \xi_i^{\lor} \geq 0, \; \xi_i^{\land} \geq 0\quad i=1,2, \ldots, m \end{align*} \tag{2.3} \]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;上式中的 &lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt; 分别对应 scikit-learn 的 &lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.svm.SVR.html#sklearn.svm.SVR&quot;&gt;SVR&lt;/a&gt; 中的参数 &lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(\text{epsilon}\)&lt;/span&gt; ，&lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt; 越大，意味着对离群点的惩罚就越大，最终就会有较少的点跨过间隔边界，模型也会变得复杂。而 &lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt; 设的越小，则较多的点会跨过间隔边界，最终形成的模型较为平滑。而 &lt;span class=&quot;math inline&quot;&gt;\(\text{epsilon}\)&lt;/span&gt; 越大，则对离群点容忍度越高，最终的模型也会较为平滑，这个参数是 &lt;span class=&quot;math inline&quot;&gt;\(\text{svr}\)&lt;/span&gt; 问题中独有的，svm 中没有这个参数。&lt;/p&gt;

&lt;p&gt;对于 &lt;span class=&quot;math inline&quot;&gt;\((2.3)\)&lt;/span&gt; 式，为每条约束引入拉格朗日乘子 &lt;span class=&quot;math inline&quot;&gt;\(\mu_i^{\lor} \geqslant 0, \, \mu_i^{\land} \geqslant 0,\, \alpha_i^{\lor} \geqslant 0, \,\alpha_i^{\land} \geqslant 0\)&lt;/span&gt; ：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align*} L(\boldsymbol{w},b,\boldsymbol{\alpha^{\lor}}, \boldsymbol{\alpha^{\land}}, \boldsymbol{\xi^{\lor}}, \boldsymbol{\xi}^{\land}, \boldsymbol{\mu}^{\lor}, \boldsymbol{\mu}^{\land}) = &amp;amp;\frac{1}{2}||\boldsymbol{w}||^2 + C\sum\limits_{i=1}^{m}(\xi_i^{\lor}+ \xi_i^{\land}) + \\ &amp;amp;\sum\limits_{i=1}^{m}\alpha_i^{\lor}(-\epsilon - \xi_i^{\lor} -y_i + \boldsymbol{w}^\top \boldsymbol{x}_i + b) + \\ &amp;amp; \sum\limits_{i=1}^{m}\alpha_i^{\land}(y_i - \boldsymbol{w}^\top \boldsymbol{x}_i - b -\epsilon - \xi_i^{\land}) - \\ &amp;amp; \sum\limits_{i=1}^{m}\mu_i^{\lor}\xi_i^{\lor} - \sum\limits_{i=1}^{m}\mu_i^{\land}\xi_i^{\land} \end{align*} \tag{2.4} \]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;其对偶问题为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{aligned} \max_{\boldsymbol{\alpha}, \boldsymbol{\mu}}\min_{\boldsymbol{w},b,\boldsymbol{\xi}} &amp;amp;\;\; L(\boldsymbol{w},b,\boldsymbol{\alpha^{\lor}}, \boldsymbol{\alpha^{\land}}, \boldsymbol{\xi^{\lor}}, \boldsymbol{\xi}^{\land}, \boldsymbol{\mu}^{\lor}, \boldsymbol{\mu}^{\land}) \\[1ex] \text{s.t.} &amp;amp;\;\; \alpha_i^{\lor}, \, \alpha_i^{\land} \geq 0, \quad i=1,2, \ldots m \\[1ex] &amp;amp; \;\;\mu_i^{\lor},\, \mu_i^{\land} \geq 0, \quad i = 1,2, \ldots m \end{aligned} \tag{2.5} \]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;上式对 &lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol{w}, b, \xi_i^\lor, \xi_i^\land\)&lt;/span&gt; 求偏导为零可得：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align} \frac{\partial L}{\partial \boldsymbol{w}} = \boldsymbol{0} &amp;amp; \implies \boldsymbol{w} = \sum\limits_{i=1}^m (\alpha_i^\land - \alpha_i^\lor) \boldsymbol{x}_i \qquad\qquad \tag{2.6} \\ \frac{\partial L}{\partial b} = 0 &amp;amp; \implies \sum\limits_{i=1}^m (\alpha_i^\land - \alpha_i^\lor) = 0 \qquad\qquad\quad\; \tag{2.7} \\ \frac{\partial L}{\partial \boldsymbol{\xi}^\lor} = 0 &amp;amp; \implies C - \alpha_i^\lor - \mu_i^\lor = 0 \qquad\qquad\quad\; \tag{2.8} \\ \frac{\partial L}{\partial \boldsymbol{\xi}^\land} = 0 &amp;amp; \implies C - \alpha_i^\land - \mu_i^\land = 0 \qquad\qquad\quad\; \tag{2.9} \end{align} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;将 &lt;span class=&quot;math inline&quot;&gt;\((2.6) \sim (2.9)\)&lt;/span&gt; 式代入 &lt;span class=&quot;math inline&quot;&gt;\((2.4)\)&lt;/span&gt; 式，并考虑由&lt;span class=&quot;math inline&quot;&gt;\((2.8), \,(2.9)\)&lt;/span&gt; 式得 &lt;span class=&quot;math inline&quot;&gt;\(C - \alpha_i = u_i \geqslant 0\)&lt;/span&gt; ，因而 &lt;span class=&quot;math inline&quot;&gt;\(0 \leqslant \alpha_i \leqslant C\)&lt;/span&gt; 得化简后的优化问题：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{aligned} \max_{\boldsymbol{\alpha}^\lor, \boldsymbol{\alpha}^\land} &amp;amp;\;\; \sum\limits_{i=1}^m y_i(\alpha_i^\land - \alpha_i^\lor) - \epsilon(\alpha_i^\land + \alpha_i^\land) - \frac12 \sum\limits_{i=1}^m\sum\limits_{j=1}^m (\alpha_i^\land - \alpha_i^\lor)(\alpha_j^\land - \alpha_j^\lor)\boldsymbol{x}_i^{\top}\boldsymbol{x}_j \\[1ex] \text{s.t.} &amp;amp; \;\; \sum\limits_{i=1}^m (\alpha_i^\land - \alpha_i^\lor) = 0 \\[1ex] &amp;amp; \;\; 0 \leqslant \alpha_i^\lor, \alpha_i^\land \leqslant C, \quad i = 1,2,\ldots m \end{aligned} \tag{2.10} \]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;上述求最优解的过程需满足 &lt;span class=&quot;math inline&quot;&gt;\(\mathbb{KKT}\)&lt;/span&gt; 条件，其中的互补松弛条件为 ：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{cases} \alpha_i^{\lor}(\epsilon + \xi_i^{\lor} + y_i - \boldsymbol{w}^\top \boldsymbol{x}_i - b ) = 0 \qquad\qquad\qquad\qquad\qquad (2.11) \\[2ex] \alpha_i^{\land}(\epsilon + \xi_i^{\land} - y_i + \boldsymbol{w}^\top \boldsymbol{x}_i + b ) = 0 \qquad\qquad\qquad\qquad\qquad (2.12) \\[2ex] \mu^\lor_i \xi^\lor_i = (C - \alpha^\lor_i)\xi^\lor_i = 0 \qquad\qquad\qquad\qquad\qquad\qquad\quad\;\; (2.13) \\[2ex] \mu^\land_i \xi^\lor_i = (C - \alpha^\land_i)\xi^\land_i = 0 \qquad\qquad\qquad\qquad\qquad\qquad\quad\;\; (2.14) \end{cases} \]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;若样本在间隔带内，则 &lt;span class=&quot;math inline&quot;&gt;\(\xi_i = 0\)&lt;/span&gt; ， &lt;span class=&quot;math inline&quot;&gt;\(| y_i - \boldsymbol{w}^\top \boldsymbol{x} - b| &amp;lt; \epsilon\)&lt;/span&gt; ，于是要让互补松弛成立，只有使 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_i^{\lor} = 0, \,\alpha_i^{\land} = 0\)&lt;/span&gt; ，则由 &lt;span class=&quot;math inline&quot;&gt;\((2.6)\)&lt;/span&gt; 式得 &lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol{w} = 0\)&lt;/span&gt; ，说明在间隔带内的样本都不是支持向量，而对于间隔带上或间隔带外的样本，相应的 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_i^\lor\)&lt;/span&gt; 或 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_i^\land\)&lt;/span&gt; 才能取非零值。此外一个样本不可能同时位于 &lt;span class=&quot;math inline&quot;&gt;\(f(\boldsymbol{x})\)&lt;/span&gt; 的上方和下方，所以 &lt;span class=&quot;math inline&quot;&gt;\((2.11)\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\((2.12)\)&lt;/span&gt; 式不能同时成立，因此 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_i^{\lor}\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_i^\land\)&lt;/span&gt; 中至少一个为零。&lt;/p&gt;

&lt;p&gt;优化问题 &lt;span class=&quot;math inline&quot;&gt;\((2.10)\)&lt;/span&gt; 同样可以使用二次规划或 SMO 算法求出 &lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol{\alpha}\)&lt;/span&gt; ，继而根据 &lt;span class=&quot;math inline&quot;&gt;\((2.6)\)&lt;/span&gt; 式求得模型参数 &lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol{w} = \sum_{i=1}^m (\alpha_i^\land - \alpha_i^\lor) \boldsymbol{x}_i\)&lt;/span&gt; 。而对于模型参数 &lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt; 来说，对于任意满足 &lt;span class=&quot;math inline&quot;&gt;\(0 &amp;lt; \alpha_i &amp;lt; C\)&lt;/span&gt; 的样本，由 &lt;span class=&quot;math inline&quot;&gt;\((2.13)\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\((2.14)\)&lt;/span&gt; 式可得 &lt;span class=&quot;math inline&quot;&gt;\(\xi _i= 0\)&lt;/span&gt; ，进而根据 &lt;span class=&quot;math inline&quot;&gt;\((2.11)\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\((2.12)\)&lt;/span&gt; 式：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ b = \epsilon + y_i - \boldsymbol{w}^\top\boldsymbol{x}_i = \epsilon + y_i - \sum\limits_{j=1}^m (\alpha_j^\land - \alpha_j^\lor) \boldsymbol{x}_j^\top \boldsymbol{x}_i \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;则 &lt;span class=&quot;math inline&quot;&gt;\(\text{svr}\)&lt;/span&gt; 最后的模型为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ f(\boldsymbol{x}) = \boldsymbol{w}^\top \boldsymbol{x} + b = \sum\limits_{i=1}^m (\alpha_i^\land - \alpha_i^\lor) \boldsymbol{x}_i^\top \boldsymbol{x} + b \]&lt;/span&gt;&lt;/p&gt;

&lt;center&gt;
&lt;h2 id=&quot;支持向量机算法总结&quot;&gt;支持向量机算法总结&lt;/h2&gt;
&lt;/center&gt;
&lt;hr/&gt;&lt;h3 id=&quot;支持向量机的优点&quot;&gt;支持向量机的优点：&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;解决高维特征的分类问题和回归问题很有效,在特征维度大于样本数时依然有很好的效果。&lt;/li&gt;
&lt;li&gt;仅仅使用一部分样本决定超平面，内存占用少。&lt;/li&gt;
&lt;li&gt;有大量的核函数可以使用，从而可以很灵活的来解决各种非线性的分类回归问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;支持向量机的缺点&quot;&gt;支持向量机的缺点：&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;当采用核函数时，如果需要存储核矩阵，则空间复杂度为 &lt;span class=&quot;math inline&quot;&gt;\(\mathcal{O}(m^2)\)&lt;/span&gt; 。&lt;/li&gt;
&lt;li&gt;选择核函数没有通用的标准 (当然其实是有的，见下文~) 。&lt;/li&gt;
&lt;li&gt;样本量很大时，计算复杂度高。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于第 3 个缺点，scikit-learn 的 &lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.html&quot;&gt;&lt;span&gt;SVC&lt;/span&gt;&lt;/a&gt; 文档中有一句话：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;The fit time scales at least quadratically with the number of samples and may be impractical beyond tens of thousands of samples.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我特意去查了下字典，”tens of thousands“ 意为 ”好几万“，也就是说对于几万的数据 svm 处理起来就已经很捉急了，至于百万到亿级的数据基本就不用想了，这在如今这个大数据时代确实不够看，不过这里说的是使用核函数的 svm。而对于线性 svm 来说，情况要好很多，一般为 &lt;span class=&quot;math inline&quot;&gt;\(\mathcal{O}(m)\)&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;LibSVM 的作者，国立台湾大学的林智仁教授在其一篇小文（&lt;a href=&quot;https://www.csie.ntu.edu.tw/~cjlin/papers/guide/guide.pdf&quot;&gt;&lt;em&gt;&lt;span&gt;A Practical Guide to Support Vector Classification&lt;/span&gt;&lt;/em&gt;&lt;/a&gt;）中提出了 svm 库的一般使用流程 :&lt;/p&gt;
&lt;center&gt;

&lt;/center&gt;

&lt;p&gt;其中第二步 scaling 对于 svm 的整体效果有重大影响。主要原因为在没有进行 scaling 的情况下，数值范围大的特征会产生较大的影响，进而影响模型效果。&lt;/p&gt;
&lt;p&gt;第三步中认为应优先试验 RBF 核，通常效果比较好。但他同时也提到，RBF 核并不是万能的，在一些情况下线性核更加适用。当特征数非常多，或者样本数远小于特征数时，使用线性核已然足够，映射到高维空间作用不大，而且只要对 C 进行调参即可。虽然理论上高斯核的效果不会差于线性核，但高斯核需要更多轮的调参。&lt;/p&gt;

&lt;p&gt;下表总结了 scikit-learn 中的 svm 分类库：&lt;/p&gt;
&lt;center&gt;

&lt;/center&gt;

&lt;p&gt;scikit-learn 中 svm 库的两个主要超参数为 &lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(\gamma\)&lt;/span&gt; ，&lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(\gamma\)&lt;/span&gt; 越大，则模型趋于复杂，容易过拟合；反之，&lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(\gamma\)&lt;/span&gt; 越大，模型变得简单，如下图所示：&lt;/p&gt;
&lt;center&gt;

&lt;/center&gt;

&lt;p&gt;/&lt;/p&gt;
</description>
<pubDate>Thu, 29 Aug 2019 17:00:00 +0000</pubDate>
<dc:creator>massquantity</dc:creator>
<og:description>'拉格朗日乘子法 KKT条件 对偶问题' '支持向量机 (一)： 线性可分类 svm' '支持向量机 (二)： 软间隔 svm 与 核函数' 支持向量机 (三)： 优化方法与支持向量回归 优化方法 一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/massquantity/p/11419971.html</dc:identifier>
</item>
<item>
<title>Go语言学习——如何实现一个过滤器 - JackieZheng</title>
<link>http://www.cnblogs.com/bigdataZJ/p/go-filter.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bigdataZJ/p/go-filter.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1、过滤器使用场景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　做业务的时候我们经常要使用过滤器或者拦截器（听这口音就是从Java过来的）。常见的场景如一个HTTP请求，需要经过鉴权过滤器、白名单校验过滤、参数验证过滤器等重重关卡最终拿到数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Java使用过滤器很简单。XML时代，只要添加一个过滤器配置再新建一个实现了Filter接口的xxxFilter实现类；Java Configuration时代，只要在xxxConfiguration配置类中声明一个Filter注解，如果想设置Filter的执行顺序，加上Order注解就行了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Java的过滤器实在太方便也太好用了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　以至于在Java有关过滤器的面试题中，只有类似于“过滤器的使用场景有哪些？”，“过滤器和拦截器有什么区别？“，几乎很少听到”你知道过滤器是怎么实现的吗？“，”如果让你实现一个过滤器，你会怎么做？“这样的题目。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2、使用过滤器的场景特征&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如同上面过滤器的例子，我们发现过滤器有一些特征：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1、入参一样，比如HTTP请求的过滤器的入参就是ServletRequest对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2、返回值类型相同，比如都是true或者false，或者是链接到下一个过滤器或者return。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下是Java实现的CORS过滤器&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;55&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
import org.springframework.http.HttpStatus;
import org.springframework.util.StringUtils;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class CORSFilter implements Filter {

    @Override
    public void doFilter(ServletRequest reserRealmq, ServletResponse res, FilterChain chain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) reserRealmq;
        HttpServletResponse response = (HttpServletResponse) res;

        String currentOrigin= request.getHeader(&quot;Origin&quot;);
        if (!StringUtils.isEmpty(currentOrigin)) {
            response.setHeader(&quot;Access-Control-Allow-Origin&quot;, currentOrigin);
            response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, DELETE, PUT&quot;);
            response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);
            response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, No-Cache, X-Requested-With, If-Modified-Since, Cache-Control, Expires, Content-Type, X-E4M-With, Index-Url&quot;);
        }

        // return http status 204 if OPTIONS requst
        if (&quot;OPTIONS&quot;.equals(request.getMethod())){
            response.setStatus(HttpStatus.NO_CONTENT.value());
        }else {
            chain.doFilter(reserRealmq, res);
        }
    }

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void destroy() {

    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;凡是具有这种特征的需求，我们都可以抽象为过滤器进行实现（Java里面称为责任链模式）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面就来说说，基于Go语言如何实现一个过滤器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3、简单实现&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　过滤器本质就是一堆条件判定，最直观的过滤方案就是创建几个方法，针对每个方法的返回结果判定，如果返回为false则终止请求，如果为true则继续执行下一个过滤器。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
package main

import (
        &quot;context&quot;
)

func main() {
        ctx := context.TODO()
  
  if continued := F1(ctx); !continued {
    ...
    return
  }
  
  if continued := F2(ctx); !continued {
    ...
    return
  }
  
  if continued := F3(ctx); !continued {
    ...
    return
  }
}

func F1(ctx context.Context) bool {
  ...
  return true
} 

func F2(ctx context.Context) bool {
  ...
  return true
}

func F3(ctx context.Context) bool {
  ...
  return false
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;该版本从功能上说，完全符合过滤器的要求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是从代码层面来说，有几个问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1、复用性较差。main函数中对于各个过滤器的判定，除了函数名不一样，其他逻辑都一样，可以考虑抽象重用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2、可扩展性较差。因为有些代码复用性差，导致代码不好扩展，如果这时候添加、删除过滤器或者调整过滤器执行顺序，代码都需要较大改动才能实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3、难以维护。不用多说。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4、重构实现&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
package main

import (
        &quot;context&quot;
        &quot;fmt&quot;
)

type MyContext struct {
        context.Context
        KeyValue map[string]bool
}

type FilterFunc func(*MyContext) bool

type FilterFuncChain []FilterFunc

type CombinedFunc struct {
        CF    FilterFuncChain
        MyCtx *MyContext
}

func main() {
        myContext := MyContext{Context: context.TODO(), KeyValue: map[string]bool{&quot;key&quot;: false}}

        cf := CombinedFilter(&amp;amp;myContext, F1, F2, F3);
        DoFilter(cf)
}

func DoFilter(cf *CombinedFunc) {
        for _, f := range cf.CF {
                res := f(cf.MyCtx)
                fmt.Println(&quot;result:&quot;, res)
                if res == false {
                        fmt.Println(&quot;stopped&quot;)
                        return
                }
        }
}

func CombinedFilter(ctx *MyContext, ff ...FilterFunc) *CombinedFunc {
        return &amp;amp;CombinedFunc{
                CF:    ff,
                MyCtx: ctx,
        }
}

func F1(ctx *MyContext) bool {
        ctx.KeyValue[&quot;key&quot;] = true
        fmt.Println(ctx.KeyValue[&quot;key&quot;])

        return ctx.KeyValue[&quot;key&quot;]
}

func F2(ctx *MyContext) bool {
        ctx.KeyValue[&quot;key&quot;] = false
        fmt.Println(ctx.KeyValue[&quot;key&quot;])

        return ctx.KeyValue[&quot;key&quot;]
}

func F3(ctx *MyContext) bool {
        ctx.KeyValue[&quot;key&quot;] = false
        fmt.Println(ctx.KeyValue[&quot;key&quot;])

        return ctx.KeyValue[&quot;key&quot;]
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;代码不长，我们一块块分析。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.1 自定义的Context&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里我使用了自定义的Context，重新定义一个MyContext的结构体，其中组合了标准库中的Context，即具备标准库Context的能力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里MyContext是作为数据载体在各个过滤器之间传递。没有用标准库的Context，采用自定义的Context主要是为了说明我们可以根据需要扩展MyContext，通过扩展MyContext添加任何我们需要的参数。这里添加的是一个map键值对。我们可以将每个过滤器处理的结果存入这个map中，再传递到下一个过滤器。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
myContext := MyContext{Context: context.TODO(), KeyValue: map[string]bool{&quot;key&quot;: false}}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面的等价写法还可以是&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
ctx := context.TODO()
myContext := context.WithValue(ctx, &quot;key&quot;, &quot;value&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里充分利用了Context的WithValue的用法，有兴趣可以去看下，这是Context创建map键值对的方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.2 充分利用Go的type的特性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
type FilterFunc func(*MyContext) bool
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　前面在使用过滤的场景特种中提到，过滤器的入参和返回值都是一样的。所以这里我们利用Go的type特性，将这种过滤器函数定义为一个变量FilterFunc&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这一特性对于精简代码起到了关键性的作用。且看&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
cf := CombinedFilter(&amp;amp;myContext, F1, F2, F3);

func CombinedFilter(ctx *MyContext, ff ...FilterFunc) *CombinedFunc {
        return &amp;amp;CombinedFunc{
                CF:    ff,
                MyCtx: ctx,
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;因为这里的F1、F2和F3都有相同入参和返回值，所以抽象为FilterFunc，并使用变长参数的FilterFunc统一接收。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CombinedFilter不仅可以加F1、F2和F3，后面还可以有F4、F5...&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
type FilterFuncChain []FilterFunc
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　这里的抽象也是同样的道理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果之前写过Java，这里是不是已经看到了Filter接口的影子。其实这里的FilterFunc可以等价于Java里面的Filter接口，接口是一种约束一种契约，Filter定义了如果要实现该接口必须要实现接口定义的方法。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package javax.servlet;

import java.io.IOException;

/**
 * A FilterChain is an object provided by the servlet container to the developer
 * giving a view into the invocation chain of a filtered request for a resource.
 * Filters use the FilterChain to invoke the next filter in the chain, or if the
 * calling filter is the last filter in the chain, to invoke the resource at the
 * end of the chain.
 *
 * @see Filter
 * @since Servlet 2.3
 **/

public interface FilterChain {

    /**
     * Causes the next filter in the chain to be invoked, or if the calling
     * filter is the last filter in the chain, causes the resource at the end of
     * the chain to be invoked.
     *
     * @param request
     *            the request to pass along the chain.
     * @param response
     *            the response to pass along the chain.
     *
     * @throws IOException if an I/O error occurs during the processing of the
     *                     request
     * @throws ServletException if the processing fails for any other reason

     * @since 2.3
     */
    public void doFilter(ServletRequest request, ServletResponse response)
            throws IOException, ServletException;

}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.3 遍历执行过滤器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　因为有了上面的特性，我们才能将这些过滤器存入切片然后依次执行，如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
func DoFilter(cf *CombinedFunc) {
        for _, f := range cf.CF {
                res := f(cf.MyCtx)
                fmt.Println(&quot;result:&quot;, res)
                if res == false {
                        fmt.Println(&quot;stopped&quot;)
                        return
                }
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在执行的过程中，如果我们发现如果返回值为false，则表示没有通过某个过滤器校验，则退出也不会继续执行后面的过滤器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5、继续改进&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;既然MyContext中的map集合可以存储各个Filter的执行情况，而且可以在各个过滤器之间传递，我们甚至可以省略FilterFunc函数的返回值，改进后如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
package main

import (
        &quot;context&quot;
        &quot;fmt&quot;
)

type MyContext struct {
        context.Context
        KeyValue map[string]bool
}

type FilterFunc func(*MyContext)

type FilterFuncChain []FilterFunc

type CombinedFunc struct {
        CF    FilterFuncChain
        MyCtx *MyContext
}

func main() {
        myContext := MyContext{Context: context.TODO(), KeyValue: map[string]bool{&quot;key&quot;: false}}

        cf := CombinedFilter(&amp;amp;myContext, F1, F2, F3);
        DoFilter(cf)
}

func DoFilter(cf *CombinedFunc) {
        for _, f := range cf.CF {
                f(cf.MyCtx)
                continued :=  cf.MyCtx.KeyValue[&quot;key&quot;]
                fmt.Println(&quot;result:&quot;, continued)
                if !continued {
                        fmt.Println(&quot;stopped&quot;)
                        return
                }
        }
}

func CombinedFilter(ctx *MyContext, ff ...FilterFunc) *CombinedFunc {
        return &amp;amp;CombinedFunc{
                CF:    ff,
                MyCtx: ctx,
        }
}

func F1(ctx *MyContext) {
        ctx.KeyValue[&quot;key&quot;] = true
        fmt.Println(ctx.KeyValue[&quot;key&quot;])
        //return ctx.KeyValue[&quot;key&quot;]
}

func F2(ctx *MyContext) {
        ctx.KeyValue[&quot;key&quot;] = false
        fmt.Println(ctx.KeyValue[&quot;key&quot;])
        //return ctx.KeyValue[&quot;key&quot;]
}

func F3(ctx *MyContext) {
        ctx.KeyValue[&quot;key&quot;] = false
        fmt.Println(ctx.KeyValue[&quot;key&quot;])
        //return ctx.KeyValue[&quot;key&quot;]
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;6、总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基于Go语言造轮子实现一个过滤器的雏形，通过实现一个相对优雅可扩展的过滤器熟悉了type的用法，Context.WithValue的作用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果您觉得阅读本文对您有帮助，请点一下“&lt;strong&gt;推荐&lt;/strong&gt;”按钮，您的&lt;strong&gt;“推荐”&lt;/strong&gt;将是我最大的写作动力！如果您想持续关注我的文章，请扫描二维码，关注JackieZheng的微信公众号，我会将我的文章推送给您，并和您一起分享我日常阅读过的优质文章。&lt;/p&gt;
&lt;pre&gt;
&lt;em&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog2015/619240/201505/162205410643708.jpg&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 29 Aug 2019 16:58:00 +0000</pubDate>
<dc:creator>JackieZheng</dc:creator>
<og:description>基于Go语言造轮子实现一个过滤器的雏形，通过实现一个相对优雅可扩展的过滤器熟悉了type的用法，Context.WithValue的作用。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bigdataZJ/p/go-filter.html</dc:identifier>
</item>
<item>
<title>Django之静态文件，中间件，admin后台管理 - YifChan</title>
<link>http://www.cnblogs.com/yifchan/p/python-1-30.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yifchan/p/python-1-30.html</guid>
<description>&lt;p&gt;Django1.8.2中文文档：&lt;a href=&quot;https://yiyibooks.cn/xx/django_182/index.html&quot; target=&quot;_blank&quot;&gt;Django1.8.2中文文档&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;静态文件&lt;/h2&gt;
&lt;h4&gt;静态文件的使用&lt;/h4&gt;
&lt;p&gt;在 网页使用的css文件，js文件和图片等叫做静态文件。&lt;br/&gt;1)在项目下新建静态文件夹 static。&lt;/p&gt;
&lt;p&gt;2) 配置静态文件所在的物理目录。Settings.py&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1618401/201908/1618401-20190829234619337-1659863100.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;STATIC_URL设置访问静态文件对应的url。&lt;/li&gt;
&lt;li&gt;STATICFILES_DIRS设置静态文件所在的物理目录。&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;动态生成静态文件的路径&lt;/h4&gt;
&lt;p&gt;即不管你的 STATIC_URL 怎么变，也对页面上的静态文件url获取没影响&lt;/p&gt;
&lt;p&gt;settings.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置访问静态文件的url地址&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; http://127.0.0.1:8000/static/images/mm.jpg，通过这个，可以直接访问图片&lt;/span&gt;
STATIC_URL = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/static/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; STATIC_URL = '/abc/'&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置静态文件存放的物理目录&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Django找静态文件的顺序：先去配置的 STATICFILES_DIRS 下面去找，找不到就去应用下面的static下面找&lt;/span&gt;
STATICFILES_DIRS = [os.path.join(BASE_DIR, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;static_test.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
{% load staticfiles %}
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;静态文件测试&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;/static/images/mm.jpg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;mm&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;/abc/images/mm.jpg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;mm&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;

动态获取 STATIC_URL，拼接静态文件路径：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;{% static 'images/mm.jpg' %}&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;mm&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配套函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; static_test(request):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;静态文件&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; render(request, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;booktest/static_test.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;中间件&lt;/h2&gt;
&lt;p&gt;中间件函数是django框架给我们预留的函数接口，让我们可以干预请求和应答的过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1618401/201908/1618401-20190829234928764-1635918941.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;使用中间件&lt;/h3&gt;
&lt;p&gt;1)在应用中新建middleware.py文件。&lt;/p&gt;
&lt;p&gt;2)定义中间件类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1618401/201908/1618401-20190829235234084-568310722.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在类中定义中间件预留函数。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;__init__:服务器响应第一个请求的时候调用。&lt;/li&gt;
&lt;li&gt;process_request:是在产生request对象，进行url匹配之前调用。&lt;/li&gt;
&lt;li&gt;process_view：是url匹配之后，调用视图函数之前。&lt;/li&gt;
&lt;li&gt;process_response：视图函数调用之后，内容返回给浏览器之前。&lt;/li&gt;
&lt;li&gt;process_exception:视图函数出现异常，会调用这个函数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果注册的多个中间件类中包含process_exception函数的时候，调用的顺序跟注册的顺序是相反的。&lt;br/&gt;3)注册中间件类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1618401/201908/1618401-20190829235307455-1439910360.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;使用中间件进行登录判断案例&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;获取浏览器端的ip地址&lt;/strong&gt;，使用request对象的META属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
request.META[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;REMOTE_ADDR&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;需求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们需要禁用某些恶意ip的访问时，需要获取用户ip，然后建立一个禁止ip列表，判断ip是否在禁止列表中，如果是恶意ip，则禁止进入，&lt;br/&gt;否则返回响应的页面，诚然，我们可以定义一个装饰器来对每个函数进行判断，但这并不是最佳的选择，我们可以使用中间件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单个函数判断&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; index(request):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;首页&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    user_ip &lt;/span&gt;= request.META[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;REMOTE_ADDR&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(user_ip)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; user_ip &lt;span&gt;in&lt;/span&gt;&lt;span&gt; EXCLUDE_IPS:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;h2&amp;gt;Forbidden&amp;lt;/h2&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;booktest/index.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;装饰器判断&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; ban_ip(view_func):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;用来禁止恶意ip的装饰器&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; wrapper(request, *args, **&lt;span&gt;kwargs):
        user_ip &lt;/span&gt;= request.META[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;REMOTE_ADDR&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(user_ip)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; user_ip &lt;span&gt;in&lt;/span&gt;&lt;span&gt; EXCLUDE_IPS:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;h2&amp;gt;Forbidden&amp;lt;/h2&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; view_func(request, *args, **&lt;span&gt;kwargs)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper

@ban_ip
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; index(request):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;首页&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; render(request, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;booktest/index.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;中间件步骤&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.在应用下新建一个middleware.py文件，名字随意，但一般用这个。&lt;/li&gt;
&lt;li&gt;2.编写中间件代码；&lt;/li&gt;
&lt;li&gt;3.在settings中注册中间件；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;中间件判断&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.utils.deprecation &lt;span&gt;import&lt;/span&gt;&lt;span&gt; MiddlewareMixin
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.http &lt;span&gt;import&lt;/span&gt;&lt;span&gt; HttpResponse

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BanIpMiddleware(MiddlewareMixin):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;中间件类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    EXCLUDE_IPS &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]

    @staticmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; process_view(request, view_func, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;视图函数调用之前会调用&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        user_ip &lt;/span&gt;= request.META[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;REMOTE_ADDR&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; user_ip &lt;span&gt;in&lt;/span&gt;&lt;span&gt; BanIpMiddleware.EXCLUDE_IPS:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;h2&amp;gt;Forbidden&amp;lt;/h2&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注册中间件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
MIDDLEWARE =&lt;span&gt; [
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;booktest.middleware.BanIpMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;中间件执行顺序&lt;/h4&gt;
&lt;p&gt;中间件的执行顺序一般是按照在settings文件里面的注册顺序来的，特殊情况是如果注册的多个中间件类中包含process_exception函数的时候，调用的顺序跟注册的顺序是相反的。&lt;/p&gt;
&lt;p&gt;__init__只在服务器重启之后，第一个请求时调用，后面的请求都不会再调用了；&lt;/p&gt;
&lt;p&gt;中间件执行顺序示例代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestMiddleware(MiddlewareMixin):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;中间件类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, get_response=&lt;span&gt;None):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;服务器重启之后，接收第一个请求时调用&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; get_response参数是必需的，这个参数指的是下一个中间件或者view函数(如果是最后一个中间件)。&lt;/span&gt;
        super().&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
        self.get_response &lt;/span&gt;=&lt;span&gt; get_response
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----init-----&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    @staticmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_request(request):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;产生request对象之后，url匹配之前调用&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----process_request-----&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    @staticmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; process_view(request, view_func, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;url匹配之后，视图函数调用之前调用&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----process_view-----&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    @staticmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_response(request, response):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;视图函数之后，应答返回浏览器之前&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----process_response-----&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; response
        
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 执行结果：&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -----init-----&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -----process_request-----&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -----process_view-----&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -----process_response-----&lt;/span&gt;


&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ExceptionTest1Middleware(MiddlewareMixin):
    @staticmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_exception(request, exception):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;视图函数发生异常时调用&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----process_exception1-----&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(exception)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ExceptionTest2Middleware(MiddlewareMixin):
    @staticmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_exception(request, exception):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;视图函数发生异常时调用&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----process_exception2-----&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;admin后台管理&lt;/h2&gt;
&lt;h4&gt;admin的使用&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;1) 本地化。语言和时区本地化。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
LANGUAGE_CODE = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zh-hans&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
TIME_ZONE &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Asia/Shanghai&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;2) 创建超级管理员。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
python mange.py createsuperuser
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;3) 注册模型类。&lt;/li&gt;
&lt;li&gt;4)&lt;/li&gt;
&lt;li&gt;4.1.自定义管理页面。&lt;/li&gt;
&lt;li&gt;4.2.自定义模型管理类。&lt;/li&gt;
&lt;li&gt;4.3.注册模型类的时候给register函数添加第二个参数，就是自定义模型管理类的名字。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;列表页选项&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;列表页选项示例代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;models.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; AreaInfo(models.Model):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;地区模型类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 地区名称&lt;/span&gt;
    atitle = models.CharField(verbose_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;地区名&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, max_length=20&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 自关联属性&lt;/span&gt;
    aParent = models.ForeignKey(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;self&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, null=True, blank=&lt;span&gt;True)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在admin点进去表之后显示地区名&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.atitle

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义title列，提供显示atitle&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; title(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.atitle
    title.admin_order_field &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义title列的排序方式&lt;/span&gt;
    title.short_description = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;地区名称&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义title列显示的列名&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; parent(self):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; self.aParent &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.aParent.atitle
    parent.short_description &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;父级地区名称&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;admin.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; AreaInfoAdmin(admin.ModelAdmin):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;地区模型管理类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    list_per_page &lt;/span&gt;= 10  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 指定每页显示10条数据&lt;/span&gt;
    list_display = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;atitle&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 指定页面上展示的内容&lt;/span&gt;
    actions_on_bottom = True  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 开启下面的action框&lt;/span&gt;
    actions_on_top = False  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 关闭上建的action框&lt;/span&gt;
    list_filter = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;atitle&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 页表右侧的过滤兰&lt;/span&gt;
    search_fields = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;atitle&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 列表页上方的搜索框&lt;/span&gt;
&lt;span&gt;

admin.site.register(models.AreaInfo, AreaInfoAdmin)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注：list_display不仅可以写模型类的属性，还可以写方法；&lt;/p&gt;
&lt;p&gt;显示效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1618401/201908/1618401-20190830001406215-401327918.png&quot; alt=&quot;&quot; width=&quot;853&quot; height=&quot;367&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;编辑页选项&lt;/h3&gt;
&lt;p&gt;初始效果图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1618401/201908/1618401-20190830001508468-731145727.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;fields控制显示字段顺序&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; AreaInfoAdmin(admin.ModelAdmin):
    fields &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;aParent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;atitle&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 控制编辑页中 显示字段的顺序&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;改变顺序后&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1618401/201908/1618401-20190830001522377-1554018854.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分组显示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; AreaInfoAdmin(admin.ModelAdmin):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;地区模型管理类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    fieldsets &lt;/span&gt;=&lt;span&gt; (
        (&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;基本&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fields&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;atitle&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]}),
        (&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;高级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fields&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;aParent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]})
    )&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分组显示效果图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1618401/201908/1618401-20190830001551903-556377357.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;应注意 ，fields和fieldsets不能同时使用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关联对象/控制显示该地区下面的子级地区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;块嵌入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 块嵌入&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; AreaStackedInline(admin.StackedInline):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 写多类的名称&lt;/span&gt;
    model = models.AreaInfo  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 关联子对象&lt;/span&gt;
    extra = 2  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 控制多余的行数/额外编辑2个子对象&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; AreaInfoAdmin(admin.ModelAdmin):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;地区模型管理类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    inlines &lt;/span&gt;= [AreaStackedInline]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表嵌入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; AreaTabularInline(admin.TabularInline):
    model &lt;/span&gt;= models.AreaInfo  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 关联子对象&lt;/span&gt;
    extra = 2  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 控制多余的行数/额外编辑2个子对象&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; AreaInfoAdmin(admin.ModelAdmin):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;地区模型管理类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    inlines &lt;/span&gt;= [AreaStackedInline]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表嵌入效果图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1618401/201908/1618401-20190830001815211-942156445.png&quot; alt=&quot;&quot; width=&quot;890&quot; height=&quot;336&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 块嵌入和表嵌入其实显示的内容是一样的，知识显示样式不同而已。&lt;/p&gt;

</description>
<pubDate>Thu, 29 Aug 2019 16:26:00 +0000</pubDate>
<dc:creator>YifChan</dc:creator>
<og:description>Django之静态文件，中间件，admin后台管理；其中，静态文件 包括静态文件的使用，动态生成静态文件的路径；中间件包括 使用中间件，使用中间件防爬虫ip案例；admin后台管理 包括 admin的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yifchan/p/python-1-30.html</dc:identifier>
</item>
<item>
<title>Elasticsearch核心技术(1)--- Docker容器中运行ES、Kibana、Cerebro - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/11432112.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/11432112.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;想加强ES有关的知识，看了阮一鸣老师讲的《Elasticsearch核心技术与实战》收获很大，所以接下来会跟着他来更加深入的学习ES。&lt;/p&gt;
&lt;p&gt;这篇博客的目的就是&lt;code&gt;部署好ES和跟ES相关的辅助工具，同时通过Logstash将测试数据导入ES&lt;/code&gt;，这些工作完成之后，之后我们就可以在此基础上深入的去学习它。&lt;/p&gt;
&lt;h2 id=&quot;一docker容器中运行eskibanacerebro&quot;&gt;&lt;span&gt;一、Docker容器中运行ES,Kibana,Cerebro&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;所需环境&quot;&gt;1、所需环境&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;Docker + docker-compose&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先环境要部署好 &lt;code&gt;Docker&lt;/code&gt; 和 &lt;code&gt;docker-compose&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;检验是否成功&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令&lt;/strong&gt; &lt;code&gt;docker —version&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;xubdeMacBook-Pro:~ xub$ docker --version
Docker version 17.03.1-ce-rc1, build 3476dbf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;命令&lt;/strong&gt; &lt;code&gt;docker-compose —version&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;xubdeMacBook-Pro:~ xub$ docker-compose --version
docker-compose version 1.11.2, build dfed245&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;docker-compose.yml&quot;&gt;2、docker-compose.yml&lt;/h4&gt;
&lt;p&gt;我们可以简单把docker-compose.yml理解成一个类似Shell的脚本，这个脚本定义了运行多个容器应用程序的信息。&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;version: '2.2'
services:
  cerebro:
    image: lmenezes/cerebro:0.8.3
    container_name: cerebro
    ports:
      - &quot;9000:9000&quot;
    command:
      - -Dhosts.0.host=http://elasticsearch:9200
    networks:
      - es7net
  kibana:
    image: docker.elastic.co/kibana/kibana:7.1.0
    container_name: kibana7
    environment:
      - I18N_LOCALE=zh-CN
      - XPACK_GRAPH_ENABLED=true
      - TIMELION_ENABLED=true
      - XPACK_MONITORING_COLLECTION_ENABLED=&quot;true&quot;
    ports:
      - &quot;5601:5601&quot;
    networks:
      - es7net
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:7.1.0
    container_name: es7_01
    environment:
      - cluster.name=xiaoxiao
      - node.name=es7_01
      - bootstrap.memory_lock=true
      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;
      - discovery.seed_hosts=es7_01,es7_02
      - cluster.initial_master_nodes=es7_01,es7_02
    ulimits:
      memlock:
        soft: -1
        hard: -1
    volumes:
      - es7data1:/usr/share/elasticsearch/data
    ports:
      - 9200:9200
    networks:
      - es7net
  elasticsearch2:
    image: docker.elastic.co/elasticsearch/elasticsearch:7.1.0
    container_name: es7_02
    environment:
      - cluster.name=xiaoxiao
      - node.name=es7_02
      - bootstrap.memory_lock=true
      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;
      - discovery.seed_hosts=es7_01,es7_02
      - cluster.initial_master_nodes=es7_01,es7_02
    ulimits:
      memlock:
        soft: -1
        hard: -1
    volumes:
      - es7data2:/usr/share/elasticsearch/data
    networks:
      - es7net

volumes:
  es7data1:
    driver: local
  es7data2:
    driver: local

networks:
  es7net:
    driver: bridge&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker-compose up      #启动
docker-compose down    #停止容器
docker-compose down -v #停止容器并且移除数据&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;查看是否成功&quot;&gt;3、查看是否成功&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;es访问地址&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;localhost:9200  #ES默认端口为9200&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201908/1090617-20190829211410397-404455124.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;kibana访问地址&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;localhost:5601 #kibana默认端口5601&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201908/1090617-20190829211522044-1950731908.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cerebro访问地址&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;localhost:9000 #cerebro默认端口9000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201908/1090617-20190829230050305-1074367035.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;整体这样就安装成功了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;说明&lt;/code&gt; 项目是在Mac系统部署成功的,尝试在自己的阿里云服务进行部署但是因为内存太小始终无法成功。&lt;/p&gt;

&lt;h2 id=&quot;二-logstash安装与数据导入es&quot;&gt;&lt;span&gt;二、 Logstash安装与数据导入ES&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt; Logstash和kibana下载的版本要和你的elasticsearch的版本号一一致。&lt;/p&gt;
&lt;h4 id=&quot;配置movices.yml&quot;&gt;1、配置movices.yml&lt;/h4&gt;
&lt;p&gt;这个名称是完全任意的&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# input代表读取数据 这里读取数据的位置在data文件夹下，文件名称为movies.csv
input {
  file {
    path =&amp;gt; &quot;/Users/xub/opt/logstash-7.1.0/data/movies.csv&quot;
    start_position =&amp;gt; &quot;beginning&quot;
    sincedb_path =&amp;gt; &quot;/dev/null&quot;
  }
}
filter {
  csv {
    separator =&amp;gt; &quot;,&quot;
    columns =&amp;gt; [&quot;id&quot;,&quot;content&quot;,&quot;genre&quot;]
  }

  mutate {
    split =&amp;gt; { &quot;genre&quot; =&amp;gt; &quot;|&quot; }
    remove_field =&amp;gt; [&quot;path&quot;, &quot;host&quot;,&quot;@timestamp&quot;,&quot;message&quot;]
  }

  mutate {

    split =&amp;gt; [&quot;content&quot;, &quot;(&quot;]
    add_field =&amp;gt; { &quot;title&quot; =&amp;gt; &quot;%{[content][0]}&quot;}
    add_field =&amp;gt; { &quot;year&quot; =&amp;gt; &quot;%{[content][1]}&quot;}
  }

  mutate {
    convert =&amp;gt; {
      &quot;year&quot; =&amp;gt; &quot;integer&quot;
    }
    strip =&amp;gt; [&quot;title&quot;]
    remove_field =&amp;gt; [&quot;path&quot;, &quot;host&quot;,&quot;@timestamp&quot;,&quot;message&quot;,&quot;content&quot;]
  }

}
# 输入位置 这里输入数据到本地es ,并且索引名称为movies
output {
   elasticsearch {
     hosts =&amp;gt; &quot;http://localhost:9200&quot;
     index =&amp;gt; &quot;movies&quot;
     document_id =&amp;gt; &quot;%{id}&quot;
   }
  stdout {}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;启动命令&lt;/strong&gt; : 启动命令会和配置文件movices.yml的摆放位置有关，进入bin目录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./logstash ../movices.yml &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;movices.yml存放的位置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201908/1090617-20190829211811236-890093644.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;启动成功&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201908/1090617-20190829211819906-1388950755.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个时候你去cerebro可视化界面可以看到,已经有名称为&lt;code&gt;movies的索引&lt;/code&gt;存在的,上面的图片其实已经存在movies索引了，因为我是Logstash数据导入ES成功才截的图。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;总结&lt;/code&gt;总的来说这里还是简单的，之前通过Logstash将Mysql数据数据迁移到es会相对复杂点，毕竟它还需要一个数据库驱动包。&lt;/p&gt;
&lt;p&gt;这样环境就已经搭建成功了，接下来的学习都在这个的基础上进行演示。&lt;/p&gt;

&lt;h3 id=&quot;感谢&quot;&gt;&lt;span&gt;感谢&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://time.geekbang.org/course/intro/197&quot;&gt;Elasticsearch核心技术与实战---阮一鸣(eBay Pronto平台技术负责人)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;课程相关资料地址 ：&lt;a href=&quot;https://github.com/geektime-geekbang/geektime-ELK/tree/master/part-1/2.3-%E5%9C%A8Docker%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%BF%90%E8%A1%8CElasticsearch%2CKibana%E5%92%8CCerebro&quot;&gt;Github地址&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; 我相信，无论今后的道路多么坎坷，只要抓住今天，迟早会在奋斗中尝到人生的甘甜。抓住人生中的一分一秒，胜过虚度中的一月一年！(8）&lt;/code&gt;
&lt;/pre&gt;

</description>
<pubDate>Thu, 29 Aug 2019 15:15:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>Docker容器中运行ES,Kibana,Cerebro和Logstash安装与数据导入ES 想加强ES有关的知识，看了阮一鸣老师讲的《Elasticsearch核心技术与实战》收获很大，所以接下来会</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qdhxhz/p/11432112.html</dc:identifier>
</item>
</channel>
</rss>