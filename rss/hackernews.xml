<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=hnrss.org%2Fnewest%3Fpoints%3D200&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://hnrss.org/newest?points=200" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dhnrss.org%252Fnewest%253Fpoints%253D200%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dhnrss.org%252Fnewest%253Fpoints%253D200%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>Hacker News: Newest</title>
<link>https://news.ycombinator.com/newest</link>
<description>Hacker News RSS</description>
<item>
<title>Google Is Turning Off the Works-with-Nest API</title>
<link>https://nest.com/whats-happening/</link>
<guid isPermaLink="true" >https://nest.com/whats-happening/</guid>
<description>&lt;p&gt;Google will use your data as described in the Google &lt;a href=&quot;https://policies.google.com/privacy&quot; class=&quot;link&quot;&gt;Privacy Policy&lt;/a&gt; when you use any Nest or Google service, subject to the limitations explained below. Learn about Google’s commitment to privacy in the home &lt;a href=&quot;https://store.google.com/category/google_nest_privacy&quot; class=&quot;link&quot;&gt;here&lt;/a&gt;. You can manage your Google Account information, privacy, and security to make Google work better for you at myaccount.google.com.&lt;br/&gt;Here are some key details about how your Nest data will be managed if you migrate:&lt;/p&gt;
&lt;p class=&quot;list-heading&quot;&gt;Audio recordings and video footage from your Nest camera and Nest Hello video doorbell&lt;/p&gt;
&lt;p class=&quot;list-copy&quot;&gt;Google will use this data to provide and improve the camera features and services you agree to receive, and will not use this data for promotions or ad personalization. To review and delete your video history or your individual saved clips, follow the instructions &lt;a href=&quot;https://nest.com/support/article/Can-I-delete-my-Nest-Cam-Video-History&quot; class=&quot;link&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p class=&quot;list-heading&quot;&gt;Sensor readings collected from environmental and activity sensors&lt;/p&gt;
&lt;p class=&quot;list-copy&quot;&gt;Some of your Nest devices include sensors that detect information about your home’s environment and what’s happening in it, such as motion, whether or not someone is home, ambient light, temperature, and humidity. Google will not use sensor readings from your home environment for ad personalization. Google will use this data for other purposes as explained in the Google &lt;a href=&quot;https://policies.google.com/privacy&quot; class=&quot;link&quot;&gt;Privacy Policy&lt;/a&gt;, such as providing your Google services and experiences related to the connected home, improving and personalizing them and developing new ones, for maintaining safety and security, and for keeping you informed of relevant Google products, services, and updates. This data will not be available for you to review and delete in &lt;a href=&quot;https://myactivity.google.com/myactivity&quot; class=&quot;link&quot;&gt;My Activity&lt;/a&gt;, and turning off your Google &lt;a href=&quot;https://myaccount.google.com/activitycontrols&quot; class=&quot;link&quot;&gt;activity controls&lt;/a&gt; will not stop the collection or retention of this data for these more limited purposes, since these purposes relate to your core connected home devices and services experience. This data is deleted when you delete your account, subject to Google’s &lt;a href=&quot;https://policies.google.com/technologies/retention&quot; class=&quot;link&quot;&gt;account deletion practices&lt;/a&gt;.&lt;/p&gt;
&lt;p class=&quot;list-heading&quot;&gt;Google Assistant usage with Nest devices&lt;/p&gt;
&lt;p class=&quot;list-copy&quot;&gt;When you use your Nest device with the Google Assistant or other Works with Assistant programs, such as to explicitly control your devices and services using voice commands via the Assistant or the Home app (“Hey Google, set my temperature to 70 degrees”), these Assistant interactions can be used to show you relevant ads. Learn more in this &lt;a href=&quot;https://support.google.com/assistant/answer/7126196&quot; class=&quot;link&quot;&gt;Help Center article&lt;/a&gt;, which explains how the Assistant uses your interactions for personalized services and ads. You can review and delete your past Assistant queries at myactivity.google.com.&lt;/p&gt;
&lt;p class=&quot;list-heading&quot;&gt;Other device usage data&lt;/p&gt;
&lt;p class=&quot;list-copy&quot;&gt;When you are not interacting with Google services like the Assistant, your Nest device usage data (for example, when you manually adjust your thermostat’s temperature settings) will not be used for ad personalization. Google will use this data for other purposes as explained in the Google &lt;a href=&quot;https://policies.google.com/privacy&quot; class=&quot;link&quot;&gt;Privacy Policy&lt;/a&gt;, such as providing your Google services and experiences related to the connected home, improving and personalizing them and developing new ones, for maintaining safety and security, and for keeping you informed of relevant Google products, services, and updates. This data will not be available for you to review and delete in &lt;a href=&quot;https://myactivity.google.com/myactivity&quot; class=&quot;link&quot;&gt;My Activity&lt;/a&gt;, and turning off your Google &lt;a href=&quot;https://myaccount.google.com/activitycontrols&quot; class=&quot;link&quot;&gt;activity controls&lt;/a&gt; will not stop the collection or retention of this data for these more limited purposes, since these purposes relate to your core connected home devices and services experience. This data is deleted when you delete your account, subject to Google’s &lt;a href=&quot;https://policies.google.com/technologies/retention&quot; class=&quot;link&quot;&gt;account deletion practices&lt;/a&gt;.&lt;/p&gt;
&lt;p class=&quot;list-heading&quot;&gt;Location data collected by the Nest app&lt;/p&gt;
&lt;p class=&quot;list-copy&quot;&gt;Nest offers a Home/Away Assist feature that uses inputs from activity sensors in your Nest devices combined with your phone’s location (after you give permission) to automatically modify the behavior of your Nest devices when you leave or return home. Learn more about Home/Away Assist &lt;a href=&quot;https://nest.com/support/article/How-Home-Away-Assist-uses-your-phone-s-location#respects-privacy&quot; class=&quot;link&quot;&gt;here&lt;/a&gt;. You can turn off use of your phone’s location to inform Home/Away Assist in the Nest app at any time.&lt;br/&gt;If you migrate to a Google Account, your location established by the Location History setting in your Google Account is not used by Home/Away Assist, nor is your phone’s location data collected by the Nest app used to establish Location History in your Google Account.&lt;br/&gt;In the future, as we integrate Nest and Google location services to provide new features, we’ll be transparent and give you controls to manage your connected home information.&lt;/p&gt;
&lt;p class=&quot;list-heading&quot;&gt;Data collected from nest.com and its subdomains, including Nest’s online store&lt;/p&gt;
&lt;p class=&quot;list-copy&quot;&gt;The data collected from you when you use the public websites available at nest.com, nest.com subdomains, or Nest’s online store (including payment information and transaction history) will be associated with your Google Account and handled for the purposes set out in the Google &lt;a href=&quot;https://policies.google.com/privacy&quot; class=&quot;link&quot;&gt;Privacy Policy&lt;/a&gt;. You can manage your Google settings to limit how Google uses this data.&lt;/p&gt;
&lt;p class=&quot;list-heading&quot;&gt;Other data, such as basic device and technical data&lt;/p&gt;
&lt;p class=&quot;list-copy&quot;&gt;Any other Nest data, such as basic device data like device name, type and attributes, and technical device data like device serial number; IP and MAC address; device hardware and software information; Wi-Fi, network connectivity and settings information; and battery, diagnostics, crash, and performance information; is handled for the purposes set out in the Google &lt;a href=&quot;https://policies.google.com/privacy&quot; class=&quot;link&quot;&gt;Privacy Policy&lt;/a&gt;, including to troubleshoot and make your connected home services and experiences better and more reliable. You can manage your Google settings to limit how Google uses this data.&lt;/p&gt;
&lt;p&gt;We’re always working on new ways to improve how you experience Google services. We’ll keep you updated on new experiences and product integrations Google offers, and if we change how your information is used, we’ll be transparent and give you controls to manage your connected home information.&lt;/p&gt;
</description>
<pubDate>Tue, 07 May 2019 23:21:35 +0000</pubDate>
<dc:creator>cek</dc:creator>
<og:type>website</og:type>
<og:url>https://www.nest.com/whats-happening/</og:url>
<og:title>What’s happening at Nest?</og:title>
<og:image>https://nest.com/images/social/nest_default_share_icon.jpg</og:image>
<og:description>Learn about Google Nest, account changes, Works with Nest and more</og:description>
<dc:language>en-US</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://nest.com/whats-happening/</dc:identifier>
</item>
<item>
<title>Flutter: a Portable UI Framework for Mobile, Web, Embedded, and Desktop</title>
<link>https://developers.googleblog.com/2019/05/Flutter-io19.html</link>
<guid isPermaLink="true" >https://developers.googleblog.com/2019/05/Flutter-io19.html</guid>
<description>&lt;noscript&gt;

&lt;p&gt;&lt;em&gt;Posted by the Flutter Team&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Today marks an important milestone for the &lt;a href=&quot;https://flutter.dev/&quot;&gt;Flutter framework&lt;/a&gt;, as we expand our focus from mobile to incorporate a broader set of devices and form factors. At I/O, we’re releasing our first technical preview of &lt;a href=&quot;https://flutter.dev/web&quot;&gt;Flutter for web&lt;/a&gt;, announcing that Flutter is powering Google’s smart display platform including the Google Home Hub, and delivering our first steps towards supporting desktop-class apps with Chrome OS.&lt;/p&gt;
&lt;h2&gt;From Mobile to Multi-Platform&lt;/h2&gt;
&lt;p&gt;For a long time, the Flutter team mission has been to build the best framework for developing mobile apps for iOS and Android. We believe that mobile development is ripe for improvement, with developers today forced to choose between building the same app twice for two platforms, or making compromises to use cross-platform frameworks. Flutter hits the sweet spot of enabling a single codebase to deliver beautiful, fast, tailored experiences with high developer productivity for both platforms, and we’ve been excited to see how our early efforts have flourished into one of the &lt;a href=&quot;https://github.com/flutter/flutter&quot;&gt;most popular open source projects&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;As we started to home in on &lt;a href=&quot;https://developers.googleblog.com/2018/12/flutter-10-googles-portable-ui-toolkit.html&quot;&gt;our 1.0 release last year&lt;/a&gt;, we began experimenting with broadening the scope of Flutter to other platforms. This was triggered both by internal teams within Google who are increasingly relying on Flutter, as well as the latent potential of the &lt;a href=&quot;https://dart.dev&quot;&gt;Dart platform&lt;/a&gt; for delivering portable experiences. In particular, a small team who were already building a web framework for Dart for internal usage started an exploratory project (codename “Hummingbird”) to evaluate the technical merits of porting the Flutter engine to support the standards-based web.&lt;/p&gt;
&lt;p&gt;The results of this project were startling, thanks in large part to the rapid progress in web browsers like Chrome, Firefox, and Safari, which have pervasively delivered hardware-accelerated graphics, animation, and text as well as fast JavaScript execution. Within a few months of beginning the project, we had the core Flutter framework primitives working, and soon after we had demos running on mobile and desktop browsers. Along with Dart’s long pedigree of compiling for the web, this proved that we could also bring the Flutter framework and apps to run on the web.&lt;/p&gt;
&lt;p&gt;In parallel, the core Flutter project has been making progress to enable desktop-class apps, with input paradigms such as keyboard and mouse, window resizing, and tooling for Chrome OS app development. The exploratory work that we did for embedding Flutter into desktop-class apps running on Windows, Mac and Linux has also graduated into the core Flutter engine.&lt;/p&gt;
&lt;h2&gt;A Portable UI Framework for All Screens&lt;/h2&gt;
&lt;a href=&quot;https://1.bp.blogspot.com/-ak_aEW48mmA/XNCDH1UYfaI/AAAAAAAAHeg/NUhgwcoZX2Ei7exfQreLRSmOfPtxdCReQCLcBGAs/s1600/image2.png&quot; imageanchor=&quot;1&quot;&gt;&lt;img alt=&quot;Flutter Mobile, Web, Desktop, and Embedded&quot; border=&quot;0&quot; data-original-height=&quot;895&quot; data-original-width=&quot;1600&quot; id=&quot;imgFull&quot; src=&quot;https://1.bp.blogspot.com/-ak_aEW48mmA/XNCDH1UYfaI/AAAAAAAAHeg/NUhgwcoZX2Ei7exfQreLRSmOfPtxdCReQCLcBGAs/s1600/image2.png&quot;/&gt;&lt;/a&gt;
&lt;p&gt;It’s worth pausing for a moment to acknowledge the business potential of a high-performance, portable UI framework that can deliver beautiful, tailored experiences to such a broad variety of form factors from a single codebase.&lt;/p&gt;
&lt;p&gt;For startups, the ability to reach users on mobile, web, or desktop through the same app lets them reach their full audience from day one, rather than having limits due to technical considerations. Especially for larger organizations, the ability to deliver the same experience to all users with one codebase reduces complexity and development cost, and lets them focus on improving the quality of that experience.&lt;/p&gt;
&lt;p&gt;With support for mobile, desktop, and web apps, our mission expands: we want to build &lt;strong&gt;the best framework for developing beautiful experiences for &lt;em&gt;any&lt;/em&gt; screen&lt;/strong&gt;.&lt;/p&gt;
&lt;h2&gt;Flutter for Web&lt;/h2&gt;
&lt;p&gt;This week, we are releasing the &lt;strong&gt;first technical preview of Flutter for the web&lt;/strong&gt;. While this technology is still in development, we are ready for early adopters to try it out and give us feedback. Our initial vision for Flutter on the web is not as a general purpose replacement for the document experiences that HTML is optimized for; instead we intend it as a great way to build highly interactive, graphically rich content, where the benefits of a sophisticated UI framework are keenly felt.&lt;/p&gt;
&lt;p&gt;To showcase Flutter for the web, we worked with the New York Times to build a demo. In addition to world-class news coverage, the New York Times is famous for its crossword and other puzzle games. Since avid puzzlers want to play on whatever device they’re using at the time, their development team was attracted to Flutter as a potential solution for their needs. Discovering that they could reach the web with the same code was a huge boon. At Google I/O this week, you can get a sneak peek of their &lt;a href=&quot;https://www.nytimes.com/games/prototype/kenken&quot;&gt;newly refreshed KENKEN puzzle game&lt;/a&gt;, which runs with the same code on Android, iOS, web, Mac, and Chrome OS.&lt;/p&gt;
&lt;a href=&quot;https://3.bp.blogspot.com/-e1IGVi16-Qo/XNGnZNzvKeI/AAAAAAAAHgo/D1mP3-JAzY4xJVB6ZFuD8PXvmWUcymwLQCLcBGAs/s1600/gif%2B%25282%2529.gif&quot; imageanchor=&quot;1&quot;&gt;&lt;img alt=&quot;ken-gratulations puzzle&quot; border=&quot;0&quot; data-original-height=&quot;732&quot; data-original-width=&quot;1256&quot; id=&quot;imgFull&quot; src=&quot;https://3.bp.blogspot.com/-e1IGVi16-Qo/XNGnZNzvKeI/AAAAAAAAHgo/D1mP3-JAzY4xJVB6ZFuD8PXvmWUcymwLQCLcBGAs/s1600/gif%2B%25282%2529.gif&quot;/&gt;&lt;/a&gt;
&lt;p&gt;Here’s what Eric von Coelln, Executive Director of Puzzles at the New York Times has to say about their experiences with Flutter:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&quot;The New York Times Crossword has more than 400,000 stand-alone subscriptions and is a daily ritual for puzzle solvers. Along with the Crossword, we’ve grown our portfolio of digital puzzles that reaches more than two million solvers each month.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;We were already beginning to explore Flutter as a potential solution to the challenge of quickly developing engaging, high-quality mobile experiences. Now the addition of being able to publish to web makes Flutter an even more appealing option to quickly deploy across all of our user platforms. This update of our old Flash-based KenKen game into a multi-platform playable experience is something we’re excited to bring to our solvers this year.”&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;There’s lots more to say about Flutter for web than we have space for here, so check out the dedicated &lt;a href=&quot;https://medium.com/flutter-io/bringing-flutter-to-the-web-904de05f0df0&quot;&gt;article about Flutter for web&lt;/a&gt; on the Flutter blog.&lt;/p&gt;
&lt;p&gt;At this early stage, we’re eager to get your feedback on how you’d like to use Flutter for web. We expect to rapidly evolve the code, with a particular focus on performance, and harmonizing the codebase with the rest of the Flutter project.&lt;/p&gt;
&lt;h2&gt;Flutter for Mobile Devices&lt;/h2&gt;
&lt;p&gt;The core Flutter framework also receives an upgrade this week, with the &lt;strong&gt;immediate availability of Flutter 1.5&lt;/strong&gt; in our stable channel. &lt;a href=&quot;https://medium.com/flutter-io/announcing-flutter-1-5-6e5d7e35b75f&quot;&gt;Flutter 1.5&lt;/a&gt; includes hundreds of changes in response to developer feedback, including updates for new App Store iOS SDK requirements, updates to the iOS and Material widgets, engine support for new device types, and Dart 2.3 featuring new &lt;a href=&quot;https://medium.com/dartlang/making-dart-a-better-language-for-ui-f1ccaf9f546c&quot;&gt;UI-as-code&lt;/a&gt; language features.&lt;/p&gt;
&lt;p&gt;As the framework itself matures, we’re investing in building out the supporting ecosystem. The architectural model of Flutter has always prioritized a small core framework, supplemented by a rich package community. In the last few months, Google has contributed production-quality packages for web views, Google Maps, and Firebase ML Vision, and this week, we’re adding &lt;a href=&quot;https://medium.com/r/?url=https%3A%2F%2Fpub.dartlang.org%2Fpackages%2Fin_app_purchase&quot;&gt;initial support for in-app payments&lt;/a&gt;. And with over 2,000 open source packages available for Flutter, there are options available for most scenarios.&lt;/p&gt;
&lt;p&gt;One particularly exciting project that we’re announcing this week at I/O is the &lt;a href=&quot;http://github.com/firebase/mlkit-custom-image-classifier&quot;&gt;ML Kit Custom Image Classifier&lt;/a&gt;. Built using Flutter and Firebase, it offers an easy-to-use app-based workflow for creating custom image classification models. You can collect training data using the phone's camera, invite others to contribute to your datasets, trigger model training, and use trained models, all from the same app.&lt;/p&gt;
&lt;a href=&quot;https://3.bp.blogspot.com/-B6k0eVGGeMs/XNCDm5FcODI/AAAAAAAAHes/POhYABZ-M_YSzsCVVIzfcE-zlQrfWwW5QCLcBGAs/s1600/image3.png&quot; imageanchor=&quot;1&quot;&gt;&lt;img alt=&quot;Flutter ML Kit: create datasets, collaborate to collect data, train model, run inference&quot; border=&quot;0&quot; data-original-height=&quot;827&quot; data-original-width=&quot;1600&quot; id=&quot;imgFull&quot; src=&quot;https://3.bp.blogspot.com/-B6k0eVGGeMs/XNCDm5FcODI/AAAAAAAAHes/POhYABZ-M_YSzsCVVIzfcE-zlQrfWwW5QCLcBGAs/s1600/image3.png&quot;/&gt;&lt;/a&gt;
&lt;p&gt;Flutter continues to grow in popularity and adoption. A &lt;a href=&quot;https://flutter.dev/showcase&quot;&gt;growing roster of demanding customers&lt;/a&gt; including eBay, Sonos, Square, Capital One, Alibaba and Tencent are developing apps with Flutter. And they’re having fun! Here’s what Larry McKenzie, a senior developer at eBay had to say about Flutter:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;“Flutter is fast! Features that once took us multiple days to implement can be finished in a single day. Many problems we used to spend a lot of time on, simply no longer occur. Our team can now focus on creating more polished user experiences and delivering functionality. Flutter is enabling us to exceed expectations!”&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;More broadly, &lt;a href=&quot;https://learning.linkedin.com/blog/tech-tips/the-fastest-growing-skills-among-software-engineers--and-how-to-&quot;&gt;LinkedIn recently conducted a study&lt;/a&gt; that showed &lt;strong&gt;Flutter is the single fastest-growing skill among software engineers&lt;/strong&gt;, based on site members claiming it on their profile over the last 12 months. And in the recent 2019 StackOverflow developer survey, &lt;a href=&quot;https://insights.stackoverflow.com/survey/2019#technology-_-most-loved-dreaded-and-wanted-other-frameworks-libraries-and-tools&quot;&gt;Flutter was listed as one of the most-loved developer frameworks&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Flutter for Desktop&lt;/h2&gt;
&lt;p&gt;Flutter is also being used on the desktop. For some months, we’ve been working on the desktop as &lt;a href=&quot;https://github.com/google/flutter-desktop-embedding&quot;&gt;an experimental project&lt;/a&gt;. But now we’re graduating this into Flutter engine, integrating this work directly into the mainline repo. While these targets are not production-ready yet, we have published early &lt;a href=&quot;https://github.com/flutter/flutter/wiki/Desktop-shells&quot;&gt;instructions for developing Flutter apps to run on Mac, Windows, and Linux&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Another quickly growing Flutter platform is Chrome OS, with millions of Chromebooks being sold every year, particularly in education. Chrome OS is a perfect environment for Flutter, both for running Flutter apps, and as a developer platform, since it supports execution of both Android and Linux apps. With Chrome OS, you can use Visual Studio Code or Android Studio to develop a Flutter app that you can test and run locally on the same device without an emulator. You can also publish Flutter apps for Chrome OS to the Play Store, where millions of others can benefit from your creation.&lt;/p&gt;
&lt;h2&gt;Flutter for Embedded Devices&lt;/h2&gt;
&lt;p&gt;As the final example of Flutter’s portability, we offer Flutter embedded on other devices. We recently published &lt;a href=&quot;https://medium.com/flutter-io/flutter-on-raspberry-pi-mostly-from-scratch-2824c5e7dcb1&quot;&gt;samples&lt;/a&gt; that demonstrate Flutter running directly on smaller-scale devices like Raspberry Pi, and we offer an &lt;a href=&quot;https://github.com/flutter/flutter/wiki/Custom-Flutter-Engine-Embedders&quot;&gt;embedding API for Flutter&lt;/a&gt; that allows it to be used in scenarios including home, automotive and beyond.&lt;/p&gt;
&lt;p&gt;Perhaps one of the most pervasive embedded platforms where Flutter is already running is on the smart display operating system that powers the likes of Google Home Hub.&lt;/p&gt;
&lt;a href=&quot;https://1.bp.blogspot.com/-bjyxSBa7HaA/XNCEFNpv2wI/AAAAAAAAHe4/YrVDngeN7fQoEKlzkAEA3JCs8lWSFHdpwCLcBGAs/s1600/image1.png&quot; imageanchor=&quot;1&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;897&quot; data-original-width=&quot;1119&quot; id=&quot;imgHalf&quot; src=&quot;https://1.bp.blogspot.com/-bjyxSBa7HaA/XNCEFNpv2wI/AAAAAAAAHe4/YrVDngeN7fQoEKlzkAEA3JCs8lWSFHdpwCLcBGAs/s1600/image1.png&quot;/&gt;&lt;/a&gt;
&lt;p&gt;Within Google, some Google-built features for the Smart Display platform are powered by Flutter today. And the Assistant team is excited to continue to expand the portfolio of features built with Flutter for the Smart Display in the coming months; the goal this year is to use Flutter to drive the overall system UI.&lt;/p&gt;
&lt;h2&gt;Other Resources&lt;/h2&gt;
&lt;p&gt;We often get asked by developers how they can get started with Flutter. We are pleased today to &lt;a href=&quot;https://www.appbrewery.co/p/flutter-development-bootcamp-with-dart/&quot;&gt;announce a comprehensive new training course for Flutter&lt;/a&gt;, built by &lt;a href=&quot;https://www.appbrewery.co/&quot;&gt;The App Brewery&lt;/a&gt;, authors of the highest-rated iOS training course on Udemy. Their new course has over thirty hours of content for Flutter, including videos, demos and labs, and with Google’s sponsorship, they are announcing today a time-limited discount of this course from the retail price of $199 to just $10.&lt;/p&gt;
&lt;p&gt;Many developers are creating inspiring apps with Flutter. In the run-up to Google I/O, we ran a contest called Flutter Create to encourage developers to see what they could build with Flutter in 5KB or less of Dart code. We had over 750 unique entries from around the world, with some amazing examples that pushed what we imagine would be possible in such a small size.&lt;/p&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/WLvpROMUjYQ&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;[embedded content]&lt;/iframe&gt;
&lt;p&gt;Today, we’re announcing the winners, which can be found on &lt;a href=&quot;https://flutter.dev/create&quot;&gt;flutter.dev/create&lt;/a&gt;. Congratulations to the overall winner, Zebiao Hu, who wins a fully-loaded iMac Pro worth over $10,000!&lt;/p&gt;
&lt;p&gt;Flutter is no longer a mobile framework, but a &lt;a href=&quot;https://youtu.be/5VbAwhBBHsg&quot;&gt;multi-platform framework&lt;/a&gt; that can help you reach your users wherever they are. We can’t wait to see what you’ll build with Flutter on the web, desktop, mobile, and beyond!&lt;/p&gt;
&lt;/noscript&gt;</description>
<pubDate>Tue, 07 May 2019 20:40:04 +0000</pubDate>
<dc:creator>mikece</dc:creator>
<og:type>article</og:type>
<og:title>Flutter: a Portable UI Framework for Mobile, Web, Embedded, and Desktop</og:title>
<og:image>https://1.bp.blogspot.com/-ak_aEW48mmA/XNCDH1UYfaI/AAAAAAAAHeg/NUhgwcoZX2Ei7exfQreLRSmOfPtxdCReQCLcBGAs/s1600/image2.png</og:image>
<og:description>Today marks an important milestone for the Flutter framework, as we expand our focus from mobile to incorporate a broader set of devices and form factors. At I/O, we’re releasing our first technical preview of Flutter for web, announcing that Flutter is powering Google’s smart display platform including the Google Home Hub, and delivering our first steps towards supporting desktop-class apps with Chrome OS.</og:description>
<og:url>https://developers.googleblog.com/2019/05/Flutter-io19.html</og:url>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://developers.googleblog.com/2019/05/Flutter-io19.html</dc:identifier>
</item>
<item>
<title>Pixel 3a</title>
<link>https://blog.google/products/pixel/io-pixel-3a/</link>
<guid isPermaLink="true" >https://blog.google/products/pixel/io-pixel-3a/</guid>
<description>&lt;h3&gt;Buy it from more places, use it on more networks&lt;/h3&gt;
&lt;p&gt;Pixel 3a and Pixel 3 are now available through more carriers, including Verizon, T-Mobile, Sprint, US Cellular, Spectrum Mobile (Charter), C Spire and Google Fi, as well as being supported on AT&amp;amp;T. If you’re new to Pixel, you can transfer photos, music and media quickly with the included Quick Switch Adapter. If you need a little extra help, 24/7 support from Google is just a tap away in the tips and support link in the settings menu. You can even share your screen for guided assistance.  &lt;br/&gt;&lt;/p&gt;
&lt;p&gt;Look for Pixel 3a in the &lt;a href=&quot;https://g.co/92jj5h&quot;&gt;Google Store&lt;/a&gt; in countries where Pixel is sold beginning today, and through our partners beginning tomorrow. &lt;/p&gt;
&lt;p&gt;&lt;sup&gt;1&lt;/sup&gt; &lt;sub&gt;Approximate battery life based on a mix of talk, data, standby, mobile hotspot and use of other features, with always on display off. An active display or data usage will decrease battery life. Charging rates are based upon use of the included charger. Charging time performance statistics are approximate. Actual results may vary.&lt;/sub&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 07 May 2019 19:19:11 +0000</pubDate>
<dc:creator>vanilla_nut</dc:creator>
<og:type>article</og:type>
<og:title>Pixel 3a: the helpful (and more affordable) phone by Google</og:title>
<og:description>A phone from Google that helps you get more done. It has everything you need in a phone, and a camera that you’ll love.</og:description>
<og:image>https://storage.googleapis.com/gweb-uniblog-publish-prod/images/Pixel3A-hero.max-1300x1300.jpg</og:image>
<og:url>https://www.blog.google/products/pixel/io-pixel-3a/</og:url>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://blog.google/products/pixel/io-pixel-3a/</dc:identifier>
</item>
<item>
<title>Css-only-chat: A truly monstrous async web chat using no JS on the front end</title>
<link>https://github.com/kkuchta/css-only-chat</link>
<guid isPermaLink="true" >https://github.com/kkuchta/css-only-chat</guid>
<description>&lt;div class=&quot;Box-body&quot;&gt;
&lt;article class=&quot;markdown-body entry-content p-5&quot; itemprop=&quot;text&quot;&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://camo.githubusercontent.com/351e844d827387206d272a9781bee8b0baa5458a/68747470733a2f2f6d656469612e67697068792e636f6d2f6d656469612f64576b78415a5467394e6241687652714f652f67697068792e676966&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/351e844d827387206d272a9781bee8b0baa5458a/68747470733a2f2f6d656469612e67697068792e636f6d2f6d656469612f64576b78415a5467394e6241687652714f652f67697068792e676966&quot; alt=&quot;&quot; data-canonical-src=&quot;https://media.giphy.com/media/dWkxAZTg9NbAhvRqOe/giphy.gif&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A truly monstrous async web chat using no JS whatsoever on the frontend.&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://camo.githubusercontent.com/cc225eb13b645b00744c19995f7ff66a7c74f315/68747470733a2f2f6d656469612e67697068792e636f6d2f6d656469612f6d43436c5353367862693875732f67697068792e676966&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/cc225eb13b645b00744c19995f7ff66a7c74f315/68747470733a2f2f6d656469612e67697068792e636f6d2f6d656469612f6d43436c5353367862693875732f67697068792e676966&quot; alt=&quot;&quot; data-canonical-src=&quot;https://media.giphy.com/media/mCClSS6xbi8us/giphy.gif&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This is an asynchronous chat that sends + receives messages in the browser with no reloads and no javascript.&lt;/p&gt;
&lt;h2&gt;Ok so how&lt;/h2&gt;
&lt;p&gt;Background-images loaded via pseudoselectors + a forever-loading index page (remember &lt;a href=&quot;https://en.wikipedia.org/wiki/Comet_(programming)&quot; rel=&quot;nofollow&quot;&gt;Comet&lt;/a&gt;?).&lt;/p&gt;
&lt;h2&gt;Say that again?&lt;/h2&gt;
&lt;p&gt;Ok, so there are two things we need the browser to do: send data and receive data. Let's start with the first.&lt;/p&gt;
&lt;h3&gt;Sending Data&lt;/h3&gt;
&lt;p&gt;CSS is really limited in what it can do. However, we &lt;em&gt;can&lt;/em&gt; use it to effectively detect button presses:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.some-button:active {
  background-image: url('some_image.jpg')
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;What's cool is that a browser won't actually load that background image until this selector is used - that is, when this button is pressed. So now we have a way to trigger a request to a server of our choice on a button press. That sounds like data sending!&lt;/p&gt;
&lt;p&gt;Now, of course, this only works once per button (since a browser won't try to load that image twice), but it's a start.&lt;/p&gt;
&lt;h3&gt;Receiving Data&lt;/h3&gt;
&lt;p&gt;Since we can't use JS, it's really hard to change a page after it's already been loaded. But it &lt;em&gt;is&lt;/em&gt; possible.&lt;/p&gt;
&lt;p&gt;Back before websockets were widly supported, we had to use clever hacks if we wanted to push data from a server to a client in an ongoing basis. One such hack was just to make the page never finish loading. It turns out that you can tell the browser to start rendering a page before it's finished loading (using the &lt;code&gt;Transfer-Encoding: chunked&lt;/code&gt; http header). And when you do that, you don't &lt;em&gt;actually&lt;/em&gt; have to stop loading the page. You can just keep adding stuff to the bottom of the html forever, at whatever rate you want.&lt;/p&gt;
&lt;p&gt;So, for example, you could start sending a normal html page, then just stop sending html (while still telling the client you're sending) until you're ready to deliver another message.&lt;/p&gt;
&lt;p&gt;Now, all this lets us do is periodically append html to the page. What can we do with that? How about, when you load the index page, this happens:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;We load up the first pile of html we want to show. A welcome message, etc.&lt;/li&gt;
&lt;li&gt;We stop loading html for a while until we want to send some sort of update.&lt;/li&gt;
&lt;li&gt;Now we load up a &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; element that &lt;code&gt;display: none&lt;/code&gt;'s all the previous html&lt;/li&gt;
&lt;li&gt;Then we load up whatever &lt;em&gt;new&lt;/em&gt; html we want to show&lt;/li&gt;
&lt;li&gt;Finially we wait until the next update we want to send and GOTO 3.&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;Single-use buttons?&lt;/h3&gt;
&lt;p&gt;Ok, so we have that problem earlier where each button is only single-use. It tries to send a get request one, then never will again.&lt;/p&gt;
&lt;p&gt;Thankfully, our method of receiving data fixes that for us. Here's what happens:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;We show an &quot;a&quot; button whose background image is like &quot;img/a&quot;.&lt;/li&gt;
&lt;li&gt;When you press it, the server receives the image request for &quot;a&quot;&lt;/li&gt;
&lt;li&gt;The server then pushes an update to the client to hide the current button and replace it with one whose background images is &quot;image/aa&quot;.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;If the buttons you pressed were &quot;h&quot;, &quot;e&quot;, and &quot;l&quot;, then the &quot;a&quot; button's background image url would be &quot;img/hela&quot;. And since we're replacing all buttons every time you press one, the single-use button problem goes away!&lt;/p&gt;
&lt;h3&gt;Misc other details&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;We actually encode a bit more info into the button urls (like each client's id)&lt;/li&gt;
&lt;li&gt;Because the data-sending and data-receiving happens on different threads, we need inter-thread communication. That sounds like work, so we'll just use Redis pubsub for that.&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;FAQ&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;What inspired this?&lt;/strong&gt; Chernobyl, Hindenburg, The Tacoma Narrows Bridge...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Really?&lt;/strong&gt; No, it was this &lt;a href=&quot;https://twitter.com/davywtf/status/1124130932573839360&quot; rel=&quot;nofollow&quot;&gt;clever tweet&lt;/a&gt; by davywtf.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Why's your code suck&lt;/strong&gt; Why do &lt;em&gt;you&lt;/em&gt; suck?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;No but really&lt;/strong&gt; Because I was mostly making this up as I went. There's a lot of exploratory coding here that I only minimally cleaned up. If I rebuilt it I'd store the UI state for a client in redis and just push it out in its entirety when needed via a single generic screen-updating mechanism.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;What could go wrong with this technique?&lt;/strong&gt; Broken by browser bg-image handling changes; long-request timeouts; running out of threads; fast-clicking bugs; generic concurrency headaches; poor handling by proxies; it's crazy inaccessible; etc etc&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Should I use this in real life?&lt;/strong&gt; Dear god yes.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I have an idea for how this could be made better/worse/hackier&lt;/strong&gt; &lt;a href=&quot;https://twitter.com/kkuchta&quot; rel=&quot;nofollow&quot;&gt;Tweet at me (@kkuchta)&lt;/a&gt;. I'm always down to see a terrible idea taken futher!&lt;/p&gt;
&lt;/article&gt;&lt;/div&gt;
</description>
<pubDate>Tue, 07 May 2019 18:27:42 +0000</pubDate>
<dc:creator>bennylope</dc:creator>
<og:image>https://avatars0.githubusercontent.com/u/820965?s=400&amp;v=4</og:image>
<og:type>object</og:type>
<og:title>kkuchta/css-only-chat</og:title>
<og:url>https://github.com/kkuchta/css-only-chat</og:url>
<og:description>A truly monstrous async web chat using no JS whatsoever on the frontend - kkuchta/css-only-chat</og:description>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://github.com/kkuchta/css-only-chat</dc:identifier>
</item>
<item>
<title>Mathics – A free, light-weight alternative to Mathematica</title>
<link>https://mathics.github.io/</link>
<guid isPermaLink="true" >https://mathics.github.io/</guid>
<description>&lt;p&gt;Mathics is a free, general-purpose online computer algebra system featuring Mathematica-compatible syntax and functions. It is backed by highly extensible Python code, relying on &lt;a href=&quot;http://sympy.org/&quot;&gt;SymPy&lt;/a&gt; for most mathematical tasks.&lt;/p&gt;
&lt;h2&gt;Use Mathics online&lt;/h2&gt;
&lt;p&gt;Mirrors:&lt;/p&gt;
&lt;h2&gt;Download and install Mathics&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mathics/Mathics/releases/latest&quot;&gt;Download&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mathics/Mathics/wiki/Installing&quot;&gt;Installation guide&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Documentation&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://mathics.angusgriffith.com/doc/&quot;&gt;Browse online&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mathics.github.io/docs/mathics-1.0.pdf&quot;&gt;Download PDF&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Support&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mathics/Mathics/issues&quot;&gt;Report a bug&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Use the Google groups &lt;a href=&quot;https://groups.google.com/forum/#!forum/mathics-users&quot;&gt;mathics-users&lt;/a&gt; for discussions regarding using Mathics and &lt;a href=&quot;https://groups.google.com/forum/#!forum/mathics-devel&quot;&gt;mathics-devel&lt;/a&gt; for discussions about development.&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Wanted&lt;/strong&gt;: Developers! Please get in touch if you want to be part of this awesome project.&lt;/p&gt;
</description>
<pubDate>Tue, 07 May 2019 18:09:46 +0000</pubDate>
<dc:creator>dvfjsdhgfv</dc:creator>
<dc:format>text/html</dc:format>
<dc:identifier>https://mathics.github.io/</dc:identifier>
</item>
<item>
<title>The Amazing $1 Microcontroller (2017)</title>
<link>https://jaycarlson.net/microcontrollers/</link>
<guid isPermaLink="true" >https://jaycarlson.net/microcontrollers/</guid>
<description>&lt;div id=&quot;vc_row-5cd272d485ae8&quot; class=&quot;vc_row wpb_row vc_row-fluid&quot;&gt;
&lt;div class=&quot;wpb_column vc_column_container vc_col-sm-12&quot;&gt;
&lt;div class=&quot;vc_column-inner&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;
&lt;div class=&quot;wpb_text_column wpb_content_element&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;
&lt;p&gt;As an embedded design consultant, the diverse collection of projects on my desk need an equally-diverse collection of microcontroller architectures that have the performance, peripheral selection, and power numbers to be the backbone of successful projects. At the same time, we all have our go-to chips — those parts that linger in our toolkit after being picked up in school, through forum posts, or from previous projects.&lt;/p&gt;
&lt;p&gt;In 2017, we saw several new MCUs hit the market, as well as general trends continuing in the industry: the migration to open-source, cross-platform development environments and toolchains; new code-generator tools that integrate seamlessly (or not so seamlessly…) into IDEs; and, most notably, the continued invasion of ARM Cortex-M0+ parts into the 8-bit space.&lt;/p&gt;
&lt;p&gt;I wanted to take a quick pulse of the industry to see where everything is — and what I’ve been missing while backed into my corner of DigiKey’s web site.&lt;/p&gt;
&lt;p&gt;It’s time for a good ol’ microcontroller shoot-out.&lt;/p&gt;

&lt;p&gt;While some projects that come across my desk are complex enough to require a hundreds-of-MHz microcontroller with all the bells and whistles, it’s amazing how many projects work great using nothing more than a $1 chip — so this is the only rule I established for this microcontroller review. &lt;sup id=&quot;footnote_plugin_tooltip_1&quot; class=&quot;footnote_plugin_tooltip_text&quot; onclick=&quot;footnote_moveToAnchor('footnote_plugin_reference_1');&quot;&gt;1&lt;/sup&gt;&lt;span class=&quot;footnote_tooltip&quot; id=&quot;footnote_plugin_tooltip_text_1&quot;&gt;To get technical: I purchased several different MCUs — all less than a $1 — from a wide variety of brands and distributors. I’m sure people will chime in and either claim that a part is more than a dollar, or that I should have used another part which can be had for less than a dollar. I used a price-break of 100 units when determining pricing, and I looked at typical, general suppliers I personally use when shopping for parts — I avoided eBay/AliExpress/Taobao unless they were the only source for the parts, which is common for devices most popular in China and Taiwan.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;I wanted to explore the $1 pricing zone specifically because it’s the least amount of money you can spend on an MCU that’s still general-purpose enough to be widely useful in a diverse array of projects.&lt;/p&gt;
&lt;p&gt;Any cheaper, and you end up with 6- or 8-pin parts with only a few dozen bytes of RAM, no ADC, nor any peripherals other than a single timer and some GPIO.&lt;/p&gt;
&lt;p&gt;Any more expensive, and the field completely opens up to an overwhelming number of parts — all with heavily-specialized peripherals and connectivity options.&lt;/p&gt;
&lt;p&gt;These MCUs were selected to represent their entire families — or sub-families, depending on the architecture — and in my analysis, I’ll offer some information about the family as a whole.&lt;/p&gt;
&lt;p&gt;If you want to scroll down and find out who the winner is, don’t bother — there’s really no sense in trying to declare the “king of $1 MCUs” as everyone knows the best microcontroller is the one that best matches your application needs. I mean, everyone knows the best microcontroller is the one you already know how to use. No, wait — the best microcontroller is definitely the one that is easiest to prototype with. Or maybe that has the lowest impact on BOM pricing?&lt;/p&gt;
&lt;p&gt;I can’t even decide on the criteria for the best microcontroller — let alone crown a winner.&lt;/p&gt;
&lt;p&gt;What I will do, however, is offer a ton of different recommendations for different users at the end. Read on!&lt;/p&gt;

&lt;p&gt;This microcontroller selection guide will have both qualitative and quantitative assessments. Overall, I’ll be looking at a few different categories:&lt;/p&gt;
&lt;h2&gt;Parametrics, Packaging, and Peripherals&lt;/h2&gt;
&lt;p&gt;Within a particular family, what is the range of core speed? Memory? Peripherals? Price? Package options?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Some microcontroller families are huge&lt;/strong&gt; — with hundreds of different models that you can select from to find the perfect MCU for your application. Some families are much smaller, which means you’re essentially going to pay for peripherals, memory, or features you don’t need. But these have an economies-of-scale effect; if we only have to produce five different MCU models, we’ll be able to make a lot more of each of them, driving down the price. How do different MCU families end up on that spectrum?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Package availability&lt;/strong&gt; is another huge factor to consider. A professional electronics engineer working on a wearable consumer product might be looking for a wafer-level CSP package that’s less than 2×2 mm in size. A hobbyist who is uncomfortable with surface-mount soldering may be looking for a legacy DIP package that can be used with breadboards and solder protoboards. Different manufacturers choose packaging options carefully, so before you dive into an architecture for a project, one of the first things to consider is making sure that it’s in a package you actually want to deal with.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Peripherals&lt;/strong&gt; can vary widely from architecture to architecture. Some MCUs have extremely powerful peripherals with multiple interrupt channels, DMA, internal clock generators, tons of power configuration control, and various clocking options. Others are incredibly simple — almost &lt;em&gt;basic&lt;/em&gt;. Just as before, different people will be looking for different things (even for different applications). It would be a massive undertaking to go over every single peripheral on these MCUs, but I’ll focus on the ones that all MCUs have in common, and point out fine-print “gotchas” that datasheets always seem to glance over.&lt;/p&gt;
&lt;h2&gt;Development Experience&lt;/h2&gt;
&lt;p&gt;Any microcontroller review or selection guide should include a discussion of the overall development environment and experience.&lt;/p&gt;
&lt;p&gt;While this is where things get subjective and opinion-oriented, I’ll attempt to present “just the facts” and let you decide what you care about. The main source of subjectivity comes from &lt;em&gt;weighing&lt;/em&gt; these facts appropriately, which I will not attempt to do.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IDEs / SDKs / Compilers:&lt;/strong&gt; What is the manufacturer-suggested IDE for developing code on the MCU? Are there other options? What compilers does the microcontroller support? Is the software cross-platform? How much does it cost? These are the sorts of things I’ll be exploring while evaluating the software for the MCU architecture.&lt;/p&gt;
&lt;p&gt;Platform functionality and features will vary a lot by architecture, but I’ll look at basic project management, source-code editor quality, initialization code-generation tools, run-time peripheral libraries, debugging experience, and documentation accessibility.&lt;/p&gt;
&lt;p&gt;I’ll focus on manufacturer-provided or manufacturer-suggested IDEs and compilers (and these will be what I use to benchmark the MCU). There are more than a dozen compilers / IDEs available for many of these architectures, so I can’t reasonably review all of them. Feel free to express your contempt of my methodology in the comments section.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Programmers / debuggers / emulators / dev boards:&lt;/strong&gt; What dev boards and debuggers are available for the ecosystem? How clunky is the debugging experience? Every company has a slightly different philosophy for development boards and debuggers, so this will be interesting to compare.&lt;/p&gt;
&lt;h2&gt;Performance&lt;/h2&gt;
&lt;p&gt;I’ve established three different code samples I’ll be using to benchmark the parts in this microcontroller review; I’ll be measuring quantitative parameters like benchmark speed, clock-cycle efficiency, power efficiency, and code-size efficiency.&lt;/p&gt;
&lt;h3&gt;While(1) Blink&lt;/h3&gt;
&lt;p&gt;For this test, I’ll toggle a pin in a &lt;code&gt;while()&lt;/code&gt; loop. I’ll use the fastest C code possible — while also reporting if the code generator tool or peripheral libraries were able to produce efficient code. I’ll use bitwise complement or GPIO-specific “toggle” registers if the platform supports it, otherwise, I’ll resort to a read-modify-write operation. I’ll report on which instructions were executed, and the number of cycles they took.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;What this tests:&lt;/strong&gt; This gives some good intuition for how the platform works — because it is so low-level, we’ll be able to easily look at the assembly code and individual instruction timing. Since many of these parts operate above flash read speed, this will allow us to see what’s going on with the flash read accelerator (if one exists), and as a general diagnostic / debugging tool for getting the platform up and running at the proper speed. This routine will obviously also test bit manipulation performance (though this is rarely important in general-purpose projects).&lt;/p&gt;
&lt;h3&gt;64-Sample Biquad Filter&lt;/h3&gt;
&lt;p&gt;This is an example of a real-world application where you often need good, real-time performance, so I thought it would be a perfect test to evaluate the raw processing power of each microcontroller. For this test, I’ll process 16-bit signed integer data through a 400 Hz second-order high-pass filter (Transposed Direct Form II implementation, for those playing along at home), assuming a sample rate of 8 kHz. We won’t &lt;em&gt;actually&lt;/em&gt; sample the data from an ADC — instead, we’ll process 64-element arrays of dummy input data, and record the time it takes to complete this process (by wiggling a GPIO pin run into my &lt;a href=&quot;https://www.saleae.com/&quot;&gt;500 MHz Saleae Logic Pro 16 logic analyzer&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;In addition to the samples-per-second measure of raw processing power, I’ll also measure power consumption, which will give us a “nanojoule-per-sample” measure; this will help you figure out how &lt;em&gt;efficient&lt;/em&gt; a processor is. While I’ve traditionally used &lt;a href=&quot;https://www.eevblog.com/projects/ucurrent/&quot;&gt;µCurrent&lt;/a&gt; units for this, I ended up using a &lt;a href=&quot;https://www.silabs.com/products/development-tools/mcu/8-bit/slstk2010a-efm8-sleepy-bee-starter-kit&quot;&gt;Silicon Labs EFM8 Sleepy Bee STK&lt;/a&gt; — I ripped the target processor off the board, turning it into a $30 time-domain logarithmic power meter. If you’re interested in more information, check out my &lt;a href=&quot;https://jaycarlson.net/pf/silicon-labs-efm8/&quot;&gt;EFM8&lt;/a&gt; review, which has the details of these excellent tools.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;What this tests:&lt;/strong&gt; Memory and 16-bit math performance per microamp, essentially. The 8-bit MCUs in our round up are going to struggle with this pretty hardcore — it’ll be interesting to see just how much better the 16 and 32-bit MCUs do. Like it or hate it, this will also evaluate a compiler’s optimization abilities since different compilers implement math routines quite differently.&lt;/p&gt;
&lt;h3&gt;DMX-512 RGB light&lt;/h3&gt;
&lt;p&gt;DMX-512 is a commonly-used lighting protocol for stage, club, and commercial lighting systems. Electrically, it uses RS-485; the protocol uses a long BREAK message at the beginning, followed by a “0” and then 511 bytes of data, transmitted at 250 kbaud. In this test, I’ll implement a DMX-512 receiver that directly drives a common-anode RGB LED. I will do this with whatever peripheral library or code-generator tool the manufacturer provides (if any at all).&lt;/p&gt;
&lt;p&gt;While you should really look for a precisely-timed break message, since this is only for prototyping, I’ll detect the start-of-frame by looking for an RX framing error (or a “break” signal, as some UARTs support LIN).&lt;/p&gt;
&lt;p&gt;I’ll minimize power consumption by lowering the frequency of the CPU as much as possible, using interrupt-based UART receiver routines, and halting or sleeping the CPU. I’ll report the average power consumption (with the LED removed from the circuit, of course). To get a rough idea of the completeness and quality of the code-generator tools or peripheral libraries, I’ll report the total number of statements I had to write, as well as the flash usage.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;What this tests:&lt;/strong&gt; This is a sort of holistic test that lets me get into the ecosystem and play around with the platform. This stuff is the bread and butter of embedded programming: interrupt-based UART reception with a little bit of flair (framing error detection), multi-channel PWM configuration, and nearly-always-halted state-machine-style CPU programming. Once you have your hardware set up and you know what you’re doing (say, after you’ve implemented this on a dozen MCUs before…), with a good code-gen tool or peripheral library, you should be able to program this with just a few lines of code in an hour or less — hopefully without having to hit the datasheet much at all.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Test notes:&lt;/strong&gt; I’m using &lt;a href=&quot;http://freestylerdmx.be/&quot;&gt;FreeStyler&lt;/a&gt; to generate DMX messages through an FTDI USB-to-serial converter (the program uses the &lt;a href=&quot;https://www.enttec.com/us/products/controls/dmx-usb/open-dmx-usb/&quot;&gt;Enttec Open DMX&lt;/a&gt; plugin to do this). As my FTDI cable is 5V, I put a 1k resistor with a 3.3V zener diode to to ground, which clamps the signal to 3.3V. The zener clamp isn’t there to protect the MCU — all of these chips tested have diode catches to protect from over-voltage — but rather, so that the MCU doesn’t inadvertently draw power from the Rx pin, which would ruin my current measurement results.&lt;/p&gt;

&lt;p&gt;All code I used to evaluate these parts in this microcontroller selection guide is available on my &lt;a href=&quot;https://github.com/jaydcarlson/microcontroller-test-code&quot;&gt;microcontroller-test-code GitHub repo&lt;/a&gt;. Check it out, fork it, submit patches, and keep me honest — if your results differ from mine, let’s get this post updated.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;contenders&quot; class=&quot;vc_row wpb_row vc_row-fluid&quot;&gt;
&lt;div class=&quot;wpb_column vc_column_container vc_col-sm-12&quot;&gt;
&lt;div class=&quot;vc_column-inner&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;

&lt;div class=&quot;wpb_text_column wpb_content_element&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;
&lt;div class=&quot;title-xlarge&quot;&gt;The Contenders&lt;/div&gt;
&lt;p&gt;This page will compare the devices, development tools, and IDEs all together. However, to prevent this article from getting overwhelmingly long, I’ve created review pages for each device that cover way more details about the architecture — along with more complete testing notes, different benchmarking variations, and in-depth assessment. If an architecture strikes your interest, you should definitely check out the full review below.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;portfolio-preloader-wrapper&quot;&gt;
&lt;div data-per-page=&quot;22&quot; data-portfolio-uid=&quot;51202d1&quot; class=&quot;portfolio no-padding portfolio-pagination-normal portfolio-style-masonry background-style-gray title-style-light hover-zooming-blur item-animation-disabled title-on-page portfolio-items-masonry columns-3&quot; data-hover=&quot;zooming-blur&quot;&gt;
&lt;div class=&quot;&quot;&gt;
&lt;div class=&quot;row&quot;&gt;
&lt;div class=&quot;portfolio-set clearfix&quot; data-max-row-height=&quot;380&quot;&gt;
&lt;div class=&quot;portfolio-item microcontrollers col-md-4 col-xs-4 item-animations-not-inited post-1067 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot; data-default-sort=&quot;0&quot; data-sort-date=&quot;1505433621&quot;&gt;
&lt;div class=&quot;wrap clearfix&quot;&gt;
&lt;div class=&quot;image post-1067 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;image-inner&quot;&gt;&lt;img src=&quot;https://jaycarlson.net/wp-content/uploads/2017/09/20170904-8362-thegem-portfolio-masonry.jpg?cbc196&amp;amp;cbc196&quot; width=&quot;754&quot; height=&quot;754&quot; class=&quot;attachment-thegem-portfolio-masonry&quot; alt=&quot;Atmel (Microchip) tinyAVR 1-Series&quot;/&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;caption post-1067 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Atmel TinyAVR&lt;/div&gt;

&lt;div class=&quot;subtitle&quot;&gt;
&lt;p&gt;Part: ATtiny1616&lt;br/&gt;The new-for-2017 tinyAVR line includes seven parts with XMEGA-style peripherals, a two-cycle 8×8 multiplier, the new UPDI one-wire debug interface, and a 20 MHz oscillator that should shoot some energy into this line of entry-level AVR controllers that was looking quite long in the tooth next to other 8-bit parts.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;portfolio-item microcontrollers col-md-4 col-xs-4 item-animations-not-inited post-1071 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot; data-default-sort=&quot;0&quot; data-sort-date=&quot;1505437253&quot;&gt;
&lt;div class=&quot;wrap clearfix&quot;&gt;
&lt;div class=&quot;image post-1071 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;image-inner&quot;&gt;&lt;img src=&quot;https://jaycarlson.net/wp-content/uploads/2017/09/20170915-8403-thegem-portfolio-masonry.jpg?cbc196&amp;amp;cbc196&quot; width=&quot;754&quot; height=&quot;754&quot; class=&quot;attachment-thegem-portfolio-masonry&quot; alt=&quot;Atmel (Microchip) megaAVR&quot;/&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;caption post-1071 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Atmel MegaAVR&lt;/div&gt;

&lt;div class=&quot;subtitle&quot;&gt;
&lt;p&gt;Part: ATmega168PB&lt;br/&gt;The AVR earned its hobbyist-friendly badge as the first MCU programmed in C with open-source tools. The “B” version of the classic ATmega168 takes a price cut due to a die-shrink, but little else has changed, including the anemic 8 MHz internal oscillator — and, like the tinyAVR, must sip on 5V to hit its full 20 MHz speed.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;portfolio-item microcontrollers col-md-4 col-xs-4 item-animations-not-inited post-1073 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot; data-default-sort=&quot;0&quot; data-sort-date=&quot;1505450353&quot;&gt;
&lt;div class=&quot;wrap clearfix&quot;&gt;
&lt;div class=&quot;image post-1073 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;image-inner&quot;&gt;&lt;img src=&quot;https://jaycarlson.net/wp-content/uploads/2017/09/20170904-8343-thegem-portfolio-masonry.jpg?cbc196&amp;amp;cbc196&quot; width=&quot;754&quot; height=&quot;754&quot; class=&quot;attachment-thegem-portfolio-masonry&quot; alt=&quot;Atmel (Microchip) SAM D10&quot;/&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;caption post-1073 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Atmel SAM D10&lt;/div&gt;

&lt;div class=&quot;subtitle&quot;&gt;
&lt;p&gt;Part: ATSAMD10D14A&lt;br/&gt;Atmel is positioning their least-expensive ARM Cortex-M0 offering — the new SAM D10 — to kill off all but the smallest TinyAVR MCUs with its performance numbers, peripherals, and price. Stand-out analog peripherals capstone a peripheral set and memory configuration that endows this part with good value.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;portfolio-item microcontrollers col-md-4 col-xs-4 item-animations-not-inited post-1074 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot; data-default-sort=&quot;0&quot; data-sort-date=&quot;1505450567&quot;&gt;
&lt;div class=&quot;wrap clearfix&quot;&gt;
&lt;div class=&quot;image post-1074 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;image-inner&quot;&gt;&lt;img src=&quot;https://jaycarlson.net/wp-content/uploads/2017/09/20170902-8183-thegem-portfolio-masonry.jpg?cbc196&amp;amp;cbc196&quot; width=&quot;754&quot; height=&quot;754&quot; class=&quot;attachment-thegem-portfolio-masonry&quot; alt=&quot;Cypress PSoC 4000S&quot;/&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;caption post-1074 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Cypress PSoC 4000S&lt;/div&gt;

&lt;div class=&quot;subtitle&quot;&gt;
&lt;p&gt;Part: CY8C4024LQI&lt;br/&gt;Reconfigurable digital logic — the PSoC’s claim to fame — is absent from this entry-level 24 MHz Arm part that also sports average analog features, and no support for Cypress’s handy “it just works” capacitive-touch hardware. Other than its unique development environment, this part treads water in a sea of low-cost ARM devices.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;portfolio-item microcontrollers col-md-4 col-xs-4 item-animations-not-inited post-1076 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot; data-default-sort=&quot;0&quot; data-sort-date=&quot;1505450675&quot;&gt;
&lt;div class=&quot;wrap clearfix&quot;&gt;
&lt;div class=&quot;image post-1076 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;image-inner&quot;&gt;&lt;img src=&quot;https://jaycarlson.net/wp-content/uploads/2017/09/20170928-8484-thegem-portfolio-masonry.jpg?cbc196&amp;amp;cbc196&quot; width=&quot;754&quot; height=&quot;754&quot; class=&quot;attachment-thegem-portfolio-masonry&quot; alt=&quot;Freescale (NXP) Kinetis KE04&quot;/&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;caption post-1076 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Freescale KE04&lt;/div&gt;

&lt;div class=&quot;subtitle&quot;&gt;
&lt;p&gt;Part: MKE04Z8VTG4&lt;br/&gt;Freescale introduced the Arm Cortex-M0 KE04 to kill off 8-bit MCUs — and with 2.7-5.5V support, tons of timers and analog options, it’s a step in that direction. Processor Expert provides a unique development experience for rapid-prototyping, which may be enough to lure some developers away from newer parts.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;portfolio-item microcontrollers col-md-4 col-xs-4 item-animations-not-inited post-1077 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot; data-default-sort=&quot;0&quot; data-sort-date=&quot;1505451000&quot;&gt;
&lt;div class=&quot;wrap clearfix&quot;&gt;
&lt;div class=&quot;image post-1077 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;image-inner&quot;&gt;&lt;img src=&quot;https://jaycarlson.net/wp-content/uploads/2017/09/20170915-8399-thegem-portfolio-masonry.jpg?cbc196&amp;amp;cbc196&quot; width=&quot;754&quot; height=&quot;754&quot; class=&quot;attachment-thegem-portfolio-masonry&quot; alt=&quot;Freescale (NXP) Kinetis KL03&quot;/&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;caption post-1077 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Freescale KL03&lt;/div&gt;

&lt;div class=&quot;subtitle&quot;&gt;
&lt;p&gt;Part: MKL03Z8VFG4&lt;br/&gt;While the KE series attacks the 8-bit sector with bells and whistles, the KL series focuses on being some of the lowest-power Arm parts on the market, with good low leakage performance in sleep mode. I’m testing this 48 MHz Arm part inside of NXP’s MCUXpresso, which recently added support for the newer Kinetis devices.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;portfolio-item microcontrollers col-md-4 col-xs-4 item-animations-not-inited post-1078 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot; data-default-sort=&quot;0&quot; data-sort-date=&quot;1505451157&quot;&gt;
&lt;div class=&quot;wrap clearfix&quot;&gt;
&lt;div class=&quot;image post-1078 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;image-inner&quot;&gt;&lt;img src=&quot;https://jaycarlson.net/wp-content/uploads/2017/09/20170813-7926-thegem-portfolio-masonry.jpg?cbc196&amp;amp;cbc196&quot; width=&quot;754&quot; height=&quot;754&quot; class=&quot;attachment-thegem-portfolio-masonry&quot; alt=&quot;Holtek HT-66&quot;/&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;caption post-1078 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Holtek HT-66&lt;/div&gt;

&lt;div class=&quot;subtitle&quot;&gt;
&lt;p&gt;Part: HT66F0185&lt;br/&gt;A basic 8-bit microcontroller with a slow, 4-cycle PIC16-style single-accumulator core. An anemic peripheral selection and limited memory capacity makes this a better one-trick pony than a main system controller. Holtek has a wide range of application-specific MCUs that integrate this core with HV power and other goodies.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;portfolio-item microcontrollers col-md-4 col-xs-4 item-animations-not-inited post-1080 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot; data-default-sort=&quot;0&quot; data-sort-date=&quot;1505451334&quot;&gt;
&lt;div class=&quot;wrap clearfix&quot;&gt;
&lt;div class=&quot;image post-1080 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;image-inner&quot;&gt;&lt;img src=&quot;https://jaycarlson.net/wp-content/uploads/2017/09/20170805-7855-thegem-portfolio-masonry.jpg?cbc196&amp;amp;cbc196&quot; width=&quot;754&quot; height=&quot;754&quot; class=&quot;attachment-thegem-portfolio-masonry&quot; alt=&quot;Infineon XMC1100&quot;/&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;caption post-1080 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Infineon XMC1100&lt;/div&gt;

&lt;div class=&quot;subtitle&quot;&gt;
&lt;p&gt;Part: XMC1100T016X0016&lt;br/&gt;Infineon Arm chips are common picks for control projects, and the new XMC1100 is no different. With 16K of RAM, a 1 MSPS six-channel ADC, flexible communications, up to 16 timer capture channels, and the ability to form a 64-bit timer for large-range timing gives this part a bit of personality among entry-level Cortex-M0 microcontrollers.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;portfolio-item microcontrollers col-md-4 col-xs-4 item-animations-not-inited post-1082 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot; data-default-sort=&quot;0&quot; data-sort-date=&quot;1505451426&quot;&gt;
&lt;div class=&quot;wrap clearfix&quot;&gt;
&lt;div class=&quot;image post-1082 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;image-inner&quot;&gt;&lt;img src=&quot;https://jaycarlson.net/wp-content/uploads/2017/09/20170915-8420-thegem-portfolio-masonry.jpg?cbc196&amp;amp;cbc196&quot; width=&quot;754&quot; height=&quot;754&quot; class=&quot;attachment-thegem-portfolio-masonry&quot; alt=&quot;Microchip PIC16&quot;/&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;caption post-1082 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Microchip PIC16&lt;/div&gt;

&lt;div class=&quot;subtitle&quot;&gt;
&lt;p&gt;Part: PIC16LF18325&lt;br/&gt;Vying with the 8051 as the most famous microcontroller of all time, the latest PIC16 Five-Digit Enhanced parts feature improved peripheral interconnectivity, more timers, and better analog. Still driven by a sluggish core that clambers along at one-fourth its clock speed, the PIC16 has always been best-suited for peripheral-heavy workloads.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;portfolio-item microcontrollers col-md-4 col-xs-4 item-animations-not-inited post-1083 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot; data-default-sort=&quot;0&quot; data-sort-date=&quot;1505451779&quot;&gt;
&lt;div class=&quot;wrap clearfix&quot;&gt;
&lt;div class=&quot;image post-1083 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;image-inner&quot;&gt;&lt;img src=&quot;https://jaycarlson.net/wp-content/uploads/2017/09/20170915-8412-thegem-portfolio-masonry.jpg?cbc196&amp;amp;cbc196&quot; width=&quot;754&quot; height=&quot;754&quot; class=&quot;attachment-thegem-portfolio-masonry&quot; alt=&quot;Microchip PIC24&quot;/&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;caption post-1083 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Microchip PIC24&lt;/div&gt;

&lt;div class=&quot;subtitle&quot;&gt;
&lt;p&gt;Part: PIC24F04KL100&lt;br/&gt;An expensive 16-bit part that’s designed (and priced) to mirror the MSP430. While it has decent performance and power consumption, it’s hard not to look toward other parts — especially the PIC32MM — which offer better pricing, and can beat the PIC24 at everything other than deep-sleep current consumption.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;portfolio-item microcontrollers col-md-4 col-xs-4 item-animations-not-inited post-1085 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot; data-default-sort=&quot;0&quot; data-sort-date=&quot;1505451867&quot;&gt;
&lt;div class=&quot;wrap clearfix&quot;&gt;
&lt;div class=&quot;image post-1085 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;image-inner&quot;&gt;&lt;img src=&quot;https://jaycarlson.net/wp-content/uploads/2017/09/20170915-8425-thegem-portfolio-masonry.jpg?cbc196&amp;amp;cbc196&quot; width=&quot;754&quot; height=&quot;754&quot; class=&quot;attachment-thegem-portfolio-masonry&quot; alt=&quot;Microchip PIC32MM&quot;/&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;caption post-1085 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Microchip PIC32MM&lt;/div&gt;

&lt;div class=&quot;subtitle&quot;&gt;
&lt;p&gt;Part: PIC32MM0064&lt;br/&gt;The 32-bit MIPS-powered PIC32MM compares similarly with ARM controllers on a per-cycle basis, but doesn’t provide the same flexibility with tooling that ARM does. It’s a great part for 32-bit beginners, though, as it brings along PIC18/PIC24-style peripherals and fuse-based configuration, easing development.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;portfolio-item microcontrollers col-md-4 col-xs-4 item-animations-not-inited post-1086 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot; data-default-sort=&quot;0&quot; data-sort-date=&quot;1505452049&quot;&gt;
&lt;div class=&quot;wrap clearfix&quot;&gt;
&lt;div class=&quot;image post-1086 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;image-inner&quot;&gt;&lt;img src=&quot;https://jaycarlson.net/wp-content/uploads/2017/09/20170915-8410-thegem-portfolio-masonry.jpg?cbc196&amp;amp;cbc196&quot; width=&quot;754&quot; height=&quot;754&quot; class=&quot;attachment-thegem-portfolio-masonry&quot; alt=&quot;Nuvoton N76&quot;/&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;caption post-1086 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Nuvoton N76&lt;/div&gt;

&lt;div class=&quot;subtitle&quot;&gt;
&lt;p&gt;Part: N76E003AT20&lt;br/&gt;The N76 is a 1T-style 8051 that brings a few twists and useful additions to the basic set of ’51 peripherals. This MCU has a slower instruction timing versus the EFM8 or STC8, but it’s hard to complain about a well-documented, fully-featured MCU with North American support that you can buy with East Asia pricing.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;portfolio-item microcontrollers col-md-4 col-xs-4 item-animations-not-inited post-1088 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot; data-default-sort=&quot;0&quot; data-sort-date=&quot;1505452201&quot;&gt;
&lt;div class=&quot;wrap clearfix&quot;&gt;
&lt;div class=&quot;image post-1088 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;image-inner&quot;&gt;&lt;img src=&quot;https://jaycarlson.net/wp-content/uploads/2017/09/20170728-7789-thegem-portfolio-masonry.jpg?cbc196&amp;amp;cbc196&quot; width=&quot;754&quot; height=&quot;754&quot; class=&quot;attachment-thegem-portfolio-masonry&quot; alt=&quot;Nuvoton M051&quot;/&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;caption post-1088 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Nuvoton M051&lt;/div&gt;

&lt;div class=&quot;subtitle&quot;&gt;
&lt;p&gt;Part: M052LDN&lt;br/&gt;The M051 series is a high-value, 50 MHz Cortex-M0 with excellent timers and comms peripherals, a coherent, easy-to-use functional-oriented peripheral library, a relatively high pin-count, and utilitarian dev tools. The Achilles’ heel is the somewhat-limited IDE options, buggy software, and gross power consumption figures.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;portfolio-item microcontrollers col-md-4 col-xs-4 item-animations-not-inited post-1091 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot; data-default-sort=&quot;0&quot; data-sort-date=&quot;1505452764&quot;&gt;
&lt;div class=&quot;wrap clearfix&quot;&gt;
&lt;div class=&quot;image post-1091 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;image-inner&quot;&gt;&lt;img src=&quot;https://jaycarlson.net/wp-content/uploads/2017/09/20170915-8397-thegem-portfolio-masonry.jpg?cbc196&amp;amp;cbc196&quot; width=&quot;754&quot; height=&quot;754&quot; class=&quot;attachment-thegem-portfolio-masonry&quot; alt=&quot;NXP LPC811&quot;/&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;caption post-1091 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;title&quot;&gt;NXP LPC811&lt;/div&gt;

&lt;div class=&quot;subtitle&quot;&gt;
&lt;p&gt;Part: LPC811M001JDH16&lt;br/&gt;The LPC81x is famous among hobbyists for the LPC810 — an 8-pin DIP-package MCU. For everyone else, the LPC81x is an older, forgettable 30 MHz ARM that’s short on peripherals (it doesn’t even have an ADC). An easy-to-use function-oriented peripheral library, serial loader, and plenty of code examples on blog posts keep this part alive.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;portfolio-item microcontrollers col-md-4 col-xs-4 item-animations-not-inited post-1092 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot; data-default-sort=&quot;0&quot; data-sort-date=&quot;1505453123&quot;&gt;
&lt;div class=&quot;wrap clearfix&quot;&gt;
&lt;div class=&quot;image post-1092 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;image-inner&quot;&gt;&lt;img src=&quot;https://jaycarlson.net/wp-content/uploads/2017/09/20170723-7683-thegem-portfolio-masonry.jpg?cbc196&amp;amp;cbc196&quot; width=&quot;754&quot; height=&quot;754&quot; class=&quot;attachment-thegem-portfolio-masonry&quot; alt=&quot;Renesas RL-78&quot;/&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;caption post-1092 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Renesas RL-78&lt;/div&gt;

&lt;div class=&quot;subtitle&quot;&gt;
&lt;p&gt;Part: R5F102A8ASP&lt;br/&gt;With the RL-78, Renesas built a clever hybrid MCU with an 8-bit-wide data path and a 16-bit-wide ALU, balancing cost and performance. Excellent low-power consumption, arrayed comms and timer peripherals, plus a good code-gen tool built into the free Eclipse IDE makes this part a strong competitor against the PIC24 and MSP430.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;portfolio-item microcontrollers col-md-4 col-xs-4 item-animations-not-inited post-1094 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot; data-default-sort=&quot;0&quot; data-sort-date=&quot;1505453458&quot;&gt;
&lt;div class=&quot;wrap clearfix&quot;&gt;
&lt;div class=&quot;image post-1094 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;image-inner&quot;&gt;&lt;img src=&quot;https://jaycarlson.net/wp-content/uploads/2017/09/20170915-8393-thegem-portfolio-masonry.jpg?cbc196&amp;amp;cbc196&quot; width=&quot;754&quot; height=&quot;754&quot; class=&quot;attachment-thegem-portfolio-masonry&quot; alt=&quot;Sanyo (ON Semiconductor) LC87&quot;/&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;caption post-1094 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Sanyo LC87&lt;/div&gt;

&lt;div class=&quot;subtitle&quot;&gt;
&lt;p&gt;Part: LC87F1M16&lt;br/&gt;There’s not much to like in the LC-87. Abysmal power consumption, lackluster peripherals, unfriendly pricing, and an obnoxiously antiquated development ecosystem should steer away almost any rational person from this architecture that, from the copyright dates on the development tools, looks to be headed to the grave.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;portfolio-item microcontrollers col-md-4 col-xs-4 item-animations-not-inited post-1095 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot; data-default-sort=&quot;0&quot; data-sort-date=&quot;1505453551&quot;&gt;
&lt;div class=&quot;wrap clearfix&quot;&gt;
&lt;div class=&quot;image post-1095 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;image-inner&quot;&gt;&lt;img src=&quot;https://jaycarlson.net/wp-content/uploads/2017/09/20170818-7949-thegem-portfolio-masonry.jpg?cbc196&amp;amp;cbc196&quot; width=&quot;754&quot; height=&quot;754&quot; class=&quot;attachment-thegem-portfolio-masonry&quot; alt=&quot;Silicon Labs EFM8 Laser Bee&quot;/&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;caption post-1095 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Silicon Labs EFM8&lt;/div&gt;

&lt;div class=&quot;subtitle&quot;&gt;
&lt;p&gt;Part: EFM8LB11&lt;br/&gt;The EFM8 Laser Bee is a snappy 72 MHz 8051 MCU that’s both the fastest 8-bit MCU in our round-up, as well as one of the lowest-power. Low-cost tools, a free cross-platform Eclipse-based IDE, and a slew of easy-to-program peripherals should get both professionals and hobbyists interested in exploring this platform.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;portfolio-item microcontrollers col-md-4 col-xs-4 item-animations-not-inited post-1096 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot; data-default-sort=&quot;0&quot; data-sort-date=&quot;1505453631&quot;&gt;
&lt;div class=&quot;wrap clearfix&quot;&gt;
&lt;div class=&quot;image post-1096 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;image-inner&quot;&gt;&lt;img src=&quot;https://jaycarlson.net/wp-content/uploads/2017/09/20170801-7836-thegem-portfolio-masonry.jpg?cbc196&amp;amp;cbc196&quot; width=&quot;754&quot; height=&quot;754&quot; class=&quot;attachment-thegem-portfolio-masonry&quot; alt=&quot;ST STM8&quot;/&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;caption post-1096 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;


&lt;div class=&quot;subtitle&quot;&gt;
&lt;p&gt;Part: STM8S103F3P6&lt;br/&gt;The STM8 feels like an ARM in disguise: a 32-bit-wide program memory bus with efficient compute performance, peripheral power gating, and a nested vector interrupt controller makes this thing look more like its STM32 big brothers. If only its STVD development environment felt as modern as its peripheral set does.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;portfolio-item microcontrollers col-md-4 col-xs-4 item-animations-not-inited post-1097 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot; data-default-sort=&quot;0&quot; data-sort-date=&quot;1505453889&quot;&gt;
&lt;div class=&quot;wrap clearfix&quot;&gt;
&lt;div class=&quot;image post-1097 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;image-inner&quot;&gt;&lt;img src=&quot;https://jaycarlson.net/wp-content/uploads/2017/09/20170904-8328-thegem-portfolio-masonry.jpg?cbc196&amp;amp;cbc196&quot; width=&quot;754&quot; height=&quot;754&quot; class=&quot;attachment-thegem-portfolio-masonry&quot; alt=&quot;ST STM32F0&quot;/&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;caption post-1097 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;title&quot;&gt;ST STM32F0&lt;/div&gt;

&lt;div class=&quot;subtitle&quot;&gt;
&lt;p&gt;Part: STM32F030F4P6&lt;br/&gt;While the F0 has an average peripheral set and worse-than-average power consumption, its low-cost ST-Link debugger, free IDE, good code-gen tools, and huge parametric latitude (up to the 180 MHz, 2 MB STM32F4) make this a useful family to learn — plus everyone seems to have an STM32 Discovery board laying around.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;portfolio-item microcontrollers col-md-4 col-xs-4 item-animations-not-inited post-1101 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot; data-default-sort=&quot;0&quot; data-sort-date=&quot;1505454223&quot;&gt;
&lt;div class=&quot;wrap clearfix&quot;&gt;
&lt;div class=&quot;image post-1101 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;image-inner&quot;&gt;&lt;img src=&quot;https://jaycarlson.net/wp-content/uploads/2017/09/20170904-8355-thegem-portfolio-masonry.jpg?cbc196&amp;amp;cbc196&quot; width=&quot;754&quot; height=&quot;754&quot; class=&quot;attachment-thegem-portfolio-masonry&quot; alt=&quot;STCmicro STC8&quot;/&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;caption post-1101 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;title&quot;&gt;STCmicro STC8&lt;/div&gt;

&lt;div class=&quot;subtitle&quot;&gt;
&lt;p&gt;Part: STC8A8K64S4A12&lt;br/&gt;A brand-new, single-cycle 8051 jam-packed full of flash, RAM, and oodles of peripherals — and a large, 64-pin package to make use of all these guts. Unfortunately, this part isn’t quite ready for prime-time: the datasheet hasn’t been translated into English yet, the errata is massive, and there’s limited availability of the part.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;portfolio-item microcontrollers col-md-4 col-xs-4 item-animations-not-inited post-1103 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot; data-default-sort=&quot;0&quot; data-sort-date=&quot;1505454322&quot;&gt;
&lt;div class=&quot;wrap clearfix&quot;&gt;
&lt;div class=&quot;image post-1103 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;
&lt;div class=&quot;image-inner&quot;&gt;&lt;img src=&quot;https://jaycarlson.net/wp-content/uploads/2017/09/20170904-8318-thegem-portfolio-masonry.jpg?cbc196&amp;amp;cbc196&quot; width=&quot;754&quot; height=&quot;754&quot; class=&quot;attachment-thegem-portfolio-masonry&quot; alt=&quot;Texas Instruments MSP430FR&quot;/&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;caption post-1103 thegem_pf_item type-thegem_pf_item status-publish has-post-thumbnail hentry&quot;&gt;


&lt;div class=&quot;subtitle&quot;&gt;
&lt;p&gt;Part: MSP430FR2111&lt;br/&gt;Texas Instruments dials down the power consumption in the latest iteration of the MSP430. FRAM memory, flexible power states, and tons of internal clocking options make this part a battery’s dream come true. You’ll pay for this power, though: the MSP430 can be twice as expensive as many 8-bit parts.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;specs&quot; class=&quot;vc_row wpb_row vc_row-fluid&quot;&gt;
&lt;div class=&quot;wpb_column vc_column_container vc_col-sm-12&quot;&gt;
&lt;div class=&quot;vc_column-inner&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;

&lt;div class=&quot;wpb_text_column wpb_content_element&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;
&lt;div class=&quot;title-xlarge&quot;&gt;Specs Comparison&lt;/div&gt;

&lt;p&gt;Microcontrollers continue to divide into two camps — those with vendor-specific core architectures, and those who use a third-party core design. Out of the 21 microcontrollers reviewed here, eight of them use a 32-bit ARM core, which is becoming ubiquitous in the industry — even at this price point. Three of the microcontrollers use an 8-bit 8051-compatible ISA. The remaining ten use the vendor’s proprietary core design: six are 8-bit parts, three are 16-bit parts, and the &lt;a href=&quot;https://jaycarlson.net/pf/microchip-pic32mm/&quot;&gt;PIC32MM&lt;/a&gt; is the sole 32-bit part that doesn’t use an ARM core.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;wpb_text_column wpb_content_element&quot; id=&quot;avr&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;
&lt;h2 id=&quot;avr&quot;&gt;AVR&lt;/h2&gt;
&lt;p&gt;The AVR core is a famous RISC design known for its clock-cycle efficiency — especially at the time it was introduced in 1997. I reviewed two microcontrollers with an AVR core — the &lt;a href=&quot;https://jaycarlson.net/pf/atmel-microchip-tinyavr-1-series/&quot;&gt;tinyAVR 1-Series&lt;/a&gt; and the &lt;a href=&quot;https://jaycarlson.net/pf/atmel-microchip-megaavr/&quot;&gt;megaAVR&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The specific AVR instruction set and timing for both parts I reviewed is known as “AVRe” — this instruction set includes a two-cycle multiply and many single-cycle operations. Note that tinyAVR parts prior to the &lt;a href=&quot;https://jaycarlson.net/pf/atmel-microchip-tinyavr-1-series/&quot;&gt;tinyAVR 1-Series&lt;/a&gt; are essentially completely different MCUs with a less-capable AVR core that has no multiplier.&lt;/p&gt;
&lt;p&gt;The AVR core has a 16-bit instruction fetch width; most instructions are 16 bits wide; some are 32. Still, this is a RISC architecture, so the instruction set is anything but orthogonal; while there are 32 registers you can operate with, there are very few instructions for working directly with RAM; and of those 32 registers, I’d say that only 16 of them are true “general purpose” registers, as R0-R15 can’t be used with all register operations (load-immediate probably being the most important).&lt;/p&gt;
&lt;p&gt;All things said, though, AVR offered a huge performance improvement over the 12-cycle or 6-cycle 8051 processors when AVR was first introduced — and the AVR is always faster than even modern 8051 derivatives when it comes to working with large arrays of data that must be stored in extended (16-bit) RAM on the 8051.&lt;/p&gt;
&lt;p&gt;It was also designed for C compilers, too — with 32 registers available at all times, compilers can efficiently juggle around many operands concurrently; the 8051, by comparison, has four banks of eight registers that are only easily switched between within interrupt contexts (which is actually quite useful).&lt;/p&gt;
&lt;p&gt;And interrupts are one of the weak points of the AVR core: there’s only one interrupt priority, and depending on the ISR, many registers will have to be pushed to the stack and restored upon exit. In my testing, this often added 10 PUSH instructions or more — each taking 2 cycles.&lt;/p&gt;
&lt;p&gt;Another issue with AVR is the generally slow clock speed — even the high-end XMEGA AVR parts can only run at up to 32 MHz, with both the parts reviewed here topping out at 20 MHz. Compare that to the &lt;a href=&quot;https://jaycarlson.net/pf/silicon-labs-efm8/&quot;&gt;EFM8&lt;/a&gt;, of which is many varieties run at 48 MHz or higher (like the 72 MHz Laser Bee I reviewed). Even a 50%-better clock cycle efficiency doesn’t help much when the competition runs almost four times faster than the AVR.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;wpb_text_column wpb_content_element&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;
&lt;h2 id=&quot;pic16&quot;&gt;Microchip PIC16&lt;/h2&gt;
&lt;p&gt;There’s something fundamentally goofy about almost all aspects of the &lt;a href=&quot;https://jaycarlson.net/pf/microchip-pic16-five-digit-enhanced/&quot;&gt;PIC16&lt;/a&gt; that make it seem, at first glance, completely bizarre that it is as popular as it is.&lt;/p&gt;
&lt;p&gt;PIC16 uses an odd-ball 14-bit-wide program memory, yet it’s an 8-bit machine. This dramatically simplifies the core architecture: a 14-bit word can hold just enough data to specify every CPU instruction — with enough free space left in the word to address up to 128 registers or 2K of program memory (for the two jump/call routines).&lt;/p&gt;
&lt;p&gt;Microchip calls the PIC16 a RISC machine since every PIC instruction (there’s just 49 of them) is precisely one word long&lt;sup id=&quot;footnote_plugin_tooltip_2&quot; class=&quot;footnote_plugin_tooltip_text&quot; onclick=&quot;footnote_moveToAnchor('footnote_plugin_reference_2');&quot;&gt;2&lt;/sup&gt;&lt;span class=&quot;footnote_tooltip&quot; id=&quot;footnote_plugin_tooltip_text_2&quot;&gt;There’s considerable debate as to the precise definition of a “RISC architecture” is, but while the PIC16 has a single-word instruction length for all instructions, the PIC16 varies greatly from most RISC parts in that it is an accumulator-based machine, and has no working registers. I’ll leave it up to you to decide.&lt;/span&gt;. The PIC16 is often described as a 4T architecture — taking 4 clock cycles to execute a single machine instruction. This isn’t &lt;em&gt;entirely &lt;/em&gt;true, as the PIC16 takes an additional 4 cycles to &lt;em&gt;fetch &lt;/em&gt;that instruction. Consequently, it’s actually an 8T machine, though it implements a pipeline scheme that allows each instruction to execute in 4 cycles — except jumps, which take 8.&lt;/p&gt;
&lt;p&gt;Since real MCUs have more than 128 bytes of registers and 2K of program memory, this PIC has a bank selection register (BSR), which is written to whenever you need to swap banks (which happens &lt;em&gt;a lot&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;The PIC16 is a single-register machine, and that register is named &lt;em&gt;W&lt;/em&gt;. Everything you do will essentially be moving &lt;em&gt;something&lt;/em&gt; into W, doing &lt;em&gt;something&lt;/em&gt; with it, and then moving it back to &lt;em&gt;somewhere&lt;/em&gt;. Consequently, programming it in assembly is easy, and downright fun.&lt;/p&gt;
&lt;p&gt;Because this part can store 8192 14-bit program words, Microchip will tell you this part has 14 KB of flash (close to 16 KB, right?), but users will tell you that it has 8K of program memory — 8192 &lt;em&gt;words&lt;/em&gt; of memory — since storing an 8192-element byte array will occupy all 14 KB of its flash memory. Keep this in mind when comparing memory.&lt;/p&gt;
&lt;p&gt;I have a longer write-up of PIC16 in the &lt;a href=&quot;https://jaycarlson.net/pf/microchip-pic16-five-digit-enhanced/&quot;&gt;main PIC16 article&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;wpb_text_column wpb_content_element&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;
&lt;h2 id=&quot;pic24&quot;&gt;Microchip PIC24&lt;/h2&gt;
&lt;p&gt;While the PIC10, 12, 16, and 18 are all 8-bit cores with 12-16 bit program memory, the PIC24 moves up to 16-bit data operated through 24-bit instructions (are you starting to catch onto the numbering system?)&lt;/p&gt;
&lt;p&gt;While all the PICs before it were 4T machines, the &lt;a href=&quot;https://jaycarlson.net/pf/microchip-pic24/&quot;&gt;PIC24&lt;/a&gt; is 2T — that is, two clock cycles per instruction cycle.&lt;/p&gt;
&lt;p&gt;The PIC24 has new indirect addressing modes that allow incrementing/decrementing and register-offset addressing, has a few more other instructions, and has three — instead of two — hardware breakpoints; but otherwise, the core is very much in the spirit of the &lt;a href=&quot;https://jaycarlson.net/pf/microchip-pic16-five-digit-enhanced/&quot;&gt;PIC16&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://jaycarlson.net/pf/microchip-pic24/&quot;&gt;PIC24&lt;/a&gt; carries the excellent power consumption figures that the &lt;a href=&quot;https://jaycarlson.net/pf/microchip-pic16-five-digit-enhanced/&quot;&gt;PIC16&lt;/a&gt; has, but many of the parts lack the clocking and oscillator options the &lt;a href=&quot;https://jaycarlson.net/pf/texas-instruments-msp430fr/&quot;&gt;MSP430&lt;/a&gt; has (and apples-to-apples, the MSP430 is lower-power).&lt;/p&gt;
&lt;p&gt;The dsPIC versions of these parts — which add DSP-friendly instructions — are popular for motor drivers, but it’s not clear that the PIC24 has more widely been the runaway success Microchip had hoped.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;wpb_text_column wpb_content_element&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;
&lt;h2 id=&quot;pic32&quot;&gt;Microchip PIC32&lt;/h2&gt;
&lt;p&gt;While everyone was migrating their 8-bit proprietary cores to Arm, Microchip was gleefully popping out PIC parts. But in 2007, they finally decided to add a new microcontroller — the &lt;a href=&quot;https://jaycarlson.net/pf/microchip-pic32mm/&quot;&gt;PIC32&lt;/a&gt; — which uses a third-party, industry-standard 32-bit core. Instead of following everyone to the Arm ecosystem, they took a different turn: PIC32 parts use the MIPS architecture — specifically the M4K core.&lt;/p&gt;
&lt;p&gt;MIPS built this core for single-chip MCU applications. M4K has 32 registers, a 5-stage pipeline, vectored interrupts and exceptions, bit-manipulation, and 16-bit instruction encoding support.&lt;/p&gt;
&lt;p&gt;It is not the same as an Arm processor, but at the C application level, they are similar enough that any Arm developer should have no problems (other than the usual manufacturer-to-manufacturer peripheral differences).&lt;/p&gt;
&lt;p&gt;You can program and debug the PIC32 using the same PGC/PGD/MCLR set-up you use on all other PIC parts — but there’s also support for JTAG, though the most popular JTAG debugger — the Segger J-Link — has limited support for the PIC32MX parts, and no support for the PIC32MM.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;wpb_text_column wpb_content_element&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;
&lt;h2&gt;Arm Cortex-M0&lt;/h2&gt;
&lt;p&gt;The Arm Cortex-M0 &lt;sup id=&quot;footnote_plugin_tooltip_3&quot; class=&quot;footnote_plugin_tooltip_text&quot; onclick=&quot;footnote_moveToAnchor('footnote_plugin_reference_3');&quot;&gt;3&lt;/sup&gt;&lt;span class=&quot;footnote_tooltip&quot; id=&quot;footnote_plugin_tooltip_text_3&quot;&gt;Formerly ARM, but as of August 1, 2017, “Arm” is the capitalization style &lt;a href=&quot;http://linuxgizmos.com/arm-becomes-arm-or-is-it-arm/&quot;&gt;they now use&lt;/a&gt;.&lt;/span&gt;is a 32-bit RISC architecture that serves as the entry-level Arm architecture available to silicon vendors for microcontroller applications. Arm cores are designed by &lt;a href=&quot;https://www.arm.com/&quot;&gt;Arm Holdings&lt;/a&gt; and licensed to semiconductor manufacturers for integration into their products.&lt;/p&gt;
&lt;p&gt;Arm started out as a personal computer microprocessor when Advanced RISC Machines formed a joint venture between Acorn, Apple, and VLSI Technology to manufacture 32-bit processors for the Acorn computer. While Arm cores have grown in popularity as microprocessors for battery-powered systems (they are almost certainly powering your smartphone), Arm moved into the microcontroller sphere as well — the ARM7TDMI-S was probably the first Arm core that was used in microcontrollers — i.e., processors with completely self-contained RAM, flash, and peripherals. The Atmel AT91 and ST STR7 were probably the first microcontroller parts designed with an Arm core.&lt;/p&gt;
&lt;p&gt;It’s important to understand the history of Arm because it explains a serious feature of Arm microcontrollers that differs substantially from the 8051 (the other multi-vendor architecture that dominates the field): Unlike the 8051, Arm is just a core, not a complete microcontroller.&lt;/p&gt;
&lt;p&gt;The ARM7TDMI-S didn’t come with any GPIO designs, or provisions for UARTs or ADCs or timers — it was designed as a microprocessor. Thus, as vendors started stuffing this core into their extremely high-end MCUs, they had to add in their vendor-specific peripherals to the AHB (AMBA&lt;sup id=&quot;footnote_plugin_tooltip_4&quot; class=&quot;footnote_plugin_tooltip_text&quot; onclick=&quot;footnote_moveToAnchor('footnote_plugin_reference_4');&quot;&gt;4&lt;/sup&gt;&lt;span class=&quot;footnote_tooltip&quot; id=&quot;footnote_plugin_tooltip_text_4&quot;&gt;Advanced Microcontroller Bus Architecture — these multi-level acronyms are getting tedious&lt;/span&gt;High-performance Bus).&lt;/p&gt;
&lt;p&gt;Consequently, Freescale used a lot of HC08 and ColdFire peripherals; while Atmel designed new peripherals from scratch. ST borrowed a bit from the ST7 (the precursor to the &lt;a href=&quot;https://jaycarlson.net/pf/st-stm8/&quot;&gt;STM8&lt;/a&gt;) but used new designs for timers and communications peripherals.&lt;/p&gt;
&lt;p&gt;Since many microcontroller projects spend 90% or more of the code base manipulating peripherals, this is a serious consideration when switching from one Arm MCU vendor to another: there’s absolutely zero peripheral compatibility between vendors, and even within a single vendor, their Arm parts can have wildly different peripherals.&lt;/p&gt;
&lt;p&gt;Unlike other Arm parts, the M0 series only supports a subset of the 16-bit Thumb instruction set, which allows it to be about 1/3 the size of a Cortex-M3 core. Still, there’s a full 32-bit ALU, with a 32-bit hardware multiplier supporting a 32-bit result. Arm provides the option of either a single-cycle multiply, or a 32-cycle multiply instruction, but in my browsing, it seems as though most vendors use the single-cycle multiply option.&lt;/p&gt;
&lt;p&gt;In addition to the normal CPU registers, Arm cores have 13 general-purpose working registers, &lt;a href=&quot;http://researchbank.rmit.edu.au/eserv/rmit:2517/n2001000381.pdf&quot;&gt;which is roughly the sweet spot&lt;/a&gt;. The core has a nested vector interrupt controller, with up to 32 interrupt vectors and 4 interrupt priorities — plenty when compared to the 8-bit competition, but a far cry from the 240 interrupts at 256 interrupt priorities that the larger Arm parts support. The core also has full support for runtime exceptions, which isn’t a feature found on 8-bit architectures.&lt;/p&gt;
&lt;p&gt;The M0+ is an improved version of the M0 that supports faster two-cycle branches (due to the pipeline going from three-stage to two-stage), and lower power consumption. There are a slew of silicon options that vendors can choose from: single-cycle GPIO, support for a simple instruction trace buffer called Micro Trace Buffer (MTB), vector table relocation, and a rudimentary memory protection unit (MPU).&lt;/p&gt;
&lt;p&gt;One of the biggest problems with ARM microcontrollers is their low code density for anything other than 16- and 32-bit math — even those that use the 16-bit Thumb instruction set. This means normal microcontroller type routines — shoving bytes out a communication port, wiggling bits around, performing software ADC conversions, and updating timers — can take a lot of code space on these parts. Exacerbating this problem is the peripherals, which tend to be more complex — I mean “flexible” — than 8-bit parts, often necessitating run-time peripheral libraries and tons of register manipulation.&lt;/p&gt;
&lt;p&gt;Another problem with ARM processors is the severe 12-cycle interrupt latency. When coupled with the large number of registers that are saved and restored in the prologue and epilogue of the ISR handlers, these cycles start to add up. ISR latency is one area where a 16 MHz 8-bit part can easily beat a 72 MHz 32-bit Arm microcontroller.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;wpb_text_column wpb_content_element&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;
&lt;h2&gt;8051&lt;/h2&gt;
&lt;p&gt;The 8051 was originally an Intel microcontroller introduced in 1980 as one of the first widely-deployed 8-bit parts. The 8-bit modified Harvard core has a fully-orthogonal variable-length CISC instruction set, hardware multiplier and hardware divider, bit-addressable RAM and specific bit-manipulation instructions, four switchable banks of eight registers each,  two-priority interrupt controller with automatic register bank-switching, 64 KB of both program and extended RAM addressability, with 128 bytes of “scratch pad” RAM accessible with fast instructions.&lt;/p&gt;
&lt;p&gt;The 8051 was actually a specific &lt;em&gt;part&lt;/em&gt; — not a family — but its name is now synonymous with the core architecture, peripherals, and even package pin-out &lt;sup id=&quot;footnote_plugin_tooltip_5&quot; class=&quot;footnote_plugin_tooltip_text&quot; onclick=&quot;footnote_moveToAnchor('footnote_plugin_reference_5');&quot;&gt;5&lt;/sup&gt;&lt;span class=&quot;footnote_tooltip&quot; id=&quot;footnote_plugin_tooltip_text_5&quot;&gt;the 8051 is a member of a family officially called the “MCS-51” — along with the 8031, 8032, 8051, and 8052 — plus all the subsequent versions that were introduced later&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;The original had 4K of ROM &lt;sup id=&quot;footnote_plugin_tooltip_6&quot; class=&quot;footnote_plugin_tooltip_text&quot; onclick=&quot;footnote_moveToAnchor('footnote_plugin_reference_6');&quot;&gt;6&lt;/sup&gt;&lt;span class=&quot;footnote_tooltip&quot; id=&quot;footnote_plugin_tooltip_text_6&quot;&gt;Expensive windows ceramic packages allowed &lt;a href=&quot;https://jaycarlson.net/2017/06/27/blinking-an-led-with-an-original-intel-8051/&quot;&gt;EPROM programming&lt;/a&gt; for developers, but production units were mask-ROM or OTP — or, in the case of the 8031, only external ROM was supported.&lt;/span&gt;, 128 bytes of RAM, four full 8-bit GPIO ports (32 I/O total), a UART, two or three timers, and a two-priority interrupt system.&lt;/p&gt;
&lt;p&gt;The 8051 has a fully orthogonal CISC instruction set, which means you can do nearly any operation with immediate, direct, or indirect operands, and you can do these operations in RAM, registers, or the A accumulator.&lt;/p&gt;
&lt;p&gt;Many vendors built direct, drop-in compatible clones of the 8051, and by the time Intel discontinued its MCS-51 products in 2007, barely anyone noticed — these third-party parts evolved from mimicking Intel functionality to outright beating them with tons of additional timers, peripherals, and special-purpose functionality.&lt;/p&gt;
&lt;p&gt;Because of its small core and fast interrupt architecture, the 8051 architecture is extremely popular for managing peripherals used in real-time high-bandwidth systems, such as USB web cameras and audio DSPs, and is commonly deployed as a house-keeping processor in FPGAs used in audio/video processing and DSP work.&lt;/p&gt;
&lt;p&gt;Old-timers associate the 8051 with “old and slow” because the original was a 12T microcontroller — each machine cycle took 12 clock cycles to complete. Since there was no pipelining, every instruction byte took a machine cycle to fetch, plus one or more additional machine cycles to execute — altogether, it could take more than 50 clock cycles to execute a given instruction. Ouch.&lt;/p&gt;
&lt;p&gt;No need to worry about that anymore, though: all the modern 8051-style MCUs available are 1T processors, and many of them have a pipelined core, meaning many instructions take the same number of clock cycles to execute as the instruction’s length. Consequently, in many 8051 implementations, operations in A (the accumulator) are the fastest, followed by the register bank, and then RAM.&lt;/p&gt;
&lt;p&gt;I ended up with three different 8051-compatible microcontrollers end the lineup: the &lt;a href=&quot;https://jaycarlson.net/pf/nuvoton-n76/&quot;&gt;Nuvoton N76&lt;/a&gt;, the &lt;a href=&quot;https://jaycarlson.net/pf/silicon-labs-efm8/&quot;&gt;Silicon Labs EFM8 Laser Bee&lt;/a&gt;, and the &lt;a href=&quot;https://jaycarlson.net/pf/stcmicro-stc8/&quot;&gt;STCmicro STC8&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;From a pure core design standpoint, the &lt;a href=&quot;https://jaycarlson.net/pf/stcmicro-stc8/&quot;&gt;STC8&lt;/a&gt; is probably the most interesting — while I can’t find documentation to confirm this, it appears that STCmicro uses a 24-bit (or more) parallel instruction-fetch size. This means that a huge number — more than 80% — of instructions can be executed in a single cycle, which is a substantial step up from all other 8051s on the market these days.&lt;/p&gt;
&lt;p&gt;However, the &lt;a href=&quot;https://jaycarlson.net/pf/silicon-labs-efm8/&quot;&gt;EFM8&lt;/a&gt;, from Silicon Labs’ C8051 lineage, can hit much higher clock speeds — topping out at 72 MHz — making it the fastest part I reviewed, by core speed.&lt;/p&gt;
&lt;p&gt;I’ll be looking more at this in the performance section of the review.&lt;/p&gt;
&lt;h2&gt;STM8&lt;/h2&gt;
&lt;p&gt;The &lt;a href=&quot;https://jaycarlson.net/pf/st-stm8/&quot;&gt;STM8&lt;/a&gt; core has six CPU registers: a single accumulator, two index registers, a 24-bit program counter, a 16-bit stack pointer, and a condition register. The STM8 has a Harvard architecture, but uses a unified address space. There’s a 32-bit-wide program memory bus which can fetch most instructions in a single cycle — and pipelined fetch/decode/execute operations permit many instructions to execute in a single cycle.&lt;/p&gt;
&lt;p&gt;The claim to fame of the core is its comprehensive list of 20 addressing modes, including indexed indirect addressing and stack-pointer-relative modes. There’s three “reaches” for addressing — short (one-byte), long (two-byte), and extended (three-byte) — trading off memory area with performance.&lt;/p&gt;
&lt;p&gt;This is the only architecture in this round-up that has this level of granularity — all the other chips are either RISC-style processors that have lots of general-purpose registers they do their work in, or 8051-style CISC parts that manipulate RAM directly — but pay a severe penalty when hitting 16-bit address space. The STM8 manages these trade-offs in an efficient manner.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;wpb_text_column wpb_content_element&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;

&lt;p&gt;Use the tabs below to compare precise specs across families.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;vc_tta-container&quot; data-vc-action=&quot;collapse&quot;&gt;
&lt;div class=&quot;vc_general vc_tta vc_tta-tabs vc_tta-color-thegem vc_tta-style-classic vc_tta-shape-rounded vc_tta-spacing-1 vc_tta-tabs-position-top vc_tta-controls-align-left&quot;&gt;

&lt;div class=&quot;vc_tta-panels-container&quot;&gt;
&lt;div class=&quot;vc_tta-panels&quot;&gt;
&lt;div class=&quot;vc_tta-panel vc_active&quot; id=&quot;1505597767097-61049c0b-4061&quot; data-vc-content=&quot;.vc_tta-panel-body&quot;&gt;

&lt;div class=&quot;vc_tta-panel-body&quot;&gt;
&lt;div class=&quot;vc_progress_bar wpb_content_element vc_progress-bar-color-bar_grey&quot;&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel tinyAVR &lt;span class=&quot;vc_label_units&quot;&gt;20 MHz&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel megaAVR &lt;span class=&quot;vc_label_units&quot;&gt;20 MHz&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel SAM D10 &lt;span class=&quot;vc_label_units&quot;&gt;48 MHz&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Cypress PSoC 4000S &lt;span class=&quot;vc_label_units&quot;&gt;24 MHz&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KE04 &lt;span class=&quot;vc_label_units&quot;&gt;48 MHz&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KL03 &lt;span class=&quot;vc_label_units&quot;&gt;48 MHz&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Holtek HT66 &lt;span class=&quot;vc_label_units&quot;&gt;20 MHz&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Infineon XMC1100 &lt;span class=&quot;vc_label_units&quot;&gt;32 MHz&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC16 &lt;span class=&quot;vc_label_units&quot;&gt;32 MHz&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC24 &lt;span class=&quot;vc_label_units&quot;&gt;32 MHz&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC32MM &lt;span class=&quot;vc_label_units&quot;&gt;25 MHz&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton N76 &lt;span class=&quot;vc_label_units&quot;&gt;16 MHz&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton M051 &lt;span class=&quot;vc_label_units&quot;&gt;50 MHz&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;NXP LPC811 &lt;span class=&quot;vc_label_units&quot;&gt;30 MHz&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Renesas RL78 &lt;span class=&quot;vc_label_units&quot;&gt;24 MHz&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Sanyo LC87 &lt;span class=&quot;vc_label_units&quot;&gt;12 MHz&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Silicon Labs EFM8 &lt;span class=&quot;vc_label_units&quot;&gt;72 MHz&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM8 &lt;span class=&quot;vc_label_units&quot;&gt;16 MHz&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM32F0 &lt;span class=&quot;vc_label_units&quot;&gt;48 MHz&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;STC STC8 &lt;span class=&quot;vc_label_units&quot;&gt;30 MHz&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;TI MSP430FR &lt;span class=&quot;vc_label_units&quot;&gt;16 MHz&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;wpb_text_column wpb_content_element&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;
&lt;p&gt;The chart above illustrates the differences in core clock speed among each MCU. As will be seen in the evaluation section, core clock speed is not a good predictor of performance when comparing between different MCU families (especially between 8-, 16-, and 32-bit parts). However, most MCUs limit the maximum peripheral clock rate to that of the CPU, which may be a driving factor if your application requires fast peripheral clocks (say, for fast GPIO bit-banging or for high-speed capture/compare timer operations). The Infineon XMC1100 is a neat exception to this rule — its peripheral clock can run at up to 64 MHz.&lt;/p&gt;
&lt;p&gt;There are other important asterisks to this data: the Atmel tinyAVR and megaAVR parts have severely limited operating ranges when running below 5V, which will affect most modern designs. The tinyAVR can only run at 10 MHz below 3.6V, and at 5 MHz below 2.2V. The megaAVR has the same speed grades, but even worse, has nothing faster than an 8 MHz internal oscillator. When talking about sub-$1 MCUs, adding a crystal or even low-cost ceramic resonator adds a sizable portion of the cost of the MCU to the BOM.&lt;/p&gt;
&lt;p&gt;The Silicon Labs EFM8 Laser Bee, with its 72 MHz core clock speed, beats out even the ARM microcontrollers in this round-up. The Sanyo LC87 brings in a 12 MHz reading — but bear in mind this is a 3T architecture, which limits the actual instruction clock speed to 4 MHz. The Holtek HT66 and Microchip PIC16 are both 4T architectures, but the PIC16 has a relatively snappy 32 MHz core speed (thanks to its on-board PLL), which allows it to compete better with 8 MHz parts.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;vc_tta-panel&quot; id=&quot;1505597767173-b1b266cd-2c07&quot; data-vc-content=&quot;.vc_tta-panel-body&quot;&gt;

&lt;div class=&quot;vc_tta-panel-body&quot;&gt;
&lt;div class=&quot;vc_progress_bar wpb_content_element vc_progress-bar-color-bar_grey&quot;&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel tinyAVR &lt;span class=&quot;vc_label_units&quot;&gt;16 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel megaAVR &lt;span class=&quot;vc_label_units&quot;&gt;16 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel SAM D10 &lt;span class=&quot;vc_label_units&quot;&gt;16 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Cypress PSoC 4000S &lt;span class=&quot;vc_label_units&quot;&gt;16 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KE04 &lt;span class=&quot;vc_label_units&quot;&gt;8 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KL03 &lt;span class=&quot;vc_label_units&quot;&gt;8 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Holtek HT66 &lt;span class=&quot;vc_label_units&quot;&gt;8 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Infineon XMC1100 &lt;span class=&quot;vc_label_units&quot;&gt;14 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC16 &lt;span class=&quot;vc_label_units&quot;&gt;14 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC24 &lt;span class=&quot;vc_label_units&quot;&gt;4 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC32MM &lt;span class=&quot;vc_label_units&quot;&gt;32 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton N76 &lt;span class=&quot;vc_label_units&quot;&gt;18 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton M051 &lt;span class=&quot;vc_label_units&quot;&gt;12 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;NXP LPC811 &lt;span class=&quot;vc_label_units&quot;&gt;8 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Renesas RL78 &lt;span class=&quot;vc_label_units&quot;&gt;10 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Sanyo LC87 &lt;span class=&quot;vc_label_units&quot;&gt;16 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Silicon Labs EFM8 &lt;span class=&quot;vc_label_units&quot;&gt;16 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM8 &lt;span class=&quot;vc_label_units&quot;&gt;32 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM32F0 &lt;span class=&quot;vc_label_units&quot;&gt;16 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;STC STC8 &lt;span class=&quot;vc_label_units&quot;&gt;64 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;TI MSP430FR &lt;span class=&quot;vc_label_units&quot;&gt;16 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;wpb_text_column wpb_content_element&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;
&lt;p&gt;Here, we consider flash capacity in terms of &lt;em&gt;bytes&lt;/em&gt; — but be aware that flash usage varies considerably by core. The PIC16 may have 14 KB of flash, but being a 14-bit-wide core, it will feel more like it has 8 KB of flash when it comes time to actually storing and manipulating data, and counting instructions. The Holtek HT66 is similar to the PIC16, but with a 16-bit-wide fetch. The same goes for the PIC24, which has a 24-bit-wide flash data path. While other cores may have a wider-than-a-byte fetch size, they still allow instructions and data to be packed into flash efficiently.&lt;/p&gt;
&lt;p&gt;The STC8’s insane equipment list starts to shine — with 64 KB of flash, this part should be able to do essentially anything you throw at its space-efficient 8051 core. On the other side of the spectrum, the ARM processors were especially stingy with flash capacity, which is important to consider for applications that rely on a lot of peripheral runtime libraries: as we’ll see in the performance evaluation, many of these parts had little room left over after the test code was programmed onto them. The Microchip PIC24’s 4 KB flash capacity makes the part essentially unusable for general-purpose applications that would usually target a 16-bit controller, as it can only hold 1408 instructions in flash (due to its 24-bit-wide word fetches).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;vc_tta-panel&quot; id=&quot;1505597874159-58117a22-19d3&quot; data-vc-content=&quot;.vc_tta-panel-body&quot;&gt;

&lt;div class=&quot;vc_tta-panel-body&quot;&gt;
&lt;div class=&quot;vc_progress_bar wpb_content_element vc_progress-bar-color-bar_grey&quot;&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel tinyAVR &lt;span class=&quot;vc_label_units&quot;&gt;2 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel megaAVR &lt;span class=&quot;vc_label_units&quot;&gt;1 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel SAM D10 &lt;span class=&quot;vc_label_units&quot;&gt;4 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Cypress PSoC 4000S &lt;span class=&quot;vc_label_units&quot;&gt;2 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KE04 &lt;span class=&quot;vc_label_units&quot;&gt;1 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KL03 &lt;span class=&quot;vc_label_units&quot;&gt;2 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Holtek HT66 &lt;span class=&quot;vc_label_units&quot;&gt;0.25 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Infineon XMC1100 &lt;span class=&quot;vc_label_units&quot;&gt;16 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC16 &lt;span class=&quot;vc_label_units&quot;&gt;1 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC24 &lt;span class=&quot;vc_label_units&quot;&gt;0.5 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC32MM &lt;span class=&quot;vc_label_units&quot;&gt;8 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton N76 &lt;span class=&quot;vc_label_units&quot;&gt;1 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton M051 &lt;span class=&quot;vc_label_units&quot;&gt;4 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;NXP LPC811 &lt;span class=&quot;vc_label_units&quot;&gt;2 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Renesas RL78 &lt;span class=&quot;vc_label_units&quot;&gt;0.768 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Sanyo LC87 &lt;span class=&quot;vc_label_units&quot;&gt;1 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Silicon Labs EFM8 &lt;span class=&quot;vc_label_units&quot;&gt;1.28 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM8 &lt;span class=&quot;vc_label_units&quot;&gt;2 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM32F0 &lt;span class=&quot;vc_label_units&quot;&gt;4 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;STC STC8 &lt;span class=&quot;vc_label_units&quot;&gt;4 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;TI MSP430FR &lt;span class=&quot;vc_label_units&quot;&gt;1 KB&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;wpb_text_column wpb_content_element&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;
&lt;p&gt;Infineon’s memory configuration is actually “backwards” — it has 8 KB of flash, and 16 KB of RAM. It &lt;a href=&quot;https://jaycarlson.net/pf/infineon-xmc1100/#performance&quot;&gt;doesn’t have a good flash pre-fetch engine&lt;/a&gt;, so performance-critical code should be moved to RAM for fast execution. While you’re at it, unless you’ve got some large data capturing/analyzing procedures, you could just &lt;a href=&quot;https://www.infineonforums.com/threads/5295-Execute-all-code-from-RAM&quot;&gt;move your entire program into RAM&lt;/a&gt;, too.&lt;/p&gt;
&lt;p&gt;The KE04 (and probably the PIC24) both have too little RAM for most projects that would target these architectures. I’m actually less worried about the Holtek HT66; it’s efficient peripheral library essentially uses no RAM, and 256 bytes of user data is plenty of space for an ultra-low-power MCU that’s designed for only the most basic duties.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;vc_tta-panel&quot; id=&quot;1505597912216-38a724d5-574b&quot; data-vc-content=&quot;.vc_tta-panel-body&quot;&gt;

&lt;div class=&quot;vc_tta-panel-body&quot;&gt;
&lt;div class=&quot;vc_progress_bar wpb_content_element vc_progress-bar-color-bar_grey&quot;&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel tinyAVR &lt;span class=&quot;vc_label_units&quot;&gt;28 Points&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel megaAVR &lt;span class=&quot;vc_label_units&quot;&gt;17 Points&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel SAM D10 &lt;span class=&quot;vc_label_units&quot;&gt;51 Points&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Cypress PSoC 4000S &lt;span class=&quot;vc_label_units&quot;&gt;37 Points&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KE04 &lt;span class=&quot;vc_label_units&quot;&gt;50 Points&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KL03 &lt;span class=&quot;vc_label_units&quot;&gt;26 Points&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Holtek HT66 &lt;span class=&quot;vc_label_units&quot;&gt;12 Points&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Infineon XMC1100 &lt;span class=&quot;vc_label_units&quot;&gt;48 Points&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC16 &lt;span class=&quot;vc_label_units&quot;&gt;47 Points&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC24 &lt;span class=&quot;vc_label_units&quot;&gt;17 Points&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC32MM &lt;span class=&quot;vc_label_units&quot;&gt;44 Points&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton N76 &lt;span class=&quot;vc_label_units&quot;&gt;31 Points&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton M051 &lt;span class=&quot;vc_label_units&quot;&gt;62 Points&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;NXP LPC811 &lt;span class=&quot;vc_label_units&quot;&gt;45 Points&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Renesas RL78 &lt;span class=&quot;vc_label_units&quot;&gt;54 Points&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Sanyo LC87 &lt;span class=&quot;vc_label_units&quot;&gt;22 Points&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Silicon Labs EFM8 &lt;span class=&quot;vc_label_units&quot;&gt;42 Points&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM8 &lt;span class=&quot;vc_label_units&quot;&gt;43 Points&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM32F0 &lt;span class=&quot;vc_label_units&quot;&gt;40 Points&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;STC STC8 &lt;span class=&quot;vc_label_units&quot;&gt;51 Points&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;TI MSP430FR &lt;span class=&quot;vc_label_units&quot;&gt;13 Points&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;wpb_text_column wpb_content_element&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;
&lt;p&gt;Each MCU’s review page discusses its complement of timers, but I wanted to come up with a score to help quickly compare timer peripherals across MCUs — I call it TimerMark.&lt;/p&gt;
&lt;p&gt;Here’s how it works:&lt;/p&gt;
&lt;h3&gt;Basic Timer Blocks&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;1 point for 8-bit counters&lt;/li&gt;
&lt;li&gt;2 points for 8-bit auto-reload (period) timers&lt;/li&gt;
&lt;li&gt;2 points for 16-bit counters&lt;/li&gt;
&lt;li&gt;4 points for 16-bit auto-reload timers&lt;/li&gt;
&lt;li&gt;6 points for 24-bit auto-reload timers&lt;/li&gt;
&lt;li&gt;8 points for 32-bit auto-reload timers&lt;/li&gt;
&lt;li&gt;2 points for RTC&lt;/li&gt;
&lt;li&gt;2 points for each 16-bit timer set that can be extended to 32-bit&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;Capture Channels &amp;amp; PWM&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;1 point for each capture channel (regardless of depth)&lt;/li&gt;
&lt;li&gt;1 point for each 8-bit PWM channel&lt;/li&gt;
&lt;li&gt;2 points for each 16-bit PWM channel&lt;/li&gt;
&lt;li&gt;3 points for each 24-bit PWM channel&lt;/li&gt;
&lt;li&gt;3 points for each arbitrary-phase PWM channel (i.e., if the channel has separate ON and OFF comparator registers&lt;/li&gt;
&lt;li&gt;2 points if the PWM module is “power friendly” (multi-channel outputs with programmable dead-time, blanking, etc)&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;vc_tta-panel&quot; id=&quot;1506483266988-7b83f991-5057&quot; data-vc-content=&quot;.vc_tta-panel-body&quot;&gt;

&lt;div class=&quot;vc_tta-panel-body&quot;&gt;
&lt;div class=&quot;vc_progress_bar wpb_content_element vc_progress-bar-color-bar_grey&quot;&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel tinyAVR &lt;span class=&quot;vc_label_units&quot;&gt;9 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel megaAVR &lt;span class=&quot;vc_label_units&quot;&gt;6 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel SAM D10 &lt;span class=&quot;vc_label_units&quot;&gt;8 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Cypress PSoC 4000S &lt;span class=&quot;vc_label_units&quot;&gt;5 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KE04 &lt;span class=&quot;vc_label_units&quot;&gt;8 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KL03 &lt;span class=&quot;vc_label_units&quot;&gt;4 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Holtek HT66 &lt;span class=&quot;vc_label_units&quot;&gt;3 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Infineon XMC1100 &lt;span class=&quot;vc_label_units&quot;&gt;4 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC16 &lt;span class=&quot;vc_label_units&quot;&gt;7 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC24 &lt;span class=&quot;vc_label_units&quot;&gt;2 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC32MM &lt;span class=&quot;vc_label_units&quot;&gt;3 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton N76 &lt;span class=&quot;vc_label_units&quot;&gt;6 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton M051 &lt;span class=&quot;vc_label_units&quot;&gt;8 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;NXP LPC811 &lt;span class=&quot;vc_label_units&quot;&gt;4 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Renesas RL78 &lt;span class=&quot;vc_label_units&quot;&gt;7 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Sanyo LC87 &lt;span class=&quot;vc_label_units&quot;&gt;4 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Silicon Labs EFM8 &lt;span class=&quot;vc_label_units&quot;&gt;6 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM8 &lt;span class=&quot;vc_label_units&quot;&gt;9 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM32F0 &lt;span class=&quot;vc_label_units&quot;&gt;6 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;STC STC8 &lt;span class=&quot;vc_label_units&quot;&gt;12 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;TI MSP430FR &lt;span class=&quot;vc_label_units&quot;&gt;2 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;vc_tta-panel&quot; id=&quot;1506486291648-a5e6b80c-45f0&quot; data-vc-content=&quot;.vc_tta-panel-body&quot;&gt;

&lt;div class=&quot;vc_tta-panel-body&quot;&gt;
&lt;div class=&quot;vc_progress_bar wpb_content_element vc_progress-bar-color-bar_grey&quot;&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel tinyAVR &lt;span class=&quot;vc_label_units&quot;&gt;3 Resources&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel megaAVR &lt;span class=&quot;vc_label_units&quot;&gt;4 Resources&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel SAM D10 &lt;span class=&quot;vc_label_units&quot;&gt;3 Resources&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Cypress PSoC 4000S &lt;span class=&quot;vc_label_units&quot;&gt;2 Resources&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KE04 &lt;span class=&quot;vc_label_units&quot;&gt;3 Resources&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KL03 &lt;span class=&quot;vc_label_units&quot;&gt;3 Resources&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Holtek HT66 &lt;span class=&quot;vc_label_units&quot;&gt;2 Resources&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Infineon XMC1100 &lt;span class=&quot;vc_label_units&quot;&gt;2 Resources&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC16 &lt;span class=&quot;vc_label_units&quot;&gt;3 Resources&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC24 &lt;span class=&quot;vc_label_units&quot;&gt;2 Resources&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC32MM &lt;span class=&quot;vc_label_units&quot;&gt;4 Resources&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton N76 &lt;span class=&quot;vc_label_units&quot;&gt;4 Resources&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton M051 &lt;span class=&quot;vc_label_units&quot;&gt;6 Resources&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;NXP LPC811 &lt;span class=&quot;vc_label_units&quot;&gt;4 Resources&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Renesas RL78 &lt;span class=&quot;vc_label_units&quot;&gt;4 Resources&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Sanyo LC87 &lt;span class=&quot;vc_label_units&quot;&gt;3 Resources&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Silicon Labs EFM8 &lt;span class=&quot;vc_label_units&quot;&gt;4 Resources&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM8 &lt;span class=&quot;vc_label_units&quot;&gt;3 Resources&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM32F0 &lt;span class=&quot;vc_label_units&quot;&gt;3 Resources&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;STC STC8 &lt;span class=&quot;vc_label_units&quot;&gt;6 Resources&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;TI MSP430FR &lt;span class=&quot;vc_label_units&quot;&gt;1 Resources&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;wpb_text_column wpb_content_element&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;
&lt;p&gt;The chart above illustrates the total number of communications resources each microcontroller has.&lt;/p&gt;
&lt;p&gt;Most vendors use a separate, dedicated module for UART, SPI, and I&lt;sup&gt;2&lt;/sup&gt;C communication. &lt;a href=&quot;https://jaycarlson.net/pf/nuvoton-m051/&quot;&gt;Nuvoton’s M0&lt;/a&gt; went a step further and doubled up everything — two UARTs, two SPI, and two I&lt;sup&gt;2&lt;/sup&gt;C. Except under heavily-loaded buses, or under extremely strange designs, there’s rarely a need for multiple SPI or I&lt;sup&gt;2&lt;/sup&gt;C buses, so this decision struck me as a bit odd.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jaycarlson.net/pf/stc-stc8/&quot;&gt;STC&lt;/a&gt;‘s decision to incorporate four separate UARTs in addition to an SPI and an I&lt;sup&gt;2&lt;/sup&gt;C module seems to be more useful, since UARTs are almost always dedicated to a particular peripheral. Doubling-up on UARTs was a popular decision overall: the other 8051s — the &lt;a href=&quot;https://jaycarlson.net/pf/silicon-labs-efm8/&quot;&gt;EFM8&lt;/a&gt; and the &lt;a href=&quot;https://jaycarlson.net/pf/nuvoton-n76/&quot;&gt;N76&lt;/a&gt; — bring a second UART, as do the &lt;a href=&quot;https://jaycarlson.net/pf/microchip-pic16-five-digit-enhanced/&quot;&gt;PIC16&lt;/a&gt; and &lt;a href=&quot;https://jaycarlson.net/pf/microchip-pic32mm/&quot;&gt;PIC32MM&lt;/a&gt;, along with the &lt;a href=&quot;https://jaycarlson.net/pf/nxp-lpc811/&quot;&gt;LPC811&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I also like the flexibility that &lt;a href=&quot;https://jaycarlson.net/pf/atmel-microchip-sam-d10/&quot;&gt;Atmel&lt;/a&gt;, &lt;a href=&quot;https://jaycarlson.net/pf/cypress-psoc-4000s/&quot;&gt;Cypress&lt;/a&gt;, &lt;a href=&quot;https://jaycarlson.net/pf/infineon-xmc1100/&quot;&gt;Infineon&lt;/a&gt;, and &lt;a href=&quot;https://jaycarlson.net/pf/renesas-rl-78/&quot;&gt;Renesas&lt;/a&gt; have — they use arrayed “serial units,” each can morph into a UART, SPI, or I&lt;sup&gt;2&lt;/sup&gt;C peripheral. Cypress and Infineon have two; Atmel and Renesas have three (plus a fourth I&lt;sup&gt;2&lt;/sup&gt;C-slave-only interface for Renesas).&lt;/p&gt;
&lt;p&gt;The odd ones out were the &lt;a href=&quot;https://jaycarlson.net/pf/microchip-pic32mm/&quot;&gt;PIC32MM&lt;/a&gt;, the &lt;a href=&quot;https://jaycarlson.net/pf/sanyo-on-semiconductor-lc87/&quot;&gt;LC87&lt;/a&gt;, and the &lt;a href=&quot;https://jaycarlson.net/pf/texas-instruments-msp430fr/&quot;&gt;MSP430&lt;/a&gt;: none of these MCUs have an I&lt;sup&gt;2&lt;/sup&gt;C peripheral — a curious omission in an era of SMBus-complaint digital sensors everywhere. And unlike the 8051’s quasi-bidirectional GPIO configuration, none of these MCUs are well-suited to bit-banging I&lt;sup&gt;2&lt;/sup&gt;C (though it’s obviously possible by switching data-direction).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;vc_tta-panel&quot; id=&quot;1508136887413-c1e94ebd-c312&quot; data-vc-content=&quot;.vc_tta-panel-body&quot;&gt;

&lt;div class=&quot;vc_tta-panel-body&quot;&gt;
&lt;div class=&quot;vc_progress_bar wpb_content_element vc_progress-bar-color-bar_grey&quot;&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel tinyAVR &lt;span class=&quot;vc_label_units&quot;&gt;20 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel megaAVR &lt;span class=&quot;vc_label_units&quot;&gt;8 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel SAM D10 &lt;span class=&quot;vc_label_units&quot;&gt;8 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Cypress PSoC 4000S &lt;span class=&quot;vc_label_units&quot;&gt;0 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KE04 &lt;span class=&quot;vc_label_units&quot;&gt;12 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KL03 &lt;span class=&quot;vc_label_units&quot;&gt;4 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Holtek HT66 &lt;span class=&quot;vc_label_units&quot;&gt;8 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Infineon XMC1100 &lt;span class=&quot;vc_label_units&quot;&gt;6 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC16 &lt;span class=&quot;vc_label_units&quot;&gt;24 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC24 &lt;span class=&quot;vc_label_units&quot;&gt;0 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC32MM &lt;span class=&quot;vc_label_units&quot;&gt;11 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton N76 &lt;span class=&quot;vc_label_units&quot;&gt;8 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton M051 &lt;span class=&quot;vc_label_units&quot;&gt;8 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;NXP LPC811 &lt;span class=&quot;vc_label_units&quot;&gt;0 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Renesas RL78 &lt;span class=&quot;vc_label_units&quot;&gt;6 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Sanyo LC87 &lt;span class=&quot;vc_label_units&quot;&gt;20 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Silicon Labs EFM8 &lt;span class=&quot;vc_label_units&quot;&gt;20 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM8 &lt;span class=&quot;vc_label_units&quot;&gt;7 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM32F0 &lt;span class=&quot;vc_label_units&quot;&gt;16 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;STC STC8 &lt;span class=&quot;vc_label_units&quot;&gt;15 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;TI MSP430FR &lt;span class=&quot;vc_label_units&quot;&gt;8 Channels&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;wpb_text_column wpb_content_element&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;
&lt;p&gt;All the reviewed parts had an ADC except the PSoC 4000S, LPC811, and the Microchip PIC24 (though these peripherals are available on more expensive members of this family).&lt;/p&gt;
&lt;p&gt;Most of the 8 and 16-bit parts had 10-bit ADCs, while the 32-bit parts had 12-bit resolution. Some 8-bit vendors offered 12-bit (Holtek HT66, STCmicro STC8), but the stand-out is the Silicon Labs EFM8, which has a 14-bit ADC — the highest resolution in our round up — and also has 20 channels, tying the tinyAVR and Sanyo LC87.&lt;/p&gt;
&lt;p&gt;The PIC16 brought in the highest channel count — it has 24 total inputs and can sample at 470 ksps.&lt;/p&gt;
&lt;p&gt;For speed, the EFM8 brings 900 ksps to the table — beat out only by ST and Infineon whose ADCs can clock at up to 1 Msps.&lt;/p&gt;
&lt;p&gt;Other vendors turned in results hovering in the 500-800 ksps range.&lt;/p&gt;
&lt;p&gt;The Atmel ADCs were the slowest, with the megaAVR’s sluggish 15 ksps (no “0” missing) far below everyone else. Even their 32-bit ARM only turned in a 350 ksps reading — the slowest ARM part tested.&lt;/p&gt;
&lt;h2&gt;DAC&lt;/h2&gt;
&lt;p&gt;In this price range, it is unusual to find parts with DACs, but in this microcontroller review, five parts had this functionality. The &lt;a href=&quot;https://jaycarlson.net/pf/silicon-labs-efm8/&quot;&gt;EFM8&lt;/a&gt; has a two-channel 12-bit DAC — the highest resolution in my round-up. The &lt;a href=&quot;https://jaycarlson.net/pf/atmel-microchip-sam-d10/&quot;&gt;SAM D10&lt;/a&gt; has a single-channel 10-bit DAC, while the &lt;a href=&quot;https://jaycarlson.net/pf/atmel-microchip-tinyavr-1-series/&quot;&gt;tinyAVR 1-Series&lt;/a&gt; part has three channels with 8-bit resolution. The &lt;a href=&quot;https://jaycarlson.net/pf/microchip-pic16-five-digit-enhanced/&quot;&gt;PIC16&lt;/a&gt; has a basic, 5-bit DAC (oddly, with two separate outputs — even though they’re generated from the same DAC). The &lt;a href=&quot;https://jaycarlson.net/pf/freescale-nxp-ke04/&quot;&gt;Freescale KE04&lt;/a&gt; also had a basic 6-bit DAC that is pumped directly into a comparator (where these low-speed, low-resolution DACs are usually used).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;vc_row-5cd272d499da0&quot; class=&quot;vc_row wpb_row vc_row-fluid&quot;&gt;
&lt;div class=&quot;wpb_column vc_column_container vc_col-sm-12&quot;&gt;
&lt;div class=&quot;vc_column-inner&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;
&lt;div class=&quot;vc_progress_bar wpb_content_element vc_progress-bar-color-bar_grey&quot;&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel tinyAVR &lt;span class=&quot;vc_label_units&quot;&gt;1.0 x&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel megaAVR &lt;span class=&quot;vc_label_units&quot;&gt;2.1 x&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel SAM D10 &lt;span class=&quot;vc_label_units&quot;&gt;4.5 x&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Cypress PSoC 4000S &lt;span class=&quot;vc_label_units&quot;&gt;9.2 x&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KE04 &lt;span class=&quot;vc_label_units&quot;&gt;16.4 x&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KL03 &lt;span class=&quot;vc_label_units&quot;&gt;14.7 x&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Holtek HT66 &lt;span class=&quot;vc_label_units&quot;&gt;1.0 x&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Infineon XMC1100 &lt;span class=&quot;vc_label_units&quot;&gt;23.6 x&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC16 &lt;span class=&quot;vc_label_units&quot;&gt;8.0 x&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC24 &lt;span class=&quot;vc_label_units&quot;&gt;19.4 x&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC32MM &lt;span class=&quot;vc_label_units&quot;&gt;66.0 x&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton N76 &lt;span class=&quot;vc_label_units&quot;&gt;3.2 x&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton M051 &lt;span class=&quot;vc_label_units&quot;&gt;10.2 x&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;NXP LPC811 &lt;span class=&quot;vc_label_units&quot;&gt;27.0 x&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Renesas RL78 &lt;span class=&quot;vc_label_units&quot;&gt;10.5 x&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Sanyo LC87 &lt;span class=&quot;vc_label_units&quot;&gt;4.2 x&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Silicon Labs EFM8 &lt;span class=&quot;vc_label_units&quot;&gt;3.9 x&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM8 &lt;span class=&quot;vc_label_units&quot;&gt;2.6 x&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM32F0 &lt;span class=&quot;vc_label_units&quot;&gt;27.0 x&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;STC STC8 &lt;span class=&quot;vc_label_units&quot;&gt;1.0 x&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;TI MSP430FR &lt;span class=&quot;vc_label_units&quot;&gt;15.3 x&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;wpb_text_column wpb_content_element&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;
&lt;h2 id=&quot;parametrics&quot;&gt;Parametric Reach&lt;/h2&gt;
&lt;p&gt;One of the major themes of this microcontroller selection guide is to show how easy it can be to get going with different parts, and comfortably jump around among ecosystems — picking the best part for the job.&lt;/p&gt;
&lt;p&gt;But for casual hobbyists who may live far away from major distributors, and professionals who have to meet tight timelines, sometimes there’s no time to play around with new architectures.&lt;/p&gt;
&lt;p&gt;If you want to commit to a single architecture, it’s important to know which one gives you the most headroom to move up. I created a fictious “times better” score by comparing the the part tested with the best part available in the same ecosystem — this usually means fairly comparable peripheral programming, along with identical development tools. I multiplied the core speed, package size, flash, and RAM capacities together, ratioed the two parts, and then took the quartic root. Essentially, if every parameter is double, it is considered “2.0 x” as powerful.&lt;/p&gt;
&lt;p&gt;Surprisingly, the &lt;a href=&quot;https://jaycarlson.net/pf/microchip-pic32mm/&quot;&gt;PIC32&lt;/a&gt; came out on top: there are four PIC32 families — the PIC32MX was the first; it’s the mainstream core that runs up to 120 MHz, with up to 512 KB of flash and 128 KB of RAM.&lt;/p&gt;
&lt;p&gt;But it’s the newer PIC32MZ that reaches even higher: up to 252 MHz, with 2 MB of flash, and — with the DA version of the part — includes 32 MB of onboard DDR2 memory. With the MZ-DA, you can build complex graphical apps without needing an application processor running Linux (and the PCB / BSP complexity that arrives with that). It’s essentially the PIC32 version of the Arm Cortex-M7.&lt;/p&gt;
&lt;p&gt;Next up, the &lt;a href=&quot;https://jaycarlson.net/pf/st-stm32f0/&quot;&gt;STM32&lt;/a&gt; line. The STM32F0 has a famous big brother — the STM32F4 — that’s one of the most capable Arm Cortex parts ever built. Several versions run up to 180 MHz, with 2 MB of flash and up to 364 KB of RAM (in the case of the STM32F469).&lt;/p&gt;
&lt;p&gt;But the brand-new STM32F7 — part of the new Cortex-M7 line of parts — goes even further, with 216 MHz maximum operating frequency, 2 MB of flash, and 512 KB of RAM.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://jaycarlson.net/pf/nxp-lpc811/&quot;&gt;LPC811&lt;/a&gt; — one of the lower-performing parts in my round-up — has several big sisters, including the LPC546xx series, a giant Cortex-M4 with 220 MHz max frequency, 512 KB of flash, 200 KB of RAM, in up to 208-pin packages.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://jaycarlson.net/pf/atmel-microchip-tinyavr-1-series/&quot;&gt;tinyAVR&lt;/a&gt; in this review has very little headroom — these devices top out at 16 KB of flash, 2 KB of RAM, 20 MHz, and 24-pin QFN packages; however, 32 KB tinyAVR parts are soon to be released.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://jaycarlson.net/pf/atmel-microchip-megaavr/&quot;&gt;megaAVR&lt;/a&gt; has a bit of reach in pinning and memory. The ATmega3290 keeps the 20 MHz clock speed but bumps up the pin-count to 100 pins. There are many megaAVR parts with 64 KB of flash and 4 K of RAM, as this part has. Some megaAVR parts have as much as 16 KB of RAM or 256 KB of flash. Oddly, Atmel can’t seem to combine these specs — there is no 100-pin, 256 KB flash, 16 KB RAM megaAVR that is in current production.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://jaycarlson.net/pf/atmel-microchip-sam-d10/&quot;&gt;SAM D10&lt;/a&gt; extends up to the SAM D21, which maintains its 48 MHz clock speed, but increases flash up to 256 KB, with up to 32 K of RAM, and sizable 64-pin package options.&lt;/p&gt;
&lt;p&gt;There’s a lot of headroom left in the SAM Arm microcontroller ecosystem, but if you leave the D1x/D2x line of parts, you’ll lose familiarity with some of the peripherals (especially the communications interfaces). Having said that, the Arm Cortex-M7-based ATSAMS70 will get you up to 300 MHz of performance, 2 MB of flash, and 384 KB of RAM, in up to 144-pin packages. The older A revision parts are deeply discounted, including this 64-pin 1 MB flash part for $5.14 on DigiKey.&lt;/p&gt;
&lt;p&gt;With the &lt;a href=&quot;https://jaycarlson.net/pf/cypress-psoc-4000s/&quot;&gt;PSoC 4000S&lt;/a&gt;, you’re at rock-bottom in the PSoC ecosystem, so the only direction is up — the PSoC 5 devices run at 80 MHz, with up to 256 KB of flash and 64 KB of RAM in 100-pin packages. These parts come with all the PSOC goodness that Cypress users love — reconfigurable digital logic, lots of analog features, and excellent capacitive-touch sensing.&lt;/p&gt;
&lt;p&gt;The just-around-the-corner PSoC 6 promises to bring even more performance to the ecosystem, with the PSoC 63 running a 150 MHz Arm Cortex-M4F, 1 MB of flash, 288 KB of RAM, integrated BTLE connectivity, and 100+ pin packages.&lt;/p&gt;
&lt;p&gt;The Freescale &lt;a href=&quot;https://jaycarlson.net/pf/freescale-nxp-ke04/&quot;&gt;KE04&lt;/a&gt; and &lt;a href=&quot;https://jaycarlson.net/pf/freescale-nxp-kinetis-kl03/&quot;&gt;KL03&lt;/a&gt; are both entry-level devices in the E and L families within the Kinetis system. The E family has good reach up to the 168 MHz KE1x, with up to 512 KB of flash, 64 KB of RAM, and up to 100-pin packaging. Unfortunately, this is a fairly different process than the KE04 reviewed here — there’s no Processor Expert support, and the communications peripherals are quite different than those in the lower-end part. It retains its 5V operating range, which segments it into the E family.&lt;/p&gt;
&lt;p&gt;The KL03 extends up to the KL28 — a 72 MHz Cortex-M0+ with 512 KB of flash, 128 KB of RAM, and up to 121-pin BGA packages available. Unlike the E series, the KL series has much more uniform peripherals across its range of devices.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://jaycarlson.net/pf/holtek-ht-66/&quot;&gt;Holtek HT-66&lt;/a&gt; has no real latitude above the HT66F0185 — but as mentioned on the review page, there are tons of application-specific products Holtek makes that use this core.&lt;/p&gt;
&lt;p&gt;The Infineon &lt;a href=&quot;https://jaycarlson.net/pf/infineon-xmc1100/&quot;&gt;XMC1000&lt;/a&gt; family extends up to the XMC1400, with 200 KB of flash, 16 K of RAM, a slightly-faster 48 MHz core clock, and a 64-pin package. Moving out of the XMC1000 ecosystem, the XMC4000 keeps the XMC1000 peripherals and swaps out the core for a Cortex-M4F, running up to 144 MHz, with 2 MB of flash, 352 KB of RAM, and up to 196-pin packaging options.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://jaycarlson.net/pf/microchip-pic16-five-digit-enhanced/&quot;&gt;PIC16&lt;/a&gt; tops out in the 64-pin PIC16F19197 device, with 56 KB of flash (well, 32 K words, because PIC), 4 K of RAM. I’ll include PIC18 devices, though, as they’re targetted with the same compiler, programmed with the same debugger, and share peripherals and architectural decisions.&lt;/p&gt;
&lt;p&gt;PIC18 devices can reach up to the PIC18F97J60 — a 100-pin beast with 128 KB of flash (64 K words), and almost 4K of RAM. While most of these 8-bit parts have similar peripherals across the board, I must note the Ethernet MAC and PHY present in the PIC18F97J60. While many higher-end microcontrollers have an Ethernet MAC, this low-end PIC18 part is one of the only microcontrollers — at any price — to also integrate a PHY &lt;sup id=&quot;footnote_plugin_tooltip_7&quot; class=&quot;footnote_plugin_tooltip_text&quot; onclick=&quot;footnote_moveToAnchor('footnote_plugin_reference_7');&quot;&gt;7&lt;/sup&gt;&lt;span class=&quot;footnote_tooltip&quot; id=&quot;footnote_plugin_tooltip_text_7&quot;&gt;The only other mainstream MCU that has an integrated Ethernet PHY is the $14 Tiva-C TM4C129x, a giant 128-pin 120 MHz Arm Cortex-M4 from Texas Instruments. There are a few other (albeit odd) choices out there: Freescale’s legacy ColdFire microcontrollers include the MCF5223X, which has an integrated Ethernet PHY. Fabless designer ASIX manufacturers the AX11015, a 100 MHz 8051 with an integrated Ethernet PHY&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;The PIC24FJ1024GA610 supports up to a 1024 KB of flash, 32 KB of RAM, and a 32 MHz run speed — though there are dsPIC devices, like the dsPIC33EP512GM604, with up to 140 MHz operating frequency, 512 KB of flash, and 48 KB of RAM.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://jaycarlson.net/pf/nuvoton-n76/&quot;&gt;Nuvoton N76&lt;/a&gt; can look up to the 40 MHz W79E658A, with 128 KB of flash, 100-pin packaging, and 1.25K of RAM.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://jaycarlson.net/pf/nuvoton-m051/&quot;&gt;Nuvoton M051&lt;/a&gt; has a few Cortex-M4 big sisters: the M505 has 2 MB of embedded SPI flash (sounds slow to me), and 128 KB of RAM, runs at 100 MHz, and comes in a 48-pin package. Nuvoton hasn’t released the M487 yet, but it promises a 192 MHz CPU with 512 KB of flash, 160 KB of RAM, and at least 80-pin package options (though Nuvoton hasn’t unveiled all details yet).&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jaycarlson.net/pf/renesas-rl-78/&quot;&gt;Renesas RL-78&lt;/a&gt; extends up to the R5F101SLAFB, with 128-pin package, 512 KB of flash, 32 KB of RAM, and a slightly-faster 32 MHz clock speed.&lt;/p&gt;
&lt;p&gt;Sanyo’s LC87 extend up to 100-pin 256 KB parts with 12 KB of RAM, and an 18 MHz clock with the LC87F7NP6AUE.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://jaycarlson.net/pf/silicon-labs-efm8/&quot;&gt;Silicon Labs EFM8LB1&lt;/a&gt; is the top-of-the-line part in the EFM8 family — these top out at 64 KB of flash, 4.25 KB of RAM, and a relatively-small 32-pin package.&lt;/p&gt;
&lt;p&gt;Having said that, you can stay in the Silicon Labs 8051 family with the C8051F120 — a 100 MHz 8051 with 128 KB of flash, 8.25 KB of RAM, and a 100-pin microcontroller. It’s an older part, but it’s still supported in Simplicity Studio (though not in Simplicity Configurator).&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://jaycarlson.net/pf/stcmicro-stc8/&quot;&gt;STC8&lt;/a&gt; I tested is the top-of-the-line part in their catalog.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://jaycarlson.net/pf/texas-instruments-msp430fr/&quot;&gt;MSP430&lt;/a&gt; extends up to the MSP430F6779, with 512 KB of flash, 32 KB of RAM, and 128-pin packaging.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;ecosystem&quot; class=&quot;vc_row wpb_row vc_row-fluid&quot;&gt;
&lt;div class=&quot;wpb_column vc_column_container vc_col-sm-12&quot;&gt;
&lt;div class=&quot;vc_column-inner&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;

&lt;div class=&quot;wpb_text_column wpb_content_element&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;
&lt;div id=&quot;dev-ecosystem&quot; class=&quot;title-xlarge&quot;&gt;Development Ecosystem&lt;/div&gt;
&lt;p&gt;The development ecosystem of a microcontroller has a profound impact on productivity and ease of use of the part, and these IDEs, peripheral libraries, dev boards, and debuggers varied wildly among the microcontrollers reviewed here.&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;wpb_text_column wpb_content_element&quot; id=&quot;eclipse&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;&lt;img data-attachment-id=&quot;1290&quot; data-permalink=&quot;https://jaycarlson.net/microcontrollers/ccstudio_2017-10-17_21-12-44/&quot; data-orig-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/ccstudio_2017-10-17_21-12-44.png&quot; data-orig-size=&quot;1238,917&quot; data-comments-opened=&quot;1&quot; data-image-meta=&quot;{&amp;quot;aperture&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;credit&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;camera&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;caption&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;created_timestamp&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;copyright&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;focal_length&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;iso&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;shutter_speed&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;orientation&amp;quot;:&amp;quot;0&amp;quot;}&quot; data-image-title=&quot;ccstudio_2017-10-17_21-12-44&quot; data-image-description=&quot;&quot; data-medium-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/ccstudio_2017-10-17_21-12-44-300x222.png&quot; data-large-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/ccstudio_2017-10-17_21-12-44-1024x758.png&quot; class=&quot;size-full wp-image-1290&quot; src=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/ccstudio_2017-10-17_21-12-44.png?cbc196&amp;amp;cbc196&quot; alt=&quot;&quot; width=&quot;1238&quot; height=&quot;917&quot; srcset=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/ccstudio_2017-10-17_21-12-44.png 1238w, https://jaycarlson.net/wp-content/uploads/2017/07/ccstudio_2017-10-17_21-12-44-300x222.png 300w, https://jaycarlson.net/wp-content/uploads/2017/07/ccstudio_2017-10-17_21-12-44-768x569.png 768w, https://jaycarlson.net/wp-content/uploads/2017/07/ccstudio_2017-10-17_21-12-44-1024x758.png 1024w&quot; sizes=&quot;(max-width: 1238px) 100vw, 1238px&quot;/&gt;Eclipse-based development environments, such as Code Composer Studio from Texas Instruments, provide a complete text editor, toolchain, and debugging system in one application — plus many vendors choose to extend Eclipse with vendor-specific features, such as the ULP Advisor that Texas Instruments bundles to help developers get active- and sleep-mode current down to the minimum.
&lt;h2&gt;Eclipse&lt;/h2&gt;
&lt;p&gt;Eclipse is a Java-based IDE originally developed at IBM to develop in Java. But since 2001, it has been an open-source project built by the Eclipse Foundation.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.eclipse.org/cdt/&quot;&gt;Eclipse CDT&lt;/a&gt; provides C/C++ tooling, and has taken off like wildfire in the embedded world — starting in the 32-bit ARM ecosystems, but migrating down to 16- and 8-bit parts as well. In fact, almost all the major microcontrollers here are programmed in an IDE based on Eclipse:&lt;/p&gt;
&lt;p&gt;Other than DAVE, CooCox, and e&lt;sup&gt;2&lt;/sup&gt; studio (which all only run on Windows), all of these toolchains have cross-platform support for Windows, macOS, and Linux.&lt;/p&gt;
&lt;img data-attachment-id=&quot;1300&quot; data-permalink=&quot;https://jaycarlson.net/microcontrollers/eclipse_2017-10-19_16-57-35/&quot; data-orig-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/eclipse_2017-10-19_16-57-35.png&quot; data-orig-size=&quot;1078,899&quot; data-comments-opened=&quot;1&quot; data-image-meta=&quot;{&amp;quot;aperture&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;credit&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;camera&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;caption&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;created_timestamp&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;copyright&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;focal_length&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;iso&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;shutter_speed&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;orientation&amp;quot;:&amp;quot;0&amp;quot;}&quot; data-image-title=&quot;eclipse_2017-10-19_16-57-35&quot; data-image-description=&quot;&quot; data-medium-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/eclipse_2017-10-19_16-57-35-300x250.png&quot; data-large-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/eclipse_2017-10-19_16-57-35-1024x854.png&quot; class=&quot;size-full wp-image-1300&quot; src=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/eclipse_2017-10-19_16-57-35.png?cbc196&amp;amp;cbc196&quot; alt=&quot;&quot; width=&quot;1078&quot; height=&quot;899&quot; srcset=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/eclipse_2017-10-19_16-57-35.png 1078w, https://jaycarlson.net/wp-content/uploads/2017/07/eclipse_2017-10-19_16-57-35-300x250.png 300w, https://jaycarlson.net/wp-content/uploads/2017/07/eclipse_2017-10-19_16-57-35-768x640.png 768w, https://jaycarlson.net/wp-content/uploads/2017/07/eclipse_2017-10-19_16-57-35-1024x854.png 1024w&quot; sizes=&quot;(max-width: 1078px) 100vw, 1078px&quot;/&gt;Recent versions of Eclipse, like the 4.6.3 Neon release that System Workbench for STM32 uses, provide good dark theme support, as well as the incredibly snappy pop-up function browser that shows you the full source code of any function you hover over.
&lt;p&gt;Main features of Eclipse CDT include multi-project workspaces, debugging with tons of introspection windows, support for different toolchains, plus a syntax-highlighting text editor with content assist text completion, macro definition browsing and highlighting, code snippets, and tons of refactoring capabilities.&lt;/p&gt;
&lt;p&gt;The code editor in Eclipse is definitely a stand-out among IDEs tested — especially if you’re coming from other IDEs. Everything is completely customizable, very snappy, and full of features. The pop-up “Source Hover” is one of my favorite features: hover over a function, and the source of the function (including any docs) will pop-up immediately. If you’re still not sure about something, move your mouse down into the pop-up window and it turns into a scrollable editor window, allowing you to see the entire contents of the function (and copy-and-paste from it). One feature request: I would &lt;em&gt;love&lt;/em&gt; to see Ctrl-Click working from &lt;em&gt;within &lt;/em&gt;this pop-up, and it would also be amazing to see editing capability, too.&lt;/p&gt;
&lt;h3&gt;Vendor Customizations&lt;/h3&gt;
&lt;p&gt;The &lt;a href=&quot;https://gnu-mcu-eclipse.github.io/&quot;&gt;GNU MCU Eclipse plug-ins&lt;/a&gt; have made it trivial to set up an Eclipse-based workflow when working on many ARM processors; under the hood, some of these IDEs are basically just pre-packaged open-source components with a nice splash screen. This is definitely the case for Kinetis Design Studio, MCUXpresso, and System Workbench for STM32 (which didn’t even bother changing the Eclipse logo). There’s nothing wrong with that — it’s far less jarring to move between stock Eclipse IDEs, and if you’re short on hard drive space, you could probably install and configure plug-ins to essentially combine many of these IDEs together.&lt;/p&gt;
&lt;p&gt;On the other hand, some vendors had to go through great lengths to get an Eclipse-based environment working with their parts. Silicon Labs had to write a debug interface from scratch that could communicate with their tools (and work with Keil C51 binaries), custom property panes for managing the build system — along with packaging a patched WINE system that can run Keil C51 seamlessly on macOS and Linux (and from my testing, they pulled it off).&lt;/p&gt;
&lt;img data-attachment-id=&quot;1287&quot; data-permalink=&quot;https://jaycarlson.net/microcontrollers/coide_2017-10-17_13-59-11/&quot; data-orig-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/CoIDE_2017-10-17_13-59-11.png&quot; data-orig-size=&quot;1073,708&quot; data-comments-opened=&quot;1&quot; data-image-meta=&quot;{&amp;quot;aperture&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;credit&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;camera&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;caption&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;created_timestamp&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;copyright&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;focal_length&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;iso&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;shutter_speed&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;orientation&amp;quot;:&amp;quot;0&amp;quot;}&quot; data-image-title=&quot;CoIDE_2017-10-17_13-59-11&quot; data-image-description=&quot;&quot; data-medium-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/CoIDE_2017-10-17_13-59-11-300x198.png&quot; data-large-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/CoIDE_2017-10-17_13-59-11-1024x676.png&quot; class=&quot;size-full wp-image-1287&quot; src=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/CoIDE_2017-10-17_13-59-11.png?cbc196&amp;amp;cbc196&quot; alt=&quot;&quot; width=&quot;1073&quot; height=&quot;708&quot; srcset=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/CoIDE_2017-10-17_13-59-11.png 1073w, https://jaycarlson.net/wp-content/uploads/2017/07/CoIDE_2017-10-17_13-59-11-300x198.png 300w, https://jaycarlson.net/wp-content/uploads/2017/07/CoIDE_2017-10-17_13-59-11-768x507.png 768w, https://jaycarlson.net/wp-content/uploads/2017/07/CoIDE_2017-10-17_13-59-11-1024x676.png 1024w&quot; sizes=&quot;(max-width: 1073px) 100vw, 1073px&quot;/&gt;CoIDE has a super-simple target configuration property pane, and Keil µVision-style buttons for building and rebuilding projects.
&lt;p&gt;In fact, one IDE — CoIDE — is so far removed from Eclipse, I hesitated to even mention it in this list. CooCox essentially stripped Eclipse down to its base, and built up CoIDE saving little more than the Eclipse shell.&lt;/p&gt;
&lt;p&gt;What results is an IDE that is extremely easy to use — great for students and hobbyists who many find the Eclipse project properties pane to be… well, a pain. This comes at the expense of flexibility, however — tons of the debugging options and windows are missing, and you can only open one project at a time. Sometimes the IDE does thing you may not want. For example, every folder you create in a project is automatically added to the list of project source files &lt;em&gt;as well as include files&lt;/em&gt;. I imagine this will quickly cause filename conflicts in large projects (which CoIDE doesn’t seem built for).&lt;/p&gt;
&lt;img data-attachment-id=&quot;497&quot; data-permalink=&quot;https://jaycarlson.net/microcontrollers/e2studio_2017-07-23_14-13-19/&quot; data-orig-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/e2studio_2017-07-23_14-13-19.png&quot; data-orig-size=&quot;1420,1175&quot; data-comments-opened=&quot;1&quot; data-image-meta=&quot;{&amp;quot;aperture&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;credit&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;camera&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;caption&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;created_timestamp&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;copyright&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;focal_length&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;iso&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;shutter_speed&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;orientation&amp;quot;:&amp;quot;0&amp;quot;}&quot; data-image-title=&quot;e2studio_2017-07-23_14-13-19&quot; data-image-description=&quot;&quot; data-medium-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/e2studio_2017-07-23_14-13-19-300x248.png&quot; data-large-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/e2studio_2017-07-23_14-13-19-1024x847.png&quot; class=&quot;size-full wp-image-497&quot; src=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/e2studio_2017-07-23_14-13-19.png?cbc196&amp;amp;cbc196&quot; alt=&quot;&quot; width=&quot;1420&quot; height=&quot;1175&quot; srcset=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/e2studio_2017-07-23_14-13-19.png 1420w, https://jaycarlson.net/wp-content/uploads/2017/07/e2studio_2017-07-23_14-13-19-300x248.png 300w, https://jaycarlson.net/wp-content/uploads/2017/07/e2studio_2017-07-23_14-13-19-768x635.png 768w, https://jaycarlson.net/wp-content/uploads/2017/07/e2studio_2017-07-23_14-13-19-1024x847.png 1024w&quot; sizes=&quot;(max-width: 1420px) 100vw, 1420px&quot;/&gt;When building out the DMX-512 demo for the RL-78, e&lt;sup&gt;2&lt;/sup&gt; studio’s Stack Analysis tool helped me see where my stack-heavy calls were.
&lt;p&gt;Vendors like Freescale decided to stop heavily customizing Eclipse with their own proprietary debugging system (which they did in &lt;a href=&quot;https://www.nxp.com/pages/codewarrior-for-mcus-eclipse-ide-coldfire.-56800-e-dsc-kinetis.-nxp-56xx-rs08-s08-s12z-v10.7:CW-MCU10&quot;&gt;CodeWarrior&lt;/a&gt;), and switch to these open-source plug-ins. I have mixed feelings about this change, as CodeWarrior seemed much faster at starting and stopping debug sessions than the GDB-based system everyone uses these days.&lt;/p&gt;
&lt;p&gt;On performance overall, recent versions of Eclipse (Mars or better) seem to be much snappier than the &lt;a href=&quot;https://jaxenter.com/eclipse-4-2-performance-slated-will-the-community-come-out-in-force-104905.html&quot;&gt;disastrous Juno release&lt;/a&gt;, so if it felt slow and bloated last time you tried it, you may want to give it another shot.&lt;/p&gt;
&lt;p&gt;Oxygen (4.7.0) was just released in June, so the newest IDEs — System Workbench, MCUXpresso, and Code Composer Studio — and are still on Neon (4.5). Other Eclipse-based IDEs are on older versions — with Kinetis Design Studio and DAVE being on the oldest release (Luna SR2 — 4.4.2).&lt;/p&gt;
&lt;img data-attachment-id=&quot;1292&quot; data-permalink=&quot;https://jaycarlson.net/microcontrollers/studio_2017-10-17_23-18-59/&quot; data-orig-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/studio_2017-10-17_23-18-59.png&quot; data-orig-size=&quot;1229,903&quot; data-comments-opened=&quot;1&quot; data-image-meta=&quot;{&amp;quot;aperture&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;credit&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;camera&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;caption&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;created_timestamp&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;copyright&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;focal_length&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;iso&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;shutter_speed&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;orientation&amp;quot;:&amp;quot;0&amp;quot;}&quot; data-image-title=&quot;studio_2017-10-17_23-18-59&quot; data-image-description=&quot;&quot; data-medium-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/studio_2017-10-17_23-18-59-300x220.png&quot; data-large-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/studio_2017-10-17_23-18-59-1024x752.png&quot; class=&quot;size-full wp-image-1292&quot; src=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/studio_2017-10-17_23-18-59.png?cbc196&amp;amp;cbc196&quot; alt=&quot;&quot; width=&quot;1229&quot; height=&quot;903&quot; srcset=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/studio_2017-10-17_23-18-59.png 1229w, https://jaycarlson.net/wp-content/uploads/2017/07/studio_2017-10-17_23-18-59-300x220.png 300w, https://jaycarlson.net/wp-content/uploads/2017/07/studio_2017-10-17_23-18-59-768x564.png 768w, https://jaycarlson.net/wp-content/uploads/2017/07/studio_2017-10-17_23-18-59-1024x752.png 1024w&quot; sizes=&quot;(max-width: 1229px) 100vw, 1229px&quot;/&gt;Simplicity Studio has a beautiful and functional register view that allows you to interact with registers using names and drop-down lists — this saves a lot of time when tracking down problems — no datasheet required.
&lt;h3&gt;Debugging in Eclipse&lt;/h3&gt;
&lt;p&gt;Eclipse — across nearly all vendors — provided the best out-of-the-box experience out of all the IDEs I tested. Projects support multiple debug configurations that allow you to use different debuggers and target configurations. Out of the box, you get a source code view with interactive breakpoints, a memory browser, a disassembly view, and a list of core CPU registers.&lt;/p&gt;
&lt;p&gt;Debugging in Eclipse is relatively unified across the platforms — the biggest differences are the supported debuggers, and the custom debugging windows — especially the peripheral register view.&lt;/p&gt;
&lt;p&gt;In my opinion, the peripheral register viewer is one of the most important debug windows — even more important than the disassembly view. My favorite register viewers are the ones used in TI’s Code Composer Studio and SiLabs’ Simplicity Studio. These have a contiguous list of all registers, organized in a tree view, with detailed descriptions of each register’s value, with combo-box selectors of all the values. Simplicity Studio edges out Code Composer Studio by naming all the constants. This is sometimes unnecessary (like: SYSCLK_DIV_12 (System clock divided by 12) ), but definitely keeps your eyes out of the datasheet for the part.&lt;/p&gt;
&lt;p&gt;Kinetis Design Studio uses &lt;a href=&quot;http://embsysregview.sourceforge.net/&quot;&gt;EmbSysRegView&lt;/a&gt; — an open-source Eclipse plugin — which provides similar functionality. This uses &lt;a href=&quot;http://www.keil.com/pack/doc/CMSIS/SVD/html/index.html&quot;&gt;SVD&lt;/a&gt;, a standardized set of tools for generating header files and descriptions of such.&lt;/p&gt;
&lt;p&gt;System Workbench for STM32 has a similar view, but doesn’t automatically fetch the register values. This may not be a bad thing, as ARM microcontrollers tend to have a lot more register addresses than 8-bit parts, but it still feels a bit clunkier.&lt;/p&gt;
&lt;p&gt;MCUXpresso and Infineon DAVE have a somewhat-strange two-step process — you select the peripheral in one view, and it creates a memory rendering. Registers are broken out logically into one or more bits, but the drop-down lists don’t have named enumerations that describe what each bit-pattern does.&lt;/p&gt;
&lt;p&gt;DAVE has exactly the same plugin as MCUXpresso, but it seems buggy — it doesn’t always work. Hopefully this gets fixed in a future version, because is severely limits the usability of the debug system.&lt;/p&gt;
&lt;p&gt;CoIDE and &lt;span&gt;e&lt;/span&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;span&gt;studio&lt;/span&gt; both have the worst register views — they simply display a list of the peripheral register whole values, without breaking them up logically or annotating them with text.&lt;/p&gt;
&lt;img data-attachment-id=&quot;498&quot; data-permalink=&quot;https://jaycarlson.net/microcontrollers/e2studio_2017-07-23_16-24-42/&quot; data-orig-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/e2studio_2017-07-23_16-24-42.png&quot; data-orig-size=&quot;1420,1087&quot; data-comments-opened=&quot;1&quot; data-image-meta=&quot;{&amp;quot;aperture&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;credit&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;camera&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;caption&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;created_timestamp&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;copyright&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;focal_length&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;iso&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;shutter_speed&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;orientation&amp;quot;:&amp;quot;0&amp;quot;}&quot; data-image-title=&quot;e2studio_2017-07-23_16-24-42&quot; data-image-description=&quot;&quot; data-medium-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/e2studio_2017-07-23_16-24-42-300x230.png&quot; data-large-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/e2studio_2017-07-23_16-24-42-1024x784.png&quot; class=&quot;wp-image-498 size-full&quot; src=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/e2studio_2017-07-23_16-24-42.png?cbc196&amp;amp;cbc196&quot; alt=&quot;&quot; width=&quot;1420&quot; height=&quot;1087&quot; srcset=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/e2studio_2017-07-23_16-24-42.png 1420w, https://jaycarlson.net/wp-content/uploads/2017/07/e2studio_2017-07-23_16-24-42-300x230.png 300w, https://jaycarlson.net/wp-content/uploads/2017/07/e2studio_2017-07-23_16-24-42-768x588.png 768w, https://jaycarlson.net/wp-content/uploads/2017/07/e2studio_2017-07-23_16-24-42-1024x784.png 1024w&quot; sizes=&quot;(max-width: 1420px) 100vw, 1420px&quot;/&gt;e2 studio has real-time watches of variables; in addition to displaying variable values as a list, they can be plotted over time, or displayed in gimmicky GUI widgets that look ugly.
&lt;h3&gt;Other features&lt;/h3&gt;
&lt;p&gt;Some vendors have gone above and beyond with useful (and not-so-useful) additional views and features. e&lt;sup&gt;2&lt;/sup&gt; studio, despite the pesky peripheral register viewer, has a useful real-time view of variables that update while debugging. I suspect the IDE is periodically breaking the MCU, reading the contents of RAM, and updating the display — but they may have a mechanism for real-time tracing in the RL-78 core.&lt;/p&gt;
&lt;p&gt;This IDE can also show flash and RAM usage — though it’s not plotted as nicely as it is in DAVE, which shows a pie chart of all symbols.&lt;/p&gt;
&lt;p&gt;Specific to ARM parts, all Eclipse IDEs I tested support semihosting, which allows you to print characters to a console window during debugging. The characters are printed through the debugging interface, so there’s no need to configure a UART. MCUXpresso and CoIDE were the easiest Eclipse-based IDEs to configure with semihosting.&lt;/p&gt;
&lt;p&gt;MCUXpresso has nice project properties panes for selecting a C runtime library (it includes Redlib in addition to Newlib Nano) as well as linker settings.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;wpb_text_column wpb_content_element&quot; id=&quot;atmel-studio&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;&lt;img data-attachment-id=&quot;1055&quot; data-permalink=&quot;https://jaycarlson.net/microcontrollers/atmelstudio_2017-08-09_19-41-41-2/&quot; data-orig-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/AtmelStudio_2017-08-09_19-41-41.png&quot; data-orig-size=&quot;1222,947&quot; data-comments-opened=&quot;1&quot; data-image-meta=&quot;{&amp;quot;aperture&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;credit&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;camera&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;caption&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;created_timestamp&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;copyright&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;focal_length&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;iso&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;shutter_speed&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;orientation&amp;quot;:&amp;quot;0&amp;quot;}&quot; data-image-title=&quot;AtmelStudio_2017-08-09_19-41-41&quot; data-image-description=&quot;&quot; data-medium-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/AtmelStudio_2017-08-09_19-41-41-300x232.png&quot; data-large-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/AtmelStudio_2017-08-09_19-41-41-1024x794.png&quot; class=&quot;wp-image-1055 size-full&quot; src=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/AtmelStudio_2017-08-09_19-41-41.png?cbc196&amp;amp;cbc196&quot; alt=&quot;&quot; width=&quot;1222&quot; height=&quot;947&quot; srcset=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/AtmelStudio_2017-08-09_19-41-41.png 1222w, https://jaycarlson.net/wp-content/uploads/2017/07/AtmelStudio_2017-08-09_19-41-41-300x232.png 300w, https://jaycarlson.net/wp-content/uploads/2017/07/AtmelStudio_2017-08-09_19-41-41-768x595.png 768w, https://jaycarlson.net/wp-content/uploads/2017/07/AtmelStudio_2017-08-09_19-41-41-1024x794.png 1024w&quot; sizes=&quot;(max-width: 1222px) 100vw, 1222px&quot;/&gt;Which of these #ifdefs are enabled? Your guess is as good as mine; Atmel Studio is Visual Studio without Microsoft’s excellent IntelliSense engine, making it worse than even Keil µVision in terms of text-editing productivity — and far inferior to the Eclipse- and NetBeans-based IDEs from competitors. I added 6 publicly-visible global variables in this file among others in the project, and none of them appear in the auto-complete list.
&lt;h2&gt;Atmel Studio&lt;/h2&gt;
&lt;img data-attachment-id=&quot;1134&quot; data-permalink=&quot;https://jaycarlson.net/pf/atmel-microchip-sam-d10/atmelstudio_2017-09-16_16-06-08/&quot; data-orig-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/09/AtmelStudio_2017-09-16_16-06-08.png&quot; data-orig-size=&quot;546,232&quot; data-comments-opened=&quot;1&quot; data-image-meta=&quot;{&amp;quot;aperture&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;credit&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;camera&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;caption&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;created_timestamp&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;copyright&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;focal_length&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;iso&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;shutter_speed&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;orientation&amp;quot;:&amp;quot;0&amp;quot;}&quot; data-image-title=&quot;AtmelStudio_2017-09-16_16-06-08&quot; data-image-description=&quot;&quot; data-medium-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/09/AtmelStudio_2017-09-16_16-06-08-300x127.png&quot; data-large-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/09/AtmelStudio_2017-09-16_16-06-08.png&quot; class=&quot;size-full wp-image-1134&quot; src=&quot;https://jaycarlson.net/wp-content/uploads/2017/09/AtmelStudio_2017-09-16_16-06-08.png?cbc196&amp;amp;cbc196&quot; alt=&quot;&quot; width=&quot;546&quot; height=&quot;232&quot; srcset=&quot;https://jaycarlson.net/wp-content/uploads/2017/09/AtmelStudio_2017-09-16_16-06-08.png 546w, https://jaycarlson.net/wp-content/uploads/2017/09/AtmelStudio_2017-09-16_16-06-08-300x127.png 300w&quot; sizes=&quot;(max-width: 546px) 100vw, 546px&quot;/&gt;This error started popping up recently in Atmel Studio — the only solution seems to restart my computer. It’s obviously from an old chunk of code, since it’s referring to the program as “AVR Studio.”
&lt;p&gt;While many vendors have transitioned to Eclipse-based IDEs, Atmel went with a Visual Studio Isolated Shell-based platform starting with AVR Studio 5. I do a ton of .NET and desktop-based C++ development, so I expected to feel right at home in Atmel Studio when I first launched it. Unfortunately, Microsoft calls this product “Visual Studio Isolated Shell” for a reason — it’s simply the &lt;em&gt;shell&lt;/em&gt; of Visual Studio, without any of the meat. The excellent IntelliSense engine that Microsoft spent years perfecting has been replaced by a third-party “Visual Assist” plugin that struggles to identify global variables, evaluate pre-processor definitions, or perform refactoring of items defined outside of the current file. The Toolchain editor is a near-clone of the Eclipse CDT one (no reason to reinvent the wheel), but it’s missing checkboxes and inputs for commonly-used compiler and linker options; one stunning omission is link-time optimization, which even when manually-specified as command parameters, doesn’t seem to work — odd, since Atmel is using a recent version of GCC.&lt;/p&gt;
&lt;p&gt;My biggest issue with Atmel Studio is how incredibly buggy and unstable it has been every time I’ve used it in the last two years. I’m not referring to a specific installation on a specific computer: rather, every single time I’ve installed the software, I’ve fought with AVR Dragon drivers, a bad DLL file in the installer, programmer firmware issues, or, most recently, the software popping up the “Waiting for an operation to complete” message that prevents me from debugging &lt;em&gt;any&lt;/em&gt; Atmel product without restarting my computer. Look, I get it: embedded firmware development is a highly-specialized task, so maintaining software that works reliably for such a small user-base can be challenging. Yet, every other vendor tools tested worked nearly flawlessly.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;wpb_text_column wpb_content_element&quot; id=&quot;mplab&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;&lt;img data-attachment-id=&quot;1299&quot; data-permalink=&quot;https://jaycarlson.net/microcontrollers/javaw_2017-10-19_16-27-14/&quot; data-orig-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/javaw_2017-10-19_16-27-14.png&quot; data-orig-size=&quot;1110,850&quot; data-comments-opened=&quot;1&quot; data-image-meta=&quot;{&amp;quot;aperture&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;credit&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;camera&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;caption&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;created_timestamp&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;copyright&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;focal_length&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;iso&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;shutter_speed&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;orientation&amp;quot;:&amp;quot;0&amp;quot;}&quot; data-image-title=&quot;javaw_2017-10-19_16-27-14&quot; data-image-description=&quot;&quot; data-medium-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/javaw_2017-10-19_16-27-14-300x230.png&quot; data-large-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/javaw_2017-10-19_16-27-14-1024x784.png&quot; class=&quot;size-full wp-image-1299&quot; src=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/javaw_2017-10-19_16-27-14.png?cbc196&amp;amp;cbc196&quot; alt=&quot;&quot; width=&quot;1110&quot; height=&quot;850&quot; srcset=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/javaw_2017-10-19_16-27-14.png 1110w, https://jaycarlson.net/wp-content/uploads/2017/07/javaw_2017-10-19_16-27-14-300x230.png 300w, https://jaycarlson.net/wp-content/uploads/2017/07/javaw_2017-10-19_16-27-14-768x588.png 768w, https://jaycarlson.net/wp-content/uploads/2017/07/javaw_2017-10-19_16-27-14-1024x784.png 1024w&quot; sizes=&quot;(max-width: 1110px) 100vw, 1110px&quot;/&gt;MPLAB X is a NetBeans-based IDE that is comparable to Eclipse in terms of OS support, editor capabilities, and debugging — but it lacks some of the advanced debug configurations and introspection features that make Eclipse so powerful.
&lt;h2&gt;MPLAB X&lt;/h2&gt;
&lt;p&gt;While many vendors were moving from their proprietary Windows-only IDEs to an open-source Eclipse-based workflow, Microchip went a different route when they moved MPLAB 8 to the NetBeans-based MPLAB X in 2012.&lt;/p&gt;
&lt;p&gt;On paper, NetBeans is a lot like Eclipse — it’s a Java-based IDE that was originally built to target Java development — but has since expanded to support C/C++ (along with web-centric languages: HTML, PHP, JavaScript, etc). Like Eclipse, NetBeans is open-source, and cross-platform. Unlike Workspaces in Eclipse, NetBeans doesn’t strongly enforce this paradigm — but it does offer “Project Groups” which has similar functionality. Both have good text-completion capabilities and source introspection; both have macro expansion.&lt;/p&gt;
&lt;p&gt;I’ve used both for years, so I feel comfortable making this subjective claim: NetBeans feels simpler; Eclipse feels more powerful. A lot of this is a result of the UX design choices — Eclipse loads the window with tons of buttons, drop-down menus, and docked panes full of features. The entire IDE’s scale is much more dense than NetBeans.&lt;/p&gt;
&lt;p&gt;Even though NetBeans has a lot of the same features, the UI is sparsely populated with the bare minimum of buttons you need to get your job done. Even the menu bar is light on options. Instead, advanced, rarely-used features are buried away inside sub-sub menus, or — somewhat more commonly — with keyboard combinations. As an example, I have no idea how to show the excellent Macro Expansion view in NetBeans, other than pressing Ctrl-Alt and clicking on a macro. Just to double-check, I went hunting for it in the menu bar, as well as digging through the context menus.&lt;/p&gt;
&lt;p&gt;I think students and hobbyists might be drawn toward the simplicity of NetBeans, but I prefer Eclipse’s density, as it encourages users to go exploring and discover new features.&lt;/p&gt;
&lt;p&gt;One big omission with the NetBeans text editor is the pop-up Source Hover code explorer that Eclipse has. Hover over any function in Eclipse, and the entire source code for that function pops up in a window you can scroll through. NetBeans will display code docs for functions, but if you want to look at the content of them, you’ll have to Ctrl-Click your way into the definition.&lt;/p&gt;
&lt;h3&gt;Microchip Customizations&lt;/h3&gt;
&lt;p&gt;I have to applaud Microchip for heavily customizing NetBeans into MPLAB X — an IDE that really feels like it was built for embedded development. The Project Properties window is all Microchip — you can select which tool you want to use to program the device (or the integrated simulator), as well as compiler options, include paths, and tool configuration.&lt;/p&gt;
&lt;p&gt;Integrating the tool setup into individual project properties is useful for developers who switch between devices (and voltages!) a lot; but it may feel clunky to users who are always on the same device, using the same settings — every time they create a new project, they’ll have to go through the same tool configuration settings (debugger powers target, select correct voltage, blah blah blah).&lt;/p&gt;
&lt;p&gt;One goof immediately visible is the redundant “Run Project” and “Make and Program Device” buttons. From what I can tell, these are identical (the manual says you can use either). However, from the bizarre Eclipse integrations I’ve seen, I’m used to dealing with UI oddities like this when dealing with embedded IDEs.&lt;/p&gt;
&lt;p&gt;Microchip integrates a lovely dashboard view (visible in the bottom of the main photo), which indicates the device target, the compiler, and the memory usage.&lt;/p&gt;
&lt;p&gt;The MPLAB X Options window allows you to add multiple instances of the Microchip XC compilers. As these compilers are &lt;a href=&quot;https://jaycarlson.net/microcontrollers/#XC&quot;&gt;quite expensive&lt;/a&gt; and don’t support new devices introduced after their release, it is common for shops to have several versions of XC compilers floating around — old, paid-for versions, and new code-size-limited versions they may grab to evaluate a new part before forking over dough.&lt;/p&gt;
&lt;img data-attachment-id=&quot;1301&quot; data-permalink=&quot;https://jaycarlson.net/microcontrollers/javaw_2017-09-13_21-26-40/&quot; data-orig-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/javaw_2017-09-13_21-26-40.png&quot; data-orig-size=&quot;1007,751&quot; data-comments-opened=&quot;1&quot; data-image-meta=&quot;{&amp;quot;aperture&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;credit&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;camera&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;caption&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;created_timestamp&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;copyright&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;focal_length&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;iso&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;shutter_speed&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;orientation&amp;quot;:&amp;quot;0&amp;quot;}&quot; data-image-title=&quot;javaw_2017-09-13_21-26-40&quot; data-image-description=&quot;&quot; data-medium-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/javaw_2017-09-13_21-26-40-300x224.png&quot; data-large-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/javaw_2017-09-13_21-26-40.png&quot; class=&quot;size-full wp-image-1301&quot; src=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/javaw_2017-09-13_21-26-40.png?cbc196&amp;amp;cbc196&quot; alt=&quot;&quot; width=&quot;1007&quot; height=&quot;751&quot; srcset=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/javaw_2017-09-13_21-26-40.png 1007w, https://jaycarlson.net/wp-content/uploads/2017/07/javaw_2017-09-13_21-26-40-300x224.png 300w, https://jaycarlson.net/wp-content/uploads/2017/07/javaw_2017-09-13_21-26-40-768x573.png 768w&quot; sizes=&quot;(max-width: 1007px) 100vw, 1007px&quot;/&gt;I’m not a big fan of the hover-over-to-view-bit-values feature in the peripheral registers view.
&lt;h3&gt;Debugging&lt;/h3&gt;
&lt;p&gt;Debugging across all Microchip devices is much slower than in other IDEs. I’m not sure if this a limitation of the MCU, the PicKit 3, or the IDE (or all of the above). The default behavior of MPLAB X is to reconnect from the tool whenever starting a debug session, but you can shave a few seconds off the debug load time by instructing the IDE to maintain a constant connection to the tool by ticking the appropriate box in the Options dialogue. This really ought to be the default option, as few developers know of its existence, debugging is slow enough as it is, and there are very few usage cases where you’d want the IDE to disconnect from the debugger upon completing a debug session.&lt;/p&gt;
&lt;p&gt;While there’s an option to display a Dissassembly view while debugging, this doesn’t come up by default, and even when you select it, it doesn’t seem to be “sticky” — you have to re-open the view every time you start a debug session. This is fine for Java or desktop C/C++ development, but for embedded microcontrollers, disassembly view is critical.&lt;/p&gt;
&lt;img data-attachment-id=&quot;1302&quot; data-permalink=&quot;https://jaycarlson.net/microcontrollers/javaw_2017-08-16_23-43-37-2/&quot; data-orig-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/javaw_2017-08-16_23-43-37.png&quot; data-orig-size=&quot;419,129&quot; data-comments-opened=&quot;1&quot; data-image-meta=&quot;{&amp;quot;aperture&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;credit&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;camera&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;caption&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;created_timestamp&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;copyright&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;focal_length&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;iso&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;shutter_speed&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;orientation&amp;quot;:&amp;quot;0&amp;quot;}&quot; data-image-title=&quot;javaw_2017-08-16_23-43-37&quot; data-image-description=&quot;&quot; data-medium-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/javaw_2017-08-16_23-43-37-300x92.png&quot; data-large-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/javaw_2017-08-16_23-43-37.png&quot; class=&quot;wp-image-1302 size-full&quot; src=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/javaw_2017-08-16_23-43-37.png?cbc196&amp;amp;cbc196&quot; alt=&quot;&quot; width=&quot;419&quot; height=&quot;129&quot; srcset=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/javaw_2017-08-16_23-43-37.png 419w, https://jaycarlson.net/wp-content/uploads/2017/07/javaw_2017-08-16_23-43-37-300x92.png 300w&quot; sizes=&quot;(max-width: 419px) 100vw, 419px&quot;/&gt;MPLAB X’s NetBeans backend seems confused by bit-field register definitions, which makes hover-over symbol inspection basically worthless when you’re in a debug session.
&lt;p&gt;Another afterthought seems to be the peripheral register view, and peripheral register handling in general. Pull up the SFRs view, and you’ll be greeted by an extremely slow-loading window that’s painful to scroll through — especially on larger devices like the PIC32.&lt;/p&gt;
&lt;p&gt;This view displays the address of the register (who cares?), the hard-to-understand short-form name, the hex value of the register, the decimal value of the register (who cares?), the binary value (hilariously long when working on 16- and 32-bit processors), and an ASCII interpretation of the register’s value (…why on Earth…?) — but what’s &lt;em&gt;not&lt;/em&gt; in this view is: a human-readable name of the register, description of the register’s function, or a human-readable decoding of the register’s current value.&lt;/p&gt;
&lt;p&gt;There’s a hover-over break-down of the register into its individual bits, but these use the same short-form datasheet names, don’t provide descriptions, and don’t contain enumeration values for multi-bit fields (or any explanation at all).&lt;/p&gt;
&lt;p&gt;Basically, you’re going to have to have your datasheet open so that you can hand-decode the values of these registers, as Microchip doesn’t seem interested in integrating that style of documentation into their IDE.&lt;/p&gt;
&lt;p&gt;These are the things that drive me nuts — it’s 2017; all of this data is already computerized. All they need to do is add a bit more functionality to their view (which many Eclipse-based vendor tools have), and all the sudden, the SFR view becomes ten times more productive to use.&lt;/p&gt;
&lt;p&gt;For higher-end PIC32 and PIC24 devices, there’s a semihosting-like feature Microchip calls appIO (though it only works with their pricy ICD debuggers). There’s also runtime variable watch and instruction tracing, but that’s only supported by the &lt;em&gt;really&lt;/em&gt; pricy RealICE debugger.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;wpb_text_column wpb_content_element&quot; id=&quot;ide3000&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;&lt;img data-attachment-id=&quot;1303&quot; data-permalink=&quot;https://jaycarlson.net/microcontrollers/ht-ide3000_2017-10-19_18-06-58/&quot; data-orig-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/HT-IDE3000_2017-10-19_18-06-58.png&quot; data-orig-size=&quot;1060,904&quot; data-comments-opened=&quot;1&quot; data-image-meta=&quot;{&amp;quot;aperture&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;credit&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;camera&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;caption&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;created_timestamp&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;copyright&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;focal_length&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;iso&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;shutter_speed&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;orientation&amp;quot;:&amp;quot;0&amp;quot;}&quot; data-image-title=&quot;HT-IDE3000_2017-10-19_18-06-58&quot; data-image-description=&quot;&quot; data-medium-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/HT-IDE3000_2017-10-19_18-06-58-300x256.png&quot; data-large-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/HT-IDE3000_2017-10-19_18-06-58-1024x873.png&quot; class=&quot;wp-image-1303 size-full&quot; src=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/HT-IDE3000_2017-10-19_18-06-58.png?cbc196&amp;amp;cbc196&quot; alt=&quot;&quot; width=&quot;1060&quot; height=&quot;904&quot; srcset=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/HT-IDE3000_2017-10-19_18-06-58.png 1060w, https://jaycarlson.net/wp-content/uploads/2017/07/HT-IDE3000_2017-10-19_18-06-58-300x256.png 300w, https://jaycarlson.net/wp-content/uploads/2017/07/HT-IDE3000_2017-10-19_18-06-58-768x655.png 768w, https://jaycarlson.net/wp-content/uploads/2017/07/HT-IDE3000_2017-10-19_18-06-58-1024x873.png 1024w&quot; sizes=&quot;(max-width: 1060px) 100vw, 1060px&quot;/&gt;HT-IDE3000 looks like Office 2003’s ugly cousin, but its ancient GUI toolkit snaps along on modern systems at lightning speed. Text completion is basic but rocket-fast, and the IDE integrates well with the debugger and target MCU.
&lt;h2&gt;Holtek HT-IDE3000&lt;/h2&gt;
&lt;p&gt;Anyone who complains about IDE bloat and download registration walls should immediately check out Holtek HT-IDE3000 (yes, that’s what it’s called). &lt;a href=&quot;http://www.holtek.com/ice-software&quot;&gt;Visit their website&lt;/a&gt;, click the download link, and a small 90 MB ZIP file starts downloading.&lt;/p&gt;
&lt;p&gt;They do make you type in the serial number on your $40 eLink debugger before using it (likely to deter debugger cloning), but that’s the only registration you’ll see.&lt;/p&gt;
&lt;p&gt;Once you get the IDE up and running, the first thing you’ll notice is its Office 2003 look. It ain’t pretty, but it’s functional. All the menu buttons you see are completely customizable through a drag-and-drop editor, which I didn’t see in any other IDE tested.&lt;/p&gt;
&lt;p&gt;The best part about having such an old-school IDE is that this thing &lt;em&gt;screams&lt;/em&gt;: zero-lag text-editing, immediate hover-over pop-up tooltips with function source code (like the Hover Source feature in Eclipse, but much more lightweight), and zippy project building. I did a double-take when looking at RAM usage: &lt;em&gt;HT-IDE3000 uses 9.9 MB of RAM&lt;/em&gt;. Yes, that decimal point is placed properly. Insane.&lt;/p&gt;
&lt;p&gt;This comes at the expense of code intelligence features. IDE3000 can go to variables, macros, and function definitions; auto-complete variables and functions; and display pop-up source listings of functions when you hover over them. But there are no real macro expansion capabilities or code outline views, and the text completion is pretty basic: it recognizes C types and functions but doesn’t seem to like remembering SFRs or other types of things that get #define’d. There’s no macro expansion, and the text completion isn’t intelligent — it’s only a selectable list of all symbols visible in the given context.&lt;/p&gt;
&lt;p&gt;This turns out to be good enough for the sorts of projects these small devices tackle. It’s not like you’re going to be juggling around more than a few dozen variables, and I’d bet 90% of the code-bases that target these parts comprise a single C file.&lt;/p&gt;
&lt;p&gt;What you &lt;em&gt;do&lt;/em&gt; get with Holtek is deep integration with the device you’re targetting. There’s built-in functionality for interacting with EEPROM on the device, programming using USB bootloaders present in some of their chips, as well as a built-in OTP workflow for generating the appropriate files Holtek needs to manufacture your parts (since most Holtek devices sold are OTP parts).&lt;/p&gt;
&lt;img data-attachment-id=&quot;1304&quot; data-permalink=&quot;https://jaycarlson.net/microcontrollers/ht-ide3000_2017-08-12_16-31-12-2/&quot; data-orig-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/HT-IDE3000_2017-08-12_16-31-12.png&quot; data-orig-size=&quot;1483,868&quot; data-comments-opened=&quot;1&quot; data-image-meta=&quot;{&amp;quot;aperture&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;credit&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;camera&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;caption&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;created_timestamp&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;copyright&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;focal_length&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;iso&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;shutter_speed&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;orientation&amp;quot;:&amp;quot;0&amp;quot;}&quot; data-image-title=&quot;HT-IDE3000_2017-08-12_16-31-12&quot; data-image-description=&quot;&quot; data-medium-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/HT-IDE3000_2017-08-12_16-31-12-300x176.png&quot; data-large-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/HT-IDE3000_2017-08-12_16-31-12-1024x599.png&quot; class=&quot;wp-image-1304 size-full&quot; src=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/HT-IDE3000_2017-08-12_16-31-12.png?cbc196&amp;amp;cbc196&quot; alt=&quot;&quot; width=&quot;1483&quot; height=&quot;868&quot; srcset=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/HT-IDE3000_2017-08-12_16-31-12.png 1483w, https://jaycarlson.net/wp-content/uploads/2017/07/HT-IDE3000_2017-08-12_16-31-12-300x176.png 300w, https://jaycarlson.net/wp-content/uploads/2017/07/HT-IDE3000_2017-08-12_16-31-12-768x450.png 768w, https://jaycarlson.net/wp-content/uploads/2017/07/HT-IDE3000_2017-08-12_16-31-12-1024x599.png 1024w&quot; sizes=&quot;(max-width: 1483px) 100vw, 1483px&quot;/&gt;Debugging in HT-IDE3000 is lightweight and snappy, with most features you’d expect. I wish the register view had more information about the individual bits (at least their full name and description as a hover-over tooltip), but it gets the job done — especially considering how simple the architecture is this IDE targets.
&lt;p&gt;As soon as you build a project, IDE3000 will jump into a debugging session in the background — even as you continue editing and building. This unconventional experience lures you tap that “Build” button often, and gush at your progress. As most firmware projects targetting this microcontroller will hover in a while() loop until interacted with, while you’re editing, you can double-click on a line of code to set a breakpoint, immediately check out what’s going on, make changes, and continue editing — without the manual process of uploading code, switching to a debug perspective, waiting for the image to flash, start running, and a breakpoint hit.&lt;/p&gt;
&lt;p&gt;Code building and uploading are so fast, it almost feels like you’re in a simulator or a PC-based environment. The debugging views are basic but fully-functional. The peripheral register view will break down each register into the bits that are set and cleared — but I would have preferred hover-over descriptions of the registers and the bits they command.&lt;/p&gt;
&lt;p&gt;While Holtek could modernize the UI, you’ll get no complaints about stability from me: I didn’t have a single crash, bug, hiccup, or driver installation kerfuffle the entire time I used IDE3000 — I tried it on both Windows 7 and Windows 10 Fall Creator’s Update, and the experience was identical. Holtek accelerates an update schedule by squashing bugs and adding new features several times a year — in fact, they had two updates over the course of my writing this review, which is more than any other IDE.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;wpb_text_column wpb_content_element&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;&lt;img data-attachment-id=&quot;1306&quot; data-permalink=&quot;https://jaycarlson.net/microcontrollers/2017-10-19_19-24-22/&quot; data-orig-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/2017-10-19_19-24-22.png&quot; data-orig-size=&quot;1118,742&quot; data-comments-opened=&quot;1&quot; data-image-meta=&quot;{&amp;quot;aperture&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;credit&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;camera&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;caption&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;created_timestamp&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;copyright&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;focal_length&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;iso&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;shutter_speed&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;orientation&amp;quot;:&amp;quot;0&amp;quot;}&quot; data-image-title=&quot;2017-10-19_19-24-22&quot; data-image-description=&quot;&quot; data-medium-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/2017-10-19_19-24-22-300x199.png&quot; data-large-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/2017-10-19_19-24-22-1024x680.png&quot; class=&quot;size-full wp-image-1306&quot; src=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/2017-10-19_19-24-22.png?cbc196&amp;amp;cbc196&quot; alt=&quot;&quot; width=&quot;1118&quot; height=&quot;742&quot; srcset=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/2017-10-19_19-24-22.png 1118w, https://jaycarlson.net/wp-content/uploads/2017/07/2017-10-19_19-24-22-300x199.png 300w, https://jaycarlson.net/wp-content/uploads/2017/07/2017-10-19_19-24-22-768x510.png 768w, https://jaycarlson.net/wp-content/uploads/2017/07/2017-10-19_19-24-22-1024x680.png 1024w&quot; sizes=&quot;(max-width: 1118px) 100vw, 1118px&quot;/&gt;STVD supports decent text completion, and customizable editor colors and fonts.
&lt;h2&gt;ST Visual Develop (STVD)&lt;/h2&gt;
&lt;p&gt;STVD is the official IDE for the &lt;a href=&quot;https://jaycarlson.net/pf/st-stm8/&quot;&gt;STM8&lt;/a&gt;. Its UI feels even older than IDE3000, but it’s a bit better when it comes to text-editing capabilities. Its code completion is invoked with the familiar ctrl-spacebar shortcut, and instead of just displaying all symbols discovered, it seems to default to symbols that make sense in the present context. It knows enough about C to walk into pointer-referenced structs, but unfortunately, has no pop-up documentation or source-code browsing when you hover over a method.&lt;/p&gt;
&lt;p&gt;Unfortunately, it feels slow&lt;em&gt;.&lt;/em&gt; Code completion can take a second or longer to pop-up in larger projects, rearranging toolbars was sluggish, going to the definition of a symbol took time to load the editor window, and menus were slow to appear.&lt;/p&gt;
&lt;img data-attachment-id=&quot;1308&quot; data-permalink=&quot;https://jaycarlson.net/microcontrollers/stvdebug_2017-10-19_20-00-37/&quot; data-orig-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/stvdebug_2017-10-19_20-00-37.png&quot; data-orig-size=&quot;1118,742&quot; data-comments-opened=&quot;1&quot; data-image-meta=&quot;{&amp;quot;aperture&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;credit&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;camera&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;caption&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;created_timestamp&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;copyright&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;focal_length&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;iso&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;shutter_speed&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;orientation&amp;quot;:&amp;quot;0&amp;quot;}&quot; data-image-title=&quot;stvdebug_2017-10-19_20-00-37&quot; data-image-description=&quot;&quot; data-medium-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/stvdebug_2017-10-19_20-00-37-300x199.png&quot; data-large-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/stvdebug_2017-10-19_20-00-37-1024x680.png&quot; class=&quot;wp-image-1308 size-full&quot; src=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/stvdebug_2017-10-19_20-00-37.png?cbc196&amp;amp;cbc196&quot; alt=&quot;&quot; width=&quot;1118&quot; height=&quot;742&quot; srcset=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/stvdebug_2017-10-19_20-00-37.png 1118w, https://jaycarlson.net/wp-content/uploads/2017/07/stvdebug_2017-10-19_20-00-37-300x199.png 300w, https://jaycarlson.net/wp-content/uploads/2017/07/stvdebug_2017-10-19_20-00-37-768x510.png 768w, https://jaycarlson.net/wp-content/uploads/2017/07/stvdebug_2017-10-19_20-00-37-1024x680.png 1024w&quot; sizes=&quot;(max-width: 1118px) 100vw, 1118px&quot;/&gt;The peripheral registers view had descriptions of all the registers, but didn’t break down registers into individual bits (or explain what they were).
&lt;p&gt;Debugging was also worse than average. Breakpoints can’t be set while the target is running — you must manually pause it, add your breakpoint, and then continue execution. The peripheral registers view was also underwhelming: while it has descriptions of registers, it only displays the whole value of the register — in hex format — without giving you a per-bit breakdown useful for catching bit math bugs in your code. Yet again, you’ll be resigned to manually cross-checking register values with values from the datasheet — one of my biggest pet peeves.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;wpb_text_column wpb_content_element&quot; id=&quot;psoc-creator&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;img class=&quot;wp-image-1042 size-full&quot; src=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/psoc_creator_2017-09-09_17-16-43.png?cbc196&amp;amp;cbc196&quot; alt=&quot;&quot; width=&quot;1411&quot; height=&quot;1012&quot; srcset=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/psoc_creator_2017-09-09_17-16-43.png 1411w, https://jaycarlson.net/wp-content/uploads/2017/07/psoc_creator_2017-09-09_17-16-43-300x215.png 300w, https://jaycarlson.net/wp-content/uploads/2017/07/psoc_creator_2017-09-09_17-16-43-768x551.png 768w, https://jaycarlson.net/wp-content/uploads/2017/07/psoc_creator_2017-09-09_17-16-43-1024x734.png 1024w&quot; sizes=&quot;(max-width: 1411px) 100vw, 1411px&quot;/&gt;PSoC Creator is built around Cypress’s code-gen tools, which provides a schematic capture interface for instantiating and connecting components; these tools generate the configuration bitstream along with an API for the peripherals.
&lt;h2&gt;PSoC Creator&lt;/h2&gt;
&lt;p&gt;Cypress PSoC Creator is the official — and only — development environment available for Cypress’s line of PSoC devices, and encompasses a project management system, text editor, schematic capture tool, code generator, and debugger.&lt;/p&gt;
&lt;p&gt;PSoC Creator’s interface lurks out of the last decade with its Office 2003 costume, and its .NET codebase ensures porting it to Linux or macOS will be an arduous task that Cypress, itself, resigns as unlikely.&lt;/p&gt;
&lt;p&gt;PSoC Creator feels snappier and lighter-weight than Eclipse or NetBeans-based environments while maintaining 90% of the IDE features and code introspection abilities. Loadable workspaces weave together one or more projects — any number of which can be open at the same time — exactly as Eclipse does.&lt;/p&gt;
&lt;p&gt;A Code Explorer pane leads you to variable and function definitions with a single click; while the text competition digs deep into functions, macros, and variables to bubble up suggestions with the familiar Ctrl-Spacebar shortcut.&lt;/p&gt;
&lt;p&gt;Cypress needs to refashion hover-over tooltips into what Eclipse or IDE3000 does; as it stands, the tooltips print the name of the function and its parameters — there are no code docs, and no quick source view you can use to peek at a function’s implementation.&lt;/p&gt;
&lt;p&gt;There’s one-click documentation access, plus a resource meter for monitoring both flash and SRAM usage — but also peripheral usage, which shows you exactly how integrated PSoC Creator is with the underlying PSoC hardware.&lt;/p&gt;
&lt;p&gt;The 500 lb gorilla in the PSoC Creator ecosystem — the schematic capture configurator tool — is a major omnipresence in PSoC Creator — but I’ll save that discussion for Code Generator section of this review page.&lt;/p&gt;
&lt;img data-attachment-id=&quot;1043&quot; data-permalink=&quot;https://jaycarlson.net/microcontrollers/psoc_creator_2017-09-09_18-29-39/&quot; data-orig-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/psoc_creator_2017-09-09_18-29-39.png&quot; data-orig-size=&quot;1097,921&quot; data-comments-opened=&quot;1&quot; data-image-meta=&quot;{&amp;quot;aperture&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;credit&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;camera&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;caption&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;created_timestamp&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;copyright&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;focal_length&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;iso&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;shutter_speed&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;orientation&amp;quot;:&amp;quot;0&amp;quot;}&quot; data-image-title=&quot;psoc_creator_2017-09-09_18-29-39&quot; data-image-description=&quot;&quot; data-medium-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/psoc_creator_2017-09-09_18-29-39-300x252.png&quot; data-large-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/psoc_creator_2017-09-09_18-29-39-1024x860.png&quot; class=&quot;wp-image-1043 size-full&quot; src=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/psoc_creator_2017-09-09_18-29-39.png?cbc196&amp;amp;cbc196&quot; alt=&quot;&quot; width=&quot;1097&quot; height=&quot;921&quot; srcset=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/psoc_creator_2017-09-09_18-29-39.png 1097w, https://jaycarlson.net/wp-content/uploads/2017/07/psoc_creator_2017-09-09_18-29-39-300x252.png 300w, https://jaycarlson.net/wp-content/uploads/2017/07/psoc_creator_2017-09-09_18-29-39-768x645.png 768w, https://jaycarlson.net/wp-content/uploads/2017/07/psoc_creator_2017-09-09_18-29-39-1024x860.png 1024w&quot; sizes=&quot;(max-width: 1097px) 100vw, 1097px&quot;/&gt;PSoC Creator has no global register inspector like other environments; you can only view peripheral registers associated with instantiated components.
&lt;p&gt;Flash load times were unimpressive (though not the worst seen in my round-up). A basic, 1.4 KB program took 7.82 seconds to load and run to main(). Filling flash up to 16 KB took 10.84 seconds.&lt;/p&gt;
&lt;p&gt;PSoC Creator jostled my brain when I strained to reduce power consumption in my DMX project. I couldn’t find a standard list of all peripheral registers which would allow me to cross-reference bits from the datasheet — instead, you can select from the peripherals you’ve configured in the schematic capture view, which initiates a limited view of that specific peripheral (and only displaying the registers associated with its current function).&lt;/p&gt;
&lt;p&gt;As this is an ARM microcontroller, you may intuit that a cross-platform GCC-based toolchain would be easy to set up — but because of the proprietary configuration bitstream required when flashing these devices, you’ll need to use Cypress’s tools to fit your design to the processor and merge this bitstream with your application binary code.&lt;/p&gt;
&lt;p&gt;While Cypress stops short of supporting Linux or macOS outright, PSoC Creator can export projects to common cross-platform Eclipse or Makefile-based environments — as well to industry stalwarts µVision and IAR.&lt;/p&gt;
&lt;p&gt;But if you’re on Windows, I wouldn’t bother — this is as close to an Eclipse/NetBeans workflow you’ll get with a proprietary IDE, and it’s definitely good enough to compete with either.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;wpb_text_column wpb_content_element&quot; id=&quot;uvision&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;
&lt;h2&gt;Keil uVision&lt;/h2&gt;
&lt;p&gt;Keil’s fame ensues from their acclaimed 8051 compiler, C51, introduced in 1988 — but since 1997, their compilers have also shipped with their in-house IDE, Keil µVision.&lt;br/&gt;Now at version 5, µVision continues to be popular among professional dev shops for both Arm and 8051 development, even as more and more manufacturers roll their own cross-platform toolchains.&lt;/p&gt;
&lt;p&gt;Speaking of that, while every Arm part I reviewed has its own manufacturer-provided IDE (save for the M051), developers can use µVision as an officially-supported development environment for all them.&lt;/p&gt;
&lt;p&gt;On the other end of the spectrum, among the 8051, only Silicon Labs maintains their own IDE for the EFM8 — both the N76 and STC8 only support µVision. Keil’s IDE has support for multi-project workspaces, though it doesn’t enforce their use.&lt;/p&gt;
&lt;p&gt;Keil’s text editor is painful to use. The first two things you’ll notice are that there are no auto-indenting inside block statements, and out of the box, there’s no keyboard shortcut for commenting or uncommenting code. Sure, you can bind “comment text selection” and “uncomment text selection” to shortcut keys, but you have to select the text before invoking. This is ridiculous.&lt;/p&gt;
&lt;p&gt;Even more painful: µVision has a Jekyll-and-Hyde act when switching between C51 (8051) and MDK (Arm) projects. When building Arm projects, µVision has ok-but-not-great text-completion (in the form of a pop-up list of discovered symbols) — but when building 8051 projects, that text completion inexplicably vanishes.&lt;/p&gt;
&lt;img data-attachment-id=&quot;1316&quot; data-permalink=&quot;https://jaycarlson.net/microcontrollers/uv4_2017-07-28_20-19-37/&quot; data-orig-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/UV4_2017-07-28_20-19-37.png&quot; data-orig-size=&quot;1252,796&quot; data-comments-opened=&quot;1&quot; data-image-meta=&quot;{&amp;quot;aperture&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;credit&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;camera&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;caption&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;created_timestamp&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;copyright&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;focal_length&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;iso&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;shutter_speed&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;orientation&amp;quot;:&amp;quot;0&amp;quot;}&quot; data-image-title=&quot;UV4_2017-07-28_20-19-37&quot; data-image-description=&quot;&quot; data-medium-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/UV4_2017-07-28_20-19-37-300x191.png&quot; data-large-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/UV4_2017-07-28_20-19-37-1024x651.png&quot; class=&quot;size-full wp-image-1316&quot; src=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/UV4_2017-07-28_20-19-37.png?cbc196&amp;amp;cbc196&quot; alt=&quot;&quot; width=&quot;1252&quot; height=&quot;796&quot; srcset=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/UV4_2017-07-28_20-19-37.png 1252w, https://jaycarlson.net/wp-content/uploads/2017/07/UV4_2017-07-28_20-19-37-300x191.png 300w, https://jaycarlson.net/wp-content/uploads/2017/07/UV4_2017-07-28_20-19-37-768x488.png 768w, https://jaycarlson.net/wp-content/uploads/2017/07/UV4_2017-07-28_20-19-37-1024x651.png 1024w&quot; sizes=&quot;(max-width: 1252px) 100vw, 1252px&quot;/&gt;Keil µVision’s Arm debugging has a functional peripheral inspector that breaks each register into each logical field, with named descriptions of any enumeration values.
&lt;p&gt;Debugging is the same sad song. Keil has good support for semihosting in Arm projects without needing much user intervention. A decent peripheral register explorer helps you diagnose peripheral issues with named-value fields that have nice descriptions.&lt;/p&gt;
&lt;img data-attachment-id=&quot;1317&quot; data-permalink=&quot;https://jaycarlson.net/microcontrollers/uv4_2017-09-12_01-07-39-2/&quot; data-orig-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/UV4_2017-09-12_01-07-39-1.png&quot; data-orig-size=&quot;1074,1029&quot; data-comments-opened=&quot;1&quot; data-image-meta=&quot;{&amp;quot;aperture&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;credit&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;camera&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;caption&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;created_timestamp&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;copyright&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;focal_length&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;iso&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;shutter_speed&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;orientation&amp;quot;:&amp;quot;0&amp;quot;}&quot; data-image-title=&quot;UV4_2017-09-12_01-07-39&quot; data-image-description=&quot;&quot; data-medium-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/UV4_2017-09-12_01-07-39-1-300x287.png&quot; data-large-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/UV4_2017-09-12_01-07-39-1-1024x981.png&quot; class=&quot;size-full wp-image-1317&quot; src=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/UV4_2017-09-12_01-07-39-1.png?cbc196&amp;amp;cbc196&quot; alt=&quot;&quot; width=&quot;1074&quot; height=&quot;1029&quot; srcset=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/UV4_2017-09-12_01-07-39-1.png 1074w, https://jaycarlson.net/wp-content/uploads/2017/07/UV4_2017-09-12_01-07-39-1-300x287.png 300w, https://jaycarlson.net/wp-content/uploads/2017/07/UV4_2017-09-12_01-07-39-1-768x736.png 768w, https://jaycarlson.net/wp-content/uploads/2017/07/UV4_2017-09-12_01-07-39-1-1024x981.png 1024w&quot; sizes=&quot;(max-width: 1074px) 100vw, 1074px&quot;/&gt;Debugging on the 8051 is a different story — the pop-up peripheral inspectors are clunky, and not every vendor adds the proper support to Keil.
&lt;p&gt;But in 8051land, weird pop-up peripheral inspectors stand in for the peripheral pane. While these curtail my productivity, I must admit they are more amusing than their Arm brethren (let’s be honest: who doesn’t love clicking checkboxes and watching LEDs light up?).&lt;/p&gt;
&lt;p&gt;I scoured the menus, feature lists, help files, and online examples trying to redeem µVision by finding something it excelled at compared to the other IDEs I evaluated. I suppose it’s much lighter-weight than Eclipse is — coming in at 105 MB of RAM usage during a debug session. It makes too many concessions for me to even consider it alongside Eclipse, though.&lt;/p&gt;
&lt;p&gt;In the end, consider µVision as nothing more than the free editor you get when you download C51 or MDK-ARM. And it’s not worth a penny more.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;vc_row-5cd272d49dd80&quot; class=&quot;vc_row wpb_row vc_row-fluid&quot;&gt;
&lt;div class=&quot;wpb_column vc_column_container vc_col-sm-12&quot;&gt;
&lt;div class=&quot;vc_column-inner&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;
&lt;div class=&quot;wpb_text_column wpb_content_element&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;

&lt;p&gt;Peripheral configuration and bring-up is generally a drop in the bucket when compared to the time required to implement an entire commercial embedded project — but if you’re working on tiny projects (either hobbyist stuff, or simple proof-of-concept engineering demos), having a code-gen tool can noticeably speed up the development cycle.&lt;/p&gt;
&lt;p&gt;Many of the development environments tested have code-gen tools either integrated directly into the IDE (Microchip Code Configurator, Simplicity Configurator, Infineon DAVE, PSoC Creator, Processor Expert, or have stand-alone tools (STM32CubeMX, Atmel START, STC-ISP, MCUXpresso Config Tools).&lt;/p&gt;
&lt;p&gt;Some generate initialization code that calls into the vendor’s general-purpose peripheral libraries (like STM32CubeMX), while some generate raw register initialization values from scratch (Silicon Labs’ Simplicity Configurator).&lt;/p&gt;
&lt;img data-attachment-id=&quot;1053&quot; data-permalink=&quot;https://jaycarlson.net/microcontrollers/chrome_2017-08-09_20-27-37-2/&quot; data-orig-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/chrome_2017-08-09_20-27-37.png&quot; data-orig-size=&quot;1199,802&quot; data-comments-opened=&quot;1&quot; data-image-meta=&quot;{&amp;quot;aperture&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;credit&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;camera&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;caption&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;created_timestamp&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;copyright&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;focal_length&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;iso&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;shutter_speed&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;orientation&amp;quot;:&amp;quot;0&amp;quot;}&quot; data-image-title=&quot;chrome_2017-08-09_20-27-37&quot; data-image-description=&quot;&quot; data-medium-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/chrome_2017-08-09_20-27-37-300x201.png&quot; data-large-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/chrome_2017-08-09_20-27-37-1024x685.png&quot; class=&quot;wp-image-1053 size-full&quot; src=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/chrome_2017-08-09_20-27-37.png?cbc196&amp;amp;cbc196&quot; alt=&quot;&quot; width=&quot;1199&quot; height=&quot;802&quot; srcset=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/chrome_2017-08-09_20-27-37.png 1199w, https://jaycarlson.net/wp-content/uploads/2017/07/chrome_2017-08-09_20-27-37-300x201.png 300w, https://jaycarlson.net/wp-content/uploads/2017/07/chrome_2017-08-09_20-27-37-768x514.png 768w, https://jaycarlson.net/wp-content/uploads/2017/07/chrome_2017-08-09_20-27-37-1024x685.png 1024w&quot; sizes=&quot;(max-width: 1199px) 100vw, 1199px&quot;/&gt;While Atmel START provides a nice-looking graphical interface especially useful for the flexible clocking schemes available on modern ARM microcontrollers, its design validation is hit or miss: in this picture, there’s absolutely no warning that the main 32 kHz oscillator isn’t enabled. Most seriously, the DFLL module indicates it’s outputting a frequency of 48 MHz, even though its multiplier is set to “0” in the configuration properties dialogue. Changing this to arbitrary values does not update the “48 MHz” display. This is a tool you cannot trust.
&lt;h2&gt;Atmel START&lt;/h2&gt;
&lt;p&gt;Microchip’s code-gen tool for its Atmel acquisition is a hold-over called Atmel START; it’s a web-based code configurator that supports nearly their whole catalog of current devices. Under the hood, it generates peripheral libraries that are considered part of ASF4 (Atmel… err, “Advanced”… Software Framework). This is a marked improvement over ASF3 on paper, but there are still significant problems with it.&lt;/p&gt;
&lt;p&gt;First, the good: using the part with 8-bit megaAVR and tinyAVR devices is a no-brainer. You can use the “initialization” drivers instead of the “basic” drivers to generate init-only code, along with any stubbed out ISR functions you need. The generated code is beautifully documented, extremely readable, and compact. It’s written the way you would probably write it by hand, and I can imagine this would serve as a nice learning tool for someone coming from Arduino, looking to take baby steps toward programming MCUs at the register level.&lt;/p&gt;
&lt;p&gt;Now the bad: Atmel START is extremely clunky to use. Projects must originate in the web browser, then get exported to a ZIP archive format, where Atmel Studio extracts them to a solution, where you can then open them. If you want to change something, thankfully Atmel Studio allows you to right-click on the project and reconfigure it — opening a browser window inside the app and automatically loading the project.&lt;/p&gt;
&lt;p&gt;But this begs the question: why can’t Atmel Studio create these projects from the get-go, if it can edit and re-generate them? Another problem with Atmel START is the lack of placeholder markers the tool can use to determine what to preserve and what to overwrite — this is only done at a whole file level. I assume this is why they don’t pre-define user callback function stubs, as these would get overwritten on subsequent regenerations of the code. This is a lazy design decision that makes integrating code with Atmel START challenging.&lt;/p&gt;
&lt;p&gt;More bad news for START: Atmel’s SAM D-series parts I evaluated require lots of clock configuration (like most Arm parts), but START provides absolutely no error-checking or clocking suggestions for you. It will gladly generate code that uses the main DFLL, without actually enabling the main DFLL, causing your program to hang in a while() loop waiting for the DFLL to start up, when it never will.&lt;/p&gt;
&lt;p&gt;This is the crap that makes getting going on a new platform so challenging, and this is precisely why I like using code configuration tools. So if a tool can’t do that, I scarcely see much value to it that I can’t get from normal peripheral libraries.&lt;/p&gt;
&lt;img data-attachment-id=&quot;754&quot; data-permalink=&quot;https://jaycarlson.net/microcontrollers/kinetis-design-studio_2017-08-04_16-10-20/&quot; data-orig-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/08/kinetis-design-studio_2017-08-04_16-10-20.png&quot; data-orig-size=&quot;1390,947&quot; data-comments-opened=&quot;1&quot; data-image-meta=&quot;{&amp;quot;aperture&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;credit&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;camera&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;caption&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;created_timestamp&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;copyright&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;focal_length&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;iso&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;shutter_speed&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;orientation&amp;quot;:&amp;quot;0&amp;quot;}&quot; data-image-title=&quot;kinetis-design-studio_2017-08-04_16-10-20&quot; data-image-description=&quot;&quot; data-medium-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/08/kinetis-design-studio_2017-08-04_16-10-20-300x204.png&quot; data-large-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/08/kinetis-design-studio_2017-08-04_16-10-20-1024x698.png&quot; class=&quot;size-full wp-image-754&quot; src=&quot;https://jaycarlson.net/wp-content/uploads/2017/08/kinetis-design-studio_2017-08-04_16-10-20.png?cbc196&amp;amp;cbc196&quot; alt=&quot;&quot; width=&quot;1390&quot; height=&quot;947&quot; srcset=&quot;https://jaycarlson.net/wp-content/uploads/2017/08/kinetis-design-studio_2017-08-04_16-10-20.png 1390w, https://jaycarlson.net/wp-content/uploads/2017/08/kinetis-design-studio_2017-08-04_16-10-20-300x204.png 300w, https://jaycarlson.net/wp-content/uploads/2017/08/kinetis-design-studio_2017-08-04_16-10-20-768x523.png 768w, https://jaycarlson.net/wp-content/uploads/2017/08/kinetis-design-studio_2017-08-04_16-10-20-1024x698.png 1024w&quot; sizes=&quot;(max-width: 1390px) 100vw, 1390px&quot;/&gt;Processor Expert provides a stunning array of configuration options and flexibility — but make sure you have a fast desktop PC, as this tool is a huge resource hog. It also generated some of the slowest peripheral code in the round-up.
&lt;h2&gt;Processor Expert&lt;/h2&gt;
&lt;p&gt;Processor Expert is at the other end of the spectrum. PE generates initialization code, interrupts, user callbacks, linker files, and an entire peripheral library. It uses a component-oriented model with dependency resolution; for example, two high-level “PWM” component instances will share a common “Timer Unit” low-level component (as they will end up on different output-compare channels of that timer unit).&lt;/p&gt;
&lt;p&gt;High-level components implement conceptual functionality, not peripheral functions. For example, if you wanted a function to execute every 25 ms, you would add a “TimerInt” component, and set the interval to 25 ms. Processor Expert will figure out which timer to use (FlexTimer, LPTimer, PIT, etc), route the clock appropriately, and calculate the necessary period register values, enable interrupts, generate an interrupt handler that takes care of any bits you need to set or clear. Of course, you can override any of its decisions at any point through its plethora of property panes — and unlike START, it will check your work to make sure everything is kosher.&lt;/p&gt;
&lt;p&gt;While it’s extremely flexible, the biggest problem with Processor Expert is its interface is unbelievably slow — whenever you change a parameter, it can take several seconds (even on a fast computer) for that change to propagate. When you hit “Generate Code” prepare to wait 10-30 seconds at least — and project rebuilding takes forever, too.&lt;/p&gt;
&lt;img data-attachment-id=&quot;1211&quot; data-permalink=&quot;https://jaycarlson.net/pf/infineon-xmc1100/dave_2017-10-14_23-03-04/&quot; data-orig-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/09/DAVE_2017-10-14_23-03-04.png&quot; data-orig-size=&quot;1100,843&quot; data-comments-opened=&quot;1&quot; data-image-meta=&quot;{&amp;quot;aperture&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;credit&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;camera&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;caption&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;created_timestamp&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;copyright&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;focal_length&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;iso&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;shutter_speed&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;orientation&amp;quot;:&amp;quot;0&amp;quot;}&quot; data-image-title=&quot;DAVE_2017-10-14_23-03-04&quot; data-image-description=&quot;&quot; data-medium-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/09/DAVE_2017-10-14_23-03-04-300x230.png&quot; data-large-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/09/DAVE_2017-10-14_23-03-04-1024x785.png&quot; class=&quot;size-full wp-image-1211&quot; src=&quot;https://jaycarlson.net/wp-content/uploads/2017/09/DAVE_2017-10-14_23-03-04.png?cbc196&amp;amp;cbc196&quot; alt=&quot;&quot; width=&quot;1100&quot; height=&quot;843&quot; srcset=&quot;https://jaycarlson.net/wp-content/uploads/2017/09/DAVE_2017-10-14_23-03-04.png 1100w, https://jaycarlson.net/wp-content/uploads/2017/09/DAVE_2017-10-14_23-03-04-300x230.png 300w, https://jaycarlson.net/wp-content/uploads/2017/09/DAVE_2017-10-14_23-03-04-768x589.png 768w, https://jaycarlson.net/wp-content/uploads/2017/09/DAVE_2017-10-14_23-03-04-1024x785.png 1024w&quot; sizes=&quot;(max-width: 1100px) 100vw, 1100px&quot;/&gt;DAVE provides a property-based GUI code generator that integrates well into the IDE. The tool calls into a lightweight peripheral library, XMClib.
&lt;h2&gt;Infineon DAVE&lt;/h2&gt;
&lt;p&gt;Infineon DAVE is similar from the user’s perspective, but instead of generating nearly-unreadable, multi-level library code, DAVE generates initialization code calls into XMClib to manage peripherals. And unlike Processor Expert, DAVE designers appear to have designed the generated code (as well as XMClib in general) for better optimization than Processor Expert, where even a single bit-toggle function ends up nearly completely unoptimized — taking 40 cycles to complete.&lt;/p&gt;
&lt;p&gt;DAVE also integrates higher-level “apps” — like built-in lighting control systems (including a DMX-512 receiver), communication protocols, graphics libraries, and motor controller libraries (we’re talking about pretty advanced stuff: FOC of ACIMs and PMSMs).&lt;/p&gt;
&lt;img data-attachment-id=&quot;1333&quot; data-permalink=&quot;https://jaycarlson.net/microcontrollers/studio_2017-10-30_03-01-17/&quot; data-orig-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/studio_2017-10-30_03-01-17.png&quot; data-orig-size=&quot;1062,790&quot; data-comments-opened=&quot;1&quot; data-image-meta=&quot;{&amp;quot;aperture&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;credit&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;camera&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;caption&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;created_timestamp&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;copyright&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;focal_length&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;iso&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;shutter_speed&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;orientation&amp;quot;:&amp;quot;0&amp;quot;}&quot; data-image-title=&quot;studio_2017-10-30_03-01-17&quot; data-image-description=&quot;&quot; data-medium-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/studio_2017-10-30_03-01-17-300x223.png&quot; data-large-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/studio_2017-10-30_03-01-17-1024x762.png&quot; class=&quot;size-full wp-image-1333&quot; src=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/studio_2017-10-30_03-01-17.png?cbc196&amp;amp;cbc196&quot; alt=&quot;&quot; width=&quot;1062&quot; height=&quot;790&quot; srcset=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/studio_2017-10-30_03-01-17.png 1062w, https://jaycarlson.net/wp-content/uploads/2017/07/studio_2017-10-30_03-01-17-300x223.png 300w, https://jaycarlson.net/wp-content/uploads/2017/07/studio_2017-10-30_03-01-17-768x571.png 768w, https://jaycarlson.net/wp-content/uploads/2017/07/studio_2017-10-30_03-01-17-1024x762.png 1024w&quot; sizes=&quot;(max-width: 1062px) 100vw, 1062px&quot;/&gt;Silicon Labs’ Simplicity Studio includes the built-in Simplicity Configurator for generating lightweight initialization code and ISR stubs.
&lt;h2&gt;Silicon Labs Simplicity Configurator&lt;/h2&gt;
&lt;p&gt;Silicon Labs takes a much lighter-weight approach to code generation with Simplicity Configurator. All Simplicity Configurator does is create peripheral initialization code, by generating functions that directly initialize register values.&lt;/p&gt;
&lt;p&gt;Silicon Labs has a full EFM8 peripheral library, but Simplicity Configurator does not call into it nor include it automatically — it just initializes peripherals, using raw register manipulation.&lt;/p&gt;
&lt;p&gt;You can combine Simplicity Configurator projects with the EFM8 peripheral library, or use your own code for interacting with the peripherals during runtime (Or just use the peripheral library without any code configurator).&lt;/p&gt;
&lt;p&gt;I really like this approach, as it provides a ton of flexibility, and keeps the size of generated code under control.&lt;/p&gt;
&lt;p&gt;It’s also one of the snappiest code-gen tools reviewed — Silicon Labs has so much confidence in its tool’s speed that it programmed the tool to auto-regenerate all the initialization code whenever you save the Configurator document, and in my testing, this didn’t introduce any noticeable lag.&lt;/p&gt;
&lt;p&gt;A neat perk unique to Simplicity Configurator is it can also generate stubs for ISRs — and the generated stubs include comments instructing you which bits to clear before leaving the ISR. Beautiful.&lt;/p&gt;
&lt;img data-attachment-id=&quot;273&quot; data-permalink=&quot;https://jaycarlson.net/microcontrollers/e2studio_2017-07-20_22-51-26/&quot; data-orig-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/e2studio_2017-07-20_22-51-26.png&quot; data-orig-size=&quot;1206,757&quot; data-comments-opened=&quot;1&quot; data-image-meta=&quot;{&amp;quot;aperture&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;credit&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;camera&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;caption&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;created_timestamp&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;copyright&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;focal_length&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;iso&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;shutter_speed&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;orientation&amp;quot;:&amp;quot;0&amp;quot;}&quot; data-image-title=&quot;e2studio_2017-07-20_22-51-26&quot; data-image-description=&quot;&quot; data-medium-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/e2studio_2017-07-20_22-51-26-300x188.png&quot; data-large-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/e2studio_2017-07-20_22-51-26-1024x643.png&quot; class=&quot;size-full wp-image-273&quot; src=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/e2studio_2017-07-20_22-51-26.png?cbc196&amp;amp;cbc196&quot; alt=&quot;&quot; width=&quot;1206&quot; height=&quot;757&quot; srcset=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/e2studio_2017-07-20_22-51-26.png 1206w, https://jaycarlson.net/wp-content/uploads/2017/07/e2studio_2017-07-20_22-51-26-300x188.png 300w, https://jaycarlson.net/wp-content/uploads/2017/07/e2studio_2017-07-20_22-51-26-768x482.png 768w, https://jaycarlson.net/wp-content/uploads/2017/07/e2studio_2017-07-20_22-51-26-1024x643.png 1024w&quot; sizes=&quot;(max-width: 1206px) 100vw, 1206px&quot;/&gt;I really enjoyed the timer documentation in the datasheet, and I was glad to see much of it made it into the code generator tool. Too many embedded programmers don’t understand all the powerful functions of advanced timers, so this tool should help out a lot.
&lt;h2&gt;Renesas Code Configurator&lt;/h2&gt;
&lt;p&gt;Renesas e2studio includes Code Configurator, their code-gen tool built into their IDE. This tool integrates a nicely-organized visual layout that’s extremely readable and self-documenting.&lt;/p&gt;
&lt;p&gt;This tool handles communication callbacks particularly effectively — the code generator creates an interrupt that handles the underlying ISR details, but then directly invokes a statically-declared callback function that’s stubbed out conveniently for the user. This callback has direct access to the buffer associated with the data, so there’s no expensive copying/buffering operation required in Processor Expert, Microchip Code Configurator, or Atmel START.&lt;/p&gt;
&lt;p&gt;Unfortunately, some of the other peripherals — especially the timers — focus heavily on initialization code, and don’t provide high-level APIs. For example, with the PWM peripheral, you’ll still need to directly modify timer registers, which involves looking up the register names in the datasheet, and learning about the values those registers can take.&lt;/p&gt;
&lt;p&gt;I would have preferred Code Configurator to generate PWM setDutyCycle()-type functions — more advanced users could directly modify the registers instead of relying on those functions, which would then be optimized out of the final code anyway.&lt;/p&gt;
&lt;h2&gt;Nuvoton NuTool PinConfig&lt;/h2&gt;
&lt;p&gt;Nuvoton provided a code configurator tool for their M0, but I mention it here only to dissuade you from thinking it has absolutely any value at all, in case you see an advertisement for it. Rather, it is full of bugs, only uses an outdated, buggy peripheral library, and cannot restore configurations properly. Whoever wrote it on their lunch break needs to spend another day or two getting it working before they release version 2.0.&lt;/p&gt;
&lt;h2&gt;NXP MCUXpresso Config Tools&lt;/h2&gt;
&lt;p&gt;Similarly, NXP really dropped the ball on the MCUXpresso Config Tools program, which it uses in lieu of Processor Expert. This stand-alone program purports to do clock configuration and pin-muxing, but in practice, the only code it generates is clock gating code. It claims to generate MCUXpresso projects, but then it informs you it cannot generate projects for MCUXpresso.&lt;/p&gt;
&lt;p&gt;You can export a weird archive format that you can import back into MCUXpresso, but if you want to make any changes, you have to go through the whole process again — recreating your project. It’s terrible.&lt;/p&gt;
&lt;p&gt;I ended up forcing it to generate code in a “generated” folder inside an existing MCUXpresso project. I set up the include paths to look in the new, generated tree structure, and was able to get it going — but this is not a procedure for novices who may be unfamiliar with Eclipse C/C++ development.&lt;/p&gt;
&lt;img data-attachment-id=&quot;117&quot; data-permalink=&quot;https://jaycarlson.net/microcontrollers/stc-isp-15xx-v6-86c_2017-07-16_20-48-00/&quot; data-orig-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/stc-isp-15xx-v6-86c_2017-07-16_20-48-00.png&quot; data-orig-size=&quot;803,583&quot; data-comments-opened=&quot;1&quot; data-image-meta=&quot;{&amp;quot;aperture&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;credit&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;camera&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;caption&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;created_timestamp&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;copyright&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;focal_length&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;iso&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;shutter_speed&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;orientation&amp;quot;:&amp;quot;0&amp;quot;}&quot; data-image-title=&quot;stc-isp-15xx-v6.86C_2017-07-16_20-48-00&quot; data-image-description=&quot;&quot; data-medium-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/stc-isp-15xx-v6-86c_2017-07-16_20-48-00-300x218.png&quot; data-large-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/stc-isp-15xx-v6-86c_2017-07-16_20-48-00.png&quot; class=&quot;size-full wp-image-117&quot; src=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/stc-isp-15xx-v6-86c_2017-07-16_20-48-00.png?cbc196&amp;amp;cbc196&quot; alt=&quot;&quot; width=&quot;803&quot; height=&quot;583&quot; srcset=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/stc-isp-15xx-v6-86c_2017-07-16_20-48-00.png 803w, https://jaycarlson.net/wp-content/uploads/2017/07/stc-isp-15xx-v6-86c_2017-07-16_20-48-00-300x218.png 300w, https://jaycarlson.net/wp-content/uploads/2017/07/stc-isp-15xx-v6-86c_2017-07-16_20-48-00-768x558.png 768w&quot; sizes=&quot;(max-width: 803px) 100vw, 803px&quot;/&gt;STC-ISP is STC’s do-everything programmer, parametric search engine, and code-gen tool. It may look a little silly, but it’s both easy to use and very functional.
&lt;h2&gt;STCmicro STC-ISP&lt;/h2&gt;
&lt;p&gt;STC-ISP — STC’s do-everything programmer utility — has some built-in code-generation capabilities. On the 8051, the three things people struggle with the most is UART, timer, and delay functions, as these all require clock calculations dependent on your particular set-up. STC-ISP generates precisely three types of source code: UART initialization, timer initialization, and delay functions. Oh, and it will output both C and ASM code, and it nicely comments the values so you remember why they’re in your source code in 6 months when you go to look at it again.&lt;/p&gt;
&lt;img data-attachment-id=&quot;792&quot; data-permalink=&quot;https://jaycarlson.net/microcontrollers/javaw_2017-08-13_17-29-52/&quot; data-orig-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/08/javaw_2017-08-13_17-29-52.png&quot; data-orig-size=&quot;1483,996&quot; data-comments-opened=&quot;1&quot; data-image-meta=&quot;{&amp;quot;aperture&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;credit&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;camera&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;caption&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;created_timestamp&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;copyright&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;focal_length&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;iso&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;shutter_speed&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;orientation&amp;quot;:&amp;quot;0&amp;quot;}&quot; data-image-title=&quot;javaw_2017-08-13_17-29-52&quot; data-image-description=&quot;&quot; data-medium-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/08/javaw_2017-08-13_17-29-52-300x201.png&quot; data-large-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/08/javaw_2017-08-13_17-29-52-1024x688.png&quot; class=&quot;size-full wp-image-792&quot; src=&quot;https://jaycarlson.net/wp-content/uploads/2017/08/javaw_2017-08-13_17-29-52.png?cbc196&amp;amp;cbc196&quot; alt=&quot;&quot; width=&quot;1483&quot; height=&quot;996&quot; srcset=&quot;https://jaycarlson.net/wp-content/uploads/2017/08/javaw_2017-08-13_17-29-52.png 1483w, https://jaycarlson.net/wp-content/uploads/2017/08/javaw_2017-08-13_17-29-52-300x201.png 300w, https://jaycarlson.net/wp-content/uploads/2017/08/javaw_2017-08-13_17-29-52-768x516.png 768w, https://jaycarlson.net/wp-content/uploads/2017/08/javaw_2017-08-13_17-29-52-1024x688.png 1024w&quot; sizes=&quot;(max-width: 1483px) 100vw, 1483px&quot;/&gt;Microchip Code Configurator provides a stellar pin-muxing perspective that other manufactures haven’t quite duplicated.
&lt;h2&gt;Microchip Code Configurator&lt;/h2&gt;
&lt;p&gt;Microchip Code Configurator (MCC) works with some (but not nearly all) 8-bit, 16-bit, and 32-bit PIC parts. This tool provides a nice pin manager view that shows you assignment possibilities for all peripherals. Each peripheral has an Easy Setup or a Registers view that lets you interact with the system at a lower level.&lt;/p&gt;
&lt;p&gt;The tool generates a purpose-built, basic, compact runtime library that’s a great place to get started with, but I’d like to see the ability to generate ISR stubs — especially for communication peripherals — instead of relying on out-of-ISR-context functions for handling data (which requires buffering data and other overheads).&lt;/p&gt;
&lt;p&gt;You can disable automatic reception to prevent MCC from generating these ISRs (allowing you to write your own), but I couldn’t find a way of being able to define my own ISR, but also have MCC generate code that automatically sets all the interrupt-enable bits that need to be present for ISRs to execute. Again, this results in an unnecessary trip to the datasheet.&lt;/p&gt;
&lt;p&gt;The tool managed to generate extremely compact code — the best in the round-up of code configurator tool (though this is also just a product of the PIC16 architecture), and, like Atmel START’s 8-bit code, read like something a human would write.&lt;/p&gt;
&lt;img data-attachment-id=&quot;1042&quot; data-permalink=&quot;https://jaycarlson.net/microcontrollers/psoc_creator_2017-09-09_17-16-43/&quot; data-orig-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/psoc_creator_2017-09-09_17-16-43.png&quot; data-orig-size=&quot;1411,1012&quot; data-comments-opened=&quot;1&quot; data-image-meta=&quot;{&amp;quot;aperture&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;credit&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;camera&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;caption&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;created_timestamp&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;copyright&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;focal_length&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;iso&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;shutter_speed&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;orientation&amp;quot;:&amp;quot;0&amp;quot;}&quot; data-image-title=&quot;psoc_creator_2017-09-09_17-16-43&quot; data-image-description=&quot;&quot; data-medium-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/psoc_creator_2017-09-09_17-16-43-300x215.png&quot; data-large-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/psoc_creator_2017-09-09_17-16-43-1024x734.png&quot; class=&quot;size-full wp-image-1042&quot; src=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/psoc_creator_2017-09-09_17-16-43.png?cbc196&amp;amp;cbc196&quot; alt=&quot;&quot; width=&quot;1411&quot; height=&quot;1012&quot; srcset=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/psoc_creator_2017-09-09_17-16-43.png 1411w, https://jaycarlson.net/wp-content/uploads/2017/07/psoc_creator_2017-09-09_17-16-43-300x215.png 300w, https://jaycarlson.net/wp-content/uploads/2017/07/psoc_creator_2017-09-09_17-16-43-768x551.png 768w, https://jaycarlson.net/wp-content/uploads/2017/07/psoc_creator_2017-09-09_17-16-43-1024x734.png 1024w&quot; sizes=&quot;(max-width: 1411px) 100vw, 1411px&quot;/&gt;PSoC Creator is built around Cypress’s code-gen tools, which provides a schematic capture interface for instantiating and connecting components; these tools generate the configuration bitstream along with an API for the peripherals.
&lt;h2&gt;PSoC Creator&lt;/h2&gt;
&lt;p&gt;PSoC Creator is infamous for its deeply-integrated code configurator tool. Because PSoC devices have peripherals whose registers are configured directly from a bitstream in flash memory, the PSoC Creator’s tools are not optional.&lt;/p&gt;
&lt;p&gt;This is an elaborate system that uses a schematic-capture interface to place individual blocks — PWM modules, SPI devices, ADC pins, and — in higher-end PSoC devices — reconfigurable analog and digital blocks.&lt;/p&gt;
&lt;p&gt;Each block has a nicely laid-out properties window that allows you to configure nearly everything about the peripheral.&lt;/p&gt;
&lt;p&gt;This system seems like it would be popular among people with an electronics — not programming — background. As much of a die-hard PCB layout guy as I am, I actually found the interface to be clunky and unproductive. You have to place &lt;em&gt;everything&lt;/em&gt; on the schematic — even pins and clock sources. If you want to define an ISR, the “PSoC way” is to wire up an ISR component to an interrupt signal on the schematic.&lt;/p&gt;
&lt;p&gt;I suppose you end up with nicely-documented PDF outputs explaining how the components fit together, but again, the system seems clunky and heavy-handed. Do I really have to create and configure a clock component, simply to route it into a timer? Can’t the timer just have a clock divider interface built-in?&lt;/p&gt;
&lt;p&gt;It’s all a matter of personal preference.&lt;/p&gt;
&lt;img data-attachment-id=&quot;1049&quot; data-permalink=&quot;https://jaycarlson.net/microcontrollers/javaw_2017-09-10_14-13-42/&quot; data-orig-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/javaw_2017-09-10_14-13-42.png&quot; data-orig-size=&quot;1086,685&quot; data-comments-opened=&quot;1&quot; data-image-meta=&quot;{&amp;quot;aperture&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;credit&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;camera&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;caption&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;created_timestamp&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;copyright&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;focal_length&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;iso&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;shutter_speed&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;orientation&amp;quot;:&amp;quot;0&amp;quot;}&quot; data-image-title=&quot;javaw_2017-09-10_14-13-42&quot; data-image-description=&quot;&quot; data-medium-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/javaw_2017-09-10_14-13-42-300x189.png&quot; data-large-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/javaw_2017-09-10_14-13-42-1024x646.png&quot; class=&quot;size-full wp-image-1049&quot; src=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/javaw_2017-09-10_14-13-42.png?cbc196&amp;amp;cbc196&quot; alt=&quot;&quot; width=&quot;1086&quot; height=&quot;685&quot; srcset=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/javaw_2017-09-10_14-13-42.png 1086w, https://jaycarlson.net/wp-content/uploads/2017/07/javaw_2017-09-10_14-13-42-300x189.png 300w, https://jaycarlson.net/wp-content/uploads/2017/07/javaw_2017-09-10_14-13-42-768x484.png 768w, https://jaycarlson.net/wp-content/uploads/2017/07/javaw_2017-09-10_14-13-42-1024x646.png 1024w&quot; sizes=&quot;(max-width: 1086px) 100vw, 1086px&quot;/&gt;STM32CubeMX is a lightweight, stand-alone code-gen tool that focuses on peripheral initialization, while pulling in the standard STM32 peripheral library for runtime duties.
&lt;h2&gt;ST STM32CubeMX&lt;/h2&gt;
&lt;p&gt;STM32CubeMX (the worst name in my round-up) is a lightweight, stand-alone Java app that’s oddly compelling to use. The tool supports initializing almost all peripherals of almost all STM32 devices — an impressive feat on its own. I couldn’t find a peripheral mode or feature that the tool didn’t support — but it’s important to understand the runtime code it generates uses the standard STM32 peripheral libraries, which have bothered some people due to their size.&lt;/p&gt;
&lt;p&gt;And, truth be told, these were some of the fattest hex files I made — only topped by Atmel START’s D10 code, and Nuvoton’s non-LTO’d peripheral library.&lt;/p&gt;
&lt;p&gt;The other problem is how basic some of the peripheral drivers are. But because the tool is intelligent enough to ignore strategically-placed user code, it’s easy to customize the generated code to suit your purposes.&lt;/p&gt;
&lt;p&gt;As a plus, the tool can generate project formats that target all popular development ecosystems — and not just their official System Workbench for STM32.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;compilers&quot; class=&quot;vc_row wpb_row vc_row-fluid&quot;&gt;
&lt;div class=&quot;wpb_column vc_column_container vc_col-sm-12&quot;&gt;
&lt;div class=&quot;vc_column-inner&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;
&lt;div class=&quot;wpb_text_column wpb_content_element&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;

&lt;p&gt;There was a large contingent of hobbyists in the 1990s and 2000s who were lured by low-quality proprietary compilers that didn’t work well, crashed often, and quickly disappeared from the market without a trace. Those have all but vanished — these days, GCC builds code for several different MCU families, while the industry stand-bys — Keil, IAR, Cosmic, etc — continue to be popular choices for 8-bit MCUs that lack C-friendliness (and thus, GCC support).&lt;/p&gt;
&lt;p&gt;The biggest change in the last 10 years is the democratization of tools — even proprietary, expensive compilers tend to have generous code-size limitations (64 KB or more in some cases — plenty for a quick evaluation or hobbyist projects).&lt;/p&gt;
&lt;p&gt;And some vendors — like Silicon Labs and ST — work with compiler vendors to offer full versions of these expensive tools free of charge to the customer.&lt;/p&gt;
&lt;p&gt;I conducted all my testing using nothing but freely-available versions of the vendor-recommended toolchains for their products. Throughout the months of testing on 21 different parts, I didn’t run into a single compiler bug — but I did run into several peculiarities and optimization snafus.&lt;/p&gt;
&lt;h2&gt;GCC&lt;/h2&gt;
&lt;p&gt;GCC is an open-source, cross-platform part of the GNU Project, and first released in 1987. Since then, developers have ported GCC to dozens of architectures. In the microcontroller world, it can target the Arm, AVR, RL-78, and MSP-430 parts reviewed — as well as parts I wasn’t able to get to, including Xtensa, RX, M16C, SH, NIOS2, and Microblaze.&lt;/p&gt;
&lt;p&gt;GCC can support MIPS processors, and there are several projects (&lt;a href=&quot;https://github.com/is1200-example-projects/mcb32tools&quot;&gt;e.g.&lt;/a&gt;) from people trying to build code for the PIC32, but you’ll get no help from Microchip &lt;sup id=&quot;footnote_plugin_tooltip_8&quot; class=&quot;footnote_plugin_tooltip_text&quot; onclick=&quot;footnote_moveToAnchor('footnote_plugin_reference_8');&quot;&gt;8&lt;/sup&gt;&lt;span class=&quot;footnote_tooltip&quot; id=&quot;footnote_plugin_tooltip_text_8&quot;&gt;and a &lt;a href=&quot;https://www.eevblog.com/forum/microcontrollers/is-microchip-violating-the-gpl/&quot;&gt;growing chorus&lt;/a&gt; is &lt;a href=&quot;https://www.embeddedrelated.com/showthread/comp.arch.embedded/91196-1.php&quot;&gt;questioning&lt;/a&gt; whether they’re in violation of GPL&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;GCC excels at producing fast math code, supporting recent C standards, and — with link-time-optimization — producing compact code.&lt;/p&gt;
&lt;p&gt;Arm, especially, has seen a mass migration to GCC — even Arm Holdings (who own MDK-ARM) take part in GCC’s upkeep, and &lt;a href=&quot;https://developer.arm.com/open-source/gnu-toolchain/gnu-rm&quot;&gt;distribute binary releases&lt;/a&gt; of it on their site. I know several smaller shops that have stopped renewing their Keil MDK licenses, because GCC is as good — or better — than MDK.&lt;/p&gt;
&lt;p&gt;I haven’t conducted thorough benchmarking myself, but in my biquad filtering test with the Nuvoton Cortex-M0 part, the GCC implementation required 30 clock cycles, while the MDK version needed 42. Code size was also better for GCC than MDK — 2880 bytes versus 3004 bytes.&lt;/p&gt;
&lt;p&gt;The Achilles’ heel for GCC on MCUs is actually not GCC itself — but rather the C library — Newlib or Newlib-Nano  — that is often linked to the program whenever you need printf() or similar C routines.&lt;/p&gt;
&lt;p&gt;Here, Keil MDK, IAR, and other vendors can produce much smaller code size, as they’re using their own C libraries that are highly-optimized for the architecture (and may not be 100% compatible with C99).&lt;/p&gt;
&lt;p&gt;This compares with Newlib, the full GCC C library that’s aimed at much larger devices running full operating systems — or Newlib-Nano, which trims down, but is still much larger than proprietary MCU C libraries.&lt;/p&gt;
&lt;p&gt;I want to highlight NXP’s MCUXpresso IDE, as they’re the only vendor to distribute a built-for-ARM C library, &lt;a href=&quot;https://community.nxp.com/thread/389152&quot;&gt;Redlib&lt;/a&gt;, with their IDE. Redlib is part of their Code Red acquisition. All other vendors copy-and-paste the same newlib and newlib-nano options.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.raisonance.com/arm_benchmark.html&quot;&gt;Raisonance conducted a benchmark&lt;/a&gt; a few years ago that confirms everything I’ve written on the strengths and weaknesses of GCC.&lt;sup id=&quot;footnote_plugin_tooltip_9&quot; class=&quot;footnote_plugin_tooltip_text&quot; onclick=&quot;footnote_moveToAnchor('footnote_plugin_reference_9');&quot;&gt;9&lt;/sup&gt;&lt;span class=&quot;footnote_tooltip&quot; id=&quot;footnote_plugin_tooltip_text_9&quot;&gt;Full disclosure: Raisonance has a stake in GCC, as they use it in their Ride7 proprietary IDE.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;One minor annoyance with GCC is that its backend considers SFR accesses as an “optimization” — so with the optimizer off, it uses fairly slow code for accessing peripherals. I’ve verified this with both AVR and RL-78 targets.&lt;/p&gt;
&lt;p&gt;On avr-gcc, compiling with -Og or higher will fix this issue, but this can introduce debugging headaches (though -Og minimizes them).&lt;/p&gt;
&lt;p&gt;GCC’s RL-78 port, however, seems crippled by this issue — no optimization flags I tried were ever able to generate correct SFR accesses; everything always went through normal 16-bit space, issuing a strong performance penalty.&lt;/p&gt;
&lt;h2&gt;CC-RL&lt;/h2&gt;
&lt;p&gt;While the RL-78 has rudimentary support for GCC, as I mentioned above, I was never able to coax it into generating good register I/O. CC-RL, the proprietary RL78 compiler from Renesas, has no issues with this.&lt;/p&gt;
&lt;p&gt;But CC-RL doesn’t inline non-native math functions — instead, it calls into runtime libraries, which introduces extra overhead.&lt;/p&gt;
&lt;p&gt;The free mode supports 64 K linking.&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Keil C51&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;The 8051 harkens from a time where developers programmed microcomputers (and microcontrollers) in assembly, not C. Its fancy control-friendly features like small sets of banked registers (which can interchange in an interrupt context) don’t play well with compilers.&lt;/p&gt;
&lt;p&gt;Worst still, the 8051 suffers from a small, 8-bit stack that struggles to keep up with traditional stack-based C implementations.&lt;/p&gt;
&lt;p&gt;Early C compilers for the 8051 often started as 68K or x86 compilers hacked with an emulated software stack stored in XRAM. This produced code that dawdled through tasks at a snail’s pace.&lt;/p&gt;
&lt;p&gt;PL/M-51&lt;sup id=&quot;footnote_plugin_tooltip_10&quot; class=&quot;footnote_plugin_tooltip_text&quot; onclick=&quot;footnote_moveToAnchor('footnote_plugin_reference_10');&quot;&gt;10&lt;/sup&gt;&lt;span class=&quot;footnote_tooltip&quot; id=&quot;footnote_plugin_tooltip_text_10&quot;&gt;PL/M-51 wasn’t a C compiler — it actually compiled code written PL/M, a proprietary Intel high-level language. Man, the 80s were weird.&lt;/span&gt;was an Intel compiler introduced in 1980 that got around this problem by passing variables in defined RAM locations.&lt;/p&gt;
&lt;p&gt;Keil took this idea and ran with it. They introduced C51 in 1988 — and it flourished in popularity.&lt;/p&gt;
&lt;p&gt;One of the problems with Keil is its trigger-happy use of nonstandard reserved words. But this what you would expect: when you’re building a C compiler for the 8051, you &lt;em&gt;have to&lt;/em&gt; have the ability to declare variables in XRAM versus RAM — or be able to instruct the compiler to make a function reentrant if necessary. You don’t have the luxury of a stack-friendly microcontroller which treats all RAM equal.&lt;/p&gt;
&lt;p&gt;While that’s unavoidable, the way Keil implemented these special attributes is not. Keil obnoxiously sets aside: alien, bdata, bit, code, compact, data, far, idata, interrupt, large, pdata, reentrant, sbit, sfr, sfr16, small, using, and xdata.&lt;/p&gt;
&lt;p&gt;Because, as we all know, no developer ever declares variables named things like “data,” so that should work out fine.&lt;/p&gt;
&lt;p&gt;This is a serious problem when porting large stacks built for other compilers, like GCC. &lt;sup id=&quot;footnote_plugin_tooltip_11&quot; class=&quot;footnote_plugin_tooltip_text&quot; onclick=&quot;footnote_moveToAnchor('footnote_plugin_reference_11');&quot;&gt;11&lt;/sup&gt;&lt;span class=&quot;footnote_tooltip&quot; id=&quot;footnote_plugin_tooltip_text_11&quot;&gt;Yes, I know you can disable these extensions with the NOEXTEND compiler directive… but obviously then you can’t use these directives.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;I would have preferred GCC-style __attribute__&lt;sup id=&quot;footnote_plugin_tooltip_12&quot; class=&quot;footnote_plugin_tooltip_text&quot; onclick=&quot;footnote_moveToAnchor('footnote_plugin_reference_12');&quot;&gt;12&lt;/sup&gt;&lt;span class=&quot;footnote_tooltip&quot; id=&quot;footnote_plugin_tooltip_text_12&quot;&gt;xdata&lt;/span&gt;or at least __xdata.&lt;/p&gt;
&lt;p&gt;A bigger problem with C51 is that, like CC-RL, it calls into pre-built math libraries whenever it needs to perform a non-native operation (such as a 16-bit multiply), instead of inlining the appropriate set of operations, as GCC does. No optimization setting will fix this behavior, and because function calls are expensive on the 8051, this has dramatic performance implications.&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Microchip XC&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Microchip produces microcontrollers of three basic designs: an 8-bit, a 16-bit, and a 32-bit. The XC8, XC16, and XC32 are the current compilers in their collection that target each of these, respective.&lt;br/&gt;These are quite different processors and, under the hood, these are quite different compilers.&lt;/p&gt;
&lt;p&gt;The 8-bit processors, in particular, have gone through slow, incremental changes over the years: from 12-bit, to 14-bit, to 16-bit program word sizes, with each bump adding more address space, new instructions, and a bit more stack space.&lt;/p&gt;
&lt;p&gt;With each improvement, these PIC devices became easier to write compilers for. The PIC18 was the first core for which Microchip supported C programming — though Hi-Tech had already developed a Keil C51-like compiler for the lower-end devices that lacked a proper stack.&lt;/p&gt;
&lt;p&gt;Eventually, Microchip acquired Hi-Tech, and combined these two disparate products into XC8, which covers all 8-bit PIC devices.&lt;/p&gt;
&lt;p&gt;None of the 8-bit PIC parts have a usable stack to store variables. To handle this shortcoming, XC8 can create a software stack on PIC18 devices, which have enough indirect addressing operators to support this.&lt;/p&gt;
&lt;p&gt;Not so on PIC10/12/16 devices. Like Keil C51, XC8 will reuse certain RAM addresses to hold local auto variables and function parameters. This works well, and is often more efficient than a stack-based approach simpler compilers can use on more advanced hardware. As mentioned with Keil C51 above, the big problem is reentrancy — when a function attempts to call itself (i.e., recursion), or when an ISR calls the same function it happened to interrupt. Here, these auto variables — which should be unique to the function’s execution — will be at the same address, thus causing possible corruption.&lt;/p&gt;
&lt;p&gt;XC8 beats out Keil C51 by tacitly duplicating any function that ISRs call into, eliminating the ISR reentrancy problem. Unfortunately, unlike Keil, XC8 has no way of forcing the compiler to generate reentrant-capable code on these midrange devices.&lt;/p&gt;
&lt;p&gt;They support optimization through the “Omniscient Code Generation” optimizer. According to the documentation, for well-written code, the main advantage to OCG is bank-tracking. Because the PIC devices use banked memory pages (for both RAM and SFRs), most source code liters bank-select statements everywhere.&lt;/p&gt;
&lt;p&gt;Most of the other optimizations — removal of dead code, unused variables, unreachable code, unused return expressions, and redundant assignments — seem only relevant to poorly-maintained code.&lt;/p&gt;
&lt;p&gt;XC16 and XC32 use GCC. Microchip doesn’t advertise the source code, but it’s available from their &lt;a href=&quot;http://www.microchip.com/development-tools/downloads-archive&quot;&gt;Archives page&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;wpb_text_column wpb_content_element&quot; id=&quot;headers&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;&lt;img data-attachment-id=&quot;1324&quot; data-permalink=&quot;https://jaycarlson.net/microcontrollers/code_2017-10-26_23-57-32/&quot; data-orig-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/Code_2017-10-26_23-57-32.png&quot; data-orig-size=&quot;895,609&quot; data-comments-opened=&quot;1&quot; data-image-meta=&quot;{&amp;quot;aperture&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;credit&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;camera&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;caption&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;created_timestamp&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;copyright&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;focal_length&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;iso&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;shutter_speed&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;orientation&amp;quot;:&amp;quot;0&amp;quot;}&quot; data-image-title=&quot;Code_2017-10-26_23-57-32&quot; data-image-description=&quot;&quot; data-medium-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/Code_2017-10-26_23-57-32-300x204.png&quot; data-large-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/Code_2017-10-26_23-57-32.png&quot; class=&quot;size-full wp-image-1324&quot; src=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/Code_2017-10-26_23-57-32.png?cbc196&amp;amp;cbc196&quot; alt=&quot;&quot; width=&quot;895&quot; height=&quot;609&quot; srcset=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/Code_2017-10-26_23-57-32.png 895w, https://jaycarlson.net/wp-content/uploads/2017/07/Code_2017-10-26_23-57-32-300x204.png 300w, https://jaycarlson.net/wp-content/uploads/2017/07/Code_2017-10-26_23-57-32-768x523.png 768w&quot; sizes=&quot;(max-width: 895px) 100vw, 895px&quot;/&gt;Nuvoton provides an entire transcript of the reference manual attached to each symbol in their header file, which is a huge step above other header-based documentation.

&lt;p&gt;I didn’t realize how important good header files were until I started working with some of these parts that simply have horrendous headers.&lt;/p&gt;
&lt;p&gt;Since MCUs rely on setting, clearing, toggling, and inspecting bits in registers, it’s convenient for the compiler and header files to provide methods for setting and clearing individual bits (and preferably bit ranges) inside registers — even if the architecture doesn’t support atomic bit instructions.&lt;/p&gt;
&lt;h4&gt;Bit-Addressable Register Access&lt;/h4&gt;
&lt;p&gt;All Microchip PIC parts, Atmel &lt;a href=&quot;https://jaycarlson.net/pf/atmel-microchip-sam-d10/&quot;&gt;SAM D10&lt;/a&gt;, and the &lt;a href=&quot;https://jaycarlson.net/pf/renesas-rl-78/&quot;&gt;RL-78&lt;/a&gt; all support bit-addressable register access. The SAM D10, in particular, is the only Arm part I’ve ever seen this feature in — and it’s fantastically useful — even if their notation is a bit heavy-handed. I’d love to see them go through and #define flat symbols to point to those structs, so instead of:&lt;/p&gt;
&lt;pre&gt;
TCC0-&amp;gt;CTRLA.bit.ENABLE = true;
&lt;/pre&gt;
&lt;p&gt;I could write&lt;/p&gt;
&lt;pre&gt;
TCC0_CTRLA_ENABLE = true;
&lt;/pre&gt;
&lt;p&gt;But at this point, I’m just nit-picking.&lt;/p&gt;
&lt;p&gt;While Renesas provides bit-addressable register definitions, there are absolutely zero docs in the header files. Same goes for Microchip PIC — there’s next to no documentation in the header files for the &lt;a href=&quot;https://jaycarlson.net/pf/microchip-pic16-five-digit-enhanced/&quot;&gt;PIC16&lt;/a&gt;, &lt;a href=&quot;https://jaycarlson.net/pf/microchip-pic24/&quot;&gt;PIC24&lt;/a&gt;, and &lt;a href=&quot;https://jaycarlson.net/pf/microchip-pic32mm/&quot;&gt;PIC32&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;It’s 2017 — storage is basically free. Header files should come chock-full of documentation, so you can keep your focus on your code — instead of having to jump around inside PDFs.&lt;/p&gt;
&lt;h4&gt;Header Documentation&lt;/h4&gt;
&lt;p&gt;By far, the best-documented header files were from the &lt;a href=&quot;https://jaycarlson.net/pf/nuvoton-m051/&quot;&gt;Nuvoton M051&lt;/a&gt;. Essentially they copy-and-pasted the entire reference manual into their header files. You get every register name and description, with every bit described in the same detail as in the official documentation. This is absolutely incredible, and really sets the standard in the industry.&lt;/p&gt;
&lt;p&gt;&lt;img data-attachment-id=&quot;492&quot; data-permalink=&quot;https://jaycarlson.net/microcontrollers/e2studio_2017-07-23_04-11-37/&quot; data-orig-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/e2studio_2017-07-23_04-11-37.png&quot; data-orig-size=&quot;762,238&quot; data-comments-opened=&quot;1&quot; data-image-meta=&quot;{&amp;quot;aperture&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;credit&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;camera&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;caption&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;created_timestamp&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;copyright&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;focal_length&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;iso&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;shutter_speed&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;orientation&amp;quot;:&amp;quot;0&amp;quot;}&quot; data-image-title=&quot;e2studio_2017-07-23_04-11-37&quot; data-image-description=&quot;&quot; data-medium-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/e2studio_2017-07-23_04-11-37-300x94.png&quot; data-large-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/e2studio_2017-07-23_04-11-37.png&quot; class=&quot;aligncenter size-full wp-image-492&quot; src=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/e2studio_2017-07-23_04-11-37.png?cbc196&amp;amp;cbc196&quot; alt=&quot;&quot; width=&quot;762&quot; height=&quot;238&quot; srcset=&quot;https://jaycarlson.net/wp-content/uploads/2017/07/e2studio_2017-07-23_04-11-37.png 762w, https://jaycarlson.net/wp-content/uploads/2017/07/e2studio_2017-07-23_04-11-37-300x94.png 300w&quot; sizes=&quot;(max-width: 762px) 100vw, 762px&quot;/&gt;Renesas, while not having &lt;a href=&quot;https://jaycarlson.net/pf/renesas-rl-78/&quot;&gt;RL-78&lt;/a&gt; header documentation, does have a bizarre pop-up PDF viewer thing that displays the relevant reference manual section when you hover-over a variable. I kind of like it, but it’s pretty heavy, and I think if I used the architecture more, I’d prefer the Nuvoton approach.&lt;/p&gt;
&lt;p&gt;Other than that, &lt;a href=&quot;https://jaycarlson.net/pf/infineon-xmc1100/&quot;&gt;Infineon&lt;/a&gt;, &lt;a href=&quot;https://jaycarlson.net/pf/st-stm32f0/&quot;&gt;ST&lt;/a&gt;, &lt;a href=&quot;https://jaycarlson.net/pf/nxp-lpc811/&quot;&gt;NXP&lt;/a&gt;, and &lt;a href=&quot;https://jaycarlson.net/pf/texas-instruments-msp430fr/&quot;&gt;Texas Instruments&lt;/a&gt; provided good documentation in their header files — though I have to fault Eclipse for not displaying this more prominently in tooltips. Often, I had to click-through to the device header file to read the register description. Atmel Studio handled doc display much better.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jaycarlson.net/pf/silicon-labs-efm8/&quot;&gt;Silicon Labs&lt;/a&gt; also provided excellent documentation, and along with the other 8051s, had all bit-addressable registers defined clearly. But because of the 8051 architecture, not all registers are bit-addressable — in fact, most aren’t.&lt;/p&gt;
&lt;p&gt;I wish Keil C51 could be coaxed into generating ORL and ANDL bitwise instructions from some sort of proprietary bit definition structure that would allow *all* bits to be manipulated independently in the same way.&lt;/p&gt;
&lt;p&gt;Even more puzzling is why there are no bitfield register definitions for the &lt;a href=&quot;https://jaycarlson.net/pf/atmel-microchip-tinyavr-1-series/&quot;&gt;tinyAVR&lt;/a&gt; or &lt;a href=&quot;https://jaycarlson.net/pf/atmel-microchip-megaavr/&quot;&gt;megaAVR&lt;/a&gt;, even though the architecture clearly supports bit manipulation. Surely there could be a proprietary AVR-GCC attribute that allowed Atmel to build header files that the compiler could use to generate &lt;code&gt;sbit&lt;/code&gt; and &lt;code&gt;clrbit&lt;/code&gt; instructions, right?&lt;/p&gt;
&lt;h4&gt;Predefined Offset Bitmasks&lt;/h4&gt;
&lt;p&gt;A (slightly inferior) alternative to bit-level register access is predefined offset macros. This is the route Silicon Labs, Texas Instruments, Infineon, NXP, and Microchip go (though again, the first three provide much better documentation). Atmel also provides this — but only for their tinyAVR.&lt;/p&gt;
&lt;h4&gt;The Worst Headers&lt;/h4&gt;
&lt;p&gt;The worst header files were from the megaAVR, the &lt;a href=&quot;https://jaycarlson.net/pf/cypress-psoc-4000s/&quot;&gt;PSoC 4000S&lt;/a&gt;, the &lt;a href=&quot;https://jaycarlson.net/pf/freescale-nxp-ke04/&quot;&gt;Kinetis KE04&lt;/a&gt;, the HT-66, the &lt;a href=&quot;https://jaycarlson.net/pf/sanyo-on-semiconductor-lc87/&quot;&gt;Sanyo LC-87&lt;/a&gt;. These header files have zero documentation, no predefined bit offsets, and no bit-addressable register definitions. Their header files are little more than register names attached to addresses.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;wpb_text_column wpb_content_element&quot; id=&quot;dev-tools&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;&lt;img data-attachment-id=&quot;760&quot; data-permalink=&quot;https://jaycarlson.net/microcontrollers/20170725-7709/&quot; data-orig-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/08/20170725-7709.jpg&quot; data-orig-size=&quot;2048,1089&quot; data-comments-opened=&quot;1&quot; data-image-meta=&quot;{&amp;quot;aperture&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;credit&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;camera&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;caption&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;created_timestamp&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;copyright&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;focal_length&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;iso&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;shutter_speed&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;orientation&amp;quot;:&amp;quot;0&amp;quot;}&quot; data-image-title=&quot;20170725-7709&quot; data-image-description=&quot;&quot; data-medium-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/08/20170725-7709-300x160.jpg&quot; data-large-file=&quot;https://jaycarlson.net/wp-content/uploads/2017/08/20170725-7709-1024x545.jpg&quot; class=&quot;size-full wp-image-760&quot; src=&quot;https://jaycarlson.net/wp-content/uploads/2017/08/20170725-7709.jpg?cbc196&amp;amp;cbc196&quot; alt=&quot;&quot; width=&quot;2048&quot; height=&quot;1089&quot; srcset=&quot;https://jaycarlson.net/wp-content/uploads/2017/08/20170725-7709.jpg 2048w, https://jaycarlson.net/wp-content/uploads/2017/08/20170725-7709-300x160.jpg 300w, https://jaycarlson.net/wp-content/uploads/2017/08/20170725-7709-768x408.jpg 768w, https://jaycarlson.net/wp-content/uploads/2017/08/20170725-7709-1024x545.jpg 1024w&quot; sizes=&quot;(max-width: 2048px) 100vw, 2048px&quot;/&gt;From left, the STM32, PSoC 4000S, Microchip SAM D10, Silicon Labs EFM8, and NXP Kinetis KL03 development boards.

&lt;p&gt;Development tools have been shrinking and simplifying over the last few years; no longer should you plan on spending hundreds of dollars on a giant beast that combines every peripheral imaginable into a horrible mess of poorly-documented schematics.&lt;/p&gt;
&lt;p&gt;For general-purpose projects that these MCUs are geared toward, I still often breadboard a first iteration of the system (usually with break-out boards for the MCU, plus modules for the peripherals). If I’m working with a big microcontroller that has a lot of support circuitry, I’ll typically use an off-the-shelf dev board. For smaller parts, I’ll toss them on a breakout board.&lt;/p&gt;
&lt;h4&gt;Breakout-Friendly Dev Boards&lt;/h4&gt;
&lt;p&gt;In terms of overall form factor, I’ll allow my personal preferences to gush out: I &lt;em&gt;love&lt;/em&gt; dev boards that integrate a debugger and a microcontroller, with nothing more than break-out pins. I think a dev board should have a row of jumpers that allow you to completely disconnect the target from the debugger.&lt;/p&gt;
&lt;p&gt;Regardless of what marketing departments think, dev boards should be free of extraneous sensors, buttons, LEDs, or anything else that a user can easily breadboard. I’m OK with capacitive-touch sliders, as long as there isn’t a lot of junk (passives) hanging off the lines.&lt;/p&gt;
&lt;p&gt;Consequently, I really enjoyed the MSP430 (and all Texas Instruments) LaunchPad boards. The integrated power measurement functionality is wonderful, and I love the no-frills jumper arrangement used to disconnect the target from the on-board debugger.&lt;/p&gt;
&lt;p&gt;I didn’t get a chance to play with the Microchip Curiosity boards, but these look appealing as well.&lt;/p&gt;
&lt;h4&gt;Snap-Apart&lt;/h4&gt;
&lt;p&gt;The snap-apart dev boards were also fun to play with — the Nuvoton N76 and M051 boards, the STM32Discovery, and the Infineon XMC1100 board. Having said that, you think they’re going to be great until you try to put them back together again. I spent several minutes in front of my bench grinder cleaning up all the snap-apart boards so they could accept standard 0.1” headers and jumpers.&lt;/p&gt;
&lt;h4&gt;Arduino UNO Form-Factor&lt;/h4&gt;
&lt;p&gt;One pet peeve of mine is the insistence on building Arduino Uno form-factor dev boards.&lt;/p&gt;
&lt;p&gt;I’m totally cool with vendors building UNO-compatible boards that support Wiring programming. This is a great way to get beginners interested in moving beyond Arduino. Nuvoton does a good job of this with the &lt;a href=&quot;https://jaycarlson.net/pf/nuvoton-m051/&quot;&gt;M0 series&lt;/a&gt;. Their &lt;a href=&quot;http://www.nuvoton.com/hq/support/tool-and-software/development-tool-hardware/numaker-uno/?__locale=en&quot;&gt;NuMaker Uno&lt;/a&gt; board uses a 5V-compatible Arm Cortex-M0 part, and they &lt;a href=&quot;https://github.com/OpenNuvoton/NuMaker_UNO&quot;&gt;provide a board support package&lt;/a&gt; for the Arduino IDE.&lt;/p&gt;
&lt;p&gt;But a lot of vendors build boards that are cosmetically similar to Arduino UNO dev boards, but have none of the software support necessary to use them with Arduino libraries or the Wiring environment in general.&lt;/p&gt;
&lt;p&gt;While many vendors are guilty of this, I have to chastise NXP specifically for this.&lt;/p&gt;
&lt;p&gt;NXP used to build fantastic little dev boards – the &lt;a href=&quot;https://www.nxp.com/products/microcontrollers-and-processors/arm-based-processors-and-mcus/lpc-cortex-m-mcus/lpc-developer-resources-/lpcxpresso-boards/lpc812-lpcxpresso-board:OM13053&quot;&gt;LPCXpresso “stick” boards&lt;/a&gt; — that were the first in the industry to have snap-off (well, cut-off) debuggers. They broke out all the pins of the MCU onto sensible 0.1” headers, making breadboard prototyping easy. These boards were great.&lt;/p&gt;
&lt;p&gt;Unfortunately, they’ve discontinued them and switched to their new &lt;a href=&quot;https://www.nxp.com/products/microcontrollers-and-processors/arm-based-processors-and-mcus/lpc-cortex-m-mcus/lpc-developer-resources-/lpcxpresso-boards/lpcxpresso812-max-board-for-lpc81x-family-mcus:OM13055&quot;&gt;LPCXpresso MAX&lt;/a&gt; boards. These new boards cram their processors — which are very unlike the ATMega328p — into an Arduino Uno form-factor.&lt;/p&gt;
&lt;p&gt;This is especially stupid for parts like the &lt;a href=&quot;https://jaycarlson.net/pf/nxp-lpc811/&quot;&gt;LPC81x series&lt;/a&gt;, which only have 11 GPIO pins (excluding SWD and crystal) and don’t even have an ADC.&lt;/p&gt;
&lt;p&gt;So what does NXP do to fit their square peg into a round hole? They throw in random I&lt;sup&gt;2&lt;/sup&gt;C GPIO and ADC peripherals to pad the LPC’s I/O count (and endow it with an ADC it doesn’t inherently have) — and then provide zero software on their downloads page for actually interacting with these peripherals.&lt;/p&gt;
&lt;p&gt;And in targeting this form factor, NXP hilariously misses the point. Do they provide Wiring support for these boards to be used inside Arduino? Nope. Do they provide libraries for all the Arduino shields that are supported by their MAX boards? Nope. Do they even have a list of which shields are compatible, and which ones are incompatible with various boards? No way.&lt;/p&gt;
&lt;p&gt;So, they’ve saved me 30 seconds by allowing me to plug a shield directly into this board (without having to use jumper wires), but haven’t done any of the actual work for me.&lt;/p&gt;
&lt;p&gt;At the same time, their debugger is no longer separable from their target, there’s a boat-load of random crap on the board that must be removed for accurate power consumption figures, and the pins no longer line up with standard 0.1” breadboards.&lt;/p&gt;
&lt;p&gt;And even if it &lt;em&gt;were&lt;/em&gt; properly executed, I think I reject the underlying goal of this strategy. The &lt;em&gt;whole purpose&lt;/em&gt; of using an Arduino UNO form-factor is to &lt;em&gt;support Arduino shields&lt;/em&gt; — yet I have &lt;em&gt;never&lt;/em&gt; seen an Arduino shield on the desk of a professional engineer or advanced hobbyist. At least, not one plugged into one of these “Uno form-factor” dev boards.&lt;/p&gt;
&lt;h4&gt;Dev Board Surgery&lt;/h4&gt;
&lt;p&gt;For the low-power part of this project, I had to do some minor surgery to the STC8, Nuvoton, and the three Atmel Xplained Mini boards covering the tinyAVR, megaAVR, and SAMD10. This mostly involved removing LEDs or separating a power trace. The schematics were clearly documented, and I consider these changes to be completely routine — just the price of admission of trying to do low-power development.&lt;/p&gt;
&lt;p&gt;While the Cypress PSoC 4000S dev board looks uncomplicated, I struggled to get accurate power consumption without several hacks that weren’t clearly documented.&lt;/p&gt;
&lt;p&gt;The Infineon board’s power subsystem was slightly confusing, as there’s no power going between the debugger and the rest of the board once you snap the two apart. Once I figured that out, I had no further issues, and I like that they took the time to put headers on the board in a way that allows the two parts to be re-joined together.&lt;/p&gt;
&lt;p&gt;I hate to say this because I was a huge fan when they first came out, but I’ve grown to fundamentally hate the Freescale (now NXP) FRDM dev boards. To even get my project to &lt;em&gt;work&lt;/em&gt;, I had to do &lt;em&gt;major&lt;/em&gt; reworking on the Kinetis KL03 FRDM board, which contained random filtering capacitors on UART RX pins. These weren’t mentioned in the documentation and were only traceable by studying six pages of schematics that came with the board.&lt;/p&gt;
&lt;p&gt;Trying to get accurate low-power measurements was a further struggle on the FRDM board, which is full of button pull-ups, LEDs, I2C sensors, and no good power separation capabilities. This dev board is a total disaster — I wouldn’t recommend it to my worst enemy. NXP needs to take a step back, simplify the board to its essence, and try again.&lt;/p&gt;
&lt;p&gt;I also had to do major hacking of the Renesas RL-78 promotional board, but this was because I was trying to be a cheap-skate and convert the kit to a general-purpose RL-78 programmer (since I needed to target a completely different microcontroller) — I can’t fault Renesas for that, but I &lt;em&gt;do&lt;/em&gt; wish their boards had debugger jumpers that would have kept me away from the soldering iron.&lt;/p&gt;
&lt;h4&gt;On-Board Debugging &amp;amp; Other Features&lt;/h4&gt;
&lt;p&gt;All dev boards tested have built-in on-board debuggers, but they varied widely in capabilities.&lt;/p&gt;
&lt;p&gt;In terms of functionality, the best dev board in the round-up is the &lt;a href=&quot;https://www.silabs.com/products/development-tools/mcu/8-bit&quot;&gt;Silicon Labs SLSTK boards&lt;/a&gt; have a full, USB 2.0 high-speed &lt;a href=&quot;https://www.segger.com/products/debug-probes/j-link/models/j-link-ob/&quot;&gt;J-Link On-Board&lt;/a&gt; debugger that has been augmented with a high-dynamic-range energy monitor, which is an amazing deal considering the cost of the dev boards ($30). While I only reviewed the EFM8 series in this review, the EFM32 ARM processors they make have nearly identical development boards.&lt;/p&gt;
&lt;p&gt;The MSP430 LaunchPad also has an energy monitor, which is still a rare feature to find in this pricing.&lt;/p&gt;
&lt;p&gt;While other manufacturers have J-Link OB debuggers, they’re usually USB 2.0 full speed, not high speed. This is the case with the Freescale KL03 and Infineon XMC1100 boards.&lt;/p&gt;
&lt;p&gt;Cypress and Microchip’s SAM D10 went with CMSIS-DAP debuggers on their boards, while the Nuvoton used their proprietary NuLink for both their Arm and 8051 controllers.&lt;/p&gt;
&lt;p&gt;Both Freescale and ST enable reprogramming the debugger firmware on their dev kits with SEGGER J-Link firmware. I don’t think anyone in the industry disagrees that J-Link is, by far, the best Arm debugger — and even operating at USB 2.0 full-speed specs (12 Mbps), flash download is snappy, and stepping through code is a breeze.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;wpb_text_column wpb_content_element&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;
&lt;h2&gt;Debug Adapters&lt;/h2&gt;
&lt;p&gt;While you can hack all current development boards to provide off-board debugging, at best this is clunky, and at worst it can be a violation of the EULA for the dev board. Serious hobbyists and professionals usually have dedicated debug adapters laying around that can easily plug into different targets they’re designing.&lt;/p&gt;
&lt;p&gt;In the Microchip camp, your choices are the &lt;a href=&quot;http://www.microchip.com/Developmenttools/ProductDetails.aspx?PartNO=PG164130&quot;&gt;PicKit3&lt;/a&gt; (&lt;a href=&quot;http://www.microchipdirect.com/ProductSearch.aspx?Keywords=PG164130&quot;&gt;$48&lt;/a&gt;), &lt;a href=&quot;http://www.microchip.com/Developmenttools/ProductDetails.aspx?PartNO=DV164045&quot;&gt;ICD4&lt;/a&gt; (&lt;a href=&quot;http://www.microchipdirect.com/product/search/all/DV164045&quot;&gt;$249&lt;/a&gt;), and &lt;a href=&quot;http://www.microchip.com/Developmenttools/ProductDetails.aspx?PartNO=DV244005&quot;&gt;RealICE&lt;/a&gt; (&lt;a href=&quot;http://www.microchipdirect.com/ProductSearch.aspx?Keywords=DV244005&quot;&gt;$499&lt;/a&gt;) — all of these debug adapters will work with all current Microchip PIC parts, but the PicKit3 is substantially slower than the ICD4, and only supports two breakpoints.&lt;/p&gt;
&lt;p&gt;The Microchip (née Atmel) AVR and SAM parts are a different story: the $130 &lt;a href=&quot;http://www.microchip.com/DevelopmentTools/ProductDetails.aspx?PartNO=ATATMEL-ICE&quot;&gt;Atmel-ICE&lt;/a&gt; is your only option, assuming you want a debugger that can target all current Atmel parts. If you’re only interested in debugging older parts, like the megaAVR and non-1-Series tinyAVR parts, you can get by with a &lt;a href=&quot;http://www.microchip.com/Developmenttools/ProductDetails.aspx?PartNO=ATAVRDRAGON&quot;&gt;$49 AVR Dragon&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The Silicon Labs EFM8 ecosystem has some of the fastest debug times, as well as some of the lowest-cost debugger hardware. Price descending, your options include the &lt;a href=&quot;https://www.segger.com/products/debug-probes/j-link/&quot;&gt;SEGGER J-Link&lt;/a&gt; debugger ($60-1000), the &lt;a href=&quot;https://www.silabs.com/products/development-tools/mcu/8-bit/8bit-mcu-accessories/8-bit-debug-adapter&quot;&gt;USB Debug Adapter&lt;/a&gt; (&lt;a href=&quot;https://www.digikey.com/product-detail/en/silicon-labs/DEBUGADPTR1-USB/336-1182-ND/807653&quot;&gt;$35&lt;/a&gt;), the &lt;a href=&quot;https://www.silabs.com/products/development-tools/mcu/8-bit/8bit-mcu-accessories/toolstick&quot;&gt;ToolStick Base Adapter&lt;/a&gt; (&lt;a href=&quot;https://www.digikey.com/product-detail/en/silicon-labs/TOOLSTICKBA/336-1345-ND/1207734&quot;&gt;$19&lt;/a&gt;), semi-sanctioned &lt;a href=&quot;https://www.ebay.com/sch/i.html?_from=R40&amp;amp;_sacat=0&amp;amp;_nkw=USB+Debug+Adapter&amp;amp;_sop=15&quot;&gt;eBay clone adapters&lt;/a&gt; ($10), or the &lt;a href=&quot;http://community.silabs.com/t5/8-bit-MCU-Knowledge-Base/Pre-Programmed-Debug-Adapter-Devices/ta-p/110859&quot;&gt;bare debugger chip&lt;/a&gt; you can use in your own design (&lt;a href=&quot;https://www.digikey.com/product-detail/en/silicon-labs/CF326-SX0261GM/CF326-SX0261GM-ND/7349647&quot;&gt;$1.78&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;In the Arm ecosystem, just shut up and buy a J-Link. Seriously. It works in every Arm IDE, with every Arm part on the market. It has the fastest debug speeds, supports any target voltage, and has unlimited software breakpoints. If you’re a student, you can get a &lt;a href=&quot;https://shop-us.segger.com/J_Link_EDU_mini_p/8.08.91.htm&quot;&gt;J-Link EDU Mini for $18&lt;/a&gt; (cheaper than clones), or the &lt;a href=&quot;https://shop-us.segger.com/J_Link_EDU_p/8.08.90.htm&quot;&gt;full EDU version for $60&lt;/a&gt;. If you’re a professional, buy the &lt;a href=&quot;http://shop-us.segger.com/J_Link_PLUS_p/8.08.28.htm&quot;&gt;$600 commercial version&lt;/a&gt; — it’s worth the handful of billable hours you’ll have to charge to pay for it.&lt;/p&gt;
&lt;p&gt;Debug adapters varied widely in speed — with the PIC16, PIC32MM, and SAM D10 taking the longest to program flash memory — the latter two took 20 seconds to program their entire flash, which is entirely too long.&lt;/p&gt;
&lt;p&gt;These parts also had the most inconsistent speeds — sometimes if I restarted my computer, they would be significantly slower or faster. I didn’t spend time fully characterizing their ineptitude, though, so your mileage may vary.&lt;/p&gt;
&lt;p&gt;The fastest IDE flash load times came from the Infineon XMC1100, running the J-Link firmware, which could fill its entire 8 KB of flash and run to main() in 2.47 seconds. That’s impressive, coming from an Eclipse-based IDE not known for its debugging kick-off abilities.&lt;/p&gt;
&lt;p&gt;Actually, the Sanyo LC87 beat it out at 1.87 seconds, but this is using their special RD87 application, which requires jumping away from their IDE to use (and has a ton of manual steps involved in loading the flash file), thus I’d take this result with a grain of salt.&lt;/p&gt;
&lt;p&gt;Other than that, the EFM8, STM8, and STC8 all had sub-5-second debug speeds when loading average-sized programs, and none took more than 6.2 seconds to fill their flash memory.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;vc_row-5cd272d4a0d1f&quot; class=&quot;vc_row wpb_row vc_row-fluid&quot;&gt;
&lt;div class=&quot;wpb_column vc_column_container vc_col-sm-12&quot;&gt;
&lt;div class=&quot;vc_column-inner&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;

&lt;div class=&quot;wpb_text_column wpb_content_element&quot; id=&quot;performance&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;
&lt;div class=&quot;title-xlarge&quot;&gt;Performance&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;vc_progress_bar wpb_content_element vc_progress-bar-color-bar_grey&quot;&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel tinyAVR &lt;span class=&quot;vc_label_units&quot;&gt;4 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel megaAVR &lt;span class=&quot;vc_label_units&quot;&gt;3 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel SAM D10 &lt;span class=&quot;vc_label_units&quot;&gt;3 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Cypress PSoC 4000S &lt;span class=&quot;vc_label_units&quot;&gt;11 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KE04 &lt;span class=&quot;vc_label_units&quot;&gt;3 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KL03 &lt;span class=&quot;vc_label_units&quot;&gt;4 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Holtek HT66 &lt;span class=&quot;vc_label_units&quot;&gt;16 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Infineon XMC1100 &lt;span class=&quot;vc_label_units&quot;&gt;9 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC16 &lt;span class=&quot;vc_label_units&quot;&gt;20 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC24 &lt;span class=&quot;vc_label_units&quot;&gt;10 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC32MM &lt;span class=&quot;vc_label_units&quot;&gt;3 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton N76 &lt;span class=&quot;vc_label_units&quot;&gt;7 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton M051 &lt;span class=&quot;vc_label_units&quot;&gt;8 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;NXP LPC811 &lt;span class=&quot;vc_label_units&quot;&gt;4 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Renesas RL78 &lt;span class=&quot;vc_label_units&quot;&gt;5 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Sanyo LC87 &lt;span class=&quot;vc_label_units&quot;&gt;18 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Silicon Labs EFM8 &lt;span class=&quot;vc_label_units&quot;&gt;8 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM8 &lt;span class=&quot;vc_label_units&quot;&gt;4 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM32F0 &lt;span class=&quot;vc_label_units&quot;&gt;9 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;STC STC8 &lt;span class=&quot;vc_label_units&quot;&gt;4 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;TI MSP430FR &lt;span class=&quot;vc_label_units&quot;&gt;7 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;wpb_text_column wpb_content_element&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;
&lt;p&gt;Some Cortex-M0+, megaAVR, and PIC32MM were able to hit 3 cycles with the help of single-cycle GPIO toggling and two-cycle jump instructions.&lt;/p&gt;
&lt;p&gt;Cortex-M0 parts can theoretically hit 5 cycles (which the XMC1100 did when running from RAM), but many of the Arm microcontrollers tested need much more — as much as 11 — due to flash caching strategies or the lack of GPIO toggle registers.&lt;/p&gt;
&lt;p&gt;Flash reading also plagued the &lt;a href=&quot;https://jaycarlson.net/pf/silicon-labs-efm8/&quot;&gt;EFM8 Laser Bee&lt;/a&gt;, which takes 8 cycles to unconditionally jump when operating at 72 MHz (though, oddly, its 8-cycle toggling performance is better than the 10 cycles it should take, if one trusts the datasheet). The &lt;a href=&quot;https://jaycarlson.net/pf/nuvoton-n76/&quot;&gt;N76&lt;/a&gt; turned in poor results caused by poor bit math performance, while the &lt;a href=&quot;https://jaycarlson.net/pf/stcmicro-stc8/&quot;&gt;STC8&lt;/a&gt;‘s 4-cycle toggle was right up there with the best.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://jaycarlson.net/pf/atmel-microchip-tinyavr-1-series/&quot;&gt;tinyAVR&lt;/a&gt; is a bit slower than the &lt;a href=&quot;https://jaycarlson.net/pf/atmel-microchip-megaavr/&quot;&gt;megaAVR&lt;/a&gt; due to its 16-bit peripheral address space, but there are special provisions for remapping specific GPIO ports into the 64-byte address space, which will give it identical performance (at the expense of only being able to access a single GPIO port from this mode).&lt;/p&gt;
&lt;p&gt;At the bottom of the pack are the 4T and 3T architectures — the &lt;a href=&quot;https://jaycarlson.net/pf/holtek-ht-66/&quot;&gt;Holtek HT66&lt;/a&gt;, the &lt;a href=&quot;https://jaycarlson.net/pf/microchip-pic16-five-digit-enhanced/&quot;&gt;Microchip PIC16&lt;/a&gt;, and the &lt;a href=&quot;https://jaycarlson.net/pf/sanyo-on-semiconductor-lc87/&quot;&gt;Sanyo LC87&lt;/a&gt;,  These 8-bit architectures must essentially load the working register with the toggle bit, XOR it into the port latches, and then jump back to the top. I’m not sure why the working register has to be reloaded each time (does the result of the XOR operation end up back in the working register before being written to the latch outputs?), and I’m planning on investigating some strange bank-select code that XC8 injects in the PIC16 loop.&lt;/p&gt;
&lt;p&gt;Speaking of weird Microchip compiler issues, XC16 — even with the optimizations cranked all the way up — generates 5-machine-cycle bit-wiggling code for the &lt;a href=&quot;https://jaycarlson.net/pf/microchip-pic24/&quot;&gt;Microchip PIC24&lt;/a&gt;, instead of a “btg” followed by a jump (which should be three machine cycles — 6 clock cycles — total).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;vc_tta-container&quot; data-vc-action=&quot;collapse&quot;&gt;
&lt;div class=&quot;vc_general vc_tta vc_tta-tabs vc_tta-color-thegem vc_tta-style-classic vc_tta-shape-rounded vc_tta-spacing-1 vc_tta-tabs-position-top vc_tta-controls-align-left&quot;&gt;

&lt;div class=&quot;vc_tta-panels-container&quot;&gt;
&lt;div class=&quot;vc_tta-panels&quot;&gt;
&lt;div class=&quot;vc_tta-panel vc_active&quot; id=&quot;1508116080202-ca28bfaf-2103&quot; data-vc-content=&quot;.vc_tta-panel-body&quot;&gt;

&lt;div class=&quot;vc_tta-panel-body&quot;&gt;
&lt;div class=&quot;vc_progress_bar wpb_content_element vc_progress-bar-color-bar_grey&quot;&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel tinyAVR &lt;span class=&quot;vc_label_units&quot;&gt;159.80 ksps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel megaAVR &lt;span class=&quot;vc_label_units&quot;&gt;123.27 ksps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel SAM D10 &lt;span class=&quot;vc_label_units&quot;&gt;1822.32 ksps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Cypress PSoC 4000S &lt;span class=&quot;vc_label_units&quot;&gt;885.69 ksps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KE04 &lt;span class=&quot;vc_label_units&quot;&gt;1715.36 ksps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KL03 &lt;span class=&quot;vc_label_units&quot;&gt;1645.24 ksps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Holtek HT66 &lt;span class=&quot;vc_label_units&quot;&gt;2.71 ksps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Infineon XMC1100 &lt;span class=&quot;vc_label_units&quot;&gt;805.84 ksps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC16 &lt;span class=&quot;vc_label_units&quot;&gt;21.83 ksps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC24 &lt;span class=&quot;vc_label_units&quot;&gt;838.46 ksps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC32MM &lt;span class=&quot;vc_label_units&quot;&gt;829.88 ksps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton N76 &lt;span class=&quot;vc_label_units&quot;&gt;38.79 ksps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton M051 &lt;span class=&quot;vc_label_units&quot;&gt;1732.07 ksps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;NXP LPC811 &lt;span class=&quot;vc_label_units&quot;&gt;731.93 ksps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Renesas RL78 &lt;span class=&quot;vc_label_units&quot;&gt;731.68 ksps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Sanyo LC87 &lt;span class=&quot;vc_label_units&quot;&gt;23.55 ksps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Silicon Labs EFM8 &lt;span class=&quot;vc_label_units&quot;&gt;202.40 ksps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM8 &lt;span class=&quot;vc_label_units&quot;&gt;79.49 ksps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM32F0 &lt;span class=&quot;vc_label_units&quot;&gt;1647.79 ksps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;STC STC8 &lt;span class=&quot;vc_label_units&quot;&gt;156.56 ksps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;TI MSP430FR &lt;span class=&quot;vc_label_units&quot;&gt;129.95 ksps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;vc_tta-panel&quot; id=&quot;1509922081005-f6dc4fcd-547d&quot; data-vc-content=&quot;.vc_tta-panel-body&quot;&gt;

&lt;div class=&quot;vc_tta-panel-body&quot;&gt;
&lt;div class=&quot;vc_progress_bar wpb_content_element vc_progress-bar-color-bar_grey&quot;&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel tinyAVR &lt;span class=&quot;vc_label_units&quot;&gt;63 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel megaAVR &lt;span class=&quot;vc_label_units&quot;&gt;65 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel SAM D10 &lt;span class=&quot;vc_label_units&quot;&gt;27 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Cypress PSoC 4000S &lt;span class=&quot;vc_label_units&quot;&gt;27 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KE04 &lt;span class=&quot;vc_label_units&quot;&gt;28 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KL03 &lt;span class=&quot;vc_label_units&quot;&gt;29 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Holtek HT66 &lt;span class=&quot;vc_label_units&quot;&gt;1333 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Infineon XMC1100 &lt;span class=&quot;vc_label_units&quot;&gt;40 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC16 &lt;span class=&quot;vc_label_units&quot;&gt;1466 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC24 &lt;span class=&quot;vc_label_units&quot;&gt;38 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC32MM &lt;span class=&quot;vc_label_units&quot;&gt;30 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton N76 &lt;span class=&quot;vc_label_units&quot;&gt;412 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton M051 &lt;span class=&quot;vc_label_units&quot;&gt;29 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;NXP LPC811 &lt;span class=&quot;vc_label_units&quot;&gt;41 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Renesas RL78 &lt;span class=&quot;vc_label_units&quot;&gt;33 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Sanyo LC87 &lt;span class=&quot;vc_label_units&quot;&gt;510 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Silicon Labs EFM8 &lt;span class=&quot;vc_label_units&quot;&gt;272 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM8 &lt;span class=&quot;vc_label_units&quot;&gt;201 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM32F0 &lt;span class=&quot;vc_label_units&quot;&gt;29 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;STC STC8 &lt;span class=&quot;vc_label_units&quot;&gt;153 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;TI MSP430FR &lt;span class=&quot;vc_label_units&quot;&gt;123 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;vc_tta-panel&quot; id=&quot;1508116080269-02bea776-e56a&quot; data-vc-content=&quot;.vc_tta-panel-body&quot;&gt;

&lt;div class=&quot;vc_tta-panel-body&quot;&gt;
&lt;div class=&quot;vc_progress_bar wpb_content_element vc_progress-bar-color-bar_grey&quot;&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel tinyAVR &lt;span class=&quot;vc_label_units&quot;&gt;3.34 mA&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel megaAVR &lt;span class=&quot;vc_label_units&quot;&gt;3.11 mA&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel SAM D10 &lt;span class=&quot;vc_label_units&quot;&gt;5.09 mA&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Cypress PSoC 4000S &lt;span class=&quot;vc_label_units&quot;&gt;3.66 mA&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KE04 &lt;span class=&quot;vc_label_units&quot;&gt;14.31 mA&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KL03 &lt;span class=&quot;vc_label_units&quot;&gt;5.21 mA&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Holtek HT66 &lt;span class=&quot;vc_label_units&quot;&gt;1.89 mA&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Infineon XMC1100 &lt;span class=&quot;vc_label_units&quot;&gt;4.24 mA&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC16 &lt;span class=&quot;vc_label_units&quot;&gt;3.61 mA&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC24 &lt;span class=&quot;vc_label_units&quot;&gt;10.74 mA&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC32MM &lt;span class=&quot;vc_label_units&quot;&gt;7.65 mA&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton N76 &lt;span class=&quot;vc_label_units&quot;&gt;3.64 mA&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton M051 &lt;span class=&quot;vc_label_units&quot;&gt;19.16 mA&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;NXP LPC811 &lt;span class=&quot;vc_label_units&quot;&gt;4.43 mA&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Renesas RL78 &lt;span class=&quot;vc_label_units&quot;&gt;3.79 mA&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Sanyo LC87 &lt;span class=&quot;vc_label_units&quot;&gt;6.51 mA&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Silicon Labs EFM8 &lt;span class=&quot;vc_label_units&quot;&gt;14.15 mA&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM8 &lt;span class=&quot;vc_label_units&quot;&gt;6.45 mA&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM32F0 &lt;span class=&quot;vc_label_units&quot;&gt;12.15 mA&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;STC STC8 &lt;span class=&quot;vc_label_units&quot;&gt;11.87 mA&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;TI MSP430FR &lt;span class=&quot;vc_label_units&quot;&gt;2.41 mA&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;vc_tta-panel&quot; id=&quot;1508116139102-c4613248-e204&quot; data-vc-content=&quot;.vc_tta-panel-body&quot;&gt;

&lt;div class=&quot;vc_tta-panel-body&quot;&gt;
&lt;div class=&quot;vc_progress_bar wpb_content_element vc_progress-bar-color-bar_grey&quot;&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel tinyAVR &lt;span class=&quot;vc_label_units&quot;&gt;69.01 nJ/Sample&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel megaAVR &lt;span class=&quot;vc_label_units&quot;&gt;83.26 nJ/Sample&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel SAM D10 &lt;span class=&quot;vc_label_units&quot;&gt;9.22 nJ/Sample&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Cypress PSoC 4000S &lt;span class=&quot;vc_label_units&quot;&gt;13.64 nJ/Sample&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KE04 &lt;span class=&quot;vc_label_units&quot;&gt;27.53 nJ/Sample&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KL03 &lt;span class=&quot;vc_label_units&quot;&gt;10.45 nJ/Sample&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Holtek HT66 &lt;span class=&quot;vc_label_units&quot;&gt;2304.95 nJ/Sample&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Infineon XMC1100 &lt;span class=&quot;vc_label_units&quot;&gt;17.36 nJ/Sample&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC16 &lt;span class=&quot;vc_label_units&quot;&gt;545.76 nJ/Sample&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC24 &lt;span class=&quot;vc_label_units&quot;&gt;42.27 nJ/Sample&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC32MM &lt;span class=&quot;vc_label_units&quot;&gt;30.42 nJ/Sample&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton N76 &lt;span class=&quot;vc_label_units&quot;&gt;309.68 nJ/Sample&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton M051 &lt;span class=&quot;vc_label_units&quot;&gt;36.50 nJ/Sample&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;NXP LPC811 &lt;span class=&quot;vc_label_units&quot;&gt;20.00 nJ/Sample&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Renesas RL78 &lt;span class=&quot;vc_label_units&quot;&gt;17.09 nJ/Sample&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Sanyo LC87 &lt;span class=&quot;vc_label_units&quot;&gt;912.36 nJ/Sample&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Silicon Labs EFM8 &lt;span class=&quot;vc_label_units&quot;&gt;176.20 nJ/Sample&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM8 &lt;span class=&quot;vc_label_units&quot;&gt;267.76 nJ/Sample&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM32F0 &lt;span class=&quot;vc_label_units&quot;&gt;24.33 nJ/Sample&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;STC STC8 &lt;span class=&quot;vc_label_units&quot;&gt;192.24 nJ/Sample&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;TI MSP430FR &lt;span class=&quot;vc_label_units&quot;&gt;61.20 nJ/Sample&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;wpb_text_column wpb_content_element&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;
&lt;p&gt;I’m going to discuss the 8-bit and 16/32-bit results separately, as there are nearly three orders of magnitude of variation among all the parts — with a clear demarcation between the 8-bit and 16/32-bit parts.&lt;/p&gt;
&lt;h2&gt;16/32-bit Processors&lt;/h2&gt;
&lt;p&gt;Except for the &lt;a href=&quot;https://jaycarlson.net/pf/texas-instruments-msp430fr/&quot;&gt;MSP430&lt;/a&gt; — which doesn’t have a hardware multiplier in the part I tested — all the 16- and 32-bit microcontrollers had similar results in terms of clock-cycle efficiency.&lt;/p&gt;
&lt;p&gt;The Arm parts were the fastest in the round-up. I think the &lt;a href=&quot;https://jaycarlson.net/pf/atmel-microchip-sam-d10/&quot;&gt;Atmel D10&lt;/a&gt;‘s PLL was running a bit hotter than 48 MHz, which allowed it to edge out over the other 48 MHz ARM parts.&lt;/p&gt;
&lt;p&gt;Looking at clock efficiency, I suspect the variation we see between parts is primarily the result of flash caching. Parts that have good flash caching can get near 27 clock cycles per filtering loop.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://jaycarlson.net/pf/cypress-psoc-4000s/&quot;&gt;PSoC&lt;/a&gt; doesn’t need a flash accelerator since it can only run at 24 MHz — thus, it can access flash at full speed with no wait-states, and can consequently hit 27 cycles.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://jaycarlson.net/pf/infineon-xmc1100/&quot;&gt;Infineon XMC1100&lt;/a&gt;, on the other hand, only seems to be able to read flash with no wait-states when operating at 8 MHz or below. It has no flash accelerator either, which deeply penalizes its scores. However, when the part runs code from RAM instead of flash, it hits 27 cycles (at very low power figures, too). I discuss this more in the &lt;a href=&quot;https://jaycarlson.net/pf/infineon-xmc1100/&quot;&gt;XMC1100 article&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The MIPS-based 32-bit &lt;a href=&quot;https://jaycarlson.net/pf/microchip-pic32mm/&quot;&gt;Microchip PIC32&lt;/a&gt; holds its own — just three cycles shy of the Cortex-M0+ results. Like the &lt;a href=&quot;https://jaycarlson.net/pf/cypress-psoc-4000s/&quot;&gt;PSoC 4000S&lt;/a&gt;, this part runs slow enough to not need a flash accelerator. Before committing to higher-speed PIC32MX devices, I’d have to investigate the flash caching.&lt;/p&gt;
&lt;p&gt;I was blown away by the performance of the 16-bit &lt;a href=&quot;https://jaycarlson.net/pf/renesas-rl-78/&quot;&gt;Renesas RL-78&lt;/a&gt;, which only has 8-bit data pathways. It was only 6 cycles away from the hot-rod Cortex-M0+ parts, and pulled 7 cycles faster than the &lt;a href=&quot;https://jaycarlson.net/pf/microchip-pic24/&quot;&gt;PIC24&lt;/a&gt;, which is a true 16-bit design. I only wish it had a faster core speed.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;wpb_text_column wpb_content_element&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;
&lt;h2&gt;8-Bit Processors&lt;/h2&gt;
&lt;p&gt;Compared to the 16/32-bit results, the 8-bit processors can be described as either “mediocre” or “absolutely awful.”&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://jaycarlson.net/pf/microchip-pic16-five-digit-enhanced/&quot;&gt;Microchip PIC16&lt;/a&gt; and &lt;a href=&quot;https://jaycarlson.net/pf/holtek-ht-66/&quot;&gt;Holtek HT-66&lt;/a&gt; — with similar single-register 4T architectures — arrive at the party dead-last in terms of clock cycle count. These parts simply aren’t built to be doing much math at all; let along 16-bit multiplies and accumulates.&lt;/p&gt;
&lt;p&gt;Because slow microcontrollers take a long time to process data, they’re often overwhelmed by static power consumption, and this test verifies this. The HT66, LC87, and PIC16 both required more than 500 nJ/sample to process the data — so much that I ended up clipping the data in the graph to help better show the variation of the more-efficient parts (without resorting to logarithmic plots).&lt;/p&gt;
&lt;p&gt;At the other end of the spectrum lies the &lt;a href=&quot;https://jaycarlson.net/pf/atmel-microchip-tinyavr-1-series/&quot;&gt;tinyAVR&lt;/a&gt; and &lt;a href=&quot;https://jaycarlson.net/pf/atmel-microchip-megaavr/&quot;&gt;megaAVR&lt;/a&gt; processors, which both brought in excellent clock-cycle counts.&lt;/p&gt;
&lt;p&gt;By the way, it’s important to note that neither of these AVR parts are running at full speed in this test. The &lt;a href=&quot;https://jaycarlson.net/pf/atmel-microchip-tinyavr-1-series/&quot;&gt;tinyAVR&lt;/a&gt; has an internal 20 MHz oscillator that has to be scaled down to 10 MHz so I can run the part at 3.3V without violating the ratings in the datasheet. The &lt;a href=&quot;https://jaycarlson.net/pf/atmel-microchip-megaavr/&quot;&gt;megaAVR&lt;/a&gt; only has an 8 MHz internal oscillator, so that’s what I have to run it on.&lt;/p&gt;
&lt;p&gt;Both these parts are capable of 20 MHz operation, so it’s a little silly to have to down-clock them because Atmel doesn’t build these parts on a modern process allowing 1.8-3.6V operation at full speed, like most other parts tested. Every other part tested has a full-speed, better-than-2% oscillator; the &lt;a href=&quot;https://jaycarlson.net/pf/atmel-microchip-megaavr/&quot;&gt;megaAVR&lt;/a&gt; is stuck with an atrociously inaccurate 8 MHz job that severely limits the performance you can get out of this part. It’s 2017 — crystals on MCUs should only be necessary for RTCs and RF.&lt;/p&gt;
&lt;p&gt;Anyway, back to the data: this should settle the PIC vs AVR debate about performance. Yes, the AVR typically has a lower clock speed, but unless you can run a PIC16 at 176 MHz, an 8 MHz AVR is going to win the math performance tests handily.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://jaycarlson.net/pf/sanyo-on-semiconductor-lc87/&quot;&gt;Sanyo LC87&lt;/a&gt; and &lt;a href=&quot;https://jaycarlson.net/pf/st-stm8/&quot;&gt;STM8&lt;/a&gt; are both better than the &lt;a href=&quot;https://jaycarlson.net/pf/holtek-ht-66/&quot;&gt;HT66&lt;/a&gt; and the &lt;a href=&quot;https://jaycarlson.net/pf/microchip-pic16-five-digit-enhanced/&quot;&gt;PIC16&lt;/a&gt;, but both have slow core speeds that limit their performance.&lt;/p&gt;
&lt;h2 id=&quot;battle-of-the-8051s&quot;&gt;Battle of the 8051s&lt;/h2&gt;
&lt;p&gt;One of the most interesting narrative that came out of this test was the wildly different performance numbers the 8051s produced.&lt;/p&gt;
&lt;p&gt;First thing’s first: Keil C51 struggled to generate good code in the biquad experiment — the biggest problem being the 16-bit multiplication. Rather than producing raw assembly that operates on whichever registers end up with these variables, Keil generates function calls into a signed-16-bit multiply library routine. This has drastic performance implications when compared to the much-better AVR-GCC code.&lt;/p&gt;
&lt;p&gt;With that said, the three different 8051s running &lt;strong&gt;identical&lt;/strong&gt; binary images produced very different results — caused by both clock-cycle efficiency and core speed. Let’s dig in a bit:&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;vc_chart vc_line-chart wpb_content_element&quot; data-vc-legend=&quot;1&quot; data-vc-tooltips=&quot;1&quot; data-vc-animation=&quot;easeinOutCubic&quot; data-vc-type=&quot;bar&quot; data-vc-values=&quot;{&amp;quot;labels&amp;quot;:[&amp;quot;1 cycle&amp;quot;,&amp;quot; 2 or fewer cycles&amp;quot;,&amp;quot; 3 or fewer cycles&amp;quot;,&amp;quot; 4 or fewer cycles&amp;quot;],&amp;quot;datasets&amp;quot;:[{&amp;quot;label&amp;quot;:&amp;quot;STC8&amp;quot;,&amp;quot;fillColor&amp;quot;:&amp;quot;#fe6c61&amp;quot;,&amp;quot;strokeColor&amp;quot;:&amp;quot;#fe6c61&amp;quot;,&amp;quot;pointColor&amp;quot;:&amp;quot;#fe6c61&amp;quot;,&amp;quot;pointStrokeColor&amp;quot;:&amp;quot;#fe6c61&amp;quot;,&amp;quot;highlightFill&amp;quot;:&amp;quot;#fe5043&amp;quot;,&amp;quot;highlightStroke&amp;quot;:&amp;quot;#fe5043&amp;quot;,&amp;quot;pointHighlightFill&amp;quot;:&amp;quot;#fe5043&amp;quot;,&amp;quot;pointHighlightStroke&amp;quot;:&amp;quot;#fe5043&amp;quot;,&amp;quot;data&amp;quot;:[&amp;quot;82&amp;quot;,&amp;quot;86&amp;quot;,&amp;quot;96&amp;quot;,&amp;quot;98&amp;quot;]},{&amp;quot;label&amp;quot;:&amp;quot;EFM8&amp;quot;,&amp;quot;fillColor&amp;quot;:&amp;quot;#8d6dc4&amp;quot;,&amp;quot;strokeColor&amp;quot;:&amp;quot;#8d6dc4&amp;quot;,&amp;quot;pointColor&amp;quot;:&amp;quot;#8d6dc4&amp;quot;,&amp;quot;pointStrokeColor&amp;quot;:&amp;quot;#8d6dc4&amp;quot;,&amp;quot;highlightFill&amp;quot;:&amp;quot;#7c57bb&amp;quot;,&amp;quot;highlightStroke&amp;quot;:&amp;quot;#7c57bb&amp;quot;,&amp;quot;pointHighlightFill&amp;quot;:&amp;quot;#7c57bb&amp;quot;,&amp;quot;pointHighlightStroke&amp;quot;:&amp;quot;#7c57bb&amp;quot;,&amp;quot;data&amp;quot;:[&amp;quot;23&amp;quot;,&amp;quot;73&amp;quot;,&amp;quot;93&amp;quot;,&amp;quot;95&amp;quot;]},{&amp;quot;label&amp;quot;:&amp;quot;STC15W&amp;quot;,&amp;quot;fillColor&amp;quot;:&amp;quot;#4cadc9&amp;quot;,&amp;quot;strokeColor&amp;quot;:&amp;quot;#4cadc9&amp;quot;,&amp;quot;pointColor&amp;quot;:&amp;quot;#4cadc9&amp;quot;,&amp;quot;pointStrokeColor&amp;quot;:&amp;quot;#4cadc9&amp;quot;,&amp;quot;highlightFill&amp;quot;:&amp;quot;#39a0bd&amp;quot;,&amp;quot;highlightStroke&amp;quot;:&amp;quot;#39a0bd&amp;quot;,&amp;quot;pointHighlightFill&amp;quot;:&amp;quot;#39a0bd&amp;quot;,&amp;quot;pointHighlightStroke&amp;quot;:&amp;quot;#39a0bd&amp;quot;,&amp;quot;data&amp;quot;:[&amp;quot;20&amp;quot;,&amp;quot;53&amp;quot;,&amp;quot;81&amp;quot;,&amp;quot;92&amp;quot;]},{&amp;quot;label&amp;quot;:&amp;quot;Nuvoton N76&amp;quot;,&amp;quot;fillColor&amp;quot;:&amp;quot;#5472d2&amp;quot;,&amp;quot;strokeColor&amp;quot;:&amp;quot;#5472d2&amp;quot;,&amp;quot;pointColor&amp;quot;:&amp;quot;#5472d2&amp;quot;,&amp;quot;pointStrokeColor&amp;quot;:&amp;quot;#5472d2&amp;quot;,&amp;quot;highlightFill&amp;quot;:&amp;quot;#3c5ecc&amp;quot;,&amp;quot;highlightStroke&amp;quot;:&amp;quot;#3c5ecc&amp;quot;,&amp;quot;pointHighlightFill&amp;quot;:&amp;quot;#3c5ecc&amp;quot;,&amp;quot;pointHighlightStroke&amp;quot;:&amp;quot;#3c5ecc&amp;quot;,&amp;quot;data&amp;quot;:[&amp;quot;15&amp;quot;,&amp;quot;30&amp;quot;,&amp;quot;55&amp;quot;,&amp;quot;86&amp;quot;]}]}&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;

&lt;ul class=&quot;vc_chart-legend&quot;&gt;&lt;li&gt;STC8&lt;/li&gt;
&lt;li&gt;EFM8&lt;/li&gt;
&lt;li&gt;STC15W&lt;/li&gt;
&lt;li&gt;Nuvoton N76&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;wpb_text_column wpb_content_element&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;
&lt;p&gt;I’ve plotted a cycle-count cumulative distribution above — I’ve included the STC15, an older part closely related to the &lt;a href=&quot;https://jaycarlson.net/pf/stcmicro-stc8/&quot;&gt;STC8&lt;/a&gt; (and mentioned extensively in the STC8 review). The STC8 manages to execute 82% of its instruction set in a single cycle, and 96% of its instructions in three or fewer cycles. The other parts — the &lt;a href=&quot;https://jaycarlson.net/pf/silicon-labs-efm8/&quot;&gt;EFM8&lt;/a&gt;, older STC15W, and &lt;a href=&quot;https://jaycarlson.net/pf/nuvoton-n76/&quot;&gt;N76&lt;/a&gt; — have much fewer single-cycle instructions. The &lt;a href=&quot;https://jaycarlson.net/pf/silicon-labs-efm8/&quot;&gt;EFM8&lt;/a&gt; starts to catch up to the STC8, while the &lt;a href=&quot;https://jaycarlson.net/pf/nuvoton-n76/&quot;&gt;N76&lt;/a&gt; remains much further behind.&lt;/p&gt;
&lt;p&gt;Multiplies are two-cycle instructions on the &lt;a href=&quot;https://jaycarlson.net/pf/stcmicro-stc8/&quot;&gt;STC8&lt;/a&gt; and STC15 — twice as fast as the &lt;a href=&quot;https://jaycarlson.net/pf/silicon-labs-efm8/&quot;&gt;EFM8&lt;/a&gt; and &lt;a href=&quot;https://jaycarlson.net/pf/nuvoton-n76/&quot;&gt;N76&lt;/a&gt;.&lt;sup id=&quot;footnote_plugin_tooltip_13&quot; class=&quot;footnote_plugin_tooltip_text&quot; onclick=&quot;footnote_moveToAnchor('footnote_plugin_reference_13');&quot;&gt;13&lt;/sup&gt;&lt;span class=&quot;footnote_tooltip&quot; id=&quot;footnote_plugin_tooltip_text_13&quot;&gt;The &lt;a href=&quot;https://jaycarlson.net/pf/nuvoton-n76/&quot;&gt;N76&lt;/a&gt; and STC15 have poor performance at bit arithmetic (4 and 3 cycles, respectively) compared to the single-cycle EFM8 and STC8, but this shouldn’t affect the results of this experiment.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The big advantage the &lt;a href=&quot;https://jaycarlson.net/pf/stcmicro-stc8/&quot;&gt;STC8&lt;/a&gt; has, though, is memory operations. STCmicro gave this part a large, parallel-fetch interface that allows it to read three or more bytes out of flash in a single cycle. That allows it to perform long op-code instructions — like “load immediate value into RAM location” — in a single cycle. This is a three-byte instruction which takes three cycles on the &lt;a href=&quot;https://jaycarlson.net/pf/nuvoton-n76/&quot;&gt;N76&lt;/a&gt; and &lt;a href=&quot;https://jaycarlson.net/pf/silicon-labs-efm8/&quot;&gt;EFM8&lt;/a&gt;. While these architectures are pipelined, they still have a single-byte fetch, which means the length of the instruction is the main factor dictating how many cycles it will take to execute.&lt;/p&gt;
&lt;p&gt;When pitted against the 8-bit darling of the RISC movement — the AVR — things get interesting.&lt;/p&gt;
&lt;p&gt;On the AVR, there simply is no instruction to do anything with RAM other than move it from/to registers — so to “load immediate value into RAM location” you must first load an immediate value into a register (1 cycle), and then load the register into RAM (2 cycles). This is a three-cycle operation in total.&lt;/p&gt;
&lt;p&gt;This may look like there’s no performance difference between the AVR and the 8051, but there’s a major hiccup for the 8051: there are only 128 bytes of true RAM in the 8051 — not enough to hold the 64-word 16-bit data arrays in this experiment.&lt;/p&gt;
&lt;p&gt;On the 8051, to access 16-bit extended memory (XRAM), you have to load the RAM address in the DPTR, load the direct value into the accumulator, and then move the accumulator to @DPTR. On the slowest 8051 — the &lt;a href=&quot;https://jaycarlson.net/pf/nuvoton-n76/&quot;&gt;N76&lt;/a&gt; — those operations take 3, 2, and 6 cycles, respectively — 10 cycles total. On the &lt;a href=&quot;https://jaycarlson.net/pf/silicon-labs-efm8/&quot;&gt;EFM8&lt;/a&gt;, those operations take 3, 2, and 3 cycles — 8 cycles total.&lt;/p&gt;
&lt;p&gt;Compare that to the two-instruction, three-cycle AVR routine, which can actually store the immediate value to &lt;em&gt;any&lt;/em&gt; RAM address — all 65,535 of them.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://jaycarlson.net/pf/stcmicro-stc8/&quot;&gt;STC8&lt;/a&gt; comes closest to the AVR: it can perform these XRAM operations in 4 cycles total.&lt;/p&gt;
&lt;p&gt;While this is still a penalty to pay when compared to AVR, consider that almost all RAM move instructions — and RAM arithmetic instructions — are single-cycle on the STC8. Since STC8 RAM is no slower than access to the 8 available registers the 8051 has, you get essentially 128 extra registers for free.&lt;/p&gt;
&lt;p&gt;While the lousy Keil C51 code prevents you from comparing across AVR and 8051 parts in this experiment, note that the &lt;a href=&quot;https://jaycarlson.net/pf/stcmicro-stc8/&quot;&gt;STC8&lt;/a&gt; only needs 153 clock cycles — compared to the 272 and 413 of the &lt;a href=&quot;https://jaycarlson.net/pf/silicon-labs-efm8/&quot;&gt;EFM8&lt;/a&gt; and &lt;a href=&quot;https://jaycarlson.net/pf/nuvoton-n76/&quot;&gt;N76&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Sure, the &lt;a href=&quot;https://jaycarlson.net/pf/silicon-labs-efm8/&quot;&gt;EFM8&lt;/a&gt; wins the overall prize in the 8-bit segment in this test. But it chugs to the finish line relying exclusively on its 72 MHz clock, which is running 9 times faster than the &lt;a href=&quot;https://jaycarlson.net/pf/atmel-microchip-megaavr/&quot;&gt;megaAVR&lt;/a&gt;‘s 8 MHz oscillator, while only performing about twice as fast as it is.&lt;/p&gt;
&lt;p&gt;And the &lt;a href=&quot;https://jaycarlson.net/pf/silicon-labs-efm8/&quot;&gt;EFM8&lt;/a&gt; uses so much power that the standard adage — run as fast as possible to minimize static power — goes out the window. The slower &lt;a href=&quot;https://jaycarlson.net/pf/atmel-microchip-megaavr/&quot;&gt;megaAVR&lt;/a&gt; and &lt;a href=&quot;https://jaycarlson.net/pf/atmel-microchip-tinyavr-1-series/&quot;&gt;tinyAVR&lt;/a&gt; both use less power than the EFM8 and STC8.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;vc_tta-container&quot; data-vc-action=&quot;collapse&quot;&gt;
&lt;div class=&quot;vc_general vc_tta vc_tta-tabs vc_tta-color-thegem vc_tta-style-classic vc_tta-shape-rounded vc_tta-spacing-1 vc_tta-tabs-position-top vc_tta-controls-align-left&quot;&gt;

&lt;div class=&quot;vc_tta-panels-container&quot;&gt;
&lt;div class=&quot;vc_tta-panels&quot;&gt;
&lt;div class=&quot;vc_tta-panel vc_active&quot; id=&quot;1508117441704-38dd8244-c194&quot; data-vc-content=&quot;.vc_tta-panel-body&quot;&gt;

&lt;div class=&quot;vc_tta-panel-body&quot;&gt;
&lt;div class=&quot;vc_progress_bar wpb_content_element vc_progress-bar-color-bar_grey&quot;&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel tinyAVR &lt;span class=&quot;vc_label_units&quot;&gt;1430 microamps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel megaAVR &lt;span class=&quot;vc_label_units&quot;&gt;1270 microamps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel SAM D10 &lt;span class=&quot;vc_label_units&quot;&gt;3410 microamps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Cypress PSoC 4000S &lt;span class=&quot;vc_label_units&quot;&gt;1030 microamps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KE04 &lt;span class=&quot;vc_label_units&quot;&gt;3340 microamps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KL03 &lt;span class=&quot;vc_label_units&quot;&gt;1340 microamps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Holtek HT66 &lt;span class=&quot;vc_label_units&quot;&gt;568 microamps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Infineon XMC1100 &lt;span class=&quot;vc_label_units&quot;&gt;1390 microamps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC16 &lt;span class=&quot;vc_label_units&quot;&gt;470 microamps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC24 &lt;span class=&quot;vc_label_units&quot;&gt;667 microamps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC32MM &lt;span class=&quot;vc_label_units&quot;&gt;493 microamps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton N76 &lt;span class=&quot;vc_label_units&quot;&gt;1750 microamps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton M051 &lt;span class=&quot;vc_label_units&quot;&gt;1970 microamps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;NXP LPC811 &lt;span class=&quot;vc_label_units&quot;&gt;3440 microamps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Renesas RL78 &lt;span class=&quot;vc_label_units&quot;&gt;516 microamps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Sanyo LC87 &lt;span class=&quot;vc_label_units&quot;&gt;6420 microamps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Silicon Labs EFM8 &lt;span class=&quot;vc_label_units&quot;&gt;607 microamps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM8 &lt;span class=&quot;vc_label_units&quot;&gt;1620 microamps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM32F0 &lt;span class=&quot;vc_label_units&quot;&gt;769 microamps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;STC STC8 &lt;span class=&quot;vc_label_units&quot;&gt;5470 microamps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;TI MSP430FR &lt;span class=&quot;vc_label_units&quot;&gt;279 microamps&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;vc_tta-panel&quot; id=&quot;1508117851676-454e0f0f-46a7&quot; data-vc-content=&quot;.vc_tta-panel-body&quot;&gt;

&lt;div class=&quot;vc_tta-panel-body&quot;&gt;
&lt;div class=&quot;vc_progress_bar wpb_content_element vc_progress-bar-color-bar_grey&quot;&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel tinyAVR &lt;span class=&quot;vc_label_units&quot;&gt;33 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel megaAVR &lt;span class=&quot;vc_label_units&quot;&gt;34 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel SAM D10 &lt;span class=&quot;vc_label_units&quot;&gt;391 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Cypress PSoC 4000S &lt;span class=&quot;vc_label_units&quot;&gt;35 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KE04 &lt;span class=&quot;vc_label_units&quot;&gt;25 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KL03 &lt;span class=&quot;vc_label_units&quot;&gt;33 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Holtek HT66 &lt;span class=&quot;vc_label_units&quot;&gt;73 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Infineon XMC1100 &lt;span class=&quot;vc_label_units&quot;&gt;16 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC16 &lt;span class=&quot;vc_label_units&quot;&gt;34 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC24 &lt;span class=&quot;vc_label_units&quot;&gt;22 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC32MM &lt;span class=&quot;vc_label_units&quot;&gt;62 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton N76 &lt;span class=&quot;vc_label_units&quot;&gt;32 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton M051 &lt;span class=&quot;vc_label_units&quot;&gt;35 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;NXP LPC811 &lt;span class=&quot;vc_label_units&quot;&gt;45 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Renesas RL78 &lt;span class=&quot;vc_label_units&quot;&gt;25 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Sanyo LC87 &lt;span class=&quot;vc_label_units&quot;&gt;28 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Silicon Labs EFM8 &lt;span class=&quot;vc_label_units&quot;&gt;26 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM8 &lt;span class=&quot;vc_label_units&quot;&gt;39 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM32F0 &lt;span class=&quot;vc_label_units&quot;&gt;24 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;STC STC8 &lt;span class=&quot;vc_label_units&quot;&gt;6 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;TI MSP430FR &lt;span class=&quot;vc_label_units&quot;&gt;16 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;vc_tta-panel&quot; id=&quot;1508117441786-1e2c8d2b-93a9&quot; data-vc-content=&quot;.vc_tta-panel-body&quot;&gt;

&lt;div class=&quot;vc_tta-panel-body&quot;&gt;
&lt;div class=&quot;vc_progress_bar wpb_content_element vc_progress-bar-color-bar_grey&quot;&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel tinyAVR &lt;span class=&quot;vc_label_units&quot;&gt;36 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel megaAVR &lt;span class=&quot;vc_label_units&quot;&gt;33 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel SAM D10 &lt;span class=&quot;vc_label_units&quot;&gt;86 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Cypress PSoC 4000S &lt;span class=&quot;vc_label_units&quot;&gt;89 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KE04 &lt;span class=&quot;vc_label_units&quot;&gt;255 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KL03 &lt;span class=&quot;vc_label_units&quot;&gt;69 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Holtek HT66 &lt;span class=&quot;vc_label_units&quot;&gt;166 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Infineon XMC1100 &lt;span class=&quot;vc_label_units&quot;&gt;56 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC16 &lt;span class=&quot;vc_label_units&quot;&gt;201 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC24 &lt;span class=&quot;vc_label_units&quot;&gt;31 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC32MM &lt;span class=&quot;vc_label_units&quot;&gt;29 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton N76 &lt;span class=&quot;vc_label_units&quot;&gt;71 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton M051 &lt;span class=&quot;vc_label_units&quot;&gt;54 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;NXP LPC811 &lt;span class=&quot;vc_label_units&quot;&gt;115 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Renesas RL78 &lt;span class=&quot;vc_label_units&quot;&gt;15 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Sanyo LC87 &lt;span class=&quot;vc_label_units&quot;&gt;131 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Silicon Labs EFM8 &lt;span class=&quot;vc_label_units&quot;&gt;59 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM8 &lt;span class=&quot;vc_label_units&quot;&gt;79 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM32F0 &lt;span class=&quot;vc_label_units&quot;&gt;58 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;STC STC8 &lt;span class=&quot;vc_label_units&quot;&gt;15 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;TI MSP430FR &lt;span class=&quot;vc_label_units&quot;&gt;56 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;vc_tta-panel&quot; id=&quot;1508118054976-21e7d71a-8964&quot; data-vc-content=&quot;.vc_tta-panel-body&quot;&gt;

&lt;div class=&quot;vc_tta-panel-body&quot;&gt;
&lt;div class=&quot;vc_progress_bar wpb_content_element vc_progress-bar-color-bar_grey&quot;&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel tinyAVR &lt;span class=&quot;vc_label_units&quot;&gt;69 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel megaAVR &lt;span class=&quot;vc_label_units&quot;&gt;67 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel SAM D10 &lt;span class=&quot;vc_label_units&quot;&gt;477 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Cypress PSoC 4000S &lt;span class=&quot;vc_label_units&quot;&gt;124 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KE04 &lt;span class=&quot;vc_label_units&quot;&gt;281 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KL03 &lt;span class=&quot;vc_label_units&quot;&gt;102 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Holtek HT66 &lt;span class=&quot;vc_label_units&quot;&gt;239 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Infineon XMC1100 &lt;span class=&quot;vc_label_units&quot;&gt;72 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC16 &lt;span class=&quot;vc_label_units&quot;&gt;235 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC24 &lt;span class=&quot;vc_label_units&quot;&gt;53 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC32MM &lt;span class=&quot;vc_label_units&quot;&gt;91 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton N76 &lt;span class=&quot;vc_label_units&quot;&gt;103 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton M051 &lt;span class=&quot;vc_label_units&quot;&gt;89 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;NXP LPC811 &lt;span class=&quot;vc_label_units&quot;&gt;159 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Renesas RL78 &lt;span class=&quot;vc_label_units&quot;&gt;40 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Sanyo LC87 &lt;span class=&quot;vc_label_units&quot;&gt;159 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Silicon Labs EFM8 &lt;span class=&quot;vc_label_units&quot;&gt;85 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM8 &lt;span class=&quot;vc_label_units&quot;&gt;118 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM32F0 &lt;span class=&quot;vc_label_units&quot;&gt;83 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;STC STC8 &lt;span class=&quot;vc_label_units&quot;&gt;21 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;TI MSP430FR &lt;span class=&quot;vc_label_units&quot;&gt;73 Cycles&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;vc_tta-panel&quot; id=&quot;1508117538280-30de95f2-383e&quot; data-vc-content=&quot;.vc_tta-panel-body&quot;&gt;

&lt;div class=&quot;vc_tta-panel-body&quot;&gt;
&lt;div class=&quot;vc_progress_bar wpb_content_element vc_progress-bar-color-bar_grey&quot;&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel tinyAVR &lt;span class=&quot;vc_label_units&quot;&gt;962 Bytes&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel megaAVR &lt;span class=&quot;vc_label_units&quot;&gt;700 Bytes&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel SAM D10 &lt;span class=&quot;vc_label_units&quot;&gt;3720 Bytes&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Cypress PSoC 4000S &lt;span class=&quot;vc_label_units&quot;&gt;2280 Bytes&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KE04 &lt;span class=&quot;vc_label_units&quot;&gt;2728 Bytes&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KL03 &lt;span class=&quot;vc_label_units&quot;&gt;2732 Bytes&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Holtek HT66 &lt;span class=&quot;vc_label_units&quot;&gt;226 Bytes&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Infineon XMC1100 &lt;span class=&quot;vc_label_units&quot;&gt;2680 Bytes&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC16 &lt;span class=&quot;vc_label_units&quot;&gt;372 Bytes&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC24 &lt;span class=&quot;vc_label_units&quot;&gt;618 Bytes&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC32MM &lt;span class=&quot;vc_label_units&quot;&gt;3904 Bytes&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton N76 &lt;span class=&quot;vc_label_units&quot;&gt;0 Bytes&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton M051 &lt;span class=&quot;vc_label_units&quot;&gt;5876 Bytes&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;NXP LPC811 &lt;span class=&quot;vc_label_units&quot;&gt;2828 Bytes&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Renesas RL78 &lt;span class=&quot;vc_label_units&quot;&gt;1118 Bytes&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Sanyo LC87 &lt;span class=&quot;vc_label_units&quot;&gt;481 Bytes&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Silicon Labs EFM8 &lt;span class=&quot;vc_label_units&quot;&gt;534 Bytes&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM8 &lt;span class=&quot;vc_label_units&quot;&gt;1903 Bytes&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM32F0 &lt;span class=&quot;vc_label_units&quot;&gt;3544 Bytes&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;STC STC8 &lt;span class=&quot;vc_label_units&quot;&gt;376 Bytes&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;TI MSP430FR &lt;span class=&quot;vc_label_units&quot;&gt;1076 Bytes&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;vc_tta-panel&quot; id=&quot;1508118421077-01d1c041-e53d&quot; data-vc-content=&quot;.vc_tta-panel-body&quot;&gt;

&lt;div class=&quot;vc_tta-panel-body&quot;&gt;
&lt;div class=&quot;vc_progress_bar wpb_content_element vc_progress-bar-color-bar_grey&quot;&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel tinyAVR &lt;span class=&quot;vc_label_units&quot;&gt;6%&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel megaAVR &lt;span class=&quot;vc_label_units&quot;&gt;4%&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Atmel SAM D10 &lt;span class=&quot;vc_label_units&quot;&gt;23%&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Cypress PSoC 4000S &lt;span class=&quot;vc_label_units&quot;&gt;14%&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KE04 &lt;span class=&quot;vc_label_units&quot;&gt;34%&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Freescale KL03 &lt;span class=&quot;vc_label_units&quot;&gt;34%&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Holtek HT66 &lt;span class=&quot;vc_label_units&quot;&gt;3%&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Infineon XMC1100 &lt;span class=&quot;vc_label_units&quot;&gt;34%&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC16 &lt;span class=&quot;vc_label_units&quot;&gt;3%&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC24 &lt;span class=&quot;vc_label_units&quot;&gt;15%&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Microchip PIC32MM &lt;span class=&quot;vc_label_units&quot;&gt;12%&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton N76 &lt;span class=&quot;vc_label_units&quot;&gt;0%&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Nuvoton M051 &lt;span class=&quot;vc_label_units&quot;&gt;49%&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;NXP LPC811 &lt;span class=&quot;vc_label_units&quot;&gt;35%&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Renesas RL78 &lt;span class=&quot;vc_label_units&quot;&gt;11%&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Sanyo LC87 &lt;span class=&quot;vc_label_units&quot;&gt;2%&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;Silicon Labs EFM8 &lt;span class=&quot;vc_label_units&quot;&gt;3%&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM8 &lt;span class=&quot;vc_label_units&quot;&gt;6%&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;ST STM32F0 &lt;span class=&quot;vc_label_units&quot;&gt;22%&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;STC STC8 &lt;span class=&quot;vc_label_units&quot;&gt;1%&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;div class=&quot;vc_general vc_single_bar&quot;&gt;&lt;small class=&quot;vc_label&quot;&gt;TI MSP430FR &lt;span class=&quot;vc_label_units&quot;&gt;29%&lt;/span&gt;&lt;/small&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;wpb_text_column wpb_content_element&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;
&lt;p&gt;There’s a lot going on in this project, so let’s break it down separately into performance (in this case, power consumption), development process, peripheral library bloat, and other platform-specific eccentricities.&lt;/p&gt;
&lt;p&gt;In terms of performance, the MSP430 is the clear favorite. The next-lowest-consuming part, the PIC16, used almost 70% more power.&lt;/p&gt;
&lt;p&gt;Most Arm chips struggled with this test. The SAM D10 was the worst — Atmel START’s ASF4 peripheral libraries have an insanely high-level UART abstraction mechanism that took almost 500 clock cycles to process a single byte. Processor Expert’s equally high-level interface fared considerably better — executing in 281 clock cycles on the KE04. But both were abysmal compared to the rest of the field.&lt;/p&gt;
&lt;p&gt;It was Infineon DAVE-generated XMCLib code that brought in the fastest Arm performance: it took only 72 cycles in the ISR to process data on the XMC1100. The XMC1100 also got closest to the theoretical 15-cycle interrupt latency of the ARM Cortex-M0+. STM32Cube-generated STM32 peripheral libraries also performed well on the STM32F0 — needing only 83 clock cycles to process data.&lt;/p&gt;
&lt;p&gt;The Nuvoton M051, with its lightweight, relatively easy-to-use peripheral library did moderately well, but the NXP Kinetis KL03 (running Kinetis SDK) and the LPC811 (running LPCware) both brought in mediocre numbers (102 and 159 cycles, respectively).&lt;/p&gt;
&lt;p&gt;As mentioned before, the HT66 has a markedly similar architecture to the PIC16, and yet again in this test, these two 4T parts have very similar performance characteristics.&lt;/p&gt;
&lt;p&gt;Halfway through my review, I noticed the PIC16 got really &lt;em&gt;really&lt;/em&gt; slow. Sure, enough the infamous messages started popping up: “Using Omniscient Code Generation that is available in PRO mode, you could have produced up to 60% smaller and 400% faster code” — my 60-day evaluation license had expired. And they’re absolutely right — I had to &lt;em&gt;double&lt;/em&gt; my device’s clock speed to hit the original performance numbers I had. The numbers mentioned in this review were from optimized code, so if you’re a student or indie developer (or even a professional who has better things to buy than a compiler), take the results with a &lt;em&gt;big&lt;/em&gt; grain of salt.&lt;/p&gt;
&lt;p&gt;The EFM8 proved to be the most flexible 8-bitter in the round-up. It beat out all 8-bit parts in the high-performance biquad math tests, and it turned around and achieved the third-lowest power consumption figures in the DMX test, too — needing only 607 µA, while running at a cool 1.531 MHz core speed. Again, a multi-byte FIFO helped immensely.&lt;/p&gt;
&lt;p&gt;The tinyAVR and megaAVR both performed poorly — they consistently look like bigger, beefier 16- or 32-bit parts in performance testing: they bring in great math performance and run-mode active current, but they had some of the highest interrupt latencies among 8-bit parts that don’t have FIFO UARTs &lt;sup id=&quot;footnote_plugin_tooltip_14&quot; class=&quot;footnote_plugin_tooltip_text&quot; onclick=&quot;footnote_moveToAnchor('footnote_plugin_reference_14');&quot;&gt;14&lt;/sup&gt;&lt;span class=&quot;footnote_tooltip&quot; id=&quot;footnote_plugin_tooltip_text_14&quot;&gt;While interrupt latency is a property of the core — not the peripherals — we often measure interrupt latency relative to an actual event happening. Here, peripherals play a major role in determining latency. UARTs with FIFOs in this test had significantly higher interrupt latencies than UARTs without FIFOs.&lt;/span&gt;, and they both struggle with stop-mode and low-speed run-mode current.&lt;/p&gt;
&lt;p&gt;Another 8-bit part that stood out was the STC8, which recorded a 6-cycle interrupt latency — that’s 6 cycles from the stop bit being received, all the way to your C interrupt handler executing. Interrupt latency is one major advantage these 8051 parts continue to press over the fancier RISC-based AVR and Arm cores, which have long prologue and epilogue code.  Unfortunately, the STC8 simply does not care about power consumption — so it barrels along at 5.47 mA.&lt;/p&gt;
&lt;p&gt;As for ease of development, things were split across the board — even between parts that had code-gen tools, only peripheral libraries, or nothing at all.&lt;/p&gt;
&lt;p&gt;With Cypress PSoC Creator, I had to write a custom ISR from scratch, as the generated code didn’t contain functions for handling this scenario. I got burned by the function documentation a bit — but was able to get it working after quite a bit of reading.&lt;/p&gt;
&lt;p&gt;Infineon DAVE essentially cheated in this competition by providing a pre-built, one-click DMX-512 Receiver Dave APP. Consequently, I simply had to glue its callback to the LEDs by writing three set-duty-cycle calls. It was beautiful.&lt;/p&gt;
&lt;p&gt;Excluding DAVE, the easiest to get going was actually the Renesas code generator, which provided function prototypes for me to implement that it called from the interrupt. I have no idea why more vendors don’t provide statically-invoked callback functions from their generated interrupt code. They either provide no callbacks at all (STM32CubeMX, Microchip MCC, Cypress PSoC Creator), or they provide a weird, super heavy-handed dynamically-invoked callback register event system (like Atmel), or provide a user callback can’t directly handle the (private) data, or manipulate the internal state of the driver — like in the case of Processor Expert on the KE04.&lt;/p&gt;
&lt;p&gt;For this particular project I enjoyed Silicon Labs’ approach with Simplicity Configurator — it will automatically create the interrupt for you, and will even make sure it gets enabled in start-up code. It will give you helpful comments above the interrupt, telling you which flags to clear. But, the generated interrupt functions are just stubs — they contain no actual code. This is definitely the most flexible and lightest-weight route to take. And while some vendors (Microchip MCC, ST STM32CubeMX, NXP Processor Expert) provide “init-only” drivers, they don’t automatically stub the ISR, nor do they automatically enable the interrupt.&lt;/p&gt;
&lt;p&gt;The HT66’s peripherals were simple to configure by hand — and it required the fewest bytes of flash.&lt;/p&gt;
&lt;p&gt;The PSoC was the most efficient of the 32-bit parts — owing to the fact that the majority of code required for this project (peripheral initialization) lives in a compact bitstream representation inside the PSoC.&lt;/p&gt;
&lt;p&gt;The Nuvoton runtime libraries are huge (since they’re so simple to use), and I’m not positive that CoIDE was properly doing link-time-optimization (I’ll need to investigate further).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;vc_row-5cd272d4a7c03&quot; class=&quot;vc_row wpb_row vc_row-fluid&quot;&gt;
&lt;div class=&quot;wpb_column vc_column_container vc_col-sm-12&quot;&gt;
&lt;div class=&quot;vc_column-inner&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;
&lt;div class=&quot;wpb_text_column wpb_content_element&quot;&gt;
&lt;div class=&quot;wpb_wrapper&quot;&gt;
&lt;div id=&quot;discussion&quot; class=&quot;title-xlarge&quot;&gt;Discussion&lt;/div&gt;
&lt;div&gt;
&lt;h4&gt;Silcon Labs EFM8: Fantastic value and ease-of-use from the only 8-bit part with a totally-free cross-platform vendor ecosystem&lt;/h4&gt;
&lt;p&gt;The &lt;a href=&quot;https://jaycarlson.net/pf/silicon-labs-efm8/&quot;&gt;EFM8&lt;/a&gt; was the fastest 8-bit part in my round-up, and admittedly, my favorite 8-bit architecture to develop with overall. What these parts lack in brains they make up for in brawns — 14-bit ADCs, 12-bit DACs, lots of timers, and a 72 MHz core clock speed that gives you timing options not found in any other part in the round-up.&lt;/p&gt;
&lt;p&gt;Plus, this is the only 8-bit part with a totally-free, cross-platform, vendor-provided ecosystem. Let that sink in.&lt;/p&gt;
&lt;p&gt;Keil C51 is a silly compiler, but Silicon Labs does an excellent job hiding it under the hood — even when running its Eclipse-based Simplicity Studio on Linux or macOS.&lt;/p&gt;
&lt;p&gt;Simplicity Configurator is the lightest-weight code generator in our round-up, using only 534 bytes of flash to house the entire DMX-512 receiver project. It was one of the easiest to use, and seemed to strike a good balance between abstraction, performance, and ease of use.&lt;/p&gt;
&lt;p&gt;Debugging speeds are snappy with a J-Link debugger, but at $35, the official Silicon Labs USB Debug Adapter is one of the cheapest first-party debugger in the round-up, and clones of the hardware are even cheaper.&lt;/p&gt;
&lt;p&gt;And call me old-fashioned, but I think the 8051 definitely has a place in 2017 — especially among hobbyists and students, where its bit-addressable memory, easy-to-use peripherals, and fuse-free configuration help get students comfortable with microcontrollers quickly.&lt;/p&gt;
&lt;h4&gt;Microchip megaAVR &amp;amp; tinyAVR 1-Series: Different strokes for different folks — still with the best 8-bit toolchain available&lt;/h4&gt;
&lt;p&gt;The &lt;a href=&quot;https://jaycarlson.net/pf/atmel-microchip-megaavr/&quot;&gt;megaAVR&lt;/a&gt; came in surprisingly flat for me: especially when compared with its lower-cost, new sibling, the &lt;a href=&quot;https://jaycarlson.net/pf/atmel-microchip-tinyavr-1-series/&quot;&gt;tinyAVR 1-Series&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;There’s no comparison when it comes to price: tinyAVR has incredible value — packing in a nice assortment of timers, analog peripherals (including a DAC), and a new 20 MHz internal oscillator — while costing 20-40% less than the megaAVR.&lt;/p&gt;
&lt;p&gt;While the megaAVR has a perplexing debugging experience that requires two completely different interfaces and protocols to work with the part, the new one-wire UPDI interface the tinyAVR sports worked flawlessly in my testing.&lt;/p&gt;
&lt;p&gt;But that’s the crux of the problem for the tinyAVR — by shedding many of its megaAVR roots, Microchip ended up with a wonderful microcontroller that will be challenging to use for a large base of Atmel fans: indie developers and hobbyists who use low-cost, open-source programmers (which don’t support the UPDI interface).&lt;/p&gt;
&lt;p&gt;While the tinyAVR wasn’t the fastest part in the round-up (even among 8-bitters), it was the most efficient – both in terms of active-mode power and clock efficiency. Amazingly, the AVR only uses about twice as many instructions as 16- and 32-bit parts when performing 16-bit math.&lt;/p&gt;
&lt;p&gt;Unfortunately, the AVR system as a whole is not without its issues. The Windows-only Atmel Studio is still buggy (especially with older megaAVR devices and AVR Dragon stuff in my tests), and there isn’t an under-$50 low-cost debugger available (other than hacking apart Xplained Mini dev boards).&lt;/p&gt;
&lt;p&gt;In many ways, there seems to be a tacit demarcation Atmel creates between its hobbyist/indie developers, and the professional shops that use Atmel parts.&lt;/p&gt;
&lt;p&gt;As a professional embedded developer, I most definitely have access to Windows computers, and I have no problem blowing a few billable hours’ worth of pay on a $140 debugger.&lt;/p&gt;
&lt;p&gt;But even as popular as Atmel is among hobbyists, Atmel has largely stayed out of this space directly. Instead, they’ve secured small-volume AVR sales by relying on the open-source community to build their own tools for themselves: turning out a slew of hardware and software used to program the megaAVR devices.&lt;/p&gt;
&lt;p&gt;While I applaud the efforts of these developers, these tools are inferior to Atmel’s. Their programming speeds are terrible, they don’t support the new tinyAVR 1-Series devices, and they have absolutely no debug capability.&lt;/p&gt;
&lt;p&gt;Having said that, both the megaAVR and tinyAVR have the best toolchain available for 8-bit MCU development. The part supports a full, end-to-end Makefile-based GCC toolchain.&lt;/p&gt;
&lt;p&gt;If you love printf() debugging, would never touch a proprietary toolchain, and hate IDEs, megaAVR and old tinyAVR parts are definitely for you. The older ones are still available in DIP packages, and as you probably know, there are a ton of low-cost programmers available across the world. The online community is massive, and as clunky as I find Atmel START to be, I have to applaud its support for Makefile-based project generation.&lt;/p&gt;
&lt;p&gt;Consequently, the megaAVR remains the most open-source 8-bit microcontroller on the market — by a long shot.&lt;/p&gt;
&lt;p&gt;But I’d really like to see Microchip provide a PicKit-priced debugger with UPDI support — and allow off-board debugging the way their PIC Curiosity Boards do.&lt;/p&gt;
&lt;p&gt;I also hope these open-source projects can add UPDI support to their tools, so that hobbyists and indie developers can start integrating the tinyAVR into their projects — it’s a much better part, and if you’re an AVR user with access to Atmel Studio, you really ought to buy an Xplained Mini board and take it for a spin.&lt;/p&gt;
&lt;h4&gt;STM32F0: A low-cost, no-nonsense part with arguably the best Arm development ecosystem tested&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://jaycarlson.net/pf/st-stm32f0/&quot;&gt;The STM32F0&lt;/a&gt; was the lowest-power Arm microcontroller in the round-up, and also one of the easiest to use. STM32CubeMX doesn’t generate the most compact code on Arm (that honor belongs to Cypress PSoC Creator and Infineon DAVE), but it has a snappy interface, and the generated code is easy enough to manipulate for your own goals.&lt;/p&gt;
&lt;p&gt;I love the nearly-stock Eclipse-based environment that System Workbench for STM32 provides, and the ST-Link and excellent Discovery/Nucleo boards seals the deal for me.&lt;/p&gt;
&lt;p&gt;Most pros have used ST parts in their work, but for all these reasons, any hobbyist looking at moving to Arm should probably pick up a dev board from this ecosystem, too. ST has a huge market footprint, so there’s tons of resources online — aimed at both hobbyists and professionals.&lt;/p&gt;
&lt;h4&gt;SAM D10: Killer performance &amp;amp; peripherals, but with runtime library hiccups&lt;/h4&gt;
&lt;p&gt;The Microchip/Atmel &lt;a href=&quot;https://jaycarlson.net/pf/atmel-microchip-sam-d10/&quot;&gt;SAM D10&lt;/a&gt; (and the broader D11/D20/D21 ecosystem) has good value (considering their analog portfolio includes a DAC, and they have good timing options), and the SAM D10 was the most efficient part tested when running at full speed.&lt;/p&gt;
&lt;p&gt;Professionals will like the easy-to-use, well-documented header files, and hobbyists will appreciate the 1.27mm-pitch SOIC package options and GCC compilers that come with the Arm ecosystem. But before I grab this part for a project, Microchip really needs to fix the extremely slow, bloated peripheral library, and update their code-gen tool to do proper error-checking of clock and peripheral configurations.&lt;/p&gt;
&lt;p&gt;As it is, whenever I use Atmel START on the D10, I want to STOP almost immediately. And there are no current, stand-alone peripheral drivers that Microchip has released for this part, so unless you want to do register programming from scratch, you’ll be relying on third-party, open-source projects — like Alex Taradov’s &lt;a href=&quot;https://github.com/ataradov/mcu-starter-projects&quot;&gt;code examples&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;Infineon XMC1100: Interesting peripheral perks make this Cortex-M0 stand out&lt;/h4&gt;
&lt;p&gt;The most interesting Arm chip was, without a doubt, the &lt;a href=&quot;https://jaycarlson.net/pf/infineon-xmc1100/&quot;&gt;Infineon XMC1100&lt;/a&gt; — and I think professionals who may be wary of getting out of the ST/NXP/Atmel Arm ecosystem need to take a second look at these XMC1000 (and XMC4000) parts.&lt;/p&gt;
&lt;p&gt;The timer options are amazingly flexible, and you can squeeze fantastic performance out of the USIC module.&lt;/p&gt;
&lt;p&gt;I’m going to go out on a limb and recommend that serious hobbyists who are building motor / lighting control projects look into these parts, too. DAVE makes setting up these complex peripherals painless, and the 38-pin TSSOP chips will be substantially easier to solder than the 0.5mm QFNs and QFPs you usually end up with in these pin counts.&lt;/p&gt;
&lt;p&gt;Like many of the parts reviewed here, the biggest problem for hobbyists and indie developers is the tiny online communities and lack of GitHub repos with open-source projects that use these chips. My advice — be bold, and post in the forums. Infineon employees monitor and usually respond within a day or so.&lt;/p&gt;
&lt;h4&gt;PIC16: Tons of peripherals with a slower, power-efficient core&lt;/h4&gt;
&lt;p&gt;When you compare the &lt;a href=&quot;https://jaycarlson.net/pf/microchip-pic16-five-digit-enhanced/&quot;&gt;PIC16&lt;/a&gt; with other 8-bit parts out there, it’s obviously a part built for low-power applications, and not processing power. And while the development ecosystem is workable, there are other parts more friendlier pathways — especially for smaller shops, hobbyists, and students who need extremely low-cost tools (and free software).&lt;/p&gt;
&lt;p&gt;To add fuel to the PIC-vs-AVR debate, my testing found that a 32 MHz PIC16 is roughly equivalent to an AVR part running at 1.4 MHz (in terms of math performance), and 9 MHz (in terms of bit-shuffling performance).&lt;/p&gt;
&lt;p&gt;Having said that, the DMX-512 receiver seems a perfect match for the PIC16, and that’s where it looks best in my testing: the PIC16 was the lowest-power 8-bit part in my testing.&lt;/p&gt;
&lt;p&gt;It’s also full of timers and digital logic-oriented peripherals that make it suitable for funky special-purpose projects that require some crafty use of configurable logic and and the numerically-controlled oscillator — these peripherals help offload the (relatively slow) CPU, at the expense of requiring more developer familiarity with the device and these peripherals.&lt;/p&gt;
&lt;p&gt;The usual Microchip gotchas apply: clunky IDE, expensive compilers, and expensive debuggers.&lt;/p&gt;
&lt;p&gt;The usual Microchip advantages apply: huge online community, seemingly infinite product lifetime guarantees, and DIP, SOIC, QFP, and QFN package availability.&lt;/p&gt;
&lt;h4&gt;PIC24: An expensive MSP430 wannabe that doesn’t hit the mark&lt;/h4&gt;
&lt;p&gt;The &lt;a href=&quot;https://jaycarlson.net/pf/microchip-pic24/&quot;&gt;PIC24&lt;/a&gt; is nearly forgettable. In the biquad test, it’s marginally faster than the &lt;a href=&quot;https://jaycarlson.net/pf/renesas-rl-78/&quot;&gt;Renesas RL-78&lt;/a&gt; but uses almost three times as much power. In the DMX-512 test, both the RL-78 and MSP430 beat it, too. It was also one of the least-endowed parts in the round-up (which really just means it’s expensive — higher-end PIC24 parts have no shortage of peripherals).&lt;/p&gt;
&lt;p&gt;The usual Microchip gotchas apply: clunky IDE, expensive compilers, and expensive debuggers.&lt;/p&gt;
&lt;p&gt;The usual Microchip advantages apply: huge online community, seemingly infinite product lifetime guarantees, and DIP, SOIC, QFP, and QFN package availability.&lt;/p&gt;
&lt;h4&gt;PIC32: An excellent 32-bit part that balances performance and power consumption&lt;/h4&gt;
&lt;p&gt;The &lt;a href=&quot;https://jaycarlson.net/pf/microchip-pic32mm/&quot;&gt;PIC32MM&lt;/a&gt; was my favorite Microchip part in the review. It brought in the lowest-power performance of every 32-bit part tested. Unfortunately, it was also the least-efficient 32-bit part tested in terms of math performance (well, excluding the couldn’t-care-less-about-power &lt;a href=&quot;https://jaycarlson.net/pf/nuvoton-m051/&quot;&gt;Nuvoton M051&lt;/a&gt;), and it’s pretty spartan on peripherals — it doesn’t even have a hardware I2C controller.&lt;/p&gt;
&lt;p&gt;But PIC32MM parts have good flash / RAM density, and have simpler clocking / peripheral gating configurations than some of the more-flexible Arm parts, which makes them feel easier to program at a register level.&lt;/p&gt;
&lt;p&gt;Plus, they have a lot of headroom: I think the high-end PIC32MZ DA devices have a home among small industrial dev shops that need Linux-like HMI functionality but don’t have the resources to bring a product like that to market.&lt;/p&gt;
&lt;p&gt;The usual Microchip gotchas apply: clunky IDE, expensive compilers, and expensive debuggers.&lt;/p&gt;
&lt;p&gt;The usual Microchip advantages apply: huge online community, seemingly infinite product lifetime guarantees, and DIP, SOIC, QFP, and QFN package availability.&lt;/p&gt;
&lt;h4&gt;Renesas RL-78: An agile, low-power, easy-to-use 16-bit part you really ought to try&lt;/h4&gt;
&lt;p&gt;I had never picked up a Renesas part before, and when I went shopping for dev kits and stumbled on only a smattering of expensive, traditional systems, I was a little anxious. But I found the &lt;a href=&quot;https://www.digikey.com/product-detail/en/YRPBRL78L1A/YRPBRL78L1A-ND/6605483?curr=usd&amp;amp;WT.z_cid=ref_octopart_dkc_buynow&amp;amp;site=us&quot;&gt;$25 RL78L1A Promotion Board&lt;/a&gt;, gave it a shot, and really enjoyed it.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://jaycarlson.net/pf/renesas-rl-78/&quot;&gt;RL-78&lt;/a&gt; is a snappy architecture that competes with Arm parts in math performance, yet it’s also relatively inexpensive — especially compared to the &lt;a href=&quot;https://jaycarlson.net/pf/texas-instruments-msp430fr/&quot;&gt;MSP430&lt;/a&gt; and &lt;a href=&quot;https://jaycarlson.net/pf/microchip-pic24/&quot;&gt;PIC24&lt;/a&gt;. It can’t quite hit the MSP430 sleep-mode power consumption figures, but it gets close — and is, by far, the most power-efficient 5V-capable part in the review.&lt;/p&gt;
&lt;p&gt;The code generator tool produces readable yet efficient code, and the IDE, e2studio, is Eclipse-based — and is getting Linux and macOS support in the next release.&lt;/p&gt;
&lt;p&gt;I’d complain about the dev board, but the new &lt;a href=&quot;https://www.renesas.com/en-us/products/software-tools/boards-and-kits/renesas-promotion-boards/yrpbrl78g13-for-rl78-g13.html&quot;&gt;YRPBRL78G13 RL78/G13 development kit&lt;/a&gt; should remedy basically all my complains with it — I can’t wait for U.S. distributors to start carrying these. They could use a more active community and more people publishing code online, but I hope this article will help inspire some remedies for that.&lt;/p&gt;
&lt;h4&gt;N76, HT66, and STM8: Low-cost parts with a smattering of development headaches&lt;/h4&gt;
&lt;p&gt;The &lt;a href=&quot;https://jaycarlson.net/pf/st-stm8/&quot;&gt;STM8&lt;/a&gt; is probably the nicest of the “cheapie” parts. It has nice peripherals and really good performance for an 8-bit part running at its frequency, but I think the entry-level &lt;a href=&quot;https://lcsc.com/product-detail/ST-Microelectronics_STMicroelectronics_STM8S103F2P6TR_STM8S103F2P6TR_C8242.html&quot;&gt;38-cent STM8S103F2P6&lt;/a&gt; is a more compelling part than the higher-end one reviewed here — simply because of its ultra-low price. The part I reviewed here looks a lot like the other 8-bit microcontrollers — but with an ancient-looking IDE that’s not nearly as productive as the competition. And almost everything out there has better power consumption figures.&lt;/p&gt;
&lt;p&gt;Still, this part is relatively cheap to get going (ahoy, $5 ST-Link clones), and the IDE and toolchain are completely free. But in that regard, you get what you pay for: STVD feels trapped in 2002, and there’s no way to set up a more modern development and debugging environment for it &lt;sup id=&quot;footnote_plugin_tooltip_15&quot; class=&quot;footnote_plugin_tooltip_text&quot; onclick=&quot;footnote_moveToAnchor('footnote_plugin_reference_15');&quot;&gt;15&lt;/sup&gt;&lt;span class=&quot;footnote_tooltip&quot; id=&quot;footnote_plugin_tooltip_text_15&quot;&gt;Though, there’s some emerging SDCC / GDB support for pairing it with an ST-Link in an open-source fashion, which might help it make inroads with the classic tinyAVR and megaAVR users&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;You’ll be forking over quite a bit of money for a Keil C51 license to develop for the &lt;a href=&quot;https://jaycarlson.net/pf/nuvoton-n76/&quot;&gt;N76&lt;/a&gt; — all for a part that doesn’t look much different than some entry-level EFM8s that have a day-and-night difference in ease of development. Still, at &lt;a href=&quot;https://lcsc.com/product-detail/NUVOTON_N76E003AT20_C82751.html&quot;&gt;23 cents per unit&lt;/a&gt;, it’s tough to beat for volume applications — and hobbyists and hackers can probably get by with the 2K code limit of Keil’s evaluation version. SDCC users need not apply: there’s no stand-alone tools for loading code into this part, and I doubt µVision can be coaxed into loading an SDCC-compiled hex file.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://jaycarlson.net/pf/holtek-ht-66/&quot;&gt;Holtek HT-66&lt;/a&gt; has terrible processing performance, but barely uses any run-mode current — there’s plenty of application-specific models to choose from, and while the IDE is goofy, I found it to be fairly productive — and it’s completely free. Careful, though: only the more-expensive “V” parts have on-chip debugging.&lt;/p&gt;
&lt;h4&gt;STC8: A neat performance-heavy part for hacking — but probably not for serious, professional work&lt;/h4&gt;
&lt;p&gt;I think every hacker and advanced hobbyist really ought to throw $10 at AliExpress/Taobao and get some STC15 and &lt;a href=&quot;https://jaycarlson.net/pf/stcmicro-stc8/&quot;&gt;STC8&lt;/a&gt; parts — just for fun.&lt;/p&gt;
&lt;p&gt;Both are jam-packed full of peripherals and memory (more than every other part reviewed), and the STC8 is also &lt;em&gt;really&lt;/em&gt; fast. There are some interesting projects you can do with a part that hits your C interrupt code 10 clock cycles after an interrupt occurs — that’s 320 nanoseconds. Both these parts support debugging over UART, so there’s no proprietary debugger to purchase.&lt;/p&gt;
&lt;p&gt;I wouldn’t seriously consider using these parts in U.S-based commercial work, as we have no access to STC inventory here, but the part is just plain fun to play with.&lt;/p&gt;
&lt;h4&gt;ON Semiconductor LC-87: Skip&lt;/h4&gt;
&lt;p&gt;You can probably skip over the &lt;a href=&quot;https://jaycarlson.net/pf/sanyo-on-semiconductor-lc87/&quot;&gt;ON Semiconductor LC87&lt;/a&gt;. This is a rare part outside the Japanese market, and it looks like it’s on its way out the door. I called Altium to try to get an evaluation version of the Tasking LC87 toolset, and the person I talked to had never heard of the LC87 before, and was almost positive they hadn’t made a compiler for it for at least three years. This part has terrible power consumption, few peripherals, and the worst development environment I saw in this review. Skip.&lt;/p&gt;
&lt;h4&gt;Kinetis KL03: Sleep-mode specialist not for beginners&lt;/h4&gt;
&lt;p&gt;While the &lt;a href=&quot;https://jaycarlson.net/pf/freescale-nxp-kinetis-kl03/&quot;&gt;Kinetis KL03&lt;/a&gt; has excellent deep-sleep current and ultra-tiny CSP package availability, it definitely feels like a specialized part not useful for the applications I evaluated. It has far fewer peripherals than the other parts reviewed, and despite NXP’s low-power claims, was consistently in the middle of my Arm rankings for the DMX-512 receiver test — though it nearly matches the &lt;a href=&quot;https://jaycarlson.net/pf/atmel-microchip-sam-d10/&quot;&gt;SAM D10&lt;/a&gt; in full-speed active mode.&lt;/p&gt;
&lt;p&gt;Kinetis SDK is awkward to use, and the dev boards are terrible — requiring a lot of reverse-engineering and hacking to get the board doing anything other than running pre-written demos (especially if you’re interested in measuring power consumption). Still, MCUXpresso is a productive, modern Eclipse-based IDE, and the KL03 has some of the lowest-leakage power modes out there, which means you can get 8-bit-like performance when you’re running an RTC or interrupt wake-up project from a coin-cell battery.&lt;/p&gt;
&lt;h4&gt;Kinetis KE04: Decent peripheral assortment with a powerful — yet clunky — code gen tool&lt;/h4&gt;
&lt;p&gt;The &lt;a href=&quot;https://jaycarlson.net/pf/freescale-nxp-ke04/&quot;&gt;Kinetis KE04&lt;/a&gt; had pretty heavy power consumption in my testing — but this was largely due to the heavy-handed Processor Expert code that Kinetis Design Studio generated. This environment is really suited to much larger, faster microcontrollers running RTOSes and not needing especially good low-level I/O performance.&lt;/p&gt;
&lt;p&gt;But, hey, if you don’t really care about performance, the nice thing about Processor Expert is it abstracts the peripherals to such a high level that you’ll never need to crack open a datasheet for the part if you’re using the peripherals in normal configurations.&lt;/p&gt;
&lt;p&gt;Plus, the KE04 (and KE02) are 5V-compatible parts, and they’re available in old-school, easy-to-solder 1.27mm SOIC and 0.8mm packages — so I could imagine hobbyists would find this part useful.&lt;/p&gt;
&lt;h4&gt;LPC811: Few perks, and less interesting than the LPC810&lt;/h4&gt;
&lt;p&gt;The LPC810 drew people in with its odd, 8-pin DIP form-factor. That chip has since been discontinued, but the LPC81x line remains. The &lt;a href=&quot;https://jaycarlson.net/pf/nxp-lpc811/&quot;&gt;LPC811&lt;/a&gt; reviewed here is sparse on peripherals — not even having an ADC — and brought in poor performance. There’s really nothing that this part does that you can’t get from one of the other vendors; but don’t discredit NXP completely — their higher-end offerings have some interesting capabilities (like dual-core Cortex-M4/M0 designs), and their development environment, MCUXpresso, is an inoffensive Eclipse system.&lt;/p&gt;
&lt;h4&gt;PSoC 4000S &amp;amp; MSP430: Bottom-of-the-barrel parts that offer a glimpse into nice ecosystems&lt;/h4&gt;
&lt;p&gt;I hesitated to review the &lt;a href=&quot;https://jaycarlson.net/pf/cypress-psoc-4000s/&quot;&gt;PSoC&lt;/a&gt; and &lt;a href=&quot;https://jaycarlson.net/pf/texas-instruments-msp430fr/&quot;&gt;MSP430&lt;/a&gt; because they tend to be relatively expensive parts, so in a $1 shoot-out, you end up with bottom-end parts that don’t look nearly as useful as their higher-cost relatives. If you really want to get a feel for what the MSP430 or PSoC parts can do, I recommend buying into a higher-end part — preferably on one of the excellent dev boards that these manufacturers make.&lt;/p&gt;
&lt;p&gt;PSoC Creator and the reconfigurable digital and analog blocks in the PSoC line draw many professional and hobbyist users into the architecture — but instead of grabbing the 4000S from this review, reach for a PSoC5 (or soon-to-launch PSoC6) dev board to get a feel for the platform.&lt;/p&gt;
&lt;p&gt;Same with the MSP430. In the DMX-512 test, it dominated in power consumption, but barely put up marks in any other category (this is especially challenging when you have no hardware multiplier, and only a smattering of peripherals).&lt;/p&gt;
&lt;p&gt;Still, the part has a solid development ecosystem with Code Composer Studio and a choice between the proprietary (but now free) TI compiler, and the open-source GCC one. Plus, hobbyists will love the easy Arduino migration path (with Code Composer Studio directly supporting Energia *.ino sketch projects) and $10 dev boards.&lt;/p&gt;
&lt;p&gt;And really, everyone starting a battery-based product needs to go buy an MSP430 Launch Pad and play around with it — these really are amazing parts that still have a lot of relevance in 2017.&lt;/p&gt;
&lt;h4&gt;Nuvoton M051: Ecosystem issues stifle a performance-packed part&lt;/h4&gt;
&lt;p&gt;The &lt;a href=&quot;https://jaycarlson.net/pf/nuvoton-m051/&quot;&gt;Nuvoton M051&lt;/a&gt; — one of the most-endowed parts reviewed — suffers ecosystem issues that Nuvoton could easily remedy in the future, so I’ll reserve judgment. There’s no manufacturer-provided Eclipse-based IDE — instead, the only IDE options are CooCox, and Keil µVision — neither of which I’m particularly fond of.&lt;/p&gt;
&lt;p&gt;I was able to get CooCox working (though the peripheral libraries that are in the CooCox repo are old and full of bugs). The M0 had some of the worst power-consumption figures in the review, but it makes up for that with tons of communications peripherals, beautiful 32-bit control-friendly timers, and easily-digestible runtime libraries and documentation that are far easier to use than other vendors’. When Nuvoton fixes the IDE absence, I’ll definitely move this part from the “meh” to “yeah” column — since it accomplishes all of these feats while remaining one of the lowest-cost Arm microcontrollers out there.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;conclusion&quot; class=&quot;title-xlarge&quot;&gt;Conclusion&lt;/div&gt;
&lt;p&gt;I had a ton of fun playing with all these different parts for the last few months for this microcontroller review, and in many ways, came away thinking what I already knew: there is no perfect microcontroller — no magic bullet that will please all users. What I &lt;em&gt;did&lt;/em&gt; learn, however, is it’s getting easier and easier to pick up a new architecture you’ve never used before, and there have never been more exciting ecosystems to choose from.&lt;/p&gt;
&lt;p&gt;And that’s what I want people to think about as they walk away from this microcontroller review. If you’re an Arduino hobbyist looking where to go next, I hope you realize there are a ton of great, easy-to-use choices. And for professional developers and hardcore hackers, perhaps there’s an odd-ball architecture you’ve noticed before, but never quite felt like plunging into — now’s the time.&lt;/p&gt;
&lt;p&gt;It’s an exciting time to be involved with electronics — whatever parts you choose to pick up, I hope you’ve enjoyed learning about what’s out there, and can get inspired to go build something great. Definitely leave a note in the comments below if you’ve got something to contribute to the discussion!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


</description>
<pubDate>Tue, 07 May 2019 17:49:50 +0000</pubDate>
<dc:creator>howard941</dc:creator>
<og:type>article</og:type>
<og:title>The Amazing $1 Microcontroller - Jay Carlson</og:title>
<og:description>A new series that reviews 21 different microcontrollers — all less than $1 — to help familiarize you with all the major ecosystems out there.</og:description>
<og:url>https://jaycarlson.net/microcontrollers/</og:url>
<og:image>https://jaycarlson.net/wp-content/uploads/2017/07/20171015-8656-1024x684.jpg</og:image>
<dc:language>en-US</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://jaycarlson.net/microcontrollers/</dc:identifier>
</item>
<item>
<title>Dear Client, Here’s Why That Change Took So Long</title>
<link>https://www.simplethread.com/dear-client-heres-why-that-change-took-so-long/</link>
<guid isPermaLink="true" >https://www.simplethread.com/dear-client-heres-why-that-change-took-so-long/</guid>
<description>&lt;p&gt;Changes in complex software systems seem like they take forever, don’t they? Even to engineers it often feels like changes take longer than they should, and we understand the reasons for the underlying complexity in the system!&lt;/p&gt;&lt;p&gt;For stakeholders it can be even more obtuse and frustrating. This can be exacerbated by the incidental complexity introduced over time in systems that haven’t been properly maintained. It can feel like we are bailing water out of a ship with a thousand leaks.&lt;/p&gt;
&lt;p&gt;So it can be incredibly frustrating and deflating when one day you get a message from a stakeholder saying, “Why in the world will this take so long?” But we have to remember that as software engineers we have a window into a world that our stakeholders often don’t have visibility into. They put a lot of trust in us to deliver for them, but sometimes a seemingly small change can end up taking a large amount of time. This leads to a frustration that results in a curt “explain to me why this takes so long.”&lt;/p&gt;
&lt;p&gt;Don’t be offended by this question; see it as an opportunity to empathize with your stakeholders and to give them a clearer picture of the complexity of the system. And at the same time, you have the opportunity to suggest ways in which to improve the situation. There is no better time than when someone is frustrated by something to tell them you have an idea for how to improve it!&lt;/p&gt;
&lt;p&gt;Below we have a letter that we have written variations of numerous times over the years. We hope this will help you to think about how you communicate with your stakeholders the next time you receive a similar question.&lt;/p&gt;
&lt;h2&gt;The Letter&lt;/h2&gt;
&lt;p&gt;Dear Client,&lt;/p&gt;
&lt;p&gt;I saw your comment on the “Notify Before Task Due” story card, and I’d be happy to discuss it in our next meeting. I’ll summarize my thoughts here for reference, no need to reply.&lt;/p&gt;
&lt;p&gt;To paraphrase your note:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Changing the tasks due email to be delivered a day earlier should be a one-line change. How could that take 4-8 hours? What am I missing?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;On one hand, I agree with you. This request is simply changing part of a query from “tasks due &amp;lt;= today” to “tasks due &amp;lt;= tomorrow”.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;On the other hand, by reducing it to that simplistic idea, we’re inadvertently ignoring inherent complexity and making a number of engineering choices – some we should discuss.&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;Part 1: Why is this small change bigger than it seems?&lt;/h2&gt;
&lt;p&gt;It’s an easy, small change, one line of code. Spending a full day, even a half day, on it sounds excessive.&lt;/p&gt;
&lt;p&gt;Of course, you can’t just deploy a change to production without, at least, running it locally or on a test server to make sure the code executes correctly, and in the case of a query change, you need to compare the output to make sure it seems roughly correct.&lt;/p&gt;
&lt;p&gt;In this case, that query output comparison can be fairly minimal, spot-check a handful, ensure result counts make sense, etc. It’s a notification for internal employees. If our date math is wrong (an easy mistake), we’ll hear about it from the teams quickly. If this were, say, an email to your customers, deeper scrutiny would be needed. But for this light testing and review, 20-40 minutes is reasonable, depending on if anything weird or unexpected comes up. Digging into data can eat time. Pushing out a change without doing a review is simply professionally negligent.&lt;/p&gt;
&lt;p&gt;So, adding in time for normal logistics like committing the code, merging changes, deployment, etc., the time spent from start to live-in-production is at minimum an hour – for a competent, professional engineer.&lt;/p&gt;
&lt;p&gt;Of course, that assumes you know exactly what line of code to change. Task workflow mostly lives in the old system, but some pieces of logic live in the new system. Moving logic out of the old system is a good thing, but it does mean the Task functionality is currently split across two systems.&lt;/p&gt;
&lt;p&gt;Because we’ve worked together for so long, our team happens to know which process sends the due/overdue task email and can point to the line of code in the new system that initiates the process. So we don’t need to spend time figuring that out at least.&lt;/p&gt;
&lt;p&gt;But if we look at the task code in the old system, there are at least 4 different ways to determine if a task is due. Plus looking around at templates and email behavior, there are at least 2 more places that seem to perform custom due logic.&lt;/p&gt;
&lt;p&gt;And then the task notification logic is more complicated than you might guess. It needs to reason about team vs individual tasks, public vs private tasks, recurring tasks, if it’s so overdue a manager should be notified, etc.. But we can figure out fairly quickly that only 2 of the 6+ overdue definitions are actually used in this notification process. And only 1 needs to be changed to accomplish the goal.&lt;/p&gt;
&lt;p&gt;That review could easily take another half hour or so, maybe less if you’ve been in that part of the codebase recently. Also, the hidden complexity means we might exceed our manual-testing estimate. But let’s just add 30 minutes for higher effort than expected.&lt;/p&gt;
&lt;p&gt;So we’re up to 1.5 hours to do this change and feel confident that it will achieve the stated request.&lt;/p&gt;
&lt;p&gt;Of course, we didn’t check if any other processes are using the query we’re changing. We don’t want to accidentally break other functionality by changing the concept of “due” to mean the day before the task is due. We need to review the codebase from this perspective. In this case, there seem to be no major dependencies – probably because the bulk of task UI is still in the old system. So we don’t need to worry about changing or testing other processes. In this best case scenario, that’s another 15-30 minutes.&lt;/p&gt;
&lt;p&gt;Oh and since the bulk of the task user interface does still live in the old system, we really should do a quick review of the task functionality in that system to see if we’re giving inconsistent feedback. For example, if the UI highlights a task when it’s due, we may want to change that logic also to match the notification – or at least go back and ask our stakeholder what she wants to do. I have not looked at task functionality in the old system lately and don’t remember if it has any notion of due/overdue. This review is another 15-30 minutes, possibly more if there are also multiple definitions of “task due” in the old system, etc.&lt;/p&gt;
&lt;p&gt;So we’re up to 2 – 2.5 hour range to do this and feel confident it will achieve the stated request, without unintended side effects or user experience confusion.&lt;/p&gt;
&lt;h2&gt;Part 2: How can we reduce that time?&lt;/h2&gt;
&lt;p&gt;The suboptimal, frustrating part is that the only output of this effort is the requested change. The knowledge, say, Sam gained in the process is personal and ephemeral. If a different developer (or ourselves 6 months from now) needed to make a change in this part of the code again, the process would need to be repeated.&lt;/p&gt;
&lt;p&gt;There are two main tactics to improve that:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;1) Actively clean a codebase – focused around reducing duplication and complexity.&lt;/li&gt;
&lt;li&gt;2) Write automated tests&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Side Note: We have discussed documentation in the past, but documentation is not a good solution in this case. Documentation can be great for high-level ideas, e.g., explaining the business reasons behind system behavior, or for highly repeatable processes, e.g., my “new integration partner” checklist. But when it comes to documenting application code, it quickly becomes far too voluminous and out of date as the code changes.&lt;/p&gt;
&lt;p&gt;You’ll notice neither of those two improvement tactics is included in our 2 – 2.5 hours.&lt;/p&gt;
&lt;p&gt;As an example, keeping a codebase clean would mean that instead of just focusing on the requested change, we’d ask questions:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Why are there so many different ways to find due/overdue tasks?&lt;/li&gt;
&lt;li&gt;Are all of those needed or even still used?&lt;/li&gt;
&lt;li&gt;Can we collapse those to one or two concepts/methods?&lt;/li&gt;
&lt;li&gt;If the concept of due is split across the old and new systems, can we consolidate this?&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;And so on.&lt;/p&gt;
&lt;p&gt;Answering those questions may be fairly quick – e.g., if they’re obviously dead code. Or it may take several hours – e.g., if they’re used in a lot of complicated processes. Once we had those answers, it would take more time still to refactor the code to reduce duplication/confusion and have a single notion of “due” – or rename concepts in code to make it obviously clear how they’re different and why.&lt;/p&gt;
&lt;p&gt;But at the end of it, this part of the codebase would be far simpler, easier to reason about, and easier to change.&lt;/p&gt;
&lt;p&gt;Another tactic we use commonly is automated testing. In some ways, automated tests are like documentation – documentation that can’t get out of date and is easier to discover. Instead of manually running code and reviewing the output, we’d write test code that runs the query and programmatically verifies the output. So any developer can run that test code to understand how the system is supposed to work and make sure it still works that way.&lt;/p&gt;
&lt;p&gt;If you have a system with decent test coverage, it can greatly speed up these types of changes. You can make the logic change and then run the full test suite to have confidence that&lt;/p&gt;
&lt;p&gt;a) your change works correctly and even more valuable&lt;br/&gt;b) your change hasn’t broken anything else.&lt;/p&gt;
&lt;p&gt;When we build systems from scratch at Simple Thread, we always include time for writing automated tests in our estimates. It can slow down initial development, but it greatly improves the efficiency of operating and maintaining a software system. It isn’t until a system grows that you truly start to feel the pain of not having tests, and by that point it can be a monumental task to work tests back into the system. It also makes it much easier to on-board new developers, and it makes it much faster and safer to change behavior.&lt;/p&gt;
&lt;h2&gt;Part 3: Where have we come from? Where are we going?&lt;/h2&gt;
&lt;p&gt;To date, we rarely include explicit cleaning or test-writing time in estimates for you. That’s partially because while writing tests from scratch is negligible overhead, adding tests to a codebase retroactively is a lot of work, kind of like rebuilding the foundation under a house that people live in.&lt;/p&gt;
&lt;p&gt;It’s also partially because when we started working with you, we immediately went into emergency triage mode. We had near-daily problems with the 3rd-party data syncs, weekly problems with report generation, constant support requests for small data changes, inadequate system monitoring and logging, etc. The codebase was sinking under the weight of technical debt, and we were feverishly trying to keep the systems afloat while also patching holes with duct tape.&lt;/p&gt;
&lt;p&gt;Over time, we’ve gotten the systems more stable and reliable and we’ve automated/provided UIs to self-service many frequent support requests. We still have a lot of technical debt, but we’re out of the emergency room. However, I don’t think we’ve ever fully shifted away from that reactive triage mentality to a more proactive, mature plan and execute mentality.&lt;/p&gt;
&lt;p&gt;We try to clean up code we’re already changing, and we always desk-test thoroughly. But being careful and diligent is different from proactive refactoring and building the infrastructure needed for good automated tests.&lt;/p&gt;
&lt;p&gt;If we don’t start paying down some technical debt, we’ll never meaningfully improve the situation, and it’ll continue to take months for highly experienced, highly competent developers to get oriented enough to make nontrivial changes.&lt;/p&gt;
&lt;p&gt;In other words, spending 1/2 day to a full day (4-8hrs) on this task is roughly 2x-4x the effort, but it could provide a benefit that greatly reduces the effort to make a similar change in the future. If this part of the codebase were cleaner and had good automated test coverage, I’d expect a competent developer to perform it in an hour or less, 1/2 or less of the original time. And a key point is that it wouldn’t be much longer for a new developer to do it versus a developer experienced in the system.&lt;/p&gt;
&lt;p&gt;This shift is one that we are going to need buy-in from you to make. It is a conscious effort to improve how your systems work at a fundamental level, not just how users perceive the system. I know that investments like this can be hard to make, precisely because there aren’t any new visible rewards, but we are happy to sit down with you and put together some hard numbers that can show how these investments would pay off long-term from an engineering perspective.&lt;/p&gt;
&lt;p&gt;Thanks,&lt;br/&gt;Al&lt;/p&gt;

&lt;span class=&quot;prev&quot;&gt;&lt;a href=&quot;https://www.simplethread.com/simple-threads-favorite-developer-things/&quot; rel=&quot;prev&quot;&gt;Previous Post&lt;/a&gt;&lt;/span&gt;</description>
<pubDate>Tue, 07 May 2019 15:52:20 +0000</pubDate>
<dc:creator>jetheredge</dc:creator>
<og:type>article</og:type>
<og:title>Dear Client, Here’s Why That Change Took So Long - Simple Thread</og:title>
<og:description>Changes in complex software systems seem like they take forever, don’t they? Even to engineers it often feels like changes take longer than they should, and we understand the reasons for the underlying complexity in the system! For stakeholders it can be even more obtuse and frustrating. This can be exacerbated by the incidental complexity... Read more »</og:description>
<og:url>https://www.simplethread.com/dear-client-heres-why-that-change-took-so-long/</og:url>
<og:image>https://www.simplethread.com/wp-content/uploads/2019/04/close-up-color-countdown-39396.jpg</og:image>
<dc:language>en-US</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.simplethread.com/dear-client-heres-why-that-change-took-so-long/</dc:identifier>
</item>
<item>
<title>To ORM or Not to ORM</title>
<link>https://eli.thegreenplace.net/2019/to-orm-or-not-to-orm/</link>
<guid isPermaLink="true" >https://eli.thegreenplace.net/2019/to-orm-or-not-to-orm/</guid>
<description>&lt;p&gt;I've been enjoying using Go's &lt;tt class=&quot;docutils literal&quot;&gt;database/sql&lt;/tt&gt; package for working with databases. Recently, some mentions of &lt;a class=&quot;reference external&quot; href=&quot;https://gorm.io/&quot;&gt;gorm&lt;/a&gt; piqued my curiosity about using ORMs in Go vs. using &lt;tt class=&quot;docutils literal&quot;&gt;database/sql&lt;/tt&gt; directly. Having had some mixed experiences with ORMs in the past, I decided to start with a practical experiment by writing the same simple application with and without gorm, and comparing the results in terms of effort spent.&lt;/p&gt;
&lt;p&gt;This led me to write down some general thoughts on the benefits and drawbacks of ORMs. If that kind of thing interests you, read on!&lt;/p&gt;
&lt;div class=&quot;section&quot; id=&quot;my-no-orm-vs-orm-experiment&quot; readability=&quot;80.63776448942&quot;&gt;
&lt;h2&gt;My no-ORM vs. ORM experiment&lt;/h2&gt;
&lt;p&gt;My experiment involves defining a simple database that could be a subset of a blogging engine, as well as write some Go code that populates and queries this database and compare how it looks using plain SQL vs. using an ORM.&lt;/p&gt;
&lt;p&gt;This is the database schema:&lt;/p&gt;
&lt;img alt=&quot;DB schema for the experiment - showing Post, Tag, Comment tables&quot; class=&quot;align-center&quot; src=&quot;https://eli.thegreenplace.net/images/2019/ormdbschema.png&quot;/&gt;&lt;p&gt;While simple, this schema demonstrates an idiomatic normalized database that most likely contains all the elements one needs to build simple wiki or blog apps - it has both one-to-many relationships (between posts and comments) and many-to-many relationships (between posts and tags). If you prefer to read DB schemas as SQL, here's the definition taken &lt;a class=&quot;reference external&quot; href=&quot;https://github.com/eliben/code-for-blog/tree/master/2019/orm-vs-no-orm/sql&quot;&gt;from the code sample&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;22&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;k&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Post&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;postID&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;integer&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;primary&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;published&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;title&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;content&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;text&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Comment&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;commentID&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;integer&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;primary&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;postID&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;integer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;author&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;published&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;content&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- One-to-many relationship between Post and Comment; each Comment&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- references a Post it's logically attached to.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;foreign&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;postID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;references&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Post&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;postID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Tag&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tagID&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;integer&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;primary&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unique&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;-- Linking table for the many-to-many relationship between Tag and Post&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PostTag&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;postID&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;integer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tagID&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;integer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;foreign&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;postID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;references&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Post&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;postID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;foreign&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tagID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;references&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Tag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tagID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This SQL was tested with SQLIte; other RDBMSs may need minor adjustments. When using gorm, there is no need to write this SQL. Instead, we define &quot;objects&quot; (really &lt;tt class=&quot;docutils literal&quot;&gt;struct&lt;/tt&gt;s) with some magic field tags for gorm:&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;kd&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Post&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;gorm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Model&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;Published&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Time&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;Title&lt;/span&gt;     &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;Content&lt;/span&gt;   &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;Comments&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Comment&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;`gorm:&quot;foreignkey:PostID&quot;`&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;Tags&lt;/span&gt;      &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Tag&lt;/span&gt;    &lt;span class=&quot;s&quot;&gt;`gorm:&quot;many2many:post_tags;&quot;`&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Tag&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;gorm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Model&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;Name&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;Posts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Post&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;`gorm:&quot;many2many:post_tags;&quot;`&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Comment&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;gorm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Model&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;Author&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;Published&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Time&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;Content&lt;/span&gt;   &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;PostID&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;int64&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a class=&quot;reference external&quot; href=&quot;https://github.com/eliben/code-for-blog/tree/master/2019/orm-vs-no-orm&quot;&gt;The code&lt;/a&gt; working with this database comes in two variants:&lt;/p&gt;
&lt;ol class=&quot;arabic simple&quot;&gt;&lt;li&gt;No-ORM; using plain SQL queries through the &lt;tt class=&quot;docutils literal&quot;&gt;database/sql&lt;/tt&gt; package.&lt;/li&gt;
&lt;li&gt;ORM; using the gorm library for database access.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;The sample is doing several things:&lt;/p&gt;
&lt;ol class=&quot;arabic simple&quot;&gt;&lt;li&gt;Add some data (posts, comments, tags) to the DB.&lt;/li&gt;
&lt;li&gt;Query all posts in a given tag.&lt;/li&gt;
&lt;li&gt;Query all post details (all comments attached to it, all tags it's marked with).&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Just as an example, here are the two variants for task (2) - finding all posts in a given tag (this could be to populate some sort of archives listing page on the blog). First, no-ORM:&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;24&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dbAllPostsInTag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sql&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;DB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;tagID&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;([]&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;post&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;rows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Query&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;    select Post.postID, Post.published, Post.title, Post.content&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;    from Post&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;    inner join PostTag on Post.postID = PostTag.postID&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;    where PostTag.tagID = ?`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;tagID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;posts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;post&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;rows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;post&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;rows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Scan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Published&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Title&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Content&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;posts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;posts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;posts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is fairly straightforward if you know SQL. We have to perform an &lt;em&gt;inner join&lt;/em&gt; between &lt;tt class=&quot;docutils literal&quot;&gt;Post&lt;/tt&gt; and &lt;tt class=&quot;docutils literal&quot;&gt;PostTag&lt;/tt&gt; and filter it by the tag ID. The rest of the code is just iterating over the results.&lt;/p&gt;
&lt;p&gt;Next, the ORM:&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;allPostsInTag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;gorm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;DB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Tag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;([]&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Post&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;posts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Post&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Related&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;posts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Posts&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Error&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Error&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;posts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the ORM code, we tend to use objects directly (&lt;tt class=&quot;docutils literal&quot;&gt;Tag&lt;/tt&gt; here) rather than their IDs, for the same effect. The SQL query generated by gorm here will be pretty much the same as the one I wrote manually in the no-ORM variant.&lt;/p&gt;
&lt;p&gt;Apart from generating the SQL for us, gorm also provides an easier way to populate a slice of results. In the code using &lt;tt class=&quot;docutils literal&quot;&gt;database/sql&lt;/tt&gt; we explicitly loop over the results, scanning each row separately into individual struct fields. gorm's &lt;tt class=&quot;docutils literal&quot;&gt;Related&lt;/tt&gt; method (and other similar querying methods) will populate structs automatically and will also scan the whole result set in one go.&lt;/p&gt;
&lt;p&gt;Feel free to &lt;a class=&quot;reference external&quot; href=&quot;https://github.com/eliben/code-for-blog/tree/master/2019/orm-vs-no-orm&quot;&gt;play with the code&lt;/a&gt;! I was pleasantly surprised at the amount of code gorm saves here (about 50% savings for the DB-intensive part of the code), and for these simple queries using gorm wasn't hard - the invocations are taken from API docs in a straightforward manner. The only complaint I have about my specific example is that setting up the many-to-many relationship between &lt;tt class=&quot;docutils literal&quot;&gt;Post&lt;/tt&gt; and &lt;tt class=&quot;docutils literal&quot;&gt;Tag&lt;/tt&gt; was a bit finicky, and the gorm struct field tags look ugly and magical.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;layered-complexity-rears-its-ugly-head&quot; readability=&quot;27.620195930671&quot;&gt;
&lt;h2&gt;Layered complexity rears its ugly head&lt;/h2&gt;
&lt;p&gt;The problem with simple experiments like that above is that it's often difficult to tickle the system's boundaries. It obviously works well for simple cases, but I was interested to find out what happens when it's pushed to the limit - how does it handle complicated queries and DB schemas? So I turned to browsing Stack Overflow. There are many gorm-related questions, and sure enough, the usual layered complexity problem is immediately apparent (&lt;a class=&quot;reference external&quot; href=&quot;https://stackoverflow.com/questions/55914830/value-0-zero-not-getting-updated-in-postgres-database-when-updation-is-perfo&quot;&gt;example 1&lt;/a&gt;, &lt;a class=&quot;reference external&quot; href=&quot;https://stackoverflow.com/questions/55656002/how-to-select-by-fields-in-preloaded-object&quot;&gt;example 2&lt;/a&gt;). Let me explain what I mean by that.&lt;/p&gt;
&lt;p&gt;Any situation where complex functionality is wrapped in another layer runs the risk of increasing the overall complexity when the wrapping layer is itself complicated. This often comes along with leaky abstractions - wherin the wrapping layer can't do a perfect job wrapping the underlying functionality, and forces programmers to fight with both layers simultaneously.&lt;/p&gt;
&lt;p&gt;Unfortunately, gorm is very susceptible to this problem. Stack Overflow has an endless supply of problems where users end up fighting complexities imposed by gorm itself, working around its limitations, and so on. Few things are as aggravating as knowing exactly what you want (i.e. which SQL query you want it to issue) but not being able to concoct the right sequence of gorm calls to end up with that query.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;pros-and-cons-of-using-an-orm&quot; readability=&quot;27&quot;&gt;
&lt;h2&gt;Pros and Cons of using an ORM&lt;/h2&gt;
&lt;p&gt;One key advantage of using an ORM is apparent from my experiment: it saves quite a bit of tedious coding. About 50% savings in DB-centered code is nontrivial and can make a real difference for some applications.&lt;/p&gt;
&lt;p&gt;Another advantage that wasn't obvious here is abstraction from different database backends. This may be less of an issue in Go, however, since &lt;tt class=&quot;docutils literal&quot;&gt;database/sql&lt;/tt&gt; already provides a great portable layer. In languages that lack a standardized SQL access layer, this advantage is much stronger.&lt;/p&gt;
&lt;p&gt;As for the disadvantages:&lt;/p&gt;
&lt;ol class=&quot;arabic simple&quot;&gt;&lt;li&gt;Another layer to learn, with all the idiosyncracies, special syntax, magical tags, and so on. This is mainly a disadvantage if you're already experienced with SQL itself.&lt;/li&gt;
&lt;li&gt;Even if you're not experienced with SQL, there is a vast bank of knowledge out there and many folks who can help with answers. Any single ORM is much more obscure knowledge not shared by many, and you will spend considerable amounts of time figuring out how to force-feed it things.&lt;/li&gt;
&lt;li&gt;Debugging query performance is challenging, because we're abstracted one level further from &quot;the metal&quot;. Sometimes quite a bit of tweaking is required to get the ORM to generate the right queries for you, and this is frustrating when you already know which queries you need.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Finally, a disadvantage that only becomes apparent in the long term: while SQL stays pretty much constant over the years, ORMs are language-specific and also tend to appear and disappear all the time. Every popular language has a large variety of ORMs to choose from; as you move from one team/company/project to another, you may be expected to switch, and that's additional mental burden. Or you may switch languages altogether. SQL is a much more stable layer that stays with you across teams/languages/projects.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;conclusion&quot; readability=&quot;28.781038374718&quot;&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Having implemented a simple application skeleton using raw SQL and compared it to an implementation using gorm, I can see the appeal of ORMs in reducing boilerplate. I can also remember myself from many years ago being a DB newbie and using Django with its ORM to implement an application - it was nice! I didn't have to think about SQL or the underlying DB much, it just worked. But that use case was really simple.&lt;/p&gt;
&lt;p&gt;With my &quot;experienced and salty&quot; hat on, I can also see many disadvantages in using an ORM. Specifically, I don't think an ORM is useful &lt;em&gt;for me&lt;/em&gt; in a language like Go which already has a good SQL interface that's mostly portable across DB backends. I'd much rather spend an extra bit of time typing, but this will save me time reading ORM's documentation, optimizing my queries, and most importantly debugging.&lt;/p&gt;
&lt;p&gt;I could see an ORM still being useful in Go if your job is to write large numbers of simple CRUD-like applications, where the savings in typing overcome the disadvantages. In the end, it all boils down to the central thesis of the &lt;a class=&quot;reference external&quot; href=&quot;http://eli.thegreenplace.net/2017/benefits-of-dependencies-in-software-projects-as-a-function-of-effort/&quot;&gt;benefits of extra dependencies as a function of effort&lt;/a&gt;: where there is significant effort to spend on a project &lt;em&gt;outside&lt;/em&gt; the DB-interfacing code - which should be the case for programs that aren't simple CRUDs - the ORM dependency is not worth it, in my opinion.&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 07 May 2019 15:32:44 +0000</pubDate>
<dc:creator>ingve</dc:creator>
<dc:format>text/html</dc:format>
<dc:identifier>https://eli.thegreenplace.net/2019/to-orm-or-not-to-orm/</dc:identifier>
</item>
<item>
<title>Researchers identify sleep as a reason why personality traits predict longevity</title>
<link>https://digest.bps.org.uk/2019/05/01/researchers-identity-sleep-as-a-key-reason-why-personality-traits-predict-longevity</link>
<guid isPermaLink="true" >https://digest.bps.org.uk/2019/05/01/researchers-identity-sleep-as-a-key-reason-why-personality-traits-predict-longevity</guid>
<description>&lt;p&gt;&lt;img data-attachment-id=&quot;37012&quot; data-permalink=&quot;https://digest.bps.org.uk/2019/05/01/researchers-identity-sleep-as-a-key-reason-why-personality-traits-predict-longevity/insomnia-and-depression/&quot; data-orig-file=&quot;https://researchdigest.files.wordpress.com/2019/05/gettyimages-155418718.jpg?w=845&quot; data-orig-size=&quot;2738,1825&quot; data-comments-opened=&quot;1&quot; data-image-meta=&quot;{&amp;quot;aperture&amp;quot;:&amp;quot;3.2&amp;quot;,&amp;quot;credit&amp;quot;:&amp;quot;Getty Images&amp;quot;,&amp;quot;camera&amp;quot;:&amp;quot;Canon EOS 5D Mark II&amp;quot;,&amp;quot;caption&amp;quot;:&amp;quot;Sweaty, disheveled mature man lying on a bed looking stricken in a dark hotel room.&amp;quot;,&amp;quot;created_timestamp&amp;quot;:&amp;quot;1285514691&amp;quot;,&amp;quot;copyright&amp;quot;:&amp;quot;Nicolas McComber&amp;quot;,&amp;quot;focal_length&amp;quot;:&amp;quot;50&amp;quot;,&amp;quot;iso&amp;quot;:&amp;quot;500&amp;quot;,&amp;quot;shutter_speed&amp;quot;:&amp;quot;0.02&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;Insomnia and depression&amp;quot;,&amp;quot;orientation&amp;quot;:&amp;quot;0&amp;quot;}&quot; data-image-title=&quot;Insomnia and depression&quot; data-image-description=&quot;&quot; data-medium-file=&quot;https://researchdigest.files.wordpress.com/2019/05/gettyimages-155418718.jpg?w=845?w=300&quot; data-large-file=&quot;https://researchdigest.files.wordpress.com/2019/05/gettyimages-155418718.jpg?w=845?w=845&quot; class=&quot;alignnone size-full wp-image-37012&quot; src=&quot;https://researchdigest.files.wordpress.com/2019/05/gettyimages-155418718.jpg?w=845&quot; alt=&quot;GettyImages-155418718.jpg&quot; srcset=&quot;https://researchdigest.files.wordpress.com/2019/05/gettyimages-155418718.jpg?w=845 845w, https://researchdigest.files.wordpress.com/2019/05/gettyimages-155418718.jpg?w=1690 1690w, https://researchdigest.files.wordpress.com/2019/05/gettyimages-155418718.jpg?w=150 150w, https://researchdigest.files.wordpress.com/2019/05/gettyimages-155418718.jpg?w=300 300w, https://researchdigest.files.wordpress.com/2019/05/gettyimages-155418718.jpg?w=768 768w, https://researchdigest.files.wordpress.com/2019/05/gettyimages-155418718.jpg?w=1024 1024w&quot; sizes=&quot;(max-width: 845px) 100vw, 845px&quot;/&gt;&lt;em&gt;By&lt;/em&gt; &lt;a href=&quot;http://www.christianjarrett.com/&quot;&gt;Christian Jarrett&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Your personality traits play an important part in how long you are likely to live, as much as, or even more than, other personal factors like your intelligence and your family’s economic background. Now &lt;a href=&quot;https://www.sciencedirect.com/science/article/pii/S0092656618302502&quot;&gt;a study&lt;/a&gt; in the &lt;em&gt;Journal of Research in Personality&lt;/em&gt; has identified a key factor that mediates the personality-mortality link – sleep. Simply put, people with certain personality characteristics are more likely to sleep too little, or too much, or to experience greater sleepiness during the day, and in turn this raises their year-on-year risk of dying (too little or excess sleep, and poor quality sleep, have known links with various health risks, such as cardiovascular disease, depression and chronic inflammation).&lt;/p&gt;
&lt;p&gt;“Sleep has been associated with both personality and longevity, yet [before now] no study has investigated whether sleep is a pathway linking personality to objective health outcomes,” say the researchers, led by Shantel Spears at West Virginia University.&lt;/p&gt;

&lt;p&gt;The researchers used data collected from thousands of participants as part of the long-running National Survey of Midlife Development in the United States, including information on their personality traits recorded in 1995-1996, and information on their sleep duration and sleep quality collected in 2004-2006. Nearly 4000 participants provided data at both these time points, and the researchers then used national records to see which of them had died and when, up to October, 2015.&lt;/p&gt;
&lt;p&gt;As expected, based on the known importance of sleep to health, the research showed that too little or too much sleep was associated with increased risk of dying – approximately 65 minutes more than, or under, the average nightly sleep duration (7 hours in this sample) was associated with a 10 per cent increased risk of dying over the course of the study.&lt;/p&gt;
&lt;p&gt;Turning to personality, and consistent with many prior studies, participants who scored lower on trait conscientiousness were more likely to die before the end of the research period, and Spears’ team established that this was explained in part by these people getting less sleep, on average, and feeling less rested during the day (a mark of poorer sleep quality). Although the study didn’t look into why exactly people low in conscientiousness were getting less sleep, one can imagine they engage in more &lt;a href=&quot;https://digest.bps.org.uk/2014/08/01/psychologists-investigate-a-major-ignored-reason-for-our-lack-of-sleep-bedtime-procrastination/&quot;&gt;bedtime procrastination&lt;/a&gt;, and generally struggle to establish &lt;a href=&quot;https://digest.bps.org.uk/2018/02/21/episode-11-how-to-get-a-good-nights-sleep/&quot;&gt;a healthy bedtime routine&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Similarly, high scorers on trait neuroticism were indirectly at greater risk of dying because of their lower and higher than average amounts of sleep, and their on-average greater feelings of fatigue in the daytime. Again, one can speculate that these folk, who have lower moods and more worry, might struggle to get to sleep or to get up promptly in the morning.&lt;/p&gt;
&lt;p&gt;Lower scores on extraversion were indirectly linked with increased risk of death, thanks to an association with greater daytime feelings of fatigue (perhaps extraverts’ greater daytime activity levels makes it easier for them to get a satisfying night’s sleep, but this is speculation). Most surprising – given prior research findings have not identified this trait as being relevant to sleep – was the indirect link between higher trait agreeableness and risk of dying, explained by these people having less sleep and more daytime fatigue; it’s not clear why this might be.&lt;/p&gt;
&lt;p&gt;Previous research had already established that personality predicts longevity because of its association with various health behaviours, such as more conscientious people being less likely to smoke, or drink and eat to excess. However, much of the personality-linked variance in risk of dying has remained unexplained, and this study now identifies too little or too much sleep (and feeling insufficiently rested during the day) as other important factors. “Our findings suggest that short and long sleep duration and daytime dysfunction may be important pathways linking aspects of personality to reduced life expectancy,” the researchers said.&lt;/p&gt;
&lt;p&gt;The research has some important limitations including the participants being mostly white and highly educated; the reliance on a short self-report test of personality; and the subjective measure of sleep being based on time spent in bed rather being asleep per se. Nonetheless, if the results can be replicated, they raise some important implications for public health, suggesting that personality screening could be used to identify those people – especially high scorers in neuroticism and low scorers in conscientiousness – most likely to benefit from interventions aimed at improving sleep. “Alternatively,” the researchers said, “&lt;a href=&quot;https://digest.bps.org.uk/2017/01/19/a-little-discussed-effect-of-therapy-it-changes-your-personality/&quot;&gt;changing these aspects of personality&lt;/a&gt; could improve sleep for these individuals, enhancing their health and longevity”.&lt;/p&gt;
&lt;p&gt;—&lt;a href=&quot;https://www.sciencedirect.com/science/article/pii/S0092656618302502&quot;&gt;Sleep: A Pathway Linking Personality to Mortality Risk&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.psychologywriter.org.uk/&quot;&gt;Christian Jarrett&lt;/a&gt; &lt;strong&gt;(&lt;/strong&gt;&lt;a href=&quot;https://twitter.com/psych_Writer&quot;&gt;&lt;span class=&quot;s3&quot;&gt;@Psych_Writer&lt;/span&gt;&lt;/a&gt;) is Editor of &lt;span class=&quot;s3&quot;&gt;&lt;a href=&quot;https://digest.bps.org.uk/&quot;&gt;BPS Research Digest&lt;/a&gt; and the author of a forthcoming book on personality change&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;
&lt;div id=&quot;jp-post-flair&quot; class=&quot;sharedaddy sd-like-enabled sd-sharing-enabled&quot;&gt;
&lt;div class=&quot;sharedaddy sd-sharing-enabled&quot;&gt;
&lt;div class=&quot;robots-nocontent sd-block sd-social sd-social-icon-text sd-sharing&quot;&gt;
&lt;h3 class=&quot;sd-title&quot;&gt;Share this:&lt;/h3&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sharedaddy sd-block sd-like jetpack-likes-widget-wrapper jetpack-likes-widget-unloaded&quot; id=&quot;like-post-wrapper-114693443-37011-5cd28cc1ea880&quot; data-src=&quot;//widgets.wp.com/likes/index.html?ver=20190321#blog_id=114693443&amp;amp;post_id=37011&amp;amp;origin=researchdigest.wordpress.com&amp;amp;obj_id=114693443-37011-5cd28cc1ea880&amp;amp;domain=digest.bps.org.uk&quot; data-name=&quot;like-post-frame-114693443-37011-5cd28cc1ea880&quot;&gt;
&lt;h3 class=&quot;sd-title&quot;&gt;Like this:&lt;/h3&gt;
&lt;div class=&quot;likes-widget-placeholder post-likes-widget-placeholder&quot;&gt;&lt;span class=&quot;button&quot;&gt;&lt;span&gt;Like&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;loading&quot;&gt;Loading...&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
</description>
<pubDate>Tue, 07 May 2019 14:07:32 +0000</pubDate>
<dc:creator>laurex</dc:creator>
<og:type>article</og:type>
<og:title>Researchers Identify Sleep As A Key Reason Why Personality Traits Predict Longevity</og:title>
<og:url>https://digest.bps.org.uk/2019/05/01/researchers-identity-sleep-as-a-key-reason-why-personality-traits-predict-longevity/</og:url>
<og:description>By Christian Jarrett. People with certain personality characteristics are more likely to sleep too little, or too much, or to experience greater sleepiness during the day, and in turn this raises t…</og:description>
<og:image>https://researchdigest.files.wordpress.com/2019/05/gettyimages-155418718.jpg</og:image>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://digest.bps.org.uk/2019/05/01/researchers-identity-sleep-as-a-key-reason-why-personality-traits-predict-longevity/</dc:identifier>
</item>
<item>
<title>Red Hat Enterprise Linux 8 released</title>
<link>https://www.redhat.com/en/enterprise-linux-8?701f20000012hnlAAA#</link>
<guid isPermaLink="true" >https://www.redhat.com/en/enterprise-linux-8?701f20000012hnlAAA#</guid>
<description>&lt;h3 class=&quot;section-label mb-2 text-red&quot;&gt;Created for innovators&lt;/h3&gt;
&lt;h2&gt;Cutting edge meets enterprise–grade&lt;/h2&gt;
&lt;p&gt;Empower your organizations' developers and engineers to build innovative new technologies, like machine learning and smart analytics.&lt;/p&gt;
&lt;p&gt;Red Hat Enterprise Linux 8 has key features—from container tools to GPU support—to deploy tomorrow's technology, today.&lt;/p&gt;
&lt;p class=&quot;cta-group&quot;&gt;&lt;a class=&quot;btn btn-outline-black&quot; href=&quot;https://www.redhat.com/en/enterprise-linux-8/details#technologies&quot;&gt;Emerging tech starts here&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 07 May 2019 13:04:44 +0000</pubDate>
<dc:creator>lubomir</dc:creator>
<og:description>Red Hat Enterprise Linux 8 is the intelligent operating system for hybrid cloud. Any workload. Any environment. One OS.</og:description>
<og:type>website</og:type>
<og:url>https://www.redhat.com/en/enterprise-linux-8</og:url>
<og:title>Red Hat Enterprise Linux 8</og:title>
<og:image>https://www.redhat.com/profiles/rh/themes/redhatdotcom/img/red-hat-social-share.jpg</og:image>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.redhat.com/en/enterprise-linux-8?701f20000012hnlAAA</dc:identifier>
</item>
</channel>
</rss>