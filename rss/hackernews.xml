<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=hnrss.org%2Fnewest%3Fpoints%3D200&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://hnrss.org/newest?points=200" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dhnrss.org%252Fnewest%253Fpoints%253D200%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dhnrss.org%252Fnewest%253Fpoints%253D200%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>Hacker News: Newest</title>
<link>https://news.ycombinator.com/newest</link>
<description>Hacker News RSS</description>
<item>
<title>Canadian permafrost thaws 70 years earlier than predicted</title>
<link>https://www.reuters.com/article/us-climate-change-permafrost/scientists-amazed-as-canadian-permafrost-thaws-70-years-early-idUSKCN1TJ1XN</link>
<guid isPermaLink="true" >https://www.reuters.com/article/us-climate-change-permafrost/scientists-amazed-as-canadian-permafrost-thaws-70-years-early-idUSKCN1TJ1XN</guid>
<description>&lt;p&gt;LONDON (Reuters) - Permafrost at outposts in the Canadian Arctic is thawing 70 years earlier than predicted, an expedition has discovered, in the latest sign that the global climate crisis is accelerating even faster than scientists had feared.&lt;/p&gt;
&lt;div class=&quot;PrimaryAsset_container&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;Image_container&quot; tabindex=&quot;-1&quot; readability=&quot;13&quot;&gt;
&lt;div class=&quot;LazyImage_container LazyImage_dark&quot;&gt;&lt;img src=&quot;https://s3.reutersmedia.net/resources/r/?m=02&amp;amp;d=20190618&amp;amp;t=2&amp;amp;i=1399126378&amp;amp;r=LYNXNPEF5H1NN&amp;amp;w=20&quot; aria-label=&quot;General view of a landscape of partially thawed Arctic permafrost near Mould Bay, Canada, in this handout photo released June 18, 2019. The image was captured in 2016 by researchers from the University of Alaska Fairbanks who were amazed to find the permafrost thawing 70 years faster than models predicted. Louise Farquharson/Handout via REUTERS&quot;/&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;General view of a landscape of partially thawed Arctic permafrost near Mould Bay, Canada, in this handout photo released June 18, 2019. The image was captured in 2016 by researchers from the University of Alaska Fairbanks who were amazed to find the permafrost thawing 70 years faster than models predicted. Louise Farquharson/Handout via REUTERS&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;A team from the University of Alaska Fairbanks said they were astounded by how quickly a succession of unusually hot summers had destabilized the upper layers of giant subterranean ice blocks that had been frozen solid for millennia.&lt;/p&gt;
&lt;p&gt;“What we saw was amazing,” Vladimir E. Romanovsky, a professor of geophysics at the university, told Reuters by telephone. “It’s an indication that the climate is now warmer than at any time in the last 5,000 or more years.”&lt;/p&gt;
&lt;p&gt;With governments meeting in Bonn this week to try to ratchet up ambitions in United Nations climate negotiations, the team’s findings, published on June 10 in Geophysical Research Letters, offered a further sign of a growing climate emergency.&lt;/p&gt;
&lt;p&gt;The paper was based on data Romanovsky and his colleagues had been analyzing since their last expedition to the area in 2016. The team used a modified propeller plane to visit exceptionally remote sites, including an abandoned Cold War-era radar base more than 300 km from the nearest human settlement.&lt;/p&gt;
&lt;p&gt;Diving through a lucky break in the clouds, Romanovsky and his colleagues said they were confronted with a landscape that was unrecognizable from the pristine Arctic terrain they had encountered during initial visits a decade or so earlier.&lt;/p&gt;
&lt;p&gt;The vista had dissolved into an undulating sea of hummocks - waist-high depressions and ponds known as thermokarst. Vegetation, once sparse, had begun to flourish in the shelter provided from the constant wind.&lt;/p&gt;
&lt;p&gt;Torn between professional excitement and foreboding, Romanovsky said the scene had reminded him of the aftermath of a bombardment.&lt;/p&gt;
&lt;p&gt;“It’s a canary in the coalmine,” said Louise Farquharson, a post-doctoral researcher and co-author of the study. “It’s very likely that this phenomenon is affecting a much more extensive region and that’s what we’re going to look at next.”&lt;/p&gt;
&lt;p&gt;Scientists are concerned about the stability of permafrost because of the risk that rapid thawing could release vast quantities of heat-trapping gases, unleashing a feedback loop that would in turn fuel even faster temperature rises.&lt;/p&gt;
&lt;p&gt;Even if current commitments to cut emissions under the 2015 Paris Agreement are implemented, the world is still far from averting the risk that these kinds of feedback loops will trigger runaway warming, according to models used by the U.N.-backed Intergovernmental Panel on Climate Change.&lt;/p&gt;
&lt;p&gt;With scientists warning that sharply higher temperatures would devastate the global south and threaten the viability of industrial civilization in the northern hemisphere, campaigners said the new paper reinforced the imperative to cut emissions.&lt;/p&gt;
&lt;p&gt;“Thawing permafrost is one of the tipping points for climate breakdown and it’s happening before our very eyes,” said Jennifer Morgan, Executive Director of Greenpeace International. “This premature thawing is another clear signal that we must decarbonize our economies, and immediately.”&lt;/p&gt;
&lt;div class=&quot;Attribution_container&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;Attribution_attribution&quot; readability=&quot;7&quot;&gt;
&lt;p class=&quot;Attribution_content&quot;&gt;Reporting by Matthew Green; Editing by Mark Heinrich&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;StandardArticleBody_trustBadgeContainer&quot;&gt;&lt;span class=&quot;StandardArticleBody_trustBadgeTitle&quot;&gt;Our Standards:&lt;/span&gt;&lt;span class=&quot;trustBadgeUrl&quot;&gt;&lt;a href=&quot;http://thomsonreuters.com/en/about-us/trust-principles.html&quot;&gt;The Thomson Reuters Trust Principles.&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
</description>
<pubDate>Tue, 18 Jun 2019 19:21:10 +0000</pubDate>
<dc:creator>anigbrowl</dc:creator>
<og:title>Scientists amazed as Canadian permafrost thaws 70 years early</og:title>
<og:url>https://www.reuters.com/article/us-climate-change-permafrost-idUSKCN1TJ1XN</og:url>
<og:type>article</og:type>
<og:description>Permafrost at outposts in the Canadian Arctic is thawing 70 years earlier than p...</og:description>
<og:image>https://s3.reutersmedia.net/resources/r/?m=02&amp;d=20190618&amp;t=2&amp;i=1399126378&amp;w=1200&amp;r=LYNXNPEF5H1NN</og:image>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.reuters.com/article/us-climate-change-permafrost/scientists-amazed-as-canadian-permafrost-thaws-70-years-early-idUSKCN1TJ1XN</dc:identifier>
</item>
<item>
<title>Berlin approves 5-year rent freeze</title>
<link>https://www.reuters.com/article/germany-housing-rent-cap/berlin-approves-5-year-rent-freeze-in-german-capital-idUSS8N20O06F</link>
<guid isPermaLink="true" >https://www.reuters.com/article/germany-housing-rent-cap/berlin-approves-5-year-rent-freeze-in-german-capital-idUSS8N20O06F</guid>
<description>&lt;p&gt;BERLIN, June 18 (Reuters) - The Berlin Senate on Tuesday approved a five-year rent freeze designed to tame soaring housing costs in the German capital, bowing to pressure from residents angry that their city has become unaffordable.&lt;/p&gt;
&lt;p&gt;The Senator for Urban Development and Housing in Berlin, Katrin Lompscher, said the five-year freeze, which was originally planned to take effect in January 2020, would apply retroactively from June 18. (Reporting by Holger Hansen und Joseph Nasr Editing by Michael Nienaber)&lt;/p&gt;
&lt;div class=&quot;StandardArticleBody_trustBadgeContainer&quot;&gt;&lt;span class=&quot;StandardArticleBody_trustBadgeTitle&quot;&gt;Our Standards:&lt;/span&gt;&lt;span class=&quot;trustBadgeUrl&quot;&gt;&lt;a href=&quot;http://thomsonreuters.com/en/about-us/trust-principles.html&quot;&gt;The Thomson Reuters Trust Principles.&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
</description>
<pubDate>Tue, 18 Jun 2019 16:34:41 +0000</pubDate>
<dc:creator>ciceryadam</dc:creator>
<og:title>Berlin approves 5-year rent freeze in German capital</og:title>
<og:url>https://www.reuters.com/article/germany-housing-rent-cap-idUSS8N20O06F</og:url>
<og:type>article</og:type>
<og:description>The Berlin Senate on Tuesday approved a five-year rent freeze designed to tame s...</og:description>
<og:image>https://s4.reutersmedia.net/resources_v2/images/rcom-default.png</og:image>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.reuters.com/article/germany-housing-rent-cap/berlin-approves-5-year-rent-freeze-in-german-capital-idUSS8N20O06F</dc:identifier>
</item>
<item>
<title>How LinkedIn exfiltrates extension data from the browser</title>
<link>https://prophitt.me/articles/nefarious-linkedin</link>
<guid isPermaLink="true" >https://prophitt.me/articles/nefarious-linkedin</guid>
<description>&lt;p&gt;How would you feel if you opened a program and the program started to check your file system to see what other programs you had installed? You would probably feel the software was overstepping. This is essentially what LInkedIn does when you visit their website. LinkedIn will scan your local browser files in an attempt to identify a number of different browser extensions you may have installed. The data collected by LinkedIn is then exfiltrated from the browser.&lt;/p&gt;
&lt;h2&gt;Unraveling the Mystery&lt;/h2&gt;
&lt;p&gt;This whole adventure started when I was browsing LinkedIn and happened to have my browser console open. While on my LinkedIn profile I noticed a large number of 404 errors and as a developer it piqued my interest.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://prophitt.me/uploads/lines/picture/image/6/spying-xs.gif&quot; alt=&quot;Alt Text&quot;/&gt;&lt;/p&gt;
&lt;p&gt;What really piqued my curiosity was the fact all of these failed web requests were for &lt;code&gt;chrome-extension://&lt;/code&gt; resources. After inspecting a few of the extension IDs in the resources I began to suspect LinkedIn was attempting to determine if I had certain extensions installed by executing local web requests to the browser itself.&lt;/p&gt;
&lt;p&gt;I spent some time toying around with my browser and LinkedIn's assets. Note, reverse engineering LinkedIn's source code is apparently &lt;a href=&quot;https://www.linkedin.com/legal/user-agreement&quot;&gt;against their terms of service&lt;/a&gt;. If I was LinkedIn I would probably not want people figuring out how I spy on them either.&lt;/p&gt;
&lt;p&gt;After poking around and doing some investigation I found an interesting object in one of LinkedIn's local storage values.&lt;/p&gt;
&lt;h2&gt;LinkedIn's Extension File&lt;/h2&gt;
&lt;p&gt;One of LinkedIn's local storage keys is &lt;code&gt;C_C_M&lt;/code&gt;. The value itself is a base64 encoded string (which isn't too abnormal). However, if you decode the string you will see a large JSON blob that seems to be encoded with unicode code points (not human readable).&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://prophitt.me/uploads/lines/picture/image/9/unicode-resized.png&quot; alt=&quot;Alt Text&quot;/&gt;&lt;/p&gt;
&lt;p&gt;I am not too sure how or why they encoded it that way, but it seems to me like it was in an attempt to obfuscate the data. The encoding is easy enough to reverse, simply parse the JSON. You can do it yourself with the following snippet:&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;nx&quot;&gt;JSON&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;atob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;localStorage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getItem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;C_C_M&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Doing so will display a large JavaScript object with some interesting data in it. &lt;em&gt;Note&lt;/em&gt;, it appears the data held in this JSON blob is personalized to some degree. In other words, my JSON blob may be larger or smaller than yours. I am unsure which heuristic LinkedIn uses to determine which extensions to scan for but they must be using some. I have attached my JSON blob to this blob post for your reference.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://prophitt.me/uploads/lines/picture/image/10/localstorage.png&quot; alt=&quot;Alt Text&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;How does LinkedIn search for extensions?&lt;/h2&gt;
&lt;p&gt;After examing the JSON file it became pretty clear what was going on. LinkedIn is using two different methods to determine if you have an extension installed.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Content changes.&lt;/li&gt;
&lt;li&gt;Web accessible resources.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;The first method is the simplest. LinkedIn simply looks for certain content on the page they know doesn't belong there. For instance, if they find a div with the ID &lt;code&gt;email-hunter&lt;/code&gt;, they know you have the Email Hunter extension installed (and now your account is probably restricted, or at least on a blacklist).&lt;/p&gt;
&lt;p&gt;The second method is a lot more interesting to me. When building an extension you can specify &lt;a href=&quot;https://developer.chrome.com/extensions/manifest/web_accessible_resources&quot;&gt;web accessible resources&lt;/a&gt;. These resources are typically used via a content script to build a custom interface. However, there's a bit of a gotcha. If the content script can make a request for the web accessible resource, so can the underlying website. LinkedIn abuses this fact and sprays web requests to your local browser in attempt to find extensions.&lt;/p&gt;
&lt;p&gt;I built a simple extension to automatically parse the extension file and display extensions LinkedIn is looking for. Check it out &lt;a href=&quot;https://prophitt.me/articles/linkedin-tool&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;What can you do as a developer to prevent detection?&lt;/h2&gt;
&lt;p&gt;So, as a developer of an extension what can you do about this? I recommend not using web accessible resources. Out of all extensions LinkedIn finds, a majority of them are due to web accessible resources.&lt;/p&gt;
&lt;p&gt;I would recommend &lt;em&gt;not&lt;/em&gt; modifying or injecting user interface features into the underlying page. Alternatively, I would use a browser action and communicate with the content page through messaging passing. That is how my extensions (&lt;a href=&quot;https://www.nymeria.io&quot;&gt;Nymeria&lt;/a&gt; and &lt;a href=&quot;https://www.thereach.io&quot;&gt;The Reach&lt;/a&gt;) work.&lt;/p&gt;
&lt;p&gt;Interested in an extension that can automatically parse LinkedIn's extension file and show you which extensions LinkedIn is searching for? I have created a tool for it! Check it out &lt;a href=&quot;https://prophitt.me/articles/linkedin-tool&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&quot;article_document&quot;&gt;&lt;a href=&quot;https://prophitt.me/uploads/lines/article/document/1/linkedin-extension.json&quot;&gt;Download linkedin-extension.json&lt;/a&gt;&lt;/div&gt;
</description>
<pubDate>Tue, 18 Jun 2019 16:19:55 +0000</pubDate>
<dc:creator>asaasinator</dc:creator>
<og:title>Nefarious LinkedIn</og:title>
<og:type>article</og:type>
<og:url>https://prophitt.me/articles/nefarious-linkedin</og:url>
<og:image>prophitt.me/uploads/lines/article/hero_image/1/linkedin-banner.jpeg</og:image>
<dc:format>text/html</dc:format>
<dc:identifier>https://prophitt.me/articles/nefarious-linkedin</dc:identifier>
</item>
<item>
<title>$1B for 20,000 Bay Area homes</title>
<link>https://blog.google/inside-google/company-announcements/1-billion-investment-bay-area-housing/</link>
<guid isPermaLink="true" >https://blog.google/inside-google/company-announcements/1-billion-investment-bay-area-housing/</guid>
<description>&lt;p&gt;As we work to build a more helpful Google, we know our responsibility to help starts at home. For us, that means being a good neighbor in the place where it all began over 20 years ago: the San Francisco Bay Area.&lt;/p&gt;
&lt;p&gt;Today, Google is one of the Bay Area’s largest employers. Across the region, one issue stands out as particularly urgent and complex: housing. The lack of new supply, combined with the rising cost of living, has resulted in a severe shortage of affordable housing options for long-time middle and low income residents. As Google grows throughout the Bay Area—whether it’s in our home town of Mountain View, in San Francisco, or in our future developments in San Jose and Sunnyvale—we’ve invested in developing housing that meets the needs of these communities. But there’s more to do.&lt;/p&gt;
&lt;p&gt;Today we’re announcing an additional $1 billion investment in housing across the Bay Area.&lt;/p&gt;
&lt;p&gt;First, over the next 10 years, we’ll repurpose at least $750 million of Google’s land, most of which is currently zoned for office or commercial space, as residential housing. This will enable us to support the development of at least 15,000 new homes at all income levels in the Bay Area, including housing options for middle and low-income families. (By way of comparison, 3,000 total homes were built in the South Bay in 2018). We hope this plays a role in addressing the chronic shortage of affordable housing options for long-time middle and low income residents.&lt;/p&gt;
&lt;p&gt;Second, we’ll establish a $250 million investment fund so that we can provide incentives to enable developers to build at least 5,000 affordable housing units across the market.&lt;/p&gt;
&lt;p&gt;In addition to the increased supply of affordable housing these investments will help create, we will give $50 million in grants through Google.org to nonprofits focused on the issues of homelessness and displacement. This builds on the $18 million in grants we’ve given to help address homelessness over the last five years, including $3 million we gave to the newly opened &lt;a href=&quot;https://sfmayor.org/article/mayor-london-breed-announces-opening-new-navigation-center&quot;&gt;SF Navigation Center&lt;/a&gt; and $1.5 million to &lt;a href=&quot;http://pah.community/palo-alto-housing-breaks-ground-new-affordable-veterans-workforce-housing-mountain-view/&quot;&gt;affordable housing&lt;/a&gt; for low income veterans and households in Mountain View.&lt;/p&gt;
&lt;p&gt;In the coming months, we’ll continue to work with local municipalities to support plans that allow residential developers to build quickly and economically. Our goal is to get housing construction started immediately, and for homes to be available in the next few years. In Mountain View, we’ve already worked with the city to change zoning in the North Bayshore area to free up land for housing, and we’re currently in productive conversations with Sunnyvale and San Jose.&lt;/p&gt;
&lt;p&gt;Of course, affordable and quality housing is only one way we’re investing in Bay Area communities. We’re also funding &lt;a href=&quot;https://communityspace.withgoogle.com/&quot;&gt;community spaces&lt;/a&gt; that provide free access to co-working areas for nonprofits, improving transit options for &lt;a href=&quot;https://mvcommunityshuttle.com/&quot;&gt;the community&lt;/a&gt; and our employees (taking 9,000 cars off the road per day), and supporting programs for &lt;a href=&quot;https://files.novaworks.org/Media/PR/NOVA_0617-01.pdf&quot;&gt;career development&lt;/a&gt;, &lt;a href=&quot;https://static1.squarespace.com/static/59d3cfe8e5dd5b0acaa2a2b4/t/5b4d67f7aa4a99d6f5aef924/1531799543580/PR-Google_Grant_CORAL_STEM-announcement.pdf&quot;&gt;education&lt;/a&gt; and &lt;a href=&quot;https://grow.google/events/redwood-city/&quot;&gt;local businesses&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Across all of this, our goal is to help communities succeed over the long term, and make sure that everyone has access to opportunity, whether or not they work in tech. Solving a big issue like the housing shortage will take collaboration across business, government and community organizations, and we look forward to working alongside others to make the Bay Area a place where everyone who lives here can thrive.&lt;/p&gt;
</description>
<pubDate>Tue, 18 Jun 2019 16:06:14 +0000</pubDate>
<dc:creator>theBashShell</dc:creator>
<og:type>article</og:type>
<og:title>$1 billion for 20,000 Bay Area homes</og:title>
<og:description>As Google grows throughout the Bay Area, we’re making our biggest investment yet to help with the housing crisis.</og:description>
<og:image>https://storage.googleapis.com/gweb-uniblog-publish-prod/images/Bay_Area_on_Google_Earth_1.max-1300x1300.png</og:image>
<og:url>https://www.blog.google/inside-google/company-announcements/1-billion-investment-bay-area-housing/</og:url>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://blog.google/inside-google/company-announcements/1-billion-investment-bay-area-housing/</dc:identifier>
</item>
<item>
<title>Transforming a Tesla Model 3 into a Pickup Truck</title>
<link>https://www.theverge.com/2019/6/18/18682633/simone-giertz-tesla-model-3-pickup-truck-youtube-diy</link>
<guid isPermaLink="true" >https://www.theverge.com/2019/6/18/18682633/simone-giertz-tesla-model-3-pickup-truck-youtube-diy</guid>
<description>&lt;p id=&quot;bSH6cT&quot;&gt;Simone Giertz was tired of waiting for Elon Musk to unveil his &lt;a href=&quot;https://www.theverge.com/2018/11/2/18055158/elon-musk-tesla-pickup-truck-bladerunner-futuristic&quot;&gt;new Tesla pickup truck&lt;/a&gt;, so she decided to make one herself. The popular YouTuber and self-described &lt;a href=&quot;https://www.theverge.com/2016/5/24/11723234/simone-giertz-queen-of-shitty-robots-interview-youtube&quot;&gt;“queen of shitty robots”&lt;/a&gt; transformed a Model 3 into an honest-to-god pickup truck, which she dubs “Truckla” — and naturally you can watch all the cutting and welding (and cursing) on her YouTube channel. There’s even a &lt;a href=&quot;https://www.youtube.com/watch?feature=youtu.be&amp;amp;v=R35gWBtLCYg&amp;amp;app=desktop&quot;&gt;fake truck commercial&lt;/a&gt; to go along with it.&lt;/p&gt;
&lt;p id=&quot;xolIt0&quot;&gt;Giertz spent over a year planning and designing before launching into the arduous task of turning her Model 3 into a pickup truck. And she recruited a ragtag team of mechanics and DIY car modifiers to tackle the project: &lt;a href=&quot;http://bridgeservicemotors.com&quot;&gt;Marcos Ramirez&lt;/a&gt;, a Bay Area maker, mechanic and artist; Boston-based Richard Benoit, whose YouTube channel &lt;a href=&quot;https://www.youtube.com/channel/UCfV0_wbjG8KJADuZT2ct4SA&quot;&gt;Rich Rebuilds&lt;/a&gt; is largely dedicated to the modification of pre-owned Tesla models; and German designer and YouTuber &lt;a href=&quot;https://www.youtube.com/channel/UCRix1GJvSBNDpEFY561eSzw&quot;&gt;Laura Kampf&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&quot;c-float-right&quot;&gt;
&lt;aside id=&quot;UDG2iC&quot;&gt;&lt;q&gt;The final results are pretty impressive&lt;/q&gt;&lt;/aside&gt;&lt;/div&gt;
&lt;p id=&quot;UtGtEg&quot;&gt;The final results are pretty impressive, and while it probably won’t look anything like the “futuristic-like cyberpunk, &lt;em&gt;Blade Runner&lt;/em&gt; pickup truck” that Musk says he plans to release later this year, it really stands on its own as a dirt-kicking, rugged, all-electric pickup truck that still has that certain Tesla panache.&lt;/p&gt;
&lt;p id=&quot;PR7uWt&quot;&gt;“My goal is to never own a gas car,” Giertz said. “I’m a part of a new generation of drivers that will only drive electric. I feel like I should pad this a little bit, but I’m not going to. Fuck oil companies. Seriously, fuck them.”&lt;/p&gt;
&lt;div id=&quot;7quoQe&quot;&gt;
&lt;section class=&quot;c-image-gallery&quot; data-cid=&quot;apps/image_gallery-1560901195_1521_36732&quot; data-cdata=&quot;{&amp;quot;anthem_component_id&amp;quot;:1114007,&amp;quot;entry_id&amp;quot;:18446674,&amp;quot;routing&amp;quot;:false,&amp;quot;keyboard&amp;quot;:false,&amp;quot;two_col&amp;quot;:false,&amp;quot;display_headline&amp;quot;:false,&amp;quot;expandable&amp;quot;:false}&quot;&gt;&lt;div class=&quot;c-image-gallery__body&quot;&gt;

&lt;div class=&quot;c-image-gallery__viewer&quot; data-ui=&quot;viewer&quot;&gt;
&lt;div class=&quot;c-image-gallery__image&quot; data-ui=&quot;next-image&quot;&gt;&lt;img src=&quot;https://www.theverge.com/2019/6/18/18682633/simone-giertz-tesla-model-3-pickup-truck-youtube-diy&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
 &lt;/div&gt;


&lt;/div&gt;
&lt;/section&gt;&lt;/div&gt;
&lt;p id=&quot;ls24pT&quot;&gt;Musk has been hyping the Tesla pickup truck for several years now, calling it his favorite vehicle in Tesla’s lineup yet and promising it won’t look anything like other trucks on the market. “It’s going to be a truck that is more capable than other trucks,” Musk said in a &lt;a href=&quot;https://teslapodcast.libsyn.com/&quot;&gt;recent podcast interview&lt;/a&gt;. “The goal is to be a better truck than a [Ford] F-150 in terms of truck-like functionality and be a better sports car than a standard [Porsche] 911. That’s the aspiration.”&lt;/p&gt;
&lt;p id=&quot;egWivY&quot;&gt;Giertz’s truck looks exactly like what it is: a Model 3 with the top part of the back half removed. As such, it blurs the line between sedan and pickup, which used to be a popular design style in the 1970s and 80s, until consumers decided that bigger is better. Think &lt;a href=&quot;https://www.carfax.com/Used-Chevrolet-El-Camino_w145&quot;&gt;Chevy El Camino&lt;/a&gt;, or &lt;a href=&quot;https://classics.autotrader.com/classic-cars-for-sale/ford-ranchero-for-sale&quot;&gt;Ford Ranchero&lt;/a&gt;. But Giertz smartly added some standard truck accoutrements, like a lumber rack with Hella lights attached to the front, so that it wouldn’t look out of place among the Rams and Silverados of the world.&lt;/p&gt;
&lt;div class=&quot;c-float-right&quot;&gt;
&lt;aside id=&quot;C5xxW5&quot;&gt;&lt;q&gt;Think Chevy El Camino or Ford Ranchero&lt;/q&gt;&lt;/aside&gt;&lt;/div&gt;
&lt;p id=&quot;sS1PUd&quot;&gt;It wasn’t a project without its obstacles. After stripping the backseat and the trunk of its many parts, the Model 3 refused to start. Ramirez explained that the car was reporting “all of its many faults” to Tesla headquarters via cell connection, or essentially “snitching” on the YouTubers who were trying to modify it. They also ran into problems after cutting through the first beam when the metal started to buckle slightly. Luckily they were able to reinforce the steel and keep going.&lt;/p&gt;
&lt;p id=&quot;4SFUdj&quot;&gt;There have been a bunch of Tesla modifications over the years, and YouTube is brimming with a variety of DIY upgrades big and small. But Giertz’s Tesla pickup truck project certainly ranks among the most ambitious.&lt;/p&gt;
&lt;p id=&quot;OgXtj6&quot;&gt;Giertz, who has 1.6 million subscribers on YouTube, is mostly known for her lineup of incredibly dumb and often hilarious robots that spill milk, brush your teeth, and slap you in the face. With Truckla, she is entering a whole new world of DIY, &lt;em&gt;Pimp My Ride&lt;/em&gt;-style car customization that has its own legion of fans. She is also stepping into a mine field by producing a Tesla pickup truck before the company itself. Musk’s company, and Musk himself, has an army of die-hard followers who have been known to leap to their idol’s defense at the slightest provocation.&lt;/p&gt;
&lt;p id=&quot;115Wu3&quot;&gt;But Giertz makes it clear that she isn’t out to subvert Musk, but celebrate his products. Still, she describes Truckla as either “the smartest or the most stupid thing I’m ever going to do.”&lt;/p&gt;
&lt;p id=&quot;nwnPAs&quot;&gt;“I really hope that people don’t just think of this as an obnoxious YouTuber cutting up a brand new car” Giertz said. “This process has destructive steps but the end goal is constructive. And I’m doing it because I really, really want this car. This is truly my dream car.”&lt;/p&gt;
&lt;div id=&quot;SGYv7E&quot;&gt;
&lt;p&gt;&lt;iframe src=&quot;https://www.youtube.com/embed/jKv_N0IDS2A?rel=0&quot; allowfullscreen=&quot;&quot; scrolling=&quot;no&quot; allow=&quot;autoplay; encrypted-media&quot;&gt;[embedded content]&lt;/iframe&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 18 Jun 2019 15:43:16 +0000</pubDate>
<dc:creator>Tomte</dc:creator>
<og:description>Giertz got tired of waiting for Elon Musk</og:description>
<og:image>https://cdn.vox-cdn.com/thumbor/g5OUUlfYx5TDI6ZfBc6kmVZ78q8=/0x445:5872x3519/fit-in/1200x630/cdn.vox-cdn.com/uploads/chorus_asset/file/16349849/IMG_7645_copy.jpg</og:image>
<og:title>YouTuber Simone Giertz transformed a Tesla Model 3 into a pickup truck</og:title>
<og:type>article</og:type>
<og:url>https://www.theverge.com/2019/6/18/18682633/simone-giertz-tesla-model-3-pickup-truck-youtube-diy</og:url>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.theverge.com/2019/6/18/18682633/simone-giertz-tesla-model-3-pickup-truck-youtube-diy</dc:identifier>
</item>
<item>
<title>Simple techniques to optimise Go programs</title>
<link>https://stephen.sh/posts/quick-go-performance-improvements</link>
<guid isPermaLink="true" >https://stephen.sh/posts/quick-go-performance-improvements</guid>
<description>&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;title&gt;stephen.sh&lt;/title&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;/&gt;&lt;meta description=&quot;Stephen Whitworth's little corner of the internet&quot;/&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/style.css&quot; type=&quot;text/css&quot;/&gt;&lt;/head&gt;&lt;body id=&quot;readabilityBody&quot; readability=&quot;419.53888358779&quot;&gt;
&lt;h3&gt;&lt;a href=&quot;https://stephen.sh/&quot;&gt;Home&lt;/a&gt; &lt;a href=&quot;https://stephen.sh/about&quot;&gt;About&lt;/a&gt; &lt;a href=&quot;https://stephen.sh/posts&quot;&gt;Posts&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I'm very interested in performance. I'm not sure I can explain the underlying reasons for it. I'm easily frustrated at slow services and programs, and it seems like &lt;a href=&quot;http://glinden.blogspot.com/2006/11/marissa-mayer-at-web-20.html&quot;&gt;I'm not alone.&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;em&gt;In A/B tests, we tried delaying the page in increments of 100 milliseconds and found that even very small delays would result in substantial and costly drops in revenue.&lt;/em&gt; - Greg Linden, Amazon.com&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;From my experience, poor performance manifests in one of two ways:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Operations that performed well at small scale, but become unviable as the number of users grows. These are usually O(N) or O(N²) operations. When your user base is small, these perform just fine, and are often done in order to get a product to market. As your use base grows, you see more &lt;a href=&quot;https://theoutline.com/post/4147/in-twitters-early-days-only-one-celebrity-could-tweet-at-a-time?zd=1&amp;amp;zi=ivqvd4py&quot;&gt;pathological examples&lt;/a&gt; that you weren't expecting, and your service grinds to a halt.&lt;/li&gt;
&lt;li&gt;Many individual sources of small optimisation - AKA 'death by a thousand crufts'.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;I've spent most of my career either doing data science with Python, or building services in Go; I have far more experience optimising the latter. Go is usually not the bottleneck in the services I write - programs are often IO bound as they talk to the database. However, in batch machine learning pipelines - like I built in my previous role - your program is often CPU bound. When your Go program is using excessive CPU, and the excessive usage is having a negative impact, there's various strategies you can use to mitigate that.&lt;/p&gt;
&lt;p&gt;This post explains some techniques you can use to significantly improve the performance of your program with little effort. I am deliberately ignoring techniques that require significant effort, or large changes to program structure.&lt;/p&gt;
&lt;h2&gt;Before you start&lt;/h2&gt;
&lt;p&gt;Before you make any changes to your program, invest time in creating a proper baseline to compare against. If you don't do this, you'll be searching around in the dark, wondering if your changes are having any improvement. Write benchmarks first, and grab &lt;a href=&quot;https://blog.golang.org/profiling-go-programs&quot;&gt;profiles&lt;/a&gt; for use in pprof. In the best case, this will be a &lt;a href=&quot;https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go&quot;&gt;Go benchmark&lt;/a&gt;: this allows easy usage of pprof, and memory allocation profiling. You should also use &lt;a href=&quot;https://godoc.org/golang.org/x/tools/cmd/benchcmp&quot;&gt;&lt;code&gt;benchcmp&lt;/code&gt;&lt;/a&gt;: a helpful tool for comparing the difference in performance between two benchmarks.&lt;/p&gt;
&lt;p&gt;If your code is not easily benchmarked, just start with something that you can time. You can profile your code manually using &lt;a href=&quot;https://golang.org/pkg/runtime/pprof/&quot;&gt;&lt;code&gt;runtime/pprof&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Let's get started!&lt;/p&gt;
&lt;h3&gt;Use &lt;code&gt;sync.Pool&lt;/code&gt; to re-use previously allocated objects&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://golang.org/pkg/sync/#Pool&quot;&gt;&lt;code&gt;sync.Pool&lt;/code&gt;&lt;/a&gt; implements a &lt;a href=&quot;https://en.wikipedia.org/wiki/Free_list&quot;&gt;free-list&lt;/a&gt;. This allows you to re-use structures that you've previously allocated. This amortises the allocation of an object over many usages, reducing the work the garbage collector has to do. The API is very simple: implement a function that allocates a new instance of your object. It should return a pointer type.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var bufpool = sync.Pool{
    New: func() interface{} {
        buf := make([]byte, 512)
        return &amp;amp;buf
    }}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;After this, you can &lt;code&gt;Get()&lt;/code&gt; objects from the pool, &lt;code&gt;Put()&lt;/code&gt;ting them back after you are done.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// sync.Pool returns a interface{}: you must cast it to the underlying type
// before you use it.
b := *bufpool.Get().(*[]byte)
defer bufpool.Put(&amp;amp;b)


// Now, go do interesting things with your byte buffer.
buf := bytes.NewBuffer(b)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Some caveats apply. Before Go 1.13, the pool was cleared out every time a garbage collection occured. This might be detrimental to performance in programs that allocate a lot. In 1.13, it &lt;a href=&quot;https://go-review.googlesource.com/c/go/+/162919/&quot;&gt;seems that more objects will survive GC's&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;⚠️&lt;strong&gt;You must zero out the fields of the struct before putting the object back in the pool&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;If you don't do this, you can obtain a 'dirty' object from the pool that contains data from previous use. This can be a severe security risk!&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type AuthenticationResponse {
    Token string
    UserID string
}

rsp := authPool.Get().(*AuthenticationResponse)
defer authPool.Put(rsp)

// If we don't hit this if statement, we might return data from other users! 😱
if blah {
    rsp.UserID = &quot;user-1&quot;
    rsp.Token = &quot;super-secret
}

return rsp
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;The safe way to ensure you always zero memory is to do so explicitly:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// reset resets all fields of the AuthenticationResponse before pooling it.
func (a* AuthenticationResponse) reset() {
    a.Token = &quot;&quot;
    a.UserID = &quot;&quot;
}

rsp := authPool.Get().(*AuthenticationResponse)
defer func() {
    rsp.reset()
    authPool.Put(rsp)
}()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;The only case in which this is not an issue is when you use &lt;em&gt;exactly&lt;/em&gt; the memory that you wrote to. For example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var (
    r io.Reader
    w io.Writer
)

// Obtain a buffer from the pool.
buf := *bufPool.Get().(*[]byte)
defer bufPool.Put(&amp;amp;buf)

// We only write to w exactly what we read from r, and no more. 😌
nr, er := r.Read(buf)
if nr &amp;gt; 0 {
    nw, ew := w.Write(buf[0:nr])
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Edit: a previous version of this blog post did not specify that the &lt;code&gt;New()&lt;/code&gt; function should return a pointer type. This avoids an extra allocation when returning through the &lt;code&gt;interface{}&lt;/code&gt; type. Thanks, &lt;a href=&quot;https://news.ycombinator.com/item?id=20214506&quot;&gt;kevinconaway&lt;/a&gt;!&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;Avoid using structures containing pointers as map keys for large maps&lt;/h3&gt;
&lt;p&gt;Phew - that was quite a mouthful. Sorry about that. Much has been said (a lot by my former colleague, &lt;a href=&quot;https://twitter.com/philpearl&quot;&gt;Phil Pearl&lt;/a&gt;) on Go's performance with &lt;a href=&quot;https://syslog.ravelin.com/further-dangers-of-large-heaps-in-go-7a267b57d487&quot;&gt;large heap sizes&lt;/a&gt;. During a garbage collection, the runtime scans objects containing pointers, and chases them. If you have a very large &lt;code&gt;map[string]int&lt;/code&gt;, the GC has to check every string within the map, every GC, as strings contain pointers.&lt;/p&gt;
&lt;p&gt;In this example, we write 10 million elements to a &lt;code&gt;map[string]int&lt;/code&gt;, and time the garbage collections. We allocate our map at the package scope to ensure it is heap allocated.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;runtime&quot;
    &quot;strconv&quot;
    &quot;time&quot;
)

const (
    numElements = 10000000
)

var foo = map[string]int{}

func timeGC() {
    t := time.Now()
    runtime.GC()
    fmt.Printf(&quot;gc took: %s\n&quot;, time.Since(t))
}

func main() {
    for i := 0; i &amp;lt; numElements; i++ {
        foo[strconv.Itoa(i)] = i
    }

    for {
        timeGC()
        time.Sleep(1 * time.Second)
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Running this program, we see the following:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;🍎 inthash → go install &amp;amp;&amp;amp; inthash
gc took: 98.726321ms
gc took: 105.524633ms
gc took: 102.829451ms
gc took: 102.71908ms
gc took: 103.084104ms
gc took: 104.821989ms
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;That's quite a while in computer land! 😰&lt;/p&gt;
&lt;p&gt;What could we do to improve it? Removing pointers wherever possible seems like a good idea - we'll reduce the number of pointers that the garbage collector has to chase. &lt;a href=&quot;https://www.reddit.com/r/golang/comments/4ologg/why_is_byte_used_as_a_string_type/d4e6gy8/&quot;&gt;Strings contain pointers&lt;/a&gt;; so let's implement this as a &lt;code&gt;map[int]int&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;runtime&quot;
    &quot;time&quot;
)

const (
    numElements = 10000000
)

var foo = map[int]int{}

func timeGC() {
    t := time.Now()
    runtime.GC()
    fmt.Printf(&quot;gc took: %s\n&quot;, time.Since(t))
}

func main() {
    for i := 0; i &amp;lt; numElements; i++ {
        foo[i] = i
    }

    for {
        timeGC()
        time.Sleep(1 * time.Second)
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Running the program again, we get the following:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;🍎 inthash → go install &amp;amp;&amp;amp; inthash
gc took: 3.608993ms
gc took: 3.926913ms
gc took: 3.955706ms
gc took: 4.063795ms
gc took: 3.91519ms
gc took: 3.75226ms
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Much better. We've chopped 97% off garbage collection timings. In a production use case, you'd need to hash the strings to an integer before inserting ino the map.&lt;/p&gt;
&lt;p&gt;ℹ️ There's plenty more you can do to evade the GC. If you allocate giant arrays of pointerless structs, ints or bytes, &lt;a href=&quot;https://medium.com/@rf_14423/did-the-big-allocations-of-ram-contain-pointers-directly-or-indirectly-actual-pointers-strings-76ed28c0bc92&quot;&gt;the GC will not scan it&lt;/a&gt;: meaning you pay no GC overhead. Such techniques usually require substantial re-working of the program, so we won't delve any further into them today.&lt;/p&gt;
&lt;p&gt;⚠️ As with all optimisation, your mileage may vary. See a &lt;a href=&quot;https://twitter.com/dgryski/status/1140685755578118144&quot;&gt;Twitter thread from Damian Gryski&lt;/a&gt; for an interesting example where removing strings from a large map in favour of a smarter data structure actually &lt;em&gt;increased&lt;/em&gt; memory. In general, you should read everything he puts out.&lt;/p&gt;
&lt;h3&gt;Code generate marshalling code to avoid runtime reflection&lt;/h3&gt;
&lt;p&gt;Marshalling and unmarshalling your structure to and from various serialisation formats like JSON is a common operation; especially when building microservices. In fact, you'll often find that the only thing most microservices are actually doing is serialisation. Functions like &lt;code&gt;json.Marshal&lt;/code&gt; and &lt;code&gt;json.Unmarshal&lt;/code&gt; rely on &lt;a href=&quot;https://blog.golang.org/laws-of-reflection&quot;&gt;runtime reflection&lt;/a&gt; to serialise the struct fields to bytes, and vice versa. This can be slow: reflection is not anywhere near as performant as explicit code.&lt;/p&gt;
&lt;p&gt;However, it doesn't have to be this way. The mechanics of marshalling JSON goes a little something like this:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package json

// Marshal take an object and returns its representation in JSON.
func Marshal(obj interface{}) ([]byte, error) {
    // Check if this object knows how to marshal itself to JSON
    // by satisfying the Marshaller interface.
    if m, is := obj.(json.Marshaller); is {
        return m.MarshalJSON()
    }

    // It doesn't know how to marshal itself. Do default reflection based marshallling.
    return marshal(obj)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;If we know how to marshal ourselves to JSON, we have a hook for avoiding runtime reflection. But we don't want to hand write all of our marshalling code, so what do we do? Get computers to write code for us! Code generators like &lt;a href=&quot;https://github.com/mailru/easyjson&quot;&gt;easyjson&lt;/a&gt; look at a struct, and generate highly optimised code which is fully compatible with existing marshalling interfaces like &lt;code&gt;json.Marshaller&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Download the package, and run the following on your &lt;code&gt;$file.go&lt;/code&gt; containing the structs you would like to generate code for.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;easyjson -all $file.go
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;You should find a &lt;code&gt;$file_easyjson.go&lt;/code&gt; file has been generated. As &lt;code&gt;easyjson&lt;/code&gt; has implemented the &lt;code&gt;json.Marshaller&lt;/code&gt; interface for you, these functions will be called instead of the reflection based default. Congratulations: you just sped up your JSON marshalling code by 3x. There's lots of things that you can twiddle to increase the performance even more.&lt;/p&gt;
&lt;p&gt;ℹ️I recommend the package because I have used it before to good effect. Caveat emptor. Please do not take this as an invitation to start aggressive discussions about the fastest JSON marshalling packages on the market with me.&lt;/p&gt;
&lt;p&gt;⚠️ You'll need to make sure to re-generate the marshalling code when you change the struct. If you forget, new fields that you add won't be serialised and de-serialised, which can be confusing! You can use &lt;code&gt;go generate&lt;/code&gt; to handle this code generation for you. In order to keep these in sync with structures, I like to have a &lt;code&gt;generate.go&lt;/code&gt; in the root of the package that calls &lt;code&gt;go generate&lt;/code&gt; for all files in the package: this can aid maintenance when you have many files that need generating. Top tip: call &lt;code&gt;go generate&lt;/code&gt; in CI and check it has no diffs with the checked in code to ensure that structures are up to date.&lt;/p&gt;
&lt;h3&gt;Use &lt;code&gt;strings.Builder&lt;/code&gt; to build up strings&lt;/h3&gt;
&lt;p&gt;In Go, strings are immutable: think of them as a read only slice of bytes. This means that every time you create a string, you're allocating new memory, and potentially creating more work for the garbage collector.&lt;/p&gt;
&lt;p&gt;In Go 1.10, &lt;a href=&quot;https://golang.org/pkg/strings/#Builder&quot;&gt;&lt;code&gt;strings.Builder&lt;/code&gt;&lt;/a&gt; was introduced as an efficient way to build up strings. Internally, it writes to a byte buffer. Only upon calling &lt;code&gt;String()&lt;/code&gt; on the builder, is the string actually created. It relies on some &lt;code&gt;unsafe&lt;/code&gt; trickery to return the underlying bytes as a string with zero allocations: see &lt;a href=&quot;https://syslog.ravelin.com/byte-vs-string-in-go-d645b67ca7ff&quot;&gt;this blog&lt;/a&gt; for a further look into how it works.&lt;/p&gt;
&lt;p&gt;Let's do a performance comparison to verify the two approaches:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// main.go
package main

import &quot;strings&quot;

var strs = []string{
    &quot;here's&quot;,
    &quot;a&quot;,
    &quot;some&quot;,
    &quot;long&quot;,
    &quot;list&quot;,
    &quot;of&quot;,
    &quot;strings&quot;,
    &quot;for&quot;,
    &quot;you&quot;,
}

func buildStrNaive() string {
    var s string

    for _, v := range strs {
        s += v
    }

    return s
}

func buildStrBuilder() string {
    b := strings.Builder{}

    // Grow the buffer to a decent length, so we don't have to continually
    // re-allocate.
    b.Grow(60)

    for _, v := range strs {
        b.WriteString(v)
    }

    return b.String()
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;// main_test.go
package main

import (
    &quot;testing&quot;
)

var str string

func BenchmarkStringBuildNaive(b *testing.B) {
    for i := 0; i &amp;lt; b.N; i++ {
        str = buildStrNaive()
    }
}
func BenchmarkStringBuildBuilder(b *testing.B) {
    for i := 0; i &amp;lt; b.N; i++ {
        str = buildStrBuilder()
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;I get the following results on my Macbook Pro:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;🍎 strbuild → go test -bench=. -benchmem
goos: darwin
goarch: amd64
pkg: github.com/sjwhitworth/perfblog/strbuild
BenchmarkStringBuildNaive-8          5000000           255 ns/op         216 B/op          8 allocs/op
BenchmarkStringBuildBuilder-8       20000000            54.9 ns/op        64 B/op          1 allocs/op
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;As we can see, &lt;code&gt;strings.Builder&lt;/code&gt; is 4.7x faster, results in 1/8th of the number of allocations, and 1/4 of the memory allocated.&lt;/p&gt;
&lt;p&gt;Where performance matters, use &lt;code&gt;strings.Builder&lt;/code&gt;. In general, I recommend using it for all but the most trivial cases of building strings.&lt;/p&gt;
&lt;h3&gt;Use strconv instead of fmt&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://golang.org/pkg/fmt/&quot;&gt;&lt;code&gt;fmt&lt;/code&gt;&lt;/a&gt; is one of the most well known packages in Go. You'll have probably used it in your first Go program to print &quot;hello, world&quot; to the screen. However, when it comes to converting integers and floats in to strings, it's not as performant as its lower level cousin: &lt;a href=&quot;https://golang.org/pkg/strconv/&quot;&gt;&lt;code&gt;strconv&lt;/code&gt;&lt;/a&gt;. This package gives you a decent whack more performance, for some very small changes in API.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fmt&lt;/code&gt; mostly takes &lt;code&gt;interface{}&lt;/code&gt; as arguments to functions. This has two downsides:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;You lose type safety. This is a big one, for me.&lt;/li&gt;
&lt;li&gt;It can increase the number of allocations needed. Passing a non-pointer type as an &lt;code&gt;interface{}&lt;/code&gt; usually causes heap allocations. Read into &lt;a href=&quot;https://www.darkcoding.net/software/go-the-price-of-interface/&quot;&gt;this blog&lt;/a&gt; to figure out why that is.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;The below program shows the difference in performance:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// main.go
package main

import (
    &quot;fmt&quot;
    &quot;strconv&quot;
)

func strconvFmt(a string, b int) string {
    return a + &quot;:&quot; + strconv.Itoa(b)
}

func fmtFmt(a string, b int) string {
    return fmt.Sprintf(&quot;%s:%d&quot;, a, b)
}

func main() {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;// main_test.go
package main

import (
    &quot;testing&quot;
)

var (
    a    = &quot;boo&quot;
    blah = 42
    box  = &quot;&quot;
)

func BenchmarkStrconv(b *testing.B) {
    for i := 0; i &amp;lt; b.N; i++ {
        box = strconvFmt(a, blah)
    }
    a = box
}

func BenchmarkFmt(b *testing.B) {
    for i := 0; i &amp;lt; b.N; i++ {
        box = fmtFmt(a, blah)
    }
    a = box
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;The benchmark results on a Macbook Pro:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;🍎 strfmt → go test -bench=. -benchmem
goos: darwin
goarch: amd64
pkg: github.com/sjwhitworth/perfblog/strfmt
BenchmarkStrconv-8      30000000            39.5 ns/op        32 B/op          1 allocs/op
BenchmarkFmt-8          10000000           143 ns/op          72 B/op          3 allocs/op
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;We can see that the &lt;code&gt;strconv&lt;/code&gt; version is 3.5x faster, results in 1/3rd the number of allocations, and half the memory allocated.&lt;/p&gt;
&lt;h3&gt;Allocate capacity in make to avoid re-allocation&lt;/h3&gt;
&lt;p&gt;Before we get to performance improvements, let's take a quick refresher on slices. The slice is a very useful construct in Go. It provides a re-sizable array, with the ability to take different views on the same underlying memory without re-allocation. If you peek under the hood, the slice is made up of three elements:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type slice struct {
    // pointer to underlying data in the slice.
    data uintptr
    // the number of elements in the slice.
    len int
    // the number of elements that the slice can 
    // grow to before a new underlying array
    // is allocated.
    cap int     
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;What are these fields?&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;data&lt;/code&gt;: pointer to underlying data in the slice&lt;/li&gt;
&lt;li&gt;&lt;code&gt;len&lt;/code&gt;: the current number of elements in the slice.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cap&lt;/code&gt;: the number of elements that the slice can grow to before re-allocation.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Under the hood, slices are fixed length arrays. When you reach the &lt;code&gt;cap&lt;/code&gt; of a slice, a new array with double the cap of the previous slice is allocated, the memory is copied over from the old slice to the new one, and the old array is discarded&lt;/p&gt;
&lt;p&gt;I often see code like the following that allocates a slice with zero capacity, when the capacity of the slice is known upfront.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var userIDs []string
for _, bar := range rsp.Users {
    userIDs = append(userIDs, bar.ID)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;In this case, the slice starts off with zero length, and zero capacity. After receiving the response, we append the users to the slice. As we do so, we hit the capacity of the slice: a new underlying array is allocated that is double the capacity of the previous slice, and the data from the slice is copied into it. If we had 8 users in the response, this would result in 5 allocations.&lt;/p&gt;
&lt;p&gt;A far more efficient way is to change it to the following:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;userIDs := make([]string, 0, len(rsp.Users)

for _, bar := range rsp.Users {
    userIDs = append(userIDs, bar.ID)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;We have explicitly allocated the capacity to the slice by using make. Now, we can append to the slice, knowing that we won't trigger additional allocations and copys.&lt;/p&gt;
&lt;p&gt;If you don't know how much you should allocate because the capacity is dynamic or calculated later in the program, measure the distribution of the size of the slice that you end up with whilst the program is running. I usually take the 90th or 99th percentile, and hardcode the value in the progam. In cases where you have RAM to trade off for CPU, set this value to higher than you think you'll need.&lt;/p&gt;
&lt;p&gt;This advice is also applicable to maps: using &lt;code&gt;make(map[string]string, len(foo))&lt;/code&gt; will allocate enough capacity under the hood to avoid re-allocation.&lt;/p&gt;
&lt;p&gt;ℹ️ See &lt;a href=&quot;https://blog.golang.org/go-slices-usage-and-internals&quot;&gt;Go Slices: usage and internals&lt;/a&gt; for more information about how slices work under the hood.&lt;/p&gt;
&lt;h3&gt;Use methods that allow you to pass byte slices&lt;/h3&gt;
&lt;p&gt;When using packages, look to use methods that allow you to pass a byte slice: these methods usually give you more control over allocation.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://golang.org/pkg/time/#Time.Format&quot;&gt;&lt;code&gt;time.Format&lt;/code&gt;&lt;/a&gt; vs. &lt;a href=&quot;https://golang.org/pkg/time/#Time.AppendFormat&quot;&gt;&lt;code&gt;time.AppendFormat&lt;/code&gt;&lt;/a&gt; is a good example. &lt;code&gt;time.Format&lt;/code&gt; returns a string. Under the hood, this allocates a new byte slice and calls &lt;code&gt;time.AppendFormat&lt;/code&gt; on it. &lt;code&gt;time.AppendFormat&lt;/code&gt; takes a byte buffer, writes the formatted representation of the time, and returns the extended byte slice. This is common in other packages in the standard library: see &lt;code&gt;strconv.AppendFloat&lt;/code&gt;(link), or &lt;code&gt;bytes.NewBuffer&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Why does this give you increased performance? Well, you can now pass byte slices that you've obtained from your &lt;code&gt;sync.Pool&lt;/code&gt;, instead of allocating a new buffer every time. Or you can increase the initial buffer size to a value that you know is more suited to your program, to reduce slice re-copying.&lt;/p&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;After reading this post, you should be able to take these techniques and apply them to your code base. Over time, you will build a mental model for reasoning about performance in Go programs. This can aid upfront design greatly.&lt;/p&gt;
&lt;p&gt;To close, a word of caution. Take my guidance as situationally-dependent advice, not gospel. Benchmark and measure.&lt;/p&gt;
&lt;p&gt;Know when to stop. Improving performance of a system is a feel-good exercise for an engineer: the problem is interesting, and the results are immediately visible. However, the usefulness of performance improvements is very dependent on the situation. If your service takes 10ms to respond, and 90ms round trip on the network, it doesn't seem worth it to try and halve that 10ms to 5ms: you'll still take 95ms. If you manage to optimise it to within an inch of it's life so it takes 1ms to respond, you're still only at 91ms. There are probably bigger fish to fry.&lt;/p&gt;
&lt;p&gt;Optimise wisely!&lt;/p&gt;
&lt;h3&gt;References&lt;/h3&gt;
&lt;p&gt;I've linked heavily throughout the blog. If you're interested in further reading, the following are great sources of inspiration:&lt;/p&gt;
&lt;/body&gt;</description>
<pubDate>Tue, 18 Jun 2019 15:10:09 +0000</pubDate>
<dc:creator>sjwhitworth</dc:creator>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://stephen.sh/posts/quick-go-performance-improvements</dc:identifier>
</item>
<item>
<title>Google Calendar Is Down</title>
<link>https://calendar.google.com/</link>
<guid isPermaLink="true" >https://calendar.google.com/</guid>
<description>&lt;div class=&quot;main content clearfix&quot; readability=&quot;5.578125&quot;&gt;
&lt;p&gt;

&lt;h2 class=&quot;hidden-small&quot;&gt;Sign in to continue to Google Calendar&lt;/h2&gt;
&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;google-footer-bar&quot;&gt;
&lt;div class=&quot;footer content clearfix&quot;&gt;
&lt;div id=&quot;lang-vis-control&quot;&gt;&lt;span id=&quot;lang-chooser-wrap&quot; class=&quot;lang-chooser-wrap&quot;&gt;&lt;label for=&quot;lang-chooser&quot;&gt;&lt;img src=&quot;https://ssl.gstatic.com/images/icons/ui/common/universal_language_settings-21.png&quot; alt=&quot;Change language&quot;/&gt;&lt;/label&gt; &lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 18 Jun 2019 14:07:17 +0000</pubDate>
<dc:creator>dnlserrano</dc:creator>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://accounts.google.com/ServiceLogin?service=cl&amp;passive=1209600&amp;osid=1&amp;continue=https://calendar.google.com/calendar/render&amp;followup=https://calendar.google.com/calendar/render&amp;scc=1</dc:identifier>
</item>
<item>
<title>The worst morale-boosting gesture I&amp;#039;ve experienced</title>
<link>https://shkspr.mobi/blog/2019/06/the-worst-morale-boosting-gesture-ive-experienced/</link>
<guid isPermaLink="true" >https://shkspr.mobi/blog/2019/06/the-worst-morale-boosting-gesture-ive-experienced/</guid>
<description>&lt;p&gt;I promise you this story is true.&lt;/p&gt;
&lt;p&gt;Many years ago, when I was very young and you were even younger...&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;Work was not going well. Our recently launched product was a flop. Rumours of job cuts were swirling. Things were tense.&lt;/p&gt;
&lt;p&gt;I was sat in work, headphones on, trying to drown out the sound of the open-plan office. Grinding through emails. When suddenly someone tapped me on the shoulder.&lt;/p&gt;
&lt;p&gt;&quot;Excuse me,&quot; the vaguely familiar woman said, &quot;do you work for &lt;em&gt;Vodafone?&lt;/em&gt;&quot;&lt;/p&gt;
&lt;p&gt;I was wearing a Voda lanyard, typing into a Voda laptop, with great big Voda posters around me. Because we were both in Vodafone's London office.&lt;/p&gt;
&lt;p&gt;&quot;Errr.... Yes? Why?&quot; It wasn't uncommon for angry customers to make their way to the office, sneak past security, and loudly grumble at marketing managers about their billing problems.&lt;/p&gt;
&lt;p&gt;&quot;You're &lt;em&gt;brilliant!&lt;/em&gt;&quot; she gushed, &quot;Wow! Everything you do is great! Your customers love you!&quot;&lt;/p&gt;
&lt;p&gt;I looked around the office, there were several strangers heaping out effusive praise. I rang building security - because I literally thought it was some kind of weird prank / invasion.&lt;/p&gt;
&lt;p&gt;&quot;Ah yes,&quot; said the security guard, &quot;you're not the first person to call...&quot;&lt;/p&gt;
&lt;p&gt;I looked up. The half dozen strangers had formed a line and started doing a little song-and-dance about how lucky we were to work for Vodafone, and how our jobs improved people's lives every day.&lt;/p&gt;
&lt;p&gt;Work had paid for &lt;strong&gt;actors&lt;/strong&gt; to come in and, literally, sing our praises.&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;I'd love to know the thought process behind this &quot;initiative.&quot;&lt;/p&gt;
&lt;p&gt;If it had been actually senior managers emerging from their offices to walk the open-plan spaces - that would have been pretty nice. Sure, it might have been slightly hollow, but having the CxO stop by for a little chat and word of encouragement is a hell of a lot less synthetic than paying people to pretend that you're doing well.&lt;/p&gt;
&lt;p&gt;I don't know how much it cost (thanks shareholders!) - but I'd much rather have the cash. Or a book token. Or a free lunch. Or anything material. It's hard to fake a sandwich.&lt;/p&gt;
&lt;p&gt;So, what's the most misplaced gesture of support you've received from your employer?&lt;/p&gt;
</description>
<pubDate>Tue, 18 Jun 2019 13:56:53 +0000</pubDate>
<dc:creator>augusto2112</dc:creator>
<og:type>article</og:type>
<og:title>The worst morale boosting gesture I've experienced</og:title>
<og:url>https://shkspr.mobi/blog/2019/06/the-worst-morale-boosting-gesture-ive-experienced/</og:url>
<og:description>I promise you this story is true. Many years ago, when I was very young and you were even younger… Work was not going well. Our recently launched product was a flop. Rumours of job cuts were …</og:description>
<og:image>https://shkspr.mobi/blog/wp-content/uploads/2018/03/Pristine-Vodafone-Logo.png</og:image>
<dc:language>en-GB</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://shkspr.mobi/blog/2019/06/the-worst-morale-boosting-gesture-ive-experienced/</dc:identifier>
</item>
<item>
<title>Facebook Cryptocurrency Plan Faces Opposition in France</title>
<link>https://www.bloomberg.com/news/articles/2019-06-18/france-calls-for-central-bank-review-of-facebook-cryptocurrency</link>
<guid isPermaLink="true" >https://www.bloomberg.com/news/articles/2019-06-18/france-calls-for-central-bank-review-of-facebook-cryptocurrency</guid>
<description>[unable to retrieve full-text content]
&lt;p&gt;Article URL: &lt;a href=&quot;https://www.bloomberg.com/news/articles/2019-06-18/france-calls-for-central-bank-review-of-facebook-cryptocurrency&quot;&gt;https://www.bloomberg.com/news/articles/2019-06-18/france-calls-for-central-bank-review-of-facebook-cryptocurrency&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Comments URL: &lt;a href=&quot;https://news.ycombinator.com/item?id=20212453&quot;&gt;https://news.ycombinator.com/item?id=20212453&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Points: 288&lt;/p&gt;
&lt;p&gt;# Comments: 118&lt;/p&gt;
</description>
<pubDate>Tue, 18 Jun 2019 12:58:40 +0000</pubDate>
<dc:creator>velcro</dc:creator>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.bloomberg.com/tosv2.html?vid=&amp;uuid=cb086760-922d-11e9-886e-1b21a4f6f987&amp;url=L25ld3MvYXJ0aWNsZXMvMjAxOS0wNi0xOC9mcmFuY2UtY2FsbHMtZm9yLWNlbnRyYWwtYmFuay1yZXZpZXctb2YtZmFjZWJvb2stY3J5cHRvY3VycmVuY3k=</dc:identifier>
</item>
<item>
<title>Two potentially life-friendly planets found orbiting a nearby star</title>
<link>https://www.nationalgeographic.com/science/2019/06/two-potentially-life-friendly-planets-found-12-light-years-away-teegardens-star/</link>
<guid isPermaLink="true" >https://www.nationalgeographic.com/science/2019/06/two-potentially-life-friendly-planets-found-12-light-years-away-teegardens-star/</guid>
<description>&lt;span itemprop=&quot;articleBody&quot; class=&quot;clearfix&quot;&gt;A tiny, old &lt;a href=&quot;https://www.nationalgeographic.com/science/space/universe/stars/&quot;&gt;star&lt;/a&gt; just 12 light-years away might host two temperate, rocky planets, astronomers announced today. If they’re confirmed, both of the newly spotted worlds are nearly identical to &lt;a href=&quot;https://www.nationalgeographic.com/science/space/solar-system/earth/&quot;&gt;Earth&lt;/a&gt; in mass, and both planets are in orbits that could allow liquid water to trickle and puddle on their surfaces.&lt;/span&gt;&lt;span itemprop=&quot;articleBody&quot; class=&quot;clearfix&quot;&gt;Scientists estimate that the stellar host, known as &lt;a href=&quot;https://www.nasa.gov/centers/goddard/news/topstory/2003/0520newstar.html&quot;&gt;Teegarden’s star&lt;/a&gt;, is at least eight billion years old, or nearly twice the sun’s age. That means any planets orbiting it are presumably as ancient, so life as we know it has had more than enough time to evolve. And for now, the star is remarkably quiet, with few indications of the tumultuous stellar quakes and flares that tend to erupt from such objects.&lt;/span&gt;&lt;span itemprop=&quot;articleBody&quot; class=&quot;clearfix&quot;/&gt;&lt;span itemprop=&quot;articleBody&quot; class=&quot;clearfix&quot;&gt;&lt;span itemprop=&quot;headline&quot; class=&quot;media__caption--title&quot;&gt;Exoplanets 101&lt;/span&gt; &lt;span itemprop=&quot;description&quot;&gt;Exoplanets challenge the notion that we are alone in the universe. Learn what types of exoplanets exist, the methods scientists employ to find them, and how many worlds might exist in the Milky Way Galaxy.&lt;/span&gt;&lt;br/&gt;&lt;small class=&quot;media__caption--credit&quot;&gt;&lt;span&gt;Producer / Narrator: Angeli Gabriel&lt;br/&gt;Editor: Dan Steinmetz&lt;br/&gt;Associate Producer: Marielena Planas&lt;br/&gt;Research Manager: Mark Levenstein&lt;br/&gt;Sound Recordist: Jay Olszewski&lt;/span&gt;&lt;/small&gt;&lt;/span&gt;</description>
<pubDate>Tue, 18 Jun 2019 12:46:12 +0000</pubDate>
<dc:creator>TuringTest</dc:creator>
<og:title>Two potentially life-friendly planets found orbiting a nearby star</og:title>
<og:description>“We will eventually see if they are actually habitable and, perhaps, even inhabited,” astronomers predict.</og:description>
<og:url>https://www.nationalgeographic.com/science/2019/06/two-potentially-life-friendly-planets-found-12-light-years-away-teegardens-star/</og:url>
<og:type>article</og:type>
<og:image>https://www.nationalgeographic.com/content/dam/science/2019/06/18/exoplanet_teegardensstar-/og_01_teegardensstar_96238main_red_dwarfjpg-copy.ngsversion.1560853800838.adapt.1900.1.jpg</og:image>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.nationalgeographic.com/science/2019/06/two-potentially-life-friendly-planets-found-12-light-years-away-teegardens-star/</dc:identifier>
</item>
</channel>
</rss>