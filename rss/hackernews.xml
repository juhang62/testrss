<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=hnrss.org%2Fnewest%3Fpoints%3D200&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://hnrss.org/newest?points=200" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dhnrss.org%252Fnewest%253Fpoints%253D200%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dhnrss.org%252Fnewest%253Fpoints%253D200%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>Hacker News: Newest</title>
<link>https://news.ycombinator.com/newest</link>
<description>Hacker News RSS</description>
<item>
<title>Unable to deal with Chrome Extension Team, Kozmos is shutting down</title>
<link>https://kodfabrik.com/journal/why-am-i-shutting-down-kozmos</link>
<guid isPermaLink="true" >https://kodfabrik.com/journal/why-am-i-shutting-down-kozmos</guid>
<description>&lt;p&gt;In this post, I'll tell the story behind why I'm shutting down &lt;a href=&quot;https://getkozmos.com&quot;&gt;Kozmos&lt;/a&gt;, a project that I built with love, and a source of monthly passive income.&lt;/p&gt;
&lt;p&gt;P.S: This will be also the story of how Google's Chrome Extensions team can continuously troll developers with take down notices based on false evaluations, and finally take down extensions anyways even if they don't violate any policies with no notice at all.&lt;/p&gt;
&lt;h2&gt;Building Kozmos&lt;/h2&gt;
&lt;p&gt;Back in 2017, I built Kozmos as a result of an experimental web browser project, &lt;a href=&quot;https://github.com/kaktus/kaktus&quot;&gt;Kaktüs&lt;/a&gt;. My goal was not just to build another bookmarking service, it was to make web browsing better by creating an alternative interface in the new tab screen.&lt;/p&gt;
&lt;p&gt;There is two posts about this goal in this blog, feel free to check them out if you're interested;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TLDR;&lt;/strong&gt; Kozmos is a service that provides you a new tab extension that works completely offline, stores all your information in your web browser, and finally syncs them up with Kozmos' servers, so you can access them anywhere.&lt;/p&gt;
&lt;h2&gt;The Chrome Extension&lt;/h2&gt;
&lt;p&gt;Kozmos' Chrome extension only requires access to browser's tabbing API and also Kozmos' own website. It does not inject anything to other websites. It periodically syncs your bookmarks with its servers, without exchanging any other data. Furthermore, the &lt;a href=&quot;https://github.com/kozmos/browser-extensions&quot;&gt;whole extension is open source&lt;/a&gt;, including the library that &lt;a href=&quot;https://github.com/kozmos/likedb&quot;&gt;syncs up your bookmarks to Kozmos&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Besides of this, people who install Kozmos are the people who pay for it. So, it's not spyware. I never sold the data. I wanted to get some funding to grow it into the project I was actually dreaming about, however, got a lot of rejections from investors, and some offers weren't acceptable for me.&lt;/p&gt;
&lt;p&gt;Anyhow, besides of the small group of users and myself, my wife also uses Kozmos since the beginning. The way Kozmos automatically categorizes and displays bookmarks was actually useful for her during pregnancy. Although it never took off, which I understand and accept, I was always satisfied with it as it is. Letting it run wasn't costing me any time but providing value as a tool, in addition to some passive income. I thought it'd just keep going without interruptions, it was too wishful for the real world though.&lt;/p&gt;
&lt;h2&gt;The Nightmare&lt;/h2&gt;
&lt;p&gt;Google's Chrome Extension team has been giving me a complete nightmare since last two years. They kept sending me robotic take-down notices although the extension was not violating any policies. I was able to deal with all these robotic take down notices by copy pasting my answers until a human being from Chrome extension team could see my answers, and realize that there was nothing wrong with Kozmos' extension.&lt;/p&gt;
&lt;p&gt;Every single e-mail thread started by a take down notice would go like this;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Google (Bot): We'll take your extension down&lt;/li&gt;
&lt;li&gt;Me: Hey, this must be a mistake&lt;/li&gt;
&lt;li&gt;Google (Bot): No mistake, review these policies, your extension violates one of them&lt;/li&gt;
&lt;li&gt;Me: It does not violate any of them, this is a mistake!&lt;/li&gt;
&lt;li&gt;Google (Finally human): Oh, sorry, a mistake.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Imagine having the same conversation, and starting it over and over from scratch every a few weeks. Robots can afford it, as they are good at repeating, but it was quite stressful for me as I had to deal with it besides of a full time job, being a father of a toddler. These e-mails became quite exhausting for me, and there was no way to stop them.&lt;/p&gt;
&lt;h2&gt;The Final Touch&lt;/h2&gt;
&lt;p&gt;Finally, Google took Kozmos' Chrome Extension down a few months ago. This time, there was no notice e-mail at all. It was taken down, and there was no clear reason behind it, no notice, nothing. Google, a company that violates privacy of millions of people, took my hard work down without any explanation.&lt;/p&gt;
&lt;p&gt;And when they did this, they could have accessed the e-mail threads of their team admitting that Kozmos' extension did not violate any policy but their bots actually made poor conclusions.&lt;/p&gt;
&lt;p&gt;Obviously, Google doesn't care about the policies they wrote. They want to take down, they can take down.&lt;/p&gt;
&lt;p&gt;And as a developer who actually worked hard to build software that respects people's privacy, there is no way to request Google to correct the mistake they made. You can't access any sort of contact information, you can't ask help, there is no support system, even though every developer is charged 5$ initial fee for publishing extensions.&lt;/p&gt;
&lt;h2&gt;Moving On&lt;/h2&gt;
&lt;p&gt;Either I re-submit the extension to the market, deal with all these bullying executed by Google's idiotic algorithms until one day they take it down without any notice again, or, simply I just shut Kozmos down, as I don't have the resources to keep up with Google's Chrome Marketplace bots.&lt;/p&gt;
&lt;p&gt;Thus, the project I built alone by programming the every single line of it, the project I organized community events for and made tens of embarrassing pitches about, the project I spent days shooting and editing videos to promote it will be completely gone.&lt;/p&gt;
&lt;p&gt;Customers have got refunds since February, while the site is operating in fremium mode for them until the shutdown. Once the few users left download their backups and move to the next service, the site will be shutdown completely.&lt;/p&gt;
&lt;p&gt;What's left for me is still more than enough anyways; all the learnings, the experience and of course, all the people I met thanks to making this project.&lt;/p&gt;
&lt;p&gt;Finally. Here is a video I shot to promote Kozmos 3 years ago.&lt;/p&gt;
&lt;iframe width=&quot;800&quot; height=&quot;400&quot; src=&quot;https://www.youtube.com/embed/BwMKHh6IXiU&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;[embedded content]&lt;/iframe&gt;
&lt;p&gt;Thanks for reading.&lt;/p&gt;
</description>
<pubDate>Sat, 23 May 2020 19:00:37 +0000</pubDate>
<dc:creator>roadbeats</dc:creator>
<og:title>Why am I shutting down Kozmos? - Azer Koçulu's Journal</og:title>
<og:type>article</og:type>
<og:url>https://kodfabrik.com/journal/why-am-i-shutting-down-kozmos</og:url>
<og:description></og:description>
<og:image>https://cldup.com/_wdrPegjtl.png</og:image>
<dc:format>text/html</dc:format>
<dc:identifier>https://kodfabrik.com/journal/why-am-i-shutting-down-kozmos/</dc:identifier>
</item>
<item>
<title>Jepsen Disputes MongoDB&amp;#039;s Data Consistency Claims</title>
<link>https://www.infoq.com/news/2020/05/Jepsen-MongoDB-4-2-6/</link>
<guid isPermaLink="true" >https://www.infoq.com/news/2020/05/Jepsen-MongoDB-4-2-6/</guid>
<description>&lt;p&gt;In an article titled &lt;a href=&quot;https://www.mongodb.com/jepsen&quot;&gt;MongoDB and Jepsen&lt;/a&gt;, MongoDB claimed that their database passed “the industry’s toughest data safety, correctness, and consistency Tests”. In response, Jepsen published an article stating that MongoDB 3.6.4 had in fact failed their tests; the newer &lt;a href=&quot;http://jepsen.io/analyses/mongodb-4.2.6&quot;&gt;MongoDB 4.2.6 has more problems&lt;/a&gt; including “retrocausal transactions” where a transaction reverses order so that a read can see the result of a future write.&lt;/p&gt;
&lt;p&gt;Jepsen LLC’s response begins with this &lt;a href=&quot;https://twitter.com/MBeugnet/status/1253622755049734150&quot;&gt;reply to Maxime Beugnet&lt;/a&gt; on their official Twitter feed:&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;I have to admit raising an eyebrow when I saw that web page. In that report, MongoDB lost data and violated causal by default. Somehow that became &quot;among the strongest data consistency, correctness, and safety guarantees of any database available today&quot;!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The report in question was titled &lt;a href=&quot;http://jepsen.io/analyses/mongodb-3-6-4&quot;&gt;MongoDB 3.6.4&lt;/a&gt; by Kit Patella. The new report, by Kyle Kingsbury, expands on this:&lt;/p&gt;
&lt;blockquote readability=&quot;19&quot;&gt;
&lt;p&gt;Similarly, MongoDB’s default level of read concern allows aborted reads: readers can observe state that is not fully committed, and could be discarded in the future. As the read isolation consistency docs note, “Read uncommitted is the default isolation level”.&lt;/p&gt;
&lt;p&gt;We found that due to these weak defaults, MongoDB’s causal sessions did not preserve causal consistency by default: users needed to specify both write and read concern majority (or higher) to actually get causal consistency. MongoDB closed the issue, saying it was working as designed, and updated their isolation documentation to note that even though MongoDB offers “causal consistency in client sessions”, that guarantee does not hold unless users take care to use both read and write concern majority. A detailed table now shows the properties offered by weaker read and write concerns.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Transaction Isolation Failures&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In recent years MongoDB has been heavily promoting its transactional capabilities. But as Jepsen found, transactional support doesn’t work by default. In one test, transactions were used to append values to a document. They found that even with write concern majority at the database/collection level, “transactions appeared to lose acknowledged writes” when using the default write concern at the transactional level. (This can be addressed by explicitly specifying a write concern at the transaction level.)&lt;/p&gt;
&lt;blockquote readability=&quot;19.735682819383&quot;&gt;
&lt;p&gt;Clients observed a monotonically growing list of elements until [1 2 3 4 5 6 7], at which point the list reset to [], and started afresh with [8]. This could be an example of MongoDB &lt;a href=&quot;https://docs.mongodb.com/manual/core/replica-set-rollbacks/&quot;&gt;rollbacks&lt;/a&gt;, which is a fancy way of saying “data loss”.&lt;/p&gt;
&lt;p&gt;This is bad, but a more subtle question arises: why were we able to read these values at all? After all, read concern linearizable is supposed to show only majority-acknowledged (i.e. durable) writes. The answer is a surprising—but documented—MongoDB design choice:&lt;/p&gt;
&lt;p&gt;Operations in a transaction use the transaction-level read concern. That is, any read concern set at the collection and database level is ignored inside the transaction.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Effectively this means “transactions without an explicit read concern downgrade any requested read concern at the database or collection level to a default level of local”, allowing the transaction to read uncommitted data which may be later rolled back.&lt;/p&gt;
&lt;p&gt;The inverse is also problematic. According to the documentation, “If the transaction does not use write concern “majority” for the commit, the &quot;snapshot&quot; read concern provides no guarantee that read operations used a snapshot of majority-committed data.”. In other words, the read concern “snapshot” is effectively ignored without setting the write-concern. And again, this must be done at the transaction level because transactions ignore the collection and database level settings.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Retrocausal Transactions&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Even with snapshot isolation, there were numerous scenarios with unexpected results. Most of them are too complex to summarize here, but one of them really stood out.&lt;/p&gt;
&lt;p&gt;In one test, Jepsen researchers told the client to read a document and then append a value to it. At the start of the test, the document contained the sequence [2, 3, 4]. After reading the value, the document was altered to be [1, 2, 3, 4].&lt;/p&gt;
&lt;p&gt;This usually worked, but in four transactions the client read [1, 2, 3, 4] from the database. Kingsbury continues,&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;This is, of course, impossible: our test submits each transaction’s operations in strict order, and unless MongoDB has built a time machine, it cannot return values which it doesn’t yet know will be written. This suggests that the retrocausal transaction actually ran twice, and on its second run, observed an effect of its own prior execution. This could be another consequence of an inappropriate retry mechanism.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This isn’t the only time the retry mechanism has been blamed.&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;We found that network partitions could cause MongoDB to duplicate the effects of transactions. Despite never appending the same value to an array twice, we repeatedly observed arrays with multiple copies of the same element.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In an attempt to understand these behaviors better, researchers attempted to disable automatic retries only to discover that “MongoDB transactions ignore the retryWrites setting, and retry regardless”.&lt;/p&gt;
&lt;p&gt;In addition to offering advice to developers on how to more safely use MongoDB, Jepsen recommends that “MongoDB may wish to revise their marketing language to use ‘snapshot isolated’ instead of ‘ACID’”.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Editors Note:&lt;/strong&gt; A previous version of this article implied that that data loss could always occur when using transactions. This specific problem only occured when using the default write concern for transactions. However, other anomalies were detected with transactions using write concern majority.&lt;/p&gt;
</description>
<pubDate>Sat, 23 May 2020 18:33:05 +0000</pubDate>
<dc:creator>anarchyrucks</dc:creator>
<og:type>website</og:type>
<og:image>https://res.infoq.com/news/2020/05/Jepsen-MongoDB-4-2-6/en/headerimage/og-c-1590150422052.jpg</og:image>
<og:title>Jepsen Disputes MongoDB’s Data Consistency Claims</og:title>
<og:description>In an article, MongoDB claimed their database passed “the industry’s toughest data safety, correctness, and consistency Tests”. In response, Jepsen published an article stating that MongoDB 3.6.4 had in fact failed their tests; the newer MongoDB 4.2.6 has more problems including “retrocausal transactions” where a transaction reverses order so that a read can see the result of a future write.</og:description>
<og:url>https://www.infoq.com/news/2020/05/Jepsen-MongoDB-4-2-6/</og:url>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.infoq.com/news/2020/05/Jepsen-MongoDB-4-2-6/</dc:identifier>
</item>
<item>
<title>Show HN: A dependently-typed programming language with static memory management</title>
<link>https://github.com/u2zv1wx/neut</link>
<guid isPermaLink="true" >https://github.com/u2zv1wx/neut</guid>
<description>&lt;p&gt;Neut is a dependently-typed programming language based on &lt;a href=&quot;https://ncatlab.org/nlab/show/calculus+of+constructions&quot; rel=&quot;nofollow&quot;&gt;the Calculus of Constructions (CoC)&lt;/a&gt;. The interesting point is that this language determines how to allocate/deallocate memory at compile-time, without extra annotations to the type system. In other words, Neut in its source language is the ordinary lambda-calculus after all (imagine something like Haskell, OCaml, Idris, Coq, Agda, or Lean), and at the same time it handles memory without using, for example:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;explicit malloc/free,&lt;/li&gt;
&lt;li&gt;garbage collection,&lt;/li&gt;
&lt;li&gt;region-based memory management.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Theoretically, this is made possible by translating the source language into a dependent variant of &lt;a href=&quot;https://www.cs.bham.ac.uk/~pbl/papers/thesisqmwphd.pdf&quot; rel=&quot;nofollow&quot;&gt;Call-By-Push-Value&lt;/a&gt;. The crucial point of this translation is to see that knowing the type of a term in the target calculus is knowing how to eta-expand the term, which in turn means knowing how to copy/discard the term. In the translation, a type is not erased, but &lt;strong&gt;translated into a computationally-meaningful term that copies/discards the terms of the type&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Practically, this means that you can write your program in the ordinary lambda-calculus without any extra restrictions or annotations, and at the same time are allowed to control how resources are used in the program. If you want an ordinary-lambda-calculus based programming language with a human-predictable semantics (including its memory management), this might be for you.&lt;/p&gt;
&lt;p&gt;Here I briefly summarize the basic properties of Neut before diving into the details:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;A compiled language&lt;/li&gt;
&lt;li&gt;The output is &lt;a href=&quot;https://llvm.org/docs/LangRef.html&quot; rel=&quot;nofollow&quot;&gt;LLVM IR&lt;/a&gt; / assembly / executable binary (the last two are via clang)&lt;/li&gt;
&lt;li&gt;The type system is CoC + fix + int + float + enum + array + struct - universe hierarchy&lt;/li&gt;
&lt;li&gt;The type inference algorithm is based on &lt;a href=&quot;https://arxiv.org/abs/1505.04324&quot; rel=&quot;nofollow&quot;&gt;the one of Lean&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The evaluation strategy is call-by-value&lt;/li&gt;
&lt;li&gt;Every tail call is optimized into a loop&lt;/li&gt;
&lt;li&gt;Memory allocation/deallocation is statically determined at compile time&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Proof-Theoretic Memory Management&lt;/h2&gt;
&lt;h3&gt;Basics&lt;/h3&gt;
&lt;p&gt;Let’s see how Neut manages resources. The following code prints the string “a” for the 3 times:&lt;/p&gt;
&lt;pre lang=&quot;neut&quot;&gt;
; download the core library
(ensure core/1.0.0.0
  &quot;https://github.com/u2zv1wx/neut-core/raw/master/release/0.1.0.0.tar.gz&quot;)

(include &quot;core/0.1.0.0/core.neut&quot;)

(with identity.bind
  (let str &quot;a&quot;)
  (let _ (string.print str))
  (let _ (string.print str))
  (string.print str))
&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;(with identity.bind (...))&lt;/code&gt; is the same as the do-notation in Haskell or other languages, specialized to the identity monad.&lt;/p&gt;
&lt;p&gt;By running &lt;code&gt;$ neut build --no-alloc-cancellation --emit llvm filename.neut&lt;/code&gt;, we obtain schematically the following LLVM IR (the &lt;code&gt;--no-alloc-cancellation&lt;/code&gt; is to disable certain optimization that we will see later):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-llvm&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@free&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;)
&lt;span class=&quot;pl-k&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@write&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;)
&lt;span class=&quot;pl-k&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@malloc&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt;)
&lt;span class=&quot;pl-k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@main&lt;/span&gt;() {
  &lt;span class=&quot;pl-c&quot;&gt;; Repeat the following for the 3 times:&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;;   &amp;lt;memory allocation for the string&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;;   &amp;lt;create the string &quot;a&quot; (i.e. write the character 'a' to the allocated memory)&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;;   &amp;lt;write the string into stdout&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;;   &amp;lt;memory deallocation for the string&amp;gt;&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The non-schematic, actual output can also be found in the &lt;a href=&quot;https://github.com/u2zv1wx/neut#llvm-ir-for-the-first-example&quot;&gt;appendix&lt;/a&gt;. I chose not to write the IR here since the output is a bit long (59 lines including comments).&lt;/p&gt;
&lt;p&gt;The resulting LLVM IR creates a string in memory, print it, and free it for the 3 times. The point here is that the resulting code creates 2 copies of the original string. This is because the variable &lt;code&gt;str&lt;/code&gt; is used for the 3 times; The content of a variable is copied to create n instances when the variable is used for the n times (n &amp;gt; 1). If the variable isn’t used at all (n &amp;lt; 1), the content of the variable is discarded (deallocated). If the variable is used exactly once, or linearly (n = 1), the content of the variable is used without any discarding/copying operation.&lt;/p&gt;
&lt;p&gt;By translating the source calculus in the way sketched above, every variable is ensured to be used linearly, except for the ones in the functions that realize those copying/discarding operations. Thus, by checking that those exponentializers use resources properly, we can ensure that the target calculus of this translation handles memory properly too. Then we check that those exponentializers are indeed sane - This is the basic storyline.&lt;/p&gt;
&lt;p&gt;The way how a variable is copied/discarded is determined by the type of the variable. For example, if the type of a variable is the array type as in the example above, the copying operation is something that you would do in C to copy an array (memory allocation followed by value insertion). If the type is an immediate type like an integer type, the “copying” operation is the one that uses the original value for the cloned value. Every type is translated into a term that copies/discards the terms of the type, including the type of the types.&lt;/p&gt;
&lt;h3&gt;Types as Exponentializers&lt;/h3&gt;
&lt;p&gt;Let us go a little deeper. Consider the following schematic user input:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-haskell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; str &lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; string &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;a&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;{-&lt;/span&gt; A CODE THAT USES `str` for the 3 times &lt;span class=&quot;pl-c&quot;&gt;-}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Intuitively, what the compiler does is to translate the term above into the following term:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-haskell&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; str &lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; string &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;a&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; (discard&lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt;string, copy&lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt;string) &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-ent&quot;&gt;TRANSLATE&lt;/span&gt;(string);
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; (str1, tmp) &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; copy&lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt;string(str);
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; (str2, str3) &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; copy&lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt;string(tmp);
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;{-&lt;/span&gt; THE CODE THAT USES `str1`, `str2`, AND `str3` LINEARLY &lt;span class=&quot;pl-c&quot;&gt;-}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that the second line extracts &lt;code&gt;discard-string&lt;/code&gt; and &lt;code&gt;copy-string&lt;/code&gt; from the tuple &lt;code&gt;TRANSLATE(string)&lt;/code&gt;. Every type &lt;code&gt;X&lt;/code&gt; is translated in this manner; the pair of &lt;code&gt;discard-X&lt;/code&gt; and &lt;code&gt;copy-X&lt;/code&gt;. These exponentializers - something that allows us to create n copies of &lt;code&gt;x&lt;/code&gt; from a single &lt;code&gt;x&lt;/code&gt; - are used in its continuation so that every variable of this type (&lt;code&gt;str&lt;/code&gt; in this example) is used linearly.&lt;/p&gt;
&lt;p&gt;Incidentally, in the actual implementation, the result of &lt;code&gt;TRANSLATE(string)&lt;/code&gt; is not a pair, but a function as in the pseudo-code below:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-haskell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
cartesian&lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt;string i e &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; i &lt;span class=&quot;pl-k&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;then&lt;/span&gt; discard&lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt;string(e)
  &lt;span class=&quot;pl-k&quot;&gt;else&lt;/span&gt; copy&lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt;string(e)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which is used in the following manner:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-haskell&quot; readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; str &lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; string &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;a&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; cartesian&lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt;string &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-ent&quot;&gt;TRANSLATE&lt;/span&gt;(string);
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; (str1, tmp) &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; cartesian&lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt;string(&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;, tmp);
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; (str2, str3) &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; cartesian&lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt;string(&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;, tmp);
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;{-&lt;/span&gt; THE CODE THAT USES `str1`, `str2`, AND `str3` LINEARLY &lt;span class=&quot;pl-c&quot;&gt;-}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This alternative translation frees us from having to create a tuple every time when we translate a type. Thus, in the actual implementation, every type is translated into a closed function, which is then lowered to a pointer (1 word).&lt;/p&gt;
&lt;p&gt;It would be worth noting here that these functions like &lt;code&gt;cartesian-string&lt;/code&gt; are β-reduced (inlined) aggressively; These are ordinary functions that can be defined in the target language, after all.&lt;/p&gt;
&lt;h3&gt;Notes on Closures&lt;/h3&gt;
&lt;p&gt;You may be wondering now: “How can we copy/discard a closure? In ordinary closure conversion, a lambda-abstraction is translated into a pair consists of (1) all the free variables in the abstraction, and (2) a pointer to an appropriately-arranged closed function. How can that tuple be copied/discarded just by using type information like &lt;code&gt;i64 -&amp;gt; bool&lt;/code&gt;, which is seemingly useless here? How should we translate the type &lt;code&gt;i64 -&amp;gt; bool&lt;/code&gt;?”&lt;/p&gt;
&lt;p&gt;That is a valid question. The key to give the answer to this question is generalizing the concept of “all the free variables”. Consider the following term:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-haskell&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
λ (a &lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt;)&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt; λ (x &lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; a)&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt; λ (y &lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; i64)&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt; (x, y)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In ordinary closure conversion, the free variables of &lt;code&gt;λ (y : i64). (x, y)&lt;/code&gt; is calculated to be &lt;code&gt;[x]&lt;/code&gt; without making a fuss. Here, however, we generalize the concept so that we “trace” all the free variables included in the type of every free variable. In this case, for example, note that the type of &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;a&lt;/code&gt;, which is again a free variable if it occurs in &lt;code&gt;λ (y : i64). (...)&lt;/code&gt;, and thus this &lt;code&gt;a&lt;/code&gt; is also considered to be a free variable. Since the type of &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;type&lt;/code&gt;, which has no free variables, our tracing stops here, resulting a chain of the free variables &lt;code&gt;[a : type, x : a]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Note that every result of this procedure is necessarily “closed”. That is, if the list &lt;code&gt;[x1 : A1, ..., xn : An]&lt;/code&gt; is a result of this tracing process, then the set of free variables in &lt;code&gt;A{i}&lt;/code&gt; is a subset of &lt;code&gt;{x1, ..., x{i-1}}&lt;/code&gt;. In this way, we extract a closed chain from a lambda-abstraction.&lt;/p&gt;
&lt;p&gt;Let us continue the example of &lt;code&gt;λ (y : i64), (x, y)&lt;/code&gt;. Using the closed chain we have just calculated, the compiler translates this lambda-abstraction conceptually as follows:&lt;/p&gt;
&lt;pre lang=&quot;text&quot;&gt;
(∑ [a : type, x : a], (a, x), LABEL_OF_A_CLOSED_FUNCTION)
&lt;/pre&gt;
&lt;p&gt;That is, a lambda-abstraction is translated into a tuple consists of &lt;strong&gt;(0) the type of its closed chain&lt;/strong&gt;, (1) its closed chain, and (2) a pointer to an appropriately-arranged closed function. Now, remember that every type is translated into a term that copies/discards the terms of the type. Also remember that every type is translated into a function pointer, which can be copied/discarded without any malloc/free operations. Thus, we can generate a function that copies/discards a closure conceptually as follows:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-haskell&quot; readability=&quot;22&quot;&gt;
&lt;pre&gt;
cartesian&lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt;closure i closure &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;do&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;--&lt;/span&gt; extract the element of the closure, freeing the outer 3-word tuple&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; (typeOfChain, chain, label) &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; closure;
  &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; i &lt;span class=&quot;pl-k&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;--&lt;/span&gt; discard the chain using the type information&lt;/span&gt;
    &lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; _ &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; typeOfChain(&lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;, chain);
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;--&lt;/span&gt; note that both typeOfChain and label are immediate&lt;/span&gt;
    &lt;span class=&quot;pl-c1&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;--&lt;/span&gt; copy the chain using the type information&lt;/span&gt;
    &lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; (chainA, chainB) &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; typeOfChain(&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;, chain);
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;--&lt;/span&gt; construct the 2 closures, and the wrapper tuple (thus do malloc for the 3 times)&lt;/span&gt;
    &lt;span class=&quot;pl-c1&quot;&gt;return&lt;/span&gt; ((typeOfChain, chainA, label), (typeOfChain, chainB, label))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Thus, we can translate every Π-type into the function &lt;code&gt;cartesian-closure&lt;/code&gt;. Every Closure is copied/discarded in the same way, regardless of its actual details. So, information like &lt;code&gt;i64&lt;/code&gt; or &lt;code&gt;bool&lt;/code&gt; in &lt;code&gt;i64 -&amp;gt; bool&lt;/code&gt; is indeed useless here; It simply isn’t necessary since every closure knows how to copy/discard itself.&lt;/p&gt;
&lt;p&gt;The remaining piece is how a type of a closed chain like &lt;code&gt;∑ [a : type, x : a]&lt;/code&gt; is translated. This is where eta-expansion plays its role. Suppose we have a term &lt;code&gt;e&lt;/code&gt; of type &lt;code&gt;∑ [a : type, x : a]&lt;/code&gt;. Since we already know the type of &lt;code&gt;e&lt;/code&gt;, we can eta-expand this term as follows:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-haskell&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; (a, x) &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; e &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt;
(a, x)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, at this point, note that if we can copy both &lt;code&gt;a : type&lt;/code&gt; and &lt;code&gt;x : a&lt;/code&gt;, we can then copy &lt;code&gt;e&lt;/code&gt; as follows:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-haskell&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; (a, x) &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; e &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; (a1, a2) &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; {&lt;span class=&quot;pl-ent&quot;&gt;COPY_a&lt;/span&gt;} a &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; (x1, x2) &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; {&lt;span class=&quot;pl-ent&quot;&gt;COPY_x&lt;/span&gt;} x &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt;
((a1, x1), (a2, x2))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Thus, thanks to eta-expansion, the problem of copying/discarding the terms of type &lt;code&gt;∑ [a : type, x : a]&lt;/code&gt; is reduced into the one of copying/discarding the terms of type &lt;code&gt;a : type&lt;/code&gt; and &lt;code&gt;x : a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The actual copying function is constructed inductively as follows. The starting point is the following term:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-haskell&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; (a, x) &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; e &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt;
((a, x), (a, x))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Firstly we copy &lt;code&gt;x&lt;/code&gt; - using its type &lt;code&gt;a&lt;/code&gt; - so that &lt;code&gt;x&lt;/code&gt; is used linearly:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-haskell&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; (a, x) &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; e &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; (x1, x2) &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; a(&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;, x) &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt;
((a, x1), (a, x2))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This creates a term that uses &lt;code&gt;x&lt;/code&gt; linearly. Then we copy the term &lt;code&gt;a&lt;/code&gt; - using its type &lt;code&gt;type&lt;/code&gt; - so that &lt;code&gt;a&lt;/code&gt; is used linearly:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-haskell&quot; readability=&quot;18&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; (a, x) &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; e &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; (a1, tmp) &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;, a) &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; (a2, a3) &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;, tmp) &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; (x1, x2) &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; a1(&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;, x) &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt;
((a2, x1), (a3, x2))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where the &lt;code&gt;type&lt;/code&gt; is a term defined as follows:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-haskell&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;pl-smi&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;
  &lt;span class=&quot;pl-smi&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;()&lt;/span&gt;     &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;--&lt;/span&gt; non-linear (affine) use of `a`&lt;/span&gt;
  &lt;span class=&quot;pl-smi&quot;&gt;else&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;a&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;a&lt;/span&gt;) &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;--&lt;/span&gt; non-linear (relevant) use of `a`&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which is resource-safe since a type is translated into a function pointer. This creates a term that uses both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; linearly.&lt;/p&gt;
&lt;p&gt;Note that, by its construction, the first element of a closed chain doesn’t contain any free variables, and therefore can be copied without using any free variables.&lt;/p&gt;
&lt;p&gt;In conclusion, the copying part of &lt;code&gt;∑ [a : type, x : a]&lt;/code&gt; is defined by the following term:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-haskell&quot; readability=&quot;18&quot;&gt;
&lt;pre&gt;
copy&lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt;sigma sig &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; (a, x) &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; sig &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; (a1, tmp) &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;, a) &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; (a2, a3) &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;, tmp) &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; (x1, x2) &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; a1(&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;, x) &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt;
  ((a2, x1), (a3, x2))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;By using this term, we can now copy the tuple &lt;code&gt;(a, x)&lt;/code&gt; in the closure &lt;code&gt;(∑ [a : type, x : a], (a, x), LABEL)&lt;/code&gt;. The discarding function is defined similarly. That is, we change the starting point to&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-haskell&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; (a, x) &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; e &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and do the same inductive procedure. Now we just have to construct the following term:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-haskell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
cartesian&lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt;sigma i sig &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; i &lt;span class=&quot;pl-k&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;then&lt;/span&gt; discard&lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt;sigma sig
  &lt;span class=&quot;pl-k&quot;&gt;else&lt;/span&gt; copy&lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt;sigma sig
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and translate &lt;code&gt;∑ [a : type, x : a]&lt;/code&gt; into the &lt;code&gt;cartesian-sigma&lt;/code&gt; above. In this way we can copy/discard a closure.&lt;/p&gt;
&lt;h3&gt;Notes on Polymorphic Functions&lt;/h3&gt;
&lt;p&gt;Or you may be wondering: “What if a function is polymorphic? If the size of an argument is not fixed, how can that function copy the term?”&lt;/p&gt;
&lt;p&gt;That is again a valid question, and here comes dependent-type. Firstly, remember that a polymorphic function in dependent-type theory is nothing but an ordinary function with an argument of type &lt;code&gt;tau&lt;/code&gt;, where &lt;code&gt;tau&lt;/code&gt; is the type of types. For example, the following is a polymorphic function that creates a pair of any type:&lt;/p&gt;
&lt;pre lang=&quot;neut&quot;&gt;
; to-tuple : Π (a : tau, x : a). a * a
(define to-tuple ((a tau) (x a))
  (tuple x x))
&lt;/pre&gt;
&lt;p&gt;This function &lt;code&gt;to-tuple&lt;/code&gt; is, for example, used as follows:&lt;/p&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(to-tuple i64 1)          ; ~&amp;gt; (tuple 1 1)
(to-tuple bool bool.true) ; ~&amp;gt; (tuple bool.true bool.true)
(to-tuple string &quot;a&quot;)     ; ~&amp;gt; (tuple &quot;a&quot; &quot;a&quot;)
&lt;/pre&gt;
&lt;p&gt;Note that the type &lt;code&gt;i64&lt;/code&gt; is used in exactly the same way as &lt;code&gt;1&lt;/code&gt;; A type is nothing but an ordinary term of type &lt;code&gt;tau&lt;/code&gt;. And these very terms &lt;code&gt;i64&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt;, and &lt;code&gt;string&lt;/code&gt; in the example are translated into ordinary closed functions that copies/discards the terms of the types. The &lt;code&gt;to-tuple&lt;/code&gt; function can therefore copy the resource &lt;code&gt;x&lt;/code&gt; of type &lt;code&gt;a&lt;/code&gt; conceptually as follows:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-haskell&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
to&lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt;tuple &lt;span class=&quot;pl-k&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Π&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;tau&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;a&lt;/span&gt;)&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;a&lt;/span&gt;
to&lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt;tuple a x &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; (x1, x2) &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; a(&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;, x) &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt;
  (x1, x2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Thus the answer to the question is: Polymorphic functions can copy/discard its polymorphic argument since the type, which is guaranteed to be passed as an argument, contains information on how to copy/discard the terms of the type.&lt;/p&gt;
&lt;h3&gt;Summary So Far&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;A variable is copied/discarded so that the variable is used linearly&lt;/li&gt;
&lt;li&gt;A type is lowered into a function pointer that copies/discards the terms of the type&lt;/li&gt;
&lt;li&gt;Closures can be copied/discarded since they know how to copy/discard itself&lt;/li&gt;
&lt;li&gt;Polymorphic function can copy/discard its polymorphic arguments thanks to the information provided by its type argument&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;This is the basic behavior of Neut’s proof-theoretic memory management. As you might already be aware, this naive copying/discarding can result in an inefficient object code. We often use a variable more than once, as in the example of &lt;code&gt;str&lt;/code&gt;:&lt;/p&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(with identity.bind
  (let str &quot;a&quot;)
  (let _ (string.print str))
  (let _ (string.print str))
  (string.print str))
&lt;/pre&gt;
&lt;p&gt;We can’t say the resulting LLVM IR of this code is efficient enough; We can’t ignore those redundant copy operations.&lt;/p&gt;
&lt;p&gt;Fortunately, there is a workaround for this performance problem.&lt;/p&gt;
&lt;h2&gt;Manual Optimization via Borrowing&lt;/h2&gt;
&lt;p&gt;The point of the workaround is straightforward: If those copying/discarding operations result from using variables non-linearly, we simply have to use variables linearly. Let’s go back to the first example code:&lt;/p&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(ensure core/1.0.0.0
  &quot;https://github.com/u2zv1wx/neut-core/raw/master/release/0.1.0.0.tar.gz&quot;)

(include &quot;core/0.1.0.0/core.neut&quot;)

(with identity.bind
  (let str &quot;a&quot;)
  (let _ (string.print str))
  (let _ (string.print str))
  (string.print str))
&lt;/pre&gt;
&lt;p&gt;We would like to use the variable &lt;code&gt;str&lt;/code&gt; linearly. To this end, we can request &lt;code&gt;string.print&lt;/code&gt; to include the argument &lt;code&gt;str&lt;/code&gt; in its return value. So, the type of &lt;code&gt;string.print&lt;/code&gt; shouldn’t be something like &lt;code&gt;string -&amp;gt; top&lt;/code&gt; - where the &lt;code&gt;top&lt;/code&gt; is the unit type - but should be &lt;code&gt;string -&amp;gt; string * top&lt;/code&gt;, where the &lt;code&gt;A * B&lt;/code&gt; means the product type of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;. More specifically, the implementation of &lt;code&gt;string.print&lt;/code&gt; should be something like (in pseudo-code):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-haskell&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
string&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;top&lt;/span&gt;
string&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;print&lt;/span&gt; str &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;do&lt;/span&gt;
  {&lt;span class=&quot;pl-c1&quot;&gt;print&lt;/span&gt; the string &lt;span class=&quot;pl-k&quot;&gt;`str`&lt;/span&gt;}
  &lt;span class=&quot;pl-c1&quot;&gt;return&lt;/span&gt; (str, unit)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With that definition of &lt;code&gt;string.print&lt;/code&gt;, we can use the variable &lt;code&gt;str&lt;/code&gt; linearly (again, in pseudo-code):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-haskell&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; str1 &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;a&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; (str2, _) &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; string&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;print&lt;/span&gt; str1;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; (str3, _) &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; string&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;print&lt;/span&gt; str2;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; (str4, _) &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; string&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;print&lt;/span&gt; str3;
unit
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that the variables &lt;code&gt;str1&lt;/code&gt;, &lt;code&gt;str2&lt;/code&gt;, and &lt;code&gt;str3&lt;/code&gt; are used exactly once, and &lt;code&gt;str4&lt;/code&gt; for the 0 time. Therefore, the copying operation doesn’t occur in the code above. Also, since the &lt;code&gt;str4&lt;/code&gt; is defined but not used, the &lt;code&gt;str4&lt;/code&gt; is discarded immediately after its definition.&lt;/p&gt;
&lt;p&gt;Now we have seen that those redundant copying/discarding operations can be avoided by writing the code in the manner above. There still remains a problem: code cluttering. It would be much nicer to have more sophisticated notation of that code pattern. Towards that end, firstly note that we can use the same name for the variables &lt;code&gt;str1&lt;/code&gt;, &lt;code&gt;str2&lt;/code&gt;, &lt;code&gt;str3&lt;/code&gt;, and &lt;code&gt;str4&lt;/code&gt; thanks to variable shadowing:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-haskell&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; str &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;a&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; (str, _) &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; string&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;print&lt;/span&gt; str;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; (str, _) &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; string&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;print&lt;/span&gt; str;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; (str, _) &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; string&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;print&lt;/span&gt; str;
unit
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, we just have to introduce a notation that translates:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-haskell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; foo &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; string&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&lt;/span&gt;str;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;into:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-haskell&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; (str, foo) &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; string&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;print&lt;/span&gt; str;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With this notation, our running example is rewritten as follows:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-haskell&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; str &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;a&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; _ &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; string&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&lt;/span&gt;str;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; _ &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; string&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&lt;/span&gt;str;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; _ &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; string&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&lt;/span&gt;str;
unit
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And this is the notation that is implemented in Neut. Indeed, the following is a valid code of Neut:&lt;/p&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(ensure core/1.0.0.0
  &quot;https://github.com/u2zv1wx/neut-core/raw/master/release/0.1.0.0.tar.gz&quot;)

(include &quot;core/0.1.0.0/core.neut&quot;)

(with identity.bind
  (let str &quot;a&quot;)
  (let _ (string.print &amp;amp;str))
  (let _ (string.print &amp;amp;str))
  (let _ (string.print &amp;amp;str))
  top.unit) ; ~&amp;gt; top.unit
&lt;/pre&gt;
&lt;p&gt;Or,&lt;/p&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(ensure core/1.0.0.0
  &quot;https://github.com/u2zv1wx/neut-core/raw/master/release/0.1.0.0.tar.gz&quot;)

(include &quot;core/0.1.0.0/core.neut&quot;)

(with identity.bind
  (let str &quot;a&quot;)
  (let _ (string.print &amp;amp;str))
  (let _ (string.print &amp;amp;str))
  (string.print str)) ; ~&amp;gt; (unit, &quot;a&quot;)
&lt;/pre&gt;
&lt;p&gt;This notation is “borrowing” in Neut. Note that borrowing in Neut is nothing but a syntactic translation. Borrowing has nothing to do with, for example, the type system, or the operational semantics, of Neut. Indeed, this syntactic translation is processed at the stage of parsing in the compiler.&lt;/p&gt;
&lt;p&gt;Let’s see how the resulting LLVM IR changes. Is it faster now? We can compile the code above by running &lt;code&gt;$ neut build --no-alloc-cancellation --emit llvm filename.neut&lt;/code&gt;. The output is schematically as follows:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-llvm&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@free&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;)
&lt;span class=&quot;pl-k&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@write&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;)
&lt;span class=&quot;pl-k&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@malloc&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt;)
&lt;span class=&quot;pl-k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@main&lt;/span&gt;() {
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;memory allocation for the string&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;create the string &quot;a&quot; (i.e. write the character 'a' to the allocated memory)&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;write the string into stdout for the three times&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;memory deallocation for the string&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;return 0&amp;gt;&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Again, the non-schematic output can be found in the &lt;a href=&quot;https://github.com/u2zv1wx/neut#llvm-ir-for-the-second-example&quot;&gt;appendix&lt;/a&gt;. The output in this time is actually short enough to include it here (36 lines including comments), though I chose not to. The point here is that the string “a” is reused without copying, as expected.&lt;/p&gt;
&lt;p&gt;The resulting assembly code, which can be obtained by &lt;code&gt;--emit asm&lt;/code&gt;, is reasonably small too (works on macOS; when you compile the same code on Linux, the &lt;code&gt;write&lt;/code&gt; operations are lowered into the corresponding syscalls):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-assembly&quot; readability=&quot;30&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-en&quot;&gt;      .&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;section&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;  __TEXT&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;__text&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;regular&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;pure_instructions&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;    .macosx_version_min &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;15&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;    .globl  _main                   ## &lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; Begin function main&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;    .p2align        &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;0x90&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;_main:                                  ## @main&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;    .cfi_startproc&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;## %bb.&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;    pushq   %&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;rbx&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;    .cfi_def_cfa_offset &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;16&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;    .cfi_offset %&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;rbx&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;15&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;    movl&lt;/span&gt;     &lt;span class=&quot;pl-c1&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; %&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;edi&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;                 # &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;byte memory allocation (you can ignore the lines above this line)&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;    callq   _malloc&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;movq&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;       %&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; %&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;rbx&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;    movb&lt;/span&gt;     &lt;span class=&quot;pl-c1&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;97&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; (%&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)              # write &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;'a'&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; (= &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;97&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;) to the allocated memory&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;    movl&lt;/span&gt;     &lt;span class=&quot;pl-c1&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; %&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;edi&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;                 # set the arguments for `_write`&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;    movl&lt;/span&gt;     &lt;span class=&quot;pl-c1&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; %&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;edx&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;movq&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;       %&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; %&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;rsi&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;    callq   _write                   # ... &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;and&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; `_write` (i.e. print &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;'a'&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;    movl&lt;/span&gt;     &lt;span class=&quot;pl-c1&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; %&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;edi&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;                 # (repe&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;    movl&lt;/span&gt;     &lt;span class=&quot;pl-c1&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; %&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;edx&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;movq&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;       %&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;rbx&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; %&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;rsi&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;    callq   _write&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;    movl&lt;/span&gt;     &lt;span class=&quot;pl-c1&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; %&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;edi&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;                 # (repe&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;    movl&lt;/span&gt;     &lt;span class=&quot;pl-c1&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; %&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;edx&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;movq&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;       %&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;rbx&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; %&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;rsi&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;    callq   _write&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;movq&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;       %&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;rbx&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; %&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;rdi&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;               # free the allocated memory&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;    callq   _free&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;    xorl    %&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; %&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;eax&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;    popq    %&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;rbx&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;    retq&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;    .cfi_endproc&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;                                        ## &lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; End function&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;.subsections_via_symbols&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In short: the resulting code is faster in that it is free from the redundant copying operations we saw in the first example.&lt;/p&gt;
&lt;p&gt;This is how Neut controls resources efficiently, without modifying the type system of the source language.&lt;/p&gt;
&lt;h2&gt;Automatic Optimization via malloc/free Cancellation&lt;/h2&gt;
&lt;p&gt;Neut’s static memory management enables not only the “manual” optimization we have just seen, but also another “automatic” optimization. Remember the first example:&lt;/p&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(with identity.bind
  (let str &quot;a&quot;)
  (let _ (string.print str))
  (let _ (string.print str))
  (let _ (string.print str))
  (i64 0))
&lt;/pre&gt;
&lt;p&gt;and the output IR of this example code:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-llvm&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@free&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;)
&lt;span class=&quot;pl-k&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@write&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;)
&lt;span class=&quot;pl-k&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@malloc&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt;)
&lt;span class=&quot;pl-k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@main&lt;/span&gt;() {
  &lt;span class=&quot;pl-c&quot;&gt;; Repeat the following for the 3 times:&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;;   &amp;lt;memory allocation for the string&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;;   &amp;lt;create the string &quot;a&quot; (i.e. write the character 'a' to the allocated memory)&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;;   &amp;lt;write the string into stdout&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;;   &amp;lt;memory deallocation for the string&amp;gt;&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The code is already judged to be inefficient in that it allocates/deallocates memory unnecessarily. More specifically, it is inefficient in that it deallocates the memory that can actually be reused.&lt;/p&gt;
&lt;p&gt;Now you might think: If the sizes of allocations/deallocations are known at compile-time, isn’t it possible to compare the sizes of them at compile-time and emit a code that reuses the allocated memory?&lt;/p&gt;
&lt;p&gt;It is indeed possible. When the option &lt;code&gt;--no-alloc-cancellation&lt;/code&gt; is not passed, the compiler translates code pieces something like this:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-llvm&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;define&lt;/span&gt; TYPE &lt;span class=&quot;pl-c1&quot;&gt;@FUNCTION_NAME&lt;/span&gt;(...) {
  (...)
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;memory allocation for the string&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;create the string &quot;a&quot; (i.e. write the character 'a' to the allocated memory)&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;write the string into stdout&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;memory deallocation for the string&amp;gt;    -- (*1)&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;memory allocation for the string&amp;gt;      -- (*2)&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;create the string &quot;a&quot; (i.e. write the character 'a' to the allocated memory)&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;write the string into stdout&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;memory deallocation for the string&amp;gt;&lt;/span&gt;
  (...)
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;into something like this:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-llvm&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;define&lt;/span&gt; TYPE &lt;span class=&quot;pl-c1&quot;&gt;@FUNCTION_NAME&lt;/span&gt;(...) {
  (...)
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;memory allocation for the string&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;create the string &quot;a&quot; (i.e. write the character 'a' to the allocated memory)&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;write the string into stdout&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;create the string &quot;a&quot; (i.e. write the character 'a' to the allocated memory)&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;write the string into stdout&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;memory deallocation for the string&amp;gt;&lt;/span&gt;
  (...)
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In other words, the compiler can cancel the memory deallocation at &lt;code&gt;(*1)&lt;/code&gt; and the allocation at &lt;code&gt;(*2)&lt;/code&gt;, reusing the allocated memory in its continuation. This is automatic malloc/free cancellation. By this fallback optimization, the compiler can emit somewhat more performant code even if a user wrote code in an inefficient way.&lt;/p&gt;
&lt;p&gt;Note that the “create the string” parts are not optimized away from the resulting LLVM IR, in contrast to the one of borrowing:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-llvm&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@main&lt;/span&gt;() {
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;memory allocation for the string&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;create the string &quot;a&quot; (i.e. write the character 'a' to the allocated memory)&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;write the string into stdout&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;write the string into stdout&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;write the string into stdout&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;memory deallocation for the string&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;return 0&amp;gt;&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Although the compiler can cancel memory allocations/deallocations, it cannot cancel their accompanying initialization processes (at least for now). If you do need performance, you need to write code in the linear/borrowing style.&lt;/p&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Neut statically determines malloc/free at compile-time via type information&lt;/li&gt;
&lt;li&gt;The content of a variable is
&lt;ul&gt;&lt;li&gt;discarded if and only if the variable isn’t used at all&lt;/li&gt;
&lt;li&gt;untouched if and only if the variable is used exactly once (i.e. used linearly)&lt;/li&gt;
&lt;li&gt;copied if and only if the variable is used more than once&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Linearity tends to result in an efficient code&lt;/li&gt;
&lt;li&gt;Non-linearity tends to result in an inefficient code&lt;/li&gt;
&lt;li&gt;Borrowing can be used as a convenient syntactic tool when accomplishing linearity&lt;/li&gt;
&lt;li&gt;Redundant malloc/free can be reduced by automatic malloc/free cancellation&lt;/li&gt;
&lt;li&gt;Borrowing-based, or “manually” optimized code is faster than cancellation-based, or “automatically” optimized code&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The currently supported platforms are: Linux (x64), macOS (x64).&lt;/p&gt;
&lt;p&gt;Make sure that you have already installed &lt;a href=&quot;https://zlib.net/&quot; rel=&quot;nofollow&quot;&gt;zlib&lt;/a&gt; (&amp;gt;= 1.2.11), &lt;a href=&quot;https://wiki.openssl.org/index.php/Libssl_API&quot; rel=&quot;nofollow&quot;&gt;libssl&lt;/a&gt; (&amp;gt;= 1.1.1), &lt;a href=&quot;https://docs.haskellstack.org/en/stable/README/&quot; rel=&quot;nofollow&quot;&gt;stack&lt;/a&gt; (&amp;gt;= 2.3.0) and &lt;a href=&quot;https://clang.llvm.org/&quot; rel=&quot;nofollow&quot;&gt;clang&lt;/a&gt; (&amp;gt;= 10.0.0). On Debian, for example, the first three can be installed as follows:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
$ sudo apt install zlib1g-dev libssl-dev haskell-stack
$ stack upgrade --binary-only &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; not required if your stack is already up-to-date&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;clang&lt;/code&gt; can be installed in the way described &lt;a href=&quot;https://apt.llvm.org/&quot; rel=&quot;nofollow&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Also make sure that you have &lt;code&gt;~/.local/bin&lt;/code&gt; in your &lt;code&gt;$PATH&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Then, clone the repository and build it:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
$ git clone https://github.com/u2zv1wx/neut
$ &lt;span class=&quot;pl-c1&quot;&gt;cd&lt;/span&gt; neut
$ git checkout 0.1.0.0
$ stack &lt;span class=&quot;pl-c1&quot;&gt;test&lt;/span&gt;    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; this builds the project and tests its behavior&lt;/span&gt;
$ stack install &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; this installs the executable `neut` into `~/.local/bin`&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To uninstall, you just have to remove the binary &lt;code&gt;~/.local/bin/neut&lt;/code&gt; and the directory &lt;code&gt;~/.local/share/neut&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;As for editor support, you can currently try &lt;a href=&quot;https://github.com/u2zv1wx/neut-mode&quot;&gt;neut-mode&lt;/a&gt; and &lt;a href=&quot;https://github.com/u2zv1wx/flycheck-neut&quot;&gt;flycheck-neut&lt;/a&gt; if you’re using Emacs. The former package is for syntax highlighting, and the latter one for linting.&lt;/p&gt;

&lt;p&gt;You can find a detailed description of the syntax, the logic, and the semantics of Neut in the succeeding sections. Those should suffice to read/write a program of Neut. Having said that though, some might prefer learning from actual source code after taking a brief look at this and that basic stuff. So here I introduce you some necessities that would be required to understand - or guess the meaning of - a program of Neut.&lt;/p&gt;
&lt;p&gt;Let’s start. Notes on programs. (0) A program of Neut is a list of statements, processed one by one. (1) &lt;a href=&quot;https://github.com/u2zv1wx/neut#ensure&quot;&gt;ensure&lt;/a&gt; and &lt;a href=&quot;https://github.com/u2zv1wx/neut#include&quot;&gt;include&lt;/a&gt; are the ones that use codes written in other files. I recommend you to read the linked notes; both of them are not so long. (2) &lt;a href=&quot;https://github.com/u2zv1wx/neut#useunuse&quot;&gt;use/unuse&lt;/a&gt; and &lt;a href=&quot;https://github.com/u2zv1wx/neut#sectionend&quot;&gt;section/end&lt;/a&gt; are the ones that handle namespace. Again I recommend you to read them.&lt;/p&gt;
&lt;p&gt;Next. Notes on terms. (0) Note that what follows presupposes the &lt;code&gt;notation.neut&lt;/code&gt; in &lt;a href=&quot;https://github.com/u2zv1wx/neut-core&quot;&gt;the core library&lt;/a&gt;; Some of these won’t work without including the file. (1) &lt;code&gt;tau&lt;/code&gt; is the type of types. (2) &lt;code&gt;Π&lt;/code&gt; is the universal quantification. Note that &lt;code&gt;Π (x : A). B&lt;/code&gt; is the same as the arrow type &lt;code&gt;A -&amp;gt; B&lt;/code&gt; if &lt;code&gt;x ∉ freevar(B)&lt;/code&gt;. Also note that a lambda-abstraction in Neut is n-ary; &lt;code&gt;(λ ((x A) (y B)) e)&lt;/code&gt; is not the same as &lt;code&gt;(λ ((x A)) (λ ((y B)) e))&lt;/code&gt;. (3) If you want to create a tuple, you can use &lt;code&gt;(sigma-introduction e1 ... en)&lt;/code&gt; or &lt;code&gt;(tuple e1 ... en)&lt;/code&gt;. You can destruct a tuple by &lt;code&gt;(sigma-elimination (x1 ... xn) e cont)&lt;/code&gt;. (4) You can write &lt;code&gt;(question e)&lt;/code&gt; or &lt;code&gt;?x&lt;/code&gt; when you want the compiler to show the type of &lt;code&gt;e&lt;/code&gt; or &lt;code&gt;x&lt;/code&gt;. (5) You can write &lt;code&gt;*&lt;/code&gt; to have the compiler infer the specified part. For example, assuming &lt;code&gt;(define id ((a tau) (x a)) x)&lt;/code&gt;, you can write &lt;code&gt;(id * bool.true)&lt;/code&gt; instead of &lt;code&gt;(id bool bool.true)&lt;/code&gt;. (6) You will notice that &lt;code&gt;(witness t e)&lt;/code&gt; is used here and there. This is a notation defined by &lt;code&gt;(notation (witness t e) ((λ ((x t)) x) e))&lt;/code&gt;; A notation that tells the compiler that the term of &lt;code&gt;e&lt;/code&gt; is &lt;code&gt;t&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Next. Notes on primitives: (0) The following primitive types are available: &lt;code&gt;i1&lt;/code&gt;, &lt;code&gt;i2&lt;/code&gt;, &lt;code&gt;i3&lt;/code&gt;, …, &lt;code&gt;i64&lt;/code&gt;. These are the same as the corresponding integer types in LLVM. (1) You can also use &lt;code&gt;f16&lt;/code&gt;, &lt;code&gt;f32&lt;/code&gt;, and &lt;code&gt;f64&lt;/code&gt;. These are LLVM’s &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, and &lt;code&gt;double&lt;/code&gt;, respectively. (2) You will soon come to want primitive instructions - like &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;mul&lt;/code&gt;, or &lt;code&gt;xor&lt;/code&gt; - that can operate on terms of these types. You can find information on them &lt;a href=&quot;https://github.com/u2zv1wx/neut#primitives&quot;&gt;in this section&lt;/a&gt;. (3) In the section you can also find notes on unsafe casting, array accessing, and syscall. I think these should also count as necessities. (4) When you use an effectful primitive like &lt;code&gt;os.write&lt;/code&gt; in a type, the behavior of the resulting executable is undefined.&lt;/p&gt;
&lt;p&gt;Next. Notes on the compiler subcommands. (0) You can build a program with &lt;code&gt;$ neut build path/to/file.neut&lt;/code&gt;. (1) You can create an &lt;code&gt;tar.gz&lt;/code&gt; archive of a project via &lt;code&gt;$ neut archive path/to/dir&lt;/code&gt;. Then you can upload the archive to somewhere, allowing others to &lt;code&gt;ensure&lt;/code&gt; and &lt;code&gt;include&lt;/code&gt; it.&lt;/p&gt;
&lt;p&gt;Now I think you are basically ready to, for example, start reading &lt;a href=&quot;https://github.com/u2zv1wx/neut/tree/master/test/data&quot;&gt;the files in the test directory&lt;/a&gt;, or &lt;a href=&quot;https://github.com/u2zv1wx/neut-core&quot;&gt;the files in the core library&lt;/a&gt;, referring the sections below as necessary. After that you should know how to write lambdas, recursive functions, inductive types, tuples. You need a state? You can use the state monad. Multiple effects? The free monad. You have the full power of lambda calculus.&lt;/p&gt;
&lt;p&gt;That pretty much should do it. I hope you enjoy this language.&lt;/p&gt;

&lt;p&gt;A program of Neut is a list of statements. Each statement is one of the following statements described in this section.&lt;/p&gt;
&lt;p&gt;Please note that the descriptions in the followings are not that formal yet.&lt;/p&gt;
&lt;p&gt;In the following, I use the symbols &lt;code&gt;LEAF&lt;/code&gt; and &lt;code&gt;TREE&lt;/code&gt; defined as follows:&lt;/p&gt;
&lt;pre lang=&quot;text&quot;&gt;
LEAF ::= {a sequence of character that doesn't contain '(', ')', ' ', '\n', or '&quot;'}
TREE ::= LEAF | (TREE ... TREE)
&lt;/pre&gt;
&lt;p&gt;I also define the symbol &lt;code&gt;STRING&lt;/code&gt; to be a double-quoted string.&lt;/p&gt;
&lt;p&gt;Note that the examples codes below usually assumes that the core library is already included.&lt;/p&gt;
&lt;h2&gt;constant&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;constant&lt;/code&gt; declares an external constant.&lt;/p&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(constant unsafe.cast
  (Π ((A tau)
      (B tau)
      (x A))
     B))

(let foo (unsafe.cast i64 string 1)) ; foo : string
&lt;/pre&gt;
&lt;h3&gt;Syntax&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(constant LEAF TREE)
&lt;/pre&gt;
&lt;h3&gt;Semantics&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;(constant x t)&lt;/code&gt; modifies the state of the compiler so that the &lt;a href=&quot;https://github.com/u2zv1wx/neut#constant&quot;&gt;constant&lt;/a&gt; &lt;code&gt;x&lt;/code&gt; of type &lt;code&gt;t&lt;/code&gt; is available in the succeeding code. Declared constants can then be available for use in the same way as ordinary &lt;a href=&quot;https://github.com/u2zv1wx/neut#upsilon&quot;&gt;variables&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;All the constants must have distinct names.&lt;/p&gt;
&lt;p&gt;This statement is currently intended only for internal use (e.g. implementation of a syscall). FFI might also be supported in future release via this statement.&lt;/p&gt;
&lt;h2&gt;ensure&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ensure&lt;/code&gt; fetches the content of the specified URL for later use.&lt;/p&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(ensure core/1.0.0.0
  &quot;https://github.com/u2zv1wx/neut-core/raw/master/release/0.1.0.0.tar.gz&quot;)

(include &quot;core/0.1.0.0/core.neut&quot;)
&lt;/pre&gt;
&lt;h3&gt;Syntax&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(ensure LEAF STRING)
&lt;/pre&gt;
&lt;h3&gt;Semantics&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;(ensure path URL)&lt;/code&gt; fetches the content of the specified URL, extracts the content into &lt;code&gt;~/.local/share/neut/NEUT_VERSION/path&lt;/code&gt;, assuming that the format of the archive is &lt;code&gt;tar.gz&lt;/code&gt;. The &lt;code&gt;path&lt;/code&gt; must be a valid path string. Every path separator in &lt;code&gt;path&lt;/code&gt; is treated “literally”. For example, if the &lt;code&gt;path&lt;/code&gt; is &lt;code&gt;some-library/0.2.0.0&lt;/code&gt;, the content of the archive is extracted into &lt;code&gt;~/.local/share/neut/NEUT_VERSION/some-library/0.2.0.0&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If the target directory of archive extraction already exists, &lt;code&gt;ensure&lt;/code&gt; does nothing.&lt;/p&gt;
&lt;p&gt;This statement is intended to be used in harmony with &lt;a href=&quot;https://github.com/u2zv1wx/neut#include&quot;&gt;include&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Archives specified in &lt;code&gt;ensure&lt;/code&gt; is expected to be the ones created via &lt;a href=&quot;https://github.com/u2zv1wx/neut#archive&quot;&gt;archive&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;enum&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;enum&lt;/code&gt; declares a new enum-type and its values.&lt;/p&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(enum choice left right) ; defines choice : tau, choice.left : choice, and choice.right : choice

(let x choice.left)

(i64.print
  (enum-elimination x
    (choice.left
      (i64 1))
     choice.right
      (i64 2))) ; ~&amp;gt; 1

(i64.print (unsafe.cast choice i64 choice.left)) ; ~&amp;gt; 0

(i64.print (unsafe.cast choice i64 choice.right)) ; ~&amp;gt; 1

(enum foo
  (a 100)
  b
  (c 20)
  d
  e
  (f 103))

(i64.print (unsafe.cast foo i64 foo.a)) ; ~&amp;gt; 100
(i64.print (unsafe.cast foo i64 foo.b)) ; ~&amp;gt; 101
(i64.print (unsafe.cast foo i64 foo.c)) ; ~&amp;gt; 20
(i64.print (unsafe.cast foo i64 foo.d)) ; ~&amp;gt; 21
(i64.print (unsafe.cast foo i64 foo.e)) ; ~&amp;gt; 22
(i64.print (unsafe.cast foo i64 foo.f)) ; ~&amp;gt; 103
&lt;/pre&gt;
&lt;h3&gt;Syntax&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(enum LEAF LEAF_INT ... LEAF_INT)

LEAF_INT := LEAF | (LEAF INT)
&lt;/pre&gt;
&lt;h3&gt;Semantics&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;(enum x a1 ... an)&lt;/code&gt; updates the state of the compiler so that the specified enum-type &lt;code&gt;x : tau&lt;/code&gt; and the enum-values &lt;code&gt;x.a1, ..., x.an : x&lt;/code&gt; can be used in its continuation.&lt;/p&gt;
&lt;p&gt;Every enum-value has its internal i64 value (discriminant). Those discriminant values can be extracted by using the constant &lt;code&gt;unsafe.cast&lt;/code&gt;, though usually not recommended.&lt;/p&gt;
&lt;p&gt;Discriminant value starts from &lt;code&gt;0&lt;/code&gt; by default, and increments one by one. The “current” value of this process can be modified by writing, e.g. &lt;code&gt;(enum foo a (b 100) c d)&lt;/code&gt;. In this example, the discriminant value of &lt;code&gt;c&lt;/code&gt; is set to be &lt;code&gt;101&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;All the discriminant values of an enum-type must be distinct.&lt;/p&gt;
&lt;h2&gt;erase&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;erase&lt;/code&gt; makes given variable invisible in its continuation.&lt;/p&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(define helper (x)
  (add-i64 x 1))

(define f (x)
  (mul-i64 (helper x) 2))

(f 10)        ; ~&amp;gt; 22

(helper 10)   ; ~&amp;gt; 11

(erase helper)

(f 10)        ; ~&amp;gt; 22

; (helper 10) ; ~&amp;gt; undefined variable: helper
&lt;/pre&gt;
&lt;h3&gt;Syntax&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(erase LEAF)
&lt;/pre&gt;
&lt;h3&gt;Semantics&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;erase&lt;/code&gt; makes given variable invisible in its continuation.&lt;/p&gt;
&lt;h2&gt;include&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;include&lt;/code&gt; “pastes” the content of the specified file.&lt;/p&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(include &quot;core/0.1.0.0/free.neut&quot;)

(include &quot;./relative/path/from/the/dir/path/of/this/file.neut&quot;)
&lt;/pre&gt;
&lt;h3&gt;Syntax&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(include STRING)
&lt;/pre&gt;
&lt;h3&gt;Semantics&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
{CODE_1}

(include STRING)

{CODE_2}

~&amp;gt;

{CODE_1}

{THE_CONTENT_OF_THE_FILE_SPECIFIED_BY_THE_STRING}

{CODE_2}
&lt;/pre&gt;
&lt;p&gt;With the following notes:&lt;/p&gt;
&lt;p&gt;(1) If the first character of the path is dot (“.”), the path is interpreted as a relative one. That is, the path is calculated using the current file’s directory as the base path. Otherwise, the base path is set to be the library path (i.e. &lt;code&gt;~/.local/share/neut/NEUT_VERSION/library&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;(2) If the file is already included, &lt;code&gt;include&lt;/code&gt; does nothing.&lt;/p&gt;
&lt;p&gt;(3) When including a file, &lt;a href=&quot;https://github.com/u2zv1wx/neut#useunuse&quot;&gt;the prefix environment&lt;/a&gt; must be empty.&lt;/p&gt;
&lt;p&gt;(4) Cyclic inclusion is invalid.&lt;/p&gt;
&lt;h2&gt;inductive&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;inductive&lt;/code&gt; defines an inductive type, its introduction rules (constructors), and its pattern match function.&lt;/p&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(inductive list ((a tau))
  (nil ()
    (list a))
  (cons ((_ a) (_ (list a)))
    (list a)))

(define length
  ((a tau)
   (xs (list a)))
  (list.case i64 a xs
    (λ ()
      0)
    (λ (_ ys)
      (add-i64 1 (length a ys)))))

(let xs (list.cons * 10 (list.cons * 20 (list.nil i64))))

(i64.print (length xs)) ; ~&amp;gt; 2

; mutually inductive types
(inductive
  (even ((_ (nat)))
    (zero-is-even
      ()
      (even (nat.zero)))
    (succ-of-odd-is-even
      ((n (nat))
       (_ (odd n)))
      (even (nat.succ n))))
  (odd ((_ (nat)))
    (succ-of-even-is-odd
      ((n (nat))
       (_ (even n)))
      (odd (nat.succ n)))))
&lt;/pre&gt;
&lt;h3&gt;Syntax&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(inductive LEAF ((LEAF TREE) ... (LEAF TREE))
  (LEAF ((LEAF TREE) ... (LEAF TREE))
    TREE)
  ...
  (LEAF ((LEAF TREE) ... (LEAF TREE))
    TREE))

; n-mutual inductive type
(inductive
  (LEAF ((LEAF TREE) ... (LEAF TREE))
    (LEAF ((LEAF TREE) ... (LEAF TREE))
      TREE)
    ...
    (LEAF ((LEAF TREE) ... (LEAF TREE))
      TREE))
  ...
  (LEAF ((LEAF TREE) ... (LEAF TREE))
    (LEAF ((LEAF TREE) ... (LEAF TREE))
      TREE)
    ...
    (LEAF ((LEAF TREE) ... (LEAF TREE))
      TREE)))
&lt;/pre&gt;
&lt;h3&gt;Semantics&lt;/h3&gt;
&lt;p&gt;When parsed, the &lt;code&gt;inductive&lt;/code&gt; statement is translated into the &lt;code&gt;let&lt;/code&gt; statements that defines (1) the inductive type, (2) the introduction rules (or the constructors of the inductive type), and (3) the pattern match function. For example, consider the following &lt;code&gt;inductive&lt;/code&gt; statement:&lt;/p&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(inductive list ((a tau))
  (nil ()
    (list a))
  (cons ((_ a) (_ (list a)))
    (list a)))
&lt;/pre&gt;
&lt;p&gt;Given this statement, the compiler generates the &lt;code&gt;let&lt;/code&gt; statements that define the followings:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;The inductive type &lt;code&gt;list : Pi (a : tau). tau&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The introduction rules (constructors) of the type:
&lt;ul&gt;&lt;li&gt;&lt;code&gt;list.nil : Pi (a : tau). list a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;list.cons : Pi (a : tau, _ : a, _ : list a). list a&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;The pattern matching function of the type:
&lt;ul&gt;&lt;li&gt;&lt;code&gt;list.case : Π (z : tau, a : tau, _ : list a, on-nil : Π (). z, on-cons : Π (_ : a, _ : list a). z). z&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;The structure of a pattern matching function is: &lt;code&gt;Π (RESULT_TYPE : tau, {ARGUMENTS_OF_THE_INDUCTIVE_TYPE}, {THE_TERM_BEING_MATCHED}, {LIST_OF_CLAUSES}). RESULT_TYPE&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The codomain of each constructor must be of the form &lt;code&gt;(a e1 ... en)&lt;/code&gt;, where the &lt;code&gt;a&lt;/code&gt; is the inductive type being defined. For example,&lt;/p&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(inductive foo ((x bool))
  (bar () i64))
&lt;/pre&gt;
&lt;p&gt;is an invalid &lt;code&gt;inductive&lt;/code&gt; statement, since the codomain of &lt;code&gt;bar&lt;/code&gt; is not of the form &lt;code&gt;(foo _)&lt;/code&gt;, but &lt;code&gt;i64&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;introspect&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;introspect&lt;/code&gt; introspects the state of the compiler and selects statements by those information.&lt;/p&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(introspect OS
  (linux
    (include library &quot;constant/linux.neut&quot;))
  (darwin
    (include library &quot;constant/darwin.neut&quot;)))
&lt;/pre&gt;
&lt;h3&gt;Syntax&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(introspect LEAF (LEAF TREE ... TREE) ... (LEAF TREE ... TREE))
&lt;/pre&gt;
&lt;h3&gt;Semantics&lt;/h3&gt;
&lt;pre lang=&quot;text&quot;&gt;
(introspect VAR
  (VAR-1 stmt-1-1 ... stmt-1-n{1})
  ...
  (VAR-m stmt-m-1 ... stmt-m-n{m}))

~&amp;gt;

(stmt-i-1)
...
(stmt-i-n)

[where VAR == VAR-i]
&lt;/pre&gt;
&lt;p&gt;If the corresponding value is not found in the clause list, this statement does nothing.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;var&lt;/code&gt; in &lt;code&gt;(introspect var (...))&lt;/code&gt; must be a valid compile-time variable. The valid compile-time variables and its possible values are currently as in the table below:&lt;/p&gt;
&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;compile-time variable&lt;/th&gt;
&lt;th&gt;possible values&lt;/th&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;OS&lt;/td&gt;
&lt;td&gt;linux, darwin&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;architecture&lt;/td&gt;
&lt;td&gt;x64&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;notation&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;notation&lt;/code&gt; statement registers a notation (macro).&lt;/p&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(notation λ Π-introduction)

((λ (x) (add-i64 x 1)) 10) ; ~&amp;gt; 11

(notation switch enum-elimination)

(notation (if b e1 e2)
  (switch b
    (bool.true e1)
    (bool.false e2)))
&lt;/pre&gt;
&lt;h3&gt;Syntax&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(notation TREE TREE)
&lt;/pre&gt;
&lt;h3&gt;Semantics&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;(notation FROM TO)&lt;/code&gt; modifies the state of the compiler so that the mapping &lt;code&gt;FROM ~&amp;gt; TO&lt;/code&gt; is recognized as a notation (macro). This affects the result of macro expansion in the succeeding code.&lt;/p&gt;
&lt;h3&gt;Notes on Macro Expansion&lt;/h3&gt;
&lt;p&gt;Macro-expansion in Neut is a process of applying &lt;strong&gt;step-expansion&lt;/strong&gt; recursively.&lt;/p&gt;
&lt;p&gt;I believe this step-expansion process is best explained by example. Consider we have defined a notation as follows:&lt;/p&gt;
&lt;pre lang=&quot;text&quot;&gt;
(notation (if b e1 e2)
  (switch b
    (bool.true e1)
    (bool.false e2)))
&lt;/pre&gt;
&lt;p&gt;Also suppose that we have the following AST:&lt;/p&gt;
&lt;pre lang=&quot;text&quot;&gt;
(if some-condition
  (i64.print 10)
  (string.print &quot;hello&quot;))
&lt;/pre&gt;
&lt;p&gt;In this situation, the compiler creates the following substitution:&lt;/p&gt;
&lt;pre lang=&quot;text&quot;&gt;
b  ~&amp;gt; some-condition
e1 ~&amp;gt; (i64.print 10)
e2 ~&amp;gt; (string.print &quot;hello&quot;)
&lt;/pre&gt;
&lt;p&gt;and then replaces &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;e1&lt;/code&gt;, and &lt;code&gt;e2&lt;/code&gt; in the codomain of the notation according to this substitution. The resulting tree is:&lt;/p&gt;
&lt;pre lang=&quot;text&quot;&gt;
(switch some-condition
  (bool.true (i64.print 10))
  (bool.false (string.print &quot;hello&quot;)))
&lt;/pre&gt;
&lt;p&gt;Given this step-expansion, macro-expansion is schematically defined as follows.&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-haskell&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-en&quot;&gt;macroExpand&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Tree&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Tree&lt;/span&gt;
macroExpand inputTree &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;case&lt;/span&gt; inputTree &lt;span class=&quot;pl-k&quot;&gt;of&lt;/span&gt;
    &lt;span class=&quot;pl-ent&quot;&gt;Leaf&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;-&amp;gt;&lt;/span&gt;
      recurseOrReturn (&lt;span class=&quot;pl-ent&quot;&gt;Leaf&lt;/span&gt; x)
    &lt;span class=&quot;pl-ent&quot;&gt;Node&lt;/span&gt; t1 &lt;span class=&quot;pl-k&quot;&gt;...&lt;/span&gt; tn &lt;span class=&quot;pl-k&quot;&gt;-&amp;gt;&lt;/span&gt;
      recurseOrReturn (&lt;span class=&quot;pl-ent&quot;&gt;Node&lt;/span&gt; (macroExpand t1) &lt;span class=&quot;pl-k&quot;&gt;...&lt;/span&gt; (macroExpand tn))

&lt;span class=&quot;pl-en&quot;&gt;recurseOrReturn&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Tree&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Tree&lt;/span&gt;
recurseOrReturn t &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;case&lt;/span&gt; stepExpand t &lt;span class=&quot;pl-k&quot;&gt;of&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;--&lt;/span&gt; if there exists a notation that step-expands `t`, with resulting subtitution `sub`&lt;/span&gt;
    &lt;span class=&quot;pl-ent&quot;&gt;Just&lt;/span&gt; sub &lt;span class=&quot;pl-k&quot;&gt;-&amp;gt;&lt;/span&gt;
      macroExpand (applySubstitution sub t)
    &lt;span class=&quot;pl-ent&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;-&amp;gt;&lt;/span&gt;
      t
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(The pseudo-code above is intended to be call-by-value)&lt;/p&gt;
&lt;p&gt;You may want to use this statement with &lt;a href=&quot;https://github.com/u2zv1wx/neut#erase-1&quot;&gt;erase&lt;/a&gt; to accomplish (a certain sort of) safety.&lt;/p&gt;
&lt;h2&gt;let&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;let&lt;/code&gt; evaluates given term and binds the result to the specified variable.&lt;/p&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(let foo (i64 10)) ; define a variable `foo` to be `10`

(i64.print foo) ; ~&amp;gt; 10 (this is equivalent to `(let _ (i64.print foo))`)

(let (bar i64) 20) ; `let` with type annotation

(i64.print bar) ; ~&amp;gt; 20

; `define` is defined in `core/&amp;lt;VERSION&amp;gt;/notation.neut` as follows:
; (notation (define f xts e)
;   (let f (fix f xts e)))
;
; (notation (define f e)
;   (let f e))
;

; ordinary definition (i.e. 1-mutual definition)
(define fact ((x i64))
  (if (icmp-sle-i64 x 0) ; compare (by less-than-or-equal) two `i64`s as signed integers
    1
    (mul-i64 x (fact (sub-i64 x 1)))))

(i64.print (fact foo)) ; ~&amp;gt; 3628800 (= 10!)

; mutual recursion can be realized as in the ordinary way:
(define even-f ((f (hom i64 bool)) (n i64))
  (if (icmp-eq-i64 n 0)
    true
    (f (sub-i64 n 1))))

(define odd ((n i64))
  (if (icmp-eq-i64 n 0)
    false
    (even-f odd (sub-i64 n 1))))

(define even ((n i64))
  (even-f odd n))

(i64.print
  (if (even 10)
    100
    1000)) ; ~&amp;gt; 100
&lt;/pre&gt;
&lt;h3&gt;Syntax&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(let LEAF_PLUS TREE)

LEAF_PLUS ::= LEAF | (LEAF TREE)
&lt;/pre&gt;
&lt;h3&gt;Semantics&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;(let x e)&lt;/code&gt; checks the type of the term &lt;code&gt;e&lt;/code&gt;, evaluates the term &lt;code&gt;e&lt;/code&gt;, then defines a variable &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;e&lt;/code&gt; as its content. &lt;code&gt;x&lt;/code&gt; is available in the continuation. The type of &lt;code&gt;x&lt;/code&gt; can be annotated to be &lt;code&gt;t&lt;/code&gt; by writing &lt;code&gt;(let (x t) e)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If a user input &lt;code&gt;e&lt;/code&gt; is not parsed as a statement when it is supposed to be, the compiler interprets it as &lt;code&gt;(let _ e)&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;record&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;record&lt;/code&gt; statement creates a record type, its elimination rules (destructors), and its introduction rule.&lt;/p&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(record my-record ((a tau))
  (item-1
    a)
  (item-2
    i64)
  (item-3
    top))

(let item
  (my-record.new
    i64
    10
    20
    top.unit))

(i64.print (my-record.item-1 i64 item)) ; ~&amp;gt; 10

(i64.print (my-record.item-2 i64 item)) ; ~&amp;gt; 20
&lt;/pre&gt;
&lt;h3&gt;Syntax&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(inductive LEAF ((LEAF TREE) ... (LEAF TREE))
  (LEAF TREE)
  ...
  (LEAF TREE))
&lt;/pre&gt;
&lt;h3&gt;Semantics&lt;/h3&gt;
&lt;p&gt;When parsed, the &lt;code&gt;record&lt;/code&gt; statement is translated into &lt;code&gt;let&lt;/code&gt; statements that defines (1) the record type, (2) the elimination rules (or the destructors of the record type), and (3) the introduction rule. For example, consider the following &lt;code&gt;record&lt;/code&gt; statement:&lt;/p&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(record my-record ((a tau))
  (item-1
    a)
  (item-2
    i64)
  (item-3
    top))
&lt;/pre&gt;
&lt;p&gt;Given this statement, the compiler generates &lt;a href=&quot;https://github.com/u2zv1wx/neut#definelet&quot;&gt;let&lt;/a&gt; statements that define the followings:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;The record type &lt;code&gt;my-record : Pi (a : tau). tau&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The elimination rules (destructors) of the type:
&lt;ul&gt;&lt;li&gt;&lt;code&gt;my-record.item-1 : Pi (a : tau, _ : my-record a). a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;my-record.item-2 : Pi (a : tau, _ : my-record a). i64&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;my-record.item-3 : Pi (a : tau, _ : my-record a). top&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;The introduction rule of the type:
&lt;ul&gt;&lt;li&gt;&lt;code&gt;my-record.new : Π (a : tau, item-1 : a, item-2 : i64, item-3 : top). my-record a&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Internally, every record statement is translated into the corresponding &lt;a href=&quot;https://github.com/u2zv1wx/neut#inductive&quot;&gt;inductive&lt;/a&gt; statement. For example, given the &lt;code&gt;record&lt;/code&gt; statement above, the compiler translates it into the following &lt;code&gt;inductive&lt;/code&gt; statement:&lt;/p&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(inductive my-record ((a tau))
  (new
    ((item-1 a)
     (item-2 i64)
     (item-3 top))
    (my-record a)))
&lt;/pre&gt;
&lt;p&gt;The compiler then processes this statement in the same way ordinary &lt;code&gt;inductive&lt;/code&gt; statement, generating the record type &lt;code&gt;my-record&lt;/code&gt; and the introduction rule &lt;code&gt;my-record.new&lt;/code&gt;, and the pattern matching function &lt;code&gt;my-record.case&lt;/code&gt;. After that, the compiler automatically generates destructors from this definition via &lt;code&gt;my-record.case&lt;/code&gt;. For example, the generated definition of &lt;code&gt;my-record.item-1&lt;/code&gt; is as follows:&lt;/p&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(define my-record.item-1 ((a tau) (record-value (my-record a)))
  (my-record.case a record-value
    (λ (item-1 item-2 item-3) item-1)))
&lt;/pre&gt;
&lt;p&gt;The other destructors are defined similarly.&lt;/p&gt;
&lt;h2&gt;use/unuse&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;use&lt;/code&gt; inserts a prefix to the prefix environment. &lt;code&gt;unuse&lt;/code&gt; removes a prefix from the prefix environment.&lt;/p&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(let foo.bar.buz (i64 10))

(i64.print buz)         ; ~&amp;gt; undefined variable: `buz`
(i64.print bar.buz)     ; ~&amp;gt; undefined variable: `bar.buz`
(i64.print foo.bar.buz) ; ~&amp;gt; 10

(use foo)

(i64.print buz)         ; ~&amp;gt; undefined variable: `buz`
(i64.print bar.buz)     ; ~&amp;gt; 10
(i64.print foo.bar.buz) ; ~&amp;gt; 10

(use foo.bar)

(i64.print buz)         ; ~&amp;gt; 10
(i64.print bar.buz)     ; ~&amp;gt; 10
(i64.print foo.bar.buz) ; ~&amp;gt; 10

(unuse foo)

(i64.print buz)         ; ~&amp;gt; 10
(i64.print bar.buz)     ; ~&amp;gt; undefined variable: `bar.buz`
(i64.print foo.bar.buz) ; ~&amp;gt; 10
&lt;/pre&gt;
&lt;h3&gt;Syntax&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(use LEAF)

(unuse LEAF)
&lt;/pre&gt;
&lt;h3&gt;Semantics&lt;/h3&gt;
&lt;p&gt;When parsed, the statement &lt;code&gt;(use PREFIX)&lt;/code&gt; inserts &lt;code&gt;PREFIX&lt;/code&gt; at the head of the prefix environment, which is a list of prefixes.&lt;/p&gt;
&lt;p&gt;When parsed, the statement &lt;code&gt;(unuse PREFIX)&lt;/code&gt; removes &lt;code&gt;PREFIX&lt;/code&gt; from the prefix environment. If the &lt;code&gt;PREFIX&lt;/code&gt; is not contained in the environment, the &lt;code&gt;unuse&lt;/code&gt; statement does nothing.&lt;/p&gt;
&lt;p&gt;The prefix environment modifies &lt;a href=&quot;https://github.com/u2zv1wx/neut#upsilon&quot;&gt;how the compiler interprets a variable&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;section/end&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;section&lt;/code&gt; - &lt;code&gt;end&lt;/code&gt; automatically adds the specified prefix to the variables defined by &lt;code&gt;let&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(section pohe)

(let foo (i64 10))

(section qux)

(let bar (i64 20))

(i64.print foo)          ; ~&amp;gt; 10
(i64.print pohe.foo)     ; ~&amp;gt; 10

(i64.print bar)          ; ~&amp;gt; 20
(i64.print qux.bar)      ; ~&amp;gt; 20
(i64.print pohe.qux.bar) ; ~&amp;gt; 20

(end qux)

(i64.print foo)          ; ~&amp;gt; 10
(i64.print pohe.foo)     ; ~&amp;gt; 10

(i64.print bar)          ; ~&amp;gt; undefined variable
(i64.print qux.bar)      ; ~&amp;gt; 20
(i64.print pohe.qux.bar) ; ~&amp;gt; 20

(end pohe)

(i64.print foo)          ; ~&amp;gt; undefined variable
(i64.print pohe.foo)     ; ~&amp;gt; 10

(i64.print bar)          ; ~&amp;gt; undefined variable
(i64.print qux.bar)      ; ~&amp;gt; undefined variable
(i64.print pohe.qux.bar) ; ~&amp;gt; 20
&lt;/pre&gt;
&lt;h3&gt;Syntax&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(section LEAF)

(end LEAF)
&lt;/pre&gt;
&lt;h3&gt;Semantics&lt;/h3&gt;
&lt;p&gt;The list of statement&lt;/p&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(section FOO)
(let x1 e1)
...
(let xn en)
(end FOO)
&lt;/pre&gt;
&lt;p&gt;is equivalent to:&lt;/p&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(use FOO)
(let FOO.x1 e1)
...
(let FOO.xn en)
(unuse FOO)
&lt;/pre&gt;
&lt;p&gt;In other words, the &lt;code&gt;section&lt;/code&gt; - &lt;code&gt;end&lt;/code&gt; statement&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;inserts &lt;a href=&quot;https://github.com/u2zv1wx/neut#useunuse&quot;&gt;use / unuse&lt;/a&gt; at the beginning and the end of the section&lt;/li&gt;
&lt;li&gt;adds the name of the section as a prefix of the variables defined by &lt;code&gt;let&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;keeps all the other statements in the section intact&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Each &lt;code&gt;section&lt;/code&gt; must be paired with an &lt;code&gt;end&lt;/code&gt; with the corresponding name.&lt;/p&gt;

&lt;h2&gt;tau&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;tau&lt;/code&gt; is the type of types.&lt;/p&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(define id ((a tau) (x a)) x)

(id i64 10)
&lt;/pre&gt;
&lt;h3&gt;Syntax&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
tau
&lt;/pre&gt;
&lt;h3&gt;Inference Rule&lt;/h3&gt;
&lt;pre lang=&quot;text&quot;&gt;
-------------------(empty)
well-formed(EMPTY)


well-formed(Γ)
--------------- (tau)
Γ |- tau : tau
&lt;/pre&gt;
&lt;h3&gt;Semantics&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;tau&lt;/code&gt; doesn’t have any operational semantics.&lt;/p&gt;
&lt;h2&gt;variable&lt;/h2&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(let x (i64 10))

(i64.print x) ; ~&amp;gt; 10

(let _ (i64 20)) ; anonymous variable
&lt;/pre&gt;
&lt;h3&gt;Syntax&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
LEAF
&lt;/pre&gt;
&lt;h3&gt;Inference Rule&lt;/h3&gt;
&lt;pre lang=&quot;text&quot;&gt;
    Γ |- A : tau
------------------------- (ext)
well-formed(Γ, x : A)


well-formed(Γ)  (x : A) ∈ Γ
---------------------------- (var)
       Γ |- x : A
&lt;/pre&gt;
&lt;h3&gt;Semantics&lt;/h3&gt;
&lt;p&gt;A variable doesn’t have any operational semantics by itself.&lt;/p&gt;
&lt;h3&gt;Notes&lt;/h3&gt;
&lt;p&gt;If a leaf is not parsed into any other syntactic construct, the leaf &lt;code&gt;x&lt;/code&gt; is regarded as a variable.&lt;/p&gt;
&lt;p&gt;The name of a variable is interpreted in relation with the keyword environment. For example, if the keyword environment is &lt;code&gt;[&quot;foo&quot;, &quot;bar&quot;, &quot;buz&quot;]&lt;/code&gt;, the name &lt;code&gt;qux&lt;/code&gt; is interpreted in the following way:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Look up a bound variable named &lt;code&gt;qux&lt;/code&gt; in current scope.&lt;/li&gt;
&lt;li&gt;If not found, look up a bound variable named &lt;code&gt;foo.qux&lt;/code&gt; in current scope.&lt;/li&gt;
&lt;li&gt;If not found, look up a bound variable named &lt;code&gt;bar.qux&lt;/code&gt; in current scope.&lt;/li&gt;
&lt;li&gt;If not found, look up a bound variable named &lt;code&gt;buz.qux&lt;/code&gt; in current scope.&lt;/li&gt;
&lt;li&gt;If not found, report the error: “undefined variable”.&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;Π&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Π&lt;/code&gt; is the universal quantification.&lt;/p&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
; unary Π-introduction
(let f2
  (Π-introduction ((x i64)) x))

; Π-elimination
(Π-elimination i64.print (Π-elimination f2 2))

; Π-elimination with the familar (or, implicit) syntax
(i64.print (f2 2))

; nullary Π-introduction
(let f1
  (lambda () (i64 1))) ; 'lambda' can be used instead of 'Π-introduction'

; binary Π-introduction
(let f3
  (λ ((x i64)   ; an argument with type annotation
      y)        ; an argument without type annotation
    (i64.add x y)))

(i64.print (f3 1 2))
&lt;/pre&gt;
&lt;h3&gt;Syntax&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(Π (LEAF_PLUS*) B)
(Π-introduction (LEAF_PLUS*) e)
(Π-elimination TREE+)
(TREE+)

LEAF_PLUS ::= LEAF | (LEAF TREE)
&lt;/pre&gt;
&lt;h3&gt;Inference Rule&lt;/h3&gt;
&lt;pre lang=&quot;text&quot;&gt;
Γ |- A1 : tau    Γ, x1 : A1 |- A2 : tau    (...)    Γ, x1 : A1, ..., xn : An |- B : tau
---------------------------------------------------------------------------------------- (Π)
                    Γ |- (Π ((x1 A1) ... (xn An)) B) : tau


             Γ, x1 : A1, ..., xn : An |- e : B
------------------------------------------------------------------------------- (Π-introduction)
 Γ |- (Π-introduction ((x1 A1) ... (xn An)) e) : (Π ((x1 A1) ... (xn An)) B)


Γ |- e : (Π ((x1 A1) ... (xn An)) B)   Γ |- e1 : A1   (...)   Γ |- en : An {xi := ei}
-------------------------------------------------------------------------------------- (Π-elimination)
              Γ |- (Π-elimination e e1 ... en) : B {xi := ei}
&lt;/pre&gt;
&lt;h3&gt;Semantics&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(Π-elimination e e1 ... en)
~&amp;gt; (Π-elimination v v1 ... vn)  [i.e. reduce e and ei into the values v and vi, from left to right]

(Π-elimination (Π-introduction ((x1 A1) ... (xn An)) e) v1 ... vn)
~&amp;gt; e {x1 := v1, ..., xn := vn}
&lt;/pre&gt;
&lt;h3&gt;Notes&lt;/h3&gt;
&lt;p&gt;If a tree &lt;code&gt;(e e1 ... en)&lt;/code&gt; is not parsed into any other terms, the tree is regarded as &lt;code&gt;(Π-elimination e e1 ... en)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If the name of an argument of a Π-introduction is “_”, the compiler automatically generates a fresh name so that the variable cannot be used in its scope.&lt;/p&gt;
&lt;p&gt;Note that the arguments of a lambda-abstraction is generalized from unary to n-ary. This enables the compiler to emit more performant code when a lambda-abstraction receives multiple arguments; Without that generalization, the arguments must be represented as a tuple, discarding the possibility to pass the arguments of a function using multiple registers.&lt;/p&gt;
&lt;p&gt;Some additional notations for Π are defined in &lt;code&gt;core/VERSION/notation.neut&lt;/code&gt;:&lt;/p&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(notation forall Π)

(notation Pi Π)

(notation lambda Π-introduction)

(notation λ Π-introduction)

; tells the compiler that the type of `e` is `t`
(notation (witness t e)
  ((λ ((x t)) x) e))
&lt;/pre&gt;
&lt;p&gt;Incidentally, I personally recommend you to use the &lt;code&gt;witness&lt;/code&gt; notation above when defining a function to write the resulting type of the function explicitly. For example, the code&lt;/p&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(define fact ((x i64))
  (witness i64
    (if (icmp-sle-i64 x 0)
      1
      (mul-i64 x (fact (sub-i64 x 1))))))
&lt;/pre&gt;
&lt;p&gt;is preferred to:&lt;/p&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(define fact ((x i64))
  (if (icmp-sle-i64 x 0)
    1
    (mul-i64 x (fact (sub-i64 x 1)))))
&lt;/pre&gt;
&lt;h2&gt;fix&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;fix&lt;/code&gt; is for recursion.&lt;/p&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(let fact
  (fix self ((x i64))
    (if (icmp-sle-i64 x 0) ; i.e. if x &amp;lt;= 0
      1
      (mul-i64 x (self (sub-i64 x 1))))))
&lt;/pre&gt;
&lt;h3&gt;Syntax&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(fix LEAF_PLUS (LEAF_PLUS ... LEAF_PLUS) TREE)

LEAF_PLUS ::= LEAF | (LEAF TREE)
&lt;/pre&gt;
&lt;h3&gt;Inference Rule&lt;/h3&gt;
&lt;pre lang=&quot;text&quot;&gt;
Γ, f : (Π ((x1 A1) ... (xn An)) B), x1 : A1, ..., xn : An |- e : B
-------------------------------------------------------------------- (fix)
Γ |- (fix f ((x1 A1) ... (xn An)) e) : (Π ((x1 A1) ... (xn An)) B)
&lt;/pre&gt;
&lt;h3&gt;Semantics&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(Π-elimination (fix self ((x1 A1) ... (xn An)) e) v1 ... vn)
~&amp;gt; e {x1 := v1,
      ...,
      xn := vn,
      self := (fix self ((x1 A1) ... (xn An)) e)}
&lt;/pre&gt;
&lt;h3&gt;Notes&lt;/h3&gt;
&lt;p&gt;Every tail call is optimized into a loop.&lt;/p&gt;
&lt;p&gt;The logic of Neut doesn’t adopt the universe hierarchy, and thus inconsistent. This means that the Z combinator can be written in the source language as an ordinary term. In other words, from the viewpoint of expressive power, &lt;code&gt;fix&lt;/code&gt; is simply redundant. The existence of &lt;code&gt;fix&lt;/code&gt; is just for optimization purpose.&lt;/p&gt;
&lt;h2&gt;constant&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;constant&lt;/code&gt; is for external constants.&lt;/p&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
((constant add-i64) 1 3) ; ~&amp;gt; 4
(add-i64 1 3)            ; ~&amp;gt; 4
&lt;/pre&gt;
&lt;h3&gt;Syntax&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(constant LEAF)
LEAF
&lt;/pre&gt;
&lt;h3&gt;Inference Rule&lt;/h3&gt;
&lt;pre lang=&quot;text&quot;&gt;
Γ |- A : tau          {`c` is declared to be a constant of type `A`}
--------------------------------------------------------------------- (constant)
         Γ |- (constant c) : A
&lt;/pre&gt;
&lt;h3&gt;Semantics&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;constant&lt;/code&gt; rule doesn’t have any operational semantics by itself; Each constant has its own dedicated semantics.&lt;/p&gt;
&lt;h3&gt;Notes&lt;/h3&gt;
&lt;p&gt;If a leaf is declared to be a constant using the &lt;a href=&quot;https://github.com/u2zv1wx/neut#constant&quot;&gt;constant&lt;/a&gt; statement beforehand, the leaf is interpreted as &lt;code&gt;(constant LEAF)&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;int&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;i{n}&lt;/code&gt; is the integer type in LLVM.&lt;/p&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(add-i64 (i64 1) 2)
(i32 10)
23456789
(mul-i2 (i2 100) 3)
&lt;/pre&gt;
&lt;h3&gt;Syntax&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
; the integer type i{n}
i{n} [where n is one of 1, 2, ..., 64]

; an integer of type i{n}
(i{n} LEAF)  [where n is one of 1, 2, ..., 64]

; an integer without explicit type info
LEAF [where this LEAF can be parsed as integer]
&lt;/pre&gt;
&lt;h3&gt;Inference Rule&lt;/h3&gt;
&lt;pre lang=&quot;text&quot;&gt;
well-formed(Γ)     {`l` is an integer}     {i{n} is a valid integer type}
--------------------------------------------------------------------------- (integer)
                  Γ |- (i{n} l) : i{n}
&lt;/pre&gt;
&lt;h3&gt;Semantics&lt;/h3&gt;
&lt;p&gt;The terms of an integer type don’t have any operational semantics by themselves.&lt;/p&gt;
&lt;h3&gt;Notes&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;int&lt;/code&gt; type in Neut is the same as the one of LLVM, restricted into &lt;code&gt;i1&lt;/code&gt;, &lt;code&gt;i2&lt;/code&gt;, …, &lt;code&gt;i64&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Every integer of type &lt;code&gt;i{n}&lt;/code&gt; is interpreted modulo &lt;code&gt;2^n&lt;/code&gt;, just as in the same way of LLVM. For example, &lt;code&gt;(i2 10)&lt;/code&gt; is the same as &lt;code&gt;(i2 6)&lt;/code&gt;, &lt;code&gt;(i2 2)&lt;/code&gt;, &lt;code&gt;(i2 -2)&lt;/code&gt;, or &lt;code&gt;(i2 -6)&lt;/code&gt;, since all of these are equivalent modulo &lt;code&gt;2^2&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;An integer without explicit type information is overloaded; it’s type is firstly set to be unknown, and then inferred.&lt;/p&gt;
&lt;h2&gt;float&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;f{n}&lt;/code&gt; is the float type in LLVM.&lt;/p&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(f16 3.8)
(f32 9.22888)
(f64 1.23456789)
(fadd-f64 1.23456 (f64 7.89))
&lt;/pre&gt;
&lt;h3&gt;Syntax&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
; the float type f{n}
f{n}   [where n is one of 16, 32, 64]

; a float of type f{n}
(f{n} LEAF) [where n is one of 16, 32, 64]

LEAF [where this LEAF can be parsed as float]
&lt;/pre&gt;
&lt;h3&gt;Inference Rule&lt;/h3&gt;
&lt;pre lang=&quot;text&quot;&gt;
well-formed(Γ)     {`l` is a float}      {f{n} is a valid float type}
------------------------------------------------------------------------ (float)
                  Γ |- l : f{n}
&lt;/pre&gt;
&lt;h3&gt;Semantics&lt;/h3&gt;
&lt;p&gt;The terms of a float type don’t have any operational semantics by themselves.&lt;/p&gt;
&lt;h3&gt;Notes&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;float&lt;/code&gt; type in Neut is the same as the one of LLVM. Specifically, LLVM’s &lt;code&gt;half&lt;/code&gt; corresponds to Neut’s &lt;code&gt;f16&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt; to &lt;code&gt;f32&lt;/code&gt;, and &lt;code&gt;double&lt;/code&gt; to &lt;code&gt;f64&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;An float without explicit type information is overloaded; it’s type is firstly set to be unknown, and then inferred.&lt;/p&gt;
&lt;h2&gt;enum&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;enum&lt;/code&gt; is the enumeration type.&lt;/p&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;p&gt;See the example in &lt;a href=&quot;https://github.com/u2zv1wx/neut#enum&quot;&gt;the section about the enum statement&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Syntax&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(enum LEAF)

(enum-introduction LEAF)
LEAF

(enum-elimination TREE
  (ENUM_CASE TREE)
  ...
  (ENUM_CASE TREE))

ENUM_CASE ::= LEAF | default
&lt;/pre&gt;
&lt;h3&gt;Inference Rule&lt;/h3&gt;
&lt;pre lang=&quot;text&quot;&gt;
well-formed(Γ)  {`E` is declared to be an enum type}
----------------------------------------------------- (enum)
                 Γ |- (enum E) : tau


well-formed(Γ)   {`l` is a value of enum-type `(enum E)`}
----------------------------------------------------------- (enum-introduction)
       Γ |- (enum-introduction l) : (enum E)


Γ |- e : (enum E)       (Γ |- e_l : A) for all l ∈ E = {l1, ..., ln}
---------------------------------------------------------------------- (enum-elimination)
       Γ |- (enum-elimination e (l1 e1) ... (ln en)) : A
&lt;/pre&gt;
&lt;h3&gt;Semantics&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(enum-elimination (enum-introduction c)
  (c1 e1)
  ...
  (cn en))
~&amp;gt; ei [where c = ci]

(enum-elimination (enum-introduction c)
  (c1 e1)
  ...
  (cn en)
  (default e)
  ...)
~&amp;gt; e [where e != e1, ..., en]
&lt;/pre&gt;
&lt;h3&gt;Notes&lt;/h3&gt;
&lt;p&gt;The cases of an enum-elimination must be exhaustive.&lt;/p&gt;
&lt;h2&gt;array&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;array&lt;/code&gt; is the array type in LLVM.&lt;/p&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
; float array
(let _
  (array-introduction f16 3.28 2.14 2.0 9.82))

(let xs
  (array-introduction i64 1 2 -30 20))

(let k
  (with identity.bind
    (let a (i64.array-access 0 4 &amp;amp;xs))
    (let b (i64.array-access 1 4 &amp;amp;xs))
    (let c (i64.array-access 2 4 &amp;amp;xs))
    (let d (i64.array-access 3 4 &amp;amp;xs))
    (erase xs)
    (i64.add a (i64.add b (i64.add c d)))))

(i64.print k) ; -7

(i64.print
  (array-elimination i64 (a b c d) xs
    (i64.add a (i64.add b (i64.add c d))))) ; -7
&lt;/pre&gt;
&lt;h3&gt;Syntax&lt;/h3&gt;
&lt;pre lang=&quot;text&quot;&gt;
; the array type
(array TREE LOWTYPE)

(array-introduction LOWTYPE TREE ... TREE)

(array-elimination LOWTYPE (LEAF_PLUS ... LEAF_PLUS) TREE TREE)

LOWTYPE ::= i{n} | f{n}

LEAF_PLUS ::= LEAF | (LEAF TREE)
&lt;/pre&gt;
&lt;h3&gt;Inference Rule&lt;/h3&gt;
&lt;pre lang=&quot;text&quot;&gt;
Γ |- len : i64    {`k` is an integer type or a float type}
----------------------------------------------------------- (array)
              Γ |- (array len k) : tau


Γ |- l1 : k   ...  Γ |- ln : k      {`k` is an integer type or a float type}
----------------------------------------------------------------------------- (array-introduction)
       Γ |- (array-introduction k l1 ... ln) : (array (i64 n) k)


Γ |- e1 : (array (i64 n) k)     Γ, x1 : k, ..., xn : k |- e2 : B
------------------------------------------------------------------- (array-elimination)
 Γ |- (array-elimination k (x1 ... xn) e1 e2) : B
&lt;/pre&gt;
&lt;h3&gt;Semantics&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(array-elimination _ (x1 ... xn) (array-introduction _ e1 ... en) e)
~&amp;gt; e {x1 := e1,
      ...,
      xn := en}
&lt;/pre&gt;
&lt;h3&gt;Notes&lt;/h3&gt;
&lt;p&gt;The type of elements of an array must be the integer type, or the float type.&lt;/p&gt;
&lt;p&gt;The memory layout of an array is the same as the one of LLVM; For example, an array of type &lt;code&gt;i8&lt;/code&gt; is aligned as in the array &lt;code&gt;[0 x i8]&lt;/code&gt; in LLVM.&lt;/p&gt;
&lt;p&gt;The array type can be used, for example, to implement string.&lt;/p&gt;
&lt;p&gt;You won’t use &lt;code&gt;array-elimination&lt;/code&gt; in actual code; You would use the constant &lt;code&gt;array-access&lt;/code&gt; instead.&lt;/p&gt;
&lt;h2&gt;struct&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;struct&lt;/code&gt; is the struct type in LLVM.&lt;/p&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(let st
  (struct-introduction
    (f16 3.8)
    (i8 8)
    (i16 -300)
    (f32 33.0)
    (i64 30)
    (i64 10)
    (f64 -329444.4444444)
    (i8 9)))

(i64.print
  (struct-elimination
    ((_ f16) (_ i8) (_ i16) (_ f32) (z i64) (w i64) (_ f64) (_ i8))
    st
    (i64.add z w))) ; ~&amp;gt; 40
&lt;/pre&gt;
&lt;h3&gt;Syntax&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
; the struct type
(struct LOWTYPE ... LOWTYPE)

(struct-introduction (LOWTYPE TREE) ... (LOWTYPE TREE))

(struct-elimination ((LEAF LOWTYPE) ... (LEAF LOWTYPE)) TREE TREE)

LOWTYPE ::= i{n} | f{n}
&lt;/pre&gt;
&lt;h3&gt;Inference Rule&lt;/h3&gt;
&lt;pre lang=&quot;text&quot;&gt;
well-formed(Γ)    {Every `ki` in {`k1`, ..., `kn`} is either an integer type or a float type}
---------------------------------------------------------------------------------------------- (struct)
                         Γ |- (struct k1 ... kn) : tau


Γ |- e1 : k1   (...)   Γ |- en : kn      Γ |- (struct k1 ... kn) : tau
-------------------------------------------------------------------------- (struct-introduction)
   Γ |- (struct-introduction (e1 k1) ... (en kn)) : (struct k1 ... kn)


Γ |- e1 : (struct k1 ... kn)       Γ, x1 : k1, ..., xn : kn |- e2 : B
--------------------------------------------------------------------------- (struct-elimination)
    Γ |- (struct-elimination ((x1 k1) ... (xn kn)) e1 e2) : B
&lt;/pre&gt;
&lt;h3&gt;Semantics&lt;/h3&gt;
&lt;pre lang=&quot;text&quot;&gt;
(struct-elimination (x1 _) ... (xn _) (struct-introduction (_ e1) ... (_ en)) e)
~&amp;gt; e {x1 := e1,
      ...,
      xn := en}
&lt;/pre&gt;
&lt;h3&gt;Notes&lt;/h3&gt;
&lt;p&gt;Note that an element of a struct type in Neut is restricted into an integer or a float. This means, among others, that you can’t write a struct that contains another struct, or a memory region. This might get in the way when you implement an interface of a syscall; You might want to use the constant &lt;code&gt;unsafe.cast&lt;/code&gt; in that case, or “flatten” the struct.&lt;/p&gt;
&lt;p&gt;The memory layout of a struct is the same as the one of LLVM; For example, a struct of type &lt;code&gt;(struct i8 f16 i32)&lt;/code&gt; is aligned as in a struct of type &lt;code&gt;{i8, f16, f32}&lt;/code&gt; in LLVM.&lt;/p&gt;
&lt;p&gt;The struct type is intended to be used for implementation of interfaces of syscalls.&lt;/p&gt;
&lt;h2&gt;question&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;question&lt;/code&gt; requests the compiler to show the type of a term.&lt;/p&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(let x top.unit)

(question x)
&lt;/pre&gt;
&lt;h3&gt;Syntax&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(question TREE)

?TREE
&lt;/pre&gt;
&lt;h3&gt;Inference Rule&lt;/h3&gt;
&lt;pre lang=&quot;text&quot;&gt;
     Γ |- e : A
----------------------- (question)
Γ |- (question e) : A
&lt;/pre&gt;
&lt;h3&gt;Semantics&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(question e)
~&amp;gt; e
&lt;/pre&gt;
&lt;h3&gt;Notes&lt;/h3&gt;
&lt;p&gt;The type of a term wrapped by &lt;code&gt;question&lt;/code&gt; is reported by the compiler. This might be useful when used in harmony with a linter like flycheck.&lt;/p&gt;
&lt;h2&gt;erase&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;erase&lt;/code&gt; makes given variables invisible in its scope.&lt;/p&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
((λ (x y) x) bool.true bool.false)                        ; ~&amp;gt; bool.true

((λ (x y) (erase (x) x)) bool.true bool.false)            ; ~&amp;gt; undefined variable: x

((λ (x y) (erase (y) x)) bool.true bool.false)            ; ~&amp;gt; bool.true

((λ (x y) (erase (x y) x)) bool.true bool.false)          ; ~&amp;gt; undefined variable: x

; `with` has a dedicated notation for `erase`
(with identity.bind
  (let x bool.true)
  (let y x)
  (erase x)
  y) ; ~&amp;gt; undefined variable: y
&lt;/pre&gt;
&lt;h3&gt;Syntax&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(erase (LEAF ... LEAF) TREE)
&lt;/pre&gt;
&lt;h3&gt;Inference Rule&lt;/h3&gt;
&lt;pre lang=&quot;text&quot;&gt;
Γ |- e : A    (x1 : A1, ..., xn : An) ∈ Γ    (x1 : A1, ..., xn : An) ∉ freevar(e)
-------------------------------------------------------------------------------------- (erase)
                   Γ |- (erase (x1 ... xn) e) : A
&lt;/pre&gt;
&lt;h3&gt;Semantics&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(erase (x1 ... xn) e)
~&amp;gt; e
&lt;/pre&gt;
&lt;h3&gt;Notes&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;erase&lt;/code&gt; can be used, for example, to ensure that a variable is not used after a certain point of a program:&lt;/p&gt;
&lt;pre lang=&quot;neut&quot;&gt;
; `with` has a dedicated notation for `erase`
(with identity.bind
  (let VAR (some-computation))
  {COMPUTATION_WITH_VAR}
  (erase VAR)
  {COMPUTATION_WITHOUT_VAR}
  ...)
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;erase&lt;/code&gt; can also be used to ensure that a variable introduced in a &lt;a href=&quot;https://github.com/u2zv1wx/neut#notation&quot;&gt;notation&lt;/a&gt; doesn’t cause name collision with a free variable. For example, consider the following notation:&lt;/p&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(notation (foo e1 e2)
  (λ
    ((z tau)
     (k (Π ((_ i64) (_ bool)) z)))
    (k e1 e2)))

(let p (foo 10 bool.true))
&lt;/pre&gt;
&lt;p&gt;Though the notation &lt;code&gt;foo&lt;/code&gt; works in many cases, it can cause an unintuitive behavior if the &lt;code&gt;e1&lt;/code&gt; or &lt;code&gt;e2&lt;/code&gt; in &lt;code&gt;(foo e1 e2)&lt;/code&gt; contains &lt;code&gt;k&lt;/code&gt; as a free variable:&lt;/p&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(let k 100)

(let p (foo k bool.true))
; ~&amp;gt; (let p
;      (λ
;        ((z tau)
;         (k (Π ((_ i64) (_ bool)))))
;        (k k bool.true)))
; ~&amp;gt; type error
&lt;/pre&gt;
&lt;p&gt;Though we luckily got a type error in the example above, generally this sort of variable capturing can result in a more hard-to-debug runtime error. &lt;code&gt;erase&lt;/code&gt; can be used here to prevent this kind of situation as follows:&lt;/p&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(notation (foo e1 e2)
  (λ
    ((z tau)
     (k (Π ((_ i64) (_ bool)) z)))
    (k (erase (z k) e1) e2)))

(let k 100)

(let p (foo k bool.true))
; ~&amp;gt; (let p
;      (λ
;        ((z tau)
;         (k (Π ((_ i64) (_ bool)))))
;        (k (erase (z k) k) bool.true)))
; ~&amp;gt; undefined variable: k
&lt;/pre&gt;
&lt;p&gt;That is, using &lt;code&gt;erase&lt;/code&gt;, we can ensure that a variable introduced by &lt;code&gt;notation&lt;/code&gt; does not collide with a free variable contained in an argument of the notation.&lt;/p&gt;
&lt;p&gt;Note that &lt;code&gt;erase&lt;/code&gt; is only a partial solution to the problem of &lt;a href=&quot;https://en.wikipedia.org/wiki/Hygienic_macro&quot; rel=&quot;nofollow&quot;&gt;hygienic macros&lt;/a&gt;. Consider the following code:&lt;/p&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(notation (unless condition on-false on-true)
  (if (bool.not condition) on-true on-false)
&lt;/pre&gt;
&lt;p&gt;The notation above presupposes that the free variable &lt;code&gt;bool.not&lt;/code&gt; is bound in a sane way; &lt;code&gt;bool.not&lt;/code&gt; can’t be something like &lt;code&gt;(λ (x) x)&lt;/code&gt;, or &lt;code&gt;(string.print &quot;hello, world!&quot;)&lt;/code&gt;. Or, even the very symbol &lt;code&gt;erase&lt;/code&gt; can theoretically be bound to a variable. Thus &lt;code&gt;erase&lt;/code&gt; has no use in this situation.&lt;/p&gt;

&lt;h2&gt;asterisk&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;*&lt;/code&gt; is a placeholder that must be inferred.&lt;/p&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(define id ((a tau) (x a)) x)

(enum foo value)

(id foo foo.value) ; ~&amp;gt; foo.value

(id * foo.value) ; ~&amp;gt; foo.value (`*` is inferred to be `foo`)
&lt;/pre&gt;
&lt;h3&gt;Syntax&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
*
&lt;/pre&gt;
&lt;h3&gt;Semantics&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;*&lt;/code&gt; doesn’t have any operational semantics.&lt;/p&gt;
&lt;h3&gt;Notes&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;*&lt;/code&gt; can be used as a placeholder that must be resolved by the compiler using the constraints generated in its type inference procedure.&lt;/p&gt;
&lt;p&gt;If the type is not determined, the compiler raises an error; For example, the type of &lt;code&gt;x&lt;/code&gt; in the following code is not determined:&lt;/p&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(let x 10)
&lt;/pre&gt;
&lt;p&gt;since the &lt;code&gt;10&lt;/code&gt; cannot be determined to be &lt;code&gt;i32&lt;/code&gt;, &lt;code&gt;i16&lt;/code&gt;, or &lt;code&gt;i64&lt;/code&gt;, etc.&lt;/p&gt;
&lt;h2&gt;sigma&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;sigma&lt;/code&gt; is the existential quantification.&lt;/p&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
; binary sigma-intro without dependence
(let pair
  (sigma-introduction (i64 2) (λ ((x tau)) x)))

; binary sigma-elim without dependence
(sigma-elimination (x _) pair
  (i64.print x))

(let n-pair
  (sigma-introduction
    (i64 1)
    (λ ((x tau)) x)
    (f32 10.82)
    top.unit
    top.unit
    top
    tau))

(let 0-pair
  (sigma-introduction)
&lt;/pre&gt;
&lt;h3&gt;Syntax&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(sigma ((x1 A1) ... (xn An)) B)

(sigma-introduction e1 ... en)

(sigma-elimination (LEAF_PLUS ... LEAF_PLUS) e1 e2)

LEAF_PLUS ::= LEAF | (LEAF TREE)
&lt;/pre&gt;
&lt;h3&gt;Semantics&lt;/h3&gt;
&lt;pre lang=&quot;text&quot;&gt;
(sigma ((x1 A1) ... (xn An)) B)
~&amp;gt; (Π ((Z tau)
        (_ (Π ((x1 A1) ... (xn An) (_ B)) Z)))
       Z))

(sigma-introduction e1 ... en)
~&amp;gt; (Π-introduction
     ((Z tau)
      (k (Π ((x1 hole) ... (xn hole)) Z)))
     (k e1 ... en))

(sigma-elimination ((x1 A1) ... (xn An)) e1 e2)
~&amp;gt; (e1 hole (lambda ((x1 A1) ... (xn An)) e2))
&lt;/pre&gt;
&lt;h3&gt;Notes&lt;/h3&gt;
&lt;p&gt;Actual definition of &lt;code&gt;sigma&lt;/code&gt; is found in &lt;code&gt;core/VERSION/notation.neut&lt;/code&gt;; &lt;code&gt;sigma&lt;/code&gt; is just a convenient notation of a certain use of &lt;code&gt;Π&lt;/code&gt;. This encoding is the ordinary one in CoC.&lt;/p&gt;
&lt;p&gt;Sigma-type with dependence can be used, for example, to realize the type of string as follows:&lt;/p&gt;
&lt;pre lang=&quot;text&quot;&gt;
(define string
  (sigma ((len i64)) (array len i8)))
&lt;/pre&gt;
&lt;p&gt;In this case, a term of this &lt;code&gt;string&lt;/code&gt; type is something like &lt;code&gt;(3, [10, 20, 30])&lt;/code&gt;. The first element is the &lt;code&gt;len : i64&lt;/code&gt; part. This part contains the length information of a string. The second element is the actual content of the string.&lt;/p&gt;
&lt;p&gt;A sigma-type without dependence is the familiar product type; &lt;code&gt;(sigma ((_ A1) ... (_ An)) B)&lt;/code&gt; is &lt;code&gt;(product A1 ... An B)&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;with&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;with&lt;/code&gt; is a do-notation with the bind operation made explicit.&lt;/p&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(with identity.bind
  (let str &quot;foo&quot;)
  (let _ (string.print &amp;amp;str))
  (string.print &amp;amp;str) ; the same as (let _ (string.print &amp;amp;str))
  (let x (i64 10))
  (let y (add-i64 100 x))
  (i64.print y))

(with identity.bind
  (let str &quot;foo&quot;)
  (let _
    (let _ (i64 100)) ; each `e` in `(let x e)` is implicitly wrapped by `with`
    (string.print &amp;amp;str)
    (string.print &amp;amp;str))
  (string.print &amp;amp;str)
  (let len (string.print &amp;amp;str))
  len)
&lt;/pre&gt;
&lt;h3&gt;Syntax&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(with TREE TREE ... TREE)
&lt;/pre&gt;
&lt;h3&gt;Semantics&lt;/h3&gt;
&lt;pre lang=&quot;text&quot;&gt;
(with bind (let x (e e1 ... en)) rest+)
~&amp;gt; (bind * * (with (e e1' ... en'))
     (lambda (sig)
       (sigma-elimination (x1 ... xj) sig (with rest+))))
where:
  ei' := if ei == &amp;amp;x then x else ei
  x1, ..., xj := (all the &quot;borrowed&quot; variables in e1, ..., en)
  sig : a fresh variable

(with bind (let x e) rest+)
~&amp;gt; (bind * * (with e)
     (lambda (x) (with rest+)))

(with bind e rest+)
~&amp;gt; (with bind (let _ e) rest+)

(with bind (erase x1 ... xn) rest+)
~&amp;gt; (erase (x1 ... xn) (with bind rest+))

(with e)
~&amp;gt; e
&lt;/pre&gt;
&lt;h3&gt;Notes&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;with&lt;/code&gt; can be understood as a generalization of &lt;code&gt;begin&lt;/code&gt; in Scheme, or an explicit version of the &lt;code&gt;do&lt;/code&gt; notation in Haskell.&lt;/p&gt;
&lt;p&gt;The “borrowing” is covered by the first rule of the semantics; As you can see from the definition, this realization of borrowing works for any &lt;code&gt;bind&lt;/code&gt; operation.&lt;/p&gt;
&lt;p&gt;Note that the &lt;code&gt;bind&lt;/code&gt; operator is not restricted to monadic bind; You can set any term there as long as the resulting term of this syntactic translation is well-typed.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;e&lt;/code&gt; in &lt;code&gt;(let x e)&lt;/code&gt; is automatically surrounded by &lt;code&gt;with&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Partial Application&lt;/h2&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(define id ((a tau) (x a)) x)

; ordinary application
(id bool bool.true)

; partial application
((id bool _) bool.true)

; of course you can bind the partially-applied function to a variable
(let id-bool (id bool _))

(id-bool bool.true)
&lt;/pre&gt;
&lt;h3&gt;Sematics&lt;/h3&gt;
&lt;pre lang=&quot;text&quot;&gt;
(e e1 ... en)  [where e_{i1} = _, ..., e_{im} = _]
~&amp;gt; (λ (x1 ... xm) (e e1 ... en)) [replacing e_{ik} with xk]
&lt;/pre&gt;

&lt;h2&gt;LLVM-Based Primitives&lt;/h2&gt;
&lt;p&gt;Neut currently supports the following LLVM instructions: &lt;code&gt;fneg, add, fadd, sub, fsub, mul, fmul, udiv, sdiv, fdiv, urem, srem, frem, shl, lshr, ashr, and, or, xor, trunc, zext, sext, fptrunc, fpext, fptoui, fptosi, uitofp, sitofp, icmp, fcmp&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Each instruction is “separated” according to its type. Let us take the instruction &lt;code&gt;fneg&lt;/code&gt; for example. This instruction can be applied to &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, and &lt;code&gt;double&lt;/code&gt; in LLVM. Thus, Neut has the following three constants as primitives: &lt;code&gt;fneg-f16, fneg-f32, fneg-f64&lt;/code&gt;. For the instruction &lt;code&gt;add&lt;/code&gt;, the constants &lt;code&gt;add-i1, add-i2, ..., add-i64&lt;/code&gt; is available.&lt;/p&gt;
&lt;p&gt;The instructions with two type arguments like &lt;code&gt;fptosi&lt;/code&gt; is named as &lt;code&gt;fptosi-f64-i32, fptosi-f32-i1, fptosi-f16-i5&lt;/code&gt;, etc.&lt;/p&gt;
&lt;p&gt;As for the comparison operators &lt;code&gt;icmp&lt;/code&gt; and &lt;code&gt;fcmp&lt;/code&gt;, the names are of the form &lt;code&gt;{icmp, fcmp}-{CONDITION}-{TYPE}&lt;/code&gt;. For example, &lt;code&gt;icmp-eq-i16, icmp-ult-i32, icmp-sge-i64, fcmp-ogt-f32, fcmp-ord-f16, fcmp-ueq-f64&lt;/code&gt; are all valid.&lt;/p&gt;
&lt;p&gt;The semantics of these instructions is as specified in the &lt;a href=&quot;https://llvm.org/docs/LangRef.html&quot; rel=&quot;nofollow&quot;&gt;LLVM Language Reference Manual&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Syscalls&lt;/h2&gt;
&lt;p&gt;Neut supports syscalls, although its current support is far from complete. As you can see in &lt;code&gt;core/VERSION/constant/{linux, darwin}.neut&lt;/code&gt;, only basic syscalls like &lt;code&gt;read, write, exit, open, close&lt;/code&gt; are supported. This is not something that is caused by theoretical difficulties; Rather, this is simply because of my limited resource of time.&lt;/p&gt;
&lt;p&gt;It would be worth noting that a syscall can’t produce/consume a resource. For example, the syscall &lt;code&gt;write&lt;/code&gt; is declared to have the following type in Neut:&lt;/p&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(constant os.write
  (Π
    ((len i64)
     (out file-descriptor)
     (buf (array len i8))
     (nbyte i64))
    (product (array len i8) i64)))
&lt;/pre&gt;
&lt;p&gt;Compare the type above with the C signature of &lt;code&gt;write&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-c&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c1&quot;&gt;ssize_t&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;int&lt;/span&gt; fildes, &lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;void&lt;/span&gt; *buf, &lt;span class=&quot;pl-c1&quot;&gt;size_t&lt;/span&gt; nbyte);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ignoring the &lt;code&gt;(len i64)&lt;/code&gt; part that is necessary to receive an array of arbitrary length, the crucial difference here is the types of the codomains. While the latter one returns ordinary &lt;code&gt;ssize_t&lt;/code&gt; (integer), the former one also returns the original array. This is because the syscall &lt;code&gt;write&lt;/code&gt; doesn’t consume (i.e. deallocate) given string. If we &lt;code&gt;write&lt;/code&gt; in Neut doesn’t return the original string, the string is never freed in the succeeding program, causing space leak.&lt;/p&gt;
&lt;p&gt;Regarding macOS: You may note that the “syscalls” are lowered to some external interface functions on macOS. This is because macOS doesn’t support a direct use of a syscall; Indeed, for example, if we were to use the syscall &lt;code&gt;fork&lt;/code&gt; directly (0x2000002), a succeeding &lt;code&gt;malloc&lt;/code&gt; causes a fatal error, saying something like &lt;code&gt;mach_vm_map(size=1048576) failed (error code=268435459)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Implementation note: A syscall can be added via the following procedure:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Declare corresponding constant (like &lt;code&gt;os.write&lt;/code&gt;) using the &lt;a href=&quot;https://github.com/u2zv1wx/neut#constant&quot;&gt;constant&lt;/a&gt; statement&lt;/li&gt;
&lt;li&gt;Register its argument information and the syscall number in &lt;code&gt;src/Data/Syscall.hs&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Rebuild the compiler and run some test codes to check if it really works&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Here, the “argument information” is a list consists of one of the following tags: “immediate”, “struct”, “array”, and “unused”. This information is necessary to generate a corresponding syscall without writing each function definition explicitly. For example, consider you add a syscall &lt;code&gt;foo&lt;/code&gt; with its argument information [“unused”, “immediate”, “struct”, “array”]. This creates a function with 4 arguments. Let us call these arguments &lt;code&gt;x1&lt;/code&gt;, &lt;code&gt;x2&lt;/code&gt;, &lt;code&gt;x3&lt;/code&gt;, and &lt;code&gt;x4&lt;/code&gt;. The compiler then generates a function that calls the syscall, assuming that the “struct”- and “array”-tagged arguments are borrowed one. That is, the compiler generates a function that is defined schematically as follows:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-haskell&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
syscall&lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt;foo x1 x2 x3 x4 &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; result &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-ent&quot;&gt;CALL_SYSCALL&lt;/span&gt;(foo, x2, x3, x4) &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;return&lt;/span&gt; (x2, x3, result)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Using this mechanism, for example, the actual implementation of the syscall &lt;code&gt;os.write&lt;/code&gt; above can be generated from [“unused”, “immediate”, “array”, “immediate”]:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-haskell&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
syscall&lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt;os&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;write &lt;span class=&quot;pl-ent&quot;&gt;A&lt;/span&gt; out buf nbyte &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; result &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-ent&quot;&gt;CALL_SYSCALL&lt;/span&gt;(write, out, buf, nbyte) &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;return&lt;/span&gt; (buf, result)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Array Indexing&lt;/h2&gt;
&lt;p&gt;Neut offers a family of constants that allows us to access an element of an array. The names of these constants are of the form &lt;code&gt;{LOWTYPE}.array-access&lt;/code&gt;, where the &lt;code&gt;{LOWTYPE}&lt;/code&gt; is either &lt;code&gt;i{n}&lt;/code&gt; or &lt;code&gt;f{n}&lt;/code&gt;. For example, &lt;code&gt;i8.array-access&lt;/code&gt; can be used for indexing of an array of type &lt;code&gt;(array N i8)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The types of these accesser are of the following form:&lt;/p&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(Π
  ((i i64)
   (n i64)
   (_ (array n LOWTYPE)))
  (product (array n LOWTYPE) LOWTYPE))
&lt;/pre&gt;
&lt;p&gt;where the first argument &lt;code&gt;i&lt;/code&gt; specifies the index of the array, and the second argument &lt;code&gt;n&lt;/code&gt; specifies the length of the array. Using this constant, one can use an element of an array without consuming the array as follows:&lt;/p&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(let xs
  (array-introduction i64 1 2 -30 20))

(with identity.bind
  (let a (i64.array-access 0 * &amp;amp;xs)) ; the `*` is inferred to be `4`, since the length of `xs` is 4
  (let b (i64.array-access 1 * &amp;amp;xs))
  (let c (i64.array-access 2 * &amp;amp;xs))
  (let d (i64.array-access 3 * &amp;amp;xs))
  (i64.add a (i64.add b (i64.add c d)))) ; 1 + 2 + (-30) + 20
&lt;/pre&gt;
&lt;h2&gt;Unsafe Cast&lt;/h2&gt;
&lt;p&gt;The constant &lt;code&gt;unsafe.cast : Pi (A : tau, B : tau, x : A). B&lt;/code&gt; is available (assuming that the constant is declared using the statement &lt;a href=&quot;https://github.com/u2zv1wx/neut#constant&quot;&gt;constant&lt;/a&gt;). The semantics of this constant is the no-op cast:&lt;/p&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(unsafe.cast t1 t2 e)
~&amp;gt; e
&lt;/pre&gt;
&lt;p&gt;You can easily break the resource management system of Neut using this constant. Consider the following example:&lt;/p&gt;
&lt;pre lang=&quot;neut&quot;&gt;
(ensure core/1.0.0.0
  &quot;https://github.com/u2zv1wx/neut-core/raw/master/release/0.1.0.0.tar.gz&quot;)

; (note that this declares the constant unsafe.cast)
(include &quot;core/0.1.0.0/core.neut&quot;)

(let z (unsafe.cast i64 (Π ((_ i64)) i64) 1))

(let foo z) ; (*1)

(let bar z) ; (*2)
&lt;/pre&gt;
&lt;p&gt;The code above uses the variable &lt;code&gt;z&lt;/code&gt; for the two times. Since &lt;code&gt;z&lt;/code&gt; is casted to a Π-type, The resulting code tries to copy the integer &lt;code&gt;1&lt;/code&gt; as if it were a closure. Since the internal representation of a closure at least uses 3 words, this causes an access to an invalid memory region, that is, a segmentation fault.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;neut&lt;/code&gt; binary provides the subcommands in this section.&lt;/p&gt;
&lt;h2&gt;archive&lt;/h2&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ neut archive path/to/source/directory -o path/to/release/directory/0.1.0.0.tar.gz
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Notes&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;archive&lt;/code&gt; subcommand creates a tar.gz archive from the specified directory. The &lt;a href=&quot;https://github.com/u2zv1wx/neut#ensure&quot;&gt;ensure&lt;/a&gt; statement expects an archive created by this subcommand.&lt;/p&gt;
&lt;h2&gt;build&lt;/h2&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
$ neut build path/to/file.neut             &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; create an executable ./file&lt;/span&gt;
$ neut build -o output path/to/file.neut   &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; create an executable ./output&lt;/span&gt;
$ neut build --emit llvm path/to/file.neut &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; create a LLVM IR file ./file.ll&lt;/span&gt;
$ neut build --emit asm path/to/file.neut  &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; create an assembly code ./file.s&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Notes&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;build&lt;/code&gt; subcommand builds given source code and emits resulting code.&lt;/p&gt;
&lt;p&gt;Internally, these command firstly creates an LLVM IR, then passes it to &lt;code&gt;clang&lt;/code&gt; (if necessary).&lt;/p&gt;
&lt;h2&gt;check&lt;/h2&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
$ neut check path/to/file.neut
$ neut check --no-color path/to/file.neut
$ neut check --end-of-entry EOE path/to/file.neut
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Notes&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;check&lt;/code&gt; subcommand type-checks given file.&lt;/p&gt;
&lt;p&gt;If &lt;code&gt;--no-color&lt;/code&gt; option is specified, the result of type checking is printed without console color.&lt;/p&gt;
&lt;p&gt;If &lt;code&gt;--end-of-entry SEPARATOR&lt;/code&gt; is specified, each entry of the result of type checking is followed by &lt;code&gt;SEPARATOR&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This subcommand is intended to be used with an editor-side syntax checker like &lt;a href=&quot;https://www.flycheck.org/en/latest/&quot; rel=&quot;nofollow&quot;&gt;flycheck&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;LLVM IR for the First Example&lt;/h2&gt;
&lt;div class=&quot;highlight highlight-source-llvm&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@free&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;)
&lt;span class=&quot;pl-k&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@write&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;)
&lt;span class=&quot;pl-k&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@malloc&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt;)
&lt;span class=&quot;pl-k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@main&lt;/span&gt;() {
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;REPETITION 1&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;memory allocation for the string&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11875&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;getelementptr&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11876&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;ptrtoint&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11875&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11877&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;fastcc&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@malloc&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11876&lt;/span&gt;)
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;create the string &quot;a&quot; (i.e. write the character 'a' to the allocated memory)&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11878&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;bitcast&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11877&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; [&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;]*
  &lt;span class=&quot;pl-c1&quot;&gt;%_11879&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;inttoptr&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;97&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11880&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;ptrtoint&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11879&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11881&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;getelementptr&lt;/span&gt; [&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;], [&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;]* &lt;span class=&quot;pl-c1&quot;&gt;%_11878&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;store&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11880&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11881&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;write the string into stdout&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11882&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;inttoptr&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11883&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;inttoptr&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11884&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;fastcc&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@write&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11882&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11877&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11883&lt;/span&gt;)
  &lt;span class=&quot;pl-c1&quot;&gt;%_11885&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;bitcast&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11877&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; [&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;]*
  &lt;span class=&quot;pl-c1&quot;&gt;%_11886&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;getelementptr&lt;/span&gt; [&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;], [&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;]* &lt;span class=&quot;pl-c1&quot;&gt;%_11885&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11887&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;load&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11886&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11888&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;bitcast&lt;/span&gt; [&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;]* &lt;span class=&quot;pl-c1&quot;&gt;%_11885&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;memory deallocation for the string&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;fastcc&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@free&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11888&lt;/span&gt;)
  &lt;span class=&quot;pl-c1&quot;&gt;%_11889&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;inttoptr&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11887&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;REPETITION 2&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;memory allocation for the string&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11890&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;getelementptr&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11891&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;ptrtoint&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11890&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11892&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;fastcc&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@malloc&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11891&lt;/span&gt;)
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;create the string &quot;a&quot; (i.e. write the character 'a' to the allocated memory)&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11893&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;bitcast&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11892&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; [&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;]*
  &lt;span class=&quot;pl-c1&quot;&gt;%_11894&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;inttoptr&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;97&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11895&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;ptrtoint&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11894&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11896&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;getelementptr&lt;/span&gt; [&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;], [&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;]* &lt;span class=&quot;pl-c1&quot;&gt;%_11893&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;store&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11895&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11896&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;write the string into stdout&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11897&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;inttoptr&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11898&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;inttoptr&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11899&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;fastcc&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@write&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11897&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11892&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11898&lt;/span&gt;)
  &lt;span class=&quot;pl-c1&quot;&gt;%_11900&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;bitcast&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11892&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; [&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;]*
  &lt;span class=&quot;pl-c1&quot;&gt;%_11901&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;getelementptr&lt;/span&gt; [&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;], [&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;]* &lt;span class=&quot;pl-c1&quot;&gt;%_11900&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11902&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;load&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11901&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11903&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;bitcast&lt;/span&gt; [&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;]* &lt;span class=&quot;pl-c1&quot;&gt;%_11900&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;memory deallocation for the string&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;fastcc&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@free&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11903&lt;/span&gt;)
  &lt;span class=&quot;pl-c1&quot;&gt;%_11904&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;inttoptr&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11902&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;REPETITION 3&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;memory allocation for the string&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11905&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;getelementptr&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11906&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;ptrtoint&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11905&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11907&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;fastcc&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@malloc&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11906&lt;/span&gt;)
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;create the string &quot;a&quot; (i.e. write the character 'a' to the allocated memory)&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11908&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;bitcast&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11907&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; [&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;]*
  &lt;span class=&quot;pl-c1&quot;&gt;%_11909&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;inttoptr&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;97&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11910&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;ptrtoint&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11909&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11911&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;getelementptr&lt;/span&gt; [&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;], [&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;]* &lt;span class=&quot;pl-c1&quot;&gt;%_11908&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;store&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11910&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11911&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;write the string into stdout&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11912&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;inttoptr&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11913&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;inttoptr&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11914&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;fastcc&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@write&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11912&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11907&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11913&lt;/span&gt;)
  &lt;span class=&quot;pl-c1&quot;&gt;%_11915&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;bitcast&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11907&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; [&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;]*
  &lt;span class=&quot;pl-c1&quot;&gt;%_11916&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;getelementptr&lt;/span&gt; [&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;], [&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;]* &lt;span class=&quot;pl-c1&quot;&gt;%_11915&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11917&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;load&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11916&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11918&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;bitcast&lt;/span&gt; [&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;]* &lt;span class=&quot;pl-c1&quot;&gt;%_11915&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;memory deallocation for the string&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;fastcc&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@free&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11918&lt;/span&gt;)
  &lt;span class=&quot;pl-c1&quot;&gt;%_11919&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;inttoptr&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11917&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; &amp;lt;return 0&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11920&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;inttoptr&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_11921&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;ptrtoint&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11920&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_11921&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;LLVM IR for the Second Example&lt;/h2&gt;
&lt;div class=&quot;highlight highlight-source-llvm&quot; readability=&quot;28&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@free&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;)
&lt;span class=&quot;pl-k&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@write&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;)
&lt;span class=&quot;pl-k&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@malloc&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt;)
&lt;span class=&quot;pl-k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@main&lt;/span&gt;() {
  &lt;span class=&quot;pl-c&quot;&gt;; memory allocation&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_12034&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;getelementptr&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_12035&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;ptrtoint&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_12034&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_12036&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;fastcc&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@malloc&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_12035&lt;/span&gt;)
  &lt;span class=&quot;pl-c&quot;&gt;; create the string &quot;a&quot; (i.e. write the character 'a' to the allocated memory)&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_12037&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;bitcast&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_12036&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; [&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;]*
  &lt;span class=&quot;pl-c1&quot;&gt;%_12038&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;inttoptr&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;97&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c&quot;&gt;; a = 97&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_12039&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;ptrtoint&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_12038&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_12040&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;getelementptr&lt;/span&gt; [&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;], [&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;]* &lt;span class=&quot;pl-c1&quot;&gt;%_12037&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;pl-c&quot;&gt;; where to write 'a'&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;store&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_12039&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_12040&lt;/span&gt; &lt;span class=&quot;pl-c&quot;&gt;; write a&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; write the string into stdout for the three times&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_12041&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;inttoptr&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c&quot;&gt;; this `1` stands for stdout&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_12042&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;inttoptr&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c&quot;&gt;; this `1` is the length of the string in bytes&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_12043&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;fastcc&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@write&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_12041&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_12036&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_12042&lt;/span&gt;)
  &lt;span class=&quot;pl-c1&quot;&gt;%_12044&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;inttoptr&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_12045&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;inttoptr&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_12046&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;fastcc&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@write&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_12044&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_12036&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_12045&lt;/span&gt;)
  &lt;span class=&quot;pl-c1&quot;&gt;%_12047&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;inttoptr&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_12048&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;inttoptr&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_12049&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;fastcc&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@write&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_12047&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_12036&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_12048&lt;/span&gt;)
  &lt;span class=&quot;pl-c&quot;&gt;; memory deallocation&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_12050&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;bitcast&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_12036&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; [&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;]*
  &lt;span class=&quot;pl-c1&quot;&gt;%_12051&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;getelementptr&lt;/span&gt; [&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;], [&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;]* &lt;span class=&quot;pl-c1&quot;&gt;%_12050&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_12052&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;load&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_12051&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_12053&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;bitcast&lt;/span&gt; [&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt;]* &lt;span class=&quot;pl-c1&quot;&gt;%_12050&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;fastcc&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;@free&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_12053&lt;/span&gt;)
  &lt;span class=&quot;pl-c1&quot;&gt;%_12054&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;inttoptr&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_12052&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;; return 0&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_12055&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;inttoptr&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;%_12056&lt;/span&gt; = &lt;span class=&quot;pl-k&quot;&gt;ptrtoint&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i8*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_12055&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%_12056&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sat, 23 May 2020 15:48:11 +0000</pubDate>
<dc:creator>u2zv1wx</dc:creator>
<og:image>https://avatars2.githubusercontent.com/u/59402289?s=400&amp;v=4</og:image>
<og:type>object</og:type>
<og:title>u2zv1wx/neut</og:title>
<og:url>https://github.com/u2zv1wx/neut</og:url>
<og:description>A dependently-typed programming language with compile-time malloc/free determination - u2zv1wx/neut</og:description>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://github.com/u2zv1wx/neut</dc:identifier>
</item>
<item>
<title>Ask HN: Who regrets choosing Elixir?</title>
<link>https://news.ycombinator.com/item?id=23283675</link>
<guid isPermaLink="true" >https://news.ycombinator.com/item?id=23283675</guid>
<description>&lt;tr readability=&quot;0.58823529411765&quot;&gt;&lt;td bgcolor=&quot;#FF6600&quot;&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr id=&quot;pagespace&quot; title=&quot;Ask HN: Who regrets choosing Elixir?&quot;&gt;&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5.8524590163934&quot;&gt;&lt;td&gt;
&lt;table class=&quot;fatitem&quot; border=&quot;0&quot; readability=&quot;4.5983606557377&quot;&gt;&lt;tr class=&quot;athing&quot; id=&quot;23283675&quot; readability=&quot;0&quot;&gt;&lt;td align=&quot;right&quot; valign=&quot;top&quot; class=&quot;title&quot;/&gt;
&lt;td valign=&quot;top&quot; class=&quot;votelinks&quot;&gt;
&lt;center&gt;

&lt;/center&gt;
&lt;/td&gt;
&lt;td class=&quot;title&quot;&gt;&lt;a href=&quot;https://news.ycombinator.com/item?id=23283675&quot; class=&quot;storylink&quot;&gt;Ask HN: Who regrets choosing Elixir?&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;0.71428571428571&quot;&gt;&lt;td colspan=&quot;2&quot;/&gt;
&lt;td class=&quot;subtext&quot;&gt;&lt;span class=&quot;score&quot; id=&quot;score_23283675&quot;&gt;237 points&lt;/span&gt; by &lt;a href=&quot;https://news.ycombinator.com/user?id=seancoleman&quot; class=&quot;hnuser&quot;&gt;seancoleman&lt;/a&gt; &lt;span class=&quot;age&quot;&gt;&lt;a href=&quot;https://news.ycombinator.com/item?id=23283675&quot;&gt;9 hours ago&lt;/a&gt;&lt;/span&gt; &lt;span id=&quot;unv_23283675&quot;/&gt; | &lt;a href=&quot;https://news.ycombinator.com/hide?id=23283675&amp;amp;goto=item%3Fid%3D23283675&quot;&gt;hide&lt;/a&gt; | &lt;a href=&quot;https://hn.algolia.com/?query=Ask%20HN%3A%20Who%20regrets%20choosing%20Elixir%3F&amp;amp;sort=byDate&amp;amp;dateRange=all&amp;amp;type=story&amp;amp;storyText=false&amp;amp;prefix&amp;amp;page=0&quot; class=&quot;hnpast&quot;&gt;past&lt;/a&gt; | &lt;a href=&quot;https://www.google.com/search?q=Ask%20HN%3A%20Who%20regrets%20choosing%20Elixir%3F&quot;&gt;web&lt;/a&gt; | &lt;a href=&quot;https://news.ycombinator.com/fave?id=23283675&amp;amp;auth=c2ecb114b6c0b3f4ea90d027f1c00e08cd5948cd&quot;&gt;favorite&lt;/a&gt; | &lt;a href=&quot;https://news.ycombinator.com/item?id=23283675&quot;&gt;223 comments&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td colspan=&quot;2&quot;/&gt;
&lt;td readability=&quot;9&quot;&gt;I’ve seen a few Elixir success stories posted here recently. Virtually all comments are from raving fans that have nothing but the best to say about Elixir.
&lt;p&gt;As someone with primarily a Ruby / Rails background, I’m choosing a language for a new API project and considering Elixir. I’m interested in hearing some counterpoints to Elixir, especially in how a smaller ecosystem Of 3rd party libraries slowed down development.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot;/&gt;
&lt;td&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1&quot;&gt;&lt;td&gt;&lt;img src=&quot;https://news.ycombinator.com/s.gif&quot; height=&quot;10&quot; width=&quot;0&quot;/&gt;&lt;br/&gt;&lt;center&gt;&lt;span class=&quot;yclinks&quot;&gt;&lt;a href=&quot;https://news.ycombinator.com/newsguidelines.html&quot;&gt;Guidelines&lt;/a&gt; | &lt;a href=&quot;https://news.ycombinator.com/newsfaq.html&quot;&gt;FAQ&lt;/a&gt; | &lt;a href=&quot;mailto:hn@ycombinator.com&quot;&gt;Support&lt;/a&gt; | &lt;a href=&quot;https://github.com/HackerNews/API&quot;&gt;API&lt;/a&gt; | &lt;a href=&quot;https://news.ycombinator.com/security.html&quot;&gt;Security&lt;/a&gt; | &lt;a href=&quot;https://news.ycombinator.com/lists&quot;&gt;Lists&lt;/a&gt; | &lt;a href=&quot;https://news.ycombinator.com/bookmarklet.html&quot; rel=&quot;nofollow&quot;&gt;Bookmarklet&lt;/a&gt; | &lt;a href=&quot;http://www.ycombinator.com/legal/&quot;&gt;Legal&lt;/a&gt; | &lt;a href=&quot;http://www.ycombinator.com/apply/&quot;&gt;Apply to YC&lt;/a&gt; | &lt;a href=&quot;mailto:hn@ycombinator.com&quot;&gt;Contact&lt;/a&gt;&lt;/span&gt;
&lt;/center&gt;
&lt;/td&gt;
&lt;/tr&gt;</description>
<pubDate>Sat, 23 May 2020 15:26:30 +0000</pubDate>
<dc:creator>seancoleman</dc:creator>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://news.ycombinator.com/item?id=23283675</dc:identifier>
</item>
<item>
<title>Hacker Mods Old Calculator to Access the Internet, Casio Files DMCA Complaint</title>
<link>https://torrentfreak.com/hacker-mods-old-calculator-to-access-the-internet-casio-files-dmca-complaint-200523/</link>
<guid isPermaLink="true" >https://torrentfreak.com/hacker-mods-old-calculator-to-access-the-internet-casio-files-dmca-complaint-200523/</guid>
<description>&lt;div id=&quot;&quot;&gt;&lt;p class=&quot;bread_cr&quot;&gt;&lt;span property=&quot;itemListElement&quot; typeof=&quot;ListItem&quot;&gt;&lt;a property=&quot;item&quot; typeof=&quot;WebPage&quot; title=&quot;Go to TorrentFreak.&quot; href=&quot;https://torrentfreak.com&quot; class=&quot;home&quot;&gt;&lt;span property=&quot;name&quot;&gt;Home&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &amp;gt; &lt;span property=&quot;itemListElement&quot; typeof=&quot;ListItem&quot;&gt;&lt;a property=&quot;item&quot; typeof=&quot;WebPage&quot; title=&quot;Go to the Anti-Piracy category archives.&quot; href=&quot;https://torrentfreak.com/category/anti-piracy/&quot; class=&quot;taxonomy category&quot;&gt;&lt;span property=&quot;name&quot;&gt;Anti-Piracy&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &amp;gt; &lt;span property=&quot;itemListElement&quot; typeof=&quot;ListItem&quot;&gt;&lt;a property=&quot;item&quot; typeof=&quot;WebPage&quot; title=&quot;Go to the DMCA category archives.&quot; href=&quot;https://torrentfreak.com/category/anti-piracy/dmca/&quot; class=&quot;taxonomy category&quot;&gt;&lt;span property=&quot;name&quot;&gt;DMCA&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &amp;gt;&lt;/p&gt;
&lt;p class=&quot;article__excerpt&quot;&gt;A hobbyist electronics hacker who took a cheap standard calculator and modified it to access the Internet has been hit with a DMCA copyright complaint. According to CASIO, the project uses its copyrighted source code but the developer informs TorrentFreak that his code was written entirely from scratch.&lt;/p&gt;
&lt;/div&gt;&lt;div readability=&quot;127.77627729012&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://torrentfreak.com/images/casio-calculator-e1590143548819.png&quot;&gt;&lt;img src=&quot;https://torrentfreak.com/images/casio-calculator-e1590143548819.png&quot; alt=&quot;&quot; width=&quot;270&quot; height=&quot;161&quot; class=&quot;alignright size-full wp-image-188007&quot;/&gt;&lt;/a&gt;Hobbyist electronics hacker and YouTuber ‘Neutrino’ only has 10 videos on his channel but many are extremely popular.&lt;/p&gt;
&lt;p&gt;Back in April he constructed his own interactive and contactless &lt;a href=&quot;https://www.youtube.com/watch?v=N_-7oMFJ18k&quot;&gt;handwash dispenser&lt;/a&gt; to help people avoid the coronavirus and earlier this month published an absolute gem, transforming an old CASIO scientific calculator into something better.&lt;/p&gt;
&lt;p&gt;After a not inconsiderable amount of work, Neutrino’s device was able to communicate with similar devices nearby and even connect to the Internet. Pretty impressive for a supposed amateur.&lt;/p&gt;
&lt;p&gt;As standard, the CASIO calculator chosen for the project can be picked up on eBay for just a few dollars but other components are also required, as listed on &lt;a href=&quot;https://www.youtube.com/watch?v=xGjS5958g1g&quot;&gt;Neutrino&lt;/a&gt;‘s YouTube channel. After desoldering the solar panel and various other steps, Neutrino managed to squeeze an OLED display into the space, along with a WiFi module and other goodies.&lt;/p&gt;
&lt;p&gt;“Since we were in lockdown I wanted to do something really fun, which can keep me occupied for a week or two,” Neutrino informs TF.&lt;/p&gt;
&lt;p&gt;“I did not have many components to work with so using this calculator (CASIO fx-ms991) was not a problem, because it was roughly 5+ years old and it was given by my uncle.”&lt;/p&gt;
&lt;p&gt;Gizmodo &lt;a href=&quot;https://gizmodo.com/calculator-hacked-for-cheating-includes-a-secret-oled-s-1843314318&quot;&gt;published an article&lt;/a&gt; on the invention earlier this month, highlighting that it could potentially be used to cheat in exams. Neutrino says he doesn’t want that but does hope that the hack will inspire others to learn and participate in the ‘maker community’.&lt;/p&gt;
&lt;p&gt;But now, just a couple of weeks after winning plenty of praise, the project has also attracted the attention of an anti-counterfeiting organization working for CASIO.&lt;/p&gt;
&lt;p&gt;REACT describes itself as a not-for-profit organization with over 30 years experience in fighting counterfeit trade. “One of our main objectives is to keep the costs of anti-counterfeiting actions affordable,” its site &lt;a href=&quot;https://www.react.org/&quot;&gt;reads&lt;/a&gt;. A wide range of high-profile companies are listed as members, from Apple to Yves Saint Laurent and dozens in between.&lt;/p&gt;
&lt;p&gt;This week REACT wrote to Github, where Neutrino has his ‘&lt;a href=&quot;https://github.com/Neutrino-1/Hack-Casio-Calculator&quot;&gt;Hack-Casio-Calculator&lt;/a&gt;‘ repository, with a demand that it should be completely taken down for infringing its client’s intellectual property rights.&lt;/p&gt;
&lt;p&gt;“I am writing on behalf of CASIO, which is a member of REACT (also known as the Anti-Counterfeiting Network ). REACT actively fights the trade-in counterfeiting products on behalf of its members,” the complaint reads.&lt;/p&gt;
&lt;p&gt;“It came to our attention that the below-mentioned repository is using copyrighted source code in order to modify Casio’s copyrighted program.&lt;/p&gt;
&lt;p&gt;“The code the repository contains is proprietary and not to be publicly published. The hosted content is a direct, literal copy of our client’s work. I hereby summon you to take expeditious action: to remove or to disable access to the infringing content immediately, but in any case no later than ten days as of today.”&lt;/p&gt;
&lt;center&gt;&lt;a href=&quot;https://torrentfreak.com/images/casio-complaint-github-e1590146167826.png&quot;&gt;&lt;img src=&quot;https://torrentfreak.com/images/casio-complaint-github-e1590146167826.png&quot; alt=&quot;&quot; width=&quot;600&quot; height=&quot;345&quot; class=&quot;aligncenter size-full wp-image-188018&quot;/&gt;&lt;/a&gt;&lt;/center&gt;
&lt;p&gt;The full DMCA notice submitted to Github is available &lt;a href=&quot;https://github.com/github/dmca/commit/1e533a25356944db37d238361989ec1ceb2cc215&quot;&gt;here&lt;/a&gt; and claims that the “entire repository is infringing” and that hosted content is a “direct, literal copy of [CASIO’s] work.&lt;/p&gt;
&lt;p&gt;The repository has been disabled by Github in response to the complaint so validating the notice’s claims is not straightforward. That being said, Neutrino informs TF that the claim is nonsense and all work is his own.&lt;/p&gt;
&lt;p&gt;“They accuse me of using copyrighted source code in order to modify CASIO’s copyrighted program. But my code has nothing to do with it,” he explains.&lt;/p&gt;
&lt;p&gt;“The code was written completely from scratch and all the libraries included in my source file were open-source. Everything was clearly mentioned in the [now removed] readme file of my GitHub repository. They also allegedly accuse me by stating that ‘The entire repository is infringing’, but in reality whatever the original content they pointed out has nothing to do with my code.”&lt;/p&gt;
&lt;p&gt;Neutrino informs us that he has already filed a DMCA counternotice with Github to get his project back. While he may yet be successful, this is just the type of action that has ‘freedom-to-tinker’ proponents throwing their hands up in despair wondering why big corporations have nothing better to do.&lt;/p&gt;
&lt;p&gt;Unfortunately, these types of complaints can discourage people from being innovative or sharing their ideas and knowledge, the exact opposite of what Neutrino hoped to achieve. CASIO may somehow feel it’s in the right here but it does seem just a little bit petty.&lt;/p&gt;
&lt;center&gt;&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/xGjS5958g1g&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;[embedded content]&lt;/iframe&gt;&lt;/center&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 23 May 2020 13:07:28 +0000</pubDate>
<dc:creator>fraqed</dc:creator>
<og:type>article</og:type>
<og:title>Hacker Mods Old Calculator to Access the Internet, CASIO Files DMCA Complaint * TorrentFreak</og:title>
<og:description>A hobbyist hacker who modified an old calculator to enable Internet access has been hit with a DMCA copyright infringement complaint by CASIO</og:description>
<og:url>https://torrentfreak.com/hacker-mods-old-calculator-to-access-the-internet-casio-files-dmca-complaint-200523/</og:url>
<og:image>https://torrentfreak.com/images/hackedfea.jpg</og:image>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://torrentfreak.com/hacker-mods-old-calculator-to-access-the-internet-casio-files-dmca-complaint-200523/</dc:identifier>
</item>
<item>
<title>Ask HN: How do you brand yourself as a freelancer?</title>
<link>https://news.ycombinator.com/item?id=23282278</link>
<guid isPermaLink="true" >https://news.ycombinator.com/item?id=23282278</guid>
<description>&lt;tr readability=&quot;0.58823529411765&quot;&gt;&lt;td bgcolor=&quot;#FF6600&quot;&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr id=&quot;pagespace&quot; title=&quot;Ask HN: How do you brand yourself as a freelancer?&quot;&gt;&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8.780193236715&quot;&gt;&lt;td&gt;
&lt;table class=&quot;fatitem&quot; border=&quot;0&quot; readability=&quot;6.1461352657005&quot;&gt;&lt;tr class=&quot;athing&quot; id=&quot;23282278&quot; readability=&quot;0&quot;&gt;&lt;td align=&quot;right&quot; valign=&quot;top&quot; class=&quot;title&quot;/&gt;
&lt;td valign=&quot;top&quot; class=&quot;votelinks&quot;&gt;
&lt;center&gt;

&lt;/center&gt;
&lt;/td&gt;
&lt;td class=&quot;title&quot;&gt;&lt;a href=&quot;https://news.ycombinator.com/item?id=23282278&quot; class=&quot;storylink&quot;&gt;Ask HN: How do you brand yourself as a freelancer?&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;0.74074074074074&quot;&gt;&lt;td colspan=&quot;2&quot;/&gt;
&lt;td class=&quot;subtext&quot;&gt;&lt;span class=&quot;score&quot; id=&quot;score_23282278&quot;&gt;205 points&lt;/span&gt; by &lt;a href=&quot;https://news.ycombinator.com/user?id=bluewalt&quot; class=&quot;hnuser&quot;&gt;bluewalt&lt;/a&gt; &lt;span class=&quot;age&quot;&gt;&lt;a href=&quot;https://news.ycombinator.com/item?id=23282278&quot;&gt;12 hours ago&lt;/a&gt;&lt;/span&gt; &lt;span id=&quot;unv_23282278&quot;/&gt; | &lt;a href=&quot;https://news.ycombinator.com/hide?id=23282278&amp;amp;goto=item%3Fid%3D23282278&quot;&gt;hide&lt;/a&gt; | &lt;a href=&quot;https://hn.algolia.com/?query=Ask%20HN%3A%20How%20do%20you%20brand%20yourself%20as%20a%20freelancer%3F&amp;amp;sort=byDate&amp;amp;dateRange=all&amp;amp;type=story&amp;amp;storyText=false&amp;amp;prefix&amp;amp;page=0&quot; class=&quot;hnpast&quot;&gt;past&lt;/a&gt; | &lt;a href=&quot;https://www.google.com/search?q=Ask%20HN%3A%20How%20do%20you%20brand%20yourself%20as%20a%20freelancer%3F&quot;&gt;web&lt;/a&gt; | &lt;a href=&quot;https://news.ycombinator.com/fave?id=23282278&amp;amp;auth=be0df5e8618afefdd8507827856e8137e9a31f3c&quot;&gt;favorite&lt;/a&gt; | &lt;a href=&quot;https://news.ycombinator.com/item?id=23282278&quot;&gt;78 comments&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;20.5&quot;&gt;&lt;td colspan=&quot;2&quot;/&gt;
&lt;td readability=&quot;24&quot;&gt;I'll quit my CTO position in a few months to become a Freelancer. I know personal branding is an important part of the job to get customers.
&lt;p&gt;In short: what do you do for that?&lt;/p&gt;
&lt;p&gt;* Where do you ensure to be visible? LinkedIn, personal website, etc?&lt;/p&gt;
&lt;p&gt;* Do you create and post content (blog, LinkedIn groups, etc.)?&lt;/p&gt;
&lt;p&gt;* What content about you do you emphasize to find leads?&lt;/p&gt;
&lt;p&gt;* Do you use your own name, or a company name?&lt;/p&gt;
&lt;p&gt;* Did you chose to brand yourself a generalist Freelancer (&quot;I'm a developper working with X and Y languages&quot;) or a specialist one (&quot;I can be a CTO as a service building your MVP for your startup and help recruiting and train your team&quot;)&lt;/p&gt;
&lt;p&gt;Thanks for sharing your tips and experience.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot;/&gt;
&lt;td&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1&quot;&gt;&lt;td&gt;&lt;img src=&quot;https://news.ycombinator.com/s.gif&quot; height=&quot;10&quot; width=&quot;0&quot;/&gt;&lt;br/&gt;&lt;center&gt;&lt;span class=&quot;yclinks&quot;&gt;&lt;a href=&quot;https://news.ycombinator.com/newsguidelines.html&quot;&gt;Guidelines&lt;/a&gt; | &lt;a href=&quot;https://news.ycombinator.com/newsfaq.html&quot;&gt;FAQ&lt;/a&gt; | &lt;a href=&quot;mailto:hn@ycombinator.com&quot;&gt;Support&lt;/a&gt; | &lt;a href=&quot;https://github.com/HackerNews/API&quot;&gt;API&lt;/a&gt; | &lt;a href=&quot;https://news.ycombinator.com/security.html&quot;&gt;Security&lt;/a&gt; | &lt;a href=&quot;https://news.ycombinator.com/lists&quot;&gt;Lists&lt;/a&gt; | &lt;a href=&quot;https://news.ycombinator.com/bookmarklet.html&quot; rel=&quot;nofollow&quot;&gt;Bookmarklet&lt;/a&gt; | &lt;a href=&quot;http://www.ycombinator.com/legal/&quot;&gt;Legal&lt;/a&gt; | &lt;a href=&quot;http://www.ycombinator.com/apply/&quot;&gt;Apply to YC&lt;/a&gt; | &lt;a href=&quot;mailto:hn@ycombinator.com&quot;&gt;Contact&lt;/a&gt;&lt;/span&gt;
&lt;/center&gt;
&lt;/td&gt;
&lt;/tr&gt;</description>
<pubDate>Sat, 23 May 2020 12:12:13 +0000</pubDate>
<dc:creator>bluewalt</dc:creator>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://news.ycombinator.com/item?id=23282278</dc:identifier>
</item>
<item>
<title>Show HN: LaTeX.css – Make your website look like a LaTeX document</title>
<link>https://latex.now.sh</link>
<guid isPermaLink="true" >https://latex.now.sh</guid>
<description>&lt;h2 id=&quot;getting-started&quot;&gt;Getting Started&lt;/h2&gt;&lt;h2 id=&quot;class-based-elements&quot;&gt;Class-based Elements&lt;/h2&gt;
&lt;h3 id=&quot;author-abstract&quot;&gt;Author and Abstract&lt;/h3&gt;
&lt;p&gt;Use the following code to add an author and abstract to your document. It will look like &lt;a href=&quot;https://latex.now.sh/#top&quot;&gt;this&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;p class=&quot;author&quot;&amp;gt;John Doe &amp;lt;br&amp;gt; December 7, 2020&amp;lt;/p&amp;gt;

&amp;lt;div class=&quot;abstract&quot;&amp;gt;
  &amp;lt;h5&amp;gt;Abstract&amp;lt;/h5&amp;gt;
  &amp;lt;p&amp;gt;...&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;tdpl&quot;&gt;Theorems, Definitions, Lemmas and Proofs&lt;/h3&gt;
&lt;p&gt;Theorems, definitions, lemmas and proofs are supported. Just wrap your content in a div and add the corresponding class to the element like in the following example.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div class=&quot;theorem&quot;&amp;gt;...&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;definition&quot;&amp;gt;...&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;lemma&quot;&amp;gt;...&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;proof&quot;&amp;gt;...&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Below are some examples.&lt;/p&gt;
&lt;h4 id=&quot;proofs-theorems&quot;&gt;Proofs &amp;amp; Theorems&lt;/h4&gt;
&lt;p&gt;The real numbers $\mathbb{R}$ are uncountable.&lt;/p&gt;
&lt;p&gt;If $\mathbb{R}$ is countable, then [0, 1] is countable as well. Hence there exists a map C from $\mathbb{N}$ onto [0, 1] with $$C(n)=\sum_{i=1}^{\infty} c_{i}(n) 10^{-i}$$ where $c_{i}(n) \in\{0,1, \ldots, 9\},$ are the digits in decimal expansion. Now consider a real number $$x=\sum_{i=1}^{\infty} \bar{c}_{i} 10^{-i} \in[0,1]$$ with $\bar{c}_{i} \neq c_{i}(i)$. Obviously $C(n) \neq x$ for all $n \in \mathbb{N} .$ Hence $C$ is not onto. A contradiction.&lt;/p&gt;
&lt;div class=&quot;theorem&quot; readability=&quot;8.9150943396226&quot;&gt;If $S$ is both countable and infinite, then there is a bijection between $S$ and $\boldsymbol{N}$ itself.&lt;sup&gt;&lt;a href=&quot;https://latex.now.sh/#fn1&quot; id=&quot;ref1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/div&gt;
&lt;p&gt;For any $s \in S,$ we let $f(s)$ denote the value of $k$ such that $s$ is the $k$ th smallest element of $S .$ This map is well defined for any $s,$ because there are only finitely many natural numbers between 1 and $s .$ It is impossible for two different elements of $S$ to both be the $k$ th smallest element of $S$. Hence $f$ is one-to-one. Also, since $S$ is infinite, $f$ is onto.&lt;/p&gt;
&lt;h4 id=&quot;lemmas&quot;&gt;Lemmas&lt;/h4&gt;
&lt;p&gt;An even number plus an even number results in an even number.&lt;/p&gt;
&lt;h4 id=&quot;definitions&quot;&gt;Definitions&lt;/h4&gt;
&lt;div class=&quot;definition&quot; readability=&quot;6.9222222222222&quot;&gt;A definition is a a statement of the meaning of a word or word group or a sign or symbol.&lt;sup&gt;&lt;a href=&quot;https://latex.now.sh/#fn2&quot; id=&quot;ref2&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/div&gt;
&lt;h2 id=&quot;html-elements&quot;&gt;HTML Elements&lt;/h2&gt;
&lt;p&gt;For a preview of all HTML elements with LaTeX.css, check out the &lt;a href=&quot;https://latex.now.sh/elements&quot;&gt;HTML5 elements test page&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;text-formatting&quot;&gt;Text Formatting&lt;/h3&gt;
&lt;p&gt;This sentence is &lt;strong&gt;bold&lt;/strong&gt;. If you like semantics, you might go with &lt;strong&gt;strong&lt;/strong&gt; or &lt;em&gt;emphasized&lt;/em&gt; text. If not, &lt;em&gt;italic&lt;/em&gt; is still around. &lt;small&gt;Small&lt;/small&gt; text is for fine print. Your copy can also be &lt;sub&gt;subscripted&lt;/sub&gt; and &lt;sup&gt;superscripted&lt;/sup&gt;, &lt;ins&gt;inserted&lt;/ins&gt;, &lt;del&gt;deleted&lt;/del&gt;, or &lt;mark&gt;highlighted&lt;/mark&gt;. You would use a &lt;a href=&quot;https://latex.now.sh/#!&quot;&gt;hyperlink&lt;/a&gt; to go to a new page. Keyboard input elements like &lt;kbd&gt;Cmd&lt;/kbd&gt; + &lt;kbd&gt;Shift&lt;/kbd&gt; are used to display textual user input.&lt;/p&gt;
&lt;h3 id=&quot;blockquotes&quot;&gt;Blockquotes&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Give me six hours to chop down a tree and I will spend the first four sharpening the axe. &lt;cite&gt;— Abraham Lincoln&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;definition-lists&quot;&gt;Definition Lists&lt;/h3&gt;
&lt;dl&gt;&lt;dt&gt;Definition Title One&lt;/dt&gt;
&lt;dd&gt;First definition description&lt;/dd&gt;
&lt;dt&gt;Binomial theorem&lt;/dt&gt;
&lt;dd&gt;$$(x+y)^{n}=\sum_{k=0}^{n}\left(\begin{array}{l}n \\ k\end{array}\right) x^{n-k} y^{k}=\sum_{k=0}^{n}\left(\begin{array}{l}n \\ k\end{array}\right) x^{k} y^{n-k}$$&lt;/dd&gt;
&lt;/dl&gt;&lt;h3 id=&quot;tables&quot;&gt;Tables&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Header 1&lt;/th&gt;
&lt;th&gt;Header 2&lt;/th&gt;
&lt;th&gt;Header 3&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tfoot&gt;&lt;tr&gt;&lt;th&gt;Footer 1&lt;/th&gt;
&lt;th&gt;Footer 2&lt;/th&gt;
&lt;th&gt;Footer 3&lt;/th&gt;
&lt;/tr&gt;&lt;/tfoot&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Description 1&lt;/td&gt;
&lt;td&gt;Description 2&lt;/td&gt;
&lt;td&gt;Description 3&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Description 1&lt;/td&gt;
&lt;td&gt;Description 2&lt;/td&gt;
&lt;td&gt;Description 3&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Description 1&lt;/td&gt;
&lt;td&gt;Description 2&lt;/td&gt;
&lt;td&gt;Description 3&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;images&quot;&gt;Images&lt;/h3&gt;
&lt;img src=&quot;https://images.unsplash.com/photo-1477346611705-65d1883cee1e?auto=format&amp;amp;fit=crop&amp;amp;w=1000&amp;amp;q=80&quot; loading=&quot;lazy&quot; alt=&quot;Mountain landscape&quot; title=&quot;&quot;/&gt; Mountain landscape by &lt;a href=&quot;https://unsplash.com/@heytowner&quot;&gt;John Towner&lt;/a&gt;.

</description>
<pubDate>Sat, 23 May 2020 11:56:19 +0000</pubDate>
<dc:creator>doerig</dc:creator>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://latex.now.sh/</dc:identifier>
</item>
<item>
<title>SQLite 3.32</title>
<link>https://sqlite.org/releaselog/3_32_0.html</link>
<guid isPermaLink="true" >https://sqlite.org/releaselog/3_32_0.html</guid>
<description>[unable to retrieve full-text content]
&lt;p&gt;Article URL: &lt;a href=&quot;https://sqlite.org/releaselog/3_32_0.html&quot;&gt;https://sqlite.org/releaselog/3_32_0.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Comments URL: &lt;a href=&quot;https://news.ycombinator.com/item?id=23281994&quot;&gt;https://news.ycombinator.com/item?id=23281994&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Points: 333&lt;/p&gt;
&lt;p&gt;# Comments: 131&lt;/p&gt;
</description>
<pubDate>Sat, 23 May 2020 11:13:06 +0000</pubDate>
<dc:creator>nikbackm</dc:creator>
<dc:format>text/html</dc:format>
<dc:identifier>https://sqlite.org/releaselog/3_32_0.html</dc:identifier>
</item>
<item>
<title>First Krita Beta for Android and ChromeOS in Play Store</title>
<link>https://krita.org/en/item/first-krita-beta-for-android-and-chromeos-in-play-store/</link>
<guid isPermaLink="true" >https://krita.org/en/item/first-krita-beta-for-android-and-chromeos-in-play-store/</guid>
<description>&lt;div class=&quot;post page&quot; readability=&quot;45.236122618061&quot;&gt;
&lt;h2 class=&quot;main-title&quot;&gt;First Krita Beta for Android and ChromeOS in Play Store&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Published    5/23/2020&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Thanks to the hard work of Sharaf Zaman, &lt;a href=&quot;https://play.google.com/store/apps/details?id=org.krita&quot;&gt;Krita is now available in the Google Play Store&lt;/a&gt; for Android tablets and Chromebooks (not for Android phones).&lt;/p&gt;
&lt;p&gt;This beta, based on Krita 4.2.9, is the full desktop version of Krita, so it doesn’t have a special touch user interface. But it’s there, and you can play with it.&lt;/p&gt;
&lt;p&gt;Unlike the Windows and Steam store, we don’t ask for money for Krita in the store, since it’s the only way people can install Krita on those devices, but you can buy a supporter badge from within Krita to support development.&lt;/p&gt;
&lt;h3&gt;Install&lt;/h3&gt;
&lt;h3&gt;&lt;strong&gt;Notes&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Supports: Android tablets &amp;amp; Chromebooks.&lt;/li&gt;
&lt;li&gt;Currently not compatible with: Android phones.&lt;/li&gt;
&lt;li&gt;If you have installed one of Sharaf’s builds or a build you’ve signed yourself, you need to uninstall that first, for all users!&lt;/li&gt;
&lt;/ul&gt;&lt;div id=&quot;attachment_10553&quot; class=&quot;wp-caption aligncenter&quot;&gt;&lt;a href=&quot;https://play.google.com/store/apps/details?id=org.krita&quot;&gt;&lt;img aria-describedby=&quot;caption-attachment-10553&quot; class=&quot;size-large wp-image-10553&quot; src=&quot;https://krita.org/wp-content/uploads/2020/05/playstore-1024x846.png&quot; alt=&quot;&quot; width=&quot;1024&quot; height=&quot;846&quot; srcset=&quot;https://krita.org/wp-content/uploads/2020/05/playstore-1024x846.png 1024w, https://krita.org/wp-content/uploads/2020/05/playstore-300x248.png 300w, https://krita.org/wp-content/uploads/2020/05/playstore-768x635.png 768w, https://krita.org/wp-content/uploads/2020/05/playstore.png 1078w&quot; sizes=&quot;(max-width: 1024px) 100vw, 1024px&quot;/&gt;&lt;/a&gt;
&lt;p id=&quot;caption-attachment-10553&quot; class=&quot;wp-caption-text&quot;&gt;Krita on the Play Store&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ssba-classic-2 ssba ssbp-wrap left ssbp--theme-1&quot;&gt;
&lt;div&gt;&lt;a data-site=&quot;linkedin&quot; class=&quot;ssba_linkedin_share ssba_share_link&quot; href=&quot;https://www.linkedin.com/shareArticle?mini=true&amp;amp;url=https://krita.org/en/item/first-krita-beta-for-android-and-chromeos-in-play-store/&quot; target=&quot;&amp;quot;_blank&amp;quot;&quot;&gt;&lt;img src=&quot;https://krita.org/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/linkedin.png&quot; title=&quot;LinkedIn&quot; class=&quot;ssba ssba-img&quot; alt=&quot;Share on LinkedIn&quot;/&gt;&lt;/a&gt;
&lt;p&gt;Linkedin&lt;/p&gt;
&lt;a data-site=&quot;pinterest&quot; class=&quot;ssba_pinterest_share&quot; href=&quot;javascript:void((function()%7Bvar%20e=document.createElement('script');e.setAttribute('type','text/javascript');e.setAttribute('charset','UTF-8');e.setAttribute('src','//assets.pinterest.com/js/pinmarklet.js?r='+Math.random()*99999999);document.body.appendChild(e)%7D)());&quot;&gt;&lt;img src=&quot;https://krita.org/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/pinterest.png&quot; title=&quot;Pinterest&quot; class=&quot;ssba ssba-img&quot; alt=&quot;Pin on Pinterest&quot;/&gt;&lt;/a&gt;
&lt;p&gt;Pinterest&lt;/p&gt;
&lt;span class=&quot; ssba_sharecount&quot;&gt;0&lt;/span&gt;&lt;a data-site=&quot;reddit&quot; class=&quot;ssba_reddit_share&quot; href=&quot;https://reddit.com/submit?url=https://krita.org/en/item/first-krita-beta-for-android-and-chromeos-in-play-store/&amp;amp;title=First%20Krita%20Beta%20for%20Android%20and%20ChromeOS%20in%20Play%20Store&quot; target=&quot;&amp;quot;_blank&amp;quot;&quot;&gt;&lt;img src=&quot;https://krita.org/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/reddit.png&quot; title=&quot;Reddit&quot; class=&quot;ssba ssba-img&quot; alt=&quot;Share on Reddit&quot;/&gt;&lt;/a&gt;
&lt;p&gt;Reddit&lt;/p&gt;
&lt;span class=&quot; ssba_sharecount&quot;&gt;247&lt;/span&gt;&lt;a data-site=&quot;&quot; class=&quot;ssba_facebook_share&quot; href=&quot;https://www.facebook.com/sharer.php?u=https://krita.org/en/item/first-krita-beta-for-android-and-chromeos-in-play-store/&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://krita.org/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/facebook.png&quot; title=&quot;Facebook&quot; class=&quot;ssba ssba-img&quot; alt=&quot;Share on Facebook&quot;/&gt;&lt;/a&gt;
&lt;p&gt;Facebook&lt;/p&gt;
&lt;span class=&quot; ssba_sharecount&quot;&gt;0&lt;/span&gt;&lt;a data-site=&quot;tumblr&quot; class=&quot;ssba_tumblr_share&quot; href=&quot;https://www.tumblr.com/share/link?url=https://krita.org/en/item/first-krita-beta-for-android-and-chromeos-in-play-store/&quot; target=&quot;&amp;quot;_blank&amp;quot;&quot;&gt;&lt;img src=&quot;https://krita.org/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/tumblr.png&quot; title=&quot;tumblr&quot; class=&quot;ssba ssba-img&quot; alt=&quot;Share on Tumblr&quot;/&gt;&lt;/a&gt;
&lt;p&gt;Tumblr&lt;/p&gt;
&lt;span class=&quot; ssba_sharecount&quot;&gt;0&lt;/span&gt;&lt;a data-site=&quot;&quot; class=&quot;ssba_twitter_share&quot; href=&quot;https://twitter.com/share?url=https://krita.org/en/item/first-krita-beta-for-android-and-chromeos-in-play-store/&amp;amp;text=First%20Krita%20Beta%20for%20Android%20and%20ChromeOS%20in%20Play%20Store%20&quot; target=&quot;&amp;quot;_blank&amp;quot;&quot;&gt;&lt;img src=&quot;https://krita.org/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/twitter.png&quot; title=&quot;Twitter&quot; class=&quot;ssba ssba-img&quot; alt=&quot;Tweet about this on Twitter&quot;/&gt;&lt;/a&gt;
&lt;p&gt;Twitter&lt;/p&gt;
&lt;a data-site=&quot;vk&quot; class=&quot;ssba_vk_share ssba_share_link&quot; href=&quot;https://vk.com/share.php?url=https://krita.org/en/item/first-krita-beta-for-android-and-chromeos-in-play-store/&quot; target=&quot;&amp;quot;_blank&amp;quot;&quot;&gt;&lt;img src=&quot;https://krita.org/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/vk.png&quot; title=&quot;VK&quot; class=&quot;ssba ssba-img&quot; alt=&quot;Share on VK&quot;/&gt;&lt;/a&gt;
&lt;p&gt;VK&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 23 May 2020 09:55:52 +0000</pubDate>
<dc:creator>reddotX</dc:creator>
<dc:language>en-US</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://krita.org/en/item/first-krita-beta-for-android-and-chromeos-in-play-store/</dc:identifier>
</item>
<item>
<title>Catalina is checking notarization of unsigned executables</title>
<link>https://lapcatsoftware.com/articles/catalina-executables.html</link>
<guid isPermaLink="true" >https://lapcatsoftware.com/articles/catalina-executables.html</guid>
<description>&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;meta name=&quot;twitter:card&quot; content=&quot;summary&quot;/&gt;&lt;meta name=&quot;twitter:site&quot; content=&quot;@lapcatsoftware&quot;/&gt;&lt;meta name=&quot;twitter:title&quot; content=&quot;Catalina is checking notarization of unsigned executables&quot;/&gt;&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0&quot;/&gt;&lt;meta name=&quot;generator&quot; content=&quot;BBEdit 10.5&quot;/&gt;&lt;title&gt;Catalina is checking notarization of unsigned executables&lt;/title&gt;&lt;/head&gt;&lt;body id=&quot;readabilityBody&quot; readability=&quot;190.71277299801&quot;&gt;
&lt;div class=&quot;articles_index&quot;&gt;&lt;a href=&quot;https://lapcatsoftware.com/articles/index.html&quot; title=&quot;The Desolation of Blog&quot;&gt;Articles index&lt;/a&gt;&lt;/div&gt;

&lt;h3&gt;May 22 2020 by Jeff Johnson&lt;br/&gt;Support this blog: &lt;a href=&quot;https://underpassapp.com/LinkUnshortener/&quot;&gt;Link Unshortener&lt;/a&gt;, &lt;a href=&quot;https://underpassapp.com/StopTheMadness/&quot;&gt;StopTheMadness&lt;/a&gt;, &lt;a href=&quot;https://underpassapp.com/&quot;&gt;Underpass&lt;/a&gt;, &lt;a href=&quot;https://www.paypal.me/JeffJohnsonWI&quot;&gt;PayPal.Me&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;This is a follow-up to Allan Odgaard's excellent article &lt;a href=&quot;https://sigpipe.macromates.com/2020/macos-catalina-slow-by-design/&quot;&gt;macOS 10.15: Slow by Design&lt;/a&gt;. I want to talk specifically about the first section &quot;Spawning a new Process&quot;, because there has been widespread misunderstanding of this. Odgaard provides a simple test to show that the first run of an executable is delayed while Catalina checks the executable's notarization status online. This occurs even for shell scripts, which cannot be code signed!&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;echo $'#!/bin/sh\necho Hello' &amp;gt; /tmp/test.sh &amp;amp;&amp;amp; chmod a+x /tmp/test.sh
time /tmp/test.sh &amp;amp;&amp;amp; time /tmp/test.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;A number of people, including myself, have reproduced this issue. However, a number of other people claim that they can't reproduce it. I'm rather skeptical of these claims, for I've found more than a few cases of people misinterpreting their own tests. You can't expect to just experience an obviously long delay, because the length of the delay depends crucially on the condition and speed of your network connection, as well as your vicinity to Apple's servers. (A Chinese commenter on &lt;a href=&quot;https://news.ycombinator.com/item?id=23274033&quot;&gt;Hacker News&lt;/a&gt; posted results of 5.746 seconds vs 6 milliseconds on VPN and 1.936 seconds vs 5 milliseconds non-VPN.) Without an online check, the script ought to finish executing within a few milliseconds. So even if your first test result is only around 100 milliseconds, that's still many times longer than expected. Some people try to explain away the delay, e.g., &quot;I would put the 300 vs 5 ms down to filesystem caching&quot;, but such hand waving doesn't stand up to further scrutiny.&lt;/p&gt;
&lt;p&gt;It's also important to remember that Catalina caches the result of the online check. If you test multiple times, this could give misleading results. In my testing, the easiest way to trigger a new online check is to modify the contents of the script. I simply created a script in TextEdit, saved it, and then kept TextEdit open for easy editing and saving.&lt;/p&gt;
&lt;p&gt;You can verify that there's an online check by taking packet traces. On the first run, there's clearly an online check. On subsequent runs of the unmodified script, there's no online check, and the execution is much faster. If you turn off your Mac's internet connection, you can see that the first run of a script is now much faster than before; yet the first run without internet is &lt;em&gt;still&lt;/em&gt; slower than subsequent runs. So it's still trying to make an online check, but failing, and then caching that result.&lt;/p&gt;
&lt;p&gt;Is Catalina trying to check the notarization of the executable? The evidence strongly indicates yes. The packet traces for this look exactly like the packet traces for a normal app notarization check. They're always to the same domain: &lt;code&gt;api.apple-cloudkit.com&lt;/code&gt;. If you search the Catalina file system, there are only a few results for this domain. I found &lt;code&gt;/System/Library/PrivateFrameworks/WorkflowKit.framework&lt;/code&gt; and &lt;code&gt;/System/iOSSupport/System/Library/PrivateFrameworks/WorkflowKit.framework&lt;/code&gt;, which are related to Shortcuts, &lt;code&gt;/usr/libexec/remindd&lt;/code&gt;, which is related to Reminders, and &lt;code&gt;/usr/libexec/syspolicyd&lt;/code&gt;, which is what we're looking for, the process responsible for checking notarization. In fact, there's only one place — &lt;code&gt;https://api.apple-cloudkit.com/database/1/%@/%@/public/records/lookup&lt;/code&gt; — where &lt;code&gt;syspolicyd&lt;/code&gt; contacts that domain. (The &lt;code&gt;%@&lt;/code&gt; in the URL are Objective-C format strings. Yes, &lt;code&gt;syspolicyd&lt;/code&gt; is still written in Objective-C, as is the majority of macOS.) You can also find the log message in &lt;code&gt;syspolicyd&lt;/code&gt; &quot;Performing legacy notarization check for unsigned code&quot;. I'm not sure why it says &quot;legacy&quot;; I could speculate, but that would just distract from the main point. In any case, I don't know how this could plausibly be called anything other than a notarization check, because there's only a single online API here, which is used for both regular apps and non-app executables.&lt;/p&gt;
&lt;p&gt;By the way, you can block macOS notarization checks without turning off your internet connection by installing &lt;a href=&quot;https://www.obdev.at/products/littlesnitch/index.html&quot;&gt;Little Snitch&lt;/a&gt; and setting the rules to deny any outgoing connection from syspolicyd. I highly recommend Little Snitch and consider it to be absolutely essential software for the Mac.&lt;/p&gt;
&lt;p&gt;In contrast to Catalina, macOS 10.14 Mojave has no online check whatsoever for shell scripts. This can also be verified by packet trace. Even if I download a file from the web, adding a quarantine extended attribute, there's still no notarization check. The first run of a shell script on Mojave is as fast as subsequent runs of the script. There's no online delay introduced by Mojave.&lt;/p&gt;
&lt;p&gt;Back to Catalina, I started wondering about other kinds of executable. What about compiled command-line tools that are not scripts but not apps either? I created a simple &quot;Hello World&quot; project in Xcode, and I changed the build settings so that the tool was not code signed at all by Xcode. When I ran the tool for the first time, there was no online notarization check, which was a bit surprising to me. When I looked at the Xcode build transcript, though, I found the explanation. The final phase of the build, after the linking phase, was &quot;Register execution policy exception&quot;. Xcode called &lt;code&gt;builtin-RegisterExecutionPolicyException&lt;/code&gt; on my tool. This gave the tool permission to execute on my Mac without getting checked.&lt;/p&gt;
&lt;p&gt;Since Xcode was messing with my test, I decided to forgo Xcode, instead directly compiling a command-line executable using &lt;code&gt;clang&lt;/code&gt;. I didn't code sign the compiled executable. When I ran it the first time, there was a notarization check! And of course there was no notarization check on subsequent runs. Thus, Catalina seems to be checking notarization on every unsigned executable, whether it's a shell script or a compiled Mach-O file.&lt;/p&gt;
&lt;p&gt;For my next test, I decided to compile another tool but this time perform &quot;ad hoc&quot; code signing on it (&lt;code&gt;codesign --sign&lt;/code&gt; with the identity &quot;-&quot;). An ad hoc signed executable is signed only for your Mac, and doesn't require a signing certificate. When I ran my ad hoc signed tool the first time, this also triggered a notarization check, like the unsigned case.&lt;/p&gt;
&lt;p&gt;The one scenario I didn't test was running a compiled command-line tool signed with my Apple developer certificate. That's easy to do with Xcode, not so easy to do without Xcode. It's not impossible, you just have to figure out the appropriate arguments to the &lt;code&gt;codesign&lt;/code&gt; invocation. To be honest, after all of my other testing, I just didn't feel like doing the additional work. Someone else can try this, please!&lt;/p&gt;
&lt;p&gt;Returning to the original article, Allan Odgaard asks, &quot;Are Apple sending the source of all my custom scripts to their server?&quot; The answer is no. There are two independent ways of verifying this. First, you can look at the disassembly (&lt;code&gt;otool -tV /usr/libexec/syspolicyd&lt;/code&gt;) to see exactly how it works. Second, you can look at the packet traces. For example, if you create a very large script, you can compare the size of the script with the number of bytes of data sent to Apple. There just aren't enough bytes to fit a large script; there aren't many bytes at all in a notarization check, which is the point, because it's supposed to be a fast as (networkly) possible. Code signing and notarization use a secure hash, not the full file contents.&lt;/p&gt;
&lt;p&gt;I hope this discussion has been a useful clarification. Unfortunately, I can't explain &lt;em&gt;why&lt;/em&gt; Catalina is running notarization checks on these executables. That mystery is really up to Apple to explain. You've got a lot of explaining to do!&lt;/p&gt;
&lt;h4&gt;Addendum May 23&lt;/h4&gt;
&lt;p&gt;Today I came across &lt;a href=&quot;https://news.ycombinator.com/item?id=23273867&quot;&gt;an intriguing comment&lt;/a&gt; by an Apple Xcode engineer. (By the way, this engineer has me blocked on the bird site, for unknown reasons… unknown except for generalized ripping on Xcode, I guess.)&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;Xcode (the UI) is able to bypass GateKeeper checks for things it builds.&lt;/p&gt;
&lt;p&gt;The &quot;Developer Tool&quot; pane in System Prefs, Security, Privacy is the same power. Drag anything into that list you'd like to grant the same privilege (such as xcodebuild). This is inherited by child processes as well.&lt;/p&gt;
&lt;p&gt;The point of this is to avoid malware packing bits of Xcode with itself and silently compiling itself on the target machine, thus bypassing system security policy.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So this may indicate Apple's motivation for adding notarization checks to scripts and other standalone executables. One major problem, though, is that this information is not documented &lt;em&gt;anywhere&lt;/em&gt;, to my knowledge. It's the first I've ever heard of it, and I'm a professional Mac developer. As is Allan Odgaard. But we're all just flailing in the dark, trying to cope with mysterious system behavior.&lt;/p&gt;
&lt;p&gt;Hacker News comments are not documentation, Apple!&lt;/p&gt;
&lt;p&gt;Let me leave you with &lt;a href=&quot;https://news.ycombinator.com/item?id=23278253&quot;&gt;another intriguing comment&lt;/a&gt; to ponder:&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;Making this about speed is burying the lede. From a privacy and user-freedom perspective, it's &lt;em&gt;horrifying&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Don't think so? Apple now theoretically has a centralized database of every Mac user who's ever used youtube-dl. Or Tor. Or TrueCrypt.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Support this blog: &lt;a href=&quot;https://underpassapp.com/LinkUnshortener/&quot;&gt;Link Unshortener&lt;/a&gt;, &lt;a href=&quot;https://underpassapp.com/StopTheMadness/&quot;&gt;StopTheMadness&lt;/a&gt;, &lt;a href=&quot;https://underpassapp.com/&quot;&gt;Underpass&lt;/a&gt;, &lt;a href=&quot;https://www.paypal.me/JeffJohnsonWI&quot;&gt;PayPal.Me&lt;/a&gt;&lt;/h3&gt;
&lt;div class=&quot;articles_index&quot;&gt;&lt;a href=&quot;https://lapcatsoftware.com/articles/index.html&quot; title=&quot;The Desolation of Blog&quot;&gt;Articles index&lt;/a&gt;&lt;/div&gt;
&lt;/body&gt;</description>
<pubDate>Sat, 23 May 2020 09:42:24 +0000</pubDate>
<dc:creator>robenkleene</dc:creator>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://lapcatsoftware.com/articles/catalina-executables.html</dc:identifier>
</item>
</channel>
</rss>