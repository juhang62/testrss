<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=hnrss.org%2Fnewest%3Fpoints%3D200&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://hnrss.org/newest?points=200" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dhnrss.org%252Fnewest%253Fpoints%253D200%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dhnrss.org%252Fnewest%253Fpoints%253D200%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>Hacker News: Newest</title>
<link>https://news.ycombinator.com/newest</link>
<description>Hacker News RSS</description>
<item>
<title>Super Mario 64 has been decompiled</title>
<link>https://github.com/n64decomp/sm64/blob/master/README.md</link>
<guid isPermaLink="true" >https://github.com/n64decomp/sm64/blob/master/README.md</guid>
<description>
&lt;p&gt;This repo contains a full decompilation of Super Mario 64 (J) and (U). The source and data have been decompiled but complete naming and documentation all of the code and data is still a work in progress. Decompiling the (E) ROM is also an ongoing effort.&lt;/p&gt;
&lt;p&gt;It builds the following ROMs:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;sm64.jp.z64 &lt;code&gt;sha1: 8a20a5c83d6ceb0f0506cfc9fa20d8f438cafe51&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;sm64.us.z64 &lt;code&gt;sha1: 9bef1128717f958171a4afac3ed78ee2bb4e86ce&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;This repo does not include all assets necessary for compiling the ROMs. A prior copy of the game is required to extract the required assets.&lt;/p&gt;
&lt;h2&gt;Installation&lt;/h2&gt;
&lt;h3&gt;Linux&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;
&lt;p&gt;For each version (jp/us/eu) that you want to build a ROM for, put an existing ROM at &lt;code&gt;./baserom.&amp;lt;version&amp;gt;.z64&lt;/code&gt; for asset extraction.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Install the following packages:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;Debian / Ubuntu&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;git&lt;/li&gt;
&lt;li&gt;binutils-mips-linux-gnu / mips64-elf (&amp;gt;= 2.27)&lt;/li&gt;
&lt;li&gt;python3 (&amp;gt;= 3.7)&lt;/li&gt;
&lt;li&gt;build-essential&lt;/li&gt;
&lt;li&gt;pkg-config&lt;/li&gt;
&lt;li&gt;zlib1g-dev&lt;/li&gt;
&lt;li&gt;libaudiofile-dev&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Arch Linux&lt;/strong&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;Install qemu-irix&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;3.a Options: 1. Clone &lt;a href=&quot;https://github.com/n64decomp/qemu-irix&quot;&gt;https://github.com/n64decomp/qemu-irix&lt;/a&gt; to somewhere and follow its install instructions in the README. 2. Optionally, grab the prebuilt qemu-irix from the Releases section. 3. (Arch) Use AUR package &lt;a href=&quot;https://aur.archlinux.org/packages/qemu-irix-git&quot; rel=&quot;nofollow&quot;&gt;qemu-irix-git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.b (For options 1 or 2), copy executable &lt;code&gt;qemu-irix&lt;/code&gt; from irix-linux-user to somewhere convenient with a relatively short path.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir -p /opt/qemu-irix/bin
cp irix-linux-user/qemu-irix /opt/qemu-irix/bin
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.c Define &lt;code&gt;QEMU_IRIX&lt;/code&gt; environment variable in your &lt;code&gt;~/.bashrc&lt;/code&gt; to point to this qemu-irix executable.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export QEMU_IRIX=/opt/qemu-irix/bin/qemu-irix
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;Run &lt;code&gt;make&lt;/code&gt; to build the ROM (defaults to us version). Make sure your path to the repo is not too long or else this process will error, as the emulated IDO compiler cannot handle paths longer than 255 characters. Build examples:&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;make VERSION=jp -j4       # build (J) version instead with 4 jobs
make VERSION=eu COMPARE=0 # non-matching EU version still WIP
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;Windows&lt;/h2&gt;
&lt;p&gt;For Windows, install WSL and a distro of your choice and follow the Linux guide.&lt;/p&gt;
&lt;h2&gt;Contributing&lt;/h2&gt;
&lt;p&gt;Pull requests are welcome. For major changes, please open an issue first to discuss what you would like to change.&lt;/p&gt;
&lt;p&gt;Run clang-format on your code to ensure it meets the project's coding standards.&lt;/p&gt;
&lt;p&gt;Official discord: &lt;a href=&quot;https://discord.gg/27JtCWs&quot; rel=&quot;nofollow&quot;&gt;https://discord.gg/27JtCWs&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 26 Aug 2019 17:50:25 +0000</pubDate>
<dc:creator>sjuut</dc:creator>
<og:image>https://avatars0.githubusercontent.com/u/47247020?s=400&amp;v=4</og:image>
<og:type>object</og:type>
<og:title>n64decomp/sm64</og:title>
<og:url>https://github.com/n64decomp/sm64</og:url>
<og:description>A Super Mario 64 decompilation, brought to you by a bunch of clever folks. - n64decomp/sm64</og:description>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://github.com/n64decomp/sm64/blob/master/README.md</dc:identifier>
</item>
<item>
<title>Beyond Meat and KFC partner to test fried plant-based ‘chicken’</title>
<link>https://www.theverge.com/2019/8/26/20833145/beyond-meat-kfc-fried-chicken-test-plant-based-sample-date</link>
<guid isPermaLink="true" >https://www.theverge.com/2019/8/26/20833145/beyond-meat-kfc-fried-chicken-test-plant-based-sample-date</guid>
<description>&lt;p id=&quot;7TU1G6&quot;&gt;It seems like most fast-food chains are getting in on the fake meat trend. Beyond Meat and KFC announced today that they’re testing fried plant-based nuggets and boneless wings — Beyond Fried Chicken — at one Atlanta location on August 27th. Customers will receive a free sample when they purchase something that day, and KFC will ask for their feedback. Their thoughts will “be considered as KFC evaluates a broader test or potential national rollout,” KFC tells &lt;a href=&quot;https://www.bloomberg.com/news/articles/2019-08-26/beyond-fried-chicken-to-get-taste-tested-in-an-atlanta-kfc&quot;&gt;&lt;em&gt;Bloomberg&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p id=&quot;1lJRCQ&quot;&gt;Multiple fast-food restaurants have tested and implemented plant-based food options on their menus recently. Burger King rolled out its &lt;a href=&quot;https://www.theverge.com/2019/8/1/20750704/burger-king-nationwide-rollout-impossible-whopper-august-8&quot;&gt;Impossible Whopper&lt;/a&gt; to all of its US stores, and Subway announced plans to test the Beyond Meatball Marinara in 685 restaurants in the US and Canada. Carl’s Jr. &lt;a href=&quot;https://vegnews.com/2018/12/carls-jr-debuts-meatless-beyond-meat-famous-star-nationwide&quot;&gt;now sells&lt;/a&gt; a meatless burger made by Beyond Meat, and White Castle is offering the &lt;a href=&quot;https://www.whitecastle.com/promotions/impossible-slider&quot;&gt;Impossible Slider&lt;/a&gt;. These restaurants partner with either Impossible Foods or Beyond Meat, setting the companies up for fierce competition.&lt;/p&gt;
&lt;p id=&quot;eU1sn5&quot;&gt;Adding to the competitive atmosphere, Beyond Meat sells its products in grocery stores, while Impossible Foods is working to do so. The Food and Drug Administration &lt;a href=&quot;https://www.bloomberg.com/news/articles/2019-07-31/impossible-burger-s-color-gets-fda-nod-clearing-retail-hurdle&quot;&gt;just gave the green light&lt;/a&gt; to Impossible Foods by approving a key ingredient — soy leghemoglobin — for consumption.&lt;/p&gt;
&lt;p id=&quot;JKTQFM&quot;&gt;Beyond Meat went public earlier this year and &lt;a href=&quot;https://markets.businessinsider.com/news/stocks/beyond-meat-earnings-2q-stock-price-reaction-share-offering-2019-7-1028395472&quot;&gt;has said&lt;/a&gt; it expects to be profitable by the end of the year. In its more recent earnings call, the company said it plans to develop more meatless options, including ground beef. Impossible Foods has yet to go public, but investors are &lt;a href=&quot;https://www.wsj.com/articles/investors-jostle-for-pre-ipo-stake-in-impossible-foods-11566501399&quot;&gt;reportedly already&lt;/a&gt; trying to buy a stake.&lt;/p&gt;


</description>
<pubDate>Mon, 26 Aug 2019 15:52:29 +0000</pubDate>
<dc:creator>brundolf</dc:creator>
<og:description>More plant-based fast food.</og:description>
<og:image>https://cdn.vox-cdn.com/thumbor/jbdxh2zJRq_6WTuYEuaBMI0E70M=/0x878:1400x1611/fit-in/1200x630/cdn.vox-cdn.com/uploads/chorus_asset/file/19104836/kfc.jpg</og:image>
<og:title>Beyond Meat and KFC partner to test fried, plant-based &quot;chicken&quot;</og:title>
<og:type>article</og:type>
<og:url>https://www.theverge.com/2019/8/26/20833145/beyond-meat-kfc-fried-chicken-test-plant-based-sample-date</og:url>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.theverge.com/2019/8/26/20833145/beyond-meat-kfc-fried-chicken-test-plant-based-sample-date</dc:identifier>
</item>
<item>
<title>What Netflix’s ‘Great Hack’ Gets Wrong About Cambridge Analytica</title>
<link>https://www.thenation.com/article/cambridge-analytica-facebook-hack/</link>
<guid isPermaLink="true" >https://www.thenation.com/article/cambridge-analytica-facebook-hack/</guid>
<description>&lt;aside class=&quot;left full-width-mobile image wide indent&quot; readability=&quot;3&quot;&gt;&lt;a class=&quot;gallery imgHover&quot; href=&quot;https://www.thenation.com/wp-content/uploads/2018/04/facebook_ap_img.jpg&quot; title=&quot;Facebook logos displayed on a smartphone and computer screen. (Dominic Lipinski / PA Wire via AP Images)&quot;&gt;&lt;img src=&quot;https://www.thenation.com/wp-content/uploads/2018/04/facebook_ap_img.jpg?scale=896&amp;amp;compress=80&quot; alt=&quot;Facebook&quot;/&gt;&lt;/a&gt;
&lt;p class=&quot;caption&quot;&gt;Facebook logos displayed on a smartphone and computer screen. &lt;span class=&quot;credits&quot;&gt;(Dominic Lipinski / PA Wire via AP Images)&lt;/span&gt;&lt;/p&gt;
&lt;/aside&gt;
&lt;aside class=&quot;left indent indents email-signup-module para-one-1&quot; data-section=&quot;0&quot; readability=&quot;0.94017094017094&quot;&gt;
&lt;/aside&gt;&lt;aside class=&quot;left indent indents email-signup-module thanks para-one-thankyou&quot; id=&quot;para-one-thankyou-320742&quot; readability=&quot;0.84810126582278&quot;&gt;&lt;div class=&quot;emailetext-blocks thanks&quot; readability=&quot;27.139240506329&quot;&gt;Thank you for signing up. For more from &lt;em&gt;The Nation&lt;/em&gt;, check out our &lt;a class=&quot;textred-highlighted&quot; href=&quot;https://www.thenation.com/issue&quot;&gt;latest issue&lt;/a&gt;.&lt;/div&gt;
&lt;/aside&gt;&lt;aside class=&quot;left indent indents email-signup-module para-one-2&quot; data-section=&quot;1&quot; readability=&quot;1&quot;&gt;&lt;div class=&quot;emailetext-blocks&quot; readability=&quot;32&quot;&gt;
&lt;p&gt;Subscribe now for as little as $2 a month!&lt;/p&gt;

&lt;/div&gt;
&lt;/aside&gt;&lt;aside class=&quot;left indent indents email-signup-module para-one-3&quot; data-section=&quot;2&quot; readability=&quot;1&quot;&gt;&lt;div class=&quot;emailetext-blocks&quot; readability=&quot;32&quot;&gt;
&lt;h4&gt;Support Progressive Journalism&lt;/h4&gt;
&lt;em&gt;The Nation&lt;/em&gt; is reader supported: Chip in $10 or more to help us continue to write about the issues that matter.

&lt;/div&gt;
&lt;/aside&gt;&lt;aside class=&quot;left indent indents email-signup-module para-one-4&quot; data-section=&quot;3&quot; readability=&quot;0.94331983805668&quot;&gt;
&lt;/aside&gt;&lt;aside class=&quot;left indent indents email-signup-module thanks para-one-thankyou&quot; id=&quot;para-one-thankyou-320742&quot; readability=&quot;0.84810126582278&quot;&gt;&lt;div class=&quot;emailetext-blocks thanks&quot; readability=&quot;27.139240506329&quot;&gt;Thank you for signing up. For more from &lt;em&gt;The Nation&lt;/em&gt;, check out our &lt;a class=&quot;textred-highlighted&quot; href=&quot;https://www.thenation.com/issue&quot;&gt;latest issue&lt;/a&gt;.&lt;/div&gt;
&lt;/aside&gt;&lt;aside class=&quot;left indent indents email-signup-module para-one-5&quot; data-section=&quot;4&quot; readability=&quot;1.5&quot;&gt;&lt;div class=&quot;emailetext-blocks&quot; readability=&quot;33&quot;&gt;
&lt;h4&gt;Travel With &lt;em&gt;The Nation&lt;/em&gt;&lt;/h4&gt;
Be the first to hear about Nation Travels destinations, and explore the world with kindred spirits.

&lt;/div&gt;
&lt;/aside&gt;&lt;aside class=&quot;left indent indents email-signup-module para-one-6&quot; data-section=&quot;5&quot;&gt;&lt;div class=&quot;emailetext-blocks&quot;&gt;
&lt;h4&gt;Sign up for our Wine Club today.&lt;/h4&gt;
&lt;span data-sheets-value=&quot;{&quot; data-sheets-userformat=&quot;{&quot;&gt;Did you know you can support &lt;em&gt;The Nation&lt;/em&gt; by drinking wine?&lt;/span&gt;

&lt;/div&gt;
&lt;/aside&gt;&lt;p&gt;Two years ago, the world learned that Cambridge Analytica, a UK-based political consulting firm, had surreptitiously obtained more than 87 million Facebook member profiles, using that data to assist the Leave campaign in the Brexit vote and the Trump 2016 presidential campaign. This news set off a seismic shift in how the public and congressional leaders on both sides of the aisle view Big Tech, opening up space for a necessary rethinking of its role in society and creating momentum for new efforts to protect consumer privacy and better regulate the major platforms.&lt;span class=&quot;paranum hidden&quot;&gt;1&lt;/span&gt;&lt;/p&gt;
&lt;aside class=&quot;ad right most-popular-plus-ad grey_back&quot;&gt;
&lt;a href=&quot;http://www.thenation.com/advertising-policy&quot; class=&quot;ad-policy&quot; target=&quot;_blank&quot;&gt;Ad Policy&lt;/a&gt;&lt;/aside&gt;&lt;p&gt;Unfortunately, the Cambridge Analytica/Facebook scandal also has renewed a very old and disabling fable embraced by many well-meaning people on the left, which is that Americans (and others overseas) keep voting for right-wing authoritarians because they are being manipulated by the media. I’m old enough to remember the 1980s, when progressives sought to explain Ronald Reagan’s popularity by emphasizing the biases of mainstream media. Now, because many people are in awe of the magical powers of technology and lack basic literacy in how political persuasion works, a new fable is spreading—the notion of the Great Hack.&lt;span class=&quot;paranum hidden&quot;&gt;2&lt;/span&gt;&lt;/p&gt;
&lt;aside class=&quot;left indent indents related-oneup&quot;&gt;&lt;h4&gt;Related Article&lt;/h4&gt;

&lt;/aside&gt;&lt;p&gt;That’s the title of a new documentary about Cambridge Analytica released two weeks ago by Netflix. According to &lt;em&gt;The Great Hack&lt;/em&gt;, by collecting thousands of data points on millions of individuals and then building psychographic profiles linked to their inferred personality traits, Cambridge Analytica was able to target voters with unprecedented precision. As Peter Bradshaw put it in an adoring &lt;a href=&quot;https://www.theguardian.com/film/2019/jul/23/the-great-hack-review-cambridge-analytica-facebook-carole-cadwalladr-arron-banks&quot;&gt;review&lt;/a&gt; of the movie for &lt;em&gt;The Guardian&lt;/em&gt;, “The data attackers could go all in, using their underhand knowledge to bombard these psycho-profiled targets, to push these persuadables’ buttons and tip them over the edge with Facebook ads that popped up intimately on their smartphones, miraculously confirming their prejudices, playing on their insecurities, magnifying and warping their worries.”&lt;span class=&quot;paranum hidden&quot;&gt;3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The film gives an inordinate amount of attention to Brittany Kaiser, a Democrat who worked for CA’s US branch as its business development director and then—after the revelations of the Facebook breach—apparently had an attack of conscience. According to her, until CA started working for Trump in June 2016, his campaign had no data infrastructure or digital marketing apparatus and no digital strategy. The implication, never blatantly stated but simply conveyed by all the tricks of modern documentary-making—striking digital graphics meant to illustrate how our data leaks into the hands of others, ominous music, and alluring close-ups of Kaiser as she watches the scandal unfold on television—is that Trump won because Cambridge Analytica gave him a secret edge.&lt;span class=&quot;paranum hidden&quot;&gt;4&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;All of this is garbage. Kaiser first worked in politics as an intern on the 2008 Barack Obama campaign, helping its social media team, but &lt;em&gt;The Great Hack&lt;/em&gt; implies that she ran his whole Facebook operation. She is not the first person to pump a small role in that campaign into a career-making calling card; Cambridge Analytica is not the first political technology vendor to make big, unproven claims about its abilities. But we live in the age of silicon snake oil. There are millions of dollars to be made selling gullible investors and clients on mumbo-jumbo. Full disclosure: I got to see Kaiser pitch Cambridge Analytica’s wares at close quarters, back in 2015, when the company was briefly a member of the civic tech center I help run in New York City, Civic Hall. I was not impressed.&lt;span class=&quot;paranum hidden&quot;&gt;5&lt;/span&gt;&lt;/p&gt;
&lt;aside class=&quot;right hidden-on-mobile most-popular-plus-ad&quot;&gt;
&lt;/aside&gt;&lt;p&gt;Evidently, neither was Ted Cruz’s 2016 presidential campaign, which paid CA millions of dollars during the Republican primaries. &lt;em&gt;The Great Hack&lt;/em&gt; gives CA credit for his victory in the Iowa caucuses—and then makes no mention of what happened soon afterward: The Cruz campaign stopped using its data. Chris Wilson, the campaign’s director of research, analytics, and digital strategy, discovered that more than half the voters CA identified as Cruz supporters in Oklahoma backed other candidates. Regarding the so-called merits of psychographic targeting, Wilson told me CA “market[ed] their usage more aggressively than others and made unsubstantiated campaigns regarding its effectiveness.” On Twitter he called Kaiser a fantasist in 2016 for her claim that the Cruz campaign was planning to use “psy-ops” to manipulate delegates attending the Republican National Convention.&lt;span class=&quot;paranum hidden&quot;&gt;6&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;The closer one looks at Kaiser’s claims, the more they dissolve into a young staffer believing the hype that her company’s higher-ups asked her to sell. It’s not for nothing that political scientist Dave Karpf, who has written two books on the use of data in modern campaigns, calls Cambridge Analytica “the Theranos of political data.” Eight GOP political consultants told &lt;em&gt;Ad Age&lt;/em&gt;’s Kate Kaye that the company was “all hat and no cattle.”&lt;span class=&quot;paranum hidden&quot;&gt;7&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Here’s the bigger issue: When it comes to voters’ decisions about their choice of candidate, most forms of paid political persuasion, including TV ads, online ads, mailers, phone calls, and door knocking, have no discernible effect in terms of changing people’s minds. That’s the conclusion of a careful meta-review of 49 field experiments looking at general election campaigns, published by political scientists Joshua Kalla and David Broockman in the &lt;em&gt;American Political Science Review&lt;/em&gt; in 2018. They write, “The circumstances in which citizens’ political choices appear manipulable appear to be exceedingly rare in the elections that matter most.” Of course, all the people making money from selling the tools of political persuasion don’t want anyone to know this. Why spoil a good racket?&lt;span class=&quot;paranum hidden&quot;&gt;8&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;The Great Hack&lt;/em&gt; wants to make its viewers care about data rights and the dangers of modern misinformation campaigns but unfortunately is itself a slick piece of misinformation that plays artfully on the prejudices and misunderstandings rife in its targeted audience. If the weaponization of misinformation was such a powerful tool for changing hearts and minds, why did the left win recent elections in Mexico and Istanbul? Why did Democrats retake the House in 2018? We aren’t losing the war for the future because of some new media masterminds. If we’re losing, it’s because our message—and messengers—aren’t connecting.&lt;span class=&quot;paranum hidden&quot;&gt;9&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 26 Aug 2019 14:17:14 +0000</pubDate>
<dc:creator>bookofjoe</dc:creator>
<og:type>article</og:type>
<og:title>What Netflix’s ‘Great Hack’ Gets Wrong About Cambridge Analytica</og:title>
<og:description>The British consulting firm didn’t steal the 2016 election, and it couldn’t have if it tried.</og:description>
<og:url>https://www.thenation.com/article/cambridge-analytica-facebook-hack/</og:url>
<og:image>https://www.thenation.com/wp-content/uploads/2018/04/facebook_ap_img.jpg</og:image>
<dc:language>en-US</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.thenation.com/article/cambridge-analytica-facebook-hack/</dc:identifier>
</item>
<item>
<title>Pronunciations for hexadecimal numbers (1968)</title>
<link>https://twitter.com/lizhenry/status/1165760903809130496</link>
<guid isPermaLink="true" >https://twitter.com/lizhenry/status/1165760903809130496</guid>
<description>[unable to retrieve full-text content]
&lt;p&gt;Article URL: &lt;a href=&quot;https://twitter.com/lizhenry/status/1165760903809130496&quot;&gt;https://twitter.com/lizhenry/status/1165760903809130496&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Comments URL: &lt;a href=&quot;https://news.ycombinator.com/item?id=20798322&quot;&gt;https://news.ycombinator.com/item?id=20798322&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Points: 463&lt;/p&gt;
&lt;p&gt;# Comments: 105&lt;/p&gt;
</description>
<pubDate>Mon, 26 Aug 2019 09:01:08 +0000</pubDate>
<dc:creator>henrik_w</dc:creator>
<dc:format>text/html</dc:format>
<dc:identifier>https://mobile.twitter.com/lizhenry/status/1165760903809130496</dc:identifier>
</item>
<item>
<title>Moscow&amp;#039;s blockchain voting system cracked a month before election</title>
<link>https://www.zdnet.com/article/moscows-blockchain-voting-system-cracked-a-month-before-election/</link>
<guid isPermaLink="true" >https://www.zdnet.com/article/moscows-blockchain-voting-system-cracked-a-month-before-election/</guid>
<description>&lt;span class=&quot;img aspect-set&quot;&gt;&lt;img src=&quot;https://zdnet4.cbsistatic.com/hub/i/2019/08/20/86135a4b-cbf1-413d-86f7-3ec4fde77d57/f3a803b68d003f38d3888551c5f02010/moscow.jpg&quot; class=&quot;&quot; alt=&quot;Moscow, Russia&quot;/&gt;&lt;/span&gt;&lt;p&gt;A French security researcher has found a critical vulnerability in the blockchain-based voting system Russian officials plan to use next month for the 2019 &lt;a href=&quot;https://en.wikipedia.org/wiki/Moscow_City_Duma&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Moscow City Duma&lt;/a&gt; election.&lt;/p&gt;
&lt;p&gt;Pierrick Gaudry, an academic at Lorraine University and a researcher for INRIA, the French research institute for digital sciences, found that he could compute the voting system's private keys based on its public keys. This private keys are used together with the public keys to encrypt user votes cast in the election.&lt;/p&gt;
&lt;h3&gt;Moscow blockchain voting system encryption broken in 20 minutes&lt;/h3&gt;
&lt;p&gt;Gaudry blamed the issue on Russian officials using a variant of the &lt;a href=&quot;https://en.wikipedia.org/wiki/ElGamal_encryption&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;ElGamal encryption scheme&lt;/a&gt; that used encryption key sizes that were too small to be secure. This meant that modern computers could break the encryption scheme within minutes.&lt;/p&gt;
&lt;p&gt;&quot;It can be broken in about 20 minutes using a standard personal computer, and using only free software that is publicly available,&quot; &lt;a href=&quot;https://members.loria.fr/PGaudry/moscow/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Gaudry said in a report&lt;/a&gt; published earlier this month.&lt;/p&gt;
&lt;p&gt;&quot;Once these [private keys] are known, any encrypted data can be decrypted as quickly as they are created,&quot; he added.&lt;/p&gt;


&lt;p&gt;What an attacker can do with these encryption keys is currently unknown, since the voting system's protocols weren't yet available in English, so Gaudry couldn't investigate further.&lt;/p&gt;
&lt;p&gt;&quot;Without having read the protocol, it is hard to tell precisely the consequences, because, although we believe that this weak encryption scheme is used to encrypt the ballots, it is unclear how easy it is for an attacker to have the correspondence between the ballots and the voters,&quot; the French researcher said.&lt;/p&gt;
&lt;section class=&quot;sharethrough-top&quot; data-component=&quot;medusaContentRecommendation&quot; data-medusa-content-recommendation-options=&quot;{&amp;quot;promo&amp;quot;:&amp;quot;promo_ZD_recommendation_sharethrough_top_in_article_desktop&amp;quot;,&amp;quot;spot&amp;quot;:&amp;quot;dfp-in-article&amp;quot;}&quot;&gt;
&lt;/section&gt;&lt;p&gt;&quot;In the worst case scenario, the votes of all the voters using this system would be revealed to anyone as soon as they cast their vote.&quot;&lt;/p&gt;
&lt;h3&gt;A first-of-its-kind system&lt;/h3&gt;


&lt;p&gt;Moscow's blockchain voting system is a first of its kind. It was developed in-house by the Moscow Department of Information Technology, and works as a &quot;&lt;a href=&quot;https://en.wikipedia.org/wiki/Smart_contract&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;smart contract&lt;/a&gt;&quot; on top of the Ethereum blockchain platform.&lt;/p&gt;
&lt;p&gt;The voting system is set to go live on September 8, and will run for 12 hours, in sync with the official voting session.&lt;/p&gt;
&lt;p&gt;Once deployed on election day (September 8), it will allow Moscow residents to vote in the election via the internet, via their phones or home computers, and have their votes cryptographically recorded on the public Ethereum blockchain.&lt;/p&gt;
&lt;p&gt;This internet and blockchain-based voting system isn't limited just to people traveling abroad or people with disabilities. Everyone who registers in advance can use it, meaning it has the potential to attract people who'd normally skip election days.&lt;/p&gt;
&lt;p&gt;When deployed next month, Moscow's internet voting system would become the first blockchain-based system used in a legally binding election, and not just in limited tests.&lt;/p&gt;
&lt;h3&gt;Moscow officials promise a fix&lt;/h3&gt;
&lt;p&gt;The French academic was able to test Moscow's upcoming blockchain-based voting system because officials published its &lt;a href=&quot;https://github.com/moscow-technologies/blockchain-voting&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;source code on GitHub&lt;/a&gt; in July, and asked security researchers to take their best shots.&lt;/p&gt;
&lt;p&gt;Following Gaudry's discovery, the Moscow Department of Information Technology promised to fix the reported issue -- the use of a weak private key.&lt;/p&gt;
&lt;p&gt;&quot;We absolutely agree that 256x3 private key length is not secure enough,&quot; &lt;a href=&quot;https://medium.com/@unassuming_teal_crab_127/dear-julia-7bac3612b178&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;a spokesperson said in an online response&lt;/a&gt;. &quot;This implementation was used only in a trial period. In few days the key's length will be changed to 1024.&quot;&lt;/p&gt;
&lt;p&gt;Gaudry, who discovered that Moscow officials modified the ElGamal encryption scheme to use three weaker private keys instead of one, couldn't explain why the IT department chose this route.&lt;/p&gt;
&lt;p&gt;&quot;This is a mystery,&quot; the French researcher said. &quot;The only possible explanation we can think of is that the designers thought this would compensate for the too small key sizes of the primes involved. But 3 primes of 256 bits are really not the same as one prime of 768 bits.&quot;&lt;/p&gt;
&lt;p&gt;However, a public key of a length of 1024 bits may not be enough, &lt;a href=&quot;https://arxiv.org/pdf/1908.05127.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;according to Gaudry&lt;/a&gt;, who believes officials should use one of at least 2048 bits instead.&lt;/p&gt;
&lt;p&gt;This design decision also baffled Chris Roberts, Chief Security Strategist at Attivo Networks.&lt;/p&gt;
&lt;p&gt;&quot;Why on this planet would the developers of the platform choose a weak length in the first place is obviously a question. Is it lack of knowledge and understanding? Or simply looking to maximize speed and efficiency or something else,&quot; Roberts said.&lt;/p&gt;
&lt;h3&gt;&quot;The US system COULD learn a lot from Mother Russia&quot;&lt;/h3&gt;
&lt;p&gt;&quot;There is a good side to this,&quot; he added. &quot;The fact that Moscow allowed others to look at the code, research it and then help them secure it.&quot;&lt;/p&gt;
&lt;p&gt;Furthermore, Moscow officials also approved a monetary reward for Gaudry, who according to Russian news site Meduza, &lt;a href=&quot;https://meduza.io/en/feature/2019/08/20/after-hackers-break-moscow-s-prototype-internet-voting-city-officials-stop-sharing-contest-results-on-github&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;stands to make one million Russian ruble&lt;/a&gt;, which is just over $15,000.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/@juliakrivonosova/internet-voting-in-russia-how-9382db4da71f&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;According to a previous report from July&lt;/a&gt;, Gaudry's reward is near the top prize the Moscow local government promised bug hunters when it put the code on GitHub, which was 1.5 million Russian ruble ($22,500).&lt;/p&gt;
&lt;p&gt;&quot;The US system COULD learn a lot from Mother Russia on this one,&quot; Roberts said, referring to the &lt;a href=&quot;https://www.vice.com/en_us/article/3kxzk9/exclusive-critical-us-election-systems-have-been-left-exposed-online-despite-official-denials&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;plethora of growing pains&lt;/a&gt; the US has been going through recently while trying to secure its electronic voting machines.&lt;/p&gt;
&lt;p&gt;These growing pains mostly come from voting machine vendors, who are &lt;a href=&quot;https://www.cyberscoop.com/def-con-voting-village-2019/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;refusing to engage with the cyber-security community&lt;/a&gt;, something the Moscow government had no problem doing.&lt;/p&gt;
&lt;p&gt;This closed-source nature around electronic voting machines and election systems used in the US is the reason why Microsoft recently announced plans to open-source on GitHub &lt;a href=&quot;https://www.zdnet.com/article/microsoft-demos-electionguard-technology-for-securing-electronic-voting-machines/&quot; target=&quot;_blank&quot;&gt;a new technology for securing electronic voting machines&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;Related cybersecurity coverage:&lt;/h3&gt;
</description>
<pubDate>Mon, 26 Aug 2019 07:29:12 +0000</pubDate>
<dc:creator>svenfaw</dc:creator>
<og:type>article</og:type>
<og:url>https://www.zdnet.com/article/moscows-blockchain-voting-system-cracked-a-month-before-election/</og:url>
<og:title>Moscow's blockchain voting system cracked a month before election | ZDNet</og:title>
<og:description>French researcher nets $15,000 prize for finding bugs in Moscow's Ethereum-based voting system.</og:description>
<og:image>https://zdnet2.cbsistatic.com/hub/i/r/2019/08/20/86135a4b-cbf1-413d-86f7-3ec4fde77d57/thumbnail/770x578/d87da918851d37da8399589a75588a17/moscow.jpg</og:image>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.zdnet.com/article/moscows-blockchain-voting-system-cracked-a-month-before-election/</dc:identifier>
</item>
<item>
<title>Should small Rust structs be passed by-copy or by-borrow?</title>
<link>https://www.forrestthewoods.com/blog/should-small-rust-structs-be-passed-by-copy-or-by-borrow/</link>
<guid isPermaLink="true" >https://www.forrestthewoods.com/blog/should-small-rust-structs-be-passed-by-copy-or-by-borrow/</guid>
<description>&lt;div readability=&quot;251.75799149403&quot;&gt;
&lt;p class=&quot;m_bottom_xxs&quot;&gt;Like many good stories, this one started with a simple question. Should small Rust structs be passed by-copy or by-borrow? For example:&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt; Vector3 {
    x&lt;span&gt;:&lt;/span&gt; &lt;span&gt;f32&lt;/span&gt;,
    y&lt;span&gt;:&lt;/span&gt; &lt;span&gt;f32&lt;/span&gt;,
    z&lt;span&gt;:&lt;/span&gt; &lt;span&gt;f32&lt;/span&gt;
}

&lt;span&gt;fn&lt;/span&gt; dot_product_by_copy(a&lt;span&gt;:&lt;/span&gt; Vector3, b&lt;span&gt;:&lt;/span&gt; Vector3) &lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; {
    a.x&lt;span&gt;*&lt;/span&gt;b.x &lt;span&gt;+&lt;/span&gt; a.y&lt;span&gt;*&lt;/span&gt;b.y &lt;span&gt;+&lt;/span&gt; a.z&lt;span&gt;*&lt;/span&gt;b.z
}

&lt;span&gt;fn&lt;/span&gt; dot_product_by_borrow(a&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt;Vector3, b&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt;Vector3) &lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; {
    a.x&lt;span&gt;*&lt;/span&gt;b.x &lt;span&gt;+&lt;/span&gt; a.y&lt;span&gt;*&lt;/span&gt;b.y &lt;span&gt;+&lt;/span&gt; a.z&lt;span&gt;*&lt;/span&gt;b.z
}
&lt;/pre&gt;
&lt;p&gt;This simple question sent me on a benchmarking odyssey with some surprising twists and discoveries.&lt;/p&gt;


&lt;p&gt;The answer to this question matters for two reasons — performance and ergonomics.&lt;/p&gt;

&lt;p&gt;Passing by-copy should mean we copy 12-bytes per &lt;code&gt;Vector3&lt;/code&gt;. Passing by-borrow should pass an 8-byte pointer per &lt;code&gt;Vector3&lt;/code&gt; (on 64-bit). That's close enough to maybe not matter.&lt;/p&gt;
&lt;p&gt;But if we change &lt;code&gt;f32&lt;/code&gt; to &lt;code&gt;f64&lt;/code&gt; now it's 8-bytes (by-borrow) versus 24-bytes (by-copy). For code that uses a &lt;code&gt;Vector4&lt;/code&gt; of &lt;code&gt;f64&lt;/code&gt; we're suddenly talking about 8-bytes versus 32-bytes.&lt;/p&gt;

&lt;p&gt;In C++ I know exactly how I'd write this.&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt; Vector3 {
    &lt;span&gt;float&lt;/span&gt; x;
    &lt;span&gt;float&lt;/span&gt; y;
    &lt;span&gt;float&lt;/span&gt; z;
};

&lt;span&gt;float&lt;/span&gt; &lt;span&gt;dot_product&lt;/span&gt;(Vector3 &lt;span&gt;const&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt; a, Vector3 &lt;span&gt;const&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt; b) {
    &lt;span&gt;return&lt;/span&gt; a.x&lt;span&gt;*&lt;/span&gt;b.x &lt;span&gt;+&lt;/span&gt; a.y&lt;span&gt;*&lt;/span&gt;b.y &lt;span&gt;+&lt;/span&gt; a.z&lt;span&gt;*&lt;/span&gt;b.z
}
&lt;/pre&gt;
&lt;p&gt;Easy peasy. Pass by const-reference and call it day.&lt;/p&gt;
&lt;p&gt;The problem with Rust is ergonomics. When passing by-copy you can combine mathematical operations cleanly and simply.&lt;/p&gt;
&lt;pre st=&quot;&quot;&gt;
&lt;span&gt;fn&lt;/span&gt; do_math(p1&lt;span&gt;:&lt;/span&gt; Vector3, p2&lt;span&gt;:&lt;/span&gt; Vector3, d1&lt;span&gt;:&lt;/span&gt; Vector3, d2&lt;span&gt;:&lt;/span&gt; Vector3, s&lt;span&gt;:&lt;/span&gt; &lt;span&gt;f32&lt;/span&gt;, t&lt;span&gt;:&lt;/span&gt; &lt;span&gt;f32&lt;/span&gt;) &lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;f32&lt;/span&gt; {
    &lt;span&gt;let&lt;/span&gt; a &lt;span&gt;=&lt;/span&gt; p1 &lt;span&gt;+&lt;/span&gt; s&lt;span&gt;*&lt;/span&gt;d1;
    &lt;span&gt;let&lt;/span&gt; b &lt;span&gt;=&lt;/span&gt; p2 &lt;span&gt;+&lt;/span&gt; s&lt;span&gt;*&lt;/span&gt;d2;
    dot_product(b &lt;span&gt;-&lt;/span&gt; a, b &lt;span&gt;-&lt;/span&gt; a)
}
&lt;/pre&gt;
&lt;p&gt;However when using borrow semantics it turns into this ugly mess:&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;fn&lt;/span&gt; do_math(p1&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt;Vector3, p2&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt;Vector3, d1&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt;Vector3, d2&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt;Vector3, s&lt;span&gt;:&lt;/span&gt; &lt;span&gt;f32&lt;/span&gt;, t&lt;span&gt;:&lt;/span&gt; &lt;span&gt;f32&lt;/span&gt;) &lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;f32&lt;/span&gt; {
    &lt;span&gt;let&lt;/span&gt; a &lt;span&gt;=&lt;/span&gt; p1 &lt;span&gt;+&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt;(&lt;span&gt;&amp;amp;&lt;/span&gt;d1&lt;span&gt;*&lt;/span&gt;s);
    &lt;span&gt;let&lt;/span&gt; b &lt;span&gt;=&lt;/span&gt; p2 &lt;span&gt;+&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt;(&lt;span&gt;&amp;amp;&lt;/span&gt;d2&lt;span&gt;*&lt;/span&gt;t);
    &lt;span&gt;let&lt;/span&gt; result &lt;span&gt;=&lt;/span&gt; dot_product(&lt;span&gt;&amp;amp;&lt;/span&gt;(&lt;span&gt;&amp;amp;&lt;/span&gt;b &lt;span&gt;-&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt;a), &lt;span&gt;&amp;amp;&lt;/span&gt;(&lt;span&gt;&amp;amp;&lt;/span&gt;b &lt;span&gt;-&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt;a));
}
&lt;/pre&gt;
&lt;p&gt;Blech! Having to explicitly borrow temporary values is super gross. 🤮&lt;/p&gt;


&lt;p&gt;So, should Rust pass small structs, like &lt;code&gt;Vector3&lt;/code&gt;, by-copy or by-borrow?&lt;/p&gt;
&lt;p&gt;None of Twitter, Reddit, or StackOverflow had a good answer. I checked popular crates like nalgebra (by-borrow) and cgmath (by-value) and found both ways are common.&lt;/p&gt;
&lt;p&gt;I don't like the ergonomics of by-borrow. But what about performance? If by-copy is fast then none of this matters. So I did the only thing that seemed reasonable. I built a benchmark!&lt;/p&gt;
&lt;p&gt;I wanted some to test something slightly more than raw operator performance. It's still a silly synthetic benchmark that is not representative of a real application. But it's a good starting point. Here's &lt;em&gt;roughly&lt;/em&gt; what I came up with.&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;let&lt;/span&gt; num_shapes &lt;span&gt;=&lt;/span&gt; &lt;span&gt;4000&lt;/span&gt;;
&lt;span&gt;for&lt;/span&gt; cycle in &lt;span&gt;0.&lt;/span&gt;..&lt;span&gt;5&lt;/span&gt; {
    &lt;span&gt;let&lt;/span&gt; (spheres, capsules, segments, triangles) &lt;span&gt;=&lt;/span&gt; generate_shapes(num_shapes);
    &lt;span&gt;for&lt;/span&gt; run in &lt;span&gt;0.&lt;/span&gt;.&lt;span&gt;5&lt;/span&gt; {
        &lt;span&gt;for&lt;/span&gt; (a,b) in collision_pairs {
            test_by_copy(a,b)
        }
        &lt;span&gt;for&lt;/span&gt; pair in collision_pairs {
            test_by_borrow(&lt;span&gt;&amp;amp;&lt;/span&gt;a, &lt;span&gt;&amp;amp;&lt;/span&gt;b)
        }
    }
}
&lt;/pre&gt;
&lt;p&gt;I randomly generate 4000 spheres, capsules, segments, and triangles. Then I perform a simple overlap test for SphereSphere, SphereCapsule, CapsuleCapsule, and SegmentTriangle for all pairs. These tests are run by-copy and by-borrow. Only time spent inside test_by_copy and test_by_borrow is counted.&lt;/p&gt;
&lt;p&gt;Each full benchmark performs 3.2 billion comparisons and finds ~220 million overlapping pairs. Here are some results running single-threaded on my beefy i7-8700k Windows desktop. All times are in milliseconds.&lt;/p&gt;
&lt;p&gt; &amp;amp;nbspRust&lt;br/&gt;   &amp;amp;nbspf32 by-copy:  &amp;amp;nbsp7,109&lt;br/&gt;   &amp;amp;nbspf32 by-borrow: 7,172 &lt;span&gt;(0.88% slower)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;   &amp;amp;nbspf64 by-copy:  &amp;amp;nbsp9,642&lt;br/&gt;   &amp;amp;nbspf64 by-borrow: 9,601 &lt;span&gt;(0.42% faster)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Well this is mildly surprising. Passing by-copy or by-borrow barely makes a difference! These results are quite consistent. Although a difference of less than 1% is well within the margin of error.&lt;/p&gt;
&lt;p&gt;Is this the answer to our question? Should we pass by-copy and call it a day? I'm not ready to say.&lt;/p&gt;


&lt;p&gt;After my initial Rust benchmarks I decided to port my test suite to C++. The code is similar, but not identical. Both Rust and C++ implementations are what I would consider idiomatic in their respective languages.&lt;/p&gt;
&lt;p&gt; &amp;amp;nbspC++&lt;br/&gt;   &amp;amp;nbspf32 by-copy:  &amp;amp;nbsp14,526&lt;br/&gt;   &amp;amp;nbspf32 by-borrow: 13,880 &lt;span&gt;(4.5% faster)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;   &amp;amp;nbspf64 by-copy:  &amp;amp;nbsp13,439&lt;br/&gt;   &amp;amp;nbspf64 by-borrow: 13,942 &lt;span&gt;(3.8% slower)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;m_top_s&quot;&gt;Wait, what?! At least two things are super weird here.&lt;/p&gt;
&lt;ol class=&quot;list_spacing m_top_s m_bottom_s&quot;&gt;&lt;li&gt;&lt;code&gt;double&lt;/code&gt; by-value is &lt;em&gt;faster&lt;/em&gt; than &lt;code&gt;float&lt;/code&gt; by-value&lt;/li&gt;
&lt;li&gt;C++ &lt;code&gt;float&lt;/code&gt; is twice as slow as Rust &lt;code&gt;f32&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Clearly something unexpected is going on. Using Visual Studio 2019 I grabbed a pair of quick CPU profiles.&lt;/p&gt;
&lt;img class=&quot;embed_img_s m_bottom_xs&quot; src=&quot;https://www.forrestthewoods.com/blog/should-small-rust-structs-be-passed-by-copy-or-by-borrow/assets/img/01.png&quot; alt=&quot;Visual Studio Benchmark C++ Result&quot;/&gt;&lt;p class=&quot;text_caption m_bottom_m&quot;&gt;C++ Profile&lt;/p&gt;
&lt;img class=&quot;embed_img_s m_bottom_xs&quot; src=&quot;https://www.forrestthewoods.com/blog/should-small-rust-structs-be-passed-by-copy-or-by-borrow/assets/img/02.png&quot; alt=&quot;Visual Studio Benchmark Reust Result&quot;/&gt;&lt;p class=&quot;text_caption m_bottom_m&quot;&gt;Rust Profile&lt;/p&gt;
&lt;p&gt;Ah hah! Rust appears to be inlining almost everything. Let's copy Rust and throw a quick &lt;code&gt;__forceinline&lt;/code&gt; infront of everything in our C++ impl.&lt;/p&gt;
&lt;p&gt; &amp;amp;nbspC++ w/ inlining&lt;br/&gt;   &amp;amp;nbspf32 by-copy:  &amp;amp;nbsp12,688&lt;br/&gt;   &amp;amp;nbspf32 by-borrow: 12,108 &lt;span&gt;(4.5% faster)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;   &amp;amp;nbspf64 by-copy:  &amp;amp;nbsp11,860&lt;br/&gt;   &amp;amp;nbspf64 by-borrow: 11,967 &lt;span&gt;(0.9% slower)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Inlining C++ provides a decent ~12% boost. But &lt;code&gt;double&lt;/code&gt; is still faster than &lt;code&gt;float&lt;/code&gt;. And C++ is still way slower than Rust.&lt;/p&gt;


&lt;p&gt;I would consider my C++ and Rust implementations to both be idiomatic. However they are different! C++ takes out parameters by reference while Rust returns a tuple. This is because Rust tuples are delightful to use and C++ tuples are a monstrosity. But I digress.&lt;/p&gt;
&lt;pre st=&quot;&quot;&gt;
&lt;span&gt;// Rust&lt;/span&gt;
&lt;span&gt;fn&lt;/span&gt; closest_pt_segment_segment(p1&lt;span&gt;:&lt;/span&gt; Vector3, q1&lt;span&gt;:&lt;/span&gt; Vector3, p2&lt;span&gt;:&lt;/span&gt; Vector3, q2&lt;span&gt;:&lt;/span&gt; Vector3) 
&lt;span&gt;-&amp;gt;&lt;/span&gt; (T, T, T, Vector3, Vector3) 
{
    &lt;span&gt;// Do math&lt;/span&gt;
}
&lt;/pre&gt;
&lt;pre class=&quot;m_bottom_l&quot;&gt;
&lt;span&gt;// C++&lt;/span&gt;
&lt;span&gt;float&lt;/span&gt; &lt;span&gt;closest_pt_segment_segment&lt;/span&gt;(
    Vector3 p1, Vector3 q1, Vector3 p2, Vector3 q2,
    &lt;span&gt;float&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt; s, &lt;span&gt;float&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt; t, Vector3&lt;span&gt;&amp;amp;&lt;/span&gt; c1, Vector3&lt;span&gt;&amp;amp;&lt;/span&gt; c2)
{
    &lt;span&gt;// Do math&lt;/span&gt;
}
&lt;/pre&gt;
&lt;p&gt;This subtle difference could cause a huge impact on performance. The C++ version compiler can't be sure the out parameters aren't aliased. Which may limit its ability to optimize. Meanwhile Rust uses and returns local variables which are known to be non-aliased.&lt;/p&gt;
&lt;p&gt;Interestingly, fixing the aliasing above doesn't make a difference! With inlining the compiler handles it already. Much to my surprise, what C++ does not handle well is the following:&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; &lt;span&gt;run_test&lt;/span&gt;(
    vector&lt;span&gt;&amp;lt;&lt;/span&gt;TSphere&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;const&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt; _spheres,
    vector&lt;span&gt;&amp;lt;&lt;/span&gt;TCapsule&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;const&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt; _capsules,
    vector&lt;span&gt;&amp;lt;&lt;/span&gt;TSegment&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;const&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt; _segments,
    vector&lt;span&gt;&amp;lt;&lt;/span&gt;TTriangle&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;const&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt; _triangles,
    &lt;span&gt;int64_t&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt; num_overlaps,
    &lt;span&gt;int64_t&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt; milliseconds)
{
    &lt;span&gt;// perform overlaps&lt;/span&gt;
}
&lt;/pre&gt;
&lt;p&gt;Changing &lt;code&gt;run_test&lt;/code&gt; to return &lt;code&gt;std::tuple&amp;lt;int64_t, int64_t&amp;gt;&lt;/code&gt; provides a small but noticeable improvement.&lt;/p&gt;
&lt;p&gt; &amp;amp;nbspC++ w/ inlining, tuples&lt;br/&gt;   &amp;amp;nbspf32 by-copy:  &amp;amp;nbsp12,863&lt;br/&gt;   &amp;amp;nbspf32 by-borrow: 11,555 &lt;span&gt;(10.17% faster)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;   &amp;amp;nbspf64 by-copy:  &amp;amp;nbsp11,832&lt;br/&gt;   &amp;amp;nbspf64 by-borrow: 11,524 &lt;span&gt;(2.60% faster)&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;At this point both C++ and Rust are compiling with default options. Visual Studio exposes a ton of flags. I tried tweaking a bunch of flags to improve performance.&lt;/p&gt;
&lt;ul class=&quot;list_spacing m_bottom_s&quot;&gt;&lt;li&gt;Favor fast code (/Ot)&lt;/li&gt;
&lt;li&gt;Disable exceptions&lt;/li&gt;
&lt;li&gt;Advanced Vector Extensions 2 (/arch:AVX2)&lt;/li&gt;
&lt;li&gt;Floating Point Mode: Fast (/fp:fast)&lt;/li&gt;
&lt;li&gt;Enable Floating Point Exceptions: No (/fp:except-)&lt;/li&gt;
&lt;li&gt;Disable security check /GS-&lt;/li&gt;
&lt;li&gt;Control flow guard: No&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;The only flags that made a real difference were &quot;disable exceptions&quot; and AVX2. Each about 10%. I decided to leave off AVX2 in an attempt to equal Rust.&lt;/p&gt;
&lt;p&gt; &amp;amp;nbspC++ w/ inlining, tuples, no C++ exceptions&lt;br/&gt;   &amp;amp;nbspf32 by-copy:  &amp;amp;nbsp11,651&lt;br/&gt;   &amp;amp;nbspf32 by-borrow: 10,455 &lt;span&gt;(10.27% faster)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;   &amp;amp;nbspf64 by-copy:  &amp;amp;nbsp10,866&lt;br/&gt;   &amp;amp;nbspf64 by-borrow: 10,467 &lt;span&gt;(3.67% faster)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;We've made three C++ optimizations but our two mysteries remain. Why is &lt;code&gt;double&lt;/code&gt; faster than &lt;code&gt;float&lt;/code&gt;? And why is C++ still so much slower than Rust?&lt;/p&gt;


&lt;p&gt;I tried looking at the disassembly in &lt;a href=&quot;https://godbolt.org/z/1gENA_&quot;&gt;Godbolt&lt;/a&gt;. There's obviously differences. But I'm not smart enough to quantify them.&lt;/p&gt;
&lt;/div&gt;&lt;div readability=&quot;84.801549865229&quot;&gt;
&lt;p&gt;Branch misprediction is awful. Not surprising. Take a close look at Vector Capacity Usage (FPU). Here's how that value is reported for different builds:&lt;/p&gt;
&lt;p&gt; &amp;amp;nbspRust f32    42.3%&lt;br/&gt; &amp;amp;nbspRust f64    32.7%&lt;br/&gt; &amp;amp;nbspC++  float  12.5%&lt;br/&gt; &amp;amp;nbspC++  double 25.0%&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;Yowza! For whatever reason, and I don't know exactly what, Rust is remarkably more efficient at utilizing my CPU's floating point vectors. The difference is enormous! Rust &lt;code&gt;f32&lt;/code&gt; is almost 3.5x more efficient than C++ &lt;code&gt;float&lt;/code&gt;. And, for some reason, C++ &lt;code&gt;double&lt;/code&gt; is twice as efficient as &lt;code&gt;float&lt;/code&gt;! 🤷‍♂️&lt;/p&gt;
&lt;p&gt;The obvious guess is that the Rust compiler simply does a better job of auto-vectorization. Is that the whole story or is there more? I honestly don't know. This is as deep as I'm going to dig for now. If any experts would like to chime in with more details I'm all ears.&lt;/p&gt;


&lt;p&gt;Somehow my Rust article has spent more time talking about C++. But that's ok!&lt;/p&gt;
&lt;p&gt;Our initial tests showed a less than one-percent different between by-copy and by-borrow. In my synthetic test the key reason appears to be because Rust auto-inlined the crap out of my code. Despite my not having a single &lt;code&gt;#[inline]&lt;/code&gt; declaration! Furthermore, Rust automatically produced code twice as fast as a similar C++ implementation.&lt;/p&gt;
&lt;p&gt;My answer to by-copy versus by-borrow for small Rust structs is &lt;strong&gt;by-copy&lt;/strong&gt;. This answer comes with several caveats.&lt;/p&gt;
&lt;ol class=&quot;list_spacing m_top_xs m_bottom_s&quot;&gt;&lt;li&gt;The definition of &quot;small&quot; is untested and unknown.&lt;/li&gt;
&lt;li&gt;Less mathematical structs may not work as well due to less auto-vectorization.&lt;/li&gt;
&lt;li&gt;Performant by-copy code likely requires inlining and trusting the compiler. 😱&lt;/li&gt;
&lt;li&gt;Including small structs implemented in another crate is untested.&lt;/li&gt;
&lt;li&gt;Synthetic benchmarks are not reflective of the real world. Always measure!&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I started with a simple question and went on a fun and educational journey. At this point I'm going to move forward with passing small structs by-copy. I'm not 100% convinced it's the right choice in all cases. But I'm going to give it a whirl for a vector math library.&lt;/p&gt;
&lt;p&gt;I suspect there will be a scenario where this is not as performant. I would advise cautious optimism. Trust the compiler to make good decisions... but verify your real-world scenario.&lt;/p&gt;
&lt;p&gt;Thanks for reading.&lt;/p&gt;


&lt;p&gt;Full source code for my benchmark is available.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.forrestthewoods.com/blog/should-small-rust-structs-be-passed-by-copy-or-by-borrow/assets/data/fts_small_struct_bench.zip&quot;&gt;FullProjects.zip&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Rust&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://www.forrestthewoods.com/blog/should-small-rust-structs-be-passed-by-copy-or-by-borrow/rust_main&quot;&gt;main.rs&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.forrestthewoods.com/blog/should-small-rust-structs-be-passed-by-copy-or-by-borrow/rust_by_copy&quot;&gt;by_copy.rs&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.forrestthewoods.com/blog/should-small-rust-structs-be-passed-by-copy-or-by-borrow/rust_by_borrow&quot;&gt;by_borrow.rs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;C++&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://www.forrestthewoods.com/blog/should-small-rust-structs-be-passed-by-copy-or-by-borrow/cpp_main&quot;&gt;main.cpp&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.forrestthewoods.com/blog/should-small-rust-structs-be-passed-by-copy-or-by-borrow/cpp_by_value&quot;&gt;by_value.cpp&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.forrestthewoods.com/blog/should-small-rust-structs-be-passed-by-copy-or-by-borrow/cpp_by_ref&quot;&gt;by_ref.cpp&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;All C++ benchmarks above were done using the MSVC build chain in Visual Studio 2019. I wondered if Clang would do a better job. It's a little faster for by-value. But it does a remarkably poor job of handling doubles by-ref.&lt;/p&gt;
&lt;p&gt; &amp;amp;nbspC++ (Clang) w/ inlining, tuples, no C++ exceptions&lt;br/&gt;   &amp;amp;nbspf32 by-copy:  &amp;amp;nbsp10416&lt;br/&gt;   &amp;amp;nbspf32 by-borrow: 10072 &lt;span&gt;(3.30% faster)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;   &amp;amp;nbspf64 by-copy:  &amp;amp;nbsp10520&lt;br/&gt;   &amp;amp;nbspf64 by-borrow: 11335 &lt;span&gt;(7.47% slower)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;All of this code could be optimized to be better. It should be possible to get C++ and Rust to the exact same level. But that's beyond the scope of this article and answering my original question.&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 26 Aug 2019 07:24:18 +0000</pubDate>
<dc:creator>forrestthewoods</dc:creator>
<og:image>https://www.forrestthewoods.com/blog/should-small-rust-structs-be-passed-by-copy-or-by-borrow/assets/img/header.png</og:image>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.forrestthewoods.com/blog/should-small-rust-structs-be-passed-by-copy-or-by-borrow/</dc:identifier>
</item>
<item>
<title>Show HN: I made a CRM system to make sales fun</title>
<link>https://wobaka.com</link>
<guid isPermaLink="true" >https://wobaka.com</guid>
<description>[unable to retrieve full-text content]
&lt;p&gt;Article URL: &lt;a href=&quot;https://wobaka.com&quot;&gt;https://wobaka.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Comments URL: &lt;a href=&quot;https://news.ycombinator.com/item?id=20798003&quot;&gt;https://news.ycombinator.com/item?id=20798003&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Points: 248&lt;/p&gt;
&lt;p&gt;# Comments: 190&lt;/p&gt;
</description>
<pubDate>Mon, 26 Aug 2019 07:13:28 +0000</pubDate>
<dc:creator>drikerf</dc:creator>
<og:title>Wobaka</og:title>
<og:url>https://wobaka.com</og:url>
<og:description>Wobaka is the CRM system you'll actually enjoy using. Making it easier, efficient and more fun to go from outreach to closed deal.</og:description>
<og:type>article</og:type>
<og:image>https://wobaka.com/img/thumb.png</og:image>
<dc:format>text/html</dc:format>
<dc:identifier>https://wobaka.com/</dc:identifier>
</item>
<item>
<title>QEMU VM Escape</title>
<link>https://blog.bi0s.in/2019/08/24/Pwn/VM-Escape/2019-07-29-qemu-vm-escape-cve-2019-14378/</link>
<guid isPermaLink="true" >https://blog.bi0s.in/2019/08/24/Pwn/VM-Escape/2019-07-29-qemu-vm-escape-cve-2019-14378/</guid>
<description>&lt;p&gt;tl;dr&lt;/p&gt;
&lt;p&gt;This post will describe how I exploited &lt;a href=&quot;https://access.redhat.com/security/cve/cve-2019-14378&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CVE-2019-14378&lt;/a&gt;, which is a pointer miscalculation in network backend of QEMU. The bug is triggered when large IPv4 fragmented packets are reassembled for processing. It was found by code auditing.&lt;/p&gt;

&lt;h2 id=&quot;Vulnerability-Details&quot;&gt;Vulnerability Details&lt;/h2&gt;
&lt;p&gt;There are two parts to networking within QEMU:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;The virtual network device that is provided to the guest (e.g. a PCI network card).&lt;/li&gt;
&lt;li&gt;The network backend that interacts with the emulated NIC (e.g. puts packets onto the host’s network).&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;By default QEMU will create a SLiRP user network backend and an appropriate virtual network device for the guest (eg an e1000 PCI card)&lt;/p&gt;
&lt;p&gt;The bug was found in the packet reassembly in SLiRP.&lt;/p&gt;
&lt;h3 id=&quot;IP-fragmentation&quot;&gt;IP fragmentation&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;IP fragmentation is an Internet Protocol (IP) process that breaks packets into smaller pieces (fragments), so that the resulting pieces can pass through a link with a smaller maximum transmission unit (MTU) than the original packet size. The fragments are reassembled by the receiving host.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;line-numbers language-plain&quot;&gt;
&lt;code class=&quot;language-plain&quot;&gt;
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Version|  IHL  |Type of Service|          Total Length         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Identification        |Flags|      Fragment Offset    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Time to Live |    Protocol   |         Header Checksum       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Source Address                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Destination Address                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Options                    |    Padding    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;Flags&quot;&gt;Flags:&lt;/h3&gt;
&lt;p&gt;3 bits&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Bit 0: reserved, must be zero&lt;/li&gt;
&lt;li&gt;Bit 1: (DF) 0 = May Fragment, 1 = Don’t Fragment.&lt;/li&gt;
&lt;li&gt;Bit 2: (MF) 0 = Last Fragment, 1 = More Fragments.&lt;/li&gt;
&lt;li&gt;Fragment Offset: 13 bits&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;line-numbers language-c&quot;&gt;
&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; mbuf &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;/* header at beginning of each mbuf: */&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; mbuf &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;m_next&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;/* Linked list of mbufs */&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; mbuf &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;m_prev&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; mbuf &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;m_nextpkt&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;/* Next packet in queue/record */&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; mbuf &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;m_prevpkt&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;/* Flags aren't used in the output queue */&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; m_flags&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;/* Misc flags */&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; m_size&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;/* Size of mbuf, from m_dat or m_ext */&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; socket &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;m_so&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;m_data&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;/* Current location of data */&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; m_len&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;/* Amount of data in this mbuf, from m_data */&lt;/span&gt;

    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;m_ext&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;/* start of dynamic buffer area, must be last element */&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; m_dat&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;mbuf&lt;/code&gt; structure is used to store IP layer information received. There are two buffers &lt;code&gt;m_dat&lt;/code&gt; which is inside the structure and &lt;code&gt;m_ext&lt;/code&gt; is allocated on the heap if the &lt;code&gt;m_dat&lt;/code&gt; is insufficient to store the packet.&lt;/p&gt;
&lt;p&gt;For the NAT translation if the incoming packets are fragmented they should be reassembled before they are edited and re transmitted. This reassembly is done by the &lt;code&gt;ip_reass(Slirp *slirp, struct ip *ip, struct ipq *fp)&lt;/code&gt; function. &lt;code&gt;ip&lt;/code&gt; contains the current IP packet data, &lt;code&gt;fp&lt;/code&gt; is a link list containing the fragmented packets.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ip_reass does the following:
&lt;ul&gt;&lt;li&gt;If first fragment to arrive (fp==NULL), create a reassembly queue and insert &lt;code&gt;ip&lt;/code&gt; into this queue.&lt;/li&gt;
&lt;li&gt;Check if the fragment is overlapping with previous received fragments, then discard it.&lt;/li&gt;
&lt;li&gt;If all the fragmented packets are received reassemble it. Create header for new ip packet by modifying header of first packet;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;line-numbers language-c&quot;&gt;
&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;/*
 * Take incoming datagram fragment and try to
 * reassemble it into whole datagram.  If a chain for
 * reassembly of this datagram already exists, then it
 * is given as fp; otherwise have to make a chain.
 */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; ip &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;ip_reass&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Slirp &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;slirp&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; ip &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;ip&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; ipq &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;fp&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;

    &lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;/*
     * Reassembly is complete; concatenate fragments.
     */&lt;/span&gt;
    q &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; fp&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;frag_link&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    m &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;dtom&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;slirp&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; q&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    q &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; ipasfrag &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;q&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;ipf_next&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;q &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; ipasfrag &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;fp&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;frag_link&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; mbuf &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;t &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;dtom&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;slirp&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; q&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        q &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; ipasfrag &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;q&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;ipf_next&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token function&quot;&gt;m_cat&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;m&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; t&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;/*
     * Create header for new ip packet by
     * modifying header of first packet;
     * dequeue and discard fragment reassembly header.
     * Make header visible.
     */&lt;/span&gt;
    q &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; fp&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;frag_link&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;/*
     * If the fragments concatenated to an mbuf that's
     * bigger than the total size of the fragment, then and
     * m_ext buffer was alloced. But fp-&amp;gt;ipq_next points to
     * the old buffer (in the mbuf), so we must point ip
     * into the new buffer.
     */&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;m&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;m_flags &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt; M_EXT&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; delta &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;q &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; m&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;m_dat&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        q &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; ipasfrag &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;m&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;m_ext &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; delta&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;The bug is at the calculation of the variable delta. The code assumes that the first fragmented packet will not be allocated in the external buffer (m_ext). The calculation &lt;code&gt;q - m-&amp;gt;dat&lt;/code&gt; is valid when the packet data is inside &lt;code&gt;mbuf-&amp;gt;m_dat&lt;/code&gt; ( q will be inside m_dat ) ( q is structure containing link list of fragments and packet data). Otherwise if &lt;code&gt;m_ext&lt;/code&gt; buffer was allocated, then q will be inside the external buffer and the calculation of the &lt;code&gt;delta&lt;/code&gt; will be wrong.&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-c&quot;&gt;
&lt;code class=&quot;language-c&quot;&gt;slirp&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;src&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;ip_input&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;ip_reass
    ip &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fragtoip&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;q&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    ip&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;ip_len &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; next&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    ip&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;ip_tos &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    ip&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;ip_src &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; fp&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;ipq_src&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    ip&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;ip_dst &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; fp&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;ipq_dst&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Later the newly calculated pointer &lt;code&gt;q&lt;/code&gt; is converted into &lt;code&gt;ip&lt;/code&gt; structure and values are modified, Due to the wrong calculation of the delta, &lt;code&gt;ip&lt;/code&gt; will be pointing to incorrect location and &lt;code&gt;ip_src&lt;/code&gt; and &lt;code&gt;ip_dst&lt;/code&gt; can be used to write controlled data onto the calculated location. This may also crash qemu if the calculated ip is located in unmaped area.&lt;/p&gt;
&lt;h2 id=&quot;Exploitation&quot;&gt;Exploitation&lt;/h2&gt;
&lt;p&gt;What are we facing&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;If we control &lt;code&gt;delta&lt;/code&gt; we will be able to write controlled data relative to m-&amp;gt;m_ext. For that need precise control over the heap.&lt;/li&gt;
&lt;li&gt;Need leaks to bypass ASLR&lt;/li&gt;
&lt;li&gt;There are no useful function pointers on the heap to get code execution. We have to get arbitrary write.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;Controlling-Heap&quot;&gt;Controlling Heap&lt;/h3&gt;
&lt;p&gt;Let’s look into how heap objects are allocated in slirp.&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-c&quot;&gt;
&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;// How much room is in the mbuf, from m_data to the end of the mbuf&lt;/span&gt;
&lt;span class=&quot;token macro property&quot;&gt;#&lt;span class=&quot;token directive keyword&quot;&gt;define&lt;/span&gt; M_ROOM(m)                                                        \
    ((m-&amp;gt;m_flags &amp;amp; M_EXT) ? (((m)-&amp;gt;m_ext + (m)-&amp;gt;m_size) - (m)-&amp;gt;m_data) : \
                            (((m)-&amp;gt;m_dat + (m)-&amp;gt;m_size) - (m)-&amp;gt;m_data))&lt;/span&gt;
&lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;// How much free room there is&lt;/span&gt;
&lt;span class=&quot;token macro property&quot;&gt;#&lt;span class=&quot;token directive keyword&quot;&gt;define&lt;/span&gt; M_FREEROOM(m) (M_ROOM(m) - (m)-&amp;gt;m_len)&lt;/span&gt;

slirp&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;src&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;slirp&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;slirp_input

      m &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;m_get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;slirp&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;// m_get return mbuf object, internally calls g_malloc(0x668)&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
      &lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;/* Note: we add 2 to align the IP header on 4 bytes,
       * and add the margin for the tcpiphdr overhead  */&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;M_FREEROOM&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;m&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; pkt_len &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; TCPIPHDR_DELTA &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;// TCPIPHDR_DELTA + 2 = &lt;/span&gt;
          &lt;span class=&quot;token function&quot;&gt;m_inc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;m&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; pkt_len &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; TCPIPHDR_DELTA &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;// allocates new m_ext buffer since m_dat is insufficiant&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;

      &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;proto &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; ETH_P_IP&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;token function&quot;&gt;ip_input&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;m&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;m_get&lt;/code&gt;, &lt;code&gt;m_free&lt;/code&gt; , &lt;code&gt;m_inc&lt;/code&gt; and &lt;code&gt;m_cat&lt;/code&gt; are wrappers for handling dynamic memory allocation. When new packet arrives new mbuf object is allocated, and if m_dat is sufficient for storing the packet data then it is used, otherwise new external buffer is allocated with &lt;code&gt;m_inc&lt;/code&gt; and the data is copied onto it.&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-c&quot;&gt;
&lt;code class=&quot;language-c&quot;&gt;slirp&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;src&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;ip_input&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;ip_input
    &lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;/*
        * If datagram marked as having more fragments
        * or if this is not the first fragment,
        * attempt reassembly; if it succeeds, proceed.
        */&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;ip&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;ip_tos &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; ip&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;ip_off&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        ip &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;ip_reass&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;slirp&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; ip&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; fp&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;ip &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

slirp&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;src&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;ip_input&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;ip_reass
    &lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;/*
     * If first fragment to arrive, create a reassembly queue.
     */&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fp &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; mbuf &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;t &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;m_get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;slirp&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;If the incoming packet is fragmented, new &lt;code&gt;mbuf&lt;/code&gt; object is used to store the packets (fp) until all the fragments arrives. When next part arrives they are enqueued onto this list.&lt;/p&gt;
&lt;p&gt;This gives us a good primitive to allocate controlled chunks on the heap size ( &amp;gt; 0x608 ). Few things to keep in mind is that, for every packets mbuf(0x670) will be allocated and if it is the first fragment then the another mbuf will be allocated (fp : fragment queue).&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;malloc(0x670)
if(pkt_len + TCPIPHDR_DELTA + 2 &amp;gt; 0x608)
   malloc(pkt_len + TCPIPHDR_DELTA + 2)
if(ip-&amp;gt;ip_off &amp;amp; IP_MF)
   malloc(0x670)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;We can use this to spray the heap,so that the subsequent allocation will be taken from the top chunk, which gives us a predictable heap state.&lt;/p&gt;
&lt;h3 id=&quot;Getting-controlled-write-on-heap&quot;&gt;Getting controlled write on heap&lt;/h3&gt;
&lt;p&gt;Now that we can control the heap. Let’s see how we can use the bug to overwrite something useful.&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-c&quot;&gt;
&lt;code class=&quot;language-c&quot;&gt;    q &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; fp&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;frag_link&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;// Points to first fragment&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;m&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;m_flags &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt; M_EXT&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; delta &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;q &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; m&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;m_dat&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        q &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; ipasfrag &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;m&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;m_ext &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; delta&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Assume this heap state&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-c&quot;&gt;
&lt;code class=&quot;language-c&quot;&gt;            &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;
            &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;     q      &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;
            &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;
            &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;            &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;
            &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;            &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;
            &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;  padding   &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;
            &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;            &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;
            &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;            &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;
            &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;
            &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;   m&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;m_dat &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;
            &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Now &lt;code&gt;delta&lt;/code&gt; will be &lt;code&gt;-padding&lt;/code&gt; and this will be added with &lt;code&gt;m-&amp;gt;m_ext&lt;/code&gt; and later we can write to that offset. Thus controlling this padding we are able to control delta.&lt;/p&gt;
&lt;p&gt;When all the fragments arrive they are concatenated to one &lt;code&gt;mbuf&lt;/code&gt; object with &lt;code&gt;m_cat&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-c&quot;&gt;
&lt;code class=&quot;language-c&quot;&gt;slirp&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;src&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;muf&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;c
&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;m_cat&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; mbuf &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;m&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; mbuf &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;n&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;/*
     * If there's no room, realloc
     */&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;M_FREEROOM&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;m&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; n&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;m_len&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;token function&quot;&gt;m_inc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;m&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; m&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;m_len &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; n&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;m_len&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token function&quot;&gt;memcpy&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;m&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;m_data &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; m&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;m_len&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; n&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;m_data&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; n&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;m_len&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    m&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;m_len &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; n&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;m_len&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token function&quot;&gt;m_free&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;n&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;


slirp&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;src&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;muf&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;c
&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;m_inc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; mbuf &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;m&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; size&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;m&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;m_flags &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt; M_EXT&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        gapsize &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; m&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;m_data &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; m&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;m_ext&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        m&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;m_ext &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;g_realloc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;m&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;m_ext&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; size &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; gapsize&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;m_inc&lt;/code&gt; calls &lt;code&gt;realloc&lt;/code&gt; function, realloc function return the same chunk if it can accommodate the requested size. So even after the reassembly of the packets, we can get the same m-&amp;gt;m_ext buffer of the fist packet. Note, m_ext will be allocated for the first fragment packet, &lt;code&gt;q&lt;/code&gt; will be pointing inside this buffer . Then the addition of &lt;code&gt;-padding&lt;/code&gt; will also be relative to &lt;code&gt;q&lt;/code&gt;. This just makes things bit easier&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-c&quot;&gt;
&lt;code class=&quot;language-c&quot;&gt;            &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;
            &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;  target    &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;
            &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;
            &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;            &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;
            &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;            &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;
            &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;  padding   &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;
            &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;            &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;
            &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;            &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;
m&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;m_ext  &lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;  &lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;// q = m-&amp;gt;m_ext + -padding  will point to target&lt;/span&gt;
            &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;     q      &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;  &lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;// delta = -paddig &lt;/span&gt;
            &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;
            &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;            &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;
            &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;            &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;
            &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;  padding   &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;
            &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;            &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;
            &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;            &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;
            &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;
            &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;   m&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;m_dat &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;
            &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;So after the pointer calculation &lt;code&gt;q&lt;/code&gt; will be pointing to &lt;code&gt;target&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-c&quot;&gt;
&lt;code class=&quot;language-c&quot;&gt;slirp&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;src&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;ip_input&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;ip_reass
    ip &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fragtoip&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;q&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
    ip&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;ip_src &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; fp&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;ipq_src&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    ip&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;ip_dst &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; fp&lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt;ipq_dst&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;since we control &lt;code&gt;fp-&amp;gt;ipq_src&lt;/code&gt; and &lt;code&gt;fp-&amp;gt;ipq_dst&lt;/code&gt; which is the source and destination ip of the packet we can overwrite targets content.&lt;/p&gt;
&lt;h3 id=&quot;Arbitrary-Write&quot;&gt;Arbitrary Write&lt;/h3&gt;
&lt;p&gt;My initial target was to overwrite the &lt;code&gt;m_data&lt;/code&gt; field, so that we can use the packet reassembly’s &lt;code&gt;m_cat()&lt;/code&gt; to get arbitrary write, but that seems to be not possible due to some alignment and offsets issues.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;slirp/src/muf.c:m_cat
    memcpy(m-&amp;gt;m_data + m-&amp;gt;m_len, n-&amp;gt;m_data, n-&amp;gt;m_len);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;But was able to overwrite &lt;code&gt;m_len&lt;/code&gt; field of the object. Since there is no check in the &lt;code&gt;m_cat&lt;/code&gt; function we can use the &lt;code&gt;m_len&lt;/code&gt; to get arbitrary write relative to &lt;code&gt;m_data&lt;/code&gt;. So now we do not have the issue of alignment and we use this to overwrite the &lt;code&gt;m_data&lt;/code&gt; of different object to get arbitrary write.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Send packet with id &lt;code&gt;0xdead&lt;/code&gt; and MF bit set (1)&lt;/li&gt;
&lt;li&gt;Send packet with id &lt;code&gt;0xcafe&lt;/code&gt; and MF bit set (1)&lt;/li&gt;
&lt;li&gt;Trigger the bug to overwrite m_len of &lt;code&gt;0xcafe&lt;/code&gt; so that m_data + m_len points to &lt;code&gt;0xdead&lt;/code&gt;‘s m_data&lt;/li&gt;
&lt;li&gt;Send packet with id &lt;code&gt;0xcafe&lt;/code&gt; and MF bit unset (0) to trigger reassembly and overwrite &lt;code&gt;0xdead&lt;/code&gt;‘s m_data with target address&lt;/li&gt;
&lt;li&gt;Send packet with id &lt;code&gt;0xdead&lt;/code&gt; and MF bit unset (0) which will write the content of this packet to m_data.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;Getting-Leaks&quot;&gt;Getting Leaks&lt;/h3&gt;
&lt;p&gt;We need leaks to bypass ASLR and PIE. For that we need some way to transfer data back to the guest . It turns out that there is a very common service that matches that description exactly: ICMP echo request. SLiRP gateway responds to a ICMP echo requests, reflecting back the payload of the packet (after the ICMP headers) unchanged.&lt;/p&gt;
&lt;p&gt;We have arbitrary write, but where will we write to since leaks are not known at this point ?&lt;/p&gt;
&lt;p&gt;We can do a partial overwrite of the &lt;code&gt;m_data&lt;/code&gt; and write data on the heap.&lt;/p&gt;
&lt;p&gt;Leaks :&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Use arbitrary write to create fake ICMP header on the heap&lt;/li&gt;
&lt;li&gt;Send an ICMP request with the MF bit set (1).&lt;/li&gt;
&lt;li&gt;Partially Overwrite &lt;code&gt;m_data&lt;/code&gt; to point to fake header on heap&lt;/li&gt;
&lt;li&gt;Send the packet with MF bit to 0 to end the ICMP request.&lt;/li&gt;
&lt;li&gt;Receive leaks from the host.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;Getting-Code-Execution&quot;&gt;Getting Code Execution&lt;/h3&gt;
&lt;p&gt;Timers (more precisely QEMUTimers) provide a means of calling a given routine (a callback) after a time interval has elapsed, passing an opaque pointer to the routine.&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-c&quot;&gt;
&lt;code class=&quot;language-c&quot;&gt;
&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; QEMUTimer &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    int64_t expire_time&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;        &lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;/* in nanoseconds */&lt;/span&gt;
    QEMUTimerList &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;timer_list&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    QEMUTimerCB &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;cb&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;opaque&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    QEMUTimer &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;next&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; scale&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; QEMUTimerList &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    QEMUClock &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;clock&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    QemuMutex active_timers_lock&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    QEMUTimer &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;active_timers&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;QLIST_ENTRY&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;QEMUTimerList&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; list&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    QEMUTimerListNotifyCB &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;notify_cb&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;notify_opaque&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    QemuEvent timers_done_ev&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;main_loop_tlg is a array in bss which contains &lt;code&gt;QEMUTimerList&lt;/code&gt; associated with different timer. And these contains list of &lt;code&gt;QEMUTimer&lt;/code&gt; structures. qemu loops through these to check whether there any of them have expired, If so, &lt;code&gt;cb&lt;/code&gt; function is called with argument &lt;code&gt;opaque&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;RIP control :&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Create fake QEMUTimer with callback as system and opaque as the argument&lt;/li&gt;
&lt;li&gt;Create fake QEMUTImerList which contains our fake QEMUTimer&lt;/li&gt;
&lt;li&gt;Overwrite main_loop_tlg entry with fake QEMUTimerList&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;You can find the full exploit at &lt;a href=&quot;https://github.com/vishnudevtj/exploits/tree/master/qemu/CVE-2019-14378&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CVE-2019-14378&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 25 Aug 2019 23:49:46 +0000</pubDate>
<dc:creator>ngaut</dc:creator>
<dc:format>text/html</dc:format>
<dc:identifier>https://blog.bi0s.in/2019/08/24/Pwn/VM-Escape/2019-07-29-qemu-vm-escape-cve-2019-14378/</dc:identifier>
</item>
<item>
<title>Major book publishers sue Amazon’s Audible over new speech-to-text feature</title>
<link>https://www.theverge.com/2019/8/23/20830057/amazon-audible-speech-to-text-feature-lawsuit-major-book-publishers</link>
<guid isPermaLink="true" >https://www.theverge.com/2019/8/23/20830057/amazon-audible-speech-to-text-feature-lawsuit-major-book-publishers</guid>
<description>&lt;p id=&quot;q3OqUe&quot;&gt;Some of the world’s largest book publishers have jointly filed a lawsuit against Amazon-owned audiobook company Audible today over a new, controversial speech-to-text feature the literary industry claims is a violation of copyright law.&lt;/p&gt;
&lt;p id=&quot;u60Bsx&quot;&gt;The &lt;a href=&quot;https://www.docdroid.net/em69IaO/chronicle-books-v-audible.pdf&quot;&gt;lawsuit&lt;/a&gt;, filed in the Southern District Court of New York, includes the Big Five: Hachette, HarperCollins, Macmillan, Penguin Random House, and Simon &amp;amp; Schuster. It also includes San Francisco-based publisher Chronicle Books and Scholastic, the major children’s publisher that owns publishing rights to &lt;em&gt;Harry Potter&lt;/em&gt; and &lt;em&gt;The Hunger Games&lt;/em&gt;. All seven plaintiffs are members of the Association of American Publishers.&lt;/p&gt;
&lt;div class=&quot;c-float-right&quot;&gt;
&lt;aside id=&quot;7R2TDC&quot;&gt;&lt;q&gt;“Audible’s actions are the kind of quintessential infringement that the Copyright Act directly forbids.”&lt;/q&gt;&lt;/aside&gt;&lt;/div&gt;
&lt;p id=&quot;69QwtO&quot;&gt;Publishers are &lt;a href=&quot;https://www.theverge.com/2019/7/19/20698383/audible-captions-feature-audiobook-book-publishers-rights&quot;&gt;taking issue with Audible’s new Captions feature&lt;/a&gt;, first unveiled last month and set to go live in September through partnerships with US public schools. The feature uses machine learning to transcribe spoken words into written ones, so users can read along while they listen to an audiobook. The issue, however, is that Audible is doing this based on audiobook recordings, which have separate licenses to physical books and ebooks. The company is not apparently obtaining the necessary licenses to reproduce the written versions of these works.&lt;/p&gt;
&lt;p id=&quot;WCxZ9u&quot;&gt;Because Audible is relying on artificial intelligence, it appears the company is trying to claim a distinction between a newly created piece of text composed using AI, based on an audio recording, and the potentially near-identical text version of the book the audiobook was created from. (As evidence that the text is generated on the fly, Amazon says its transcriptions may contain errors and are not intended to be complete recereations of the text version of a book.) At the time of its launch, Audible CEO Don Katz positioned Captions as an educational feature designed for schools, &lt;a href=&quot;https://www.usatoday.com/story/tech/talkingtech/2019/07/15/audible-let-you-read-audiobook-youre-listening/1503387001/?utm_source=feedblitz&amp;amp;utm_medium=FeedBlitzRss&amp;amp;utm_campaign=usatoday-techtopstories&quot;&gt;telling &lt;em&gt;USA Today&lt;/em&gt;&lt;/a&gt;, “We know from years and years of work, that parents and educators, in particular, understand that an audio experience of well-composed words is really important in developing learners.”&lt;/p&gt;
&lt;p id=&quot;QJk3LY&quot;&gt;“Audible’s actions — taking copyrighted works and repurposing them for its own benefit without permission — are the kind of quintessential infringement that the Copyright Act directly forbids,” the complaint reads. “If Audible is not enjoined, Audible will take for itself a format of digital distribution it is not authorized to provide, devalue the market for cross-format products, and harm Publishers, authors, and the consumers who enjoy and rely on books.”&lt;/p&gt;
&lt;p id=&quot;49P8vQ&quot;&gt;In a statement given to &lt;em&gt;The Verge&lt;/em&gt;, Audible defended the development of Captions as an educational feature designed to help young kids and improve literacy, saying “it is not and was never intended to be a book.” An Audible spokesperson also pointed to an &lt;a href=&quot;https://www.audible.com/about/newsroom/audible-captions-a-demonstration/&quot;&gt;explanation of the Captions feature and an attached FAQ penned by Katz&lt;/a&gt; in late July, which details the differences between Captions and a proper ebook and the limitations posed on listeners. One key difference, Audible says, is not being able to flip through pages, as users must wait for each line of text to be progressively generated as they’re listening. Here is Audible’s statement in full:&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p id=&quot;4Hfiiw&quot;&gt;We are surprised and disappointed by this action and any implication that we have not been speaking and working with publishers about this feature, which has not yet launched. Captions was developed because we, like so many leading educators and parents, want to help kids who are not reading engage more through listening. This feature would allow such listeners to follow along with a few lines of machine-generated text as they listen to the audio performance. It is not and was never intended to be a book. We disagree with the claims that this violates any rights and look forward to working with publishers and members of the professional creative community to help them better understand the educational and accessibility benefits of this innovation.”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p id=&quot;zI4cJ6&quot;&gt;At the heart of the case will be a determination on the transformative nature of an AI-created audio transcription, and whether that constitutes a violation of the copyrights held on a written work.&lt;/p&gt;
&lt;p id=&quot;cBDKWD&quot;&gt;“This is one of many lawsuits that will help define the future of intellectual property rights in the digital age. It raises major questions over what impact artificial intelligence, when it interacts with copyrighted material, will have on intellectual property rights,” Sam P. Israel, a copyright attorney and founder of Sam P. Israel P.C., told &lt;em&gt;The Verge&lt;/em&gt; over email. “Ultimately, unauthorized reproductions of copyrighted material, even when done unwittingly through the assistance of AI, will likely not pass muster in the courts.”&lt;/p&gt;
&lt;p id=&quot;fnOSGC&quot;&gt;The case happens to have a strong analog to a former Amazon publishing controversy a decade ago, when the company tried to launch a text-to-speech feature for its Kindle platform that would effectively do what Amazon Captions does today, but in reverse.&lt;/p&gt;
&lt;p id=&quot;uVmVK7&quot;&gt;Publishers at the time were enraged, accusing Amazon of trying to trample on the nascent audiobook market and the licensing rights that publishers believed would help it become a thriving business. Amazon eventually caved in that regard, &lt;a href=&quot;https://www.theguardian.com/technology/blog/2009/mar/01/authors-guild-blocks-kindle-voice&quot;&gt;allowing publishers to disable the Kindle text-to-speech feature&lt;/a&gt; after a massive outcry from the US Authors Guild.&lt;/p&gt;
&lt;div class=&quot;c-float-left&quot;&gt;
&lt;aside id=&quot;eHhT2z&quot;&gt;&lt;q&gt;“There is a simple English word to describe this: and that is theft.”&lt;/q&gt;&lt;/aside&gt;&lt;/div&gt;
&lt;p id=&quot;TKfT8L&quot;&gt;Publishers and the Authors Guild have been putting up a similar fight for the last month. After the feature was announced, the Authors Guild released a statement saying “existing ACX and Audible agreements do not grant Audible the right to create text versions of audio books.” The group said the feature “appears to be outright, willful copyright infringement, and it will inevitably lead to fewer ebook sales and lower royalties for authors for both their traditionally published and self-published books.”&lt;/p&gt;
&lt;p id=&quot;XjcD97&quot;&gt;Audible has been mostly quiet about the matter, &lt;a href=&quot;https://www.theverge.com/2019/7/19/20698383/audible-captions-feature-audiobook-book-publishers-rights&quot;&gt;telling &lt;em&gt;The Verge&lt;/em&gt; last month&lt;/a&gt; that it did “not agree with this interpretation” from the Authors Guild, but the company formally declined to comment further. Audible also refused to comment about whether it would work with publishers on establishing some form of licensing that would allow the Audible Captions feature to exist while also fairly compensating rights holders.&lt;/p&gt;
&lt;p id=&quot;oY9r3q&quot;&gt;In a new statement, the Authors Guild &lt;a href=&quot;https://www.authorsguild.org/industry-advocacy/authors-guild-issues-statement-supporting-aaps-lawsuit-against-audible/&quot;&gt;expressed support for the lawsuit&lt;/a&gt;. “Without authorization and in violation of its contracts with publishers, Audible added a text feature to its audiobooks. Text and audio are different book markets, and Audible is licensed only for audio,” writes Mary Rasenberger, the executive director of the Authors Guild.” It has chosen to use its market power to force publishers’ hands by proceeding without permission in clear violation of copyright in the titles.”&lt;/p&gt;
&lt;p id=&quot;hab4Lr&quot;&gt;In an interesting twist, some of the books for which Audible has added Captions support are written by Authors Guild President Doug Preston, who was not pleased. “My contract is crystal clear that the only rights conveyed to Audible are for voice recording and playback. The rights to reproduce text in any way are specifically withheld,” Preston said in a statement. “I can’t believe that Audible has so little respect for authors, contractual promises, and copyright that it thinks it can just help itself to rights it doesn’t have, by fiat. There is a simple English word to describe this: and that is theft.”&lt;/p&gt;
&lt;p id=&quot;aP93X2&quot;&gt;&lt;em&gt;&lt;strong&gt;Update August 23rd, 2:40PM ET:&lt;/strong&gt;&lt;/em&gt; &lt;em&gt;Added statements from the Authors Guild.&lt;/em&gt;&lt;/p&gt;
&lt;p id=&quot;TABUPQ&quot;&gt;&lt;em&gt;&lt;strong&gt;Update August 23rd, 5:33PM ET:&lt;/strong&gt;&lt;/em&gt; &lt;em&gt;Added statement from Audible.&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 25 Aug 2019 23:45:54 +0000</pubDate>
<dc:creator>bookofjoe</dc:creator>
<og:description>Publishers say it is a ‘quintessential’ violation of copyright law</og:description>
<og:image>https://cdn.vox-cdn.com/thumbor/79KVbj_lU7-gnUtOZBqkBcIZltk=/0x146:2040x1214/fit-in/1200x630/cdn.vox-cdn.com/uploads/chorus_asset/file/18322066/acastro_190719_1777_audible_0001.0.jpg</og:image>
<og:title>Major book publishers sue Amazon’s Audible over new speech-to-text feature</og:title>
<og:type>article</og:type>
<og:url>https://www.theverge.com/2019/8/23/20830057/amazon-audible-speech-to-text-feature-lawsuit-major-book-publishers</og:url>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.theverge.com/2019/8/23/20830057/amazon-audible-speech-to-text-feature-lawsuit-major-book-publishers</dc:identifier>
</item>
<item>
<title>Zen 2 Missives – AMD now delivering efficiencies that are double that of Intel</title>
<link>http://apollo.backplane.com/2019-Zen2Missive.html</link>
<guid isPermaLink="true" >http://apollo.backplane.com/2019-Zen2Missive.html</guid>
<description>&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;&lt;title&gt;Zen 2 Missives&lt;/title&gt;&lt;/head&gt;&lt;body id=&quot;readabilityBody&quot; readability=&quot;112.5&quot;&gt;
&lt;center&gt;
&lt;h2&gt;&lt;strong&gt;Zen 2 Missives - 2019&lt;/strong&gt;&lt;/h2&gt;
&lt;/center&gt;
&lt;center&gt;
&lt;h2&gt;&lt;strong&gt;Matthew Dillon&lt;/strong&gt;&lt;/h2&gt;
&lt;/center&gt;
&lt;h2&gt;&lt;strong&gt;(I) The Socket Didn't Have to Change&lt;/strong&gt;&lt;/h2&gt;
&lt;div readability=&quot;49&quot;&gt;
&lt;p&gt;After languishing through the CPU dark-ages (read: Intel trying real hard to keep people on 4 cores so they could charge an arm and a leg for more), the last two years has seen a vertible tsunami of advances in CPU technologies. AMD's introduction of an 8-core CPU (the 1700X) began the rat-race and with both AMD and Intel now pushing high-core-count CPUs, the big winners here are us! The consumer, the power user, the programmer, the technically-oriented enthusiast. All of us are the winners of this new race.&lt;/p&gt;
&lt;p&gt;But all is not equal. The situation developing now is primarily related to power distribution and power consumption. Intel got caught with their pants down on multiple fronts... they got stuck on their 14nm node and could only produce minor improvements in power efficiency. And they also got stuck on a socket with power delivery capabilities a bit lower than they would have liked. This puts Intel in the unenviable situation of having to compete against AMD by introducing a higher core-count CPU (a 10-core) without a commesurate improvement in power efficiency, forcing a new socket and motherboard upgrade on the Intel world. Intel is taking power consumption way beyond what most people are actually going to be willing to push into their machines. It's a doubly-whammy with Intel on the losing-end.&lt;/p&gt;
&lt;p&gt;AMD thought ahead. Their AM4 socket can handle tons more power. More importantly, AMD is now delivering, on 7nm, performance efficiencies that are nearly double that of Intel. This means that AMD not only does not have to change their socket, but their new CPUs will run just fine on just about ANY AM4 motherboard introduced in the last three years without even breaking a sweat. AMD is not going to have to impose a new socket until something major changes in the memory subsystem, such as a new memory standard that is incompatible with the DDR4 DIMM socket. Notice I didn't say electrical, I said socket. Because the CPU is more or less directly wired to the DIMM slots.&lt;/p&gt;
&lt;p&gt;It is a common misconception that getting the most out of one of these new Zen 2 CPUs requires a high-end X570 motherboard, with beefier, higher-end VRMs and other beefy features. But as it turns out, this is not actually true. The reason is that power efficiency actually keeps even the high-end 3900X (and later the 3950X) within the power envelope that older motherboards (B350 and B450 mobos) can deliver. In the case of the B450, with room to spare. A 3900X gets 95% of its performance with just 110W in the socket and even low-end B450 motherboards can put 150W into the socket. Low-end B350 motherboards can put at least 100W in the socket, which is close enough.&lt;/p&gt;
&lt;p&gt;Did I mention that you can just pop into the BIOS and set the power cap for the socket to whatever you want? Poor airflow? Old motherboard? It doesn't matter. Well, sure, it does matter, just not as much as people seem to think.&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;(II) The Physics has Changed with These Smaller Nodes&lt;/strong&gt;&lt;/h2&gt;
&lt;div readability=&quot;65&quot;&gt;
&lt;p&gt;When you compare the TSMC 7nm node AMD's Zen 2 CPUs are currently on with Intel's 14nm+++(many pluses) node you will notice some major differences in how the physics of the node works. Intel's 14nm node is relatively temperature-agnostic. When you overclock a 9900K you can take temps right up to the limit, continuing to push more power into the socket to get those high frequencies. Zen 2 on 7nm doesn't work this way. On 7nm, temperature has a direct correlation with frequency. And so on a Zen 2 system if you increase the voltage to push frequency you also wind up increasing the temperature which retards the maximum possible stable frequency. In otherwords, you can't just push power into a Zen 2 cpu to get the overclocks you want. It doesn't work.&lt;/p&gt;
&lt;p&gt;On a Zen 2 system the key to overclocking is lower temps, NOT higher power. Well, if you want to run the bleeding edge and you hit a hard stop on temps then sure, you can push more power into the socket (as long as you keep those temps hard-stopped), but this level of overkill just doesn't net a whole lot more in the performance department. Strangely enough this means that you don't actually need those beefy X570 motherboards with 10+ phases to get a decent overclock, you just need a good cooler. I'll bet a lot of people will start seriously thinking about going sub-ambient as well (at least down to +5C, since going negative has severe condensation issues). But for the rest of us mere mortals, a decent tower air cooler gets us almost as much overclock as a good water loop.&lt;/p&gt;
&lt;p&gt;When I say good what I mean is that if you really want to overclock you can easily get to 4.2 on air without pushing massive amounts of power. The absolute best overclock you will ever get on Zen 2 at non-destructive voltages (1.3V VCORE, approximately) will be around 4.4 GHz, all-cores. Higher than that and it won't be stable or you will have to push too much voltage. The difference between 4.2 and 4.4 is only 5%. For most of us, 5% isn't worth the massive investment in time, effort, and cooling. Overclocking Zen 2 is easy... you just leave it at stock settings and maybe bump up the socket power envelope a little, run XMP on your memory, and you are done, and you get it on any motherboard, even the cheap ones.&lt;/p&gt;
&lt;p&gt;A second major differences in the physics of the TSMC 7nm node verses Intel's 14nm is the single-core boost. Whereas you can push more volts into a 9900K (almost) regardless of how many cores are loaded, the smaller 7nm node cannot. High current all-cores boosts require a lower voltage to avoid destroying the chip due to electron momentum, whereas a low current single-core boost allows a higher voltage (up to 1.45V).&lt;/p&gt;
&lt;p&gt;So while Intel overclockers can always look for ways to push more power into the socket (at least on 14nm+++*), AMD overclocks wind up between a rock and a hard place fairly quickly with ambient cooling. Heat matters. The physics are just different. This isn't a bad thing, by the way. It means that very high performance systems can be built more cheaply.&lt;/p&gt;
&lt;p&gt;Intel will be in the same boat soon enough, because this difference in physics seems to be a side effect of getting smaller. Intel's 10nm node is rumored to be limited to 4.1 GHz or so. And later on we may see even more limitations on clocks. The only way to really scale from here on will be with IPC and by adding cores.&lt;/p&gt;
&lt;p&gt;Nobody is interesting in pushing 200W into their socket, which puts Intel at a dead-end on 14nm. They may try to push more cores on 14nm, but the power consumption makes it non-competitive. Remember that.&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;(III) Power Density, Caches, and IPC&lt;/strong&gt;&lt;/h2&gt;
&lt;div readability=&quot;33&quot;&gt;
&lt;p&gt;As nodes get smaller, power density increases. Radically. That is, the smaller size of the chips more then compensates for the improved power efficiency. From an absolute performance point of view we do get that power efficiency. But from a power-density point of view we do not. The transistors are packed more tightly. The power density is heading up and not down.&lt;/p&gt;
&lt;p&gt;Higher power densities mean higher temperature gradiants going from the transistors to the socket to the cooling solution. &lt;strong&gt;No amount of cooling can completely compensate for this gradient.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Only lower frequencies can help here, and much larger caches. Why the larger caches? Because CPU caches have relatively low power densities. They take up chip real-estate but actually improve the overall power density problem. So every new architecture from here forwards is going to have much larger CPU caches. We've seen this with Zen 2 where each CPU chiplet (8 cores) sports 32MB of L3 cache. This means that the 3900X and the 3950X both have 64MB of L3 cache. A 64-core TR3 or EPYC will have 256MB of L3 cache.&lt;/p&gt;
&lt;p&gt;Up until now, Intel has always sported small caches on their consumer chips. They dribble out 6MB here, 8MB there, and they reserve the large caches for their expensive Xeon behemoths... its a really poor showing by Intel, frankly. Increasing IPC requires increasing the CPU cache sizes, and possibly even adding an even larger L4 cache to the die. This is no longer a knob that Intel can shirk on, not with AMD putting 64MB of L3 into its high-end consumer chips with Zen 2. As already indicatd, increasing cache size is one of the most important ways a CPU can scale IPC up.&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;(IV) I/O Infrastructure and Bandwidth in the New World&lt;/strong&gt;&lt;/h2&gt;
&lt;div readability=&quot;26&quot;&gt;
&lt;p&gt;Forget PCIe-v4, or v5, or v6... well, no. Don't forget about them, they are important. Just not quite as important as people are probably thinking. The most important aspect of AMD's X570 chipset is not the PCIe-v4 support it has going into the PCIe connectors, it's the 4-lanes of (effectively) infinity-fabric (basically a rejiggered PCIe-v4) going from the CPU to the chipset. And it is the 20 lanes of PCIe-v4 heading out of the CPU just waiting to be fed into expanders.&lt;/p&gt;
&lt;p&gt;Why? Because very few PCIe cards actually need PCIe-v4's bandwidth. Even the fancy new PCIe-v4 M.2 SSDs... its already overkill. What is important here is the land expansion that is possible, not pushing 5GBytes/sec from a single device.&lt;/p&gt;
&lt;p&gt;Paired with this vast new I/O capability is M.2 and U.2, embodying a wonderful new chipset standard called NVMe that Intel couldn't intentionally hamstring like they did AHCI and SATA (in order to favor SAS). This plus SSDs could spell doom for consumer-vs-commercial separation of the SSD markets. For a SSD the only thing that matters in terms of market separation is its endurance... and endurance is a lot harder to gimick than an interface standard. Rejoice folks! The age of incredible I/O bandwidth has arrived and we are already being overwhelmed by it!&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;(V) Intel Will Catch-up, Consumers Will Still Win&lt;/strong&gt;&lt;/h2&gt;
&lt;div readability=&quot;27&quot;&gt;
&lt;p&gt;Don't get me wrong, Intel will catch up. Eventually. But the days of Intel's domination of the CPU are over. TSMC is not being bankrolled by AMD, they are being bankrolled by the likes of Apple, Google, and others. Samsung and TSMC both have a lot to lose if they get behind. Domination of the fabrication node is a monopoly that Intel has definitely lost.&lt;/p&gt;
&lt;p&gt;This means that from here on out the CPU race between AMD and Intel is going to remain relatively neck and neck. That is my belief anyhow. Intel is quickly losing its monopoly (it will still take half a decade for commercial market shares to equalize)... we are going to wind up with a 50-50 split.&lt;/p&gt;
&lt;p&gt;I would like to say that ARM is there waiting in the wings but... it really isn't. The fab has become equal, but CPU design is still in the realm of the gods. It is a long, iterative process, and the ARM architecture (even the 64-bit arch) is still way behind in many respects. ARM is relevant, but I wouldn't worry about a third wheel inserting itself in the AMD-Intel competition any time soon.&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;</description>
<pubDate>Sun, 25 Aug 2019 19:46:16 +0000</pubDate>
<dc:creator>olvy0</dc:creator>
<dc:format>text/html</dc:format>
<dc:identifier>http://apollo.backplane.com/2019-Zen2Missive.html</dc:identifier>
</item>
</channel>
</rss>