<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed43.com%2Fmathalg-jtks.xml&amp;max=5&amp;links=preserve&amp;exc=1" />
<atom:link rel="alternate" title="Source URL" href="http://feed43.com/mathalg-jtks.xml" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed43.com%252Fmathalg-jtks.xml%26max%3D5%26links%3Dpreserve%26exc%3D1&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed43.com%252Fmathalg-jtks.xml%26max%3D5%26links%3Dpreserve%26exc%3D1" />
<title>算法与数学之美</title>
<link>http://www.jintiankansha.me/column/c9dZ5TM2aS</link>
<description>算法与数学之美 - 今天看啥</description>
<ttl>360</ttl>
<item>
<title>〖数学算法〗开平方的七种算法</title>
<link>http://www.jintiankansha.me/t/yeGtcH60sd</link>
<guid isPermaLink="true" >http://www.jintiankansha.me/t/yeGtcH60sd</guid>
<description>&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.0609375&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_gif/951TjTgiabkyibhvGLgaqX9NkLdhIcdPwR25icvKqfV9L0leq4zoIuDGk5MVNXKRO7bZg9KgWg9ozC6icfRIWtSQKg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;sqrt()函数，是绝大部分语言支持的常用函数，它实现的是开方运算；开方运算最早是在我国魏晋时数学家刘徽所著的《九章算术》被提及。今天写了几个函数加上国外大神的几个神级程序带大家领略sqrt的神奇之处。&lt;/span&gt;&lt;/p&gt;

&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot; readability=&quot;1&quot;&gt;&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.古人算法（暴力法）  &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;原理：从0开始0.00001,000002...一个一个试，直到找到x的平方根，代码如下：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;public class APIsqrt {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;static double baoliSqrt(double x) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;final double _JINGDU = 1e-6;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;double i;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;for (i = 0; Math.abs(x - i * i) &amp;gt; _JINGDU; i += _JINGDU)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;return i;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;public static void main(String[] args) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;double x = 3;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;double root = baoliSqrt(x);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;System.out.println(root);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;测试结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.7320509999476947&lt;/span&gt;&lt;/p&gt;

&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.牛顿迭代法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;计算机科班出身的童鞋可能首先会想到的是《数值分析》中的牛顿迭代法求平方根。原理是：随意选一个数比如说8，要求根号3，我们可以这么算：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;(8 + 3/8) = 4.1875&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;(4.1875 + 3/4.1875) = 2.4519&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;(2.4519 + 3/2.4519) = 1.837&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;(1.837 + 3/1.837) = 1.735&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;做了4步基本算出了近似值了，这种迭代的方式就是传说中的牛顿迭代法了，代码如下：&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;public class APIsqrt {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;static double newtonSqrt(double x) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;if (x &amp;lt; 0) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;System.out.println(&quot;负数没事开什么方&quot;);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;return -1;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;if (x == 0)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;return 0;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;double _avg = x;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;double last_avg = Double.MAX_VALUE;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;final double _JINGDU = 1e-6;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;p&gt;&lt;span&gt;while (Math.abs(_avg - last_avg) &amp;gt; _JINGDU) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;last_avg = _avg;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;_avg = (_avg + x / _avg) / 2;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;return _avg;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;public static void main(String[] args) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;double x = 3;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;double root = newtonSqrt(x);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;System.out.println(root);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;测试结果：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1.7320508075688772&lt;/span&gt;&lt;/p&gt;


&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.暴力-牛顿综合法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;原理：还是以根号3为例，先用暴力法讲根号3逼近到1.7，然后再利用上述的牛顿迭代法。虽然没有用牛顿迭代好，但是也为我们提供一种思路。代码如下：&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;public class APIsqrt {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;static double baoliAndNewTonSqrt(double x) {&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;if (x &amp;lt; 0) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;System.out.println(&quot;负数没事开什么方&quot;);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;return -1;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;if (x == 0)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;return 0;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;double i = 0;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;double _avg;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;double last_avg = Double.MAX_VALUE;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;for (i = 0; i*i &amp;lt; x; i += 0.1);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;_avg = i;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;final double _JINGDU = 1e-6;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;while (Math.abs(_avg - last_avg) &amp;gt; _JINGDU) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;last_avg = _avg;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;_avg = (_avg + x / _avg) / 2;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;return _avg;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;public static void main(String[] args) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;double x = 3;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;double root = baoliAndNewTonSqrt(x);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;System.out.println(root);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;测试结果：&lt;/span&gt;&lt;/p&gt;

&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;p&gt;&lt;span&gt;1.7320508075689423&lt;/span&gt;&lt;/p&gt;



&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.二分开方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;原理：还是以3举例：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;(0+3)/2 = 1.5, 1.5^2 = 2.25, 2.25 &amp;lt; 3;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;(1.5+3)/2 = 2.25, 2.25^2 = 5.0625, 5.0625 &amp;gt; 3;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;(1.5+2.25)/2 = 1.875, 1.875^2 = 3.515625; 3.515625&amp;gt;3;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;直到前后两次平均值只差小于自定义精度为止，代码如下：&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;public class APIsqrt {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;static double erfenSqrt(double x) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;if (x &amp;lt; 0) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;System.out.println(&quot;负数没事开什么方&quot;);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;return -1;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;if (x == 0)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;return 0;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;final double _JINGDU = 1e-6;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;double _low = 0;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;double _high = x;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;double _mid = Double.MAX_VALUE;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;double last_mid = Double.MIN_VALUE;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;while (Math.abs(_mid - last_mid) &amp;gt; _JINGDU) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;last_mid = _mid;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;_mid = (_low + _high) / 2;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;if (_mid * _mid &amp;gt; x)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;_high = _mid;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;if (_mid * _mid &amp;lt; x)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;_low = _mid;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;return _mid;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;public static void main(String[] args) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;double x = 3;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;double root = erfenSqrt(x);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;System.out.println(root);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;测试结果：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1.732051134109497&lt;/span&gt;&lt;/p&gt;



&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot; readability=&quot;1&quot;&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;section readability=&quot;2&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.计算 (int)(sqrt(x))算法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;PS:此算法非博主所写&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原理：空间换时间，细节请大家自行探究，代码如下：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;public class APIsqrt2 {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;final static int[] table = { 0, 16, 22, 27, 32, 35, 39, 42, 45, 48, 50, 53,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;55, 57, 59, 61, 64, 65, 67, 69, 71, 73, 75, 76, 78, 80, 81, 83, 84,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;86, 87, 89, 90, 91, 93, 94, 96, 97, 98, 99, 101, 102, 103, 104,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;106, 107, 108, 109, 110, 112, 113, 114, 115, 116, 117, 118, 119,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;120, 121, 122, 123, 124, 125, 126, 128, 128, 129, 130, 131, 132,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 144,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;145, 146, 147, 148, 149, 150, 150, 151, 152, 153, 154, 155, 155,&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 06 Oct 2019 01:03:25 +0000</pubDate>
<dc:language>zh-CN</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.jintiankansha.me/t/yeGtcH60sd</dc:identifier>
</item>
<item>
<title>天天骑共享单车，是不是应该认识认识她</title>
<link>http://www.jintiankansha.me/t/wrYP9UXzQS</link>
<guid isPermaLink="true" >http://www.jintiankansha.me/t/wrYP9UXzQS</guid>
<description>&lt;div id=&quot;img-content&quot; class=&quot;paper rich_media_area_primary &quot; readability=&quot;4.76&quot;&gt;

                        

                        
                            
&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;&gt;&lt;/ins&gt;
&lt;p&gt;
                &lt;h2 class=&quot;common_share_title&quot;&gt;
                                        &lt;span id=&quot;video_title&quot;&gt;天天骑共享单车，是不是应该认识认识她&lt;/span&gt;
                &lt;/h2&gt;
                            &lt;/p&gt;
                        

                        &lt;br /&gt;&lt;/div&gt;

                    &lt;div class=&quot;post-meta&quot;&gt;
                        &lt;div class=&quot;&quot;&gt;
                            &lt;p&gt;分享到&lt;/p&gt;
                            &lt;a target=&quot;_blank&quot; href=&quot;http://service.weibo.com/share/share.php?url=http%3A%2F%2Fwww.jintiankansha.me%2Ft%2FwrYP9UXzQS&amp;amp;appkey=2206014828&amp;amp;pic=&amp;amp;title=%E5%A4%A9%E5%A4%A9%E9%AA%91%E5%85%B1%E4%BA%AB%E5%8D%95%E8%BD%A6%EF%BC%8C%E6%98%AF%E4%B8%8D%E6%98%AF%E5%BA%94%E8%AF%A5%E8%AE%A4%E8%AF%86%E8%AE%A4%E8%AF%86%E5%A5%B9+%40%E4%BB%8A%E5%A4%A9%E7%9C%8B%E5%95%A5&quot;&gt;
                                &lt;img width=&quot;30px&quot; src=&quot;http://www.jintiankansha.me/static/img/site/weibo.svg?v=fa758ebd6691cf5931bbbed63230327b&quot; /&gt;&lt;/a&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;

                    
                    
                </description>
<pubDate>Sun, 06 Oct 2019 01:03:22 +0000</pubDate>
<dc:language>zh-CN</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.jintiankansha.me/t/wrYP9UXzQS</dc:identifier>
</item>
</channel>
</rss>